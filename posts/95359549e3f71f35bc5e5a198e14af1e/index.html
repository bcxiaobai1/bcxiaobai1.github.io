<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【中山大学编译原理课程】SYsU-lang实验攻略 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【中山大学编译原理课程】SYsU-lang实验攻略</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-dracula">
                    
                        
                    
                    <blockquote> 
 <p>实验项目链接：https://github.com/arcsysu/SYsU-lang</p> 
</blockquote> 
<p>实现一个C语言的编译器很难吗？其实未必！依我个人的观点，编译器的代码并没有什么特别复杂的算法，理解起来不会很困难，但是它的工作量着实不小。古语有言：<strong>“庖丁解牛”</strong>，完成这些工作量的关键是要把握它内部的结构和脉络，如果没有一个合理的程序架构，那么这些工作量就会不断发酵，最终耗尽你的精力和耐心。</p> 
<p>这篇攻略不会过多地关注工具的使用细节，而是重在阐述代码设计和编写的最佳实践，帮助你产出正确、美观、易维护的代码完成这项实验。攻略主要针对实验2，但正像你即将看到的，其中的内容对实验1和实验3也会有所帮助。</p> 
<p></p> 
<div class="toc"> 
 <h3>全文目录</h3> 
 <ul>
<li><a href="#_8">设计抽象语义表示</a></li>
<li>
<ul>
<li><a href="#_58">使用所有权管理器</a></li>
<li><a href="#_116">语法解析树、抽象语法树、抽象语义图的对比</a></li>
</ul> 
  </li>
<li><a href="#FlexBison_230">Flex和Bison的使用范式</a></li>
<li>
<ul>
<li><a href="#FlexBison_240">Flex和Bison的联合使用</a></li>
<li><a href="#unionn_312">使用`%union`和`$n`定义和访问语义值</a></li>
<li><a href="#_398">一些其它的提示</a></li>
</ul> 
  </li>
<li><a href="#VisitorASG_440">使用Visitor模式遍历ASG</a></li>
<li>
<ul><li><a href="#_514">错误处理</a></li></ul> 
  </li>
<li><a href="#_526">代码的整体架构</a></li>
<li>
<ul>
<li><a href="#2_528">实验2</a></li>
<li><a href="#3_555">实验3</a></li>
<li><a href="#_569">完整的编译器</a></li>
</ul> 
  </li>
<li><a href="#_575">关于文法规则的提示</a></li>
<li>
<ul>
<li><a href="#_579">保留字和标识符</a></li>
<li><a href="#_585">表达式优先级和结合性</a></li>
<li><a href="#C_607">C的类型表达式语法</a></li>
<li><a href="#ifelse_638">if-else移入归约冲突</a></li>
</ul> 
 </li>
</ul> 
</div> 
<p></p> 
<h1>
<a id="_8"></a>设计抽象语义表示</h1> 
<blockquote> 
 <p>这一节是整个攻略最重要的内容。</p> 
</blockquote> 
<p>在实验1我们使用Flex编写了一个词法分析器，它输入字符串形式的源代码然后将解析到的词法单元按行打印出来，这是一个比较简单的任务，也不需要写太多的代码，很多同学就全写在一个Flex文件中就搞定了。实验2的内容是从实验1输出的词法单元流中识别出语法结构，然后把结构用JSON打印出来，同学们最容易犯的一个设计错误就是以为这里和之前一样，把发射JSON语法树的代码直接就塞到Bison的语法定义文件中——事实上，实验2的复杂程度要高得多，所以这最终会导致一堆乱糟糟的代码和看不到尽头的调试过程。</p> 
<p>这里的最佳实践是：**引入一个表达抽象语义的、方便编程操作的中间数据结构，Bison解析器首先将输入的词法单元流转换到这个数据结构，然后再将这个数据结构转换到JSON打印出来以满足实验要求。**实际上这个中间数据结构就是一种程序的中间表示形式（Intermediate Representation, IR），现代编译器通常会使用多层中间表示，在不同的中间表示上执行变换操作。从编程的角度来说，其实编译器设计的主要内容并不在于算法，而是数据结构，有了合理的数据结构，很多时候算法是显而易见的。</p> 
<p>程序的抽象语义通常使用图，而不足以使用树来表示，因此我们称之为<a href="https://en.wikipedia.org/wiki/Abstract_semantic_graph">抽象语义图（Abstract Semantic Graph, ASG）</a>。文法中经常会出现形如“<code>表达式 -&gt; 整数字面量 | 变量引用 | 二元运算</code>”的选择结构和“<code>加法 -&gt; 表达式 ("+" | "-" | "*" | "/") 表达式</code>”的递归结构，一些高级编程语言（比如OCaml）支持联合类型和递归类型，可以很好地表达它们，虽然C/C++中没有这些特性，但我们可以使用结构体和指针实现等价的效果：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Obj</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Decl</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Obj</span></span> <span class="token punctuation">{<!-- --></span>	<span class="token comment">// 表达一个符号声明（变量、参数等）</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>	<span class="token comment">// 符号名</span>
    Type type<span class="token punctuation">;</span>  		<span class="token comment">// 符号类型（这里省略了 struct Type 的定义）</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Expr</span> ： <span class="token keyword">public</span> Obj <span class="token punctuation">{<!-- --></span>
    Type type<span class="token punctuation">;</span>			<span class="token comment">// C语言的每个表达式都有类型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">IntegerLiteral</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Expr</span></span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span><span class="token keyword">int64_t</span> val<span class="token punctuation">;</span>	<span class="token comment">// 整数字面量的值</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">DeclRefExpr</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Expr</span></span> <span class="token punctuation">{<!-- --></span>
    Decl<span class="token operator">*</span> decl<span class="token punctuation">;</span>			<span class="token comment">// 指向引用的声明</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">BinaryExpr</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Expr</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span> kAdd<span class="token punctuation">,</span> kSub<span class="token punctuation">,</span> kMul<span class="token punctuation">,</span> kDiv <span class="token punctuation">}</span> op<span class="token punctuation">;</span>		<span class="token comment">// 操作符</span>
    Expr <span class="token operator">*</span>lft<span class="token punctuation">,</span> <span class="token operator">*</span>rht<span class="token punctuation">;</span>						<span class="token comment">// 指向左右操作数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>相信你一看到上面的代码，就能感觉到它确实高度精炼地表达了语言中真正有意义的那部分，而且正如前面提到的，这些结构体也非常容易编程操作。在你设计好ASG之后，这些结构体的定义不光可以用于完成实验2，也会成为在实验3中发射LLVM IR的起点，如果设计得当，在ASG的这一层IR上，你就已经可以很方便地实现常量传播、公共子表达式消除等许多优化算法了。</p> 
<p>上面的代码中有两点需要重点注意：</p> 
<ul>
<li> <p>所有类型都继承（直接或间接）自<code>Obj</code>类型，且<code>Obj</code>的析构函数为虚；</p> <p>这样我们就可以用一个统一的类型<code>Obj*</code>来引用所有类型的语义结构，而令析构函数为虚是为了让所有的类型都具备运行时类型识别（RTTI）的能力以分辨出具体的结点类型（通过<code>dynamic_cast</code>），以及用于对象的管理和回收。</p> </li>
<li> <p>可以引入一些中间子类（如<code>Expr</code>），从而利用继承机制来更精确地表达选择结构。</p> <p>可以提供一些静态类型检查的辅助，这不是必须的，如果没有这些中间子类，那么对其它结点的引用可以都使用<code>Obj*</code>的指针，但这就不能防止我们把一个<code>Decl*</code>赋值给<code>BinaryExpr</code>的<code>lft</code>和<code>rht</code>，虽然可以通过RTTI识别出错误，但实际上这种情况基本不会发射，因此这种灵活性其实是多余的。</p> </li>
</ul> 
<h2>
<a id="_58"></a>使用所有权管理器</h2> 
<p>指针在这里给了我们无与伦比的灵活性，这种灵活性可以大大减少之后的代码量，但是也给我们带来了一个问题：内存泄漏。从完成实验的角度，你完全可以<code>new</code>完不<code>delete</code>它，这并不会影响你通过测试样例，但这并不意味着我们应该放任这个问题的发生。</p> 
<p>也许你在这里会去尝试使用<code>std::unique_ptr</code>或<code>std::shared_ptr</code>来管理<code>Obj</code>的生命周期，然而这不是一个有效的做法，因为就像之前说的，程序的语义通常要用图来表达，而不是简单树，因此几乎必然存在循环引用的问题（比如函数的递归调用），这时也许你又想到可以使用<code>std::weak_ptr</code>破除循环引用——然而这注定是一次没有结果的探索，这些花哨的智能指针并不适合这个场景，在这里最原始的指针就是最好用的。</p> 
<p>最佳实践是：**使用一个单独的管理器接管所有对象的所有权，当我们在堆上创建任何对象时，使用资源获取即初始化（RAII）将指针交给管理器，然后让管理器析构时释放其管理的所有对象。**我们只需要保证管理器的生命周期比所有管理的对象都长，就可以避免指针悬挂。</p> 
<p>我们可以非常容易地使用<code>std::unique_ptr</code>和<code>std::vector</code>实现一个最基本的管理器：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Mgr</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">vector</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span><span class="token class-name">unique_ptr</span><span class="token operator">&lt;</span><span class="token class-name">Obj</span><span class="token operator">&gt;&gt;</span></span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Mgr gMgr<span class="token punctuation">;</span> <span class="token comment">// 全局的管理器对象</span>
</code></pre> 
<p>在上面的代码中，我出于简单起见直接创建了一个全局的管理器对象用于本次实验，这样可以它就可以获得最长的生命周期（尽管这样已经和内存泄漏没有什么区别了）。然后我们在创建每个对象时，只需要注意在<code>new</code>的时候将返回指针加入<code>gMgr</code>就行了：</p> 
<pre><code class="prism language-cpp">Decl<span class="token operator">*</span> <span class="token function">compile_decl</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> decl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Decl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    gMgr<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>decl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">return</span> decl<span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
</code></pre> 
<p>每次申请对象都要写两行代码显得非常啰嗦，我们可以给<code>Mgr</code>添加一个<code>make</code>方法封装RAII操作：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Mgr</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">vector</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span><span class="token class-name">unique_ptr</span><span class="token operator">&lt;</span><span class="token class-name">Obj</span><span class="token operator">&gt;&gt;</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// 第三个参数用于静态检查参数是否正确，也可以省略。</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
           <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token punctuation">,</span>
           <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_constructible_v<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>
  T<span class="token operator">*</span> <span class="token function">make</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> obj <span class="token operator">=</span> ptr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">emplace_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>然后再创建对象时只要一个简洁的函数调用就能搞定了：</p> 
<pre><code class="prism language-cpp">Decl<span class="token operator">*</span> <span class="token function">compile_decl</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> decl <span class="token operator">=</span> gMgr<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">make</span><span class="token generic class-name"><span class="token operator">&lt;</span>Decl<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">return</span> decl<span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
</code></pre> 
<p>这种模式目前并没有一个公认的名称，不过我个人喜欢叫它“<a href="https://www.cnblogs.com/gaochundong/p/design_pattern_manager.html">管理器模式</a>”。如果你愿意，你甚至可以在此基础上多写一些代码进一步实现<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">标记清扫垃圾回收</a>，以在后续的处理过程中提前清理掉那些没有被引用的对象——不过这并不会为你在本实验中增加任何得分。</p> 
<h2>
<a id="_116"></a>语法解析树、抽象语法树、抽象语义图的对比</h2> 
<p>在学习了这么多编译原理的课程知识后，相信你已经了解了“语法解析树”和“抽象语法树”的概念，这里我们把它们进行对比一下，使用的例子是一个很短的全局变量声明：<code>int a[2] = {0, 1}, *b = a + 1;</code>。</p> 
<ul>
<li> <p>语法解析树（Parse Tree）</p> <p>语法解析树包含语法解析过程中的所有非终结符号和终结符号，一个递归下降语法分析器的运行过程可以视为是对语法解析树的深度优先遍历。语法解析树通常是非常复杂和庞大的，因此一般并不会真的生成出来，例如上面的例子如果真的生成一个语法解析树，那他可能是这个样子：</p> 
  <div class="mermaid sequence-diagram"> 
    
    #mermaid-svg-CuQAoWnbJV5LT8Gt {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-CuQAoWnbJV5LT8Gt .error-icon{fill:#552222;}#mermaid-svg-CuQAoWnbJV5LT8Gt .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-CuQAoWnbJV5LT8Gt .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-CuQAoWnbJV5LT8Gt .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-CuQAoWnbJV5LT8Gt .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-CuQAoWnbJV5LT8Gt .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-CuQAoWnbJV5LT8Gt .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-CuQAoWnbJV5LT8Gt .marker{fill:#333333;stroke:#333333;}#mermaid-svg-CuQAoWnbJV5LT8Gt .marker.cross{stroke:#333333;}#mermaid-svg-CuQAoWnbJV5LT8Gt svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-CuQAoWnbJV5LT8Gt .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-svg-CuQAoWnbJV5LT8Gt .cluster-label text{fill:#333;}#mermaid-svg-CuQAoWnbJV5LT8Gt .cluster-label span{color:#333;}#mermaid-svg-CuQAoWnbJV5LT8Gt .label text,#mermaid-svg-CuQAoWnbJV5LT8Gt span{fill:#333;color:#333;}#mermaid-svg-CuQAoWnbJV5LT8Gt .node rect,#mermaid-svg-CuQAoWnbJV5LT8Gt .node circle,#mermaid-svg-CuQAoWnbJV5LT8Gt .node ellipse,#mermaid-svg-CuQAoWnbJV5LT8Gt .node polygon,#mermaid-svg-CuQAoWnbJV5LT8Gt .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-CuQAoWnbJV5LT8Gt .node .label{text-align:center;}#mermaid-svg-CuQAoWnbJV5LT8Gt .node.clickable{cursor:pointer;}#mermaid-svg-CuQAoWnbJV5LT8Gt .arrowheadPath{fill:#333333;}#mermaid-svg-CuQAoWnbJV5LT8Gt .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-CuQAoWnbJV5LT8Gt .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-CuQAoWnbJV5LT8Gt .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-svg-CuQAoWnbJV5LT8Gt .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-svg-CuQAoWnbJV5LT8Gt .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-CuQAoWnbJV5LT8Gt .cluster text{fill:#333;}#mermaid-svg-CuQAoWnbJV5LT8Gt .cluster span{color:#333;}#mermaid-svg-CuQAoWnbJV5LT8Gt div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-CuQAoWnbJV5LT8Gt :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;} 
     
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
       
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
       
       
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
       
       
        
         
         
          
          <div> 
           <span class="nodeLabel">declaration_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">typeSpecifier_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initDeclaratorList_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'int'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initDeclarator_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">','</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initDeclaratorList_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">declarator_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'='</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initializer_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initDeclarator_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">ε</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">directDeclarator_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'{'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initializerList_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'}'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">declarator_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'='</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initializer_4</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">directDeclarator_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'['</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">expression_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">']'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initializer_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">','</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initializerList_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">*</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">directDeclarator_3</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">expression_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'a'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">expression_3</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initializer_3</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">ε</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'b'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">additiveExpression_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'2'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">expression_4</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">expression_5</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'+'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">expression_6</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'0'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral_3</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'a'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral_4</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'1'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'1'</span> 
          </div> 
          
         
        
       
      
     
    
  </div> <p>希望这张图能够让你感受到语法解析树的复杂和庞大。而实际上，上图其实已经简化了表达式相关语法规则（虚线表示），后面为我们会看到，因为运算符优先级的存在，每个表达式结点实际上都会产生出一个长长的分支链。</p> </li>
<li> <p>抽象语法树（Abstract Syntax Tree）</p> <p>抽象语法树通过去掉了那些只起到结构标识作用的结点、压缩树的层级等方式大大简化了语法解析树的结构。上面的例子对应的抽象语法树可能是：</p> 
  <div class="mermaid sequence-diagram"> 
    
    #mermaid-svg-b0HgqwwhXdosDJr3 {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-b0HgqwwhXdosDJr3 .error-icon{fill:#552222;}#mermaid-svg-b0HgqwwhXdosDJr3 .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-b0HgqwwhXdosDJr3 .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-b0HgqwwhXdosDJr3 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-b0HgqwwhXdosDJr3 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-b0HgqwwhXdosDJr3 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-b0HgqwwhXdosDJr3 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-b0HgqwwhXdosDJr3 .marker{fill:#333333;stroke:#333333;}#mermaid-svg-b0HgqwwhXdosDJr3 .marker.cross{stroke:#333333;}#mermaid-svg-b0HgqwwhXdosDJr3 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-b0HgqwwhXdosDJr3 .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-svg-b0HgqwwhXdosDJr3 .cluster-label text{fill:#333;}#mermaid-svg-b0HgqwwhXdosDJr3 .cluster-label span{color:#333;}#mermaid-svg-b0HgqwwhXdosDJr3 .label text,#mermaid-svg-b0HgqwwhXdosDJr3 span{fill:#333;color:#333;}#mermaid-svg-b0HgqwwhXdosDJr3 .node rect,#mermaid-svg-b0HgqwwhXdosDJr3 .node circle,#mermaid-svg-b0HgqwwhXdosDJr3 .node ellipse,#mermaid-svg-b0HgqwwhXdosDJr3 .node polygon,#mermaid-svg-b0HgqwwhXdosDJr3 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-b0HgqwwhXdosDJr3 .node .label{text-align:center;}#mermaid-svg-b0HgqwwhXdosDJr3 .node.clickable{cursor:pointer;}#mermaid-svg-b0HgqwwhXdosDJr3 .arrowheadPath{fill:#333333;}#mermaid-svg-b0HgqwwhXdosDJr3 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-b0HgqwwhXdosDJr3 .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-b0HgqwwhXdosDJr3 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-svg-b0HgqwwhXdosDJr3 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-svg-b0HgqwwhXdosDJr3 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-b0HgqwwhXdosDJr3 .cluster text{fill:#333;}#mermaid-svg-b0HgqwwhXdosDJr3 .cluster span{color:#333;}#mermaid-svg-b0HgqwwhXdosDJr3 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-b0HgqwwhXdosDJr3 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;} 
     
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
       
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
       
       
        
         
          
          <div> 
           <span class="edgeLabel">.typeSpecifier</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.initDeclaratorList[0]</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.initDeclaratorList[1]</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.declarator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.initializer</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.declarator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.initializer</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.declarator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.size</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">[0]</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">[1]</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.declarator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.left</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.operator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.right</span> 
          </div> 
          
         
        
       
       
        
         
         
          
          <div> 
           <span class="nodeLabel">declaration_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">int</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initDeclarator_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initDeclarator_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">arrayDeclarator</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initializerList_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">pointerDeclarator</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">binaryExpressin_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">Identifier<br>'a'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral<br>2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral<br>1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral<br>2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">Identifier<br>'b'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">Identifier<br>'a'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">+</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral<br>1</span> 
          </div> 
          
         
        
       
      
     
    
  </div> <p>很显然AST比语法解析树简单得多，如果你用过<a href="https://www.antlr.org/">ANTLR</a>、<a href="https://www.boost.org/doc/libs/1_81_0/libs/spirit/doc/html/index.html">Boost.Spirit</a>等语法解析器框架的话，就会知道这种语法解析器的输出结果往往都是这种形式。</p> </li>
<li> <p>抽象语义图（Abstract Semantic Graph）</p> <p>单论名字的用法而言，大家并不是那么严格地区分“ASG”和“AST”，很多人把他的IR数据结构称为AST，尽管这些数据结构的引用关系在事实上是图而并非树。不过，相比于那些语法解析器框架，我们上面定义的C++结构体们与之还是有很大差别的，这主要体现在语义结点的相互引用上：</p> 
  <div class="mermaid sequence-diagram"> 
    
    #mermaid-svg-MlSojBZmjrRGpH6O {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-MlSojBZmjrRGpH6O .error-icon{fill:#552222;}#mermaid-svg-MlSojBZmjrRGpH6O .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-MlSojBZmjrRGpH6O .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-MlSojBZmjrRGpH6O .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-MlSojBZmjrRGpH6O .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-MlSojBZmjrRGpH6O .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-MlSojBZmjrRGpH6O .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-MlSojBZmjrRGpH6O .marker{fill:#333333;stroke:#333333;}#mermaid-svg-MlSojBZmjrRGpH6O .marker.cross{stroke:#333333;}#mermaid-svg-MlSojBZmjrRGpH6O svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-MlSojBZmjrRGpH6O .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-svg-MlSojBZmjrRGpH6O .cluster-label text{fill:#333;}#mermaid-svg-MlSojBZmjrRGpH6O .cluster-label span{color:#333;}#mermaid-svg-MlSojBZmjrRGpH6O .label text,#mermaid-svg-MlSojBZmjrRGpH6O span{fill:#333;color:#333;}#mermaid-svg-MlSojBZmjrRGpH6O .node rect,#mermaid-svg-MlSojBZmjrRGpH6O .node circle,#mermaid-svg-MlSojBZmjrRGpH6O .node ellipse,#mermaid-svg-MlSojBZmjrRGpH6O .node polygon,#mermaid-svg-MlSojBZmjrRGpH6O .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-MlSojBZmjrRGpH6O .node .label{text-align:center;}#mermaid-svg-MlSojBZmjrRGpH6O .node.clickable{cursor:pointer;}#mermaid-svg-MlSojBZmjrRGpH6O .arrowheadPath{fill:#333333;}#mermaid-svg-MlSojBZmjrRGpH6O .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-MlSojBZmjrRGpH6O .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-MlSojBZmjrRGpH6O .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-svg-MlSojBZmjrRGpH6O .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-svg-MlSojBZmjrRGpH6O .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-MlSojBZmjrRGpH6O .cluster text{fill:#333;}#mermaid-svg-MlSojBZmjrRGpH6O .cluster span{color:#333;}#mermaid-svg-MlSojBZmjrRGpH6O div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-MlSojBZmjrRGpH6O :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;} 
     
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
       
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
       
       
        
         
          
          <div> 
           <span class="edgeLabel">[0]</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">[1]</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.name</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.typeSpec</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.declarator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.initializer</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.name</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.typeSpec</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.declarator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.initializer</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.declarator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.size</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">[0]</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">[1]</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.declarator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.left</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.operator</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.right</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
       
       
        
         
         
          
          <div> 
           <span class="nodeLabel">declarations</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">declaration_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">declaration_2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'a'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">int</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">arrayDeclarator_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">initializerList_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'b'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">int</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">pointerDeclarator</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">binaryExpressin_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel"></span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral<br>2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral<br>1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral<br>2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel"></span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">declReference_1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">+</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">integerLiteral<br>1</span> 
          </div> 
          
         
        
       
      
     
    
  </div> <p>相比于AST中存储的是变量名，我们在<code>declReference_1</code>中直接存储指向变量声明的那个语义结点指针，这将会给后面的分析和变换的代码编写带来极大的便利。</p> </li>
</ul> 
<h1>
<a id="FlexBison_230"></a>Flex和Bison的使用范式</h1> 
<p>Flex和Bison是实验框架默认的解析器生成工具，接下来我会介绍使用它们的最佳实践，由于Flex比较简单，主要是介绍Bison。</p> 
<p>首先要明白的一点是，Flex和Bison的代码不是C和C++源代码，严格地说它们是专用于生成词法解析器和语法解析器的领域特定语言（DSL），一般的静态代码分析器通常不能很好地在上面工作，你的IDE也不能很好地助力你编写这些代码，因此最佳实践是：<strong>除非必要，否则尽可能不要将代码写在<code>.l</code>和<code>.y</code>文件里，让这两个文件保持尽可能地简单，除了生成词法和语法解析器外，不要有多余的功能。</strong></p> 
<p>Flex和Bison的代码文件在整体结构上都是被两个<code>%%</code>分成了三个部分：前言、主体、后记。理想情况下，后记完全可以留白，而前言中除了包含头文件指令不要写任何其它C/C++代码，所以，将你原本写在前言的C/C++代码都分离到两个另外的<code>.h(.hpp)</code>和<code>.c(.cpp)</code>文件中。如果你非要将代码<code>.l</code>和<code>.y</code>文件中，你应该在前言区只写函数和全局变量的声明，然后将定义写在后记中。</p> 
<p>其次要明白的是，Flex和Bison是两个历史非常久远的工具了，许多现代的编程范式在其上都不适用，而且它们的用法是生成C代码，而不是C++，只是在后来逐步扩充了对其它功能的支持。所以，就本实验而言，<strong>如果你不想陷入对Flex和Bison琐碎的配置选项和技术细节的纠缠中，那么就应该小心地编写代码，尽量不要超出经典用法的场景。</strong></p> 
<h2>
<a id="FlexBison_240"></a>Flex和Bison的联合使用</h2> 
<p>Flex和Bison生成的代码分处于两个C源代码文件，它们各自单独编译，然后通过外部链接机制最终链接为一个整体。</p> 
<p>Flex和Bison默认用法的场景是传统的命令行指令式程序，生成使用全局变量的不可重入代码，并且Flex固定地从<code>&lt;stdio.h&gt;</code>输入输出数据。两者的关系以Bison为主，Flex只是辅助的可选项：Bison从代码文件生成一个<code>int yyparse();</code>函数，其内部调用两个需要我们补充定义的函数<code>int yylex();</code>、<code>void yyerror(const char *)</code>来读取词法单元流和报告错误，Flex就是用于生成那个<code>yylex</code>函数。</p> 
<p>在联合使用时，我们应该首先编写Bison语法定义（<code>.y</code>），通过前言区的<code>%token</code>定义有哪几种词法单元，然后在Flex代码中包含生成的头文件，再编写词法单元的解析规则，这和我们实验1到实验2的顺序是相反的。知道这些之后，我们就得到了基本的文件骨架：</p> 
<ul>
<li> <p><strong><code>parser.y</code></strong></p> <pre><code>%code requires {
int yylex();
void yyerror(const char *);
}
%%
%%
</code></pre> <p>为了让Bison生成的代码能够通过编译环节，必须在其中加入<code>yylex</code>和<code>yyerror</code>的声明。</p> 
  <blockquote> 
   <p>此处可以使用<code>%{ ... %}</code>代替<code>%code requires { ... }</code>，它们的区别是后者的代码会输出到头文件中，而前者只是输出到源文件中，因此<code>%code requires</code>更合适，详见<a href="https://www.gnu.org/software/bison/manual/html_node/Prologue-Alternatives.html">Bison文档</a>。</p> 
  </blockquote> </li>
<li> <p><strong><code>lexer.l</code></strong></p> <pre><code>%{
#include "parser.tab.h"
%}
%%
%%
</code></pre> <p>其中头文件名<code>"parser.tab.h"</code>是Bison的默认名字，你应该填你实际指定的文件名。这样生成的词法解析器代码默认会调用一个外部定义函数<code>yywrap</code>，如果你没定义就会导致链接通不过，对于本实验而言这个函数是没用的，因此实验1中的模板代码在前言区加入了一行<code>%option noyywrap</code>。</p> </li>
</ul> 
<p>这里是一个最小的具体例子，用于解析正负数字：</p> 
<ul>
<li> <p><strong><code>parser.y</code></strong></p> <pre><code>%code top {
int yylex (void);
void yyerror (char const *);
}

%token NUMBER
%token ADD
%token SUB

%%
start: NUMBER | ADD NUMBER | SUB NUMBER;
%%
</code></pre> </li>
<li> <p><strong><code>lexer.l</code></strong></p> <pre><code>%{
#include "parser.tab.h"
%}

%option noyywrap

%%
[0-9]+	{ return NUMBER; }
"+"		{ return ADD; }
"-"		{ return SUB; }
%%
</code></pre> </li>
</ul> 
<blockquote> 
 <p>为了更好地展示Flex和Bison的联合使用，这里是我写的一个计算加减乘除表达式的具体例子：https://github.com/yhgu2000/flex-bison-calc-example</p> 
</blockquote> 
<h2>
<a id="unionn_312"></a>使用<code>%union</code>和<code>$n</code>定义和访问语义值</h2> 
<p>你已经在理论课上了解到，每个语法解析树的结点都会和一些“属性”关联起来，不同结点有哪些属性一般都是不一样的，反映到代码里就是不同非终结符和终结符的语义值类型是不一样的，比如一个整数字面量可能对应一个<code>int</code>，而一个字符串字面量可能对应一个<code>char*</code>，所以总的而言文法符号的语义类型是这些类型的“或”，也就是一个联合类型，对应C中的联合体<code>union</code>。但是，使用联合体是十分容易出错的，Bison考虑到了这一点，所以它提供了<code>%union</code>和<code>$n</code>机制代替我们直接编写和操作联合体。</p> 
<p>在前言区，使用<code>%union</code>定义所有可能的语义值类型，然后在<code>%nterm</code>和<code>%token</code>中将文法符号和类型关联起来：</p> 
<pre><code>%union {
  int num;
  char* str;
}

%nterm &lt;str&gt; start
%token &lt;num&gt; NUMBER
%token &lt;str&gt; STRING
</code></pre> 
<p>然后在主体部分直接使用<code>$n</code>就可以操作文法符号对应的语义值：</p> 
<pre><code>start: NUMBER STRING { $$ = $2 + $1; } ;
</code></pre> 
<p>其中<code>$$</code>、<code>$1</code>、<code>$2</code>会被Bison自动拓展为类似于<code>start.str</code>、<code>NUMBER.num</code>、<code>STRING.str</code>的联合体成员引用，并且Bison会帮我们检查类型的使用是否正确。语义值最终的来源是词法解析器，在<code>yylex</code>函数（flex主体部分）中，使用全局变量<code>yylval</code>填入词法单元的语义值，不过这里就需要我们手动引用成员了：</p> 
<pre><code>[0-9]+ {
  yylval.num = atol(yytext);
  return NUMBER;
}

[a-zA-Z]+ {
  char* str = malloc(strlen(yytext));
  strcpy(str, yytext);
  yylval.str = str;
  return STRING;
}
</code></pre> 
<p>如果有一些文法符号没有语义值（比如C语句的分号），那么<code>%nterm</code>和<code>%token</code>的类型标注<code>&lt;...&gt;</code>可以省略。</p> 
<p>前面我说过，Flex和Bison原先设计是生成C代码，可是我们的实验却假定同学们使用的是C++，所以在这里使用<code>%union</code>时需要特别注意，其所有成员必须是<a href="https://zh.cppreference.com/w/cpp/named_req/PODType">简旧数据类型（POD）</a>，如果你不知道什么是POD，简单地说就是不能有构造函数和析构函数，所以你不能在<code>%union</code>里使用<code>std::string</code>这样的C++类。</p> 
<blockquote> 
 <p>事实上你可以在C++的联合体中使用非POD，只是同时需要补充构造函数和析构函数的定义，而为此你又需要了解许多C++类和内存管理的底层细节。</p> 
</blockquote> 
<p><strong>如果你按照我前一节中的内容设计你的ASG，那么在这里就不是问题，因为前一节中就是直接使用指针引用ASG结构体的，而ASG结构体中是可以使用非POD的成员变量的</strong>，使用一个全局的管理器（<code>gMgr</code>），你就可以在Bison代码里创建这些ASG结构体，像这样：</p> 
<pre><code>/* ... */

%code requires {
#include "asg.hpp"	// 为了%union中使用ASG结构体类型
}

%union {
	Obj* obj;
	Decl* decl;
	Expr* expr;
}

%nterm &lt;expr&gt; expression
%token &lt;expr&gt; 
/* ... other nterms */

%token &lt;expr&gt; NUMBER
%token        ADD
/* ... other tokens */

%%
expression: NUMBER | binaryOp ;

binaryOp:
	expression ADD expression {
		auto p = gMgr.make&lt;BinaryOp&gt;();
		p-&gt;op = BinaryOp::kAdd;
		p-&gt;lft = $1, p-&gt;rht = $3;
		$$ = p;
	}
;

/* ... other rules */
%%
</code></pre> 
<p>我向你保证这种模式完全足以完成整个实验，但是如果你非要用一些非POD的语义值类型，Bison也提供了一个<a href="https://www.gnu.org/software/bison/manual/html_node/C_002b_002b-Variants.html">Variant类型支持</a>，这时就不能再用<code>%union</code>了，取而代之的是要在导言区写上一行<code>%define api.value.type variant</code>，然后在<code>%nterm</code>和<code>%token</code>的尖括号里直接写类型名（而非<code>%union</code>成员），具体的细节请直接阅读文档，这里不再赘述。</p> 
<h2>
<a id="_398"></a>一些其它的提示</h2> 
<ul>
<li> <p>如何获取解析结果</p> <p>解析结果存储在根产生式结点对应的联合体对象中，我们可以引入一个全局变量和一个顶级产生式来向<code>yyparse</code>的调用者返回这个对象：</p> <pre><code>%code requires {
#include "asg.hpp"
extern Obj* gRoot;
}

%union {
	Obj* obj;
	Decl* decl;
	Expr* expr;
}

/* ... */

%%
start: expression {	gRoot = $1; };
expression: NUMBER | binaryOp ;

/* ... */
%%
</code></pre> </li>
<li> <p>生成可重入的解析器</p> <p>实际项目中经常要求代码的可重入性，而以上所说的Flex和Bison使用方式生成的是不可重入的代码。举例来说，因为生成的代码中使用了全局变量，所以如果使用多线程同时解析多个输入文件就会出现并发安全问题，通常会引发未定义行为。</p> <p>针对这种情况，Bison提供了两种方案，第一种是给<code>yyparse</code>等函数添加额外的参数，这主要用于C语言代码，第二种用于C++，是将代码放到一个类中以实现可重入性，Flex也是这样。但是这种情况下将Flex和Bison联合使用就不再是那么简单了，就像之前所说的，这两种超出经典的用法都会带来一些新的问题，就本实验而言，为这些问题耗费心思不会给你带来任何的收益，所以这里不再展开介绍。</p> <p>相关文档：</p> 
  <ul>
<li> <p>https://www.gnu.org/software/bison/manual/html_node/Pure-Calling.html</p> </li>
<li> <p>https://www.gnu.org/software/bison/manual/html_node/C_002b_002b-Parser-Interface.html</p> </li>
<li> <p>http://westes.github.io/flex/manual/Extra-Data.html#Extra-Data</p> </li>
</ul> </li>
</ul> 
<h1>
<a id="VisitorASG_440"></a>使用Visitor模式遍历ASG</h1> 
<p>现在你已经设计好你的ASG了，也知道如何从文本中解析出ASG了，距离实验2的目标只差把你得到的ASG打印输出为JSON了，这一步该怎么做呢？一些对C++有所了解的人可能会想当然地使用虚函数和动态转发机制，他们写出的代码类似这样：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Obj</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> json<span class="token double-colon punctuation">::</span>value <span class="token function">to_json</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Decl</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Obj</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">virtual</span> json<span class="token double-colon punctuation">::</span>value <span class="token function">to_json</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">Expr</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Obj</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">virtual</span> json<span class="token double-colon punctuation">::</span>value <span class="token function">to_json</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* ... */</span>
</code></pre> 
<p>然而这种写法在这里是一个常见的设计错误，想象一下，如果我们还要把ASG打印为XML、YAML、TOML等其它格式，或者是接下来在实验3中发射LLVM IR，那么我们是不是就要在ASG的类定义中加入一堆毫不相干的成员？这显然违背了“高内聚”的设计原则，而事实上也确实会导致杂乱和难以维护的代码，所以，最佳实践是：<strong>将每种遍历操作的代码从ASG的定义中分离出来，保持ASG代码的简洁，如果将这些分离出的代码放到一个类中，那么这就是Visitor模式。</strong></p> 
<p>常见的Visitor类写法是重载类的调用成员函数<code>operator()()</code>，以上面代码为例，提取出的<code>ToJson</code>类大概像这个样子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ToJson</span> <span class="token punctuation">{<!-- --></span>
	json<span class="token double-colon punctuation">::</span>value <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Decl<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	json<span class="token double-colon punctuation">::</span>object <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Expr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _counter<span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中可以看到Visitor模式的优点：</p> 
<ul>
<li>对于不同的数据类型可以有不同的函数签名；</li>
<li>遍历过程中使用的额外数据和变量只会在存在于遍历过程中，而不是一直存储在ASG类上。</li>
</ul> 
<p>对于“<code>表达式 -&gt; 整数字面量 | 变量引用 | 二元运算</code>”这样的选择结构，在对应的遍历方法中使用<code>dynamic_cast</code>：</p> 
<pre><code class="prism language-cpp">json<span class="token double-colon punctuation">::</span>value <span class="token class-name">ToJson</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Expr<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>IntegerLiteral<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>DeclRefExpr<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>BinaryOp<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在编译器这个场景，有些时候允许遍历器在结点中存储一些数据会更方便或者更高效，一个最简单做法是在<code>Obj</code>类中加上一个空类型的指针：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Obj</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span><span class="token operator">*</span> _any<span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>然后在遍历器的代码中，将这个指针<code>reinterpret_cast</code>到所知的类型。或者也可以使用<code>std::any</code>以确保类型安全：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Obj</span> <span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>any _any<span class="token punctuation">;</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2>
<a id="_514"></a>错误处理</h2> 
<p>如果在运行中发现错误（比如<code>dynamic_cast</code>失败），我们的代码应该如何处理？常见的回答有以下几种模式：</p> 
<ol>
<li>假定不会出错，出错是未定义行为；</li>
<li>可能出错的函数返回一个错误码（通常是<code>int</code>类型）；</li>
<li>使用一个全局的错误码变量（例如标准库的<code>errno</code>）；</li>
<li>抛出C++异常；</li>
<li>返回一个<code>Result&lt;T,E&gt;</code>或者<code>Optional&lt;T&gt;</code>对象。</li>
</ol> 
<p>可能你会不假思索地使用方式4，没错，抛出异常的确是符合C++编程风格的错误处理方式，但我需要提醒你的是，这个实验不考察你的错误处理，它的所有测试用例都是正确的、要求能通过编译的，并且在可见的将来也不会加入对错误处理的考察。也就是说，你在错误处理上花费的心血不会为你多加一分，所以这里你可以直接使用方式1，不过你应该给所有的意外情况都加上<code>assert(false);</code>或者<code>abort();</code>，这是为了在调试时及时发现实现上的错误，防止程序在出错时跑飞掉。</p> 
<h1>
<a id="_526"></a>代码的整体架构</h1> 
<h2>
<a id="2_528"></a>实验2</h2> 
<p><img src="https://images2.imgbox.com/68/c6/BScar1ea_o.png" alt="请添加图片描述"><br> 如果你遵照本篇攻略的指示，那么你最终得到的代码架构大概和上图差不多，图中的实线框表示直接手写的文件，虚线框表示生成的文件，实线箭头表示文件的包含引用关系，虚线箭头表示文件的生成关系。其中<code>lexer.l</code>和<code>parser.y</code>相关的文件肯定不必多说，我解释一下其它文件中的内容：</p> 
<ul>
<li> <p><code>asg.hpp</code></p> <p>由于使用了Visitor模式，ASG的代码就只是一堆类和结构体的定义，因此不需要有源文件。</p> </li>
<li> <p><code>lexer.l</code>和<code>lexer.cc</code></p> <p>这两个文件是可选的。在本实验中，实验2程序实际接受的输入是已经完成词法分析环节的词法单元流，其中每行是一个词法单元，对于这种形式的输入，可以仍然使用Flex生成<code>yylex</code>函数，但也可以直接手写，这时相比之下手写反而更为简单直接。</p> </li>
<li> <p><code>ToJson.hpp</code>和<code>ToJson.cpp</code></p> <p>定义和实现转换ASG为JSON的Visitor。</p> </li>
<li> <p><code>Typing.hpp</code>和<code>Typing.cpp</code></p> <p>如果你想和clang一样输出包含完整类型信息的语法树，那么就需要再写一个Visitor来做类型推导和检查。</p> 
  <blockquote> 
   <p>事实上clang发射的JSON语法树有一些结点就是为类型系统服务的，因此如果你想通过实验2也许不得不实现这个Visitor。</p> 
  </blockquote> </li>
<li> <p><code>main.cpp</code></p> <p>程序入口，将其它代码简单地结合起来。由于程序的主体代码都在其它地方，所以这个文件的代码通常不会太长，一般只有10~30行左右。</p> </li>
</ul> 
<h2>
<a id="3_555"></a>实验3</h2> 
<p><img src="https://images2.imgbox.com/e7/5c/ACeLXuGr_o.png" alt="请添加图片描述"></p> 
<p>如图所示，实验3的代码结构反而要简单得多。如果你在实验2中设计得当，那么其中的<code>asg.hpp</code>完全可以一个字都不用改地复用，你也可以再复用实验二中的<code>Typing.hpp</code>和<code>Typing.cpp</code>，对输入的JSON再做一次类型检查。对于其它的文件：</p> 
<ul>
<li> <p><code>FromJson.hpp</code>和<code>FromJson.cpp</code></p> <p>解析JSON构造ASG，这是一个JSON数据类型的Visitor。</p> </li>
<li> <p><code>EmitIR.hpp</code>和<code>EmitIR.cpp</code></p> <p>定义和实现一个ASG的Visitor，调用LLVM的API，将ASG发射到LLVM IR。这部分代码的主要难点在熟悉LLVM API的用法，而并非算法本身，就和前面说的一样，如果你厘清了编译器的结构，那么这些代码其实就只不过相当于“把话换一种方式说出来”而已，没有什么难以理解的。</p> </li>
</ul> 
<h2>
<a id="_569"></a>完整的编译器</h2> 
<p><img src="https://images2.imgbox.com/97/38/ZUgyOxDr_o.png" alt="请添加图片描述"><code>ToJson</code>和<code>FromJson</code>是出于实验评测的要求才必须有的，在你通过所有实验（包括实验4）后，你完全可以跳过JSON的这个中间环节，直接从文本形式的源代码生成最终的可执行二进制文件，这时你项目的整体代码架构就会和上图展示的一样。</p> 
<p>其中<code>Passes*</code>就是你写的各种优化趟，它具体的写法是由LLVM框架的设计决定的；这里的<code>main.cpp</code>仍然是将其它代码简单地结合起来而已，不过为了输出二进制文件，你可能需要查阅更多的LLVM文档，这部分代码的编写就没有在我们的实验中涉及了。</p> 
<h1>
<a id="_575"></a>关于文法规则的提示</h1> 
<p>最后，我在这里给出一些文法规则设计层面的提示，相比于写实验代码，这些提示和理论课的内容更接近，也许它们可以避免你落入陷阱。</p> 
<h2>
<a id="_579"></a>保留字和标识符</h2> 
<p>我们知道C和很多语言的标识符词法规则都是<code>[a-zA-z_][a-zA-z_0-9]*</code>，而绝大部分保留字也是符合这个词法规则的，比如<code>if</code>、<code>while</code>，因此这里就多出了一个设计选项：我们可以在词法分析环节将保留字一并处理为标识符，然后在之后的语法解析环节再做区分，这种设计选项好不好呢？</p> 
<p>应该说，大部分情况下，你都应该尽量避免这么做，因为将这些逻辑越早地实现，你就可以越少写一些代码。然而，实际也会有不得不这么做的时候，这往往是因为语言在之后的演进中引入了新的关键字，比如<a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#soft-keywords">Python的<code>case</code></a>。</p> 
<h2>
<a id="_585"></a>表达式优先级和结合性</h2> 
<p>表达式语法是一个经典且重要的文法设计案例，这些文法规则淋漓尽致地体现了上下文无关文法的特征，并且几乎在所有编程语言都有用到，和表达式语法相关的问题有两个：优先级和结合性，Bison为表达式的优先级和结合性特意提供了<a href="https://www.gnu.org/software/bison/manual/html_node/Precedence.html">一套机制</a>，但是仍然有必要掌握使用上下文无关文法描述优先级和结合性的方法，因为其它的语法解析框架不一定有这些机制。</p> 
<p>对比一下，下面两种文法规则分别生成左结合和右结合的语法树：</p> 
<ul>
<li>左结合：<code>表达式序列 -&gt; 表达式 | 表达式序列 ("+" | "-") 表达式</code>
</li>
<li>右结合：<code>表达式序列 -&gt; 表达式 | 表达式 ("+" | "-") 表达式序列</code>
</li>
</ul> 
<p>而不同的优先级可以通过为每层引入一个非终结符实现：</p> 
<pre><code>表达式 -&gt; 加减
加减 -&gt; 乘除 | 乘除 ("+" | "-") 乘除
乘除 -&gt; 原子 | 原子 ("*" | "/") 原子
原子 -&gt; 数字 | "(" 表达式 ")"
</code></pre> 
<p>这种方式的一个缺点是在每个表达式在解析时都会产生很深的调用栈，这可能带来性能和内存使用方面的问题，不过这确实是一种常见的实现方式。</p> 
<blockquote> 
 <p>这也是为什么第一节中的示例语法解析树我要省略表达式相关结点。</p> 
</blockquote> 
<h2>
<a id="C_607"></a>C的类型表达式语法</h2> 
<p>C的类型表达式语法是为大家广为诟病的设计缺陷，在你做这个实验时你会更深刻地感受到这一点。处理它的棘手之处主要有两点：</p> 
<ul>
<li> <p>C的类型语法是包裹起来的，而非是展开的，声明语句的符号名在最里面；</p> <p>比如这样的变量声明语句：<code>int a, *b, (*c)(int c, int d);</code>。</p> </li>
<li> <p>C的类型表达式是从内到外的，而非和它的表达式一样是从外到内的。</p> <p>比如，<code>int a[2][3];</code>的语义结构是这样：</p> 
  <div class="mermaid sequence-diagram"> 
    
    #mermaid-svg-tHpSKuDpaqrdZUlo {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-tHpSKuDpaqrdZUlo .error-icon{fill:#552222;}#mermaid-svg-tHpSKuDpaqrdZUlo .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-tHpSKuDpaqrdZUlo .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-tHpSKuDpaqrdZUlo .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-tHpSKuDpaqrdZUlo .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-tHpSKuDpaqrdZUlo .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-tHpSKuDpaqrdZUlo .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-tHpSKuDpaqrdZUlo .marker{fill:#333333;stroke:#333333;}#mermaid-svg-tHpSKuDpaqrdZUlo .marker.cross{stroke:#333333;}#mermaid-svg-tHpSKuDpaqrdZUlo svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-tHpSKuDpaqrdZUlo .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-svg-tHpSKuDpaqrdZUlo .cluster-label text{fill:#333;}#mermaid-svg-tHpSKuDpaqrdZUlo .cluster-label span{color:#333;}#mermaid-svg-tHpSKuDpaqrdZUlo .label text,#mermaid-svg-tHpSKuDpaqrdZUlo span{fill:#333;color:#333;}#mermaid-svg-tHpSKuDpaqrdZUlo .node rect,#mermaid-svg-tHpSKuDpaqrdZUlo .node circle,#mermaid-svg-tHpSKuDpaqrdZUlo .node ellipse,#mermaid-svg-tHpSKuDpaqrdZUlo .node polygon,#mermaid-svg-tHpSKuDpaqrdZUlo .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-tHpSKuDpaqrdZUlo .node .label{text-align:center;}#mermaid-svg-tHpSKuDpaqrdZUlo .node.clickable{cursor:pointer;}#mermaid-svg-tHpSKuDpaqrdZUlo .arrowheadPath{fill:#333333;}#mermaid-svg-tHpSKuDpaqrdZUlo .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-tHpSKuDpaqrdZUlo .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-tHpSKuDpaqrdZUlo .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-svg-tHpSKuDpaqrdZUlo .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-svg-tHpSKuDpaqrdZUlo .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-tHpSKuDpaqrdZUlo .cluster text{fill:#333;}#mermaid-svg-tHpSKuDpaqrdZUlo .cluster span{color:#333;}#mermaid-svg-tHpSKuDpaqrdZUlo div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-tHpSKuDpaqrdZUlo :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;} 
     
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
       
        
        
        
        
        
        
       
       
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.size</span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel">.size</span> 
          </div> 
          
         
        
       
       
        
         
         
          
          <div> 
           <span class="nodeLabel">2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">3</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">Decl</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'int'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">Array1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">'a'</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">Array2</span> 
          </div> 
          
         
        
       
      
     
    
  </div> <p>而<code>a[2][3]</code>的语义结构却是这样：</p> 
  <div class="mermaid sequence-diagram"> 
    
    #mermaid-svg-qYjvKXoh3XuaCBmi {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-qYjvKXoh3XuaCBmi .error-icon{fill:#552222;}#mermaid-svg-qYjvKXoh3XuaCBmi .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-qYjvKXoh3XuaCBmi .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-qYjvKXoh3XuaCBmi .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-qYjvKXoh3XuaCBmi .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-qYjvKXoh3XuaCBmi .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-qYjvKXoh3XuaCBmi .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-qYjvKXoh3XuaCBmi .marker{fill:#333333;stroke:#333333;}#mermaid-svg-qYjvKXoh3XuaCBmi .marker.cross{stroke:#333333;}#mermaid-svg-qYjvKXoh3XuaCBmi svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-qYjvKXoh3XuaCBmi .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-svg-qYjvKXoh3XuaCBmi .cluster-label text{fill:#333;}#mermaid-svg-qYjvKXoh3XuaCBmi .cluster-label span{color:#333;}#mermaid-svg-qYjvKXoh3XuaCBmi .label text,#mermaid-svg-qYjvKXoh3XuaCBmi span{fill:#333;color:#333;}#mermaid-svg-qYjvKXoh3XuaCBmi .node rect,#mermaid-svg-qYjvKXoh3XuaCBmi .node circle,#mermaid-svg-qYjvKXoh3XuaCBmi .node ellipse,#mermaid-svg-qYjvKXoh3XuaCBmi .node polygon,#mermaid-svg-qYjvKXoh3XuaCBmi .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-qYjvKXoh3XuaCBmi .node .label{text-align:center;}#mermaid-svg-qYjvKXoh3XuaCBmi .node.clickable{cursor:pointer;}#mermaid-svg-qYjvKXoh3XuaCBmi .arrowheadPath{fill:#333333;}#mermaid-svg-qYjvKXoh3XuaCBmi .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-qYjvKXoh3XuaCBmi .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-qYjvKXoh3XuaCBmi .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-svg-qYjvKXoh3XuaCBmi .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-svg-qYjvKXoh3XuaCBmi .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-qYjvKXoh3XuaCBmi .cluster text{fill:#333;}#mermaid-svg-qYjvKXoh3XuaCBmi .cluster span{color:#333;}#mermaid-svg-qYjvKXoh3XuaCBmi div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-qYjvKXoh3XuaCBmi :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;} 
     
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
      
      
       
       
        
        
        
        
       
       
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
        
         
          
          <div> 
           <span class="edgeLabel"></span> 
          </div> 
          
         
        
       
       
        
         
         
          
          <div> 
           <span class="nodeLabel">2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">3</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">IndexExpr1</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">IndexExpr2</span> 
          </div> 
          
         
        
        
         
         
          
          <div> 
           <span class="nodeLabel">a</span> 
          </div> 
          
         
        
       
      
     
    
  </div> </li>
</ul> 
<p>如果你真的总结不出来它的语法规则，你可以看一看ANTLR给出的答案：https://github.com/antlr/grammars-v4/blob/master/c/C.g4。</p> 
<h2>
<a id="ifelse_638"></a>if-else移入归约冲突</h2> 
<p>在C里产生这个问题的产生式是下面这两条：</p> 
<pre><code>语句 -&gt; 选择 | ...
选择 -&gt; "if" 语句 "else" 语句
</code></pre> 
<p>直接在Bison里输入这两条语法就会报告一个移入归约冲突的警告。这是一个非常经典的问题，你可以参考《编译原理》（龙书）P133页，Bison文档中也有给出相关解决方案，因为过于经典我就不再这里赘述了。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>