<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>蓝桥杯第十四届蓝桥杯模拟赛第三期考场应对攻略（C/C&#43;&#43;） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">蓝桥杯第十四届蓝桥杯模拟赛第三期考场应对攻略（C/C&#43;&#43;）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p>这里把我的想法和思路写出来，恳请批评指正！</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%80%83%E5%89%8D%E5%87%86%E5%A4%87-toc" style="margin-left:0px"><a href="#%E8%80%83%E5%89%8D%E5%87%86%E5%A4%87">考前准备</a></p> 
<p id="%E8%AF%95%E9%A2%981%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%981%EF%BC%9A">试题1：</a></p> 
<p id="%E8%AF%95%E9%A2%982%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%982%EF%BC%9A">试题2：</a></p> 
<p id="%E8%AF%95%E9%A2%983%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%983%EF%BC%9A">试题3：</a></p> 
<p id="%E8%AF%95%E9%A2%984%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%984%EF%BC%9A">试题4：</a></p> 
<p id="%E8%AF%95%E9%A2%985%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%985%EF%BC%9A">试题5：</a></p> 
<p id="%E8%AF%95%E9%A2%986%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%986%EF%BC%9A">试题6：</a></p> 
<p id="%E8%AF%95%E9%A2%987%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%987%EF%BC%9A">试题7：</a></p> 
<p id="%E8%AF%95%E9%A2%988%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%988%EF%BC%9A">试题8：</a></p> 
<p id="%E8%AF%95%E9%A2%989%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%989%EF%BC%9A">试题9：</a></p> 
<p id="%E8%AF%95%E9%A2%9810%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E8%AF%95%E9%A2%9810%EF%BC%9A">试题10：</a></p> 
<p id="%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E6%80%BB%E7%BB%93%EF%BC%9A">总结：</a></p> 
<hr id="hr-toc">
<h1>考前准备</h1> 
<p>考前五分钟，开十个源文件，并把头文件等必须写的部分写出来，写完的程序一定要有顺序地保留</p> 
<h1 id="%E8%AF%95%E9%A2%981%EF%BC%9A">试题1：</h1> 
<p>问题描述<br> 请找到一个大于 2022 的最小数，这个数转换成十六进制之后，所有的数位（不含前导 0）都为字母（A 到 F）。<br> 请将这个数的十进制形式作为答案提交。</p> 
<p>答案提交<br> 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p> 
<p><br> 个人认为难度：易</p> 
<p>答案：2730</p> 
<p>思路：从2023开始一直输出十六进制形式，用眼睛找第一个全字母的就行</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	for(int i=2023;i;i++)
	cout&lt;&lt;dec&lt;&lt;i&lt;&lt;' '&lt;&lt;hex&lt;&lt;i&lt;&lt;endl;
	//2730 10*16*16+10*16+10
	//cout&lt;&lt;10*16*16+10*16+10;
} </code></pre> 
<h1 id="%E8%AF%95%E9%A2%982%EF%BC%9A">试题2：</h1> 
<p>问题描述<br> 在 Excel 中，列的名称使用英文字母的组合。前 26 列用一个字母，依次为 A 到 Z，接下来 26*26 列使用两个字母的组合，依次为 AA 到 ZZ。<br> 请问第 2022 列的名称是什么？</p> 
<p>答案提交<br> 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个由大写字母组成的字符串，在提交答案时只填写这个字符串，填写多余的内容将无法得分。<br>  </p> 
<p>个人认为难度：易</p> 
<p>答案：BYT</p> 
<p>思路：纯手算就行</p> 
<p>考场推导过程：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	//26
	//26*26=676;
	//676+26=702
	//A676 676+702=1378
	//B676 1378+676=2054 BZZ=2054
	//BZ 2054-26=2028 BZA=2029
	//BY 2028-26=2004 BYZ=2028 BYY BYX BYW BYV BYU=2023 BYT=2022
	  
	//cout&lt;&lt;1378+676;
} </code></pre> 
<h1 id="%E8%AF%95%E9%A2%983%EF%BC%9A">试题3：</h1> 
<p>问题描述<br> 对于一个日期，我们可以计算出年份的各个数位上的数字之和，也可以分别计算月和日的各位数字之和。请问从 1900 年 1 月 1 日至 9999 年 12 月 31 日，总共有多少天，年份的数位数字之和等于月的数位数字之和加日的数位数字之和。<br> 例如，2022年11月13日满足要求，因为 2+0+2+2=(1+1)+(1+3) 。<br> 请提交满足条件的日期的总数量。</p> 
<p>答案提交<br> 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p> 
<p>个人认为难度：易中之间</p> 
<p>答案：70910</p> 
<p>思路：年份转化成字符串计算（四位数也算比较多的了，取模作除法可能麻烦一点），月份日期可以纯枚举，至于闰年的问题可以拿出来单独讨论，还是比较容易算错的</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn=9999;
ll year[maxn],md[maxn][maxn],day[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int num1,num2,ans;
string y,m,d;

void run()
{
	for(int i=1900;i&lt;=9999;i++)
	{
		if(i%4==0&amp;&amp;i%100!=0||i%400==0)
		{
			y=to_string(i);
			if((int)y[0]+(int)y[1]+(int)y[2]+(int)y[3]-48*4==13)
			{
				cout&lt;&lt;y&lt;&lt;endl;
				ans++;
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	for(int i=1900;i&lt;=9999;i++)
	{
		y=to_string(i);
		year[i]=(int)y[0]+(int)y[1]+(int)y[2]+(int)y[3]-48*4;
	}
	for(int i=1;i&lt;=12;i++)
	{
		if(i&lt;10) num1=i;
		if(i==10) num1=1;
		if(i==11) num1=2;
		if(i==12) num1=3;
		for(int j=1;j&lt;=day[i];j++)
		{
			if(j&lt;10) num2=j;
			if(j==10) num2=1;
			if(j==11) num2=2;
			if(j==12) num2=3;
			if(j==13) num2=4;
			if(j==14) num2=5;
			if(j==15) num2=6;
			if(j==16) num2=7;
			if(j==17) num2=8;
			if(j==18) num2=9;
			if(j==19) num2=10;
			if(j==20) num2=2;
			if(j==21) num2=3;
			if(j==22) num2=4;
			if(j==23) num2=5;
			if(j==24) num2=6;
			if(j==25) num2=7;
			if(j==26) num2=8;
			if(j==27) num2=9;
			if(j==28) num2=10;
			if(j==29) num2=11;
			if(j==30) num2=3;
			if(j==31) num2=4;
			md[i][j]=num1+num2;
		}
	}
	for(int i=1900;i&lt;=9999;i++)
	{
		for(int j=1;j&lt;=12;j++)
		{
			for(int k=1;k&lt;=day[j];k++)
			{
				if(year[i]==md[j][k])
				{
					ans++;
					cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;' '&lt;&lt;k&lt;&lt;endl;
				}
			}
		}
	}
	run();
	cout&lt;&lt;ans;
	
} </code></pre> 
<h1 id="%E8%AF%95%E9%A2%984%EF%BC%9A">试题4：</h1> 
<p>问题描述<br> 小蓝有 30 个数，分别为：99, 22, 51, 63, 72, 61, 20, 88, 40, 21, 63, 30, 11, 18, 99, 12, 93, 16, 7, 53, 64, 9, 28, 84, 34, 96, 52, 82, 51, 77 。<br> 小蓝可以在这些数中取出两个序号不同的数，共有 30*29/2=435 种取法。<br> 请问这 435 种取法中，有多少种取法取出的两个数的乘积大于等于 2022 。</p> 
<p>答案提交<br> 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p> 
<p>个人认为难度：易</p> 
<p>答案：189</p> 
<p>思路：这里其实就能看出来这个模拟赛的水了，第四题甚至感觉比第一题还好算，直接两重循环解决问题</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
int num[30]={99, 22, 51, 63, 72, 61, 20, 88, 40, 21, 63, 30, 11, 18, 99, 12, 93, 16, 7, 53, 64, 9, 28, 84, 34, 96, 52, 82, 51, 77 };
int ans;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	for(int i=0;i&lt;=29;i++)
	{
		for(int j=i+1;j&lt;=29;j++)
		{
			if(num[i]*num[j]&gt;=2022)
			{
				cout&lt;&lt;num[i]&lt;&lt;'*'&lt;&lt;num[j]&lt;&lt;endl;
				ans++;
			}
		}
	}
	cout&lt;&lt;ans;
} </code></pre> 
<h1 id="%E8%AF%95%E9%A2%985%EF%BC%9A">试题5：</h1> 
<p id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</p> 
<p>小蓝有一个 30 行 60 列的数字矩阵，矩阵中的每个数都是 0 或 1 。如果从一个标为 1 的位置可以通过上下左右走到另一个标为 1 的位置，则称两个位置连通。与某一个标为 1 的位置连通的所有位置（包括自己）组成一个连通分块。<br> 请问矩阵中最大的连通分块有多大？</p> 
<pre><code class="language-cpp">110010000011111110101001001001101010111011011011101001111110
010000000001010001101100000010010110001111100010101100011110
001011101000100011111111111010000010010101010111001000010100
101100001101011101101011011001000110111111010000000110110000
010101100100010000111000100111100110001110111101010011001011
010011011010011110111101111001001001010111110001101000100011
101001011000110100001101011000000110110110100100110111101011
101111000000101000111001100010110000100110001001000101011001
001110111010001011110000001111100001010101001110011010101110
001010101000110001011111001010111111100110000011011111101010
011111100011001110100101001011110011000101011000100111001011
011010001101011110011011111010111110010100101000110111010110
001110000111100100101110001011101010001100010111110111011011
111100001000001100010110101100111001001111100100110000001101
001110010000000111011110000011000010101000111000000110101101
100100011101011111001101001010011111110010111101000010000111
110010100110101100001101111101010011000110101100000110001010
110101101100001110000100010001001010100010110100100001000011
100100000100001101010101001101000101101000000101111110001010
101101011010101000111110110000110100000010011111111100110010
101111000100000100011000010001011111001010010001010110001010
001010001110101010000100010011101001010101101101010111100101
001111110000101100010111111100000100101010000001011101100001
101011110010000010010110000100001010011111100011011000110010
011110010100011101100101111101000001011100001011010001110011
000101000101000010010010110111000010101111001101100110011100
100011100110011111000110011001111100001110110111001001000111
111011000110001000110111011001011110010010010110101000011111
011110011110110110011011001011010000100100101010110000010011
010011110011100101010101111010001001001111101111101110011101
</code></pre> 
<h3 id="%E7%AD%94%E6%A1%88%E6%8F%90%E4%BA%A4">答案提交</h3> 
<p>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p> 
<p>个人认为难度：中</p> 
<p>答案：148</p> 
<p>思路：全球变暖的变形题，用BFS，本来我是不想写代码的，因为30*60这个规模感觉还好，可以用眼睛看，但是还是看错了，模拟之后完整写了这个代码，还要注意文件读取问题</p> 
<p>考场推导过程（看看方法就行）：</p> 
<p><img alt="" height="988" src="https://images2.imgbox.com/2d/a5/RZn3F5pi_o.png" width="853"></p> 
<p> 代码：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
char mp[31][61];
queue&lt;pair&lt;int,int&gt; &gt;q;
bool vis[31][61];
int X[4]={0,0,1,-1};
int Y[4]={1,-1,0,0};
ll x,y,maxn=0,cnt=0;
void bfs()
{
	for(int i=1;i&lt;=30;i++)
	{
		for(int j=1;j&lt;=60;j++)
		{
			cnt=0; 
			if(mp[i][j]=='1')
			{
				q.push({i,j});
				cnt++;
			}
			vis[i][j]=true;
			while(q.size())
			{
				x=q.front().first;
				y=q.front().second;
				for(int k=0;k&lt;=3;k++)
				{
					int nx=x+X[k];
					int ny=y+Y[k];
					if(nx&gt;0&amp;&amp;nx&lt;=30&amp;&amp;ny&gt;0&amp;&amp;ny&lt;=60&amp;&amp;!vis[nx][ny]&amp;&amp;mp[nx][ny]=='1')
					{
						vis[nx][ny]=true;
						cnt++;
						q.push({nx,ny});
					}
				}
				cout&lt;&lt;q.front().first&lt;&lt;' '&lt;&lt;q.front().second&lt;&lt;endl; 
				q.pop();
			}
			maxn=max(maxn,cnt);
		}
	}
	
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	freopen("C:\Users\张px\Desktop\input.txt","r",stdin);
	for(int i=1;i&lt;=30;i++)
	{
		for(int j=1;j&lt;=60;j++)
		{
			cin&gt;&gt;mp[i][j];
		}
	}
	bfs();
	cout&lt;&lt;maxn;
	return 0;
} </code></pre> 
<h1 id="%E8%AF%95%E9%A2%986%EF%BC%9A">试题6：</h1> 
<p>问题描述<br> 给定一天是一周中的哪天，请问 n 天后是一周中的哪天？</p> 
<p>输入格式<br> 输入第一行包含一个整数 w，表示给定的天是一周中的哪天，w 为 1 到 6 分别表示周一到周六，w 为 7 表示周日。<br> 第二行包含一个整数 n。</p> 
<p>输出格式<br> 输出一行包含一个整数，表示 n 天后是一周中的哪天，1 到 6 分别表示周一到周六，7 表示周日。</p> 
<p>样例输入<br> 6<br> 10</p> 
<p>样例输出<br> 2</p> 
<p>评测用例规模与约定<br> 对于所有评测用例，1 &lt; = n &lt; = 1000000 <br>  </p> 
<p>个人认为难度：易</p> 
<p>思路：取模运算就行</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll today,target,n;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	scanf("%lld%lld",&amp;today,&amp;n);
	target=today+n%7;
	target=target%7;
	printf("%lld",target);
	return 0;
} </code></pre> 
<h1 id="%E8%AF%95%E9%A2%987%EF%BC%9A">试题7：</h1> 
<p>问题描述<br> 小蓝负责一块区域的信号塔安装，整块区域是一个长方形区域，建立坐标轴后，西南角坐标为 (0, 0)， 东南角坐标为 (W, 0)， 西北角坐标为 (0, H)， 东北角坐标为 (W, H)。其中 W, H 都是整数。<br> 他在 n 个位置设置了信号塔，每个信号塔可以覆盖以自己为圆心，半径为 R 的圆形（包括边缘）。<br> 为了对信号覆盖的情况进行检查，小蓝打算在区域内的所有横纵坐标为整数的点进行测试，检查信号状态。其中横坐标范围为 0 到 W，纵坐标范围为 0 到 H，总共测试 (W+1) * (H+1) 个点。<br> 给定信号塔的位置，请问这 (W+1)*(H+1) 个点中有多少个点被信号覆盖。</p> 
<p>输入格式<br> 输入第一行包含四个整数 W, H, n, R，相邻整数之间使用一个空格分隔。<br> 接下来 n 行，每行包含两个整数 x, y，表示一个信号塔的坐标。信号塔可能重合，表示两个信号发射器装在了同一个位置。</p> 
<p>输出格式<br> 输出一行包含一个整数，表示答案。</p> 
<p>样例输入<br> 10 10 2 5<br> 0 0<br> 7 0</p> 
<p>样例输出<br> 57</p> 
<p>评测用例规模与约定<br> 对于所有评测用例，1 &lt;= W, H &lt;= 100，1 &lt;= n &lt;= 100, 1 &lt;= R &lt;= 100, 0 &lt;= x &lt;= W, 0 &lt;= y &lt;= H。<br>  </p> 
<p>个人认为难度：易</p> 
<p>思路：注意记忆即可，加上欧式距离这一限制条件即可</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll W,H,n,R,ans,x,y;
bool vis[105][105];
void num()
{
	for(int k=0;k&lt;=W;k++)
	{
		for(int p=0;p&lt;=H;p++)
		{
			if(!vis[k][p]&amp;&amp;(x-k)*(x-k)+(y-p)*(y-p)&lt;=R*R)
			{
				vis[k][p]=true;
				//cout&lt;&lt;k&lt;&lt;' '&lt;&lt;p&lt;&lt;endl;
				ans++;
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	scanf("%lld%lld%lld%lld",&amp;W,&amp;H,&amp;n,&amp;R);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%lld%lld",&amp;x,&amp;y);
		num();
	}
	printf("%lld",ans);
	return 0;
} </code></pre> 
<h1 id="%E8%AF%95%E9%A2%988%EF%BC%9A">试题8：</h1> 
<p>问题描述<br> 小蓝有一个 n * m 大小的矩形水域，小蓝将这个水域划分为 n 行 m 列，行数从 1 到 n 标号，列数从 1 到 m 标号。每行和每列的宽度都是单位 1 。<br> 现在，这个水域长满了水草，小蓝要清理水草。<br> 每次，小蓝可以清理一块矩形的区域，从第 r1 行（含）到第 r2 行（含）的第 c1 列（含）到 c2 列（含）。<br> 经过一段时间清理后，请问还有多少地方没有被清理过。</p> 
<p>输入格式<br> 输入第一行包含两个整数 n, m，用一个空格分隔。<br> 第二行包含一个整数 t ，表示清理的次数。<br> 接下来 t 行，每行四个整数 r1, c1, r2, c2，相邻整数之间用一个空格分隔，表示一次清理。请注意输入的顺序。</p> 
<p>输出格式<br> 输出一行包含一个整数，表示没有被清理过的面积。</p> 
<p>样例输入1<br> 2 3<br> 2<br> 1 1 1 3<br> 1 2 2 2</p> 
<p>样例输出1<br> 2</p> 
<p>样例输入2<br> 30 20<br> 2<br> 5 5 10 15<br> 6 7 15 9</p> 
<p>样例输出2<br> 519</p> 
<p>评测用例规模与约定<br> 对于所有评测用例，1 &lt;= r1 &lt;= r2 &lt;= n &lt;= 100, 1 &lt;= c1 &lt;= c2 &lt;= m &lt;= 100, 0 &lt;= t &lt;= 100。<br>  </p> 
<p>个人认为难度：易</p> 
<p>思路：感觉和第七题出重复了，同样需要记忆</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn=105;
ll n,m,t, r1, c1, r2, c2,ans;
bool vis[105][105];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;t);
	for(int i=1;i&lt;=t;i++)
	{
		scanf("%lld%lld%lld%lld",&amp;r1, &amp;c1, &amp;r2, &amp;c2);
		for(int j=r1;j&lt;=r2;j++)
		{
			for(int k=c1;k&lt;=c2;k++)
			{
				if(!vis[j][k])
				{
					vis[j][k]=true;
					ans++;
				}
			}
		}
	}
	printf("%lld",n*m-ans);
	return 0;
} </code></pre> 
<h1 id="%E8%AF%95%E9%A2%989%EF%BC%9A">试题9：</h1> 
<p>问题描述<br> 小蓝准备在一个空旷的场地里面滑行，这个场地的高度不一，小蓝用一个 n 行 m 列的矩阵来表示场地，矩阵中的数值表示场地的高度。<br> 如果小蓝在某个位置，而他上、下、左、右中有一个位置的高度（严格）低于当前的高度，小蓝就可以滑过去，滑动距离为 1 。<br> 如果小蓝在某个位置，而他上、下、左、右中所有位置的高度都大于等于当前的高度，小蓝的滑行就结束了。<br> 小蓝不能滑出矩阵所表示的场地。<br> 小蓝可以任意选择一个位置开始滑行，请问小蓝最多能滑行多远距离。</p> 
<p>输入格式<br> 输入第一行包含两个整数 n, m，用一个空格分隔。<br> 接下来 n 行，每行包含 m 个整数，相邻整数之间用一个空格分隔，依次表示每个位置的高度。</p> 
<p>输出格式<br> 输出一行包含一个整数，表示答案。</p> 
<p>样例输入<br> 4 5<br> 1 4 6 3 1<br> 11 8 7 3 1<br> 9 4 5 2 1<br> 1 3 2 2 1</p> 
<p>样例输出<br> 7</p> 
<p>样例说明<br> 滑行的位置一次为 (2, 1), (2, 2), (2, 3), (3, 3), (3, 2), (4, 2), (4, 3)。</p> 
<p>评测用例规模与约定<br> 对于 30 % 评测用例，1 &lt; = n &lt; = 20 ，1 &lt; = m &lt; = 20 ，0 &lt; = 高度 &lt; = 100<br> 对于所有评测用例，1 &lt; = n &lt; = 100 ，1 &lt; = m &lt; = 100 ，0 &lt; = 高度 &lt; = 10000 <br>  </p> 
<p>个人认为难度：中</p> 
<p>思路：找最值路径，用BFS，每一点都作为起点搜索一次，然后开一个二维数组记录滑行的次数，搜索完一次就遍历一次二维数组更新最大值</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
int maxn=0;
int n,m,mp[105][105];
int X[4]={1,-1,0,0};
int Y[4]={0,0,1,-1};
int cnt[105][105];
int x,y,nx,ny;
queue&lt;pair&lt;int,int&gt; &gt;q;
void bfs()
{
	while(q.size())
	{
		x=q.front().first;
		y=q.front().second;
		//cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;endl;
		for(int k=0;k&lt;4;k++)
		{
			nx=x+X[k];
			ny=y+Y[k];
			//cout&lt;&lt;nx&lt;&lt;' '&lt;&lt;ny&lt;&lt;endl;
			//if(nx&gt;0) cout&lt;&lt;1;
			//if(ny&gt;0) cout&lt;&lt;2;
			//if(nx&lt;=n) cout&lt;&lt;3;
			//if(ny&lt;=m) cout&lt;&lt;4;
			 //cout&lt;&lt;mp[x][y]&lt;&lt;' '&lt;&lt;mp[nx][ny];
			//cout&lt;&lt;endl;
			if(nx&gt;0&amp;&amp;ny&gt;0&amp;&amp;nx&lt;=n&amp;&amp;ny&lt;=m&amp;&amp;mp[x][y]&gt;mp[nx][ny])
			{
				q.push({nx,ny});
				cnt[nx][ny]=cnt[x][y]+1;
			}
		}
		q.pop();
	}
	for(int a=1;a&lt;=n;a++)
	{
		for(int b=1;b&lt;=m;b++)
		{
			maxn=max(cnt[a][b],maxn);
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	scanf("%lld%lld",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=m;j++)
		{
			cin&gt;&gt;mp[i][j];
		}
	}
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=m;j++)
		{
			q.push({i,j});
			memset(cnt,0,sizeof(cnt));
			cnt[i][j]=1;
			bfs();
		}
	}
	printf("%d",maxn);
	return 0;
} </code></pre> 
<h1 id="%E8%AF%95%E9%A2%9810%EF%BC%9A">试题10：</h1> 
<p>问题描述<br> 小蓝有一个序列 a[1], a[2], …, a[n]。<br> 给定一个正整数 k，请问对于每一个 1 到 n 之间的序号 i，a[i-k], a[i-k+1], …, a[i+k] 这 2k+1 个数中的最小值是多少？当某个下标超过 1 到 n 的范围时，数不存在，求最小值时只取存在的那些值。</p> 
<p>输入格式<br> 输入的第一行包含一整数 n。<br> 第二行包含 n 个整数，分别表示 a[1], a[2], …, a[n]。<br> 第三行包含一个整数 k 。</p> 
<p>输出格式<br> 输出一行，包含 n 个整数，分别表示对于每个序号求得的最小值。</p> 
<p>样例输入<br> 5<br> 5 2 7 4 3<br> 1</p> 
<p>样例输出<br> 2 2 2 3 3</p> 
<p>评测用例规模与约定<br> 对于 30 % 的评测用例，1 &lt; = n &lt; = 1000 1 &lt; = a [ i ] &lt; = 1000 <br> 对于 50 % 的评测用例，1 &lt; = n &lt; = 10000 1 &lt; = a [ i ] &lt; = 10000 <br> 对于所有评测用例，1 &lt; = n &lt; = 1000000 1 &lt; = a [ i ] &lt; = 1000000 <br>  </p> 
<p>个人认为难度：中难之间</p> 
<p>思路：我使用multimap直接对数进行排序，然后从最小的开始对序号进行筛选，如果符合区间i-k到i+k之间，那么就直接输出进行下一轮搜索，这样做能节省一部分时间复杂度（没有对所有数据进行搜索），但是可能还是不如用ST表</p> 
<p>我把我的代码写出来吧</p> 
<p>代码:</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll maxn=1000005;
ll num[maxn],xuhao[maxn],n;
multimap&lt;int,int,less&lt;int&gt; &gt;m;
ll k,cnt;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	scanf("%lld",&amp;n);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%lld",&amp;num[i]);
		m.insert(pair&lt;ll,ll&gt;(num[i],i));
	}
	scanf("%lld",&amp;k);
	
	for(int i=1;i&lt;=n;i++)
	{
		for(multimap&lt;int,int,less&lt;int&gt; &gt;::iterator it=m.begin();it!=m.end();it++)
		{
			if(i-k&gt;=0&amp;&amp;i-k&lt;=n&amp;&amp;it-&gt;second&gt;=i-k&amp;&amp;it-&gt;second&lt;=i+k) 
			{
				printf("%lld ",it-&gt;first); 
				break;
			}
		}
		
	}
	return 0;
} </code></pre> 
<h1 id="%E6%80%BB%E7%BB%93%EF%BC%9A">总结：</h1> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr>
<td>序号</td>
<td>个人认为难度</td>
<td>涉及知识点</td>
<td>是否推荐手算</td>
</tr>
<tr>
<td>1</td>
<td>易</td>
<td>进制输入输出流</td>
<td>否</td>
</tr>
<tr>
<td>2</td>
<td>易</td>
<td></td>
<td>是</td>
</tr>
<tr>
<td>3</td>
<td>易中之间</td>
<td>年份问题</td>
<td>否</td>
</tr>
<tr>
<td>4</td>
<td>易</td>
<td></td>
<td>尽量不要手算</td>
</tr>
<tr>
<td>5</td>
<td>中</td>
<td>搜索+数据结构+文件读取</td>
<td>自己决定</td>
</tr>
<tr>
<td>6</td>
<td>易</td>
<td>取模</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>易</td>
<td>记忆</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>易</td>
<td>记忆</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>中</td>
<td>搜索+数据结构</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>中难之间</td>
<td>ST表/高级数据结构</td>
<td></td>
</tr>
</tbody></table>
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>