<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>《小猫猫大课堂》三轮3——字符函数和字符串函数及其模拟实现 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《小猫猫大课堂》三轮3——字符函数和字符串函数及其模拟实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p><img alt="" height="546" src="https://images2.imgbox.com/bd/53/MTwsh1ab_o.png" width="809"></p> 
<p><span style="color:#fe2c24">宝子，你不点个赞吗？不评个论吗？不收个藏吗？</span></p> 
<p><span style="color:#fe2c24">最后的最后，关注我，关注我，关注我，你会看到更多有趣的博客哦！！！</span></p> 
<p><span style="color:#fe2c24">喵喵喵，你对我真的很重要。</span></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px"><a href="#%E5%89%8D%E8%A8%80">前言</a></p> 
<p id="%E7%9F%A5%E8%AF%86%E5%AF%BC%E5%9B%BE-toc" style="margin-left:0px"><a href="#%E7%9F%A5%E8%AF%86%E5%AF%BC%E5%9B%BE">知识导图</a></p> 
<p id="%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px"><a href="#%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BD%BF%E7%94%A8"> 字符串的使用</a></p> 
<p id="strlen%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B-toc" style="margin-left:0px"><a href="#strlen%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B">strlen​​​​​​​</a></p> 
<p id="const-toc" style="margin-left:80px"><a href="#const">const</a></p> 
<p id="strlen%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#strlen%E7%9A%84%E5%BA%94%E7%94%A8">strlen的应用</a></p> 
<p id="strlen%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#strlen%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strlen的模拟实现</a></p> 
<p id="assert-toc" style="margin-left:80px"><a href="#assert">assert</a></p> 
<p id="strcpy-toc" style="margin-left:0px"><a href="#strcpy">strcpy</a></p> 
<p id="strcpy%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#strcpy%E7%9A%84%E5%BA%94%E7%94%A8">strcpy的应用</a></p> 
<p id="strcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#strcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strcpy的模拟实现</a></p> 
<p id="strcat-toc" style="margin-left:0px"><a href="#strcat">strcat</a></p> 
<p id="strcat%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#strcat%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strcat的应用及模拟实现</a></p> 
<p id="strcmp-toc" style="margin-left:0px"><a href="#strcmp">strcmp</a></p> 
<p id="strcmp%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#strcmp%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strcmp的应用及模拟实现</a></p> 
<p id="strncpy-toc" style="margin-left:0px"><a href="#strncpy">strncpy</a></p> 
<p id="strncpy%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#strncpy%E7%9A%84%E5%BA%94%E7%94%A8">strncpy的应用</a></p> 
<p id="strncat-toc" style="margin-left:0px"><a href="#strncat">strncat</a></p> 
<p id="strncat%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#strncat%E7%9A%84%E5%BA%94%E7%94%A8">strncat的应用</a></p> 
<p id="strncmp-toc" style="margin-left:0px"><a href="#strncmp">strncmp</a></p> 
<p id="strncmp%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#strncmp%E7%9A%84%E5%BA%94%E7%94%A8">strncmp的应用</a></p> 
<p id="strstr-toc" style="margin-left:0px"><a href="#strstr">strstr</a></p> 
<p id="strstr%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#strstr%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strstr的应用及模拟实现</a></p> 
<p id="strtok-toc" style="margin-left:0px"><a href="#strtok">strtok</a></p> 
<p id="strtok%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#strtok%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strtok的应用及模拟实现</a></p> 
<p id="strerror-toc" style="margin-left:0px"><a href="#strerror">strerror</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0">字符分类函数</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A-toc" style="margin-left:80px"><a href="#%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A">字符分类函数的应用：</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%EF%BC%9A%C2%A0%C2%A0-toc" style="margin-left:80px"><a href="#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%EF%BC%9A%C2%A0%C2%A0">字符转换：  </a></p> 
<p id="memcpy-toc" style="margin-left:0px"><a href="#memcpy">memcpy</a></p> 
<p id="memcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#memcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">memcpy的模拟实现</a></p> 
<p id="memmove-toc" style="margin-left:0px"><a href="#memmove">memmove</a></p> 
<p id="memmove%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#memmove%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">memmove的应用及模拟实现</a></p> 
<p id="memcmp-toc" style="margin-left:0px"><a href="#memcmp">memcmp</a></p> 
<p id="memcmp%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%88VS%E4%B8%8B%E8%BF%9B%E8%A1%8C%EF%BC%89-toc" style="margin-left:80px"><a href="#memcmp%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%88VS%E4%B8%8B%E8%BF%9B%E8%A1%8C%EF%BC%89">memcmp的模拟实现（VS下进行）</a></p> 
<p id="memset-toc" style="margin-left:0px"><a href="#memset">memset</a></p> 
<p id="memset%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#memset%E7%9A%84%E5%BA%94%E7%94%A8">memset的应用</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px"><a href="#%E6%80%BB%E7%BB%93">总结</a></p> 
<hr id="hr-toc"> 
<h1><span style="color:#0d0016">前言</span></h1> 
<blockquote> 
 <p><span style="color:#0d0016">啊哒，想小喵没？喵喵喵~，小喵想死你啦。</span></p> 
 <p><span style="color:#0d0016">这一次我们学习字符函数和字符串的函数，及其模拟实现，了解一个库函数的前世今生。额，一共有14个库函数，多吧，乱吧，小喵画个知识导图吧！学习每个库函数时，我们大体的思路是它是什么，有什么作用，注意事项，函数模拟实现。</span></p> 
 <p><span style="color:#0d0016">啊，当然啦，为什么跳过三轮的第二章呢？来上图</span></p> 
 <p><img alt="" height="592" src="https://images2.imgbox.com/3c/fc/uD1BkEPK_o.png" width="842"></p> 
 <p>瞧见没，准备搞一键透彻，内容不出意外，会非常多，小喵倒时会分一分，一次搞定，还是多轮食用，全看宝子自己。一定要看啊。不要像小喵一样，摆烂，白天的债，晚上还。呜呜，小喵想呼死自己，不争气的玩意。 </p> 
 <p>那么，宝子，我们开始吧！</p> 
</blockquote> 
<h1 id="%E7%9F%A5%E8%AF%86%E5%AF%BC%E5%9B%BE">知识导图</h1> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7e/54/7moAvAcH_o.png" width="1200"></p> 
<hr> 
<h1 id="%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BD%BF%E7%94%A8"> <span style="color:#0d0016">字符串的使用</span>
</h1> 
<p>C语言中对字符和字符串的处理很是频繁，但是<span style="background-color:#fbd4d0">C语言本身是没有字符串类型的</span>，字符串通常放在 <span style="background-color:#fbd4d0">常量字符串 </span>中或者 <span style="background-color:#fbd4d0">字符数组</span> 中。</p> 
<p>字符串常量 适用于那些<span style="background-color:#fbd4d0">对它不做修改的字符串函数</span>.</p> 
<p><span style="color:#9c8ec1">有点晕哈，宝子，你细品，品不出来就往下看，看完回头，会明朗许多。</span></p> 
<hr> 
<h1 id="strlen%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B">strlen​​​​​​​</h1> 
<p><img alt="" height="221" src="https://images2.imgbox.com/61/fd/aAB4vzLB_o.png" width="634"></p> 
<blockquote> 
 <h3 id="const">const</h3> 
 <p><span style="color:#9c8ec1">它在这个代码中的作用是保证str不变，定死了的。</span></p> 
 <p>const是一个C语言（ANSI C）的关键字，具有着举足轻重的地位。它限定一个<span style="background-color:#fbd4d0">变量不允许被改变</span>，产生静态作用。使用const在一定程度上可以提高程序的安全性和可靠性。另外，在观看别人代码的时候，清晰理解const所起的作用，对理解对方的程序也有一定帮助。 </p> 
</blockquote> 
<blockquote> 
 <p>strlen的作用和sizeof很像，C语言中strlen 函数用来<span style="color:#0d0016"><strong><span style="background-color:#fbd4d0">求字符串的长度</span></strong><span style="background-color:#fbd4d0">（</span></span>包含多少个字符）。</p> 
 <p>注意事项：</p> 
 <ul>
<li>字符串已经<span style="background-color:#fbd4d0"> '' 作为结束标志</span>，strlen函数返回的是在字符串中 '' 前面出现的字符个数（<span style="background-color:#fbd4d0">不包 含 '' )。</span>
</li>
<li>参数指向的字符串必须要以 '' 结束。</li>
<li>注意函数的返回值为size_t，是<span style="background-color:#fbd4d0">无符号的</span>（ 易错 ）</li>
</ul> 
</blockquote> 
<h3 id="strlen%E7%9A%84%E5%BA%94%E7%94%A8">strlen的应用</h3> 
<pre><code class="hljs">#include &lt;stdio.h&gt;
int main()
{
 const char*str1 = "abcdef";
 const char*str2 = "bbb";
 if(strlen(str2)-strlen(str1)&gt;0)
 {
 printf("str2&gt;str1n");
 } 
 else
 {
 printf("srt1&gt;str2n");
 }
 return 0;
}</code></pre> 
<h3 id="strlen%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strlen的模拟实现</h3> 
<p><img alt="" height="682" src="https://images2.imgbox.com/52/70/n2w1km2S_o.png" width="548"></p> 
<blockquote> 
 <h3 id="assert">assert</h3> 
 <p><span style="color:#9c8ec1">它在这个代码中的作用是保证str不能等于零。</span></p> 
 <p>编写代码时，我们总是会做出一些<a href="https://baike.baidu.com/item/%E5%81%87%E8%AE%BE/1524526?fromModule=lemma_inlink" title="假设">假设</a>，断言就是用于在代码中捕捉这些假设，可以将断言看作是<a href="https://baike.baidu.com/item/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/6250107?fromModule=lemma_inlink" title="异常处理">异常处理</a>的一种高级形式。断言表示为一些<a href="https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/1574380?fromModule=lemma_inlink" title="布尔表达式">布尔表达式</a>，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言，而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新启用断言。使用断言可以创建更稳定，品质更好且不易于出错的代码。</p> 
</blockquote> 
<hr> 
<h1 id="strcpy">strcpy</h1> 
<pre><code class="hljs">char* strcpy(char * destination, const char * source )
//destination是一个英语单词，名词，作名词时意为“目的地，终点”。（结果）
//source是一个英语单词，解释是（河的）源头；水源，引申意思为出处等意思。（输入值）</code></pre> 
<blockquote> 
 <p>strcpy，即string copy（字符串复制）的缩写。</p> 
 <p>strcpy是<a href="https://baike.baidu.com/item/C%2B%2B/99272?fromModule=lemma_inlink" title="C++">C++</a>语言的一个标准函数 <a name="ref_%5B1%5D_1026861"> </a> ，strcpy把含有<a href="https://baike.baidu.com/item/%27%5C0%27/9931274?fromModule=lemma_inlink" title="''">''</a>结束符的字符串复制到另一个<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4?fromModule=lemma_inlink" title="地址空间">地址空间</a>，返回值的类型为char*。</p> 
 <p>在<a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/1814181?fromModule=lemma_inlink" title="C语言函数">C语言函数</a>中：</p> 
 <p>原型声明：char *strcpy(char* dest, const char *src);</p> 
 <p>头文件：#include &lt;<a href="https://baike.baidu.com/item/string.h?fromModule=lemma_inlink" title="string.h">string.h</a>&gt; 和 #include &lt;stdio.h&gt;</p> 
 <p>功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4?fromModule=lemma_inlink" title="地址空间">地址空间</a></p> 
 <p>说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。</p> 
 <p>返回指向dest的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink" title="指针">指针</a>。</p> 
 <p>注意事项：</p> 
 <ul>
<li>将源指向的 C 字符串复制到目标指向的数组中，包括终止空字符（并在该点停止）</li>
<li>源字符串必须以 '' 结束。</li>
<li>会将源字符串中的 '' 拷贝到目标空间。</li>
<li>目标空间必须足够大，以确保能存放源字符串。</li>
<li>目标空间必须可变。</li>
</ul> 
</blockquote> 
<h3 id="strcpy%E7%9A%84%E5%BA%94%E7%94%A8">strcpy的应用</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;


int main()
{
	char arr1[20] = "";
	//char* p = "abcdefghiqwer";
	char arr2[] = "hello bit";
	my_strcpy(arr1, arr2);
	printf("%sn", arr1);
	return 0;
}</code></pre> 
<h3 id="strcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strcpy的模拟实现</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;

char* my_strcpy(char* dest, const char* src)
{
	char* ret = dest;
	assert(dest &amp;&amp; src);
	while (*dest++ = *src++)
	{
		;
	}
	return ret;
}

int main()
{
	char arr1[20] = "";
	//char* p = "abcdefghiqwer";
	char arr2[] = "hello bit";
	my_strcpy(arr1, arr2);
	printf("%sn", arr1);
	return 0;
}
</code></pre> 
<hr> 
<h1 id="strcat">strcat</h1> 
<pre><code class="hljs">char * strcat ( char * destination, const char * source )</code></pre> 
<blockquote> 
 <p>strcat</p> 
 <p>原型</p> 
 <p>extern char *strcat(char *dest, const char *src);</p> 
 <p>用法</p> 
 <p>#include &lt;string.h&gt;</p> 
 <p>头文件</p> 
 <p>在C中，函数原型存在 &lt;string.h&gt;头文件中。</p> 
 <p>在C++中，则存在于&lt;cstring&gt;头文件中。</p> 
 <p>功能</p> 
 <p>把src所指向的字符串（包括“”）复制到dest所指向的字符串后面（删除*dest原来末尾的“”）。要保证*dest足够长，以容纳被复制进来的*src。*src中原有的字符不变。返回指向dest的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink" title="指针">指针</a>。</p> 
 <p>举个栗子</p> 
 <p>将两个<a href="https://baike.baidu.com/item/char/5156054?fromModule=lemma_inlink" title="char">char</a>类型连接。</p> 
 <p>例如：</p> 
 <p>char d[20]="Golden";</p> 
 <p>char s[20]="View";</p> 
 <p>strcat(d,s);</p> 
 <p>//打印d</p> 
 <p>printf("%s",d);</p> 
 <p>输出 d 为 GoldenView （中间无空格）</p> 
 <p>d和s所指内存区域<span style="background-color:#fbd4d0">不可以重叠</span>且d<span style="background-color:#fbd4d0">必须有足够的空间</span>来容纳s的字符串。</p> 
 <p>返回指向d的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304?fromModule=lemma_inlink" title="指针">指针</a>。</p> 
 <ul>
<li>Appends a copy of the source string to the destination string. The terminating null character in destination is overwritten by the first character of source, and a null-character is included at the end of the new string formed by the concatenation of both in destination.（翻译：将源字符串的副本追加到目标字符串。目标中的终止空字符被源的第一个字符覆盖，并且在目标中由两者串联形成的新字符串的末尾包含一个空字符。)</li>
<li>源字符串必须以 '' 结束。</li>
<li>目标空间必须有足够的大，能容纳下源字符串的内容。</li>
<li>目标空间必须可修改。 字符串自己给自己追加，如何？会出现错误，重复，达不到预期效果</li>
</ul> 
</blockquote> 
<h3 id="strcat%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strcat的应用及模拟实现</h3> 
<pre><code class="hljs">char* my_strcat(char* dest, const char* src)
{
	assert(dest &amp;&amp; src);
	char* ret = dest;

	//1. 找目标空间的
	while (*dest)
	{
		dest++;
	}
	//2. 追加
	while (*dest++ = *src++)
	{
		;
	}
	return ret;
}

int main()
{
	char arr[20] = "hello ";
	//char arr2[] = "world";
	char* p = "world";
	my_strcat(arr, p);

	printf("%sn", arr);

	return 0;
}</code></pre> 
<hr> 
<h1 id="strcmp">strcmp</h1> 
<pre><code class="hljs">int strcmp ( const char * str1, const char * str2 )</code></pre> 
<blockquote> 
 <p>strcmp<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912?fromModule=lemma_inlink" title="函数">函数</a>是string compare(字符串比较)的缩写，用于比较两个字符串并根据比较结果返回整数。基本形式为strcmp(str1,str2)，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。</p> 
 <p>当s1&lt;s2时，返回为负数；</p> 
 <p>当s1=s2时，返回值= 0；</p> 
 <p>当s1&gt;s2时，返回正数。 </p> 
 <p>即：两个<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6?fromModule=lemma_inlink" title="字符">字符</a>串自左向右逐个字符相比（<span style="background-color:#fbd4d0">按ASCII值大小相比较</span>），直到出现不同的字符或遇''为止。</p> 
 <p>注意事项：</p> 
 <ul>
<li>This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached.（翻译：此函数开始比较每个字符串的第一个字符。如果它们彼此相等，则继续以下对，直到字符不同或达到终止空字符。）</li>
<li>标准规定：</li>
</ul> 
 <p>第一个字符串大于第二个字符串，则返回大于0的数字</p> 
 <p>第一个字符串等于第二个字符串，则返回0</p> 
 <p>第一个字符串小于第二个字符串，则返回小于0的数字</p> 
</blockquote> 
<h3 id="strcmp%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strcmp的应用及模拟实现</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;

int my_strcmp(const char* str1, const char* str2)
{
	assert(str1 &amp;&amp; str2);
	while (*str1 == *str2)
	{
		if (*str1 == '')
			return 0;
		str1++;
		str2++;
	}
	/*if (*str1 &gt; *str2)
		return 1;
	else
		return -1;*/
	return *str1 - *str2;
}


int main()
{
	char arr1[] = "abq";
	char arr2[] = "abcdef";
	//VS环境下：
	//&gt; 1 
	//= 0 
	//&lt; -1
	int ret = my_strcmp(arr1, arr2);

	if (ret &gt; 0)
		printf("arr1&gt;arr2n");

	printf("%dn", ret);

	return 0;
}
</code></pre> 
<hr> 
<p><span style="color:#9c8ec1">接下来三个多“n”的库函数，用法是和前面几个函数一样的，唯独区别就是使用参数上，可以规定作用到具体的字符</span></p> 
<h1 id="strncpy">str<span style="color:#fe2c24">n</span>cpy</h1> 
<p><img alt="" height="41" src="https://images2.imgbox.com/ba/71/Yw0VJyoc_o.png" width="728"></p> 
<blockquote> 
 <p>注意事项：</p> 
 <ul>
<li>Copies the first num characters of source to destination. If the end of the source C string (which is signaled by a null-character) is found before num characters have been copied, destination is padded with zeros until a total of num characters have been written to it.（翻译：将源的第一个字符数复制到目标。如果在复制 num 个字符之前找到源 C 字符串的末尾（由 null 字符表示），则目标将填充零，直到总共写入 num 个字符为止。）</li>
<li>拷贝num个字符从源字符串到目标空间。</li>
<li>如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。</li>
</ul> 
</blockquote> 
<h3 id="strncpy%E7%9A%84%E5%BA%94%E7%94%A8">str<span style="color:#fe2c24">n</span>cpy的应用</h3> 
<p><span style="color:#9c8ec1">建议调试，用监视窗口看更明显</span></p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;

 int main()
{
	char arr1[20] = "xxxxxxxxxxxxxx";
	strncpy(arr1, "abcdef", 10);
	printf("%sn", arr1);
	return 0;
}</code></pre> 
<hr> 
<h1 id="strncat">str<span style="color:#fe2c24">n</span>cat</h1> 
<pre><code class="hljs">char * strncat ( char * destination, const char * source, size_t num )</code></pre> 
<blockquote> 
 <p>Appends the first num characters of source to destination, plus a terminating null-character. If the length of the C string in source is less than num, only the content up to the terminating null-character is copied（翻译：将源的第一个数字字符追加到目标，外加一个终止空字符。如果源中 C 字符串的长度小于 num，则仅复制终止空字符之前的内容）</p> 
</blockquote> 
<h3 id="strncat%E7%9A%84%E5%BA%94%E7%94%A8">strncat的应用</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
//#include &lt;assert.h&gt;
#include &lt;string.h&gt;
int main()
{
	char arr1[20] = "abcxxxxxxxx";
	strncat(arr1, "defqwer", 4);
	printf("%sn", arr1);

	return 0;
}
</code></pre> 
<p><span style="color:#9c8ec1">变化有点小，要仔细看哦，最好从监视窗口看，会很不错。</span></p> 
<hr> 
<h1 id="strncmp">str<span style="color:#fe2c24">n</span>cmp</h1> 
<pre><code class="hljs">int strncmp ( const char * str1, const char * str2, size_t num )</code></pre> 
<blockquote> 
 <p>比较到出现另个字符不一样或者一个字符串结束或者num个字符全部比较完。</p> 
</blockquote> 
<p><img alt="" height="121" src="https://images2.imgbox.com/1b/78/vn1jshRq_o.png" width="606"></p> 
<h3 id="strncmp%E7%9A%84%E5%BA%94%E7%94%A8">strncmp的应用</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
//#include &lt;assert.h&gt;
#include &lt;string.h&gt;
int main()
{
	char* p1 = "abcdef";
	char* p2 = "abcqwer";
	int ret = strncmp(p1, p2, 4);
	printf("%dn", ret);
	return 0;
}</code></pre> 
<hr> 
<h1 id="strstr">strstr</h1> 
<pre><code class="hljs">char * strstr ( const char *str1, const char * str2)</code></pre> 
<blockquote> 
 <p>strstr</p> 
 <p>strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回 str1字符串从 str2第一次出现的位置开始到 str1结尾的字符串；否则，返回NULL。</p> 
 <p>函数原型：string strstr( string1，string2)</p> 
 <p>功能：strstr返回一个指针，指向string2在string1中首次出现的位置。 </p> 
 <p>返回类型：字符串类型</p> 
 <p>Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1.（翻译：返回指向 str1 中第一次出现的 str2 的指针，如果 str2 不是str1.）</p> 
 <p><span style="color:#9c8ec1">有点乱哈，它的作用就是str2是否在str1里重复</span></p> 
</blockquote> 
<h3 id="strstr%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strstr的应用及模拟实现</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
char* my_strstr(const char* str1, const char* str2)
{
	assert(str1 &amp;&amp; str2);
	if (*str2 == '')
	{
		return (char*)str1;
	}
	const char* s1 = NULL;
	const char* s2 = NULL;
	const char* cp = str1;

	while (*cp)
	{
		s1 = cp;
		s2 = str2;
		while (*s1 !='' &amp;&amp; *s2!='' &amp;&amp; *s1 == *s2)
		{
			s1++;
			s2++;
		}
		if (*s2 == '')
		{
			return (char*)cp;
		}
		cp++;
	}

	return NULL;
}

int main()
{
	char arr1[] = "abbbcdbbcef";
	char arr2[] = "bbc";
	char* ret = my_strstr(arr1, arr2);

	if (ret == NULL)
	{
		printf("找不到n");
	}
	else
	{
		printf("%sn", ret);
	}

	return 0;
}
</code></pre> 
<hr> 
<h1 id="strtok">strtok</h1> 
<pre><code class="hljs">char * strtok ( char * str, const char * sep )</code></pre> 
<blockquote> 
 <p>原型：</p> 
 <p>char *strtok(char s[], const char *delim);</p> 
 <p><a name="2"></a>功能：</p> 
 <p>strtok()用来将字符串分割成一个个片段。参数s指向欲分割的<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6?fromModule=lemma_inlink" title="字符">字符</a>串，参数delim则为分割字符串中包含的所有字符。</p> 
 <p>例如：strtok("abc,def,ghi",",")，最后可以分割成为abc def ghi.尤其在点分十进制的IP中提取应用较多。</p> 
 <p>strtok的函数原型为char *strtok(char *s, char *delim)，功能为“Parse S into tokens separated by characters in DELIM.If S is NULL, the saved pointer in SAVE_PTR is used as the next starting point. ” 翻译成汉语就是：作用于字符串s，以包含在delim中的字符为分界符，将s切分成一个个子串；如果，s为空值NULL，则函数保存的指针SAVE_PTR在下一次调用中将作为起始位置。</p> 
 <p><a name="3"></a><a name="sub1028553_3"></a><a name="%E8%AF%B4%E6%98%8E"></a>说明</p> 
 <p>strtok()用来将字符串分割成一个个片段。参数s指向欲分割的<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6?fromModule=lemma_inlink" title="字符">字符</a>串，参数delim则为分割字符串中包含的所有字符。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时,则会将该字符改为 字符。在第一次调用时，strtok()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回指向被分割出片段的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink" title="指针">指针</a>。</p> 
 <p><a name="4"></a><a name="sub1028553_4"></a><a name="%E8%BF%94%E5%9B%9E%E5%80%BC"></a>返回值：</p> 
 <p>从s开头开始的一个个被分割的串。当s中的字符查找到末尾时，返回NULL。</p> 
 <p>如果查找不到delim中的字符时，返回当前strtok的字符串的指针。</p> 
 <p>所有delim中包含的字符都会被滤掉，并将被滤掉的地方设为一处分割的节点。</p> 
 <p>注意事项：</p> 
 <ul>
<li>sep参数是个字符串，定义了用作分隔符的字符集合</li>
<li>第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标 记</li>
<li>strtok函数找到str中的下一个标记，并将其用  结尾，返回一个指向这个标记的指针。（注： strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容 并且可修改。）</li>
<li>strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串 中的位置。</li>
<li>strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标 记。</li>
<li>如果字符串中不存在更多的标记，则返回 NULL 指针</li>
</ul> 
</blockquote> 
<h3 id="strtok%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strtok的应用及模拟实现</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 int main()
{
	char arr[] = "miaomiao@yeah.net";//"@."
	char arr[] = "192#168.120.85";
	char* p = "#.";
	char buf[20] = { 0 };
	strcpy(buf, arr);
	char* ret = NULL;
	for (ret = strtok(buf, p); ret != NULL; ret=strtok(NULL, p))
	{
		printf("%sn", ret);
	}
	
	/*char* ret = strtok(buf, p);
	printf("%sn", ret);
	ret = strtok(NULL, p);
	printf("%sn", ret);
	ret = strtok(NULL, p);
	printf("%sn", ret);*/
	return 0;
}</code></pre> 
<hr> 
<h1 id="strerror">strerror</h1> 
<pre><code class="hljs">char * strerror ( int errnum )</code></pre> 
<blockquote> 
 <p>strerror</p> 
 <p>通过标准错误的标号，获得错误的描述字符串 ，将单纯的错误标号转为字符串描述，方便用户查找错误。</p> 
 <p>函数名：</p> 
 <p>strerror, _strerror, _wcserror, __wcserror</p> 
 <p><a name="sub2015157_2"></a><a name="%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8"></a>函数作用：</p> 
 <p>Get a system error message (strerror, _wcserror) or prints a user-supplied error message (_strerror, __wcserror).</p> 
 <p>获取系统错误信息或打印用户<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF?fromModule=lemma_inlink" title="程序错误">程序错误</a>信息。</p> 
 <p><a name="sub2015157_3"></a><a name="%E5%A4%B4%E6%96%87%E4%BB%B6"></a>头文件：</p> 
 <p>#include &lt;errno.h&gt;</p> 
 <p>#include &lt;string.h&gt;</p> 
</blockquote> 
<p>strerror的应用</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
//C语言的库函数在运行的时候，如果发生错误，就会将错误码存在一个变量中，这个变量是：errno
//错误码是一些数字：1 2 3 4 5 
//我们需要讲错误码翻译成错误信息
//
int main()
{
	printf("%sn", strerror(0));
	printf("%sn", strerror(1));
	printf("%sn", strerror(2));
	printf("%sn", strerror(3));
	printf("%sn", strerror(4));
	printf("%sn", strerror(5));

	return 0;
}</code></pre> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 #include &lt;errno.h&gt;

int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		//printf("%sn", strerror(errno));
		perror("fopen");
		return 1;
	}
	//读文件
	//关闭文件
	fclose(pf);
	pf = NULL;

	return 0;
}

</code></pre> 
<hr> 
<h1 id="%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0">字符分类函数</h1> 
<blockquote> 
 <p>函数               如果他的参数符合下列条件就返回真</p> 
 <p>iscntrl             任何控制字符</p> 
 <p>isspace          空白字符：空格‘ ’，换页‘f’，换行'n'，回车‘r’，制表符't'或者垂直制表符'v' isdigit             十进制数字 0~9</p> 
 <p>isxdigit           十六进制数字，包括所有十进制数字，小写字母a~f，大写字母A~F</p> 
 <p>islower           小写字母a~z</p> 
 <p>isupper          大写字母A~Z</p> 
 <p>isalpha           字母a~z或A~Z</p> 
 <p>isalnum          字母或者数字，a~z,A~Z,0~9</p> 
 <p>ispunct           标点符号，任何不属于数字或者字母的图形字符（可打印） isgraph 任何图形                        字符</p> 
 <p>isprint             任何可打印字符，包括图形字符和空白字符</p> 
</blockquote> 
<p><span style="color:#9c8ec1">这几个函数使用方法是一样的。</span></p> 
<h3 id="%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A"><span style="color:#0d0016">字符分类函数的应用：</span></h3> 
<pre><code class="hljs">#include &lt;string.h&gt;
 #include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
int main()
{
	char arr[] = "I Have An Apple.";
	int i = 0;
	while (arr[i])
	{
		if (isupper(arr[i]))
		{
			arr[i] = tolower(arr[i]);
		}
		printf("%c", arr[i]);
		i++;
	}
	return 0;
}

</code></pre> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 #include &lt;errno.h&gt;
#include &lt;ctype.h&gt;

int main()
{
	int ret = isdigit('Q');
	printf("%dn", ret);

	return 0;
}</code></pre> 
<blockquote> 
 <h3 id="%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%EF%BC%9A%C2%A0%C2%A0">字符转换：  </h3> 
 <p>int tolower ( int c )</p> 
 <p>int toupper ( int c )</p> 
</blockquote> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 #include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
int main()
{
	printf("%cn", toupper('a'));
	printf("%cn", tolower('A'));

	return 0;
}</code></pre> 
<hr> 
<h1 id="memcpy">memcpy</h1> 
<pre><code class="hljs">void * memcpy ( void * destination, const void * source, size_t num )</code></pre> 
<blockquote> 
 <p>memcpy</p> 
 <p>memcpy指的是C和C++使用的内存拷贝函数，函数原型为void *memcpy(void *destin, void *source, unsigned n)；函数的功能是从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中，即从源source中拷贝n个字节到目标destin中。</p> 
 <p>参数：</p> 
 <ul>
<li> <p><strong>destin</strong>-- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</p> </li>
<li> <p><strong>source</strong>-- 指向要复制的数据源，类型强制转换为 void* 指针。</p> </li>
<li> <p><strong>n</strong>-- 要被复制的字节数。</p> </li>
</ul> 
 <p><a name="1_3"></a><a name="sub736225_1_3"></a><a name="1-3"></a>返回值：</p> 
 <p>该函数返回一个指向目标存储区<strong>destin</strong>的指针。</p> 
 <p><a name="1_4"></a><a name="sub736225_1_4"></a><a name="%E5%8A%9F%E8%83%BD"></a><a name="1-4"></a>功能：</p> 
 <p>从源<strong>source</strong>所指的内存地址的起始位置开始拷贝n个字节到目标<strong>destin</strong>所指的内存地址的起始位置中。 <a name="ref_2"></a></p> 
 <p><a name="1_5"></a><a name="sub736225_1_5"></a><a name="%E6%89%80%E9%9C%80%E5%A4%B4%E6%96%87%E4%BB%B6"></a><a name="1-5"></a>头文件：</p> 
 <p>C语言：#include&lt;string.h&gt;</p> 
 <p>C++：#include&lt;cstring&gt;</p> 
 <p>注意事项：</p> 
 <ul>
<li>函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置。</li>
<li>这个函数在遇到 '' 的时候并不会停下来。</li>
<li>如果source和destination有任何的重叠，复制的结果都是未定义的。</li>
</ul> 
</blockquote> 
<p>memcpy的应用</p> 
<pre><code class="hljs">/* memcpy example */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
struct {
  char name[40];
  int age;
} person, person_copy;
int main ()
{
  char myname[] = "Pierre de Fermat";
  /* using memcpy to copy string: */
  memcpy ( person.name, myname, strlen(myname)+1 );
  person.age = 46;
  /* using memcpy to copy structure: */
  memcpy ( &amp;person_copy, &amp;person, sizeof(person) );
  printf ("person_copy: %s, %d n", person_copy.name, person_copy.age );
  return 0;
}</code></pre> 
<h3 id="memcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">memcpy的模拟实现</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 #include &lt;errno.h&gt;
#include &lt;ctype.h&gt;

void* my_memcpy(void* dest, const void* src, size_t num)
{
	void* ret = dest;
	assert(dest &amp;&amp; src);
	//前-&gt;后
	while (num--)
	{
		*(char*)dest = *(char*)src;
		dest = (char*)dest + 1;
		src = (char*)src + 1;
	}
	return ret;
}
int main()
{
	int arr1[] = { 1,2,3,4,5,6,7,8,9,10 };
	int arr2[10] = { 0 };
	//内存拷贝-memcpy
	//    int*   int*
	my_memcpy(arr2, arr1 + 2, 17);
	//01 00 00 00 02 00 00 00 03 00 00 00
}

</code></pre> 
<hr> 
<h1 id="memmove">memmove</h1> 
<pre><code class="hljs">void * memmove ( void * destination, const void * source, size_t num )</code></pre> 
<blockquote> 
 <p>memmove</p> 
 <p>memmove用于拷贝字节，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。</p> 
 <p>头文件：&lt;string.h&gt;</p> 
 <p>功能：由src所指内存区域复制count个字节到dest所指内存区域。</p> 
 <p>注意事项：</p> 
 <ul>
<li>和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的。</li>
<li>如果源空间和目标空间出现重叠，就得使用memmove函数处理</li>
</ul> 
</blockquote> 
<h3 id="memmove%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">memmove的应用及模拟实现</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 #include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
void* my_memmove(void* dest, const void* src, size_t num)
{
	void* ret = dest;
	assert(dest &amp;&amp; src);
	if (dest &lt; src)
	{
		//前--&gt;后
		while (num--)
		{
			*(char*)dest = *(char*)src;
			dest = (char*)dest + 1;
			src = (char*)src + 1;
		}
	}
	else
	{
		//后-&gt;前
		while (num--)
		{
			*((char*)dest + num) = *((char*)src + num);
		}
	}

	return ret;
}

void test3()
{
	int arr1[] = { 1,2,3,4,5,6,7,8,9,10 };
	my_memmove(arr1+2, arr1, 20);
}
int main()
{
	test3();
	return 0;
}
</code></pre> 
<hr> 
<h1 id="memcmp">memcmp</h1> 
<pre><code class="hljs">int memcmp ( const void * ptr1, const void * ptr2, size_t num )</code></pre> 
<blockquote> 
 <p>memcmp：</p> 
 <p>memcmp函数的原型为 int memcmp(const void *str1, const void *str2, size_t n);其功能是把存储区 str1 和存储区 str2 的前 n 个字节进行比较。该函数是按<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82/1096318?fromModule=lemma_inlink" title="字节">字节</a>比较的，位于string.h。</p> 
 <p>注意事项：</p> 
 <ul>
<li>比较从ptr1和ptr2指针开始的num个字节</li>
<li>返回值如下：</li>
<li>如果返回值 &lt; 0，则表示 str1 小于 str2。</li>
<li> <p>如果返回值 &gt; 0，则表示 str2 小于 str1。</p> </li>
<li> <p>如果返回值 = 0，则表示 str1 等于 str2。</p> </li>
</ul> 
</blockquote> 
<p>memcmp的应用</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 #include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
int main()
{
	int arr1[] = { 1,2,6 };//01 00 00 00 02 00 00 00 06 00 00 00
	int arr2[] = { 1,2,5 };//01 00 00 00 02 00 00 00 05 00 00 00
	int ret = memcmp(arr1, arr2, 9);
	printf("%dn", ret);

	return 0;
}</code></pre> 
<h3 id="memcmp%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%88VS%E4%B8%8B%E8%BF%9B%E8%A1%8C%EF%BC%89">memcmp的模拟实现（VS下进行）</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 #include &lt;errno.h&gt;
#include &lt;ctype.h&gt;

void test4()
{
	int arr1[] = { 1,2,3,4,5,6,7,8,9,10 };
	memcpy(arr1, arr1+2, 20);
}

int main()
{
	test4();
	return 0;
}
</code></pre> 
<hr> 
<h1 id="memset">memset</h1> 
<pre><code class="hljs">void *memset(void *s, int ch, size_t n)</code></pre> 
<blockquote> 
 <p>memset</p> 
 <p>memset是计算机中<a href="https://baike.baidu.com/item/C/7252092?fromModule=lemma_inlink" title="C">C</a>/<a href="https://baike.baidu.com/item/C%2B%2B/99272?fromModule=lemma_inlink" title="C++">C++</a>语言初始化函数。作用是将某一块<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614?fromModule=lemma_inlink" title="内存">内存</a>中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。</p> 
</blockquote> 
<h3 id="memset%E7%9A%84%E5%BA%94%E7%94%A8">memset的应用</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 #include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
//memset - 内存设置函数
//以字节为单位来设置内存中的数据的

int main()
{
	char arr[] = "hello world";
	memset(arr, 'x', 5);
	printf("%sn", arr);
	memset(arr+6, 'y', 5);
	printf("%sn", arr);

	/*int arr[10] = { 0 };
	memset(arr, 0, 40);*/

	return 0;
}</code></pre> 
<hr> 
<h1 id="%E6%80%BB%E7%BB%93">总结</h1> 
<blockquote> 
 <p>啊，要猫命啦，一万多字成为基操，但小喵还是有些不满意的地方，懒了懒了，给宝子说明一下，第一，头文件没有准确使用，嘿嘿，有用没用，小喵都写上了，粘贴的嘛，是有些粗糙，给宝子打个预防针。第二就是各个函数的模拟实现，小喵没有细讲，罪过罪过，很虚，希望宝子可以看懂代码。其他的话，可能会出现前言不搭后语的情况，重复的情况，粘贴的嘛，拼了好几处的内容。罪过罪过，希望不影响食用。</p> 
 <p>这些库函数，能用净量使用，可以使代码更加简洁，美观。还有很多库函数没有学习，这些只是一角，宝子在<a class="link-info" href="https://legacy.cplusplus.com/reference/" title="cplusplus">cplusplus</a>（点开看看）上学习吧！</p> 
 <p>啊哒，希望这篇不下6小时的博客可以真的帮到你，有什么不对头的地方，麻烦评论区Q下小喵，改改改，喵呜。</p> 
 <p>宝子，好久不见，十分想念，喵~</p> 
</blockquote> 
<hr> 
<p> <span style="color:#fe2c24">宝子，你不点个赞吗？不评个论吗？不收个藏吗？</span></p> 
<p><span style="color:#fe2c24">最后的最后，关注我，关注我，关注我，你会看到更多有趣的博客哦！！！</span></p> 
<p><span style="color:#fe2c24">喵喵喵，你对我真的很重要。</span></p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/3b/5c/pOc4ktqi_o.jpg"></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>