<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>区块链原理(笔记) - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">区块链原理(笔记)</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <h2>
<a id="_0"></a>数据存储：分布式记账</h2> 
<h4>
<a id="_1"></a>竞争记账是什么</h4> 
<blockquote> 
 <p>是比特币系统的记账方式，，解决了如何在去中心化的记账系统中保证比特币系统账本一致性的问题。<br> 解释：在比特币网络中，全网矿工共同参与算了竞争，算力高的矿工计算能力更强，更容易获得记账权，成功抢到记账权的矿工负责记账，并将账本信息同步给整个网络，作为回报，矿工将获得系统新生成的比特币1作为奖励。</p> 
</blockquote> 
<h4>
<a id="_5"></a>分布式记账</h4> 
<h5>
<a id="_6"></a>定义</h5> 
<blockquote> 
 <p>分布式记账技术是分布在多个计算机节点上的数据库，每个节点都可以复制并保存一个账本，且每个计算机都可以进行独立更新。它的特征是账本不由任何中央机构维护，而是由每个计算机节点独立构建和记录。在对新帐本进行投票后，又称为共识机制，一旦达成，分布式账本就会自行更新。</p> 
</blockquote> 
<h5>
<a id="_9"></a>优势</h5> 
<blockquote> 
 <p>在区块链中，系统的每一个人都有机会进行记账，系统会评判这段时间内记账最快、最好的人，将其记录的内容写到账本里，并发送给系统内的其他人进行备份，这样系统里的每一个人都有一本完整的账本。篡改者需要同时修改超过半数的系统节点数据才能真正的篡改数据，这种篡改的代价极高，导致几乎不可能。</p> 
</blockquote> 
<h2>
<a id="_12"></a>公链记账：挖矿与奖励</h2> 
<h4>
<a id="_13"></a>挖矿是什么</h4> 
<blockquote> 
 <p>挖矿是将一段时间内比特币系统中比特币系统发生的交易进行确认并记录在区块链上形成新区块的过程，简单的说挖矿就是记账的过程。通过奖励系统新生比特币来激励矿工挖矿，因此挖矿就是生成比特币的过程。</p> 
</blockquote> 
<h4>
<a id="_16"></a>比特币怎么挖矿</h4> 
<blockquote> 
 <p>每10分钟，全网一起计算一道算术题，先算出答案的相当于挖到了这个区块，该矿工便能获得新产生的比特币。随着比特币的价值升高，挖矿人数增多，挖矿难度成指数级上升，大家开始用矿机挖矿，但比特币网络算力太大，个人购置矿机也难以挖矿。于是很多矿工加入矿池一起挖矿。矿场负责计算，矿池负责信息打包，矿池挖到比特币之后根据矿场的算力占比分配收益。</p> 
</blockquote> 
<h2>
<a id="_19"></a>交易支付：代币交易</h2> 
<h4>
<a id="_20"></a>比特币交易与找零</h4> 
<blockquote> 
 <p>比特币转账可以一次把多个地址的余额转出或者一次转向多个地址(后者需要告知矿工，否则剩余比特币可能会给矿工当手续费)</p> 
</blockquote> 
<h4>
<a id="_23"></a>一个交易的生命周期</h4> 
<blockquote> 
 <p>1、某人发出请求<br> 2、广播交易到p2p网络<br> 3、矿工验证交易正确性<br> 4、多个交易组成一个区块<br> 5、新的区块加入到一个已经存在的区块链中<br> 6、交易完成</p> 
</blockquote> 
<h2>
<a id="_31"></a>系统奖励：交易币基</h2> 
<h4>
<a id="Q_32"></a>比特币和Q币</h4> 
<blockquote> 
 <p>比特币是一种去中心化的数字资产，没有发行主体。Q币是由腾讯公司发行的电子货币，类似电子积分，实际上不是货币，Q币由于腾讯的信用背书而被认可，Q币的价值完全取决于人们对腾讯公司的信任。</p> 
</blockquote> 
<h4>
<a id="_35"></a>交易币基</h4> 
<p>交易信息前几个字节表示的是该区块包含的交易数量，交易数量类型采用的是一种压缩尺寸的变长整形，并且每个区块第一个交易规定为coinbase交易。</p> 
<ul>
<li>Coinbase交易结构<br> <img src="https://images2.imgbox.com/70/16/fbeuluZI_o.png" alt="在这里插入图片描述">
</li>
<li>交易输入结构</li>
</ul> 
<blockquote> 
 <p>Coinbase的交易输入格式经过数次改变，在高度227836之前遵从的区块版本号为1.<br> <img src="https://images2.imgbox.com/3f/2f/cq7WJEw3_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ul><li>交易输出结构<br> <img src="https://images2.imgbox.com/14/fc/y73EUGLN_o.png" alt="在这里插入图片描述">
</li></ul> 
<h2>
<a id="Merkle_45"></a>溯源的基础:Merkle</h2> 
<h3>
<a id="Merkle_46"></a>什么是Merkle树</h3> 
<blockquote> 
 <p>顾名思义，Merkel Tree就是存储hash值的一棵树，树的的叶子是数据块的hash值，非叶子节点的是其对应子节点的hash.</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/03/b6/2dRIaHul_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="Merkle_51"></a>Merkle树结构</h3> 
<h4>
<a id="Hash_52"></a>Hash</h4> 
<blockquote> 
 <p>Hash是把任意长度的数据映射成固定长度的数据的函数。例如，对于数据完整性校验，最简单的方法是对整个数据做Hash运算得到固定长度的Hash值，然后把得到的Hash值公布在网上，这样用户下载到数据之后，对数据再次进行Hash运算，比较运算结果和网上公布的Hash值进行比较，如果两个Hash值相等，说明下载的数据没有损坏。并且，根据Hash值反推原始数据的特征是困难的。</p> 
</blockquote> 
<h4>
<a id="Hash_List_55"></a>Hash List</h4> 
<blockquote> 
 <p>在点对点网络中作数据传输的时候，会同时从多个机器上下载数据，而且很多机器可以认为是不稳定或者不可信的。为了校验数据的完整性，更好的办法是把大的文件分割成小的数据块。这样的好处是，如果小块数据在传输过程中损坏了，那么只要重新下载这一快数据就行了，不用重新下载整个文件。那我们是如何确定小的数据块有没有损坏?<br> 在下载数据的时候，我们首先会从可信源得到正确的根Hash,然后将每一小块数据的Hash值拼到一起，然后对这个长字符串在做一次Hash，与根的Hash进行对比校验。</p> 
</blockquote> 
<h4>
<a id="Merkle_Tree_59"></a>Merkle Tree</h4> 
<blockquote> 
 <p>我们从叶子节点出发，将底层两个相邻的哈希并成一个并进行哈希运算，得到子哈希，一层层向上推，如果有一层是单数的情况下就会有一个遗漏的，这个遗漏的就直接进行哈希运算，最终形成一棵倒挂的树，到了树根的位置就会有一个根哈希，称作Merkle Root.</p> 
</blockquote> 
<p>在p2p网络下载网络之前，先从可信的源获得文件的MerkleTree树根。一旦获得了树根，就可以从其他从不可信的源获取Merkletree。通过可信的树根来检查接受到的MerkleTree。如果MerkleTree是损坏的或者虚假的，就从其他源获得另一个MerkleTree，直到获得一个与可信树根匹配的MerkleTree。</p> 
<h4>
<a id="MerkleTreeHashList_64"></a>MerkleTree和HashList的主要区别是</h4> 
<blockquote> 
 <p>Merkle可以直接下载并立即验证Merkle Tree的一个分支，因为可以将文件分成小的数据块，这样如果有一块数据损坏，仅仅重新下载这个数据块即可，Merkletree可以一次下载一个分支，然后立即验证这个分支，如果分支验证通过，就可以下载数据了。而Hashlist只有下载整个hashlist才能验证。</p> 
</blockquote> 
<h4>
<a id="Merkle_67"></a>Merkle树的应用</h4> 
<blockquote> 
 <p>1、数字签名最初MerkleTree目的是高效的处理Lamportone-timesignatures。每一个Lamportkey只能被用来签名一个消息，但是与Merkletree结合可以来签名多条Merkle。这种方法成为了一种高效的数字签名框架，即MerkleSignatureScheme。<br> 2、P2P网络在P2P网络中，MerkleTree用来确保从其他节点接受的数据块没有损坏且没有被替换，甚至检查其他节点不会欺骗或者发布虚假的块。<br> 3、比特币梅克尔树最早的应用是比特币，它是由中本聪在2009年描述并创建的。Bitcoin的Blockchain利用Merkleproofs来存储每个区块的交易。</p> 
</blockquote> 
<h2>
<a id="Merkle_72"></a>Merkle树与区块链</h2> 
<h3>
<a id="_73"></a>区块链分布式记账存在的问题</h3> 
<blockquote> 
 <p>区块链是实现无中心分布式总账的一种技术，总账技术的基本单元是‘交易’，整个账本是由一条条的交易构成‘块’类似于账本中的页，每页都记录了若干条交易，把一页一页的账页按照时间顺序装订起来，就形成了一个完整的账本——‘区块链’。‘块’是交易的容器，‘块’通过密码学算法相连接，形成了按照时间序列的‘链’。<br> 优点：<br> 数据易于保持完整，并且从密码学角度看安全性较高。<br> 缺点：<br> 对于比特币系统来说，这个问题并不大，因为截止目前为止，比特币仍然是每10分钟一个区块，每个区块1MB，即便到了100年后，总的数据量也不会大到单机无法处理。但是对于某些企业级应用的区块链系统来说，情况就完全不一样了。每个区块可能会非常大，生成区块的速度也会非常快，数据量就会变得非常的大。</p> 
</blockquote> 
<h3>
<a id="_80"></a>如何解决数据量过大的问题</h3> 
<blockquote> 
 <p>在传统的数据系统中，也存在这种情况，一般的处理方法是把历史的交易数据移到其他专门的存储设备上，主机数据库保存账号的最新状态和最近一段时间的交易记录即可。但是在区块链系统中，尤其是使用UTXO方式存储交易的区块链系统中，保存的都是交易的过程，即如果一个账户一直没有交易，它则不会出现在最新的区块中，那么按照传统数据库删除历史数据的方式，只要一个区块有一个交易一直没有后续交易就是没有人使用这个交易账户，但是为了维护整个区块链系统的密码学完整性和安全性，就必须保留这个区块，同时该区块后面的所有区块也需要保留。</p> 
</blockquote> 
<p>实际上，中本聪已经预留了一个最佳的解决方案：默克尔树（MerkleTree）算法。<br> 区块的结构图如下：<br> <img src="https://images2.imgbox.com/50/3b/KoFDOQiL_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>1、每个区块中的Hash1就是本区块中所有交易的哈希值。但这个哈希值不是把所有交易连成一个长字符串后计算HASH值，而是使用了默克尔树（MerkleTree）算法来计算获得这个HASH值，我们称之为Merkle根。(棒！)</p> 
 <p>2、 默克尔树算法在这里并不是直接计算整个字符串的Hash值，而是每个交易都计算一个Hash值，然后两两连接再次计算Hash，一直到最顶层的Merkle根。默克尔树（MerkleTree）算法的最大好处就是，每个交易都可以单独直接删除，只保留这个交易的Hash值即可。这样，对整个区块来说，并没有改变他的密码学安全性和完整性，但是数据量可以大大减小。（Hash值32个字节，而一笔交易一般要400多个字节）。</p> 
</blockquote> 
<h3>
<a id="Merkle_90"></a>区块链如何运用Merkle树验证交易真实性</h3> 
<p>既然区块链采用了Merkle树的数据结构，怎么能快速的找到该笔交易和验证交易的真实性呢？</p> 
<blockquote> 
 <p>那么会有人说，每笔交易不是都用哈希计算出来了嘛，直接保存所有的数据，验证一个交易是否存在还不简单？<br> 但是由于中本聪在比特币发明之初，有一种轻钱包的设计，简称SPV。<br> 特性：<br> 轻钱包并不保存完整的区块链，而是只保存每一个区块的区块头。区块体保存了完整的交易信息，而交易信息需要的存储量大部分都是交易头的千倍以上。所以，如果只保存交易头，就可以极大的减少本地客户端存储的区块链信息。</p> 
</blockquote> 
<p>但是问题来了，没有交易信息那验证？</p> 
<blockquote> 
 <p>这个时候区块头里的merkleroot就发挥作用了。</p> 
</blockquote> 
<p>在讲述轻钱包如何验证时，先了解如何在merkletree里面做验证。</p> 
<blockquote> 
 <p>我们已知merkletree里面父节点和子节点的运算关系，因此，当我们要证明一个叶子节点存在于这棵树时，只需要得到从该叶子节点到根的运算过程里面需要的那些hash即可，并不需要所有叶子节点参与计算。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/da/a5/xH22wyMj_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>你可能觉得有点奇怪，为什么不直接把所有的叶子节点告诉它就行了，你用所有叶子节点能算出roothash就验证通过了。但事实就是这样，因为每一个父节点hash一定是由两个子节点hash运算得到，所以，我们只需要挑选出所有参与运算的节点，就可以证明这个叶子节点存在于树中。这样可以减少hash运算的次数。<strong>而这些被挑选出来的节点，以及它们之间的层级关系，就是验证路径，即上图中merkleroot那个盒子下面的所有盒子。</strong></p> 
</blockquote> 
<p>比特币网络中的交易，只有已经被记录到区块链，并且已经得到6个确认的，才被认为是真实的。那么对于SPV轻钱包而言，怎么知道一个交易是否真实的呢？</p> 
<blockquote> 
 <p>SPV拿到一个交易信息之后（比如接收到一笔钱），并不能确认这个交易是否合法，因此要对这个交易的输入进行验证。<strong>但是它只拿到了单个交易的信息，而没有本地的完整区块链数据，因此，SPV要拿着这个交易的信息向网络发起查询请求，这个请求被称为merkleblockmessage。当其他有完整区块链数据的客户端收到这个请求之后，利用传过来的交易信息在自己的区块链数据库中进行查询，并把验证路径返回给请求源，SPV拿到验证路径之后，再做一次merkle校验，确认无误之后，就认为这个交易是可信的。</strong></p> 
</blockquote> 
<p>根据上面的验证过程就会出现下面的问题：</p> 
<blockquote> 
 <p>怎么从区块链里面查一个交易？<br> 怎么获取merkle验证路径？<br> 怎么确保网络上这个返回的验证路径不是伪造的?</p> 
</blockquote> 
<h4>
<a id="_113"></a>怎么从区块链里面查一个交易？</h4> 
<blockquote> 
 <p>区块链的数据结构是离散的，比特币里面一个区块被保存在一个文件里面，要得到一个交易的验证路径，必须得到这个交易所在的区块链。这是一个复制的查询过程，可能需要把所有的区块都遍历一遍才能找到。<br> 解决方案有：<br> 1、把每一个区块的数据结构修改为关系型数据库，通过关系型数据库，可以用sql语句快速查询。但是，要遍历查询所有区块链，是比较浪费的。<br> 2、利用交易的时间戳来快速定位区块位置，在临近的几个区块中快速找到它</p> 
</blockquote> 
<h4>
<a id="merkle_119"></a>如何获取merkle验证路径?</h4> 
<blockquote> 
 <p>实际上，merkle的验证路径生成的前提是已经存在一棵完整的merkle树。市面上有很多merkle树的实现包，有的包直接给出来getProof的方法来获取某个叶子节点的验证路径。<br> 在客户端收到merkleblockmessage之后，要执行下面的步骤：<br> ①通过上述方法找到包含该交易的区块<br> ②检查该区块是否是整个网络中最长链条里面的<br> ③取出所有交易生成merkletree，利用getProof方法得到该交易的验证路径<br> ④将该验证路径发送回请求源</p> 
</blockquote> 
<h4>
<a id="_127"></a>怎么确保网络上这个返回的验证路径不是伪造的?</h4> 
<p>SPV得到响应之后,要将取回来的merkleroot进行验证，验证步骤如下：</p> 
<blockquote> 
 <p>1.同步区块链，确保是整个网络中最长的一条<br> 2.先拿到merkleroot去区块链中查找，确保该merkleroothash是在链条中<br> 3.利用拿到的验证路径，再进行一次merkle校验，确保验证路径全部合法</p> 
</blockquote> 
<p>参考资料：<br> 知链科技区块链教育。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>