<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>数据的存储 详解 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据的存储 详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p><strong><span style="color:#956fe7">1 .数据类型的介绍</span></strong></p> 
<p></p> 
<p>   1.1类型的基本归类</p> 
<p>--------------------------------------------------------------------------------------------------------------------------------</p> 
<p>基本的数据类型：</p> 
<pre><code>char       //字符数据类型（整形家族）
short      //短整型
int        //整型
long       //长整型
long long  //长长（更长的）整型 （c99）
float      //单精度浮点数
double     //双精度浮点数
         </code></pre> 
<pre><code>    printf("%dn", sizeof(char));	    //1个字节    
	
    printf("%dn", sizeof(short));      //2个字节    
	
    printf("%dn", sizeof(int));        //4个字节  （32位机器或64位机器）早期为（16位机器）2个 字节   
	
    printf("%dn", sizeof(long));       //4个字节     
	
    printf("%dn", sizeof(long long));  //8个字节  
	
    printf("%dn", sizeof(float));      //4个字节  
	
    printf("%dn", sizeof(double));     //8个字节  </code></pre> 
<p><span style="color:#9c8ec1"><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></span></p> 
<p><span style="color:#9c8ec1"><strong>                                                </strong></span><strong><span style="color:#fe2c24">这 是 一 些 扩 展 大 家 可 以 看 看</span></strong></p> 
<p></p> 
<p><span style="color:#a5a5a5">有没有字符串类型呢？</span></p> 
<p><span style="color:#0d0016">答案是  </span><span style="color:#fe2c24">有的</span></p> 
<p>字符串是字符的序列，基本就是一组单词，是Phthon中常用的数据类型，可以用单引号（' '）和双引号（" "）来定义 （创建）字符串。</p> 
<pre><code>//比如可以这样
str = "My name is 9527 ";

str1 = 'HELLO WORLD!';

str2 ="""because of you""";//对了也可以用三引号(""" """)和(''' ''')
------------------------------------------------------------
print("%s" % str); //输出为 My name is 9527

print("%s" % str1);//输出为 HELLO WORLD!

print("%s" % str2);//输出为 because of you</code></pre> 
<p><span style="color:#fe2c24">不同的数据类型内会导致存储时和访问时有不同的差异 比如：浮点型就是一个典例（后面会给大家讲到 嘿嘿）</span></p> 
<p><span style="color:#956fe7">做点小扩展（摘自 cppreference.com）</span></p> 
<p></p> 
<ul><li>浮点类型</li></ul>
<ul><li>实际浮点类型：<span style="color:#0000ff"><span>float </span></span>, <span style="color:#0000ff"><span>double </span></span>,<span style="color:#956fe7">long </span><span style="color:#0000ff"><span>double</span></span>
</li></ul>
<table border="1" cellspacing="0"><tbody>
<tr>
<td style="background-color:#ffffff"> 
    <ul><li>十进制实数浮点类型：<span>_Decimal32</span>,<span>_Decimal64</span>,<span>_Decimal128</span>
</li></ul>
</td>
<td style="background-color:#ffffff"><span style="color:#008000">（自 C23 起）</span></td>
</tr>
<tr>
<td style="background-color:#ffffff"> 
    <ul>
<li>复杂类型：<span style="color:#4da8ee">float</span><span><span style="color:#0000ff">_Complex</span></span>,double<span><span style="color:#0000ff">_Complex</span></span>,<span style="color:#0000ff">long double</span><span>_Complex</span>
</li>
<li>虚数类型：float<span><span style="color:#0000ff">_Imaginary</span></span>,double<span><span style="color:#0000ff">_Imaginary</span></span>,<span style="color:#0000ff">long double</span><span>_Imaginary</span>
</li>
</ul>
</td>
<td style="background-color:#ffffff"><span style="color:#008000">（自C99起）</span></td>
</tr>
</tbody></table>
<p>可以简单了解一下 嘻嘻嘻</p> 
<p><strong><span style="color:#956fe7">其次就是 布尔类型 (_Bool) 是C语言中专门用来表示 真 / 假 的一种类型</span></strong><span style="color:#956fe7"><strong>（c++中也有哦）</strong></span></p> 
<p><span style="color:#956fe7"><strong>c99标准才开始引入原因是因为 </strong></span><strong><span style="color:#a5a5a5">在早期 C语言都是用0表示假 非0为真 后期才开始有了这样</span></strong></p> 
<p><span style="color:#0d0016">给大家演示一下：</span></p> 
<pre><code>   //c99才开始引入
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;//这里需要引用头文件
 int main()
{

     _Bool flag = true;//true为真false为假
	
     if (flag)
	{
		printf("Oh yeah! , you do it!");
	}

   return 0;
}</code></pre> 
<p><span style="color:#4da8ee"><strong>_Bool</strong></span> 没有什么好神奇的 本质是对<strong><span style="color:#4da8ee"> int </span></strong> 的一种重命名 你看这就很好的说明了 并且平常我们看到的代码也很少有用到_Bool类型的 即使 <span style="color:#4da8ee"><strong>c99 </strong></span><span style="color:#0d0016">中引入了 引用得不是很广泛有些编译器甚至不支持 当然你想用也是可以的 哈哈哈哈</span></p> 
<pre><code>   #define bool  _Bool
   
   #define false 0 //类似于int false = 0；
   
   #define true  1//类似于int true = 0；</code></pre> 
<p><span style="color:#9c8ec1"><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></span></p> 
<p><span style="color:#4da8ee">                                            <em><strong> “ 家族  ”类型</strong></em></span></p> 
<p><strong><span style="color:#fe2c24">1. 接下来是我们的整型家族</span></strong></p> 
<pre><code>    char :
		unsigned char
		signed char
	
    short :
		unsigned short  //short等价于signed short
		signed short
	
    int:
		unsigned int    //int等价于signed int
		signed int
	
    long:
	    unsigned long   //long等价于signed long
    	signed long</code></pre> 
<p><strong><span style="color:#4da8ee">char类型</span></strong><span style="color:#0d0016"> 之所以归于整型家族中是因为其字符有与其相对应的 </span><strong><span style="color:#4da8ee">ASCLL码值</span></strong></p> 
<p><span style="color:#0d0016">对于 </span><strong><span style="color:#4da8ee">char类型 </span></strong><span style="color:#0d0016">是不一样的 </span><strong><span style="color:#4da8ee">char</span></strong><span style="color:#0d0016"> 到底等不等同于 </span><strong><span style="color:#4da8ee">signed char </span></strong><span style="color:#0d0016">是取决于编译器的不同的</span></p> 
<p><span style="color:#0d0016">但是一般来讲是 </span><span style="color:#a5a5a5">等同</span><span style="color:#0d0016"> 的</span></p> 
<p><span style="color:#0d0016">需要注意 有符号 无符号 在打印是也要求的</span></p> 
<pre><code>    //注意：%d 是按照有符号数来打印的
    //%u 才是按照无符号来打印的

    unsigned int num = -10;
	printf("%d", num);       //打印为 -10  

    int num1 = -10;
	printf("%u", num1);      //打印出来为4294967286
</code></pre> 
<p><strong><span style="color:#fe2c24">2 浮点数家族</span></strong></p> 
<pre><code>float
double</code></pre> 
<p><span style="color:#fe2c24"><strong>除了这些类型之外还有 </strong></span><span style="color:#38d8f0"><strong>构造类型 （就是自己构造的类型）</strong></span></p> 
<p></p> 
<ul><li><a href="https://en.cppreference.com/w/c/language/enum" title="枚举类型">枚举类型</a></li></ul>
<ul><li>派生类型</li></ul>
<ul>
<li><a href="https://en.cppreference.com/w/c/language/array" title="数组类型">数组类型</a></li>
<li><a href="https://en.cppreference.com/w/c/language/struct" title="结构类型">结构类型</a></li>
<li><a href="https://en.cppreference.com/w/c/language/union" title="联合类型">联合类型</a></li>
<li><a href="https://en.cppreference.com/w/c/language/functions" title="函数类型">函数类型</a></li>
<li><a href="https://en.cppreference.com/w/c/language/pointer" title="指针类型">指针类型</a></li>
</ul>
<table><tbody><tr>
<td> 
    <ul><li><a href="https://en.cppreference.com/w/c/language/atomic" title="原子类型">原子类型</a></li></ul>
</td>
<td>（自C11起）</td>
</tr></tbody></table>
<p>对于上面列出的每个类型，可能存在其类型的几个限定版本，对应于一个，两个或全部三个<a href="https://en.cppreference.com/w/c/language/const" title="const，volatile">const，volatile</a>和<a href="https://en.cppreference.com/w/c/language/restrict" title="strict">strict</a>限定符的组合（在限定符的语义允许的情况下）。<span style="color:#4da8ee"><strong>（摘自 cppreference.com）</strong></span></p> 
<p>可以提的一点就是还有一个<strong><span style="color:#4da8ee"> void类型 </span></strong><span style="color:#0d0016">他表示一种空类型（应用于 函数的返回的类型、函数的参数、函数的类型）。</span></p> 
<pre><code>void function(void)
{
    void *tmp;

}</code></pre> 
<p><strong><span style="color:#fe2c24">2.    整型在数据中的存储</span></strong></p> 
<p>变量的创建是需要在<span style="color:#a5a5a5">栈区创建空间的 而不同的类型决定了创建的空间的大小</span></p> 
<p>2.1 <span style="color:#fe2c24"><strong>原码、反码、补码</strong></span></p> 
<p>在了解 <span style="color:#38d8f0"><strong>原 反 补</strong></span> 之间的关系前 我们要知道一个点就是<span style="color:#fe2c24">整数在内存存储的补码</span></p> 
<p>正整数 的 <span style="color:#38d8f0"><strong>原 反 补</strong></span> 是相同的</p> 
<p>负整数 的 <span style="color:#38d8f0"><strong>原 反 补</strong></span> 之间的关系可以这样解释</p> 
<pre><code>int a= -12;

//1 0000000 00000000 00000000 00001100 (原码)一个字节八个bit位
//1 1111111 11111111 11111111 11110011 (反码)按位取反符号位不变
//1 1111111 11111111 11111111 11110100 (补码)取反后加一

//前面的1为符号位 1表示其为负数 0表示其为正数

int b= 12;

//0 0000000 00000000 00000000 00001100(原 反 补)</code></pre> 
<p>在计算机系统中，数值一律用补码来表示和存储。原因<span style="color:#4da8ee">在于使用，可以将符号位和数值域统一处理</span></p> 
<p>同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换其运算过程是相同的，不需要额外的硬件电路。</p> 
<p>用补码<span style="color:#fe2c24">有什么效果好处是什么？</span></p> 
<p><span style="color:#0d0016">大家可以这样看看</span></p> 
<pre><code>int a = 1;
int b =-1;

//00000000 00000000 00000000 00000001 (a的原码，反码，补码)

//10000000 00000000 00000000 00000001 (b的原码)
//11111111 11111111 11111111 11111110 (b的反码)
//11111111 11111111 11111111 11111111 (b的补码)

//如果此时我们计算 a+b 使用原码

//得到的结果就是这样的
//11111111 11111111 11111111 11111110 显然这个是不等于0

//如果我们用到补码来计算情况就是这样的了
//1 00000000 00000000 00000000 00000000此时前面的1就溢出了 最后得到就是
//00000000 00000000 00000000 00000000 此时得到结果就是0了</code></pre> 
<p><span style="color:#fe2c24"><strong>2.2 大小端</strong></span></p> 
<p>大段 （存储） 模式 数据的<span style="color:#38d8f0">低位</span>保存在内存的<span style="color:#956fe7">高地址</span>，而数据的<span style="color:#38d8f0">高位</span>，保存在内存的<span style="color:#4da8ee">低地址</span>中</p> 
<p>小段 （存储）模式 数据的<span style="color:#38d8f0">低位</span>保存在内存的<span style="color:#956fe7">低地址</span>，而数据的<span style="color:#38d8f0">高位</span>，保存在内存的<span style="color:#4da8ee">高地址</span>中</p> 
<p>其实通俗来讲的话 可以这样理解：<span style="color:#38d8f0"><strong> 小段（存储）模式下内存存储的字节序是相反的，大段就是与之相反的。</strong></span></p> 
<p style="text-align:center"><span style="color:#7b7f82">大家来看：<img alt="" src="https://images2.imgbox.com/09/46/ti7vwG1T_o.png"></span></p> 
<pre><code>// 大家看
// 10的补码 00000000 00000000 00000000 00001100 

//4个字节为1个16进制

//0000 0000 | 0000 0000 | 0000 0000 | 0000 1100 
//  0    0  |   0    0  |   0    0  |   0   a(10)
   高字节  &lt;----------------------------低字节
//所以按照 小端存储 的话 就是反着存的
//拿进去就是这样的 

//0a 00 00 00</code></pre> 
<p> 这就是小段的存储 大家看懂了吗？大段就是与之相反的 嘻嘻</p> 
<p>最后补一句 只要一个数值在内存存储的大小超过一个字节 那么他在内存中的字节存储就有顺序</p> 
<p>就好像<span style="color:#4da8ee">char类型</span>就没有字节序(大小端)的区别</p> 
<p>除此之外 <span style="color:#fe2c24"><strong>大家还需要注意数据在进行赋值时的一些原理 （因为他们很可能会发生</strong></span><span style="color:#4da8ee"><strong> 整型提升</strong></span><span style="color:#fe2c24"><strong> 和 </strong></span><span style="color:#4da8ee"><strong>算数转换</strong></span><span style="color:#fe2c24"><strong> ）</strong></span></p> 
<p>就好像是这样：</p> 
<pre><code>

   char x = -1;          //大家注意看这里 -1为一个整型（32个bit位）现在要放在一个字符型（8bit 
  位）的变量中那么就需要发生截断 

  //11111111 11111111 11111111 11111111
  //                           11111111(截断后就是这样了前面的1就没有了)
   

   signed char y = -1;  //在VS中char等同于signed char 所以截断和第一个一样的

   unsigned char z =-1; //这里也是一样的道理 无符号并不会有影响 他依旧只能存储8个bit位</code></pre> 
<p>整型提升内<span style="color:#fe2c24">就是以他的符号位的数字往前补1或0（这里就不做细讲了）</span></p> 
<pre><code>//如果不理解的话大家可以看看这样

//在printf("%d %d %d",x,y,z);   这个时候之前的char 、signed char 、unsigned char就开始发挥他们的作用了

//之前不是 x 被 char 截断的后变成了  11111111

%d是要以有符号的整型打印出来前面也提到过了
所以呢这个时候 就会发生整型提升：
//11111111
//11111111 11111111 11111111 11111111(因为截断后的x是有符号的并且为 1 所以就补 1 )
这个时候内 这还是补码 要转换成原码来打印出来
因为-1的补码为全1 （大家可以记一下）所以这个时候打印出来就是 -1

unsigned char截断的z就会在前面补0（因为它是无符号的就补0）
//00000000 00000000 00000000 11111111
%d打印是以有符号的方式打印出来 所以它（%d）就会认为0 是他的符号位 因为0为符号位为正数 
原、反、补码相同 此时的虽为补码 原反补相同就直接按照
//00000000 00000000 00000000 11111111
打印出来 就是这样的 嘿嘿</code></pre> 
<p><strong><span style="color:#fe2c24">3. 浮点数在内存中的存储（与整数是不一样的哦）</span></strong></p> 
<p>浮点数家族：<span style="color:#4da8ee">float 、double 、long double</span></p> 
<p><span style="color:#0d0016">其中大家可以了解一下这个 </span><span style="color:#4da8ee">1E6</span><span style="color:#0d0016"> 这也是一个浮点数 </span><span style="color:#4da8ee">1E6 =1*10^6</span></p> 
<p><span style="color:#4da8ee">(浮点数后边不加 f 默认为double类型 加后改为float类型)</span></p> 
<p><span style="color:#9c8ec1"><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></span></p> 
<p><strong><span style="color:#fe2c24">大家来看一下浮点数的存储规则：</span></strong></p> 
<p>根据国际标准IEEE(电气和电子工程协会)754，任何一个二进制浮点数 <span style="color:#4da8ee"><strong>V </strong></span>可以表示成下面的形式</p> 
<p>(-1)^<span style="color:#4da8ee"><strong>S</strong></span>*<strong><span style="color:#fe2c24">M</span></strong>*2*<span style="color:#6eaad7"><strong>E</strong></span></p> 
<p> <span style="color:#1a439c">1</span>.  (-1)^<span style="color:#4da8ee"><strong>S</strong></span><span style="color:#0d0016">表示的是符号位，当</span><span style="color:#4da8ee"><strong>S</strong></span><span style="color:#0d0016">为0时 </span><span style="color:#4da8ee"><strong>V</strong></span><span style="color:#0d0016"> 为正数 当</span><span style="color:#4da8ee"><strong>S</strong></span><span style="color:#0d0016">为1，</span><span style="color:#4da8ee"><strong>V</strong></span><span style="color:#0d0016">为负数</span></p> 
<p><span style="color:#0d0016"> 2.  </span><span style="color:#fe2c24"><strong>M</strong></span><span style="color:#0d0016">表示有效数字，大于等于1，小于2</span></p> 
<p><span style="color:#0d0016"> 3.  2^</span><strong><span style="color:#6eaad7">E</span></strong><span style="color:#0d0016">表示指数位</span></p> 
<p><span style="color:#9c8ec1"><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></span></p> 
<pre><code>   //大家来这样看
好比 6.5--&gt;110.1(二进制)  0.5=2^-1所以 0.5--&gt;0.1(二进制)

// 110.1=1.101*2^2  这里乘以二的二次方 就好比 9527=9.527*10^3 科学计数法

//6.5为正数 所以 (-1)^S 这里的S就等于0；
//有效数字M就为1.101
//指数E就是2</code></pre> 
<p style="text-align:center">接下来 就是这些数应该如何放进去：（画得不太好 嘻嘻）<img alt="" src="https://images2.imgbox.com/b8/0e/pbd6cImN_o.png"></p> 
<p><span style="color:#4da8ee"><strong>1. S </strong></span><span style="color:#0d0016">的存储即1或者0放进去（浮点数不存在原反补的概念）2</span></p> 
<p>2. 因为之前 <span style="color:#fe2c24"><strong>M </strong></span><span style="color:#0d0016">说到 </span><span style="color:#fe2c24"><strong>1&lt;= M &lt;2 </strong></span><span style="color:#0d0016">所以 </span><strong><span style="color:#fe2c24">M </span></strong><span style="color:#0d0016">可以表示成 1点几 (1.??????) 所以在存储 </span><strong><span style="color:#fe2c24">M </span></strong><span style="color:#0d0016">时就只会存储小数点后面的数 这样的话拿出来使用只需要在 </span><span style="color:#fe2c24"><strong>M </strong></span><span style="color:#0d0016">前面加 1 就可以了 并且这样还能节省一个空间也就可以多存储一位了 怎么样 是不是很 </span><span style="color:#cbe0f1">女少</span></p> 
<p>3. 存储 <strong><span style="color:#6eaad7">E</span></strong><span style="color:#0d0016">时情况就比较复杂了 分为以下几种：</span></p> 
<p><span style="color:#0d0016">首先大家要知道</span><strong><span style="color:#6eaad7">E</span></strong><span style="color:#0d0016">为</span><span style="color:#4da8ee">无符号整型</span><span style="color:#0d0016">（unsigned int）</span></p> 
<p>如果计算出来 <strong><span style="color:#6eaad7">E</span></strong><span style="color:#0d0016"> 的值需要加一个中间数 ，8位的情况下加的是127，11位的情况下加的是1023</span></p> 
<p><span style="color:#0d0016">好比 ：现在 </span><strong><span style="color:#6eaad7">E </span></strong><span style="color:#0d0016">计算出来为-1 那么存进去时就应该是 -1+127=126 存进去</span></p> 
<p><span style="color:#0d0016">10的话 就是10+127=137 大家明白了吗 </span><strong><span style="color:#4da8ee">（还有一点 8位情况下 E的取值范围是0~255 这里的范围是计算的 E 加上中间值127后的范围 这样说大家理解嘛？）</span></strong></p> 
<p>在取出<strong><span style="color:#6eaad7">E</span></strong><span style="color:#0d0016">时又分为以下的几种情况：</span></p> 
<p><span style="color:#0d0016">1 .</span><span style="color:#6eaad7">E</span><span style="color:#0d0016">不全为1或不全为0的时候：</span></p> 
<p><span style="color:#0d0016">这个时候就只需要把 </span><strong><span style="color:#6eaad7">E </span></strong><span style="color:#0d0016">的值取出来减去一个中间值即可</span></p> 
<p><span style="color:#0d0016">2. </span><strong><span style="color:#6eaad7">E</span></strong><span style="color:#0d0016">全</span><span style="color:#0d0016">为0时：</span></p> 
<p><strong><span style="color:#6eaad7">E</span></strong><span style="color:#0d0016">为0就意味着之前计算出来的 </span><strong><span style="color:#6eaad7">E </span></strong><span style="color:#0d0016">为-127 大家想想一个指数-127 （2^-127）得多小啊</span></p> 
<p><span style="color:#0d0016">所以这个时候 </span><strong><span style="color:#6eaad7">E </span></strong><span style="color:#0d0016">直接拿出来就等于 1-127 或 1-1023 此时有效数字 </span><span style="color:#fe2c24"><strong>M </strong></span><span style="color:#0d0016">就不再加1了而是直接变成0.？？？？（大家可以了解一下）</span></p> 
<pre><code>    （-1）^S*1.？？？*2^-127
//这样的数不就是一个趋近于0的很小很小的数了嘛</code></pre> 
<p>3.<strong><span style="color:#6eaad7">E</span></strong><span style="color:#0d0016">为全1时：</span></p> 
<pre><code>// 1111 1111 这个计算出来为255 说明计算出来的 E 就应该为 128 
// 想想一个数 2^128是不一个很大的数目

//到这里大家就已经看见 E 为全0，E 为全1 就是两个相对的极端 </code></pre> 
<p>给大家演示一下下：</p> 
<pre><code>int n =12;
float *p=(float*)&amp;n; 
printf("%fn",*p);   //注意这里是以整型放进去 然后以浮点数的形式打印出来

//00000000 00000000 00000000 00001100
%f去识别时
//0 00000000 00000000000000000001100
  S     E               M

//这时E全为0 所以M就不用加上1了所以这个拿出来就是

//(-1)^0 * 0.00000000000000000001100 * 2^-126 得到就是一个很小很小的数

%f %lf 都是默认为输出小数点后六 这里显然后六位 全为0 输出自然而然就是 0.000000</code></pre> 
<pre><code>//再给大家演示一下 存储的过程

延续刚刚的代码
*p = 12.0;
printf("%f",*p);  //这里就是浮点数放进去浮点数拿出来了
printf("%d",*p);

   12.0--&gt;十进制 S=0
   1100.0--&gt;二进制
   1.100*2^3--&gt;E=3,M=0.100
  
//0 10000010 100 00000000000000000000(后面不够补0)
 //完整来看 0 10000010 10000000000000000000000
存储在内存中时 大家这样来看
// 0100 0001 0100 0000 0000 0000 0000 0000
// 4    1    4    0    0    0    0    0  大家想想浮点数有大小端之分嘛</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/31/cf/LVooNvg7_o.png"></p> 
<p> 很明显是<span style="color:#fe2c24"><strong> 有的</strong></span></p> 
<pre><code>图中 
printf（"%d",n）;   //这里的n打印出来是 1094713344 为什么内 我给大家解释一下啊

此时n的地址中的内容已经发生了改变
// 0100 0001 0100 0000 0000 0000 0000 0000 如果把这个放到计算器中
</code></pre> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/3c/08/4QNdGDwK_o.png"></p> 
<p> 大家看 是不是一样的 嘿嘿</p> 
<p><span style="color:#9c8ec1"><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></span></p> 
<p>到这里内 <span style="color:#fe2c24"><strong>数据的存储 </strong></span>就讲完啦 感谢大家看到这里 谢谢啦 （第一篇博客 有些不好的地方麻烦各位大牛指正）</p> 
<p>那就这样吧！ <span style="color:#fe2c24"><strong>祝大家都能进入自己喜欢的大厂！ 加油</strong></span></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>