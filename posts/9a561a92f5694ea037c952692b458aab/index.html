<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>十大排序算法 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">十大排序算法</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h2>一、冒泡排序</h2> 
<p>        冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访要排序的数列，一次比<br> 较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经交换慢慢"浮"到数列的头部。</p> 
<pre><code class="language-java">/**
 * 冒泡排序
 */
public class BubbleSort {
    public void sort(int[] arr) {
        if (arr == null || arr.length == 0) {
            return;
        }
        for (int i = 1; i &lt; arr.length; i++) { //比较的轮数
            for (int j = 0; j &lt; arr.length - i; j++) { // 每轮比较的次数
                if (arr[j] &gt; arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
</code></pre> 
<h2> 二、选择排序</h2> 
<p>        选择排序也是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以<br> 用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p> 
<pre><code class="language-java">public class SelectionSort {
    public void sort(int[] arr) {
        if (arr == null || arr.length == 0) {
            return;
        }
        for (int i = 0; i &lt; arr.length - 1; i++) { //比较的轮数
            int min = i;// 记录最小值的索引
            for (int j = i + 1; j &lt; arr.length; j++) {
                if (arr[min] &gt; arr[j]) {
                    min = j;
                }
            }
            // 将最小值放置在索引为i的位置
            if (min != i) {
                int temp = arr[i];
                arr[i] = arr[min];
                arr[min] = temp;
            }
        }
    }
}</code></pre> 
<h2>三、插入排序</h2> 
<p>       插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理<br> 解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p> 
<pre><code class="language-java">public class InsertSort {
    public void sort(int[] arr) {
        if (arr == null || arr.length == 0) {
            return;
        }
        for (int i = 1; i &lt; arr.length; i++) {
            int instartVal = arr[i];
            int j = i - 1; // 有序区最后一个元素
            while (j &gt;= 0) {
                if (arr[j] &gt; instartVal) {
                    arr[j + 1] = arr[j];
                    j--;
                } else {
                    break;
                }
            }
            arr[j + 1] = instartVal;
        }
    }
}</code></pre> 
<h2>四、希尔排序</h2> 
<p>     希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>     希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>      • 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<br>      • 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br>     希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排<br> 序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。</p> 
<pre><code class="language-java">
public class ShellSort {
    public void sort(int[] arr) {
        if (arr == null || arr.length == 0) {
            return;
        }
        int length = arr.length;
        // step:表示希尔增量
        for (int step = length / 2; step &gt;= 1; step /= 2) {
            //从setp位置开始进行插入排序，直至完毕
            for (int i = step; i &lt; arr.length; i++) {
                int instartVal = arr[i];
                int j = i - step; // 有序区最后一个元素
                while (j &gt;= 0) {
                    if (arr[j] &gt; instartVal) {
                        arr[j + step] = arr[j];
                        j -= step;
                    } else {
                        break;
                    }
                }
                arr[j + step] = instartVal;
            }
        }
    }
}</code></pre> 
<h2> 五、 归并排序</h2> 
<p>       归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法<br> （Divide and Conquer）的一个非常典型的应用。<br> 1. 算法步骤<br> 1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br> 2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br> 3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br> 4. 重复步骤 3 直到某一指针达到序列尾；<br> 5. 将另一序列剩下的所有元素直接复制到合并序列尾。</p> 
<pre><code class="language-java">import java.util.Arrays;

/**
 * 归并排序
 */
public class MergeSort {
    public int[] sort(int[] arr) {
        if (arr == null || arr.length &lt; 2) {
            return arr;
        }
        int middle = (int) Math.floor(arr.length / 2);
        int[] left = Arrays.copyOfRange(arr, 0, middle );
        int[] right = Arrays.copyOfRange(arr, middle , arr.length);
        return merge(sort(left), sort(right));
    }

    protected int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0;
        int m = 0;
        int n = 0;
        while (m &lt; left.length  &amp;&amp; n &lt; right.length) {
            if (left[m] &lt;= right[n]) {
                result[i++] = left[m++];
            } else {
                result[i++] = right[n++];
            }
        }
        while (m &lt; left.length) {
            result[i++] = left[m++];
        }
        while (n &lt; right.length) {
            result[i++] = right[n++];
        }
        return result;
    }
}</code></pre> 
<h2>六、 快速排序</h2> 
<p>1. 算法步骤<br> 1. 从数列中挑出一个元素，称为 "基准"（pivot）;<br> 2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br> 3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p> 
<pre><code class="language-java">
/**
 * 快速排序
 */
public class FastSort {
    public void sort(int[] arr) {
        if (arr == null || arr.length &lt; 2) {
            return;
        }
        //  排序
        fastSort(arr, 0, arr.length - 1);
    }

    // 对[left,right]区间进行排序
    private void fastSort(int[] arr, int left, int right) {
        // 递归到底的情况
        if (left &gt;= right) {
            return;
        }
        // 递归操作
        int pivot = arr[left];
        int i = left;
        int j = right;

        while (i &lt; j) {
            // 从右边开始找到第一个小于pivot的元素
            while (i &lt; j &amp;&amp; arr[j] &gt; pivot) {
                j--;
            }
            // 替换
            if (i &lt; j) {
                arr[i] = arr[j];
                i++;
            }
            // 从左边开始找到第一个比pivot大的元素
            while (i &lt; j &amp;&amp; arr[i] &lt; pivot) {
                i++;
            }
            // 替换
            if (i &lt; j) {
                arr[j] = arr[i];
                j--;
            }
        }
        arr[i] = pivot;
        fastSort(arr, left, i - 1);
        fastSort(arr, i + 1, right);
    }
}
</code></pre> 
<h2>
<br> 七、 堆排序</h2> 
<p>       堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：<br> 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br> 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br> 堆排序的平均时间复杂度为 Ο(nlogn)。<br> 1. 算法步骤<br> 1. 创建一个堆 H[0……n-1]；<br> 2. 把堆首（最大值）和堆尾互换；<br> 3. 调用 shift_down方法，使除过堆尾元素的树满足最大堆的性质；<br> 4. 重复步骤 2，直到堆中只有一个元素。</p> 
<pre><code class="language-java">
// 堆排序
public class HeapSort {
    private int getParentIndex(int index) {
        if (index &lt; 0) {
            throw new IllegalArgumentException("index is invalid!");
        }
        if (index == 0) { // 处理根节点
            return -1;
        }
        return (index - 1) / 2;
    }

    // 根据当前结点所在数组的索引获取左孩子结点的索引
    private int getLeftChildIndex(int index) {
        return 2 * index + 1;
    }

    public void sort(int[] arr) {
        if (arr == null || arr.length == 0) {
            return;
        }
        // 将完全二叉树整理成堆
        heapify(arr);
        // 排序
        for (int i = arr.length - 1; i &gt; 0; i--) {
            // 将堆尾元素与堆首元素互换
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            // 整理成堆
            siftDown(0, arr, i);
        }
    }


    private void heapify(int[] arr) {
        // 1、找到最后一个元素的父节点
        int parentIndex = getParentIndex(arr.length - 1);

        // 2、从最后一个元素的父节点开始下沉操作，直到根节点
        for (; parentIndex &gt;= 0; parentIndex--) {
            siftDown(parentIndex, arr, arr.length);
        }
    }

    private void siftDown(int curIndex, int[] arr, int length) {
        int leftChildIndex = getLeftChildIndex(curIndex);
        int chageIndex = leftChildIndex;
        while (leftChildIndex &lt; length) {
            int rigthChildIndex = leftChildIndex + 1;
            if (rigthChildIndex &lt; length &amp;&amp; arr[rigthChildIndex] &gt; arr[leftChildIndex]) {
                chageIndex = rigthChildIndex;
            }
            if (arr[chageIndex] &gt; arr[curIndex]) {
                // 交换操作
                int temp = arr[curIndex];
                arr[curIndex] = arr[chageIndex];
                arr[chageIndex] = temp;
                curIndex = chageIndex;
                leftChildIndex = getLeftChildIndex(curIndex);
                chageIndex = leftChildIndex;
            } else {
                break;
            }
        }
    }
}
</code></pre> 
<h2>八、 计数排序</h2> 
<p>      计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br> 1. 计数排序的特征当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。<br><strong>2、算法步骤</strong><br> （1）找出待排序的数组中最大和最小的元素<br> （2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br> （3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br> （4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p> 
<pre><code class="language-java">public class CountingSort {
    public void sort(int[] arr) {
        if (arr == null || arr.length &lt; 2) {
            return;
        }
        // 获取数组中最大的值
        int maxVal = getMaxVal(arr);
        // 创建一个数组，用来计数
        int[] counts = new int[maxVal + 1];
        // 计数
        for (int i = 0; i &lt; arr.length; i++) {
            counts[arr[i]]++;
        }
        // 反向填充
        int index = 0;
        for (int i = 0; i &lt; counts.length; i++) {
            while (counts[i] &gt; 0) {
                arr[index++] = i;
                counts[i]--;
            }
        }
    }

    private int getMaxVal(int[] arr) {
        int max = arr[0];
        for (int i = 1; i &lt; arr.length; i++) {
            max = Math.max(max, arr[i]);
        }
        return max;
    }
}</code></pre> 
<h2>九、 桶排序</h2> 
<p>     桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<br> • 在额外空间充足的情况下，尽量增大桶的数量<br> • 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br> 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<br> 1. 什么时候最快<br> 当输入的数据可以均匀的分配到每一个桶中。<br> 2. 什么时候最慢<br> 当输入的数据被分配到了同一个桶中。</p> 
<pre><code class="language-java">
import java.util.ArrayList;
import java.util.List;

// 桶排序
public class BucketSort {
    public void sort(int[] arr) {
        if (arr == null || arr.length &lt; 2) {
            return;
        }
        // 创建桶
        List&lt;Integer&gt;[] buckets = new ArrayList[10];
        // 初始化桶
        for (int i = 0; i &lt; buckets.length; i++) {
            buckets[i] = new ArrayList&lt;&gt;();
        }
        // 将数据放入桶中
        for (int i = 0; i &lt; arr.length; i++) {
            int index = arr[i] / 10;
            buckets[index].add(arr[i]);
        }
        //分别堆每个桶进行排序
        for (int i = 0; i &lt; buckets.length; i++) {
            buckets[i].sort(null);
        }
        // 将桶中的元素反向填充到arr中
        int index = 0;
        for (int i = 0; i &lt; buckets.length; i++) {
            List&lt;Integer&gt; item = buckets[i];
            while (!item.isEmpty()) {
                arr[index++] = item.remove(0);
            }
        }
    }
}
</code></pre> 
<h2>十、 基数排序</h2> 
<p>     原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的方式可以采用<br> LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p> 
<p>MSD：先从高位开始进行排序，在每个关键字上，可采用计数排序<br> LSD：先从低位开始进行排序，在每个关键字上，可采用桶排序<br> 1. 基数排序 vs 计数排序 vs 桶排序<br> 基数排序有两种方法：<br> 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：<br> • 基数排序：根据键值的每位数字来分配桶；<br> • 计数排序：每个桶只存储单一键值；<br> • 桶排序：每个桶存储一定范围的数值；</p> 
<pre><code class="language-java">
import java.util.ArrayList;
import java.util.List;

/**
 * 计数排序
 */
public class RadixSort {
    public void sort(int[] arr) {
        if (arr == null || arr.length &lt; 2) {
            return;
        }

        // 获取最大值
        int maxValue = getMaxVal(arr);
        // 获取最大位数
        int maxDigit = getMaxDigit(maxValue);
        radixSort(arr, maxDigit);
    }

    private void radixSort(int[] arr, int maxDigit) {
        int mod = 10;// 模数
        int dev = 1;
        for (int i = 0; i &lt; maxDigit; i++) { // 比较轮数
            // 创建桶
            List&lt;Integer&gt;[] bucket = new ArrayList[10];
            // 对桶进行初始化
            for (int n = 0; n &lt; bucket.length; n++) {
                bucket[n] = new ArrayList&lt;&gt;();
            }
            for (int j = 0; j &lt; arr.length; j++) {
                int bucketIndex = (arr[j] / dev) % mod;
                bucket[bucketIndex].add(arr[j]);
            }
            // 对桶进行排序
            //分别堆每个桶进行排序
            for (int k = 0; k &lt; bucket.length; k++) {
                bucket[k].sort(null);
            }
            // 将桶中的元素反向填充到arr中
            int index = 0;
            for (int m = 0; m &lt; bucket.length; m++) {
                List&lt;Integer&gt; item = bucket[m];
                while (!item.isEmpty()) {
                    arr[index++] = item.remove(0);
                }
            }
            dev = dev * 10;
        }
    }

    private int getMaxDigit(int maxValue) {
        int length = 1;
        int curNum = maxValue;
        while (curNum / 10 != 0) {
            curNum = curNum / 10;
            length++;
        }
        return length;
    }

    private int getMaxVal(int[] arr) {
        int max = arr[0];
        for (int i = 1; i &lt; arr.length; i++) {
            max = Math.max(max, arr[i]);
        }
        return max;
    }
}
</code></pre> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>