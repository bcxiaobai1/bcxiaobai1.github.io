<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>嵌入式C语言（入门必看） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式C语言（入门必看）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p>     </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="STM32%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px"><a href="#STM32%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">STM32的数据类型</a></p> 
<p id="const%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px"><a href="#const%E5%85%B3%E9%94%AE%E5%AD%97">const关键字</a></p> 
<p id="static%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px"><a href="#static%20%E5%85%B3%E9%94%AE%E5%AD%97">static 关键字</a></p> 
<p id="volatile%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px"><a href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97">volatile关键字</a></p> 
<p id="extern%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px"><a href="#extern%E5%85%B3%E9%94%AE%E5%AD%97">extern关键字</a></p> 
<p id="%C2%A0struct%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:0px"><a href="#%C2%A0struct%E7%BB%93%E6%9E%84%E4%BD%93"> struct结构体</a></p> 
<p id="enum-toc" style="margin-left:0px"><a href="#enum">enum</a></p> 
<p id="%C2%A0typedef-toc" style="margin-left:0px"><a href="#%C2%A0typedef"> typedef</a></p> 
<p id="%23define-toc" style="margin-left:0px"><a href="#%23define">#define</a></p> 
<p id="%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">回调函数</a></p> 
<p id="%23ifdef%20%E3%80%81%23ifndef%E3%80%81%23else%20%C2%A0%E3%80%81%23if%20%C2%A0%20%C2%A0-toc" style="margin-left:0px"><a href="#%23ifdef%20%E3%80%81%23ifndef%E3%80%81%23else%20%C2%A0%E3%80%81%23if%20%C2%A0%20%C2%A0">#ifdef 、#ifndef、#else  、#if    </a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>嵌入式开发中既有底层硬件的开发又涉及上层应用的开发,即涉及系统的硬件和软件,C语言既具有汇编语言操作底层的优势，又具有高级语言功能性强的特点，当之无愧地成为嵌入式开发的主流语言。在 STM32开发过程中，不论是基于寄存器开发还是基于库开发，深入理解和掌握嵌入式C语言的函数、指针、结构体是学习STM32的关键。<br> 嵌入式C语言的结构特点如下。<br> (1）程序总是从main函数开始执行，语句以分号“;”结束，采用/*…*/或//做注释。</p> 
<p>(2）函数是C语言的基本结构，每个C语言程序均由一个或多个功能函数组成。</p> 
<p>(3） 函数由两部分组成:说明部分和函数体。<br>  </p> 
<pre><code>  函数名（参数）
  {
      [说明部分];
      函数体；
  }</code></pre> 
<p>(4)一个C语言程序包含若干个源程序文件(.c文件)和头文件(.h文件)，其中.h头文件主要由预处理命令（包括文件、宏定义、条件编译等)和数据声明(全局变量、函数等声明）组成;c源文件主要是功能函数的实现文件。<br> (5)采用外设功能模块化设计方法，一个外设功能模块包括一个源文件（.c文件）和一个头文件(.h文件)，.c文件用于具体外设功能模块函数的实现，.h头文件用于对该外设功能模块参数及功能函数的声明。<br>       嵌入式系统开发多采用模块化、层次化的设计思想，系统层次架构清晰，便于协同开发。图1为嵌入式系统的软件基本结构框图。<br><img alt="" height="225" src="https://images2.imgbox.com/1c/3e/4cC799Ql_o.png" width="562"></p> 
<p>                            图1 嵌入式系统的软件基本结构框架图</p> 
<h1 id="STM32%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><strong>STM32的数据类型</strong></h1> 
<p><br> 数据是嵌入式C语言的基本操作对象,数据类型是指数据在计算机内存中的存储方式,如基本数据类型中的整型(存放整数)、浮点型(存放实数)、字符型(存放字符)、指针(存放地址)以及派生出的复合数据类型（如数组、结构体、共用体、枚举类型)。嵌入式C语言的数据类型如图2所示。</p> 
<p class="img-center"><img alt="" height="203" src="https://images2.imgbox.com/d6/f7/DQYcebHX_o.png" width="343"></p> 
<p>                                                     图二 嵌入式C语言的数据类型</p> 
<p>      由于不同CPU定义的数据类型的长度不同，因此ARM公司联合其他半导体厂商制定了统一的CMSIS 软件标准，这个标准中预先定义了相关的数据类型,ST公司也为开发人员提供了基于C语言的标准外设库，其定义的数据类型如表1所示，相关源代码请参考STM32标准外设库v3.5.0的stdint.h头文件。<br>       stm32f10x.h头文件还对标准外设库之前版本所使用的数据类型进行了说明，v3.5.0版本已不再使用这些旧的数据类型,为了兼容以前的版本，新版本对其进行了兼容说明，如图3所示。</p> 
<p>                                                  表1   STM32定义的数据类型<br>  </p> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/2a/71/4DU5jWmY_o.png" width="609"></p> 
<p></p> 
<p class="img-center"><img alt="" height="454" src="https://images2.imgbox.com/f5/8f/wkIlCEDe_o.png" width="571"></p> 
<p>                                 图3  STM32标准外设库数据类型兼容说明</p> 
<p>图3中的_I、_O以及_IO为IO类型限定词，内核头文件 core_cm3.h定义了标准外设库所使用的IO类型限定词，如表2所示。注意,IO类型限定词加下画线是为了避免命名冲突。<br> 表1的数据类型与表2中的IO类型限定词相结合，在标准外设库中常用来定义寄存器和结构体变量，图4为stm32f10x.h头文件中相关外设的寄存器定义。</p> 
<p>                                                表2   STM32的IO类型限定词</p> 
<p class="img-center"><img alt="" height="98" src="https://images2.imgbox.com/3b/9a/kp7TACF2_o.png" width="615"></p> 
<p class="img-center"><img alt="" height="594" src="https://images2.imgbox.com/84/f6/pX5Iv5oi_o.png" width="643"></p> 
<p>                                              图4 stm32f10x.h头文件中相关外设的寄存器定义</p> 
<p>       结合表2和图3，可以看出同一数据类型有多种表示方式，如无符号8位整型数据有unsigned char、uint8_t、u8三种表示方式,在不同的ST标准外设库版本中这三种表示方式都可以表示无符号8位整型数据，初学者应了解这三种表达方式，最新的v3.5.0版本采用 CMSIS软件标准的C99标准,即 uint8_t方式。</p> 
<h1 id="const%E5%85%B3%E9%94%AE%E5%AD%97"><strong>const关键字</strong></h1> 
<p>      const关键字用于定义只读的变量，其值在编译时不能被改变,注意，const关键字定义的是变量而不是常量。<br>       使用 const关键字是为了在编译时防止变量的值被误修改，同时提高程序的安全性和可靠性,一般放在头文件中或者文件的开始部分。<br>       在C99标准中，const关键字定义的变量是全局变量。const 关键字与#definc关键字存在区别，#define关键字只是简单的文本替换，而const关键字定义的变量是存储在静态存储器中的。使用#define关键字定义常量的形式为</p> 
<pre><code>#define PI3.14159</code></pre> 
<p><br>       使用该方式定义后，无论在何处使用PI,都会被预处理器以3.14159替代，编译器不对PI进行类型检查，若使用不慎，则很可能由预处理引入错误，且这类错误很难发现。用const声明变量的方式虽然增加了分配空间，但可以很好地消除预处理引入的错误，并提供了良好的类型检查形式,保证安全性。<br> 利用 const关键字进行编程时需要注意以下三点。<br> （1)使用const关键字声明的变量，只能读取,不能被赋值。如:</p> 
<pre><code>const uint8t sum = 3.14;
uint8_t abs=0;

...
sum= abs;//非法,将导致编译错误,因为sum 只能被读取,不能赋值
abs- sum: //合法</code></pre> 
<p><br> (2） const关键词修饰的变量在声明时必须初始化，上述语句表示 sum值是3.14，且sum值在编译时不能修改，若在编译过程中直接修改sum值，则编译器会提示出错。<br> (3)函数的形参声明为const,则意味着所传递的指针指向的内容只能读,不能被修改。如C语言的标准函数库中用于统计字符串长度的函数 int strlen(const char*str)。</p> 
<h1 id="static%20%E5%85%B3%E9%94%AE%E5%AD%97">
<br><strong>static 关键字</strong>
</h1> 
<p>      在嵌入式C语言中，static关键字可以用来修饰变量，使用static关键字修饰的变量，称为静态变量。<br>       静态变量的存储方式与全局变量一样，都是静态存储方式。全局变量的作用范围是整个源程序，当一个源程序由多个源文件组成时，全局变量在各个源文件中都是有效的，即一个全局变量定义在某个源文件中，若想在另一个源文件中使用该全局变量，则只需要在该源文件中通过 extern关键字声明该全局变量就可以使用了。若在该全局变量前加上关键字static，则该全局变量被定义成一个静态全局变量,其作用范围只在定义该变量的源文件内有效，其他源文件不能引用该全局变量，这样就避免了在其他源文件中因引用相同名字的变量而引发的错误,有利于模块化程序设计。<br>       利用static关键字进行编程时需要注意以下要点。<br>       (1)static关键字不仅可以用来修饰变量，而且可以用来修饰函数。模块化程序设计中，若用static声明一个函数，则该函数只能被该模块内的其他函数调用，例如:<br>  </p> 
<pre><code class="language-cpp">      #include "stm32f1xx_hal .h”
      static void DMA_SetConfig (DMA_HandleTypeDef *hdma,uint32_t SrcAddress,uint32_t DstAddress, uint32_t DataLength);
...
      HAL_statusTypeDef HAL_DMA_start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
      HAL_StatusTypeDef status- HAL_OK;”
.... ...
      if(HAL_DMA_STATE_REA.DY m- hdma-&gt;state)
  {
        DMA_Setconfig(hdma, SrcAddress, DstAddress, DataLength);
       ... ...
  }
      ... ...
}
</code></pre> 
<p> 上述代码为DMA模块的源文件stm32f1xx_hal_dma.c,若利用static将DMA_SetConfig()函数声明为一个静态函数，则 DMA_SetConfig)函数只能被stm32flxx_hal_dma.c中的其他函数调用，而不能被其他模块的文件使用，即定义了一个本地函数，有效避免了因其他模块的文件定义了同名函数而引发的错误，充分体现了程序的模块化设计思想。<br> (2） static除了用于定义静态全局变量，还用于定义静态局部变量，保证静态局部变量在调用过程中不被重新初始化。典型应用案例有实现计数统计功能。</p> 
<pre><code class="language-cpp">void fun_count()
{
      static count_num=0;
      //声明一个静态局部变量,count_num用作计数器,初值为0
      count_num++;
      printf("%dn",count_num) :
}
int main(void)
(
     int i=0;
     for( i=0;i&lt;=5;i++)
  {
     fun_count();
  }
     return 0;
}
</code></pre> 
<p>在main函数中每调用一次 fun_count()函数，静态局部变量count_num加1，而不是每次都被初始化为初值0。</p> 
<h1 id="volatile%E5%85%B3%E9%94%AE%E5%AD%97">
<br><strong>volatile关键字</strong>
</h1> 
<p><br>       嵌入式开发中，常用到volatile关键字，它是一个类型修饰符，含义为“易变的”。使用方式如下:</p> 
<pre><code class="language-cpp">volatile char i;</code></pre> 
<p><br>       这里使用volatile关键字定义了一个字符型的变量i,指出i是随时可能发生变化的，每次使用该变量时都必须从i的地址中读取。<br>       由于内存的读/写速度远不及CPU中寄存器的读/写速度,为了提高数据信息的存取速度,一方面在硬件上引入高速缓存Cache，另一方面在软件上使用编译器对程序进行优化,将变量的值提前从内存读取到CPU的寄存器中，以后用到该变量时,直接从速度较快的寄存器中读取，这样有利于提高运算速度，但同时也可能存在风险,如该变量在内存中的值有可能被程序的其他部分（如其他线程)修改或覆盖，而寄存器中存放的仍是之前的值，这就导致应用程序读取的值和实际变量值不一致;也有可能是寄存器中的值发生了改变，而内存中该变量的值没有被修改，同样也会导致不一致的情况发生。因此，为防止由于编译器对程序进行优化导致读取错误数据，使用 volatile关键词进行定义。<br>       简单地说，使用volatile关键字就是不让编译器进行优化，即每次读取或者修改值时,都必须重新从内存中读取或者修改，而不是使用保存在寄存器的备份。<br>       举个简单的例子:大学里的奖/助学金的发放一般都是直接转给学校,学校再发给每名学生，学校财务处都登记了每名学生的银行卡号，但不可避免地会有一些学生因各种原因丢失银行卡或不再使用这张银行卡，而没来得及去财务处重新登记,从而影响奖/助学金的发放，这里，学生就是变量的原始地址，而财务处的银行卡号就是变量在寄存器中的备份,使用 volatile关键字来定义学生这个变量，这样每次发放奖/助学金时都去找学生这个变量的原始地址，而不是直接转到财务处保存的银行卡上，进而避免错误的发生。<br>        const关键字的含义为“只读”,volatile关键字的含义为“易变的”，但volatile关键字解释为“直接存取原始内存地址”更为合适，使用 volatile关键字定义变量后,该变量就不会因外因而发生变化了。一般来说，volatile 关键字常用在以下场合。<br>      (1）中断服务程序中修改的、供其他程序检测的变量需要使用volatile关键字。</p> 
<p>     (2)多任务环境下各任务间共享的标志应添加 volatile关键字。</p> 
<p>  （3）外设寄存器地址映射的硬件寄存器通常要用volatile关键字进行声明。</p> 
<h1 id="extern%E5%85%B3%E9%94%AE%E5%AD%97">
<br><strong>extern关键字</strong>
</h1> 
<p><br>        extern关键字用于指明此函数或变量定义在其他文件中，提示编译器遇到此函数或变量时到其他模块中寻找其定义。这样,extern关键字声明的函数或变量就可以在本模块或其他模块中使用，因此，使用extern关键字是一个声明而不是重新定义。使用方法如下:</p> 
<pre><code class="language-cpp">extern int a;
extern int  funA( ):</code></pre> 
<p><br>       解析:第一条语句仅仅是变量a的声明,而不是定义变量a，并未为a分配内存空间，变量a作为全局变量只能被定义一次。第二条语句声明函数funA()，此函数已在其他文件中定义。<br>        STM32中,extern关键字还有一个重要作用，即与"C一起连用，即 extern "c"，进行链接指定。例如,stm32f10x.h头文件中有如下代码。</p> 
<pre><code class="language-cpp">#ifndef _STM32F10× H
#define _STM32F10x_H
#ifdef .epluspius
extern "C"{
#endif
...
#ifdef _eplusplus
}
"endif</code></pre> 
<p>       这段代码的含义是，若没有定义_STM32F10x_H,则定义_STM32F10x H，若已经定义_cplusplus，则执行 extern "C"中语句，extern "C"是告诉C++编译器括号中的程序代码是按照C语言的文件格式进行编译的，_cplusplus是C++编译器中自定义的宏，plus是“+”的意思。<br> C+H+支持函数重载，即在编译时会将函数名与参数联合起来生成一个新的中间函数名称，而C语言不支持函数重载，这就导致在C++环境下使用C函数会出现链接时找不到对应函数的情况，这时就需要使用extern "C"进行链接指定，告知编译器此时采用的是C语言定义的函数，需要使用C语言 的命名规则来处理函数，不要生成用于链接的中间函数名。<br>        一般将函数声明存放在头文件中，当函数有可能被C语言或C+使用时,将函数声明存放在 extern "C"中以免出现编译错误，完整的使用方法如下:<br>  </p> 
<pre><code class="language-cpp">#ifdef__cplusplus
   extern "C"{
    #endif
   //函数声明
    #ifdef_Cplusplus
     }
#endif
</code></pre> 
<p>       STM32中很多头文件都采用这样的用法，如标准外设库中的 stm32f1 0x_adc.h ,stm32f10x can.h、 stm32f1Ox_gpio.h 等。<br>       利用extern 关键字进行编程时需要注意以下要点。<br>       嵌入式开发一般采用模块化设计思想,因此,为保证全局变量和功能函数的使用,extern关键字一般用在.h头文件中对某个模块提供给其他模块调用的外部函数及变量进行声明,实际编程中只需要将该.h头文件包含进该模块对应的.c文件中，即在该模块的.c文件中加入代码#include "xxx.h”。实例如下:<br><img alt="" height="312" src="https://images2.imgbox.com/e7/1f/tG7wINwb_o.png" width="658"></p> 
<h1 id="%C2%A0struct%E7%BB%93%E6%9E%84%E4%BD%93"><strong> struct结构体</strong></h1> 
<p>      struct用于定义结构体类型，其作用是将不同数据类型的数据组合在一起,构造出一个新的数据类型。struct一般用法如下:</p> 
<pre><code class="language-cpp"> struct  结构体名
	{
	 数据类型　　　成员名1；
	 数据类型　　　成员名2；
	 数据类型　　　成员名n；
	 }；
</code></pre> 
<pre><code class="language-cpp">struct Student{         //声明结构体
    char name[20];      //姓名
    int num;            //学号
    float score;        //成绩
};</code></pre> 
<h1 id="enum"><strong>enum</strong></h1> 
<p>       有时一个变量会有几种可能的取值，如一个星期有7天、每学期开设的课程、12种不同的颜色（红、橙、黄、绿、青、蓝、紫、灰、粉、黑、白、棕)等,C语言提供了一种enum枚举类型，用来将变量或对象的所有可能的值一一列出,变量取值只限于列举出来的值。enum枚举类型的用法如下:<br>  </p> 
<pre><code class="language-cpp">enum枚举名
{
枚举成员1,
枚举成员2,
...
枚举成员n;
}枚举变量;
</code></pre> 
<p>      enum枚举类型是一个集合,将所有可能的取值用花括号括住,花括号中的各枚举成员之间用逗号隔开,最后一个枚举成员后省略逗号。enum枚举类型以分号结束,这里的枚举变量可以省略,在后面需要时再根据枚举名进行定义。<br> 例如，利用enum枚举类型列举几种常见的颜色。<br>  </p> 
<pre><code class="language-cpp">enum Color
{
RED,
GREEN,
BLACK,
YELLOw
}；</code></pre> 
<p>      上述名为 Color的枚举类型只有4个成员:RED、GREEN、BLACK、YELLOW,即意味着Color类型变量的取值只能取这4种颜色中的某一种颜色。<br>       例如，利用enum定义一个 Weekdays枚举类型名，包括7个枚举成员:从星期一到星期日,并定义枚举变量 Mydays 与 Olddays.</p> 
<pre><code class="language-cpp">enumweekdays
{
Monday=1，
Tuesday,
wednesday,
Thursday,
Friday,
Saturday,
sunday
}Mydays.olddays;
</code></pre> 
<p>      注意:enum枚举类型具有自动编号功能，第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员值上自动加1，也可以自定义枚举成员的值，若把第一个枚举成员的值定义为1,则第二枚举成员的值就为2,依此类推,如上述例子中 Friday 的值为5。因此，enum枚举类型中的枚举成员的值是常量而不是变量,不能在程序中用赋值语句再对它赋值,但可以将枚举值赋给枚举变量。<br> 例如，以下两条语句是正确的。</p> 
<pre><code class="language-cpp">Mydays=Thursday；
olddays=Friday；</code></pre> 
<p><br>       但以下两条语句是错误的。</p> 
<pre><code class="language-cpp">Tuesday=o;
Mydays=1;</code></pre> 
<h1 id="%C2%A0typedef"><strong> typedef</strong></h1> 
<p>      typedef用于为复杂的声明定义一个简单的别名，它不是一个真正意义上的新类型。在编程中使用 typedef的目的一般有两个:①为变量起一个容易记忆且意义明确的新名称;②简化一些比较复杂的类型声明。其基本格式如下:<br> typedef类型名自定义的别名;<br> 例如:</p> 
<pre><code class="language-cpp">typedef signed char int8_t;//为数据类型signed char起别名int8_t
typedef signed int int32_t;//为数据类型signed int起别名int32_t</code></pre> 
<p><br>       STM32开发中,typedef主要有以下三种用法。<br>     <strong>  1． typedef的基本应用</strong><br>       为已知的数据类型起一个简单的别名,如上例。<br><strong>      2. typedef 与结构体struct结合使用</strong><br>       该用法用于自定义数据类型。如 stm32f10x_gpio.h头文件中的GPIO初始化结构体GPIO_InitTypeDef。</p> 
<pre><code class="language-cpp">typedef struct
{
   uint16_t GPIO_ Pin;
   GPIOSpeed_TypeDef GPIO_Speed;
   GPIOMode TypeDef GPIO_Mode;
}IGPIo_InitTypeDef;</code></pre> 
<p><br>        上述语句利用 struct创建了一个新的结构体，这个新结构体有三个成员 GPIO_Pin、GPIO_Speed和 GPIO_Mode，同时又使用 typedef为这个新建的结构体定义一个新的名称GPIO_InitTypeDef，在应用时就可以直接使用GPIO_InitTypeDef 来定义变量。例如:</p> 
<pre><code class="language-cpp">GPIO_InitTypeDef GPIO_ InitStrueture;</code></pre> 
<p><br>        上述语句利用 GPIO_InitTypeDef结构体定义了一个变量GPIO_InitStructure，引用三个成员的方法如下:</p> 
<pre><code class="language-cpp">GPIO InitStructure.GPIO_Pin;
GPIO_InitStructure.GPIO_Speed;
GPIO InitStructure.GPIO Mode;</code></pre> 
<p><strong>3. typedef 与 enum结合使用</strong><br>       利用typedef关键字将枚举类型定义成别名，并利用该别名进行变量声明，STM32标准外设库v3.5.0版本中有很多enum和 typedef结合使用的应用。stm32f10x_gpio.h头文件中的代码如下。</p> 
<pre><code class="language-cpp">Typedef enum
{
GPIO Speed_1OMHz=1,
GPIo_Speed_2MHz,
GPIOSpeed_50MHz;
}GPIOSpeed_TypeDef;</code></pre> 
<p><br>        该例中enum枚举类型共有三个成员:GPIO Speed_10MHz、GPIO Speed_2MHz和GPIO_Speed_50MHz，并将第一个枚举成员GPIO_Speed_10MHz赋值为1，enum枚举类型会将枚举成员的赋值在第一个枚举成员赋值的基础上加1，因此GPIO_Speed_2MHz 默认值为2,GPIO_Speed_50MHz默认值为3。同时,利用typedef关键字将此枚举类型定义一个别名GPIOSpeed TypeDef，这里省略了枚举类型的枚举名，只用 typedef为枚举类型定义一个别名。</p> 
<h1 id="%23define">
<br><strong>#define</strong>
</h1> 
<p>      #define是C语言的预处理命令,它用于宏定义,用来将一个标识符定义为一个字符串,该标识符称为宏名，被定义的字符串称为替换文本,采用宏定义的目的主要是方便程序编写，一般放在源文件的前面,称为预处理部分。<br>       所谓预处理是指在编译前所做的工作。预处理是C语言的一个重要功能,由预处理程序负责完成，程序编译时，系统将自动引用预处理程序对源程序中的预处理部分进行处理，处理完毕后自动进入对源程序的编译。<br>       STM32标准外设库中,#define的使用方式主要有以下两种。<br><strong>1．无参数宏定义</strong><br> 无参数宏定义的一般形式如下:</p> 
<pre><code class="language-cpp">#define&lt;宏名&gt;字符串&gt;</code></pre> 
<p><br> 其中,字符串可以是常数、字符串和表达式等。<br>        例如:#define UINT8_MAX 255<br>        该语句表示定义了宏名UINT8_MAX,它代表255,例如:#define_IO volatile;<br>        该语句表示定义宏名_IO，代表 volatile，若以后程序中再需要用到 volatile,则可以使用IO。<br>        例如:#define RCC AHBPeriph_DMA1 ((uint32_t)0x00000001)<br>        该语句表示定义RCC_AHBPeriph_DMA1宏名,代表32位的无符号数据0x00000001.</p> 
<p>       STM32中有很多此类用法，如标准外设库 v3.5.0的 stm32f1 0x_rcc.h文件中APB2_peripheral外设基地址的定义，如图5所示。</p> 
<p><img alt="" height="372" src="https://images2.imgbox.com/0d/45/UAzo9K34_o.png" width="506"></p> 
<p>                          图5  APB2_peripheral各外设基地址的定义<br><br><strong>2．带参数的宏定义</strong><br> 宏定义格式如下:</p> 
<pre><code class="language-cpp">#define&lt;宏名&gt;(参数1，参数2，…，参数n)&lt;替换列表&gt;</code></pre> 
<p>例如:</p> 
<pre><code class="language-cpp">define SUM(x,y) (x+y)
…
a=SUM(2,2）:</code></pre> 
<p><br> 其中，a的结果是4，将 SUM(X,y)定义为x+y，预编译时会将SUM(x,y)替换为xty。<br> 例如:</p> 
<pre><code class="language-cpp">#define IsGPIO_SPEED(SPEED)（((SPEED) = GP1o_Speed_10MHz)||((SPEED)==GPIO_Speed_ 2MHz)||（(SPEED)==GP10_Speed_50MHz)）</code></pre> 
<p><br> 使用宏定义#define 将 IS_GPIO_SPEED(SPEED)替换为 GPIO_Speed_10MHz、GPIO_Speed_2MHz或者GPIO_Speed_50MHz。<br>       注意:带参数的宏定义同样也只是进行简单的字符替换，替换是在编译前进行的，展开并不分配内存单元，不进行值的传递处理，因此替换不会占用运行时间，只占用编译时间，因此该方式可以提高运行效率。<br>        #define与 typedef的区别为:typedef是在编译阶段处理的，具有类型检查的功能,而#define是在预处理阶段处理的，即在编译前，只进行简单的字符串替换，而不进行任何检查。</p> 
<h1 id="%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">
<br><strong>回调函数</strong>
</h1> 
<p>       回调函数是一个通过函数指针调用的函数。操作系统中的某些函数常需要调用用户定义的函数来实现其功能，由于与常用的用户程序调用系统函数的调用方向相反，因此将这种调用称为回调（Callback），而被系统函数调用的函数就称为回调函数。<br>       STM32的HAL库在stm32flxx_hal_xxx.c文件中定义了相应的回调函数，并由中断触发，其实质是中断处理程序。如 stm32flxx_hal_gpio.c代码中通过GPIO中断处理函数voidHAL _GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)调用相应的回调函数HAL_GPIO_EXTICallback(GPIO_Pin)，开发人员只需要在回调函数中编写应用程序就能实现中断服务功能。</p> 
<h1 id="%23ifdef%20%E3%80%81%23ifndef%E3%80%81%23else%20%C2%A0%E3%80%81%23if%20%C2%A0%20%C2%A0">
<strong><em>#ifdef 、#ifndef、#else  </em>、</strong><em><strong>#if</strong>    </em>
</h1> 
<p><br><em>#define            定义一个预处理宏<br> #undef            取消宏的义<br>  #if                  编译预处理中的条件命令，相当于C语法中的if语句<br> #ifdef              判断某个宏是否被定义，若已定义，执行随后的语句<br> #ifndef            与#ifdef相反，判断某个宏是否未被定义<br> #elif                若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if<br> #else              与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else<br> #endif             #if, #ifdef, #ifndef这些条件命令的结束标志.<br> defined          与#if, #elif配合使用，判断某个宏是否被定义</em></p> 
<p><em>指针相关内容我这里就不在赘述了网上有很多丰富的资料。</em></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>