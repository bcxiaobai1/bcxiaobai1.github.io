<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C&#43;&#43;】| C/C&#43;&#43;内存管理 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】| C/C&#43;&#43;内存管理</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24"><strong>前言：</strong></span></p> 
<p><span style="color:#1a439c"><strong><span style="background-color:#ffd900">在上期，我们已经对类和对象的全部知识进行了总结和梳理。在类和对象学习完之后，今天我将给大家呈现的是关于——C/C++内存管理的基本知识。</span></strong></span></p> 
<p class="img-center"><img alt="【C++】C/C++内存管理（new和delete详解）- 惊觉" src="https://images2.imgbox.com/b3/4b/QnTRj5W1_o.jpg"></p> 
<p> </p> 
<hr>
<p id="main-toc"><strong>本文目录</strong></p> 
<p id="1.%20C%2FC%2B%2B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83-toc" style="margin-left:0px"><a href="#1.%20C%2FC%2B%2B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83">1. C/C++内存分布</a></p> 
<p id="2.%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px"><a href="#2.%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">2. C语言中动态内存管理方式</a></p> 
<p id="%EF%BC%881%EF%BC%89C%E8%AF%AD%E8%A8%80%E8%B7%9F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px"><a href="#%EF%BC%881%EF%BC%89C%E8%AF%AD%E8%A8%80%E8%B7%9F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">（1）C语言跟内存分配方式</a></p> 
<p id="(2)C%E8%AF%AD%E8%A8%80%E8%B7%9F%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%282%29C%E8%AF%AD%E8%A8%80%E8%B7%9F%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0">(2)C语言跟内存申请相关的函数</a></p> 
<p id="%EF%BC%883%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px"><a href="#%EF%BC%883%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98">（3）面试题</a></p> 
<p id="3.%20C%2B%2B%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-toc" style="margin-left:0px"><a href="#3.%20C%2B%2B%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">3. C++中动态内存管理</a></p> 
<p id="3.1%20new%2Fdelete%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px"><a href="#3.1%20new%2Fdelete%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">3.1 new/delete操作内置类型</a></p> 
<p id="3.2%20new%E5%92%8Cdelete%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px"><a href="#3.2%20new%E5%92%8Cdelete%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">3.2 new和delete操作自定义类型</a></p> 
<p id="4.%20operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%F0%9F%98%8E-toc" style="margin-left:0px"><a href="#4.%20operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%F0%9F%98%8E">4. operator new与operator delete函数?</a></p> 
<p id="5.%20new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:0px"><a href="#5.%20new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">5. new和delete的实现原理</a></p> 
<p id="5.1%20%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px"><a href="#5.1%20%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">5.1 内置类型</a></p> 
<p id="5.2%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px"><a href="#5.2%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">5.2 自定义类型</a></p> 
<p id="6.%20%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F(placement-new)-toc" style="margin-left:0px"><a href="#6.%20%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F%28placement-new%29">6. 定位new表达式(placement-new)</a></p> 
<p id="7.%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px"><a href="#7.%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">7. 常见面试题</a></p> 
<p id="7.1%20malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px"><a href="#7.1%20malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB">7.1 malloc/free和new/delete的区别</a></p> 
<p id="8.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px"><a href="#8.%E6%80%BB%E7%BB%93">8.总结</a></p> 
<hr id="hr-toc">
<p></p> 
<p></p> 
<h1></h1> 
<h1 id="1.%20C%2FC%2B%2B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><a href="#1.%20C%2FC%2B%2B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83">1. C/C++内存分布</a></h1> 
<blockquote> 
 <p><strong>C++的内存管理其实还是延续了C语言的内存管理的规则，首先第一点带大家解答为什么需要内存管理？?</strong></p> 
</blockquote> 
<ul>
<li><span style="color:#1a439c"><strong>因为在程序里面需要不同类型或者不同性质的数据，那这些不同的数据是存在不同的区域，例如我之前讲过内存中有堆区，栈区，静态区等不同的区域。</strong></span></li>
<li><span style="color:#1a439c"><strong>有这些区域的本质原因，即是对于不同的数据类型有不同的特性，我们为了方便更好的对其进行管理呢，就会把一些相同特性的数据分到同一区域进行管理。</strong></span></li>
</ul>
<p><span style="color:#0d0016"><strong>接下来，我们通过习题的方式带大家来具体的理解其中的关系：</strong></span></p> 
<pre><code class="language-cpp">int globalVar = 1;
static int staticGlobalVar = 1;
void Test()
{
 static int staticVar = 1;
 int localVar = 1;
 int num1[10] = { 1, 2, 3, 4 };
 char char2[] = "abcd";
 const char* pChar3 = "abcd";
 int* ptr1 = (int*)malloc(sizeof(int) * 4);
 int* ptr2 = (int*)calloc(4, sizeof(int));
 int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);
 free(ptr1);
 free(ptr3);
}

1. 选择题：
   选项: A.栈  B.堆  C.数据段(静态区)  D.代码段(常量区)

   globalVar在哪里？____   staticGlobalVar在哪里？____
   staticVar在哪里？____   localVar在哪里？____
   num1 在哪里？____
   
   char2在哪里？____       *char2在哪里？___
   pChar3在哪里？____      *pChar3在哪里？____
   ptr1在哪里？____        *ptr1在哪里？____</code></pre> 
<p><span style="color:#fe2c24"><strong>解析如下：</strong></span></p> 
<ul>
<li>
<strong><span style="color:#1a439c">【globalVar】：</span></strong> <strong> globalVar作为全局变量在<span style="color:#fe2c24">数据段</span>（静态区）</strong>
</li>
<li><strong><span style="color:#1a439c">【staticGlobalVar】：</span>staticGlobalVar作为<span style="color:#fe2c24">静态全局变量在静态区</span></strong></li>
<li>
<strong><span style="color:#1a439c">【staticVar】：</span>staticVar作为</strong><span style="color:#fe2c24"><strong>静态局部变量在静态区</strong></span>
</li>
<li>
<strong><span style="color:#1a439c">【localVar】：</span></strong> <strong> localVar作为</strong><span style="color:#fe2c24"><strong>局部变量</strong></span>，<strong>局部变量放在</strong><span style="color:#fe2c24"><strong>栈区</strong></span>
</li>
<li>
<strong><span style="color:#1a439c">【num1】：</span></strong> <strong> num1为</strong><span style="color:#fe2c24"><strong>局部变量</strong></span>，<strong>一样也存放在</strong><span style="color:#fe2c24"><strong>栈区</strong></span>
</li>
</ul>
<p><strong><span style="background-color:#ffd900">以上这个五个我相信大多数小伙伴都可以作对的，接下来我们讲解下面几个：</span></strong></p> 
<ul>
<li>
<span style="color:#1a439c"><strong>【char2】：</strong></span>  <strong>char2是一个数组，跟num1的区别是（num1是自己确定大小，而char2是通过初始化来确定大小），所以不难得出num1和char2是在一个地方的，即——<span style="color:#fe2c24">作为局部变量，放在栈区</span>  </strong>
</li>
<li>
<span style="color:#1a439c"><strong>【*char2】：</strong></span><strong>char2是一个数组，把后面常量字符串拷贝过来到数组中，数组在栈上，所以*char2在<span style="color:#fe2c24">栈上</span></strong>
</li>
<li>
<span style="color:#1a439c"><strong>【pChar3】：</strong></span> <strong>pChar3局部变量在<span style="color:#fe2c24">栈区</span></strong>
</li>
<li>
<span style="color:#1a439c"><strong>【* pChar3】：</strong></span><strong> *pChar3得到的是字符串常量字符在<span style="color:#fe2c24">代码段</span></strong>
</li>
<li><strong><span style="color:#1a439c">【ptr1】：</span>  ptr1是指针，作为<span style="color:#fe2c24">局部变量</span>在<span style="color:#fe2c24">栈区   </span></strong></li>
<li><strong><span style="color:#1a439c">【* ptr1】：</span> *ptr1就是ptr指向的那块空间，因此得到的是<span style="color:#fe2c24">动态申请空间的数据在堆区</span></strong></li>
</ul>
<blockquote> 
 <p><span style="color:#0d0016"><strong>接下来，我们结合图形，大家可以直观的感受！！</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="694" src="https://images2.imgbox.com/4e/d6/esaSnWwt_o.png" width="1006"></p> 
<p><strong> 接下来，还有个连环的问题，大家在看看下列的题目，不知道各位是否能够拿下它呢？</strong></p> 
<pre><code class="language-cpp"> sizeof(num1) = ____;  

 sizeof(char2) = ____;   strlen(char2) = ____;

 sizeof(pChar3) = ____;   strlen(pChar3) = ____;

 sizeof(ptr1) = ____;</code></pre> 
<p><span style="color:#fe2c24"><strong>解析：</strong></span></p> 
<ul>
<li>  <strong>sizeof(num1) = __40__; <span style="color:#fe2c24">sizeof数组名，即计算数组大小,10个整形数据一共40字节</span></strong>
</li>
<li>  <strong>sizeof(char2) = __5__;<span style="color:#fe2c24"> 包括的空间，因此为5</span></strong>
</li>
<li><strong>  strlen(char2) = __4__; <span style="color:#fe2c24">遇到即截止，不包括的长度，因此为4</span></strong></li>
<li><strong>  sizeof(pChar3) = __4__; <span style="color:#fe2c24">因为pChar3为指针，所以跟后面指向的美誉关系，32位下为大小4，64位下8</span></strong></li>
<li><strong>  strlen(pChar3) = __4__; <span style="color:#fe2c24">字符串“abcd”的长度，不包括的长度</span></strong></li>
<li><strong>  sizeof(ptr1) = __4__;<span style="color:#fe2c24"> ptr1是指针，同上</span></strong></li>
</ul>
<p></p> 
<p><span style="color:#fe2c24"><strong>【说明】?</strong></span></p> 
<ul>
<li><span style="color:#1a439c"><strong>1. 栈又叫堆栈--非静态局部变量/函数参数/返回值等等，栈是向下增长的。</strong></span></li>
<li><span style="color:#1a439c"><strong>2. 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口 创建共享共享内存，做进程间通信。（Linux课程如果没学到这块，现在只需要了解一下）</strong></span></li>
<li><span style="color:#1a439c"><strong>3. 堆用于程序运行时动态内存分配，堆是可以上增长的。 </strong></span></li>
<li><span style="color:#1a439c"><strong>4. 数据段--存储全局数据和静态数据。 </strong></span></li>
<li><span style="color:#1a439c"><strong>5. 代码段--可执行的代码/只读常量。</strong></span></li>
</ul>
<p>通过上述的问题带大家仔细再次认识了一下程序在内中的分布问题。接下来，我们将探讨关于动态内存管理方式的问题！！！</p> 
<hr>
<h1 id="2.%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><a href="#2.%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">2. C语言中动态内存管理方式</a></h1> 
<p>这个知识点，我们在之前就已经具体的讲到过了，在这里给大家简单的在过一遍。这里给大家一段代码，大家先回顾一下之前有关的知识：</p> 
<pre><code class="language-cpp">void Test ()
{
int* p1 = (int*) malloc(sizeof(int));
free(p1);

// 1.malloc/calloc/realloc的区别是什么？
int* p2 = (int*)calloc(4, sizeof (int));
int* p3 = (int*)realloc(p2, sizeof(int)*10);

// 这里需要free(p2)吗？
free(p3 );
}
</code></pre> 
<h2 id="%EF%BC%881%EF%BC%89C%E8%AF%AD%E8%A8%80%E8%B7%9F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><strong><span style="background-color:#ffd900">（1）C语言跟内存分配方式</span></strong></h2> 
<ul>
<li>&lt;1&gt;<span style="color:#fe2c24"><strong>从静态存储区域分配.</strong></span>
</li>
<li><strong>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在.例如全局变量、static变量.</strong></li>
<li>&lt;2&gt;<span style="color:#fe2c24"><strong>在栈上创建</strong></span>
</li>
<li><strong>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放.栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限.</strong></li>
<li>&lt;3&gt;<span style="color:#fe2c24"><strong>从堆上分配，亦称动态内存分配.</strong></span>
</li>
<li><strong>程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存.动态内存的生存期由用户决定，使用非常灵活，但也很容易出现问题</strong></li>
</ul>
<h2 id="(2)C%E8%AF%AD%E8%A8%80%E8%B7%9F%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><strong><span style="background-color:#ffd900">(2)C语言跟内存申请相关的函数</span></strong></h2> 
<blockquote> 
 <p><strong>C语言跟内存申请相关的函数主要有calloc、malloc、free、realloc等.</strong></p> 
</blockquote> 
<p></p> 
<ul>
<li><span style="color:#1a439c"><strong> &lt;a&gt;malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.</strong></span></li>
<li><span style="color:#1a439c"><strong>&lt;b&gt;calloc则将初始化这部分的内存,设置为0.</strong></span></li>
<li><span style="color:#1a439c"><strong>&lt;c&gt;realloc则对malloc申请的内存进行大小的调整.</strong></span></li>
<li><span style="color:#1a439c"><strong>&lt;d&gt;申请的内存最终需要通过函数free来释放.</strong></span></li>
</ul>
<p><span style="color:#fe2c24"><strong>⭐</strong><strong>切记：</strong></span></p> 
<ul><li><span style="color:#fe2c24"><strong> 当程序运行过程中malloc了,但是没有free的话,会造成内存泄漏.一部分的内存没有被使用,但是由于没有free,因此系统认为这部分内存还在使用,造成不断的向系统申请内存,使得系统可用内存不断减少.</strong></span></li></ul>
<hr>
<p>对于<strong>malloc</strong>详细的知识可以参考如下地址：</p> 
<p><a class="link-info" href="https://legacy.cplusplus.com/reference/cstdlib/malloc/?kw=malloc" title="malloc函数">malloc函数</a></p> 
<p>对于<strong>calloc</strong>详细的知识可以参考如下地址：</p> 
<p><a class="link-info" href="https://legacy.cplusplus.com/reference/cstdlib/calloc/?kw=calloc" title="calloc函数">calloc函数</a></p> 
<p>对于<strong>realloc</strong>详细的知识可以参考如下地址：</p> 
<p><a class="link-info" href="https://legacy.cplusplus.com/reference/cstdlib/realloc/?kw=realloc" title="realloc函数">realloc函数</a></p> 
<hr>
<h2 id="%EF%BC%883%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98"><span style="background-color:#ffd900">（3）面试题</span></h2> 
<p>接下来给大家解答一个常见的面试题——<span style="color:#fe2c24"><strong>malloc/calloc/realloc的区别？</strong></span></p> 
<p><span style="color:#fe2c24"> <strong>区别</strong>:</span></p> 
<p><br><span style="color:#1a439c"><strong>    (1)函数malloc不能初始化所分配的内存空间,而函数calloc能</strong></span></p> 
<ul>
<li><strong>如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;</strong></li>
<li><strong>反之, 如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据.</strong></li>
<li><strong>也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间已经被重新分配)那么就可能会出现问题.</strong></li>
</ul>
<p><br><span style="color:#1a439c"><strong>    (2)函数calloc() 会将所分配的内存空间中的每一位都初始化为零</strong></span></p> 
<ul>
<li><strong>也就是说,如果你是字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;</strong></li>
<li><strong>如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针;</strong></li>
<li><strong>如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零.</strong></li>
</ul>
<p><br>    <span style="color:#1a439c"><strong> (3)函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void*类型.</strong></span></p> 
<ul><li><strong>void*表示未确定类型的指针.C,C++规定，void* 类型可以强制转换为任何其它类型的指针.</strong></li></ul>
<p><br>  <span style="color:#1a439c"><strong>   (4)realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.</strong></span></p> 
<ul>
<li><strong>当然，如果是缩小，则被缩小的那一部分的内容会丢失.realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址.</strong></li>
<li><strong>相反，realloc返回的指针很可能指向一个新的地址.</strong></li>
</ul>
<p><br><span style="color:#1a439c"><strong>    (5)realloc是从堆上分配内存的.</strong></span></p> 
<ul>
<li><strong>当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；</strong></li>
<li><strong>如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.这句话传递的一个重要的信息就是数据可能被移动.</strong></li>
</ul>
<hr>
<p></p> 
<h1 id="3.%20C%2B%2B%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">3. C++中动态内存管理</h1> 
<h2 id="3.1%20new%2Fdelete%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">3.1 new/delete操作内置类型</h2> 
<blockquote> 
 <p><strong>C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力，而且使用起来比较麻烦，因 此C++又提出了自己的内存管理方式：</strong></p> 
</blockquote> 
<ul><li><span style="color:#fe2c24"><strong>通过new和delete操作符进行动态内存管理。</strong></span></li></ul>
<p>首先第一个知识点来了，那就是小伙伴们知道默认情况下【new】会不会初始化呢？</p> 
<p class="img-center"><img alt="" height="494" src="https://images2.imgbox.com/37/bd/uHY3fSri_o.png" width="1200"></p> 
<p><strong><span style="background-color:#ffd900">我通过调试带大家仔细瞧瞧是不是像我所说的那样：</span></strong></p> 
<p class="img-center"><img alt="" height="235" src="https://images2.imgbox.com/33/4e/2wmUxCXL_o.png" width="1200"></p> 
<ul><li><strong><span style="background-color:#ffd900"> 从上述我们不难发现，不管是对于【new】定义的【p1】来说，还是通过传统的【malloc】方式定义的【p2】来说，默认都是没有进行初始化操作的！！！</span></strong></li></ul>
<p><strong>那么大家就会好奇了，【new】是否可以初始化呢？</strong></p> 
<ul><li><span style="color:#1a439c"><strong>答案当然是可以的，接下来我带大家看看具体的操作。</strong></span></li></ul>
<p class="img-center"><img alt="" height="303" src="https://images2.imgbox.com/1e/55/nAFJEk3G_o.png" width="1179"></p> 
<blockquote> 
 <p> 此时，一个可能让大家混淆的点就出现了，大家是否能够区别下述这种方法呢？?</p> 
</blockquote> 
<pre><code class="language-cpp">int* p1 = new int(1);//初始化

int* p3 = new int[10];</code></pre> 
<p><span style="color:#fe2c24"><strong>大家是否知道这两个的区别呢？不知道没关系，接下来我给大家解答一下：</strong></span></p> 
<ul>
<li>
<span style="color:#0d0016"><strong>对于【int* p1 = new int(1);】</strong></span><span style="color:#1a439c"><strong>：这是进行初始化操作，申请一个（int）类型，并初始化为1；</strong></span>
</li>
<li>
<span style="color:#0d0016"><strong>对于（int* p3 = new int[10];）</strong></span><span style="color:#1a439c"><strong>：它的意思动态申请10个int类型的空间</strong></span>
</li>
<li><span style="color:#1a439c"><strong>大家一定区分二者之间的差别，不要搞混淆了！！</strong></span></li>
</ul>
<p class="img-center"><img alt="" height="322" src="https://images2.imgbox.com/bd/18/3aMJMpgb_o.png" width="1161"></p> 
<blockquote> 
 <p><strong> 那对于<span style="color:#0d0016">（int* p3 = new int[10];）这种情况，我们是否还能对其初始化呢？其实也是可以的，C++支持这样的操作，具体如下所示：</span></strong></p> 
</blockquote> 
<pre><code class="language-cpp">	int* p4 = new int[10] {1, 2, 3, 4};</code></pre> 
<p><span style="color:#0d0016"><strong><span style="background-color:#ffd900"> 当我们想对其进行初始化时，只需在后面加上</span></strong></span><span style="color:#fe2c24"><strong><span style="background-color:#ffd900">【{}】</span></strong></span><span style="color:#0d0016"><strong><span style="background-color:#ffd900">即可，那么是不是呢？我通过调试给大家展示：</span></strong></span></p> 
<p class="img-center"><img alt="" height="327" src="https://images2.imgbox.com/55/2a/0Y3Tuk8s_o.png" width="1200"></p> 
<p> </p> 
<p></p> 
<p><strong>我们从上述不难看出，当我们用【new】时是不是比我们用【malloc】方便得多呀！</strong></p> 
<ul><li><span style="color:#1a439c"><strong>对于【malloc】我们不仅需要强转类型，还需要进行检查</strong></span></li></ul>
<p><span style="color:#0d0016"><strong>还是通过代码，大家就可以一目了然两者之间的差别到底有多大：</strong></span></p> 
<p class="img-center"><img alt="" height="572" src="https://images2.imgbox.com/94/0b/kKp5KqWz_o.png" width="1200"></p> 
<p><span style="color:#fe2c24"><strong> 注意：</strong></span></p> 
<ol><li><strong><span style="color:#1a439c">此时很多小伙伴或许就会问，难道【new】不会失败吗？其实是会的，它失败的机制跟【malloc】是不一样的，它通过“抛异常”来进行错误判别的，我们后面会讲到。</span></strong></li></ol>
<p>我用一张图给大家总结，大家看下表就能直观的理解上面的知识了：</p> 
<p class="img-center"><img alt="" height="633" src="https://images2.imgbox.com/2b/08/6GkZvihD_o.png" width="656"></p> 
<p><strong> <span style="color:#fe2c24">特别注意一点:?</span></strong></p> 
<ul><li><strong>申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用 new[]和delete[]，<span style="color:#fe2c24">注意：匹配起来使用</span>。</strong></li></ul>
<hr>
<h2 id="3.2%20new%E5%92%8Cdelete%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">3.2 new和delete操作自定义类型</h2> 
<blockquote> 
 <p>上述我们已经知道一点，new/delete 和 malloc/free对于内置类型的处理几乎是一样的，但是对于自定义类型是否也是一样的呢？</p> 
</blockquote> 
<p>我们还是通过代码来大家理解这个问题，大家看以下代码，最终的结果是什么呢？</p> 
<pre><code class="language-cpp">class A
{
public:
	A(int a = 0)
		: _a(a)
	{
		cout &lt;&lt; "A():" &lt;&lt; this &lt;&lt; endl;
	}
	~A()
	{
		cout &lt;&lt; "~A():" &lt;&lt; this &lt;&lt; endl;
	}
private:
	int _a;
};

int main()
{
	A* p1 = (A*)malloc(sizeof(A));
	A* p2 = new A(1);

	free(p1);
	delete p2;

		return 0;
}</code></pre> 
<p><span style="color:#fe2c24"><strong>解析：</strong></span></p> 
<p>我们直接打印看看最后的结果是什么。</p> 
<p class="img-center"><img alt="" height="317" src="https://images2.imgbox.com/a0/48/AtEgMNwk_o.png" width="523"></p> 
<ul><li><span style="color:#1a439c"><strong> 通过上述不知道大家有没有发现一个点呀！那就是此时这里我们是定义的两个，怎么只调用了一次构造和析构函数呢？是谁没有调用呢？接下来，通过调试，我带大家一步一步的去查看</strong></span></li></ul>
<p></p> 
<p class="img-center"><img alt="" height="414" src="https://images2.imgbox.com/b8/b5/qwxlnkfA_o.png" width="1200"></p> 
<p><span style="color:#fe2c24"><strong> 解析：</strong></span></p> 
<ul><li><strong>第一步，首先是对【p1】进行的操作，此时当执行完【p1】之后，我们发现并没有去调用构造函数。</strong></li></ul>
<p class="img-center"><img alt="" height="330" src="https://images2.imgbox.com/43/71/N0boQvbe_o.png" width="1200"></p> 
<p> <span style="color:#fe2c24"><strong> 解析：</strong></span></p> 
<ul><li>
<span style="color:#1a439c"><strong>此时，当我们去执行完【p2】之后，我们发现，此时程序就去调用了构造函数，并且成功的完成了初始化操作。</strong></span><span style="color:#0d0016"><strong>继续执行</strong></span>
</li></ul>
<p class="img-center"><img alt="" height="382" src="https://images2.imgbox.com/42/10/TvAqjoA0_o.png" width="1200"></p> 
<p>  <span style="color:#fe2c24"><strong> 解析：</strong></span></p> 
<ul><li><span style="color:#1a439c"><strong>当执行完毕，对其进行释放的时候，我们可以发现，程序是先对【p1】进行的释放，但是此时并没有去调用析构函数。</strong></span></li></ul>
<p class="img-center"><img alt="" height="414" src="https://images2.imgbox.com/c7/b5/CS76rZsm_o.png" width="1200"></p> 
<p>  <span style="color:#fe2c24"><strong> 解析：</strong></span></p> 
<ul><li><span style="color:#1a439c"><strong>最后，当我们对【p2】进行释放的时候，此时程序调用了析构函数，并且也成功的把【p2】释放掉了。</strong></span></li></ul>
<blockquote> 
 <p>因此，综上所述：<strong><span style="background-color:#ffd900">在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc与 free不会。</span></strong></p> 
</blockquote> 
<hr>
<h1 id="4.%20operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%F0%9F%98%8E">4. operator new与operator delete函数?</h1> 
<ul>
<li><span style="color:#1a439c"><strong>上述我们已经知道对于 【new】和【delete】是用户进行动态内存申请和释放的操作符；</strong></span></li>
<li><span style="color:#1a439c"><strong>而接下来要学习的operator new 和operator delete是系统提供的全局函数；</strong></span></li>
<li><span style="color:#1a439c"><strong>new在底层调用operator new全局函数来申请空间，delete在底层通过 operator delete全局函数来释放空间。</strong></span></li>
</ul>
<p><strong>大家是不是一看到这个就以为是函数重载呀！在之前我们已经学习过，【new】是函数，而【operator】是重载的符号：</strong></p> 
<ul>
<li><span style="color:#1a439c"><strong>其实不然啊，大家千万不要这么理解。这里的两个函数是库里面提供的两个全局函数，不是运算符重载哟！！！</strong></span></li>
<li><span style="color:#1a439c"><strong>取这个名字给大家造成了极大的误解，至于为什么要这么定义呢？我们也不得而知了，可能我们的祖师爷在设计的时候没有想到好名字，这就造成了许多学习【C++】的在这里吃了一个亏。</strong></span></li>
</ul>
<blockquote> 
 <p>接下来带大家浅浅的看一下库里面是怎么实现这两个函数的，以下为库里面的代码（看不明白没关系）</p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900">对于【operator new】，库里面是这么写的：</span></strong></p> 
<pre><code class="language-cpp">/*
operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间
失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。
*/

void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)
{
// try to allocate size bytes
void *p;
while ((p = malloc(size)) == 0)
  if (_callnewh(size) == 0)
     {
         // report no memory
         // 如果申请内存失败了，这里会抛出bad_alloc 类型异常
         static const std::bad_alloc nomem;
         _RAISE(nomem);
     }
return (p);
}</code></pre> 
<p><span style="color:#fe2c24"><strong>解析：</strong></span></p> 
<ul><li><strong>大家看代码，我们可以看到operator new里面是不是调用的【malloc】啊，只是它这里跟【malloc】不同的是，紧接着往下看我们可以发现，上述代码【malloc】之后赋值给了【p】，然后判断，如果【p】等于0的话就调用【(_callnewh(size) == 0】这个函数，然后进入里面进行了“抛异常”，即【malloc】失败了就会抛异常。</strong></li></ul>
<p></p> 
<p><strong><span style="background-color:#ffd900">而对于【operator delete】，库里面是这么写的：</span></strong></p> 
<pre><code class="language-cpp">/*
operator delete: 该函数最终是通过free来释放空间的
*/
void operator delete(void *pUserData)
{
     _CrtMemBlockHeader * pHead;
     RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));
     if (pUserData == NULL)
         return;
     _mlock(_HEAP_LOCK);  /* block other threads */
     __TRY
         /* get a pointer to memory block header */
         pHead = pHdr(pUserData);
          /* verify block type */
         _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));
         _free_dbg( pUserData, pHead-&gt;nBlockUse );
     __FINALLY
         _munlock(_HEAP_LOCK);  /* release other threads */
     __END_TRY_FINALLY
     return;
}
/*
free的实现
*/
#define   free(p)               _free_dbg(p, _NORMAL_BLOCK)
</code></pre> 
<p><span style="color:#fe2c24"><strong>解析：</strong></span></p> 
<ul><li><strong>上面那一大串的大家都可以不用看，看最后的一两行，最后是不是显示的【free】啊！</strong></li></ul>
<p></p> 
<p><strong><span style="background-color:#ffd900">因此，我们可以得出一个结论：</span></strong></p> 
<ul>
<li><span style="color:#1a439c"><strong>通过上述两个全局函数的实现知道，operator new 实际也是通过malloc来申请空间，如果 malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。</strong></span></li>
<li><span style="color:#1a439c"><strong>operator delete 最终是通过free来释放空间的。</strong></span></li>
<li><span style="color:#1a439c"><strong>因此，【operator delete】和【operator new】本质上就是【delete】和【new】的封装。</strong></span></li>
</ul>
<p></p> 
<blockquote> 
 <p><strong>接下来就给大家讲解其中的原因？</strong></p> 
</blockquote> 
<p>首先，我们怎么使用者两个函数呢？其实吧，这两个函数的实现跟【malloc】是类似的，我们举例观察：</p> 
<p class="img-center"><img alt="" height="388" src="https://images2.imgbox.com/af/17/MXi3RZNf_o.png" width="690"></p> 
<p><span style="color:#fe2c24"><strong>解析：</strong></span></p> 
<ul>
<li><strong>对于上述的【p1】，我们使用的是【<span style="color:#1a439c">operator new</span>】，我们不难发现跟【malloc】的实现方式很类似。</strong></li>
<li><strong>只是底层的机制不一样罢了。对于【malloc】实现，会进行严格的检查，而对于【<span style="color:#1a439c">operator new</span>】则是失败后“抛异常”！！</strong></li>
</ul>
<p><span style="color:#0d0016"><strong><span style="background-color:#ffd900">紧接着大家是否好奇为什么会有这两个函数呢？</span></strong></span></p> 
<ul>
<li><strong><span style="color:#1a439c">我们都知道【c++】兼容C语言，就拿我们之前以及讲过的“引用”为例，当在【C++】中为了实现这个会去单独的创造一套语法啊什么的出来吗？应该不会吧。</span><span style="color:#fe2c24">引用底层是按指针</span><span style="color:#1a439c">的方式来实现引用，那么这时还有必要再去创造新的东西呢？结果可能而知。</span></strong></li>
<li><strong><span style="color:#1a439c">现在我们来对比一下【new】的实现，第一步是</span><span style="color:#fe2c24">申请空间</span>，<span style="color:#1a439c">紧接着就是</span><span style="color:#fe2c24">调用构造函数</span>。<span style="color:#1a439c">对于申请空间是不是就是去堆上申请啊，在【C】语言中我们也是从堆上申请的呀！而在【C】语言中，对于申请空间，是不是就要调用【malloc】。</span></strong></li>
<li><strong><span style="color:#1a439c">而对于【C++】来说，因为它是</span><span style="color:#fe2c24">面向对象</span><span style="color:#1a439c">的语言，虽然兼容C语言，但是新增的那部分是面向对象的，而面向对象的语言处理异常使用的是</span>“<span style="color:#fe2c24">抛异常</span>”。<span style="color:#1a439c">而在【C】语言中，对于失败，返回的是【null】，就不符合我们的需求，所以C++就用</span>【<span style="color:#1a439c">operator new</span>】<span style="color:#1a439c">去封装【malloc】，封装【malloc】失败之后“抛异常”！！！?</span></strong></li>
</ul>
<p><span style="color:#0d0016">我们在通过反汇编的角度去看看，不难发现底层确实像我们所说的那样：</span></p> 
<p class="img-center"><img alt="" height="528" src="https://images2.imgbox.com/79/a7/0Tr21DMn_o.png" width="1200"></p> 
<p></p> 
<hr>
<p> </p> 
<h1 id="5.%20new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">5. new和delete的实现原理</h1> 
<h2 id="5.1%20%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">5.1 内置类型</h2> 
<ul>
<li><strong><span style="color:#1a439c">如果申请的是内置类型的空间，new和malloc，delete和free基本</span><span style="color:#fe2c24">类似</span><span style="color:#1a439c">.</span></strong></li>
<li>
<strong><span style="color:#fe2c24">不同的地方是：</span> new/delete申请和释放的是<span style="color:#fe2c24">单个</span>元素的空间，new[]和delete[]申请的是<span style="color:#fe2c24">连续</span>空间，而且new在申 请空间失败时会<span style="color:#fe2c24">抛异常</span>，malloc会返回NULL</strong>。</li>
</ul>
<h2 id="5.2%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">5.2 自定义类型</h2> 
<p><span style="color:#fe2c24"><strong>new的原理</strong></span></p> 
<ul>
<li><span style="color:#1a439c"><strong>1. 调用operator new函数申请空间 </strong></span></li>
<li><span style="color:#1a439c"><strong>2. 在申请的空间上执行构造函数，完成对象的构造</strong></span></li>
</ul>
<p><span style="color:#fe2c24"><strong>delete的原理</strong></span></p> 
<ul>
<li><span style="color:#1a439c"><strong>1. 在空间上执行析构函数，完成对象中资源的清理工作</strong></span></li>
<li><span style="color:#1a439c"><strong>2. 调用operator delete函数释放对象的空间</strong></span></li>
</ul>
<p><span style="color:#fe2c24"><strong>new T[N]的原理</strong></span></p> 
<ul>
<li><span style="color:#1a439c"><strong>1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对 象空间的申请 </strong></span></li>
<li><span style="color:#1a439c"><strong>2. 在申请的空间上执行N次构造函数</strong></span></li>
</ul>
<p><span style="color:#fe2c24"><strong>delete[]的原理</strong></span></p> 
<ul>
<li><span style="color:#1a439c"><strong>1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理</strong></span></li>
<li><span style="color:#1a439c"><strong>2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释 放空间</strong></span></li>
</ul>
<hr>
<p></p> 
<h1 id="6.%20%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F(placement-new)">6. 定位new表达式(placement-new)</h1> 
<p>作用：<span style="color:#1a439c"><strong>定位new表达式是在已分配的原始内存空间中调用构造函数初始化一个对象。</strong></span></p> 
<p>使用格式：</p> 
<ul>
<li><span style="color:#1a439c"><strong>new (place_address) type或者new (place_address) type(initializer-list) </strong></span></li>
<li><span style="color:#1a439c"><strong>place_address必须是一个指针，initializer-list是类型的初始化列表</strong></span></li>
</ul>
<p>我们先看一下以下代码：</p> 
<pre><code class="language-cpp">int main()
{
	A aa;

	A* p1 = (A*)malloc(sizeof(A));
	if (p1 == nullptr)
	{
		perror("malloc fail");
	}
	return 0;
}
</code></pre> 
<p>解析：</p> 
<p>此时，我们这里有一块已经【malloc】出来的空间，此时当我们在想对其进行初始化时是不行的</p> 
<p class="img-center"><img alt="" height="312" src="https://images2.imgbox.com/9e/33/1IfkBEWZ_o.png" width="650"></p> 
<p> </p> 
<blockquote> 
 <p>此时对于【C++】来说，对已经有一块空间的进行初始化，此时应该怎么办呢？基于这种情况，就引入了——定位new</p> 
</blockquote> 
<pre><code class="language-cpp">new(p1)A;  // 注意：如果A类的构造函数有参数时，此处需要传参

new(p1)A(1);  </code></pre> 
<p>接下来，我们通过调试带大家去看看：</p> 
<p class="img-center"><img alt="" height="234" src="https://images2.imgbox.com/84/a1/101BOsAK_o.png" width="1200"></p> 
<p> </p> 
<p><span style="color:#fe2c24"><strong>解析：</strong></span></p> 
<ul><li><span style="color:#1a439c"><strong>对于没有参数的时候，调试出来的我们发现也没有参数。</strong></span></li></ul>
<p class="img-center"><img alt="" height="503" src="https://images2.imgbox.com/d2/e9/8HdPTKFU_o.png" width="627"></p> 
<p> <span style="color:#fe2c24"><strong>解析：</strong></span></p> 
<ul><li><span style="color:#1a439c"><strong>对于有参数的时候，调试出来的我们对其进行了初始化操作。</strong></span></li></ul>
<p></p> 
<p>当我们想去调用析构函数时，我们可以显示的去调用是可以的，具体如下：</p> 
<pre><code class="language-cpp">int main()
{
	A aa;

	A* p1 = (A*)malloc(sizeof(A));
	if (p1 == nullptr)
	{
		perror("malloc fail");
	}

	//new(p1)A;  // 注意：如果A类的构造函数有参数时，此处需要传参

	new(p1)A(1);  

	p1-&gt;~A(); //调用析构函数，显示的去调用
	free(p1);


	return 0;
}</code></pre> 
<p>输出结果为：</p> 
<p class="img-center"><img alt="" height="266" src="https://images2.imgbox.com/05/ea/5MTCEw5M_o.png" width="821"></p> 
<p> </p> 
<p><strong>大家看完这个是不是会觉得十分麻烦呀！这么复杂搞得，我们直接【new】不是更好吗？具体如下：</strong></p> 
<pre><code class="language-cpp">	A* p2 = new A;
</code></pre> 
<ul><li><strong><span style="background-color:#ffd900">其实确实是这样的，在实际当中对其自定义类型，我们直接用【new】就可以了，没必要再去【malloc】紧接着再去使用这个定位new。</span></strong></li></ul>
<p>那么何时我们改用这个呢？</p> 
<ul><li><span style="color:#1a439c"><strong>定位new表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化。 </strong></span></li></ul>
<p><strong>如果还没明白。接下来我讲个故事，大家可以类比的进行理解：</strong></p> 
<ul>
<li><span style="color:#1a439c"><strong>在以前，假如还没有水缸之类的东西用于存储，假如此时我们要煮饭，我们就去水井里舀水回来，总之就是当我们想使用水时时就要去水井里盛水回来；</strong></span></li>
<li><span style="color:#1a439c"><strong>现在引入内存池，意思就相当于现在有装水的容器了，我们可以一次性盛许多水回来，当我们想用时就不用再每次去水井里盛水了，只有当装水的容器里没了之后，我们才去水井里盛水。</strong></span></li>
</ul>
<hr>
<p></p> 
<h1 id="7.%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">7. 常见面试题</h1> 
<h2 id="7.1%20malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB">7.1 malloc/free和new/delete的区别</h2> 
<p><span style="color:#fe2c24"><strong>malloc/free和new/delete的共同点是：</strong></span></p> 
<ul><li><span style="color:#1a439c"><strong>都是从堆上申请空间，并且需要用户手动释放。</strong></span></li></ul>
<p><span style="color:#fe2c24"><strong>不同的地方是：</strong></span></p> 
<ul>
<li><span style="color:#1a439c"><strong>1. malloc和free是函数，new和delete是操作符 </strong></span></li>
<li><span style="color:#1a439c"><strong>2. malloc申请的空间不会初始化，new可以初始化 </strong></span></li>
<li><span style="color:#1a439c"><strong>3. malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可， 如果是多个对象，[]中指定对象个数即可</strong></span></li>
<li><span style="color:#1a439c"><strong>4. malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型</strong></span></li>
<li><span style="color:#1a439c"><strong>5. malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需 要捕获异常</strong></span></li>
<li><span style="color:#1a439c"><strong>6. 申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new 在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成 空间中资源的清理</strong></span></li>
</ul>
<p></p> 
<h1 id="8.%E6%80%BB%E7%BB%93">8.总结</h1> 
<blockquote> 
 <p>以上便是关于C/C++内存管理的问题，还有部分关于内存泄漏的问题，我们到后面在讲。最后，总结一下本期的内容。</p> 
</blockquote> 
<p><strong>对于内存管理呢，C/C++其实是类似的，唯独在C++中引入了【new】和【delete】机制。</strong></p> 
<p><span style="color:#fe2c24"><strong>并且建议使用【new】和【delete】机制，原因有二：</strong></span></p> 
<ul>
<li><span style="color:#1a439c"><strong>第一是因为用起来方便许多相比于【malloc】这种方式；</strong></span></li>
<li><span style="color:#1a439c"><strong>第二个原因针对自定义类型，【new】和【delete】能更好的调用构造函数和析构函数，而【malloc】则不满足这种场景。</strong></span></li>
</ul>
<blockquote> 
 <p>到此，便是关于内存管理的所有内容。如果感觉对您有帮助的话，麻烦点赞三连哟！！！</p> 
</blockquote> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/9d/00/6N3oIoaI_o.gif"></p> 
<p> </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>