<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>网络问题排查实例集锦（实战经验分享） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络问题排查实例集锦（实战经验分享）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81Windows%E9%98%B2%E7%81%AB%E5%A2%99%E6%8B%A6%E6%88%AA%E4%BA%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%BF%87%E6%9D%A5%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E9%93%BE%E5%A4%B1%E8%B4%A5-toc" style="margin-left:40px"><a href="#1%E3%80%81Windows%E9%98%B2%E7%81%AB%E5%A2%99%E6%8B%A6%E6%88%AA%E4%BA%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%BF%87%E6%9D%A5%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E9%93%BE%E5%A4%B1%E8%B4%A5">1、Windows防火墙拦截了客户端发过来的TCP连接请求，导致客户端与服务器建链失败</a></p> 
<p id="2%E3%80%81%E5%9C%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BE%A7%E6%8A%93%E5%8C%85%E9%80%89%E9%94%99%E7%BD%91%E5%8D%A1%E4%BA%86%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%8A%93%E7%9A%84%E5%8C%85%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E4%B8%8D%E4%B8%8A-toc" style="margin-left:40px"><a href="#2%E3%80%81%E5%9C%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BE%A7%E6%8A%93%E5%8C%85%E9%80%89%E9%94%99%E7%BD%91%E5%8D%A1%E4%BA%86%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%8A%93%E7%9A%84%E5%8C%85%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E4%B8%8D%E4%B8%8A">2、在Linux服务器侧抓包选错网卡了，导致抓的包和客户端对不上</a></p> 
<p id="3%E3%80%81%E5%8D%87%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%94%B9%E5%8F%98%E4%BA%86%EF%BC%8C%E5%AF%BC%E8%87%B4%E8%BD%AF%E4%BB%B6%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7%E4%BA%86-toc" style="margin-left:40px"><a href="#3%E3%80%81%E5%8D%87%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%94%B9%E5%8F%98%E4%BA%86%EF%BC%8C%E5%AF%BC%E8%87%B4%E8%BD%AF%E4%BB%B6%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7%E4%BA%86">3、升级服务器的端口改变了，导致软件无法进行在线升级了</a></p> 
<p id="4%E3%80%81Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%BC%80%E5%90%AF%E4%BA%86reuse%E5%92%8Crecycle%E9%80%89%E9%A1%B9%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%9A%E6%97%B6%E4%B8%8D%E6%97%B6%E8%BF%9E%E4%B8%8D%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px"><a href="#4%E3%80%81Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%BC%80%E5%90%AF%E4%BA%86reuse%E5%92%8Crecycle%E9%80%89%E9%A1%B9%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%9A%E6%97%B6%E4%B8%8D%E6%97%B6%E8%BF%9E%E4%B8%8D%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8">4、Linux服务器系统中开启了reuse和recycle选项，导致客户端会时不时连不上服务器</a></p> 
<p id="5%E3%80%81Windows%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%8C%E7%BD%91%E5%8D%A1%E6%97%B6%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1-toc" style="margin-left:40px"><a href="#5%E3%80%81Windows%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%8C%E7%BD%91%E5%8D%A1%E6%97%B6%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1">5、Windows系统中使用双网卡时可能需要添加策略路由</a></p> 
<p id="6%E3%80%81%E8%BF%9E%E6%8E%A5%E7%BA%BF%E8%B7%AF%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%B0%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%AC%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E6%8E%89%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%90%8E%E7%BB%AD%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px"><a href="#6%E3%80%81%E8%BF%9E%E6%8E%A5%E7%BA%BF%E8%B7%AF%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%B0%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%AC%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E6%8E%89%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%90%8E%E7%BB%AD%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8">6、连接线路中的网络设备将客户端与本网络设备的连接关闭掉，导致后续登录服务器时出现异常</a></p> 
<p id="7%E3%80%81%E5%9C%A8%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%87%E6%8D%A2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98-toc" style="margin-left:40px"><a href="#7%E3%80%81%E5%9C%A8%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%87%E6%8D%A2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98">7、在复杂网络环境中主从服务器切换时遇到的多个网络异常问题</a></p> 
<p id="8%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E7%9A%84TCP%2FIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%87%8D%E5%AE%9A%E5%90%91%E9%80%89%E9%A1%B9%E8%A2%AB%E5%85%B3%E9%97%AD%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E5%93%8D%E5%BA%94%E7%BD%91%E5%85%B3%E5%8F%91%E6%9D%A5%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E6%B6%88%E6%81%AF%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E4%B8%A5%E9%87%8D%E7%9A%84%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98-toc" style="margin-left:40px"><a href="#8%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E7%9A%84TCP%2FIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%87%8D%E5%AE%9A%E5%90%91%E9%80%89%E9%A1%B9%E8%A2%AB%E5%85%B3%E9%97%AD%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E5%93%8D%E5%BA%94%E7%BD%91%E5%85%B3%E5%8F%91%E6%9D%A5%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E6%B6%88%E6%81%AF%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E4%B8%A5%E9%87%8D%E7%9A%84%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98">8、Linux系统的TCP/IP协议栈重定向选项被关闭后，无法响应网关发来的重定向消息，导致收发数据出现严重的丢包问题</a></p> 
<hr id="hr-toc">
<p>       现在大部分软硬件系统都是基于网络的，有走局域网（私网）的，有走外网（公网）的，会不可避免地出现很多与网络相关的问题，特别是将产品部署到安全级别较高的客户环境中，会出现各式各样的复杂网络问题。今天我们就来分享一下实际项目中遇到的多个网络问题，以供参考！</p> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/e7/dc/lteTJZEX_o.png" width="530"></p> 
<h2 id="1%E3%80%81Windows%E9%98%B2%E7%81%AB%E5%A2%99%E6%8B%A6%E6%88%AA%E4%BA%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%BF%87%E6%9D%A5%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E9%93%BE%E5%A4%B1%E8%B4%A5">1、Windows防火墙拦截了客户端发过来的TCP连接请求，导致客户端与服务器建链失败</h2> 
<p>       这是一个Windows系统自带的防火墙拦截程序网络数据的例子。客户端和服务器程序运行在两台Windows电脑上，客户端需要连接到远端的服务器上获取数据，但客户端始终连接不上远端的服务器。用wireshark抓包看，<strong>客户端给服务器发送TCP三次握手的SYN包，服务器始终没有回应，导致TCP连接始终无法建立。</strong></p> 
<p>       我们先是<span style="color:#be191c">ping</span>了服务器所在机器的IP地址，是能ping通的。又在服务器所在电脑上使用<span style="color:#be191c">netstat -a</span>命令查看到服务器的9001端口是出于<span style="color:#be191c">Listening</span>监听状态的，如下所示：</p> 
<p class="img-center"><img alt="" height="444" src="https://images2.imgbox.com/14/e0/FEGHFcmw_o.png" width="675"></p> 
<p>这就奇怪了，<strong>服务器的ip能ping的通的，服务器的端口也处于正常的监听状态</strong>，为啥始终没法和服务器建链呢？</p> 
<p>       后来想到我们在Widnows系统上第一次运行程序时，一般都会弹出类似下面的截图：</p> 
<p class="img-center"><img alt="" height="427" src="https://images2.imgbox.com/68/95/hOnF28LY_o.png" width="538"></p> 
<p>一般情况下我们使用默认的选择，没有全部勾选，直接就点击下面的“允许访问”的按钮了。窗口中提示Windows防火墙已经阻止了部分功能，应该是将公网网络和专网网络都勾选上的，<strong>估计是Windows防火墙将发给该服务器程序的部分数据包拦截了</strong>，于是将服务器程序所在系统的Windows防火墙关闭，然后客户端可以正常连接了。</p> 
<p>       其实可以在服务器侧抓包，客户端发来的用于三次握手的SYN包，服务器所在机器的网卡应该收到了，只是向应用层传递数据时数据被防火墙拦截了。</p> 
<p>       最终的解决办法是允许该服务器程序能通过防火墙进行通信，在控制面板中点击<strong>系统和安全-&gt;Widnows Defender防火墙-&gt;允许应用或功能通过Windows防火墙</strong>，在打开的界面中找到服务器程序：</p> 
<p class="img-center"><img alt="" height="454" src="https://images2.imgbox.com/4f/c8/kQivuxlh_o.png" width="667"></p> 
<p>将专用网络和公用都勾上，点击确定就好了。即允许服务器程序通过防火墙进行通信，防火墙就不会拦截发给服务器的数据包了。</p> 
<h2 id="2%E3%80%81%E5%9C%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BE%A7%E6%8A%93%E5%8C%85%E9%80%89%E9%94%99%E7%BD%91%E5%8D%A1%E4%BA%86%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%8A%93%E7%9A%84%E5%8C%85%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E4%B8%8D%E4%B8%8A">2、在Linux服务器侧抓包选错网卡了，导致抓的包和客户端对不上</h2> 
<p>       客户端和服务器通信的过程中出现了问题，导致业务出现了异常，于是要在客户端和服务端两侧抓包，对照两边的网络数据包，看看到底是哪一侧出问题了。</p> 
<p>       客户端运行在Windows系统中，直接启动<span style="color:#be191c">WireShark</span>就可以直击抓包了。服务器运行在远端的Linux系统上，需要使用<span style="color:#be191c">SSH</span>工具远程登录到Linux系统中，然后使用<span style="color:#be191c">tcpdump</span>命令进行抓包，然后再将抓包文件下载到Windows系统中，然后使用WireShark打开查看。</p> 
<p>       打开服务器的抓包文件后，发现有问题，和客户端抓的数据包对不上，<strong>服务器侧的抓包文件中显示的服务器IP地址，和终端侧抓包文件中显示的服务器IP地址是不一致的</strong>。服务器侧抓到的包中显示的是服务器IP是<strong>内网的IP</strong>，而终端侧抓包显示连接的服务器IP是<strong>外网的IP</strong>，所以两边对不上的，后来想起来可能<strong>输入tcpdump命令时选错了网卡</strong>导致的。</p> 
<p>       后经平台侧的运维同事确认，Linux服务器上确实有两张物理网卡，在Linux命令行中使用<span style="color:#be191c">ifconfig</span>命令就可以查看到服务器上的网卡信息，<strong>一个是配置了内网的eth0网卡，一个是配置了外网IP的eth1网卡：</strong></p> 
<p class="img-center"><img alt="" height="329" src="https://images2.imgbox.com/54/a5/4qzHiQ1C_o.png" width="534"></p> 
<p>所以要修改之前输入的tcpdump命令，命令中指定抓eth1网卡的数据包：</p> 
<blockquote> 
 <p><strong>tcpdump</strong> <span style="color:#be191c"><strong> -i eth1</strong></span>  -s 0  -w  dvsserver.pcap</p> 
</blockquote> 
<p>或者抓所有网卡的数据包：</p> 
<blockquote> 
 <p><strong>tcpdump</strong>  <span style="color:#be191c"><strong>-i any</strong></span>  -s 0  -w  dvsserver.pcap</p> 
</blockquote> 
<h2 id="3%E3%80%81%E5%8D%87%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%94%B9%E5%8F%98%E4%BA%86%EF%BC%8C%E5%AF%BC%E8%87%B4%E8%BD%AF%E4%BB%B6%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7%E4%BA%86">3、升级服务器的端口改变了，导致软件无法进行在线升级了</h2> 
<p style="text-align:center"><img alt="" height="278" src="https://images2.imgbox.com/bb/f8/gperCvJM_o.png" width="463"></p> 
<p>       某日测试同事在客户端软件上发起在线版本监测，结果始终连不上服务器。使用wireshark抓包看到，软件在发送TCP三次握手的<span style="color:#be191c">SYN</span>包后，远端服务器直接回了个<span style="color:#be191c">RST</span>包，强行将客户端的连接请求给终止了。</p> 
<p>       首先，服务器回包了，那服务器肯定是能<span style="color:#be191c">ping</span>通的，于是使用<span style="color:#be191c">telnet</span>命令检测升级服务器的63000服务端口是否正常，结果该端口是连不上的。<strong>一般情况下直接回复RST可能是端口不存在引起的</strong>，经后来和升级服务器开发确认，升级服务器的端口已经变更了，不再是之前的60000端口号了。</p> 
<p>       其实这个问题中，还有两点是有问题的：</p> 
<blockquote> 
 <p>（1）客户端软件侧处理的有问题，不应该将升级服务器的端口在代码中固定为某个数字，<strong>应该使用登录时平台返回的升级服务器端口</strong>。</p> 
 <p>（2）平台变更端口后应该发邮件通知客户端侧，平台侧应该对老的客户端提供兼容支持，老的版本已经发布已经交付给客户使用，<strong>平台要对老版本做兼容，应该做个端口重定向</strong>，老版本使用60000端口发起连接时应该重定向到最新的端口上。</p> 
</blockquote> 
<h2 id="4%E3%80%81Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%BC%80%E5%90%AF%E4%BA%86reuse%E5%92%8Crecycle%E9%80%89%E9%A1%B9%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%9A%E6%97%B6%E4%B8%8D%E6%97%B6%E8%BF%9E%E4%B8%8D%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8">4、Linux服务器系统中开启了reuse和recycle选项，导致客户端会时不时连不上服务器</h2> 
<p style="text-align:center"><img alt="" height="313" src="https://images2.imgbox.com/f8/61/kSKyTwwL_o.png" width="580">       </p> 
<p>       有用户反馈软件客户端会时不时出现无法登录服务器的问题。使用Wireshark抓包看，客户端在发出三次握手的<span style="color:#be191c">SYN</span>包，始终收不到服务器的<span style="color:#be191c">ACK</span>包，甚至触发了客户端的丢包重传，即<strong>多次发送SYN包，服务器都没有回应，导致客户端和服务器建TCP连接失败</strong>。</p> 
<p>       后来在平台侧也进行了抓包，发现服务器<strong>确实收到了客户端发来的SYN包，但就是没有回ACK应答包</strong>。经排查得知，服务器的Linux系统的TCP/IP协议栈开启了<strong><span style="color:#be191c">reuse和recycle选项</span></strong>，这和协议栈的<strong>timestamp时间戳策略</strong>会冲突，如果短时间内多次收到SYN包，平台侧TCP/IP协议栈会直接将请求拒绝掉，不给SYN包发送端任何回应。</p> 
<p>        服务器侧这两个选项一般都不能开启，特别是<strong><span style="color:#be191c">tcp_tw_recycle</span>选项开启后，可能会导致部分连接请求不响应，导致连接失败。</strong>在服务器侧，可以通过命令直接将这两个选项关闭掉：</p> 
<pre><code class="language-bash">echo 0 &gt; /proc/sys/net/ipv4/tcp_tw_reuse
echo 0 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</code></pre> 
<p>        关于这两个选项的说明如下：</p> 
<blockquote> 
 <p>（1）<strong>tcp_tw_reuse</strong>：主要用于端口复用，用在客户端侧，将其设置为1表示允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭。<br> （2）<strong>tcp_tw_recycle</strong>：将其设置为1表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p> 
</blockquote> 
<h2 id="5%E3%80%81Windows%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%8C%E7%BD%91%E5%8D%A1%E6%97%B6%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1">5、Windows系统中使用双网卡时可能需要添加策略路由</h2> 
<p>       在一台测试用的Windows PC机上，配置了两张网卡，一张是连接外网的网卡，用于上外网；一张是连接内网的网卡，用于连局域网，如下：</p> 
<p class="img-center"><img alt="" height="165" src="https://images2.imgbox.com/25/db/JcZ7qH4H_o.png" width="534"></p> 
<p>而<strong>Windows操作系统只允许设置一个默认网关</strong>，<strong>所以只能有一个网卡配置默认网关，一般是连接外网的网卡配置默认网关，因为外网的IP地址是不固定的。</strong>内网的网卡则不配置网关，对于内网的IP地址是相对固定的，比如以<span style="color:#be191c">192.168</span>开头的、以<span style="color:#be191c">172.16</span>开头的、以<span style="color:#be191c">10.</span>开头的。当要访问这些地址时，可以通过<span style="color:#494949"><strong>添加策略路由的方式</strong></span>指定访问这些开头的IP地址从指定的局域网的网关出去。</p> 
<p>       只要是有网卡配置了默认网关，都会在路由表中添加一条走默认网关的默认路由，如下所示：</p> 
<p class="img-center"><img alt="" height="449" src="https://images2.imgbox.com/61/6b/nhcYilUg_o.png" width="680"></p> 
<p>通过命令去添加策略路由时，也会向系统中添加对应的路由条目，添加策略路由的命令如下：</p> 
<pre><code class="language-bash">route add 172.16.0.0 mask 255.255.0.0  172.16.125.88（内网的网关）</code></pre> 
<p>这条添加路由命令的含义是：<strong>所有访问以172.16开头的IP地址，都从网关172.16.125.88出去。</strong></p> 
<p>       当我们发起对一个IP地址的访问时（也可能通过域名去访问，会先将域名解析为IP地址，然后用IP地址去访问），系统在查找路由时，会优先匹配系统的非默认路由，即会匹配添加的策略路由，当匹配不上时才会去使用默认路由。</p> 
<p>       所以，访问外网的地址时会走连接外网的网卡出去，访问以192.168开头的、以172.16开头的等内网地址时，会走策略路由中指定的连接内网的网关出去。</p> 
<h2 id="6%E3%80%81%E8%BF%9E%E6%8E%A5%E7%BA%BF%E8%B7%AF%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%B0%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%AC%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E6%8E%89%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%90%8E%E7%BB%AD%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8">6、连接线路中的网络设备将客户端与本网络设备的连接关闭掉，导致后续登录服务器时出现异常</h2> 
<p>       在公司局域网的测试环境中，客户端自动重连服务器出现问题。根据打印日志发现，客户端和服务器之间的TCP长连接因为网络问题出现断链，<strong>客户端在收到断链通知后，会去自动重连服务器，但始终都连接不上。</strong></p> 
<p>       根据打印日志看到，<strong>服务器返回的错误码是用户已登录</strong>。这个就奇怪了，明明是客户端收到与服务器的连接断开的通知后去重连的，为啥服务器侧还反馈我们的账号还处于登录状态呢？既然连接断了，服务器应该也能感知到的，账户不太可能还出于连接状态的！</p> 
<p>       于是使用<span style="color:#be191c">SSH</span>远程登录到服务器上，使用<span style="color:#be191c">netstat</span>查看服务器当前的TCP连接列表，在列表中看到了客户端的IP，客户端居然和服务器还处于连接状态。</p> 
<p>       于是找公司大牛帮忙排查分析一下，他查下来怀疑可能是客户端与服务器之间的<span style="color:#494949"><strong>路由器单方面将路由器与客户端之间的链路给断开了，但路由器与服务器之间的链路还保持着，还没断开</strong></span>。该路由器是好多年前购买的<span style="color:#be191c">老式华为路由器</span>，可能是路由器有问题，<strong>估计是因为客户端与服务器长时间没有数据交互，路由器认为客户端与其的链路失去活性了，强行将其与客户端之间的链路释放了。</strong></p> 
<p class="img-center"><img alt="" height="70" src="https://images2.imgbox.com/ba/ab/xigGwy0s_o.png" width="480"></p> 
<p>       客户端与服务器之间使用<span style="color:#be191c">websocket</span>网络库（<span style="color:#be191c">libwebsockets</span>开源库）进行通信的，libwebsockets库支持开启心跳机制、设置心跳参数的。为了解决连接链路上长时间不跑数据导致链路被释放问题，在初始化libwebsockets库时，设置一下心跳参数就可以了。</p> 
<p>       libwebsockets库中设置心跳参数的结构体如下所示：</p> 
<pre><code class="language-cpp">/**
 * struct lws_context_creation_info - parameters to create context with
 *
 * This is also used to create vhosts.... if LWS_SERVER_OPTION_EXPLICIT_VHOSTS
 * is not given, then for backwards compatibility one vhost is created at
 * context-creation time using the info from this struct.
 *
 * If LWS_SERVER_OPTION_EXPLICIT_VHOSTS is given, then no vhosts are created
 * at the same time as the context, they are expected to be created afterwards.
 *
 * @port:    VHOST: Port to listen on... you can use CONTEXT_PORT_NO_LISTEN to
 *        suppress listening on any port, that's what you want if you are
 *        not running a websocket server at all but just using it as a
 *        client
 * @iface:    VHOST: NULL to bind the listen socket to all interfaces, or the
 *        interface name, eg, "eth2"
 *        If options specifies LWS_SERVER_OPTION_UNIX_SOCK, this member is
 *        the pathname of a UNIX domain socket. you can use the UNIX domain
 *        sockets in abstract namespace, by prepending an @ symbole to the
 *        socket name.
 * @protocols:    VHOST: Array of structures listing supported protocols and a protocol-
 *        specific callback for each one.  The list is ended with an
 *        entry that has a NULL callback pointer.
 *        It's not const because we write the owning_server member
 * @extensions: VHOST: NULL or array of lws_extension structs listing the
 *        extensions this context supports.  If you configured with
 *        --without-extensions, you should give NULL here.
 * @token_limits: CONTEXT: NULL or struct lws_token_limits pointer which is initialized
 *        with a token length limit for each possible WSI_TOKEN_***
 * @ssl_cert_filepath:    VHOST: If libwebsockets was compiled to use ssl, and you want
 *            to listen using SSL, set to the filepath to fetch the
 *            server cert from, otherwise NULL for unencrypted
 * @ssl_private_key_filepath: VHOST: filepath to private key if wanting SSL mode;
 *            if this is set to NULL but sll_cert_filepath is set, the
 *            OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY callback is called
 *            to allow setting of the private key directly via openSSL
 *            library calls
 * @ssl_ca_filepath: VHOST: CA certificate filepath or NULL
 * @ssl_cipher_list:    VHOST: List of valid ciphers to use (eg,
 *             "RC4-MD5:RC4-SHA:AES128-SHA:AES256-SHA:HIGH:!DSS:!aNULL"
 *             or you can leave it as NULL to get "DEFAULT"
 * @http_proxy_address: VHOST: If non-NULL, attempts to proxy via the given address.
 *            If proxy auth is required, use format
 *            "username:password@server:port"
 * @http_proxy_port:    VHOST: If http_proxy_address was non-NULL, uses this port at
 *             the address
 * @gid:    CONTEXT: group id to change to after setting listen socket, or -1.
 * @uid:    CONTEXT: user id to change to after setting listen socket, or -1.
 * @options:    VHOST + CONTEXT: 0, or LWS_SERVER_OPTION_... bitfields
 * @user:    CONTEXT: optional user pointer that can be recovered via the context
 *        pointer using lws_context_user
 * @ka_time:    CONTEXT: 0 for no keepalive, otherwise apply this keepalive timeout to
 *        all libwebsocket sockets, client or server
 * @ka_probes:    CONTEXT: if ka_time was nonzero, after the timeout expires how many
 *        times to try to get a response from the peer before giving up
 *        and killing the connection
 * @ka_interval: CONTEXT: if ka_time was nonzero, how long to wait before each ka_probes
 *        attempt
 * @provided_client_ssl_ctx: CONTEXT: If non-null, swap out libwebsockets ssl
 *        implementation for the one provided by provided_ssl_ctx.
 *        Libwebsockets no longer is responsible for freeing the context
 *        if this option is selected.
 * @max_http_header_data: CONTEXT: The max amount of header payload that can be handled
 *        in an http request (unrecognized header payload is dropped)
 * @max_http_header_pool: CONTEXT: The max number of connections with http headers that
 *        can be processed simultaneously (the corresponding memory is
 *        allocated for the lifetime of the context).  If the pool is
 *        busy new incoming connections must wait for accept until one
 *        becomes free.
 * @count_threads: CONTEXT: how many contexts to create in an array, 0 = 1
 * @fd_limit_per_thread: CONTEXT: nonzero means restrict each service thread to this
 *        many fds, 0 means the default which is divide the process fd
 *        limit by the number of threads.
 * @timeout_secs: VHOST: various processes involving network roundtrips in the
 *        library are protected from hanging forever by timeouts.  If
 *        nonzero, this member lets you set the timeout used in seconds.
 *        Otherwise a default timeout is used.
 * @ecdh_curve: VHOST: if NULL, defaults to initializing server with "prime256v1"
 * @vhost_name: VHOST: name of vhost, must match external DNS name used to
 *        access the site, like "warmcat.com" as it's used to match
 *        Host: header and / or SNI name for SSL.
 * @plugin_dirs: CONTEXT: NULL, or NULL-terminated array of directories to
 *        scan for lws protocol plugins at context creation time
 * @pvo:    VHOST: pointer to optional linked list of per-vhost
 *        options made accessible to protocols
 * @keepalive_timeout: VHOST: (default = 0 = 60s) seconds to allow remote
 *        client to hold on to an idle HTTP/1.1 connection
 * @log_filepath: VHOST: filepath to append logs to... this is opened before
 *        any dropping of initial privileges
 * @mounts:    VHOST: optional linked list of mounts for this vhost
 * @server_string: CONTEXT: string used in HTTP headers to identify server
 *        software, if NULL, "libwebsockets".
 */

struct lws_context_creation_info {
    int port;                    /* VH */
    const char *iface;                /* VH */
    const struct lws_protocols *protocols;        /* VH */
    const struct lws_extension *extensions;        /* VH */
    const struct lws_token_limits *token_limits;    /* context */
    const char *ssl_private_key_password;        /* VH */
    const char *ssl_cert_filepath;            /* VH */
    const char *ssl_private_key_filepath;        /* VH */
    const char *ssl_ca_filepath;            /* VH */
    const char *ssl_cipher_list;            /* VH */
    const char *http_proxy_address;            /* VH */
    unsigned int http_proxy_port;            /* VH */
    int gid;                    /* context */
    int uid;                    /* context */
    unsigned int options;                /* VH + context */
    void *user;                    /* context */
    int ka_time;                    /* context */
    int ka_probes;                    /* context */
    int ka_interval;                /* context */
#ifdef LWS_OPENSSL_SUPPORT
    SSL_CTX *provided_client_ssl_ctx;        /* context */
#else /* maintain structure layout either way */
    void *provided_client_ssl_ctx;
#endif

    short max_http_header_data;            /* context */
    short max_http_header_pool;            /* context */

    unsigned int count_threads;            /* context */
    unsigned int fd_limit_per_thread;        /* context */
    unsigned int timeout_secs;            /* VH */
    const char *ecdh_curve;                /* VH */
    const char *vhost_name;                /* VH */
    const char * const *plugin_dirs;        /* context */
    const struct lws_protocol_vhost_options *pvo;    /* VH */
    int keepalive_timeout;                /* VH */
    const char *log_filepath;            /* VH */
    const struct lws_http_mount *mounts;        /* VH */
    const char *server_string;            /* context */

    /* Add new things just above here ---^
     * This is part of the ABI, don't needlessly break compatibility
     *
     * The below is to ensure later library versions with new
     * members added above will see 0 (default) even if the app
     * was not built against the newer headers.
     */

    void *_unused[8];
};</code></pre> 
<p>上述结构体中的ka_time、ka_interval和ka_probes三个字段，是心跳参数，这三个参数的含义是：</p> 
<blockquote> 
 <p><strong>ka_time</strong>：两个心跳包之间的时间间隔；</p> 
 <p><strong>ka_interval</strong>：给对端发送心跳包之后，收不到对端ACK确认超时时间；</p> 
 <p><strong>ka_probes</strong>：心跳包探测次数。</p> 
</blockquote> 
<p>        我们在调用<span style="color:#be191c">lws_create_context</span>接口初始化libwebsockets库时，可以指定这三个参数</p> 
<pre><code class="language-cpp">static lws_context* CreateContext()
{
    lws_set_log_level( 0xFF, NULL );
    lws_context* plcContext = NULL;

    lws_context_creation_info tCreateinfo;
    memset(&amp;tCreateinfo, 0, sizeof tCreateinfo);

    tCreateinfo.port = CONTEXT_PORT_NO_LISTEN;
    tCreateinfo.protocols = protocols;
    tCreateinfo.ka_time = 10;     // 心跳包间的时间间隔
    tCreateinfo.ka_interval = 10; // 发出心跳包后没有收到ACK确认包时重发心跳包的超时时间
    tCreateinfo.ka_probes = 3;    // 心跳探测次数，对于windows操作系统，此设置是无效的，Windows系统时固定为10次，不可修改
    tCreateinfo.options = LWS_SERVER_OPTION_DISABLE_IPV6;

    plcContext = lws_create_context(&amp;tCreateinfo);

    return plcContext;
}</code></pre> 
<p>        跟进libwebsockets库的开源代码中，函数<span style="color:#be191c">lws_create_context</span>的内部，最终调用的是<span style="color:#be191c">lws_plat_set_socket_options</span>接口，该接口内部最终是给对应的socket套接字设置心跳参数的，如下：</p> 
<pre><code class="language-cpp">LWS_VISIBLE int
lws_plat_set_socket_options(struct lws_vhost *vhost, lws_sockfd_type fd)
{
    int optval = 1;
    int optlen = sizeof(optval);
    u_long optl = 1;
    DWORD dwBytesRet;
    struct tcp_keepalive alive;
    int protonbr;
#ifndef _WIN32_WCE
    struct protoent *tcp_proto;
#endif

    if (vhost-&gt;ka_time) {
        /* enable keepalive on this socket */
        // 先调用setsockopt打开发送心跳包（设置）选项
        optval = 1;
        if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE,
                         (const char *)&amp;optval, optlen) &lt; 0)
            return 1;

        alive.onoff = TRUE;
        alive.keepalivetime = vhost-&gt;ka_time*1000;
        alive.keepaliveinterval = vhost-&gt;ka_interval*1000;
 
        if (WSAIoctl(fd, SIO_KEEPALIVE_VALS, &amp;alive, sizeof(alive),
                          NULL, 0, &amp;dwBytesRet, NULL, NULL))
            return 1;
    }

    /* Disable Nagle */
    optval = 1;
#ifndef _WIN32_WCE
    tcp_proto = getprotobyname("TCP");
    if (!tcp_proto) {
        lwsl_err("getprotobyname() failed with error %dn", LWS_ERRNO);
        return 1;
    }
    protonbr = tcp_proto-&gt;p_proto;
#else
    protonbr = 6;
#endif

    setsockopt(fd, protonbr, TCP_NODELAY, (const char *)&amp;optval, optlen);

    /* We are nonblocking... */
    ioctlsocket(fd, FIONBIO, &amp;optl);

    return 0;
}</code></pre> 
<p>所以<strong>libwebsockets库的心跳设置，使用的还是TCPIP协议栈的心跳，不是应用层自己实现的心跳机制。</strong></p> 
<p>       关于TCPIP协议栈的三个心跳参数的详细说明如下：</p> 
<blockquote> 
 <p>（1）<strong>keepalivetime：</strong>心跳正常时，本端发送一个心跳包给对端，收到对端心跳包的回应，间隔keepalivetime时间后，发下一包心跳包，windows默认的心跳包发送间隔是2小时。<br> （2）<strong>keepaliveinterval：</strong>心跳异常时，本端发送心跳包后没收到对端的回应，间隔keepaliveinterval时间后，发送下一个心跳包（继续探测）。如果多次没有收到对端的回应，当探测次数达到上限（keep-alive probes）时，则协议栈认为连接出问题。<br> （3）<strong>keep-alive probes：</strong>windows系统中 ，心跳包探测次数keep-alive probes是不可改变的，协议栈固定为10次。</p> 
</blockquote> 
<h2 id="7%E3%80%81%E5%9C%A8%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%87%E6%8D%A2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98">7、在复杂网络环境中主从服务器切换时遇到的多个网络异常问题</h2> 
<p class="img-center"><img alt="" height="382" src="https://images2.imgbox.com/e6/32/zZGGdS04_o.png" width="484"></p> 
<p>       主服务器和从服务器共用一个IP，当主服务器出问题时，切换到从服务器上，然后服务器以组播的方式将抢IP的数据包发出去，这个数据包始终没有发出来，导致抢IP操作失败。通过排查得知，<strong>组播数据包会被客户网络环境中的一台华为路由器拦截</strong>，可能是这台华为路由器有问题，但客户要求我们从我们服务器这一侧去修改，后来<strong>将多播改成单播</strong>才解决问题。</p> 
<p>       客户的网络设备上配置了很多安全规则，其中一个规则是<strong>将<span style="color:#be191c">IP-MAC</span>地址绑定</strong>，<strong>如果设备的IP和MAC地址对不上，设备发出来的数据包就会被网络设备认为是不安全的数据，会直接被拦截。</strong>在从服务器拿到主服务器的IP之后，IP对应的MAC地址就变了，正好就触发了这个IP-MAC绑定规则，导致数据包被拦截。后来的解决办法是<strong>将主从服务器公用的IP作为特例进行放行</strong>，即对这个IP不进行拦截。</p> 
<h2 id="8%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E7%9A%84TCP%2FIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%87%8D%E5%AE%9A%E5%90%91%E9%80%89%E9%A1%B9%E8%A2%AB%E5%85%B3%E9%97%AD%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E5%93%8D%E5%BA%94%E7%BD%91%E5%85%B3%E5%8F%91%E6%9D%A5%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E6%B6%88%E6%81%AF%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E4%B8%A5%E9%87%8D%E7%9A%84%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98">8、Linux系统的TCP/IP协议栈重定向选项被关闭后，无法响应网关发来的重定向消息，导致收发数据出现严重的丢包问题</h2> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/12/61/c5TRVBtg_o.png" width="589"></p> 
<p>       给客户部署的系统中，有台设备放置于某个网络节点下，给该设备配置了该节点下的默认网关，结果联调下来发现，<strong>所有的其他节点下的其他设备都没问题，就这台设备有问题</strong>，这台设备发出来的数据有严重的丢包问题。</p> 
<p>       现场人员和客户一起做了对比测试，把客户之前购买的别的厂商的设备放置在该网络节点下，别的厂商的设备都没有丢包问题，就我们公司的设备有问题。期间，我们给客户调拨了一个我们几年前研发的一款老式设备，放置在该节点下也没问题，就当前使用的新式设备有问题。</p> 
<p>       这个问题折腾的比较久，始终没有查出来问题，后来找公司的顶级专家来排查，才查出来问题。这台设备发出去的数据，默认情况下都要通过其配置的默认网关发出去，抓包发现，默认网关会给设备发了<strong>ICMP重定向消息</strong>，<strong>该消息中携带一个IP地址</strong>，<strong>该消息是用来告诉设备，要发送数据都从这个IP发出去。</strong></p> 
<p><strong>       </strong>一般情况下，协议栈在收到这个ICMP重定向消息后，会向系统路由表中添加一条路由，这样要发送的数据会使用这条路由中的IP发送出去。通过大量的抓包分析之后，找到了问题的症结，是因为设备内置的Linux系统的TCP/IP协议栈的重定向选项都被关闭导致的，在linux命令行使用命令sysctrl -a | grep redirects可以查看到：</p> 
<p class="img-center"><img alt="" height="540" src="https://images2.imgbox.com/bd/5e/qC9NzhMG_o.png" width="612"></p> 
<p>       我们硬件设备中的使用的Linux系统是经过裁剪后部署进去的，之前<strong>在系统裁剪时，出于安全考虑，将系统的TCP/IP网络协议栈中所有重定向选项都关闭了，所以此案例中默认网关发过来的ICMP重定向消息被丢弃了，导致发出的数据还是发到默认网关上，但从默认网关出去的数据会有明显的丢包问题</strong>（客户网络环境故意这么处理的，不让数据从默认网关出去），所以出现了最开始出现的问题。        </p> 
<p>       此问题的临时解决办法是<strong>手动将这些重定向选项打开</strong>，后续进行Linux系统裁剪时要将这些重定向选项打开。</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>