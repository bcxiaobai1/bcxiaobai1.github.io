<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>SQL必知必会（第五版） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SQL必知必会（第五版）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h2>
<a id="SQL_1"></a>SQL必知必会</h2> 
<h2>
<a id="SQL_5"></a>了解SQL</h2> 
<h3>
<a id="1_7"></a>1.数据库</h3> 
<p>数据库就像是一个容器，存放各种表。需要与DBMS区分</p> 
<h4>
<a id="11_11"></a>1.1表</h4> 
<p>一个结构化的清单，存储各种数据。</p> 
<p>sql全称是struct query language 结构化查询语言</p> 
<p>描述表的信息就是 <strong>模式</strong> <strong>schema</strong>，当然模式也可以描述数据库。</p> 
<p>表是由 <strong>列 column</strong>构成的。表中的一个<strong>字段</strong>称为列</p> 
<p>每列都有对应的数据类型，数字还是字符串等。</p> 
<p>数据是由 <strong>行 row</strong> 构成的。一行称为一条记录</p> 
<h4>
<a id="12_31"></a>1.2主键</h4> 
<blockquote> 
 <p>表中每一行都应该能唯一标识自己。这就是 <strong>主键 primary key</strong>的作用</p> 
</blockquote> 
<p>表中任何列都可以称为主键，至于要满足以下条件</p> 
<blockquote> 
 <p>任何两行都没有相同的主键</p> 
 <p>每一行必须都有一个主键，非null</p> 
 <p>主键列的值不允许修改或更新</p> 
 <p>主键值不能重用，比如某一行删除后他的主键不能付给新行</p> 
</blockquote> 
<p>虽然可以用多列联合作为主键，但是主键是唯一的。</p> 
<h2>
<a id="_47"></a>检索数据</h2> 
<h3>
<a id="1_49"></a>1.检索列</h3> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> prod_name
<span class="token keyword">from</span> Products<span class="token punctuation">;</span>
</code></pre> 
<p>从Products表选取prod_name列</p> 
<p><strong>sql语句结尾必须用；号结束</strong></p> 
<p><strong>SQL不区分大小写，SELECT select Select三者完全相同</strong></p> 
<blockquote> 
 <p>未排序数据返回时可能会与数据库里显示的不一致。但是行数一致即可。</p> 
 <p>显示时可能时数据添加的顺序，也可能不是。</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> prod_id<span class="token punctuation">,</span>prod_name<span class="token punctuation">,</span>prod_price
<span class="token keyword">from</span> Products<span class="token punctuation">;</span>
</code></pre> 
<p>检索多列只要在列名后加 **，**号即可</p> 
<p><strong>除此之外还可以用通配符 比如*号显示全部</strong></p> 
<p>需要注意的是最好别用这个 *。这会损失检索性能。</p> 
<p>但是该通配符也可以检索出你不知道名字的列。</p> 
<h3>
<a id="2_81"></a>2.去重</h3> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> vend_id 
<span class="token keyword">from</span> Products
</code></pre> 
<p>显示该列不重复的所有值。</p> 
<blockquote> 
 <p>选哟注意的是，distinct对其后的所有列都生效</p> 
 <p>比如 distinct a,b</p> 
 <p>则会显示a,b列所有不重复的组合。</p> 
</blockquote> 
<h3>
<a id="3_96"></a>3.显示行数控制</h3> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token keyword">top</span> <span class="token number">5</span> <span class="token keyword">from</span> xxx
<span class="token keyword">select</span> a <span class="token keyword">from</span> xxx <span class="token keyword">limit</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre> 
<p>第一行时mysql显示前五行，第二个是hive显示前五条数据。</p> 
<pre><code class="prism language-hive">select a from xxx limit 5 offset 5
</code></pre> 
<p>该语句意思选则第五条数据后的五条数据。也就是6-10条。</p> 
<p>需要注意的是offset时从 <strong>0</strong>开始计数。</p> 
<blockquote> 
 <p>也可以简化，比如 limit 5，1</p> 
 <p>该语句表示从第五条数据开始数，取一条。与标准写法相比是反着的。</p> 
</blockquote> 
<h2>
<a id="_117"></a>排序数据</h2> 
<h3>
<a id="_119"></a>单列排序</h3> 
<blockquote> 
 <p>一般来说显示的数据是数据往数据库插入的数据，但是如果后续修改了数据。</p> 
 <p>比如喊出或更新，DBMS可能会因为优化空间而修改存储数据。</p> 
</blockquote> 
<p>为了排序我们可以使用Order By子句，但是确保其 处于最后一个子句</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> s<span class="token punctuation">,</span>name
<span class="token keyword">from</span> xx
<span class="token keyword">order</span> <span class="token keyword">By</span> s<span class="token punctuation">;</span>
</code></pre> 
<p><strong>可以用没select的列进行排序。</strong></p> 
<h3>
<a id="_135"></a>多列排序</h3> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c
<span class="token keyword">from</span> xx
<span class="token keyword">order</span> <span class="token keyword">by</span> a <span class="token punctuation">,</span>b
</code></pre> 
<p><strong>默认都是升序</strong></p> 
<p>先按a升序排，如果a相同，则按b的升序排</p> 
<blockquote> 
 <p>也有更简介的写法</p> 
 <p>order by 2,3</p> 
 <p>就是先按第二列排，然后排第三列，都是升序</p> 
 <p><strong>如果排序的列没有select上，不可以使用该用法</strong></p> 
 <p>ASC是升序，DESC是降序</p> 
</blockquote> 
<h2>
<a id="_157"></a>过滤数据</h2> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> a
<span class="token keyword">from</span> x
<span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">3</span>
</code></pre> 
<p>可以通过where子句过滤符合的条件</p> 
<p><strong>order by子句应位于where之后</strong></p> 
<h3>
<a id="where_169"></a>where的操作符</h3> 
<blockquote> 
 <p>= 等于</p> 
 <p>&lt;&gt; 不等于</p> 
 <p>&lt; 不等于</p> 
 <p>&lt;= 小于等于</p> 
 <p>!&lt; 不小于</p> 
 <p>&gt; 大于</p> 
 <p>&gt;= 大于等于</p> 
 <p>!&gt; 不大于</p> 
 <p>BETWEEN 在两值之间，左闭右开，左边值可以取到，右边取不到。</p> 
 <p>IS NULL 是null值</p> 
</blockquote> 
<p><strong>如果判断值是字符则应该用单引号</strong></p> 
<p>between 使用时搭配 and 之前是低端值。之后是高端值</p> 
<h3>
<a id="_195"></a>高级过滤</h3> 
<blockquote> 
 <p>操作符 and or 可以用在where子句</p> 
 <p>and:两边条件都得满足</p> 
 <p>or：满足之一即可</p> 
 <p>or是懒惰运算的，如果第一个条件满足了，就不会执行第二个判断</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> xxx
<span class="token keyword">from</span> a
<span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'xcw'</span> <span class="token operator">and</span> age<span class="token operator">=</span><span class="token number">19</span>
<span class="token keyword">order</span> <span class="token keyword">by</span> age
</code></pre> 
<p><strong>运算顺序</strong></p> 
<p>必要时使用括号括起来相同的条件，并且记住 <strong>and是优先执行的</strong></p> 
<p>例如想查看由 a。b厂商制造的10元以上的产品</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> a
<span class="token keyword">from</span> xx
<span class="token keyword">where</span> <span class="token punctuation">(</span>id<span class="token operator">=</span>a <span class="token operator">or</span> id<span class="token operator">=</span>b<span class="token punctuation">)</span><span class="token operator">and</span> price <span class="token operator">&gt;</span><span class="token number">10</span>
</code></pre> 
<p><strong>()括号优先级大于and 或or运算符</strong></p> 
<p><strong>IN操作符</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> a
<span class="token keyword">from</span> xxx
<span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">)</span> <span class="token operator">and</span> price <span class="token operator">&gt;</span><span class="token number">10</span>
</code></pre> 
<p>这个和上面的操作一样</p> 
<p><strong>in的性能大于or，同时in后可以跟select子句</strong></p> 
<p><strong>NOT运算符</strong></p> 
<p>否定之后的所有条件</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> a
<span class="token keyword">from</span> a
<span class="token keyword">where</span> <span class="token operator">not</span> id <span class="token operator">=</span><span class="token number">1</span>
</code></pre> 
<p><strong>Like操作符</strong></p> 
<blockquote> 
 <p>通配符：用来匹配值的一种特殊字符</p> 
 <p>搜索模式：由字面值和通配符两者构成的搜索条件</p> 
</blockquote> 
<p>% 表示任何字符出现任意次数。简单理解就是代表是随机的字符串。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> prodname
<span class="token keyword">from</span> <span class="token keyword">as</span>
<span class="token keyword">where</span> prodname <span class="token operator">like</span> <span class="token string">'ID%'</span>
</code></pre> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> prodname
<span class="token keyword">from</span> <span class="token keyword">as</span>
<span class="token keyword">where</span> prodname <span class="token operator">like</span> <span class="token string">'%ID%'</span>
‘F<span class="token operator">%</span>Y’ <span class="token comment">//F开头。Y结尾</span>


<span class="token keyword">SELECT</span> prod_name<span class="token punctuation">,</span>prod_desc
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_desc <span class="token operator">like</span> <span class="token string">'%toy%'</span> <span class="token operator">AND</span> prod_desc <span class="token operator">LIKE</span> <span class="token string">'%carrots%'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name <span class="token keyword">DESC</span><span class="token punctuation">;</span>
要同时包含两个<span class="token operator">like</span>时，得完整写一遍条件
</code></pre> 
<p>通配符可以出现在任意位置，这表示文本中包含ID的字符值</p> 
<p>_用来匹配一个字符</p> 
<p>[]匹配指定字符集</p> 
<blockquote> 
 <p>通配符虽然使用起来容易，但是会造成性能损失。有以下tips</p> 
 <p>不哟啊过度使用通配符，如果能使用其他通配符，优先其他</p> 
 <p>就算使用，也尽量别把通配符放在最开始的地方，搜索起来最慢</p> 
</blockquote> 
<h2>
<a id="_288"></a>计算字段</h2> 
<blockquote> 
 <p>字段 field 与列 coulum意思相同</p> 
</blockquote> 
<p>计算字段是再select时创建的</p> 
<h3>
<a id="_294"></a>拼接字符</h3> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> name <span class="token operator">+</span> <span class="token string">'('</span><span class="token operator">+</span>contry<span class="token operator">+</span><span class="token string">')'</span>
</code></pre> 
<p>用+号拼接字符和列值</p> 
<p><strong>trim（）可以去除空格</strong> retrim去除右侧空格，ltrim去掉左边空格，trim去掉左右两边空格</p> 
<p>AS 可以为sql列指定别名。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> name <span class="token operator">+</span> <span class="token string">'('</span><span class="token operator">+</span>contry<span class="token operator">+</span><span class="token string">')'</span> <span class="token keyword">as</span> <span class="token string">'new_column'</span>
</code></pre> 
<blockquote> 
 <p>虽然as后别名可以为字符串，但是再客户端中字符串别名会带了各种问题，一般都是命名为一个字母</p> 
</blockquote> 
<h3>
<a id="_312"></a>常用算数符</h3> 
<p>±*/</p> 
<h2>
<a id="_316"></a>函数处理数据</h2> 
<blockquote> 
 <p>函数还可以再where中使用或其他sql语句中使用，也可以对别名使用</p> 
</blockquote> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gFsrhqld-1670463155106)(SQL必知必会第五版.assets/image-20221124151501262.png)]</p> 
<h3>
<a id="_322"></a>日期处理函数</h3> 
<p><strong>DATEPART函数</strong></p> 
<p>日期中包含的</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> xxx
<span class="token keyword">from</span> s
<span class="token keyword">where</span> DATEPART<span class="token punctuation">(</span>yy<span class="token punctuation">,</span>order_year<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token number">2020</span>
订单日期是<span class="token number">2022</span>年的数据返回
</code></pre> 
<h3>
<a id="_335"></a>数值处理函数</h3> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hhFjG90a-1670463155107)(SQL必知必会第五版.assets/image-20221124153004650.png)]</p> 
<h2>
<a id="_339"></a>聚合函数</h2> 
<blockquote> 
 <p>我们长须汇总数据而不是一条一条展示出来，这就会用到聚合函数，也叫聚簇函数</p> 
 <p>聚合函数的作用是根据计算返回一个值</p> 
</blockquote> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AmUYqSwd-1670463155107)(SQL必知必会第五版.assets/image-20221124160244527.png)]</p> 
<p><strong>count（*）是计算所有列个数</strong></p> 
<h2>
<a id="_349"></a>分组数据</h2> 
<p>分组可以把数据分组后再使用聚合函数</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> id <span class="token punctuation">,</span><span class="token function">count</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token keyword">from</span> a
<span class="token keyword">group</span> <span class="token keyword">by</span> id
</code></pre> 
<blockquote> 
 <p>先根据id分组，然后聚簇函数计算每种id有几条数据</p> 
</blockquote> 
<p><strong>group注意事项</strong></p> 
<blockquote> 
 <p>groupby子句可以包含任意数目列，因此可以对分组嵌套</p> 
 <p>如果建立了分组，groupby会把分组当一整个数据来计算</p> 
 <p>group by中 不能使用聚合函数，</p> 
 <p>大多数sql不支持varchar使用在groupby</p> 
 <p><strong>除了聚集函数外，select的每一列都得再group的条件里 不能使用别名</strong></p> 
 <p>所有的null值是一个分组</p> 
 <p>group位于where之后order之前</p> 
</blockquote> 
<h3>
<a id="_377"></a>过滤分组</h3> 
<blockquote> 
 <p>where只能根据某一条件过滤行，没有分组的概念</p> 
 <p>比如，想要获得分组内大于两条数据的用户，这种必须基于组来操作</p> 
 <p>这时要使用 <strong>having</strong>语句 其也支持所有的通配符和操作符</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> orders
<span class="token keyword">FROM</span> Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_id
<span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="_394"></a>子句顺序</h3> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vzKEYBSe-1670463155107)(SQL必知必会第五版.assets/image-20221125132627733.png)]</p> 
<h2>
<a id="_398"></a>子查询</h2> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> cust_id
<span class="token keyword">FROM</span> Orders
<span class="token keyword">WHERE</span> order_num <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> order_num
 <span class="token keyword">FROM</span> OrderItems
 <span class="token keyword">WHERE</span> prod_id <span class="token operator">=</span> <span class="token string">'RGAN01'</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>子查询总是由内向外处理</p> 
 <p><strong>子查询只能返回单列</strong></p> 
</blockquote> 
<blockquote> 
 <p>计算字段的子查询</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> 
 cust_state<span class="token punctuation">,</span>
 <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> 
 <span class="token keyword">FROM</span> Orders 
 <span class="token keyword">WHERE</span> Orders<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> orders
<span class="token keyword">FROM</span> Customers 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name<span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>举例来说，在查数据时。比如到了某一条数据。子查询使用了cust_id字段。<strong>该字段默认是该条数据的字段，这样就完成了绑定的效果</strong></p> 
</blockquote> 
<p><strong>完全限定列名 table.colume</strong></p> 
<h2>
<a id="_432"></a>联结表</h2> 
<blockquote> 
 <p>连接是指 <strong>join</strong></p> 
 <p>把数据分为多个表有利于数据结构，所以要分表</p> 
</blockquote> 
<h3>
<a id="_438"></a>普通的多表联结</h3> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> Vendors<span class="token punctuation">,</span> Products
<span class="token keyword">WHERE</span> Vendors<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> Products<span class="token punctuation">.</span>vend_id
</code></pre> 
<blockquote> 
 <p>该表使用where正确的联结， <strong>必须使用完全列名</strong></p> 
 <p>执行时是A表的每一个数据去匹配B表，同时where过滤</p> 
 <p>如果有多个where条件可以用and 链接，每一个and的条件都要完整的写出来</p> 
 <p>如果没有条件就会产生 <strong>笛卡尔积</strong>，a表每一条数据去匹配b表每条数据</p> 
 <p><strong>笛卡尔积也称 叉联结 cross join</strong></p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> prod_name<span class="token punctuation">,</span> vend_name<span class="token punctuation">,</span> prod_price<span class="token punctuation">,</span> quantity
<span class="token keyword">FROM</span> OrderItems<span class="token punctuation">,</span> Products<span class="token punctuation">,</span> Vendors
<span class="token keyword">WHERE</span> Products<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> Vendors<span class="token punctuation">.</span>vend_id
<span class="token operator">AND</span> OrderItems<span class="token punctuation">.</span>prod_id <span class="token operator">=</span> Products<span class="token punctuation">.</span>prod_id
<span class="token operator">AND</span> order_num <span class="token operator">=</span> <span class="token number">20007</span>
</code></pre> 
<blockquote> 
 <p>需要注意的是，以上这种多表联结非常损耗性能，不要联结不必要的表。表联结的越多，性能下降越严重。</p> 
 <p>虽然sql语法本身不限制联结表个数，但是具体的dbms会限制</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> Vendors
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Products <span class="token keyword">ON</span> Vendors<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> Products<span class="token punctuation">.</span>vend_id
</code></pre> 
<p><strong>innerjoin的语法</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> cust_email 
<span class="token keyword">FROM</span> Customers 
 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Orders<span class="token punctuation">.</span>cust_id 
 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> OrderItems <span class="token keyword">ON</span> Orders<span class="token punctuation">.</span>order_num <span class="token operator">=</span> OrderItems<span class="token punctuation">.</span>order_num 
<span class="token keyword">WHERE</span> prod_id <span class="token operator">=</span> <span class="token string">'BR01'</span>
</code></pre> 
<p>多个innerjoin的用法，作用是链接多个表。</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span>orderitems<span class="token punctuation">.</span>item_price<span class="token operator">*</span>orderitems<span class="token punctuation">.</span>quantity<span class="token punctuation">)</span> <span class="token keyword">as</span> total
<span class="token keyword">FROM</span> customers
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> orders <span class="token keyword">on</span> customers<span class="token punctuation">.</span>cust_id<span class="token operator">=</span>orders<span class="token punctuation">.</span>cust_id
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> orderitems <span class="token keyword">ON</span> orders<span class="token punctuation">.</span>order_num<span class="token operator">=</span>orderitems<span class="token punctuation">.</span>order_num
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_name
<span class="token keyword">HAVING</span> <span class="token function">SUM</span><span class="token punctuation">(</span>orderitems<span class="token punctuation">.</span>item_price<span class="token operator">*</span>orderitems<span class="token punctuation">.</span>quantity<span class="token punctuation">)</span> <span class="token operator">&gt;=</span><span class="token number">1000</span> 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name



</code></pre> 
<p>Having那里不能用as取别名，所以需要在select那里重新计算一下</p> 
<p>同时having也可以接筛选的工作，直接大于等于即可</p> 
<h2>
<a id="_503"></a>高级联结</h2> 
<h3>
<a id="_505"></a>表别名</h3> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> RTRIM<span class="token punctuation">(</span>vend_name<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">' ('</span> <span class="token operator">+</span> RTRIM<span class="token punctuation">(</span>vend_country<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">')'</span>
 <span class="token keyword">AS</span> vend_title
<span class="token keyword">FROM</span> Vendors
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name
</code></pre> 
<blockquote> 
 <p>sql除了可以给列名和计算字段赋别名之外，还可以给 <strong>表赋别名</strong></p> 
 <p>表别名不会和列别名一样返回客户端</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact
<span class="token keyword">FROM</span> Customers <span class="token keyword">AS</span> C<span class="token punctuation">,</span> Orders <span class="token keyword">AS</span> O<span class="token punctuation">,</span> OrderItems <span class="token keyword">AS</span> OI
<span class="token keyword">WHERE</span> C<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> O<span class="token punctuation">.</span>cust_id
<span class="token operator">AND</span> OI<span class="token punctuation">.</span>order_num <span class="token operator">=</span> O<span class="token punctuation">.</span>order_num
<span class="token operator">AND</span> prod_id <span class="token operator">=</span> <span class="token string">'RGAN01'</span>
</code></pre> 
<blockquote> 
 <p><strong>oracle中没有 AS.需要使用的话可以使用Customers C来起别名</strong></p> 
</blockquote> 
<h3>
<a id="selfjoin_natural_join_outer_join_528"></a>自联结（self-join） 自然联结（natural join）外联结 （outer join）</h3> 
<h4>
<a id="_530"></a>自联结</h4> 
<blockquote> 
 <p>假如要给与 Jim Jones 同一公司的所有顾客发送一封信件。这个查询要求 首先找出 Jim Jones 工作的公司，然后找出在该公司工作的顾客。下面是 解决此问题的一种方法：</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span> cust_name<span class="token punctuation">,</span> cust_contact
<span class="token keyword">FROM</span> Customers
<span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> cust_name
 <span class="token keyword">FROM</span> Customers
 <span class="token keyword">WHERE</span> cust_contact <span class="token operator">=</span> <span class="token string">'Jim Jones'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>cust_id cust_name cust_contact</p> 
 <p>1000000003 Fun4All Jim Jones 1</p> 
 <p>000000004 Fun4All Denise L. Stephens</p> 
</blockquote> 
<p><strong>如果使用自联结，同时搭配表别名。sql如下</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span>  c1<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> c1<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> c1<span class="token punctuation">.</span>cust_contact
<span class="token keyword">from</span> customers <span class="token keyword">as</span> c1<span class="token punctuation">,</span>customer <span class="token keyword">as</span> c2
<span class="token keyword">where</span> c1<span class="token punctuation">.</span>cust_name<span class="token operator">=</span>c2<span class="token punctuation">.</span>cust_name <span class="token operator">and</span> c2<span class="token punctuation">.</span>cust_contact <span class="token operator">=</span><span class="token string">'jim jones'</span><span class="token punctuation">;</span>
</code></pre> 
<h4>
<a id="_556"></a>自然联结</h4> 
<p><strong>默认情况下 自联结速度是比子查询要快的</strong></p> 
<blockquote> 
 <p>默认情况下join的表至少有一个相同列（被join那个列）</p> 
 <p>所以一个表join出来本来会有多个相同的列，</p> 
 <p>所以显示哪些列就必须由你决定select</p> 
 <p>这就叫 <strong>自然联结</strong></p> 
</blockquote> 
<h4>
<a id="_568"></a>外联结</h4> 
<blockquote> 
 <p>inner join只能联结有关联行的数据，比如都有cust_id等。</p> 
 <p>如果某一个表没有关联数据则不会被选中</p> 
 <p>比如左表是顾客表，右侧是订单表。左侧有没有消费过的顾客。</p> 
 <p>这样在join时是根据顾客id 来join。没有消费过的顾客在inner join时就不会选中</p> 
</blockquote> 
<p><strong>使用outer join</strong> 除了被联结的数据（类似inner join）还会有<strong>没有被选中的数据</strong></p> 
<p><strong>据此，outer join使用时必须指定那一侧是全量数据，使用 Right或者Left</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>order_num
<span class="token keyword">FROM</span> Customers
<span class="token keyword">RIGHT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Orders<span class="token punctuation">.</span>cust_id
</code></pre> 
<blockquote> 
 <p>优化之一就是小表放左侧。</p> 
</blockquote> 
<p>还有一种用法是全外联结 （full outer join）</p> 
<p><strong>会显示除了关联的行，还有所有两个表不关联的行</strong></p> 
<h3>
<a id="_594"></a>使用带聚集函数的的联结</h3> 
<p>联结的表一样可以使用聚集函数</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span>
 <span class="token function">COUNT</span><span class="token punctuation">(</span>Orders<span class="token punctuation">.</span>order_num<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_ord
<span class="token keyword">FROM</span> Customers
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Orders<span class="token punctuation">.</span>cust_id
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Customers<span class="token punctuation">.</span>cust_id
</code></pre> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span>
 <span class="token function">COUNT</span><span class="token punctuation">(</span>Orders<span class="token punctuation">.</span>order_num<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_ord
<span class="token keyword">FROM</span> Customers
<span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Orders<span class="token punctuation">.</span>cust_id
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Customers<span class="token punctuation">.</span>cust_id
</code></pre> 
<blockquote> 
 <p><strong>注意事项</strong></p> 
 <p>确保联结类型正确</p> 
 <p>每个dbms联结不同，请查看具体dbms的手册</p> 
 <p>提供联结条件，否则会产生 <strong>笛卡尔积</strong></p> 
 <p>多表联结时，可以把一个一个join来排查错误</p> 
</blockquote> 
<h2>
<a id="_624"></a>组合查询</h2> 
<blockquote> 
 <p>常规情况返回的结果是一个sql的结果</p> 
 <p>可以通过 <strong>UNION（并）来将多条sql结果一起返回</strong></p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact<span class="token punctuation">,</span> cust_email
<span class="token keyword">FROM</span> Customers
<span class="token keyword">WHERE</span> cust_state <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'IL'</span><span class="token punctuation">,</span><span class="token string">'IN'</span><span class="token punctuation">,</span><span class="token string">'MI'</span><span class="token punctuation">)</span>
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact<span class="token punctuation">,</span> cust_email
<span class="token keyword">FROM</span> Customers
<span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Fun4All'</span>
</code></pre> 
<pre><code class="prism language-sql">ust_name cust_contact cust_email
<span class="token comment">----------- ----------- ----------------</span>
Fun4All Denise L<span class="token punctuation">.</span> Stephens dstephens<span class="token variable">@fun4all.com</span>
Fun4All Jim Jones jjones<span class="token variable">@fun4all.com</span>
Village Toys John Smith sales<span class="token variable">@villagetoys.com</span>
The Toy Store Kim Howard <span class="token boolean">NULL</span>
</code></pre> 
<p><strong>通过union可以拼合两个sql的结果</strong></p> 
<p>union本身没什么问题，可以简化， <strong>但是上例</strong>完全可以把所有where子句条件放到一个where里。</p> 
<p>所以union大多数都是用于复杂的条件或者非常多个表联结是使用</p> 
<blockquote> 
 <p>union本身语法没有联结数量限制，但是具体请查看dbms文档</p> 
</blockquote> 
<blockquote> 
 <p>理论上来说多条where性能强于union，因为where会先晒出后分析，而union相当于操作两次或多次。</p> 
 <p>但是这只是理论上，具体 <strong>请实验</strong></p> 
</blockquote> 
<p>以下是注意事项</p> 
<ul>
<li>union必须组合两个或多个sql。同时用union联结</li>
<li>union的结果必须包含相同的列，聚合函数，或表达式。 <strong>但是显示顺序可以不一样</strong>
</li>
</ul> 
<blockquote> 
 <p>说明：UNION 的列名 如果结合 UNION 使用的 SELECT 语句遇到不同的列名，那么会返回什 么名字呢？比如说，如果一条语句是 SELECT prod_name，而另一条 语句是 SELECT productname，那么查询结果返回的是什么名字呢？ 答案是它会返回第一个名字，举的这个例子就会返回 prod_name，而 不管第二个不同的名字。这也意味着你可以对第一个名字使用别名， 因而返回一个你想要的名字。 这种行为带来一个有意思的副作用。由于只使用第一个名字，那么想 要排序也只能用这个名字。拿我们的例子来说，可以用 ORDER BY prod_name 对结果排序，如果写成 ORDER BY productname 就会出错， 因为查询结果里没有叫作 productname 的列。</p> 
</blockquote> 
<h3>
<a id="_668"></a>消除重复的行</h3> 
<p>上例可以看到第一条sql返回3行。第二条返回2行。<strong>但是union后只有四行</strong>这是因为第一个sql结果和第二个sql结果中重复的行会被dbms自动抹去</p> 
<p><strong>如果想要返回两条sql所有的结果需要使用 union all</strong></p> 
<blockquote> 
 <p><strong>这意味着。如果你想返回所有的数据，只能用union all而不是where，因为where不会选中重复数据</strong></p> 
</blockquote> 
<h3>
<a id="union_676"></a>对union结果排序</h3> 
<p>可以使用order by语句。其应处于最后一条sql后。会排序所有的结果。</p> 
<p><strong>且只可有一个order by子句</strong>不可以对单个语句排序</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact<span class="token punctuation">,</span> cust_email
<span class="token keyword">FROM</span> Customers
<span class="token keyword">WHERE</span> cust_state <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'IL'</span><span class="token punctuation">,</span><span class="token string">'IN'</span><span class="token punctuation">,</span><span class="token string">'MI'</span><span class="token punctuation">)</span>
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact<span class="token punctuation">,</span> cust_email
<span class="token keyword">FROM</span> Customers
<span class="token keyword">WHERE</span> cust_name <span class="token operator">=</span> <span class="token string">'Fun4All'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name<span class="token punctuation">,</span> cust_contact<span class="token punctuation">;</span>
</code></pre> 
<h2>
<a id="_693"></a>插入数据</h2> 
<h3>
<a id="__695"></a>可以插入行 ，行的一部分，子查询</h3> 
<blockquote> 
 <p>插入前请确保权限够</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Customers
<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1000000006</span><span class="token punctuation">,</span> 
 <span class="token string">'Toy Land'</span><span class="token punctuation">,</span>
 <span class="token string">'123 Any Street'</span><span class="token punctuation">,</span>
 <span class="token string">'New York'</span><span class="token punctuation">,</span>
 <span class="token string">'NY'</span><span class="token punctuation">,</span>
 <span class="token string">'11111'</span><span class="token punctuation">,</span>
 <span class="token string">'USA'</span><span class="token punctuation">,</span>
 <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>这种写法非常依赖数据插入次序。也非常不安全。因为没办法保证表移植后有相同的次序</p> 
<p>所以使用下列写法指定列名,这个列名可以不是表的列名。这样 <strong>即使表结构变了，数据也能正常插入</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Customers<span class="token punctuation">(</span>cust_id<span class="token punctuation">,</span>
 cust_name<span class="token punctuation">,</span>
cust_address<span class="token punctuation">,</span>
 cust_city<span class="token punctuation">,</span>
cust_state<span class="token punctuation">,</span>
 cust_zip<span class="token punctuation">,</span>
 cust_country<span class="token punctuation">,</span>
 cust_contact<span class="token punctuation">,</span>
 cust_email<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1000000006</span><span class="token punctuation">,</span>
 <span class="token string">'Toy Land'</span><span class="token punctuation">,</span>
 <span class="token string">'123 Any Street'</span><span class="token punctuation">,</span>
 <span class="token string">'New York'</span><span class="token punctuation">,</span>
 <span class="token string">'NY'</span><span class="token punctuation">,</span>
 <span class="token string">'11111'</span><span class="token punctuation">,</span>
 <span class="token string">'USA'</span><span class="token punctuation">,</span>
 <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token boolean">NULL</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p><strong>提示：总是使用列的列表 不要使用没有明确给出列的 INSERT 语句。给出列能使 SQL 代码继续 发挥作用，即使表结构发生了变化</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>注意：小心使用 VALUES 不管使用哪种 INSERT 语法，VALUES 的数目都必须正确。</strong></p> 
 <p><strong>如果不提供列 名，则必须给每个表列提供一个值，如果为空的字段，可以使用NULL；</strong></p> 
 <p><strong>如果提供列名，则必须给列出的每 个列一个值。否则，就会产生一条错误消息，相应的行不能成功插入。</strong></p> 
</blockquote> 
<h3>
<a id="_745"></a>插入子查询</h3> 
<pre><code class="prism language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Customers<span class="token punctuation">(</span>cust_id<span class="token punctuation">,</span>
 cust_contact<span class="token punctuation">,</span>
 cust_email<span class="token punctuation">,</span>
 cust_name<span class="token punctuation">,</span>
 cust_address<span class="token punctuation">,</span>
 cust_city<span class="token punctuation">,</span>
cust_state<span class="token punctuation">,</span>
 cust_zip<span class="token punctuation">,</span>
 cust_country<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span>
 cust_contact<span class="token punctuation">,</span>
 cust_email<span class="token punctuation">,</span>
 cust_name<span class="token punctuation">,</span>
 cust_address<span class="token punctuation">,</span>
 cust_city<span class="token punctuation">,</span>
 cust_state<span class="token punctuation">,</span>
 cust_zip<span class="token punctuation">,</span>
 cust_country
<span class="token keyword">FROM</span> CustNew<span class="token punctuation">;</span>
</code></pre> 
<p><strong>可以使用CTAS语法快速建表</strong></p> 
<p>create table xxx as select * from</p> 
<h2>
<a id="_773"></a>更新和删除数据</h2> 
<h3>
<a id="_775"></a>更新数据</h3> 
<p>可以选择 更新选中的行，或者更新所有行</p> 
<blockquote> 
 <p>更新时一定要注意，一不小心就会更新所有的行。</p> 
 <p>update子句是where结束的，如果没有where，他就会更新所有的行</p> 
</blockquote> 
<p><strong>确定表，列名和新的值，确定过滤条件</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">UPDATE</span> Customers
<span class="token keyword">SET</span> cust_email <span class="token operator">=</span> <span class="token string">'kim@thetoystore.com'</span>
<span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">1000000005</span>
</code></pre> 
<p><strong>多行更新如下</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">UPDATE</span> Customers
<span class="token keyword">SET</span> cust_contact <span class="token operator">=</span> <span class="token string">'Sam Roberts'</span><span class="token punctuation">,</span>
 cust_email <span class="token operator">=</span> <span class="token string">'sam@toyland.com'</span>
<span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">1000000006</span>
</code></pre> 
<p>需要注意的是，update不支持子查询更新多行。</p> 
<h3>
<a id="_802"></a>删除数据</h3> 
<blockquote> 
 <p>delete时要注意where子句，如果没有会删除所有行。</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Customers
<span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">1000000006</span>
</code></pre> 
<blockquote> 
 <p>delete 语句删除表中所有的行，但是delete从来不删除表本身。</p> 
</blockquote> 
<p><strong>如果想更快的删除</strong></p> 
<p><strong>TRUNCATE TABLE</strong> 语句，它完成相同的工作，而速度更快（因为不记录数据的变动）</p> 
<h4>
<a id="_817"></a>更新和删除的前提</h4> 
<ul>
<li>一定要，确保带where子句</li>
<li>保证每个表都有主键</li>
<li>使用前先用select先测试数据</li>
<li>使用完整性的数据库</li>
</ul> 
<h2>
<a id="_824"></a>创建表和操作表</h2> 
<h3>
<a id="_826"></a>创建表</h3> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Products
<span class="token punctuation">(</span> 
 prod_id <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 vend_id <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 prod_name <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 prod_price <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 prod_desc <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span>
</code></pre> 
<h3>
<a id="_839"></a>更新表</h3> 
<pre><code class="prism language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> Vendors
<span class="token keyword">ADD</span> vend_phone <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>

<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> Vendors
<span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> vend_phone
</code></pre> 
<h3>
<a id="_849"></a>更新表一般操作</h3> 
<blockquote> 
 <p>(1) 用新的列布局创建一个新表；</p> 
 <p>(2) 使用 INSERT SELECT 语句（关于这条语句的详细介绍，请参阅第 15 课）从旧表复制数据到新表。有必要的话，可以使用转换函数和计算 字段；</p> 
 <p>(3) 检验包含所需数据的新表；</p> 
 <p>(4) 重命名旧表（如果确定，可以删除它）；</p> 
 <p>(5) 用旧表原来的名字重命名新表；</p> 
 <p>(6) 根据需要，重新创建触发器、存储过程、索引和外键</p> 
</blockquote> 
<h3>
<a id="_863"></a>删除表</h3> 
<pre><code class="prism language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> CustCopy
</code></pre> 
<blockquote> 
 <p>该操作会删除表结构和表中数据，而不像delete仅删除表数据而不动表结构</p> 
</blockquote> 
<p><strong>删除表没有确认步骤， 也不能撤销，执行这条语句将永久删除该表</strong></p> 
<h2>
<a id="_873"></a>视图</h2> 
<blockquote> 
 <p>视图时虚拟的表，视图本身不存储数据，甚至可以理解为一段存储的sql。只有使用时才执行。</p> 
 <p>非常类似于spark的transforming操作。</p> 
</blockquote> 
<h3>
<a id="_879"></a>使用视图的原因</h3> 
<ul>
<li>重用SQL语句</li>
<li>简化复杂SQL，编写查询时可以不知道内部复杂的细节</li>
<li>使用表的一部分而不是整个表</li>
<li>保护数据，可以给用户授予表的部分而不是全部权限</li>
<li>更改数据格式和显示，视图可以返回与表格式不同的数据</li>
</ul> 
<blockquote> 
 <p><strong>视图每次执行都会处理查询所需要的所有检索，所以对性能有要求</strong></p> 
 <p>如果用多个联结，或者复杂过滤，非常复杂的sql会导致数据库性能下降。</p> 
 <p>所以使用视图时请进行测试。</p> 
</blockquote> 
<h3>
<a id="_893"></a>使用视图的规则和限制</h3> 
<ul>
<li>视图命名必须唯一</li>
<li>视图数目没有限制</li>
<li>视图可以嵌套，<strong>但是会导致严重的性能下降</strong>
</li>
<li>有些DBMS会禁止orderby</li>
<li>有些DBMS会让视图只读</li>
</ul> 
<blockquote> 
 <p>每个DBMS环境都不一致，具体请看DBMS手册</p> 
</blockquote> 
<h3>
<a id="_903"></a>创建视图</h3> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> ProductCustomers <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact<span class="token punctuation">,</span> prod_id
<span class="token keyword">FROM</span> Customers<span class="token punctuation">,</span> Orders<span class="token punctuation">,</span> OrderItems
<span class="token keyword">WHERE</span> Customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Orders<span class="token punctuation">.</span>cust_id
<span class="token operator">AND</span> OrderItems<span class="token punctuation">.</span>order_num <span class="token operator">=</span> Orders<span class="token punctuation">.</span>order_num
</code></pre> 
<blockquote> 
 <p>删除视图使用drop view tablename</p> 
</blockquote> 
<h2>
<a id="_915"></a>存储过程</h2> 
<h3>
<a id="_917"></a>什么是存储过程</h3> 
<p>实际开发中，一个业务流程会与多个业务耦合。</p> 
<p>比如用户下单。涉及到订单记录，库存变更，用户记录。</p> 
<p>所以一个业务流程实际是多个业务sql耦合起来。</p> 
<p>而各个sql需要低耦合，这样可以分别维护。</p> 
<blockquote> 
 <p>存储过程就是保存一条或多条sql语句。将其分为批文件。</p> 
 <p>通过存储过程可以把复杂的处理过程封装为一个过程。</p> 
</blockquote> 
<h3>
<a id="_931"></a>执行存储过程</h3> 
<p>存储过程的执行远比编写要频繁。</p> 
<p>使用 <strong>execute</strong>即可执行</p> 
<pre><code class="prism language-sql"><span class="token keyword">EXECUTE</span> AddNewProduct<span class="token punctuation">(</span><span class="token string">'JTS01'</span><span class="token punctuation">,</span> 
 <span class="token string">'Stuffed Eiffel Tower'</span><span class="token punctuation">,</span> 
<span class="token number">6.49</span><span class="token punctuation">,</span>
<span class="token string">'Plush stuffed toy with 
➥the text La Tour Eiffel in red white and blue'</span><span class="token punctuation">)</span>
</code></pre> 
<h3>
<a id="_945"></a>创建存储过程</h3> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> MailingListCount <span class="token punctuation">(</span>
 ListCount <span class="token keyword">OUT</span> <span class="token keyword">INTEGER</span>
<span class="token punctuation">)</span> 
<span class="token operator">IS</span>
v_rows <span class="token keyword">INTEGER</span><span class="token punctuation">;</span>
<span class="token keyword">BEGIN</span>
 <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">INTO</span> v_rows
 <span class="token keyword">FROM</span> Customers
 <span class="token keyword">WHERE</span> <span class="token operator">NOT</span> cust_email <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
 ListCount :<span class="token operator">=</span> v_rows<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span>
</code></pre>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>