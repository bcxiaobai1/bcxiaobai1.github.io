<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【深度学习计算机指令系统，彻底搞懂指令十大寻址方式】 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【深度学习计算机指令系统，彻底搞懂指令十大寻址方式】</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <h1 id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">
<a id="_0"></a>系列文章目录</h1> 
<h3 id="1.%E3%80%8A%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%8C%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%EF%BC%8C%E6%89%93%E9%80%9A%E4%BD%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9A%84%E4%BB%BB%E7%9D%A3%E4%BA%8C%E8%84%89%E3%80%8B"><strong>1.《带你深挖计算机底层逻辑，打通你计算机基础知识的任督二脉》</strong></h3> 
<h3 id="2.%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%8B">
<a name="t2"></a><strong>2.《深度学习计算机底层原理，深度剖析存储器》</strong>
</h3> 
<h3 id="3.%E3%80%8A%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%8B">
<a name="t3"></a>3.《基于内存全面理解高速缓冲存储器》</h3> 
<h3 id="4.%E3%80%8A%E7%8E%8B%E8%80%85%E6%95%99%E7%A8%8B%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%AF%B9%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%89%80%E7%95%8F%E6%83%A7%E3%80%8B">4.《深度学习计算机指令系统，彻底搞懂指令十大寻址方式》</h3> 
<hr>
<div> 
 <h3 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</h3> 
 <ul>
<li><a href="#_0">系列文章目录</a></li>
<li><a href="#_12">前言</a></li>
<li><a href="#pandas_22">一、指令格式</a></li>
<li><a href="#_26">二、指令寻址</a></li>
<li><a href="#_26">三、CISC、RISC的基本概念</a></li>
<li><a href="#_55">总结</a></li>
</ul>
</div> 
<p></p> 
<hr>
<h1 id="%E5%89%8D%E8%A8%80">
<a id="_12"></a>前言</h1> 
<p>        我在之前的文章专栏已经系统地为大家讲解了计算机最基本的组成框架、存储器、高速缓冲存储器，计算机的下一个重要部分就是CPU了，可是再介绍CPU之前，我们不得不先介绍一下计算机指令系统，因为这个可以说是使得计算机正常运转的核心，我们也可以借助指令系统对于之前的给大家讲解的内容也是一种巩固。</p> 
<p>        但是在这里还是要提醒各位老铁一下，计算机底层原理进行到这里的时候，我们对于计算机底层原理就应该有了一个很清晰的认识了，也就是说要想把指令系统学会对于计算机最基本的框架应该构建起来了，我们应该已经达到了对于计算机的每一个部件，他们的功能，以及在主机当中的位置结构有了一个非常清晰的认识了，如果还没有的话，建议各位老铁先到我之前的文章去看看，对于计算机系统的组成有了一个初步的了解之后，再来学习指令系统，否则将很难学懂指令，因为今天的这篇文章要涉及到大量的与主存、寄存去的相关知识，如果对于这些不了解的话，则很难理解，今天的内容。</p> 
<hr>
<h1 id="%E4%B8%80%E3%80%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F">
<a id="pandas_22"></a>一、指令格式</h1> 
<p><strong>概述：</strong>指令也就是机器指令，或者说是一种命令，他是用来指挥计算机完成某称操作的命令，一台计算机上的所有指令构成计算机的指令系统，也称指令集，指令系统是计算机的主要属性，位于软件和硬件的交界处。</p> 
<h3 id="1.%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F">1.指令的基本格式</h3> 
<p><strong>注意：每一条指令都有其相应的运算形式，并不是每一条指令都适用于每一种情形的运算，这个一定要很清楚，比如说我们平常所见的算术运算指令和逻辑运算指令都是用而地址指令来运算的，那么其他指令是用来干什么的呢？接下来为大家讲解。</strong></p> 
<table align="center" border="2" cellpadding="1" cellspacing="1" style="width:500px"><tbody><tr>
<td style="text-align:center"><strong>操作码字段</strong></td>
<td style="text-align:center"><strong>地址码字段</strong></td>
</tr></tbody></table>
<p>        一条指令就是计算机语言的一个语句，他是一组有意义的二进制代码，一条指令通常包括操作码字段和地址码字段两个部分，其中操作码是用来指出指令应该执行什么样性质的指令一句指令具有何种功能，通俗的来讲，你是想要执行加法指令还是减法指令还是要返回一个数，这些最基本的信息必须告诉CPU，而这些信息就是操作码携带的。     </p> 
<p>        地址码给出操作数的地址、运算结果的地址，程序的转移地址等等。</p> 
<p>        指令的长度是指指令所含二进制代码的位数，而指令字长取决于操作码的长度、地址码的长度以及地址码的个数。</p> 
<blockquote> 
 <p><span style="color:#fe2c24">注意：</span><span style="color:#0d0016">这里的地址码时代表操作数的地址，也就是要进行运算所需的数据的地址，而并非操作数本身。</span></p> 
</blockquote> 
<p>        <strong>1.零地址指令：</strong></p> 
<table align="center" border="2" cellpadding="1" cellspacing="1" style="width:500px"><tbody><tr><td style="text-align:center"><strong>OP（操作码、但没有地址码）</strong></td></tr></tbody></table>
<p>        之所以存在零地址指令是因为，有些操作他本身就是不需要操作数的，例如空操作指令、停机指令、关中断指令等等。</p> 
<p>        还有另外一种情况，因为零地址指令的运算尽在堆栈当中进行，通常参与运算的两个操作数隐含地从栈顶和次栈顶的位置弹出，送到运算器进行运算完成以后，运算的结果还会放回到对堆栈当中。所以操作码的地址就是默认的——堆栈当中的栈顶和次栈顶两个位置，所以就不需要给出地址码。</p> 
<p>        <strong>2.一地址指令：</strong></p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:500px"><tbody><tr>
<td style="text-align:center"><strong>OP（操作码）</strong></td>
<td style="text-align:center"><strong>A1（地址码）</strong></td>
</tr></tbody></table>
<p>        1）：第一种情况时按照A1地址从内存当中读取操作数，进行OP操作以后，结果还会存放会原来的地址当中去，相当于把原来的数据给破坏了（OP操作数代表着指令的类型，这里不说明具体指令的类型统一用OP操作来代替诸如加法指令、减法指令等多条指令） 。</p> 
<blockquote> 
 <p>        OP（A1）-&gt;A1;</p> 
</blockquote> 
<p><strong>详解： </strong></p> 
<p>        2）：隐含了目的地址的双操作数指令，也就是说指令的操作需要两个操作数，但是指令当中只提供了一个地址码，显然还有一个操作数不由指令来提供，那怎么办呢？这个时候就需要用到CPU当中ALU（算术逻辑单元）中的ACC累加寄存器，一个隐含操作数地址会放到ACC当中，由ALU进行运算之后的结果，仍然会放到ACC当中。</p> 
<blockquote> 
 <p>        （ACC）OP（A1）-&gt;A1;</p> 
</blockquote> 
<p><span style="color:#fe2c24">指令含义： </span><span style="color:#0d0016">可能有小伙伴对于上面所描述的指令（ACC）OP-&gt;A1的含义不太明白，现在就为大家进行进一步的说明，你要相信我，这些内容真的特别简单，学不会你打我。</span></p> 
<ol>
<li>
<span style="color:#0d0016">首先我来解释一下‘（）’的含义（有些计算机指令集用（），而有些则用[ ]来表示，至于他们的区别是什么我们随会介绍），首先他们的含义都是</span><span style="color:#fe2c24">解引用</span><span style="color:#0d0016">，提到解引用大家都不陌生吧，只要是了解过指针的小伙伴我相信对于解引用这个东西都不会陌生，所以（ACC）的意思就是根据数据存放在ACC里面相应的地址把存放在ACC寄存器里面相应的地址里面的内容给取出来，就是这么简单。</span>
</li>
<li><span style="color:#0d0016">OP的含义我们刚才其实也提到过了，它用来代表指令的操作类型，这里不具体指明指令要进行哪些操作，所以统一用OP操作来表示。</span></li>
<li>
<span style="color:#0d0016">那么这里的（A1）是什么意思呢？A1这里代表一个地址，（A1）就是根据这个地址，把存放在这个地址里面的内容给取出来，说白了他就是一个</span><span style="color:#fe2c24">指针</span><span style="color:#0d0016">，它的功能就和*A1的功能是一样的。</span>
</li>
<li>
<span style="color:#0d0016">所以</span>（ACC）OP（A1）-&gt;A1的含义就是把第一个操作数从ACC当中取出，第二个操作数从A1这个地址取出，然后两数进行OP操作，结果存放到A1这个地址里面去，'-&gt;'是赋值的意思。</li>
<li>OP（A1）-&gt;A1这条指令的意思也很简单，就是把A1地址存放的数据取出来进行OP操作以后再存放到A1地址里面去。</li>
<li>这些指令的基本根式一定要非常清晰，首先你一定要知道‘（）’是解引用，-&gt;是赋值的意思，因为我们马上就要学习指令的寻址方式，如果这些没有搞懂的话，后面很难有进展。</li>
</ol>
<p><strong>         3.二地址指令：</strong></p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:500px"><tbody><tr>
<td style="text-align:center"><strong>OP（操作码）</strong></td>
<td style="text-align:center"><strong>A1（地址码）</strong></td>
<td style="text-align:center"><strong>A2（地址码）</strong></td>
</tr></tbody></table>
<p><span style="color:#fe2c24">特别提醒： </span><span style="color:#0d0016">给大家补充一个非常重要的知识点，就是指令字长为四个字节，32位比特位（1byte==4bit），而操作码要占用一个字节，所以剩余的其他位数就是地址码字段，地址码字段所占的位数就代表着他的寻址范围例如但地址指令，地址码占24位，所以寻址范围就是2^24。</span></p> 
<p>        1）常用来算数运算指令和逻辑运算指令 往往要求使用两个操作数，分为源操作数和目的操作数，目的操作数就是运算结束以后的结果存放在目的操作数，但是原来的目的操作数里面存放的数据就会被覆盖。</p> 
<blockquote> 
 <p>        (A1) OP (A2)-&gt;A1;</p> 
</blockquote> 
<p>指令含义：相信大家到这里的时候就已经都能够明白这条指令的含义了吧，把目的操作数从A1地址出取出来，把源操作数从地址A2出取出来进行OP操作运算以后把运算的结果再放回到A1当中，这里的A1、A2都代表地址，（A1/A2）就代表着对这两个地址解引用，把存放在此处的地址的值取出来。</p> 
<p>        当然往后还有三地址指令、四地址指令不过这些都是大同小异，就不在此处做过多的说明了。</p> 
<h3 id="2.%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B">2.指令的操作类型</h3> 
<p>注释：这些指令都是汇编常见指令，需要大家掌握理解并且记忆，记忆的时候要根据他们的英文含义去记忆，不要死记硬背。</p> 
<ol>
<li>
<strong>数据传送：</strong>MOV()寄存器之间的操作、LOAD(从内存单元读取数据存放到相应的寄存器)、STORE(从CPU的寄存器将数据写到内存单元)。</li>
<li>
<strong>算术和逻辑运算：</strong>ADD(加法指令)、SUB(减法指令)、CMP(比较指令)、MUL（乘法指令）、DIV（除法指令）、AND(逻辑与)、OR(逻辑或)、XOR(逻辑异或)、INC(加一操作)、DEC(减一操作)。</li>
<li>
<strong>移位操作：</strong>算术移位、逻辑移位、循环移位等。</li>
<li>
<strong>转移操作：</strong>JMP（无条件跳转指令）、CALL（调用指令）。</li>
<li>
<strong>输入输出操作：</strong>用于完成CPU与外部设备交换数据或传送命令及控制信息。</li>
</ol>
<p>操作码扩展技术：</p> 
<p>        有些时候我们在指令字长有限的前提下要保证指令的多样性，这个时候就需要对指令进行扩展操作码，操作码扩展那么地址码就会随之减少。</p> 
<p>        不过对于程序员来说，这些我们并不需要掌握，只需要理解其基本原理即可，如果又想要考研的小伙伴，可以自行学习。面试的过程当中是肯定不会涉及到的。</p> 
<hr>
<h1 id="%E4%BA%8C%E3%80%81%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">
<a id="_26"></a>二、指令的寻址方式</h1> 
<p><strong>温馨提示：</strong>指令的寻址方式是整个指令当中最重要也是最难的一个环节，这对于我们后续《深度理解CPU》的学习至关重要。不过大家放心，既然我敢拿出来讲，那说明我有信心用最浅显易懂的方式保证大家能学会，废话不多说接下来我们进入正题。</p> 
<blockquote> 
 <h3><span style="color:#fe2c24">序言：</span></h3> 
 <p><span style="color:#0d0016">        寻址方式是寻找指令或者操作数的有效地址，也就是确定本条指令的数据地址以及下一条指令的地址。</span></p> 
 <p><span style="color:#0d0016">        还有特别要注意的一点是，指令当中的地址码字段并不代表操作数的</span><span style="color:#fe2c24">真实的地址</span><span style="color:#0d0016">，这种地址成为</span><span style="color:#fe2c24">形式地址A</span><span style="color:#0d0016">，形式地址的意思就是不是操作数本身的地址，而是操作数所在位置的地址，我这么说大家能够理解吗？如果还是不能够理解的话，我可以这么说，比如你坐在公交车上那么公交车的地址就是你的形式地址，那么你在公交车上的作为就是你的真实地址，要是这么说的话，我表述清楚了吗？</span></p> 
 <p><span style="color:#0d0016">        形式地址结合寻址方式，才能够计算出操作数在寄存器中的真实地址，这种地址成为有效地址</span><span style="color:#fe2c24">EA（effectively address）</span><span style="color:#0d0016">，他仅仅只是一个英文单词的缩写而已，没有什么其他的含义了。</span></p> 
 <p><span style="color:#0d0016">        还要特别注意（A）是地址A这个存储单元里面的数值，当然这个数值仍然还有可能是一个地址，这就好比一个二级指针，那么A既可以某个寄存器、也可以是内存地址，那么对应的（A）就是寄存器当中存放的数值或地址，还可以是相应的存储单元的数值。</span></p> 
 <p>        EA=（A）的意思就是有效地址是A当中的数值，那么如果EA=A呢？那么代表着指令当中的地址码字段就是有效地址。</p> 
</blockquote> 
<h3 id="1.%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80">1.指令寻址和数据寻址</h3> 
<p>        <strong>1.指令寻址：</strong></p> 
<p>        1）顺序寻址：通过程序计数器PC+1（这里的1代表一个指令字长，一个指令字长为4个字节，所以有些时候看到有些教材上面写着PC+4的时候，也不要感到奇怪）。</p> 
<p>        2）跳跃寻址：很好理解就是不按照顺序来进行寻址，在计算完当前指令以后，会有当前指令自动计算下一条指令的位置，PC+A（偏移量），跳跃寻址的地址分为相对地址和绝对地址。</p> 
<p><strong>补充：</strong>相对地址、绝对地址</p> 
<p><strong>        绝对地址：</strong>绝对地址其实就是数据准确的地址，比如说山西省太原市尖草坪区学院路三号中北大学这就是绝对地址。</p> 
<p><strong>        相对地址：</strong>相对地址就是以某地址为参照进行寻址，比如说同样是中北大学，我可以这么说上兰村对面，以上兰村为基址进行寻址。</p> 
<p><strong>        2.数据寻址：</strong></p> 
<p><strong>        </strong>数据寻址就是在指令中表示一个操作数地址，由于数据寻址的方式有很多，为了区别这几种方式，通常在指令当中设计一个字段，由此来指明属于哪种寻址方式，由此可得指令的格式如下。</p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:500px"><tbody><tr>
<td style="text-align:center"><strong>操作码</strong></td>
<td style="text-align:center"><strong>寻址特征</strong></td>
<td style="text-align:center"><strong>形式地址A</strong></td>
</tr></tbody></table>
<p>那么数据寻址的方式到底有多少种呢？接下来我们就来谈一谈这个问题。</p> 
<h3 id="2.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%C2%A0">2.常见的数据寻址方式 </h3> 
<p>     <strong>   1.隐含寻址：</strong>这种类型的指令不会直接给出操作数的地址，而是在指令当中隐含操作数的地址，可能这样理解比较抽象，比如说我们之前介绍过的但地址指令就属于隐含寻址，他只给出了一个操作数的地址，而由ACC累加寄存器作为第二个操作数的地址，所以ACC对于但地址指令的格式来说就属于隐含寻址。</p> 
<p><strong>详解：</strong>以ACC累加器的隐含寻址为例，我们来讲述一下隐含寻址的具体原理和形式到底是怎样的，具体过程如下图：</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/19/7c/yZa88CWM_o.png"></p> 
<blockquote> 
 <p><strong>具体流程： </strong></p> 
 <ol>
<li><strong>首先CPU根据指令当中的地址码字段，找到主存当中的相应的存储单元，从存储单元取出操作数，那么这个时候还缺少一个操作数，由ACC完成。</strong></li>
<li><strong>主存通过数据总线将第二个操作数存放到CPU当中的ACC里面，再由ACC提供第二个操作数。</strong></li>
<li><strong>这个时候由主存当中的操作数和ACC当中提供的操作数同时提供给ALU，注意必须是同时提供给ALU，ALU才可以对两个操作数做运算（至于为什么是同时提供给ALU，这个我们会在后续的文章里面《深度理解CPU》当中为大家细心讲解）。</strong></li>
<li><strong>这个时候ALU计算出结果以后将结果放到暂存器当中（可能又会有小伙伴会问为什么要放到暂存器，这个同样在后续的文章当中《深度理解CPU》当中为大家讲解）。</strong></li>
<li><strong>这个时候运算结果从暂存器当中取出以后会再次放到ACC当中。，这个时候就完成了隐含寻址的全部过程。</strong></li>
</ol>
</blockquote> 
<p><strong>        2.立即（数）寻址：</strong>这种类型的寻址的指令当中的地址码字段不在存放操作数的形式地址，而是直接存放操作数的本身，这种数就叫做立即数，他在计算机当中采用补码表示（至于为什么要用补码来表示，小伙伴们可以去了解一下原反补和数据的大小端，就很清晰了），这种指令的运算就很简单了，也不用访存，直接从地址吗字段的位置把操作数给取出来，然后在放到ALU当中，算完以后再放回来。</p> 
<p>     <strong>   3.直接寻址：</strong>直接寻址其实就是，指令的地址码字段存放的不再是形式地址了，而是操作数的真实地址，即EA=A。</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/22/60/IgNx7E92_o.png"></p> 
<blockquote> 
 <p><strong>详解： </strong></p> 
 <ol>
<li><strong>根据指令当中的地址码字段存放的操作数的真实地址（主存当中的存储单元的地址）把操作数取出来以后送往ACC累加器，注意这里送往累加器并不是一定的，只有单地址指令并且是ADD运算的时候才需要，从主存当中取出来以后至于具体要送到哪里，还要看指令的类型。</strong></li>
<li><strong>但是这样的寻址方式有一定的缺点，就是直接将有效地址放入地址码字段是很难修改的，万一想要变换操作数，这是一件很麻烦的事情。</strong></li>
</ol>
</blockquote> 
<p><strong>        4.间接寻址：</strong></p> 
<p>        间接寻址是相对于直接寻址的，间接寻址给出的地址码字段并不是有效地址，而是形式地址，也就是操作数所在的存储单元的地址，也就是操作数地址的地址（二级指针）。间接寻址可以一次间接寻址，也可以多次间接寻址。</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/60/bc/UsTLk7Kb_o.png"></p> 
<hr>
<blockquote> 
 <p><strong>详解： </strong></p> 
 <ol>
<li>CPU根据操作数的形式地址，去主存当中找到存储单元的地址也就是有效地址，这个时候再根据有效地址取出操作数本身即可。</li>
<li>他的缺点就在于需要多次访存，对系统的损耗很大。</li>
</ol>
</blockquote> 
<p>      <strong>  5.寄存器寻址：</strong>寄存器寻址和之前的一个区别就在于操作数不在内存当中而是在寄存器当中，所以指令的地址码字段存放的并不是形式地址，而是寄存器的编号即EA=Ri（register是寄存器的意思）。操作数直接从寄存器当中取出操作数以后进行运算，运算结束以后在放回到寄存器当中去即可。</p> 
<p>        <strong>6.寄存器间接寻址：</strong>这种寻址方式对应的是前一种寄存器寻址，他唯一的变化就是，寄存器当中不在是存放操作数了，而是操作数在内从当中的地址了，这肯定比普通的间接寻址要快，但是指令的执行阶段仍然需要访问主存，毕竟操作数还在主存当中。</p> 
<p>        <strong>7.相对寻址：</strong>相对寻址就是相对于当前的指令，给当前的指令一个偏移量，即EA=（PC）+A，（PC）是指PC（程序计数器、用于存放当前指令的有效地址）当中当中的存放的有效地址加上一个偏移量就是操作数的有效地址。</p> 
<p>      <strong>  8.基址寻址：</strong>EA=（BR）+A，它是由基址寄存器当中存放的内容再加上指令当中的形式地址A共同作用下形成操作数的有效地址，在这里还是要强调一下，这里的有效地址是经过基址寄存器和形式地址经过ALU算术逻辑单元运算出来的有效地址，并不是凭空产生的，具体实现原理如下图所示。</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/06/15/c1pS6eAc_o.png"></p> 
<blockquote> 
 <p><strong>详解： </strong></p> 
 <ol>
<li> 在程序的执行过程当中基址寄存器当中的内容是不会发生变化的，这也就是基址寻址的名称的含义，但是形式地址A确实是可以发生变化的，这里的A作为偏移量，通过对A的改变以此来查找有效地址。</li>
<li>基址寄存器是面向操作系统的，他又操作系统或管理程序来确定，它的主要功能就是用来解决逻辑地址和物理地址的无关性的，简单地说就是把逻辑地址转换为物理地址，要知道在虚拟存储器当中操作系统会给我们提供一个比真实地址内存空间大得多的内存空间，所以也会给我们提供一系列的逻辑地址，二基址寄存器就是专门解决逻辑地址和物理地址的无关性的，通过逻辑地址依然可以找到操作数的真是物理地址。</li>
<li>他的一个最大的优点就是可以扩大寻址范围，用户不必考虑自己的程序存在于主存当中的哪块空间，有利于多道程序设计，但是他的偏移量的位数比较短。</li>
</ol>
</blockquote> 
<p>        <strong>9.变址寻址：</strong>变址寻址是基于变址寄存器和指令字当中的形式地址的内容之和即EA=（IX）+A，IX是变址寄存器，当然也可以用通用寄存器来作为变址寄存器（要不怎么叫通用寄存器呢）。</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/c5/cc/H9wOdzak_o.png"></p> 
<blockquote> 
 <p><strong> 详解： </strong></p> 
 <ol>
<li>基址寻址是面向用户的，在程序执行过程当中变址寄存器当中的值是可以改变的（作为偏移量），反倒是指令字当中的形式地址A不可变（作为基址）。</li>
<li>他的一个巨大的优势就在于可以扩大寻址范围，就比如在数组的处理过程当中可设定A为数组的首地址，不断地改变变址寄存器的值，便很容易地形成数组当中任一数据的地址，而且IX的位数足以表示整个存储空间的地址。</li>
<li>其实我讲到这里大家也能够发现，基址寻址和变址寻址的区别在哪里，前者的寄存器当中的内容是由操作系统来确定的，不可变但是形式地址A可变，而后者的寄存器确实有用户程序员来确定的，寄存器当中的内容可变，但是形式地址A不可变。</li>
</ol>
</blockquote> 
<p><strong>        10.堆栈寻址：</strong>堆栈其实就是存储器（或者专用寄存器）中一块特定的，按照后进先出的原则管理的存储区，该存储区当中的读/写单元的地址是用一个特定的寄存器给出的，该寄存器成为堆栈指针（SP），其实就是起到一个类似于指针的作用，按照一定的次序先后存取内从当中的数据，并且保存当前正在访问的内存区域，可以把它比喻成一个指针。SP通常都是从栈区的顶层向下访问的，所以当出栈的时候SP+1，这个和我们平时所理解的操作正好是相反的。</p> 
<hr>
<h1>三、CISC和RISC的基本概念</h1> 
<ol>
<li>指令系统朝着两个截然不同的方向发展，一是增强原有的指令功能，设置更为复杂的新指令实现软件的硬化，这类机器成为复杂指令系统计算机（CISC），最典型的X86架构的计算机，二是减少指令的类型简化指令的功能，提高指令的执行速度，这类指令成为精简指令系计算机（RISC）典型的ARM、MIPS架构的计算机。</li>
<li>但是在使用复杂指令集的时候问题便凸现出来了，指令集在被使用的时候符合二八定律，就是20%的指令约占整个程序的80%。而剩下的多数指令则很少会被系统调用，这才有了后来的精简指令集。</li>
<li>对于将来不打算考研的小伙伴来说我们了解这些就已经足够了，如果有老铁想要更细致的了解，可以在《计算机组成原理》这本书上自己去寻觅答案。</li>
</ol>
<hr>
<h1 id="%E6%80%BB%E7%BB%93">
<a id="_55"></a>总结</h1> 
<p>        今天的内容就到此结束了，到目前为止关于计算机底层逻辑的内容就已经为大家介绍了一半了，说实在话我自己的收获真的很大，通过写博客分享的形式，真的对自己的知识是一个很大的提升，和一个很大的挑战，因为有时候自己学会了知识自己的一个主观感受，在为大家进行讲解的时候曾多次发现自己的知识体系有着很大的漏洞，这个时候通过写博客就是对自己的知识的一种巩固。</p> 
<p>        下一次将为大家介绍有关CPU的详细知识，这个是整个计算机组成远离当中最难的一部分，也是内容最多的一部分，指令流水、中断屏蔽、微指令等重难点都会在这里有所体现，这对于我来说也是一个重大的挑战，我写博客需要两个小时，但是光整理学习整理这些知识可能就要20个小时不止。本期内容到这里就结束了，我们下次再见。</p> 
<hr>
<h1 style="text-align:center">你的支持就是我最大的动力，请问你学会了吗？</h1>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>