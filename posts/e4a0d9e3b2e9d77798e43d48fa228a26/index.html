<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C&#43;&#43;】面试官：你小子,继承与多态的题你都会 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】面试官：你小子,继承与多态的题你都会</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p></p> 
</blockquote> 
<p></p> 
<div> 
 <h3>文章目录</h3> 
 <ul>
<li><a href="#_7">前言</a></li>
<li>
<a href="#pandas_16">一、</a><span style="color:#fe2c24">理论知识类</span>
</li>
<li>
<a href="#_19">二、</a><span style="color:#956fe7">编程题选择类</span>
</li>
</ul> 
</div> 
<p></p> 
<hr> 
<h1>
<a id="_7"></a>前言</h1> 
<p>上一篇文章我们详细了介绍了多态，用汇编一步一步的查看了多态的实现原理，讲解了这么多理论知识该做一些面试题了，这些面试题都是历年来大厂所出的笔试题，希望大家可以把我今天所讲的全部学懂~</p> 
<hr> 
<p></p> 
<h1>
<a id="pandas_16"></a>一、理论知识类</h1> 
<div> 
 <span style="color:#777777">1. </span> 
 <span style="color:#777777">下面哪种面向对象的方法可以让你变得富有</span> 
 <span style="color:#777777">( A) </span> 
</div> 
<div> 
 <span style="color:#777777">A: </span> 
 <span style="color:#777777">继承</span> 
 <span style="color:#777777"> B: </span> 
 <span style="color:#777777">封装</span> 
 <span style="color:#777777"> C: </span> 
 <span style="color:#777777">多态</span> 
 <span style="color:#777777"> D: </span> 
 <span style="color:#777777">抽象</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777">这道题说哪种面向对象的方法可以让我们更富有，也就是东西更多，那么一定是继承无疑了,因为继承可以让我们获得所有父类的东西。</span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#777777">2. ( D)</span> 
  <span style="color:#777777">是面向对象程序设计语言中的一种机制。这种机制实现了方法的定义与具体的对象无关， </span> 
 </div> 
 <div> 
  <span style="color:#777777">而对方法的调用则可以关联于具体的对象。 </span> 
 </div> 
 <div> 
  <span style="color:#777777">A: </span> 
  <span style="color:#777777">继承</span> 
  <span style="color:#777777"> B: </span> 
  <span style="color:#777777">模板</span> 
  <span style="color:#777777"> C: </span> 
  <span style="color:#777777">对象的自身引用</span> 
  <span style="color:#777777"> D: </span> 
  <span style="color:#777777">动态绑定</span> 
 </div> 
 <div></div> 
 <div>
   这道题的关键在于“方法的定义与具体的对象无关”这句话，选项里只有多态才满足这样的要求，当我们是父类指针的时候调用一个函数有可能调用的是父类的实现，有可能调用的是子类的实现，这要看指针里面存放的是什么类型的对象，如果不是多态那么父类指针只能调用父类的方法。 
 </div> 
 <div></div> 
 <div> 
  <div> 
   <span style="color:#777777">3. </span> 
   <span style="color:#777777">面向对象设计中的继承和组合，下面说法错误的是？（C） </span> 
  </div> 
  <div> 
   <span style="color:#777777">A</span> 
   <span style="color:#777777">：继承允许我们覆盖重写父类的实现细节，父类的实现对于子类是可见的，是一种静态复 </span> 
  </div> 
  <div> 
   <span style="color:#777777">用，也称为白盒复用 </span> 
  </div> 
  <div> 
   <span style="color:#777777">B</span> 
   <span style="color:#777777">：组合的对象不需要关心各自的实现细节，之间的关系是在运行时候才确定的，是一种动 </span> 
  </div> 
  <div> 
   <span style="color:#777777">态复用，也称为黑盒复用 </span> 
  </div> 
  <div> 
   <span style="color:#777777">C</span> 
   <span style="color:#777777">：优先使用继承，而不是组合，是面向对象设计的第二原则 </span> 
  </div> 
  <div> 
   <span style="color:#777777">D</span> 
   <span style="color:#777777">：继承可以使子类能自动继承父类的接口，但在设计模式中认为这是一种破坏了父类的封 </span> 
  </div> 
  <div> 
   <span style="color:#777777">装性的表现 </span> 
  </div> 
  <div></div> 
  <div>
    c选项错误的原因是 
   <span style="color:#fe2c24"><strong>优先使用对象组合，而不是类继承， </strong></span> 
   <span style="color:#0d0016">通常可以看</span>他们的关系是is a（每个派生类对象都是一个基类对象）还是has a（组合是has a的关系，假设B组合了A，那么每个B对象中都有一个A对象）。 
  </div> 
  <div></div> 
  <div> 
   <div> 
    <span style="color:#777777">4. </span> 
    <span style="color:#777777">以下关于纯虚函数的说法</span> 
    <span style="color:#777777">,</span> 
    <span style="color:#777777">正确的是</span> 
    <span style="color:#777777">(A ) </span> 
   </div> 
   <div> 
    <span style="color:#777777">A</span> 
    <span style="color:#777777">：声明纯虚函数的类不能实例化对象</span> 
    <span style="color:#777777"> B</span> 
    <span style="color:#777777">：声明纯虚函数的类是虚基类 </span> 
   </div> 
   <div> 
    <span style="color:#777777">C</span> 
    <span style="color:#777777">：子类必须实现基类的纯虚函数</span> 
    <span style="color:#777777"> D</span> 
    <span style="color:#777777">：纯虚函数必须是空函数</span> 
   </div> 
   <div></div> 
   <div>
     纯虚函数不可以实例化出对象，声明纯虚函数的类是抽象类，如果不用子类可以不重写基类的纯虚函数，纯虚函数的函数体内可以实现，不一定必须是空函数，这点大家可以用编译器自行确认。 
   </div> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#777777">5. </span> 
     <span style="color:#777777">关于虚函数的描述正确的是</span> 
     <span style="color:#777777">(B ) </span> 
    </div> 
    <div> 
     <span style="color:#777777">A</span> 
     <span style="color:#777777">：派生类的虚函数与基类的虚函数具有不同的参数个数和类型</span> 
     <span style="color:#777777"> B</span> 
     <span style="color:#777777">：内联函数不能是虚函数 </span> 
    </div> 
    <div> 
     <span style="color:#777777">C</span> 
     <span style="color:#777777">：派生类必须重新定义基类的虚函数</span> 
     <span style="color:#777777"> D</span> 
     <span style="color:#777777">：虚函数可以是一个</span> 
     <span style="color:#777777">static</span> 
     <span style="color:#777777">型的函数</span> 
    </div> 
    <div></div> 
    <div>
      A：虚函数有三同，函数名相同，返回值相同，参数相同（协变和析构函数除外），协变就是返回值可以是具有父子关系的指针或引用，而析构函数由于编译器统一识别为destruct，所以即使每个类看着析构函数的函数名不同，但是却可以实现虚函数。B：内联函数不能成为虚函数，因为内联函数会被展开没有地址，而虚函数需要地址。C：派生类可以不重新定义基类的虚函数。D：虚函数不可以是static类型，因为虚函数需要this指针调用，而static类型的函数无this指针。 
    </div> 
    <div></div> 
    <div> 
     <div> 
      <span style="color:#777777">6. </span> 
      <span style="color:#777777">关于虚表说法正确的是（ D） </span> 
     </div> 
     <div> 
      <span style="color:#777777">A</span> 
      <span style="color:#777777">：一个类只能有一张虚表 </span> 
     </div> 
     <div> 
      <span style="color:#777777">B</span> 
      <span style="color:#777777">：基类中有虚函数，如果子类中没有重写基类的虚函数，此时子类与基类共用同一张虚表 </span> 
     </div> 
     <div> 
      <span style="color:#777777">C</span> 
      <span style="color:#777777">：虚表是在运行期间动态生成的 </span> 
     </div> 
     <div> 
      <span style="color:#777777">D</span> 
      <span style="color:#777777">：一个类的不同对象共享该类的虚表</span> 
     </div> 
     <div></div> 
     <div>
       A：多继承的时候可能就会有多张虚表。B：子类和基类是两个不同的对象，他们的虚表没有任何关系。  C：虚表是在编译时期生成的，而虚表指针是在构造函数的初始化列表生成的。D：一个类的不同对象用的同一张虚表是正确的。 
     </div> 
     <div></div> 
     <div> 
      <p>7.关于虚函数说法正确的是（ B）</p> 
      <p>A.被virtual修饰的函数称为虚函数</p> 
      <p>B.虚函数的作用是用来实现多态</p> 
      <p>C.虚函数在类中声明和类外定义时候，都必须加虚拟关键字</p> 
      <p>D.静态虚成员函数没有this指针</p> 
      <p> A：被virtual修饰的<span style="color:#fe2c24">成员函数</span>称为虚函数  B：虚函数的作用就是用来实现多态的，正确 C：virtual只需要在声明的时候加上，在类外实现不能加。D：静态成员函数不可以设置为虚函数</p> 
      <p>8.关于多态，说法不正确的是（C ）</p> 
      <p>A.C++语言的多态性分为编译时的多态性和运行时的多态性</p> 
      <p>B.编译时的多态性可通过函数重载实现</p> 
      <p>C.运行时的多态性可通过模板和虚函数实现</p> 
      <p>D.实现运行时多态性的机制称为动态绑定</p> 
      <p>C错误的点在于运行时的多态性通过虚函数实现，与模板无关。</p> 
      <p>9.关于重载、重写和重定义的区别说法正确的是（ AF）【不定项选择】</p> 
      <p>A.重写和重定义都发生在继承体系中</p> 
      <p>B.重载既可以在一个类中，也可以在继承体系中</p> 
      <p>C.它们都要求原型相同</p> 
      <p>D.重写就是重定义</p> 
      <p>E.重定义就是重写</p> 
      <p>F.重写比重定义条件更严格</p> 
      <p>G.以上说法全错误</p> 
      <p>A：虚函数重写就是发生在继承体系中的，重定义就是隐藏，隐藏也是发生在继承体系中并且是在继承体系中的子类中。B:重载不可以在继承体系中，重载必须在同一个作用域。C：重载，重写，重定义都要求函数名相同,但是只要重写要求三同。D：重写和重定义是不同的概念。E：重定义是隐藏，重写是多态。F：重写的条件需要三同，而重定义对于成员函数而言只需要函数名相同就构成隐藏。</p> 
      <p>10.关于重载和多态正确的是 （B ）</p> 
      <p>A.如果父类和子类都有相同的方法,参数个数不同, 将子类对象赋给父类对象后, 采用父类对象调用该同名方法时，实际调用的是子类的方法</p> 
      <p>B.选项全部都不正确</p> 
      <p>C.重载和多态在C++面向对象编程中经常用到的方法,都只在实现子类的方法时才会使用</p> 
      <p>D.class A{ public: void test(float a) { cout &lt;&lt; a; } }; class B :public A{ public: void test(int b){ cout &lt;&lt; b; } }; void main() { A *a = new A; B *b = new B; a = b; a-&gt;test(1.1); } 结果是1</p> 
      <p>A：多态必须用父类的指针或引用。C：重载要求在同一个作用域，不能再两个类中 D：父类A指针存放A的对象，子类B指针存放B的对象，将子类指针给父类指针后调用test函数，由于test函数不是虚函数不构成多态，父类指针只能调用父类的方法，所以打印1.1</p> 
      <p>11.关于抽象类和纯虚函数的描述中，错误的是 （ D）</p> 
      <p>A.纯虚函数的声明以“=0;”结束</p> 
      <p>B.有纯虚函数的类叫抽象类，它不能用来定义对象</p> 
      <p>C.抽象类的派生类如果不实现纯虚函数，它也是抽象类</p> 
      <p>D.纯虚函数不能有函数体</p> 
      <p>D：纯虚函数可以有函数体，并且函数体内也可以实现一些内容。</p> 
      <p>12.假设A为抽象类，下列声明（B ）是正确的</p> 
      <p>A.A fun(int);</p> 
      <p>B.A*p;</p> 
      <p>C.int fun(A);</p> 
      <p>D.A obj;</p> 
      <p>抽象类不可以实例化对象，只要是有A对象都错误，B答案中是指针类型，不管是什么类型的指针都是内置类型。</p> 
      <p>13.如果类B继承类A，A::x()被声明为虚函数，B::x()重写了A::x()方法，下述语句中哪个x()方法会被调用：(B )           ﻿B b;b.x();</p> 
      <p>A.A::x()</p> 
      <p>B.B::x()</p> 
      <p>C.A::x() B::x()</p> 
      <p>D.B::x() A::x()</p> 
      <p>因为b是一个子类对象，对象调用只能调用自己的函数。</p> 
      <p>14.关于不能设置成虚函数的说法正确的是（D ）</p> 
      <p>A.友元函数可以作为虚函数，因为友元函数出现在类中</p> 
      <p>B.成员函数都可以设置为虚函数</p> 
      <p>C.静态成员函数不能设置成虚函数，因为静态成员函数不能被重写</p> 
      <p>D.析构函数建议设置成虚函数，因为有时可能利用多态方式通过基类指针调用子类析构函数</p> 
      <p>A：友元函数不可以设为虚函数 B：成员函数static不可以设置为虚函数  C：静态成员函数不能设置为虚函数的原因是静态成员函数没有this指针。D：析构函数建议设置为虚函数是正确的。</p> 
      <p>15.要实现多态类型的调用，必须（ D）</p> 
      <p>A.基类和派生类原型相同的函数至少有一个是虚函数即可</p> 
      <p>B.假设重写成功，通过指针或者引用调用虚函数就可以实现多态</p> 
      <p>C.在编译期间，通过传递不同类的对象，编译器选择调用不同类的虚函数</p> 
      <p>D.只有在需要实现多态时，才需要将成员函数设置成虚函数，否则没有必要</p> 
      <p>A：必须将基类原型相同的函数设置为虚函数  B：必须是父类的指针或引用   C：是在运行期间（编译期间，编译器主要检测代码是否违反语法规则，此时无法知道基类的指针或者引用到底引用那个类的对象，也就无法知道调用那个类的虚函数。在程序运行时，才知道具体指向那个类的对象，然后通过虚表调用对应的虚函数，从而实现多态。）</p> 
      <p>16.假设A类中有虚函数，B继承自A，B重写A中的虚函数，也没有定义任何虚函数，则（B ）</p> 
      <p>A.A类对象的前4个字节存储虚表地址，B类对象前4个字节不是虚表地址</p> 
      <p>B.A类对象和B类对象前4个字节存储的都是虚表的地址</p> 
      <p>C.A类对象和B类对象前4个字节存储的虚表地址相同</p> 
      <p>D.A类和B类中的内容完全一样，但是A类和B类使用的不是同一张虚表</p> 
      <p>A：父类对象和子类对象的前4个字节都是虚表地址  C：A类和B类是不同的类如果都有虚函数各自有各自的虚表  D：A类和B类不是同一个类内容一定不同。</p> 
      <p>17.假设D类先继承B1，然后继承B2，B1和B2基类均包含虚函数，D类对B1和B2基类的虚函数重写了，并且D类增加了新的虚函数，则：（B ）</p> 
      <p>A.D类对象模型中包含了3个虚表指针</p> 
      <p>B.D类对象有两个虚表，D类新增加的虚函数放在第一张虚表最后</p> 
      <p>C.D类对象有两个虚表，D类新增加的虚函数放在第二张虚表最后</p> 
      <p>D.以上全部错误</p> 
      <p>首先这是多继承问题，D继承了B1 B2而且B1 B2都有虚函数所以他们都有虚表，所以D有2张虚表，因为先继承的B1所以B1的虚表是第一张，而派生类新增加的虚函数会放在第一张虚表的最后</p> 
      <p>（D类有几个父类，如果父类有虚函数，则就会有几张虚表，自身子类不会产生多余的虚表，所以只有2张虚表）</p> 
      <p>18.下面关于继承说法不正确的是（C）</p> 
      <p>A.继承可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展</p> 
      <p>B.继承体系中子类必须要体现出与基类的不同</p> 
      <p>C.子类对象一定比基类对象大</p> 
      <p>D.继承呈现了面相对象程序设计的层次结构，体现了有简单到复杂的认知过程</p> 
      <p>C：中错误的原因是如果基类实现了虚函数那么就会多出来一个虚表指针这个指针4/8字节，通常在子类没有比父类多出变量并且子类没有虚函数的时候子类就不一定比基类对象大了。</p> 
      <p>19.关于继承说法正确的是（D ）</p> 
      <p>A.所有的类都可以被继承</p> 
      <p>B.Car(汽车)类和Tire(轮胎)类可以使用继承方式体现</p> 
      <p>C.继承是实现代码复用的唯一手段</p> 
      <p>D.狗是一种动物，可以体现出继承的思想</p> 
      <p>A：<strong><span style="color:#fe2c24">final说明的类不能被继承</span></strong>   B：car和tire类是has a 的关系，不能用继承应该用组合。（因为轮胎不能代表汽车，而狗继承了动物后不仅有自己独特的特征同时自己也有动物的所有特征）</p> 
      <p>20.下面关于访问权限与继承权限说法不正确的是（ C）</p> 
      <p>A.访问权限和继承权限是不同的概念</p> 
      <p>B.访问权限和继承权限关键字上是一样的，但是出现位置不一样</p> 
      <p>C.如果是protected继承方式，基类public的成员变量能通过基类对象在类外直接访问</p> 
      <p>D.基类私有的成员变量在子类中都不能直接访问，因为没有被子类继承了</p> 
      <p>D选项错误的原因是子类也会继承基类的私有成员，但是因为权限问题访问不了基类的私有成员。</p> 
      <p>21.关于同名隐藏的说法正确的是（D ）</p> 
      <p>A.同一个类中，不能存在相同名称的成员函数</p> 
      <p>B.在基类和子类中，可以存在相同名称但参数列表不同的函数，他们形成重载</p> 
      <p>C.在基类和子类中，不能存在函数原型完全相同的函数，因为编译时会报错</p> 
      <p>D.成员函数可以同名，只要参数类型不同即可，成员变量不能同名，即使类型不同</p> 
      <p>A:一个类中可以存在，比如函数重载   C：重写要求三同，就是函数原型完全相同的函数  </p> 
      <p>22.下面说法正确的是（D ）</p> 
      <p>A.派生类构造函数初始化列表的位置必须显式调用基类的构造函数，已完成基类部分成员的初始化</p> 
      <p>B.派生类构造函数先初始化子类成员，再初始化基类成员</p> 
      <p>C.派生类析构函数不会自动析构基类部分成员</p> 
      <p>D.子类构造函数的定义有时需要参考基类构造函数</p> 
      <p>A:不显示调用编译器会默认调用基类的构造函数初始化基类部分（前提是基类一定要有默认的构造函数）  B：派生类构造函数先初始化父类成员  C：派生类析构函数会在子类析构函数结束后自动调用父类的析构函数，完成先析构子，再析构父</p> 
      <p>23.关于派生类构造函数与析构函数说法正确的是（ A）</p> 
      <p>A.在派生类对象构造时，先调用基类构造函数，后调用子类构造函数</p> 
      <p>B.在派生构造函数初始化列表的位置必须显式调用基类构造函数</p> 
      <p>C.在派生类对象销毁时，先调用基类析构函数，后调用子类析构函数</p> 
      <p>D.派生类的析构函数只需析构派生类的资源即可</p> 
      <p>这题与上题同理。</p> 
      <p>24.关于基类哪些成员被子类继承说法不正确的是（C ）</p> 
      <p>A.静态成员函数</p> 
      <p>B.所有成员变量</p> 
      <p>C.基类的友元函数</p> 
      <p>D.静态成员变量在整个继承体系中只有一份</p> 
      <p>C：友元函数不可以被继承</p> 
      <p>25关于基类与派生类对象模型说法正确的是（E）</p> 
      <p>A.基类对象中包含了所有基类的成员变量</p> 
      <p>B.子类对象中不仅包含了所有基类成员变量，也包含了所有子类成员变量</p> 
      <p>C.子类对象中没有包含基类的私有成员</p> 
      <p>D.基类的静态成员可以不包含在子类对象中</p> 
      <p>E.以上说法都不对</p> 
      <p>A：静态成员变量属于所有类  B：同理静态成员变量  C：子类对象也会继承父类的私有成员  D:基类的静态成员一定不能包含在子类对象中</p> 
      <p>26.关于基类与子类对象之间赋值说法不正确的是（B ）</p> 
      <p>A.基类指针可以直接指向子类对象</p> 
      <p>B.基类对象可以直接赋值给子类对象</p> 
      <p>C.子类对象的引用不能引用基类的对象</p> 
      <p>D.子类对象可以直接赋值给基类对象</p> 
      <p>只需要记住父类不能直接赋值给子类（可以动态转换）包括引用。</p> 
      <p>27.下面关于继承权限说法正确的是（C ）</p> 
      <p>A.派生类在继承基类时，必须明确指定继承方式</p> 
      <p>B.Class定义的类，默认的访问权限是protected</p> 
      <p>C.struct定义的类，默认访问权限是public</p> 
      <p>D.子类没有继承基类私有的成员</p> 
      <p>A：可以不明确，默认私有继承  B：class的类默认访问权限为私有 </p> 
      <p>28.关于以下菱形继承说法不正确的是（C ）</p> 
      <p>﻿class B {public: int b;};</p> 
      <p>class C1: public B {public: int c1;};</p> 
      <p>class C2: public B {public: int c2;};</p> 
      <p>class D : public C1, public C2 {public: int d;};</p> 
      <p>A.D总共占了20个字节</p> 
      <p>B.B中的内容总共在D对象中存储了两份</p> 
      <p>C.D对象可以直接访问从基类继承的b成员</p> 
      <p>D.菱形继承存在二义性问题，尽量避免设计菱形继承</p> 
      <p>A：D继承了C1，C1继承了B有b和c1两个变量一共八字节，C2继承了B有b和c2两个变量一共8字节，又因为D有自己的d变量，所以一共20字节。  C：D对象不可以直接访问从基类继承的b成员，因为b成员有两份这里有二义性的问题，需要前面加上域名限定符才能正确访问。</p> 
      <p></p> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<h1>
<a id="_19"></a>二、编程题选择类</h1> 
<p>1.下面代码输出结果：( D)</p> 
<pre><code class="language-cpp">class A
{
public:
  void f(){ cout&lt;&lt;"A::f()"&lt;&lt;endl; }
  int a;   
};

class B : public A
{
public:
  void f(int a){cout&lt;&lt;"B::f()"&lt;&lt;endl;}
  int a;
};
int main()
{
  B b;
  b.f();
  return 0;
}</code></pre> 
<p>A.打印A::f()</p> 
<p>B.打印B::f()</p> 
<p>C.不能通过编译，因为基类和派生类中a的类型以及名称完全相同</p> 
<p>D.以上说法都不对</p> 
<p> 首先看main函数，定义了一个对象b，既然是对象先去B类中找f()函数如果没有才去父类中寻找，而子类中由于f()函数与父类函数同名构成隐藏，隐藏了父类的函数实现方法所以只能调用子类的f(int a)函数，而由于缺乏参数所以编译报错。</p> 
<p>2.下面哪项结果是正确的（C ）</p> 
<pre><code class="language-cpp">﻿class Base1 { public: int _b1; };
class Base2 { public: int _b2; };
class Derive : public Base1, public Base2 
{ 
  public: int _d; 
};


int main(){
Derive d;
Base1* p1 = &amp;d;
Base2* p2 = &amp;d;
Derive* p3 = &amp;d;
return 0;
}</code></pre> 
<p> A.p1 == p2 == p3</p> 
<p>B.p1 &lt; p2 &lt; p3</p> 
<p>C.p1 == p3 != p2</p> 
<p>D.p1 != p2 != p3</p> 
<p> 首先d继承了base1和base2,有一个base1的指针存储d对象，base2的指针也存储d对象，派生类指针存储子类对象，下面我们画图看看他们的关系：</p> 
<p><img alt="" height="345" src="https://images2.imgbox.com/3b/06/8nhag3na_o.png" width="1084"></p> 
<p> 由于d先继承的base1所以只有base1的首地址与d相同，而base2的首地址在base1类的下一个所以和d不相同。</p> 
<p>3.下列代码中f函数执行结束后输出（C ）</p> 
<pre><code class="language-cpp">class A
{
public:
  A() { cout&lt;&lt;"A::A()"&lt;&lt;endl; }
  ~A() { cout&lt;&lt;"A::~A()"&lt;&lt;endl; }
  int a;
};

class B : public A
{
public:
  B() { cout&lt;&lt;"B::B()"&lt;&lt;endl; }
  ~B() {cout&lt;&lt;"B::~B()"&lt;&lt;endl; }
  int b;
};

void f()
{
  B b;
}</code></pre> 
<p>A.B::B() B::~B()</p> 
<p>B.B::B() A::A() A::~A() B::B()</p> 
<p>C.A::A() B::B() B::~B() A::~A()</p> 
<p>D.以上都不对</p> 
<p>首先从f()函数开始看起，有一个子类对象b，这时候调用B的构造函数，进入B的构造函数初始化列表调用父类A的构造函数，所以先打印A（），然后进入B构造函数的函数体打印B(），然后函数结束开始析构，先析构子类对象打印~B（），然后子类析构结束后自动调用父类析构~A（）。</p> 
<p>4.以下哪项说法时正确的（D ）</p> 
<pre><code class="language-cpp">class A
{
public:
  void f1(){cout&lt;&lt;"A::f1()"&lt;&lt;endl;}
  virtual void f2(){cout&lt;&lt;"A::f2()"&lt;&lt;endl;}
  virtual void f3(){cout&lt;&lt;"A::f3()"&lt;&lt;endl;}
};


class B : public A
{
public:
  virtual void f1(){cout&lt;&lt;"B::f1()"&lt;&lt;endl;}
  virtual void f2(){cout&lt;&lt;"B::f2()"&lt;&lt;endl;}
  void f3(){cout&lt;&lt;"B::f3()"&lt;&lt;endl;}
};</code></pre> 
<p>A.基类和子类的f1函数构成重写</p> 
<p>B.基类和子类的f3函数没有构成重写，因为子类f3前没有增加virtual关键字</p> 
<p>C.如果基类指针引用子类对象后，通过基类对象调用f2时，调用的是子类的f2</p> 
<p>D.f2和f3都是重写，f1是重定义</p> 
<p>f1由于在基类中没有加virtual关键字，所以只能构成隐藏。f2和f3满足重写的条件。</p> 
<p>5.以下程序输出结果是( C)</p> 
<pre><code class="language-cpp">﻿class A
{
public:
  A ():m_iVal(0){test();}
  virtual void func() { std::cout&lt;&lt;m_iVal&lt;&lt;‘ ’;}
  void test(){func();}
public:
  int m_iVal;
};

class B : public A
{
public:
  B(){test();}
  virtual void func()
  {
    ++m_iVal;
    std::cout&lt;&lt;m_iVal&lt;&lt;‘ ’;
  }
};

int main(int argc ,char* argv[])
{
  A*p = new B;
  p-&gt;test();
  return 0;
}</code></pre> 
<p>A.1 0</p> 
<p>B.0 1</p> 
<p>C.0 1 2</p> 
<p>D.2 1 0</p> 
<p>E.不可预期</p> 
<p>F. 以上都不对</p> 
<p>首先从main函数看起，父类指针存放子类是多态的信号，先自动调用B类的构造函数，在B的构造函数的初始化列表调用A的构造函数，然后将mval初始化为0，调用A类中的test函数，在test函数中又调用了func函数，这个时候由于派生类的构造函数初始化列表还没走完，所以没有虚表指针不构成多态，只能调用A类中的func打印0，然后进入B类的构造函数的函数体中调用test函数，由于B中无test函数只能去父类A中调用，在A类中的test函数体中调用func函数，这个时候因为派生类的初始化列表已经走完了虚表指针形成了，并且func被子类重写由this指针也就是A*父类指针调用func满足多态所以在B类中的func中先让mval++变成1然后打印1，接下来由父类指针P主动调用test函数，同样满足多态调用B类中的func函数，mval++变成2然后打印2，所以答案是0 1 2.</p> 
<p>6.下面函数输出结果是（ A）</p> 
<pre><code class="language-cpp">class A
{
public: 
  virtual void f()
  {
    cout&lt;&lt;"A::f()"&lt;&lt;endl;
  }
};

class B : public A
{
private:
   virtual void f()
  {
    cout&lt;&lt;"B::f()"&lt;&lt;endl;
  }
};
int main()
{
A* pa = (A*)new B;
pa-&gt;f();
}</code></pre> 
<p>A.B::f()</p> 
<p>B.A::f()，因为子类的f()函数是私有的</p> 
<p>C.A::f()，因为强制类型转化后，生成一个基类的临时对象，pa实际指向的是一个基类的临时对象</p> 
<p>D.编译错误，私有的成员函数不能在类外调用</p> 
<p>先从main函数看起，父类指针存放子类，先调用子类的构造函数，无构造我们就直接往下讲了，由于继承中天生的赋值类型转换，所以子类到父类并不需要强转，所以这一步没有作用，父类指针调用f函数，进入A类中发现f是虚函数子类重写了这个虚函数所以调用B类中的f()函数，虽然这个时候B类中的f()函数是私有的，但是多态仅仅是用子类函数的地址覆盖虚表，最终调用的位置不变只是执行函数发生了变化，所以还是打印B（）</p> 
<p>7.下面 C++ 程序的运行结果是（C）</p> 
<pre><code class="language-cpp">class parent {
int i;
protected:
int x;
public:
parent() { x = 0; i = 0; }
void change() { x++; i++; }
void display();
};
class son :public parent {
public:
void modify();
};
void parent::display() {
cout &lt;&lt; "x=" &lt;&lt; x &lt;&lt; endl;
}
void son::modify() {
x++;
}
int main() 
{
son A;
parent B;
A.display();
A.change();
A.modify();
A.display();
B.change();
B.display();
return 0;
}</code></pre> 
<p>A：x=1  x=0   x=2<br> B ：x=2    x=0     x=1<br> C ：x=0    x=2    x=1<br> D： x=0    x=1    x=2</p> 
<p> 先进入main函数，有一个子类对象A，有一个父类对象B，都经过构造函数初始化x=0，A调用A中的display打印x = 0,然后A调用父类中的change函数（因为子类无change函数），x变成1，然后A调用A中的modify函数x++变成2然后打印2，<span style="color:#fe2c24">由于A和B是两个不同的类</span>，所以B调用B中的change函数后x从0变成1，然后打印1。</p> 
<p>8.分析一下这段程序的输出(A)</p> 
<pre><code class="language-cpp">class B
{
public:
B()
{
cout &lt;&lt; "default constructor" &lt;&lt; " ";
}
~
B()
{
cout &lt;&lt; "destructed" &lt;&lt; " ";
}
B(int i): data(i)
{
cout &lt;&lt; "constructed by parameter" &lt;&lt; data &lt;&lt; " ";
}
private: int data;
};
B Play( B b)
{
return b;
}
int main(int argc, char *argv[])
{
B temp = Play(5);
return 0;
}</code></pre> 
<p>A constructed by parameter5 destructed destructed<br> B constructed by parameter5 destructed<br> C default constructor" constructed by parameter5 destructed<br> D default constructor" constructed by parameter5 destructed destructed</p> 
<p>首先进入main函数，调用play函数，而play函数的参数是B类对象，所以这里生成一个B类的临时对象将5拿来构造B然后调用B的构造函数打印constructed by parameter 5，然后调用拷贝构造将这个对象给play函数中的形参，返回的时候本来要创建一个B类的临时对象调用拷贝构造将b给临时对象后再释放原来形参中的那个b变量,但是由于编译器的优化会直接将play的返回值给temp，然后析构掉刚刚那个返回值对象，所以返回值析构打印destructed,函数结束后temp对象析构打印destructed.</p> 
<p>9.以下程序的输出是（C）</p> 
<pre><code class="language-cpp">class Base {
public:
Base(int j): i(j) {}
virtual~Base() {}
void func1() {
i *= 10;
func2();
}
int getValue() {
return i;
}
protected:
virtual void func2() {
i++;
}
protected:
int i;
};
class Child: public Base {
public:
Child(int j): Base(j) {}
void func1() {
i *= 100;
func2();
}
protected:
void func2() {
i += 2;
}
};
int main() {
Base * pb = new Child(1);
pb-&gt;func1();
cout &lt;&lt; pb-&gt;getValue() &lt;&lt; endl; delete pb;
}</code></pre> 
<p>A 11<br> B 101<br> C 12<br> D 102</p> 
<p>首先基类指针存放子类对象是多态的信号，child调用自己的构造函数，然后在初始化列表中用1初始化基类对象，然后去基类的构造函数中用1初始化i，然后调用func1函数，由于func1不是虚函数所以调用基类的func1i*10==10，然后调用func2函数，发现func2是虚函数并且this指针是父类指针所以调用子类中的func2函数i变成12.</p> 
<p>10.下面 C++ 代码的运行结果为（A）</p> 
<pre><code class="language-cpp">class B0 {
public:
virtual void display() {
cout &lt;&lt; "B0::display0" &lt;&lt; endl;
}
};
class B1 :public B0 {
public:
void display() { cout &lt;&lt; "B1::display0" &lt;&lt; endl; }
};
class D1 : public B1 {
public:
void display() {
cout &lt;&lt; "D1::display0" &lt;&lt; endl;
}
};
void fun(B0 ptr) {
ptr.display();
}
int main() {
B0 b0;
B1 b1;
D1 d1;
fun(b0);
fun(b1);
fun(d1);
}</code></pre> 
<p>A B0::display0 B0::display0 B0::display0<br> B B0::display0 B0::display0 D1::display0<br> C B0::display0 B1::display0 D1::display0<br> D B0::display0 B1::display0 B1::display0</p> 
<p>首先main函数有3个对象，然后都去调用fun函数，而fun函数参数是基类对象，由对象调用display只能调用父类B0自己的函数，所以打印三次B0::display0</p> 
<p>11.下面 C++ 程序的运行结果为（A）</p> 
<pre><code class="language-cpp">class A {
public: A(const char* s) { cout &lt;&lt; s &lt;&lt; endl; } ~A() {}
};
class B : virtual public A {
public: B(const char* s1, const char* s2) :A(s1) { cout &lt;&lt; s2 &lt;&lt; endl; }
};
class C : virtual public A {
public: C(const char* s1, const char* s2) :A(s1) { cout &lt;&lt; s2 &lt;&lt; endl; }
};
class D : public B, public C {
public: D(const char* s1, const char* s2, const char* s3, const char* s4) :B(s1, s2), C(s1, s3), A(s1)
{ cout &lt;&lt; s4 &lt;&lt; endl; }
};
int main()
{ 
  D* p = new D("class A", "class B", "class C", "class D"); delete p; return 0;
}</code></pre> 
<p> A class A    class B     class C     class D<br> B class D    class B     class C     class A<br> C class D    class C     class B     class A<br> D class A     class C     class B     class D</p> 
<p> 首先这是个多继承问题，我们可以看到D类先继承B，再继承C，而B类中先继承了A，所以D中构造函数的初始化顺序为A B C D，A用s1初始化进入s1的构造函数打印class A，然后用s1和s2初始化B，由于B虚继承A只有一份A所以刚开始在A初始化一次后后面在其他类的初始化列表就不再初始化A了，所以打印S2也就是classB，然后用s1和s3初始化C，与B同理A不初始化打印S3也就是class C，最后进入D的构造函数函数体打印classD</p> 
<p>12.有如下C++代码（A）</p> 
<pre><code class="language-cpp">struct A{
void foo(){printf("foo");}
virtual void bar(){printf("bar");}
A(){bar();}
};
struct B:A{
void foo(){printf("b_foo");}
void bar(){printf("b_bar");}
};

A *p = new B;
p-&gt;foo();
p-&gt;bar();</code></pre> 
<p>A barfoob_bar<br> B foobarb_bar<br> C barfoob_foo<br> D foobarb_fpp</p> 
<p>首先A和B是struct，struct默认访问权限和继承权限都是公有，new一个B对象，调用B的构造函数在B的构造函数的初始化列表调用A的构造函数，在A的构造函数中调用bar函数，由于初始化列表没有结束只能调用A的bar函数所以打印bar,然后父类指针调用foo函数foo不是虚函数所以调用A中的foo打印foo，然后父类指针调用bar函数，bar是虚函数满足多态条件所以打印b_bar.</p> 
<p>13.以下程序输出结果是（B）</p> 
<pre><code class="language-cpp">class A
{
public:
virtual void func(int val = 1)
{ std::cout&lt;&lt;"A-&gt;"&lt;&lt;val &lt;&lt;std::endl;}
virtual void test()
{ func();}
};
class B : public A
{
public:
void func(int val=0) {std::cout&lt;&lt;"B-&gt;"&lt;&lt;val &lt;&lt;std::endl;}
};
int main(int argc ,char* argv[])
{
B*p = new B;
p-&gt;test();
return 0;
}</code></pre> 
<p>A ：A-&gt;0<br> B ：B-&gt;1<br> C ：A-&gt;1<br> D： B-&gt;0</p> 
<p>首先子类指针存放子类对象，然后调用test函数，进入B类中发现没有test函数只能去父类中找，然后调用调用父类中的test函数，函数体中调用func函数，这时的this指针为A*，func为虚函数去B类中调用func函数，由于缺省参数是编译期间就完成的，而虚函数是运行期间完成的，所以当调用func函数的时候缺省参数还是父类的int val = 1,所以这时候打印B-&gt;1.</p> 
<p>14.下面程序的输出是（B）</p> 
<pre><code class="language-cpp">class A
{
public:
void foo()
{
printf("1");
}
virtual void fun()
{
printf("2");
}
};
class B: public A
{
public:
void foo()
{
printf("3");
}
void fun()
{
printf("4");
}
};
int main(void)
{
A a;
B b;
A *p = &amp;a;
p-&gt;foo();
p-&gt;fun();
p = &amp;b;
p-&gt;foo();
p-&gt;fun();
A *ptr = (A *)&amp;b;
ptr-&gt;foo();
ptr-&gt;fun();
return 0;
}</code></pre> 
<p>A 121434<br> B 121414<br> C 121232<br> D 123434</p> 
<p>首先父类指针p存放父类对象，所以调用的函数都是父类的，打印1 2，然后p又存放子类对象，由于fun是虚函数所以打印1 4，因为子类对象本来就可以直接给父类，所以强转无任何意义与p = &amp;b一模一样，还是打印1 4.</p> 
<p>15.下面这段代码运行时会出现什么问题（B）</p> 
<pre><code class="language-cpp">class A
{
public:
void f()
{
printf("An");
}
};
class B: public A
{
public:
virtual void f()
{
printf("Bn");
}
};
int main()
{
A *a = new B;
a-&gt;f();
delete a;
return 0;
}</code></pre> 
<p>A 没有问题，输出B<br> B 不符合预期的输出A<br> C 程序不正确<br> D 以上答案都不正确</p> 
<p>因为父类指针保存的子类对象，f不是虚函数正常调用A的f函数，但是delete的时候只会调用父类的析构函数这里是会崩溃的，正确的做法是将父类的析构函数定义为虚函数，就可以正常释放子类的资源了。</p> 
<h1><a id="_45"></a></h1>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>