<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Python基础知识大全(适用于全面复习Python语法知识) - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python基础知识大全(适用于全面复习Python语法知识)</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    
                        
                    
                    <h2>
<a id="python_0"></a>python语言的类型</h2> 
<p>python属于解释型语言</p> 
<p>源代码(python)&lt;-&gt;解释器(逐行解释每一句源代码)&lt;-&gt;操作系统&lt;-&gt;cpu</p> 
<p>java属于编译型语言</p> 
<p>源代码(java)-&gt;编译器-&gt;可执行文件-&gt;操作系统&lt;-&gt;cpu</p> 
<h2>
<a id="python_10"></a>python语言数据的基本类型</h2> 
<p>容易混淆的几种表现形式</p> 
<p>元组( ) 和列表[ ] 类似 只是元组不可以修改 这两个有点类似于C语言中的数组</p> 
<p>集合 唯一{ } 和字典类似 只是没有values 字典中的key一定是不可变类型 而且字典查找速度快 缺点是占用内存 同样集合中的元素均是不可变的 所以不能有列表</p> 
<h2>
<a id="_18"></a>可变序列和不可变序列</h2> 
<p>可变序列列和不可变序列区分的标准是是否能够对序列进行增、删、改操作；并且，增删改操作后的对象地址不发生改变。能做增删改操作的序列称为可变序列。反之，不能做增删改操作的序列称为不可变序列。<br> 可变序列：列表、字典、集合<br> 不可变序列：数字、字符串、元组</p> 
<h2>
<a id="_24"></a>列表</h2> 
<h3>
<a id="_26"></a>定义</h3> 
<p>列表（list）是Python中使用最频繁的数据类型，在其他语言中通常叫做数组，专门用来存储一组数据。</p> 
<pre><code>#第一种方式
name_list = []  OR name_list = ['tom','jack']
#第二种方式
data_list = list()
</code></pre> 
<p>ps: 相当于C语言中的数组 只不过C语言的数组存的是同一类型的数据</p> 
<h3>
<a id="count_39"></a>count</h3> 
<pre><code>data_list = ['python', 'java', 'python', 'php']
print(data_list.count("python"))  #2
</code></pre> 
<h3>
<a id="____46"></a>索引[] 列表可以用索引来用数据</h3> 
<pre><code>name_list = ['张三', '李四']
print(name_list[0]) # 张三
print(name_list[1]) # 李四
</code></pre> 
<h3>
<a id="append_____54"></a>append(数据) 在末尾插入数据</h3> 
<pre><code>val_list = ["Web自动化", "UI自动化", "接口自动化"]
val_list.append("APP自动化")
print(val_list) 
# ['Web自动化', 'UI自动化', '接口自动化', 'APP自动化']
ps：
可以插入的各种不同类型的数据  比如数字 字典  元组
</code></pre> 
<h3>
<a id="extend_65"></a>extend()</h3> 
<p>使用新的序列来扩展当前序列，需要一个序列作为参数，它会将该序列中的元素添加到当前列表中</p> 
<pre><code>stus.extend(['唐僧','白骨精'])  相当于
stus += ['唐僧','白骨精']
</code></pre> 
<h3>
<a id="clear_74"></a>clear()</h3> 
<pre><code>stus = ['孙悟空','猪八戒','沙和尚','唐僧']
stus.clear()    #清空序列  []
</code></pre> 
<h3>
<a id="insert_81"></a>insert(位置,数据)</h3> 
<p>abc = [‘yinsheng’, ‘jiayou’, 1111, (11, 22, 33), {‘abc’: 456}]</p> 
<p>abc.insert(0,{“key”:1})</p> 
<p>print(abc)</p> 
<p>#[{‘key’: 1}, ‘yinsheng’, ‘jiayou’, 1111, (11, 22, 33), {‘abc’: 456}]</p> 
<h3>
<a id="remove_91"></a>remove()</h3> 
<pre><code># 删除指定值得元素，如果相同值得元素有多个，只会删除第一个
stus = ['孙悟空','猪八戒','沙和尚','唐僧','猪八戒']
stus.remove('猪八戒')  
print(stus)  #['孙悟空','沙和尚','唐僧','猪八戒']
</code></pre> 
<h3>
<a id="pop_____102"></a>pop (列表索引号) 删除某个数据</h3> 
<pre><code>val_list = ["Web自动化", "UI自动化", "接口自动化"]
val = val_list.pop(0)
print(val, val_list) 
# web自动化，['UI自动化', '接口自动化']
ps：
不指定位置号  那么默认删除最后一个
</code></pre> 
<h3>
<a id="_113"></a>排序</h3> 
<p>reverse() 反转列表</p> 
<pre><code>my_list = [10,1,20,3,4,5,0,-2]
print('修改前',my_list)  #[10,1,20,3,4,5,0,-2]
my_list.reverse()
print('修改后',my_list) #[-2, 0, 5, 4, 3, 20, 1, 10]
</code></pre> 
<p>sort() 默认reverse=false</p> 
<p>sort(reverse=true) #降序</p> 
<p>sort(reverse=false) #升序</p> 
<pre><code>val_list = [8, 100, 30, 10, 40, 2]
val_list.sort(reverse=True)
print(val_list) # [100, 40, 30, 10, 8, 2]
val_list.sort()
print(val_list)  #[2, 8, 10, 30, 40, 100]
</code></pre> 
<p>sorted() 临时排序</p> 
<pre><code>val_list = [8, 100, 30, 10, 40, 2]
b= sorted(val_list)
print(val_list)  #[8, 100, 30, 10, 40, 2]
print(b)  #[2, 8, 10, 30, 40, 100]

</code></pre> 
<h3>
<a id="_150"></a>嵌套</h3> 
<pre><code>student_list = [["张三", "18", "功能测试"], {"key":1,"key1":2},(11,222,333)]
print(student_list[1]["key1"]) #2
print(student_list[0][1]) # 18
print(student_list[2][1]) #222
</code></pre> 
<h2>
<a id="_159"></a>元组</h2> 
<p>ps： 和列表list 几乎差不多 只是不可以修改 但是这个不可以修改指的是指向永远不变</p> 
<p>for example</p> 
<pre><code>t = ('a', 'b', ['A', 'B'],111,(2,3,4),{"key":1})
t[2][0] = 'x'
t[2][1] = 'y'
t[5]["key"]=2
print(t)  
#('a', 'b', ['x', 'y'], 111, (2, 3, 4), {'key': 2})
</code></pre> 
<h3>
<a id="_174"></a>定义</h3> 
<p>元组和列表一样，都可用于存储多个数据，不同之处在于元组的元素不能修改</p> 
<pre><code>#第一种方式
user_info = ()  OR name_list = ('zhangsan',18,1.75)
#第二种方式
info_tuple = tuple()
ps:元组中只包含一个元素时，需要在元素后面添加逗号
如  data=（1，）
</code></pre> 
<h3>
<a id="by_187"></a>查(by索引)</h3> 
<pre><code>tuple1 = (1, 2, 3)
print(tuple1[1]) # 2
</code></pre> 
<h3>
<a id="count_194"></a>count</h3> 
<pre><code>tuple1 = (1, 2, 3)
print(tuple1.count(3)) # 1
</code></pre> 
<h3>
<a id="_201"></a>解包</h3> 
<p>元组的特殊用法: 交换两个变量的值</p> 
<pre><code>num1 = 100
num2 = 200
num2,num1 = num1,num2
print(num1)  #200
print(num2)  #100

ps:
1.在Python中可以使用对应数据个数的变量，获取对应元组数据中的每一个元素
2.在Python中定义多个元素的元组数据时，小括号可以省略
3.借助以上两个特性，可以通过元组快速实现交换两个变量的值
</code></pre> 
<p>解包</p> 
<pre><code>my_tuple = 10 , 20 , 30 , 40
a , b , *c = my_tuple
print(a,b,c)  #10 20 [30, 40]
a , *b , c = my_tuple
print(a,b,c) #10 [20, 30] 40
*a , b , c = my_tuple
print(a,b,c)   #[10, 20] 30 40
</code></pre> 
<h3>
<a id="_232"></a>注意</h3> 
<pre><code>ps:
# 当元组不是空元组时，括号可以省略
# 如果元组不是空元组，它里边至少要有一个,
</code></pre> 
<h2>
<a id="_242"></a>字典</h2> 
<h3>
<a id="_244"></a>定义</h3> 
<pre><code>test = dict()
test2 = {}

d = dict(name1='孙悟空',age1=18,gender1='男')
print(d)    #{'name1': '孙悟空', 'age1': 18, 'gender1': '男'}

#利用双值子序列
d = dict([('name','孙悟饭'),('age',18)])
print(d)  #{'name': '孙悟饭', 'age': 18}
</code></pre> 
<h3>
<a id="__260"></a>增加和修改 字典[键]=值</h3> 
<pre><code>info = {
"name": "tom",
"age": 18
}
info["salary"] = 100000
print(info) # {'name': 'tom', 'age': 18, 'salary': 100000}
</code></pre> 
<h3>
<a id="pop____271"></a>pop(键) 删除</h3> 
<pre><code>info = {
"name": "tom",
"age": 18,
"gender": "男" }
info.pop("gender")
print(info) # {'name': 'tom', 'age': 18}
</code></pre> 
<h3>
<a id="get____282"></a>get(键) 查询</h3> 
<pre><code>info = {
"name": "tom",
"age": 18,
"gender": "男" }
print(info.get("name")) # tom
print(info.get("abc")) # None
</code></pre> 
<h3>
<a id="for_key_in_keys_293"></a>for key in 字典.keys()</h3> 
<pre><code>#遍历得到所有键名
info = {
"name": "tom",
"age": 18,
"gender": "男" }
for key in info.keys():
	print(key)
</code></pre> 
<h3>
<a id="for_value_in_values_305"></a>for value in 字典.values():</h3> 
<pre><code>#遍历得到所有的键对应的值
info = {
"name": "tom",
"age": 18,
"gender": "男" }
for value in info.values():
	print(value)
</code></pre> 
<h3>
<a id="for_k_v_in_items_317"></a>for k, v in 字典.items():</h3> 
<pre><code>#遍历得到所有的键和值
info = {
"name": "tom",
"age": 18,
"gender": "男" }
for k, v in info.items():
	print(f"key={k} value={v}")
</code></pre> 
<h3>
<a id="_329"></a>一些常用方法</h3> 
<p>setdefault(key, default]) 可以用来向字典中添加key-value</p> 
<pre><code>#如果key已经存在于字典中，则返回key对应的value值，不会对字典做任何操作
#如果key不存在，则向字典中添加这个key，并设置value
d = dict([('name','孙悟饭'),('age',18)])
result = d.setdefault('name1','猪八戒')
result2 = d.setdefault('name','11111')
print(result) #猪八戒
print(result2)  #孙悟饭
print(d)  #{'name': '孙悟饭', 'age': 18, 'name1': '猪八戒'}
</code></pre> 
<p>update()</p> 
<pre><code>#将其他的字典中的key-value添加到当前字典中
#如果有重复的key，则后边的会替换到当前的
d = {'a':1,'b':2,'c':3}
d2 = {'d':4,'e':5,'f':6, 'a':7}
d.update(d2)
print(d) #{'a': 7, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
</code></pre> 
<p>del</p> 
<pre><code>d = {'a': 7, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
del d['a']
print(d)  #{'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
del d['e']
print(d)  #{'b': 2, 'c': 3, 'd': 4, 'f': 6}
</code></pre> 
<p>popitem()</p> 
<pre><code>#随机删除字典中的一个键值对，一般都会删除最后一个键值对
#删除之后，它会将删除的key-value作为返回值返回
#返回的是一个元组，元组中有两个元素，第一个元素是删除的key，第二个是删除的value
#当使用popitem()删除一个空字典时，会抛出异常 KeyError
d = {'b': 2, 'c': 3, 'd': 4, 'f': 6}
result = d.popitem() 
print(result)  # ('f', 6)
print(d)  # {'b': 2, 'c': 3, 'd': 4}
</code></pre> 
<p>copy()</p> 
<pre><code># 该方法用于对字典进行浅复制
# 复制以后的对象，和原对象是独立，修改一个不会影响另一个
# 注意，浅复制会简单复制对象内部的值，如果值也是一个可变对象，这个可变对象不会被复制  意味着修改了这个可变对象的值之后 两个地方的值均变化  因为它不独立
</code></pre> 
<pre><code>d = {'a':{'name':'孙悟空','age':18},'b':2,'c':3}
d2 = d.copy() 
print(d2)  # {'a': {'name': '孙悟空', 'age': 18}, 'b': 2, 'c': 3}
d2['a']['name'] = '测试一想'
d2['b']=6
print(d2) # {'a': {'name': '测试一想', 'age': 18}, 'b': 6, 'c': 3}
print('d = ',d , id(d)) #d =  {'a': {'name': '测试一想', 'age': 18}, 'b': 2, 'c': 3} 2363954785808
print('d2 = ',d2 , id(d2)) #d2 =  {'a': {'name': '测试一想', 'age': 18}, 'b': 6, 'c': 3} 2363954786168
</code></pre> 
<p>clear()</p> 
<pre><code>d = {'b': 2, 'c': 3, 'd': 4}
d.clear() #{}
</code></pre> 
<p>in not in</p> 
<h3>
<a id="_406"></a>注意</h3> 
<pre><code>字典的值可以是任意对象
字典的键可以是任意的不可变对象（int、str、bool、tuple ...），但是一般我们都会使用str
字典的键是不能重复的，如果出现重复的后边的会替换到前边的
</code></pre> 
<h2>
<a id="_414"></a>集合</h2> 
<h3>
<a id="_416"></a>定义</h3> 
<pre><code>a = set()
print(type(a))
a = {1,3,4}
print(type(a))
</code></pre> 
<h3>
<a id="_____425"></a>将列表 字符串 字典 元组转化为集合</h3> 
<pre><code>s = set([1,2,3,4,5,1,1,2,3,4,5])
print(s) # {1, 2, 3, 4, 5}

s = set('hello')
print(s) # {'l', 'o', 'e', 'h'}

s = set({'a':1,'b':2,'c':3}) 
print(s)  # {'a', 'b', 'c'}

s = (1,2,3,4)
print(set(s)) # {1, 2, 3, 4}
</code></pre> 
<h3>
<a id="_441"></a>常用方法</h3> 
<p>in not in</p> 
<p>使用in和not in来检查集合中的元素</p> 
<pre><code>s = {'a' , 'b' , 1 , 2 , 3 , 1}
print('c' not in s)  #True
print('a' in s)    #True
</code></pre> 
<p>add()</p> 
<pre><code>s = {'a' , 'b' , 1 , 2 , 3 , 1}
s.add(10)
print(s) #{1, 2, 3, 'a', 10, 'b'}
</code></pre> 
<p>update()</p> 
<p>update() 将一个集合中的元素添加到当前集合中</p> 
<p>update()可以传递序列或字典作为参数，字典只会使用键</p> 
<pre><code>s = {'a' , 'b' , 1 , 2 , 3 , 1}
s2 = set('hello')
s.update(s2)
print(s)  #{1, 2, 3, 'o', 'e', 'a', 'h', 'b', 'l'}
s.update((10,20,30,40,50))
print(s)  #{1, 2, 3, 'o', 40, 10, 'e', 'a', 'h', 50, 20, 30, 'b', 'l'}
s.update({10:'ab',20:'bc',100:'cd',1000:'ef'})
print(s)  #{1, 2, 3, 100, 'o', 40, 10, 'e', 1000, 'a', 'h', 50, 20, 30, 'b', 'l'}

</code></pre> 
<p>pop()</p> 
<p>pop()随机删除并返回一个集合中的元素</p> 
<pre><code>s = {'a' , 'b' , 1 , 2 , 3 , 1}
result = s.pop()  
print(result) #1
print(s)  #{2, 3, 'a', 'b'}
</code></pre> 
<p>remove()</p> 
<pre><code>s = {'a' , 'b' , 100 , 2 , 3 , 100}
s.remove(100)
print(s)  # {2, 3, 'b', 'a'}
</code></pre> 
<p>clear()</p> 
<p>copy() #对集合进行浅复制</p> 
<h3>
<a id="_502"></a>集合的运算</h3> 
<p>&amp;</p> 
<pre><code>s = {1,2,3,4,5}
s2 = {3,4,5,6,7}
# &amp; 交集运算
result = s &amp; s2 
print(result)  # {3, 4, 5}
</code></pre> 
<p>|</p> 
<pre><code>s = {1,2,3,4,5}
s2 = {3,4,5,6,7}
# | 并集运算
result = s | s2 
print(result)  # {1,2,3,4,5,6,7}
</code></pre> 
<ul><li></ul> 
<pre><code>s = {1,2,3,4,5}
s2 = {3,4,5,6,7}
# - 差集
result = s - s2
print(result)   # {1, 2}
</code></pre> 
<p>^</p> 
<pre><code>s = {1,2,3,4,5}
s2 = {3,4,5,6,7}
# ^ 异或集 获取只在一个集合中出现的元素
result = s ^ s2 
print(result)  # {1, 2, 6, 7}

</code></pre> 
<p>&lt;=</p> 
<p>&lt;= 检查一个集合是否是另一个集合的子集</p> 
<p>如果a集合中的元素全部都在b集合中出现，那么a集合就是b集合的子集，b集合是a集合超集</p> 
<pre><code>a = {1,2,3}
b = {1,2,3,4,5}
result = a &lt;= b # True
result = {1,2,3} &lt;= {1,2,3} # True
result = {1,2,3,4,5} &lt;= {1,2,3} # False
</code></pre> 
<p>&lt;</p> 
<p>&lt; 检查一个集合是否是另一个集合的真子集</p> 
<p>如果超集b中含有子集a中所有元素，并且b中还有a中没有的元素，则b就是a的真超集，a是b的真子集</p> 
<pre><code>result = {1,2,3} &lt; {1,2,3} # False
result = {1,2,3} &lt; {1,2,3,4,5} # True
</code></pre> 
<p>大于和&gt;=</p> 
<pre><code># &gt;= 检查一个集合是否是另一个的超集
# &gt; 检查一个集合是否是另一个的真超集
</code></pre> 
<h2>
<a id="_579"></a>通用方法</h2> 
<p>包含字符串(str) 元组(tuple) 列表(list)</p> 
<h3>
<a id="_583"></a>切片操作</h3> 
<p>ps： 列表 元组 字符串 均可切片 集合和字典不可切片</p> 
<p><strong>数据[起始索引:结束索引:步长]</strong></p> 
<pre><code>name = "abcdefg"
print(name[2:5:1]) # cde
print(name[2:5]) # cde
print(name[:5]) # abcde
print(name[1:]) # bcdefg
print(name[:]) # abcdefg
print(name[::2]) # aceg
print(name[:-1]) # abcdef, 负1表示倒数第一个数据print(name[-
4:-1]) # def
print(name[::-1]) # gfedcba
</code></pre> 
<h3>
<a id="len_602"></a>len(）</h3> 
<pre><code>str_data = "hello python"
print(len(str_data)) # 12: 字符中字符个数（包含空格）
list_data = ["python", "java"]
print(len(list_data)) # 2: 列表中元素个数
tuple_data = ("admin", 123456, 8888)
print(len(tuple_data)) # 3: 元组中元素个数
dict_data = {"name": "tom", "age": 18, "gender": "男"}
print(len(dict_data)) # 3: 字典中键值对的个数
</code></pre> 
<h3>
<a id="__615"></a>加减乘除 不是都是哦</h3> 
<p>字符串 和 列表 和 元组 可以 + * 字典和集合不行</p> 
<h3>
<a id="in___or__not__in_621"></a>in or not in</h3> 
<h3>
<a id="max__min_623"></a>max() min()</h3> 
<h3>
<a id="count_______625"></a>count() 对 字典和集合不适用</h3> 
<pre><code>index_1 = '123'   
print(index_1.count('1'))   #1
index_1 = [1,2,3]
print(index_1.count(1))   #1
index_1 = (1,2,3)
print(index_1.count(1))   #1
</code></pre> 
<h3>
<a id="index_____636"></a>index() 对 字典和集合不适用</h3> 
<pre><code>index_1 = (1,2,3)
print(index_1.index(1))  #0
index_1 = [1,2,3]
print(index_1.index(3))  #2
index_1 = 'abc'
print(index_1.index('b'))  #1
</code></pre> 
<h2>
<a id="_651"></a>函数</h2> 
<h3>
<a id="_653"></a>定义的语法格式:</h3> 
<p>函数名命名遵循标识符命名规则：字母，数字，下划线，不能以数字开头，不用使用系统关键字</p> 
<p>def是英文define的缩写</p> 
<p>函数名最好能够表达函数内部封装的代码的功能，方便后续的获取调用[见名知意]</p> 
<pre><code>def 函数名():
	函数封装的代码
</code></pre> 
<h3>
<a id="_666"></a>模块和包</h3> 
<p>一个py文件就是一个模块</p> 
<p>一个包就是包含多个模块的特殊目录</p> 
<h3>
<a id="_672"></a>缺省函数、多值函数、匿名函数</h3> 
<p>缺省函数</p> 
<pre><code>def print_info(name, title="", gender="男生"):
    print(f"{title}{name} 是 {gender}")
# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！
print_info("小明")    #小明 是 男生
print_info("老王", title="班长")  #班长老王 是 男生
print_info("小美", gender="女生") #小美 是 女生
</code></pre> 
<p>多值函数</p> 
<pre><code>def demo(num, *args):
    print(num)
    print(args)
demo(1, 2, 3, 4, 5)    # 1换行 (2, 3, 4, 5)

def sum_numbers(*args):
    num = 0
# 遍历 args 元组求和
    for n in args:
        num += n
    return num
nums = (1, 2, 3)
result = sum_numbers(*nums)
print(f"result={result}")   #result=6
</code></pre> 
<p>匿名函数</p> 
<pre><code>user_list = [
{'name': '张三', 'age': 22, 'title': '测试工程师'},
{'name': '李四', 'age': 24, 'title': '开发工程师'},
{'name': '王五', 'age': 21, 'title': '测试工程师'}
]
# 按照age进行排序
user_list.sort(key=lambda m: m["age"])
print(user_list)
</code></pre> 
<h2>
<a id="_719"></a>基础一步一步实践开始</h2> 
<h3>
<a id="_721"></a>编码</h3> 
<p>ANSI 最开始 是美国 那边针对 英语26个单词 几乎采用是1个字节编码 这样范围是256</p> 
<p>之后 我们中国有中文 日本有日语 韩国有韩语 这样都出了对应的编码 可这太乱了</p> 
<p>于是 unicode 应运而生 采用2个字节编码 但这样对那些英文字母只需1个字节编码的来说 浪费了空间</p> 
<p>于是 utf-8 应运而生 采用可变编码UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节 对于英文被编码1个字节 中文通常3个字节 特别偏僻的一般4-6个字节</p> 
<p>内存中的编码都是unicode 最后存储的时候转化为utf-8存储</p> 
<p>编码 decode 主要是编成 unicode</p> 
<p>解码 encode 主要是解编成 utf-8</p> 
<h3>
<a id="_737"></a>格式化</h3> 
<p><strong>格式化的四种形式</strong></p> 
<pre><code>name = 'yinsheng'
print('欢迎 '+name+' 光临！')
# 多个参数
print('欢迎',name,'光临！')
# 占位符
print('欢迎 %s 光临！'%name)
# 格式化字符串
print(f'欢迎 {name} 光临！')
</code></pre> 
<h3>
<a id="_752"></a>迭代</h3> 
<p>for 循环 也称为 迭代</p> 
<h3>
<a id="_756"></a>列表生成式</h3> 
<p>[x*x for x in range(0,10)]</p> 
<p>其实 字典也可以 {x*x for x in range(0,10)}</p> 
<h3>
<a id="_762"></a>生成器</h3> 
<p>列表生成式 换成元组 其实就是 生成器了</p> 
<p>g=(x*x for x in range(0,10))</p> 
<p>然后通过 next(g) 或者for循环来 for x in g ：</p> 
<p>还可以弄成函数形式 其中 field就是一个标志</p> 
<h3>
<a id="_772"></a>迭代器</h3> 
<p>生成器的对象 一定是迭代器</p> 
<p>字典、集合 列表、元组 字符串 不是迭代器 但是可以通过iter()函数变成迭代器</p> 
<p>字典 集合 列表 元组 字符串 生成器 都是可迭代的</p> 
<h3>
<a id="__780"></a>返回值_闭包</h3> 
<p>闭包 就是 函数里面返回函数</p> 
<p>调用闭包 创建的函数哪怕一模一样 也不相等</p> 
<p>注意闭包函数 里面调用的变量 比如 i 这种有变化的 用函数封装 不要用 for 循环</p> 
<p>里面 引用外面的变量要赋值的话 注意nonlocal 声明变量</p> 
<h3>
<a id="_790"></a>访问限制</h3> 
<p>__开头的变量和函数 类外面调用不了</p> 
<p>_开头的变量和函数 类外面可以调用 但是不要调用 它已经代表私有的意思在里面了</p> 
<p>而要调用以及修改 则类要多加两个函数 get调用获取 和set 修改</p> 
<h3>
<a id="_798"></a>继承和多态</h3> 
<p>当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样： ---------&lt;廖雪峰&gt;</p> 
<p>继承(ocp原则 保持代码不变但是可扩展)</p> 
<p>多重继承(排在前面的方法会覆盖后面的方法) 比如</p> 
<pre><code>class A(B,C):
	pass
假如B和C中都有test方法  B中的test方法优先调用 相当于覆盖率C中的test方法
</code></pre> 
<h3>
<a id="_812"></a>私有属性和私有方法</h3> 
<p>当属性和方法只需要在类定义内部使用时，就可以使用私有属性和私有方法特点：在类定义外部，无论是通过类对象还是实例对象均无法获取私有属性和调用私有方法</p> 
<h3>
<a id="_816"></a>获取对象信息</h3> 
<p>dir 获取属性和方法</p> 
<p>getattr 获得属性名称的值 getattr(obj,属性名称)</p> 
<p>setattr 建立属性 setattr(obj,属性名称,值)</p> 
<p>hasattr 判断是否有属性 hasattr(obj,属性名名称)</p> 
<h3>
<a id="_826"></a>异常处理</h3> 
<p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">Built-in Exceptions — Python 3.10.5 documentation</a></p> 
<p>捕获异常 try: exception finally</p> 
<p>1捕获成功 打印出对应的提示信息</p> 
<p>2没有捕获成功 则一层一层抛出错误的信息 要学会定位到真正的地方 且接下来的不会执行 要想有错误信息且执行后面的语句 就要借助logging模块 logging.exception(错误信息)</p> 
<p>抛出异常</p> 
<p>1.捕获之后 也可以抛出异常</p> 
<p>2.抛出的异常和捕获的异常不一样 相当于转化了异常错误类型</p> 
<h3>
<a id="_844"></a>进制转换</h3> 
<p>二进制转十进制 用 int(a,2)</p> 
<p><strong>八进制 16进制转十进制</strong> 用int(a,8) int(a,16)</p> 
<p>十进制转二进制 bin(a)</p> 
<p>十进制转八进制 oct(a)</p> 
<p>十进制转16进制 hex(a)</p> 
<h3>
<a id="python_858"></a>python一些内在的原理图片</h3> 
<p><img src="https://images2.imgbox.com/c1/a4/4aRxdrY2_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/fd/1e/AjpfEUTK_o.png" alt=""></p> 
<h3>
<a id="_864"></a>正则表达式</h3> 
<p><a href="https://www.cnblogs.com/alanminmin/p/16256410.html">Python3 正则表达式特殊符号及用法（详细列表） - alanminmin - 博客园 (cnblogs.com)</a></p> 
<h2>
<a id="lesson__868"></a>lesson_尚硅谷</h2> 
<h3>
<a id="_870"></a>数值</h3> 
<p>Python数值分成了三种：整数、浮点数（小数）、复数</p> 
<p>Python中的整数的大小没有限制，可以是一个无限大的整数</p> 
<p>如果数字的长度过大，可以使用下划线作为分隔符</p> 
<p>python 二进制表现形式 0b 开头 八进制表现形式 0o开头 十进制表现形式 0x开头</p> 
<p>10进制的数字不能以0开头 其他进制的整数，只要是数字打印时一定是以十进制的形式显示的</p> 
<p>只要带<strong>小数</strong>对python来说都是<strong>浮点数</strong> 以及<strong>浮点数相加</strong>会得到一个不精确的结果</p> 
<h3>
<a id="_884"></a>字符串</h3> 
<p>单引号和双引号不能跨行使用</p> 
<p>三重引号可以跨行，并且会保留字符串中的格式</p> 
<pre><code>可以使用  作为转义字符，通过转义字符，可以在字符串中使用一些特殊的内容
' 表示'
" 表示"
t 表示制表符
n 表示换行符
\ 表示反斜杠
uxxxx 表示Unicode编码
</code></pre> 
<pre><code>b = 'hello %3.5s'%'abcdefg' # %3.5s字符串的长度限制在3-5之间
b = 'hello %s' % 123.456  #%s也可对应浮点数和整数
</code></pre> 
<p>字符串 + 是拼接 *是 复制 -和/不行</p> 
<h3>
<a id="_907"></a>布尔值和空值</h3> 
<pre><code>布尔值实际上也属于整型，True就相当于1，False就相当于0
</code></pre> 
<pre><code>None（空值）
# None专门用来表示不存在
</code></pre> 
<h3>
<a id="_918"></a>类型</h3> 
<p>整数 浮点数 字符串 None bool</p> 
<p>转换</p> 
<p>int(a) a不能是None 不能是非整数字符串如’yinsheng’ 不能是浮点数字符串如 ‘123.4’</p> 
<p>float(a) 和int差不多</p> 
<p>str(a) 啥都行</p> 
<p>bool(a) 啥都行 0和None转化成的false</p> 
<pre><code>ps
int()函数不会对原来的变量产生影响，他是对象转换为指定的类型并将其作为返回值返回
# 如果希望修改原来的变量，则需要对变量进行重新赋值
</code></pre> 
<h3>
<a id="_938"></a>运算符</h3> 
<p>1.算术运算符 + - * / //(整除) **(幂) %</p> 
<p>2.赋值运算符 += -= /= //= %= *= **=</p> 
<p>3.关系运算符 &gt; &gt;= &lt; &lt;= == is is not</p> 
<pre><code>关系运算符用来比较两个值之间的关系，总会返回一个布尔值
如果关系成立，返回True，否则返回False
result = 1 == True # True
result = 1 is True # False
result = 1 is not True # True
ps:
is 比较两个对象是否是同一个对象，比较的是对象的id
== 比较两个对象的值是否相等
</code></pre> 
<pre><code>result = 'ab' &gt; 'b' # False
result = '2' &gt; '11' # True
ps:
当对字符串进行比较时，实际上比较的是字符串的Unicode编码
比较两个字符串的Unicode编码时，是逐位比较的
且我发现 ord('A')  只能转个位字符串
</code></pre> 
<p>4.逻辑运算符</p> 
<p>and or not</p> 
<pre><code>and or  都是短路  比如and前面是false后面久不执行了  比如or前面是true后面就不执行了
非布尔值的与或运算  当我们对非布尔值进行与或运算时，Python会将其当做布尔值运算，最终会返回原值(主要看执行到哪一条语句  执行第一条就不执行了 则返回第一条语句的值)
not 对于非布尔值，运算会先将其转换为布尔值  然后进行运算
</code></pre> 
<p>5.条件运算符</p> 
<p>语句1 if 条件表达式 else 语句2</p> 
<pre><code>执行流程：
条件运算符在执行时，会先对条件表达式进行求值判断
如果判断结果为True，则执行语句1，并返回执行结果
如果判断结果为False，则执行语句2，并返回执行结果
</code></pre> 
<p>运算符优先级</p> 
<p>查表</p> 
<h3>
<a id="_991"></a>流程控制语句</h3> 
<p>input函数返回的是字符串类型</p> 
<p>if else</p> 
<p>if elif else</p> 
<p>while 条件表达式:</p> 
<p>​ 语句</p> 
<p>else:</p> 
<p>​ 语句</p> 
<h3>
<a id="__1007"></a>修改元素 针对的是可变序列</h3> 
<pre><code>stus = ['孙悟空','猪八戒','沙和尚','唐僧','蜘蛛精','白骨精']
stus[0:2] = ['牛魔王','红孩儿']
print(stus)  #['牛魔王','红孩儿','沙和尚','唐僧','蜘蛛精','白骨精']

stus[0:2] = ['牛魔王','红孩儿','二郎神']
print(stus) #['牛魔王','红孩儿','二郎神','沙和尚','唐僧','蜘蛛精','白骨精']

stus[0:0] = ['牛魔王'] 
print(stus)    #['牛魔王','牛魔王','红孩儿','二郎神','沙和尚','唐僧','蜘蛛精','白骨精']

stus[::2] = ['牛魔王','红孩儿','二郎神','加油']
print(stus) #['牛魔王','牛魔王','红孩儿','二郎神','二郎神','唐僧','加油','白骨精']

del stus[0:2]
print(stus)  #['红孩儿','二郎神','二郎神','唐僧','加油','白骨精']

del stus[::2]
print(stus)  #['二郎神','唐僧','白骨精']

stus[0] = '哈哈'
print(stus)    #['哈哈','唐僧','白骨精']

del stus[2] 
print(stus)    #['哈哈','唐僧']
</code></pre> 
<h3>
<a id="_1036"></a>函数参数</h3> 
<p>位置参数</p> 
<p>默认参数</p> 
<pre><code>def fn(a = 5 , b = 10 , c = 20):
    print('a =',a)
    print('b =',b)
    print('c =',c)
fn(1 , 2 , 3)  #1   2   3
fn(1 , 2)    #1  2  20
fn()    #5   10   20

</code></pre> 
<p>关键字参数 **</p> 
<p>**形参可以接收其他的关键字参数，它会将这些参数统一保存到一个字典中，字典的key就是参数的名字，字典的value就是参数的值</p> 
<p>**形参只能有一个，并且必须写在所有参数的最后</p> 
<pre><code>def fn3(b,c,**a) :
    print('a =',a,type(a))
    print('b =',b)
    print('c =',c)
fn3(1,2,k=5,w=6)
#a = {'k': 5, 'w': 6} &lt;class 'dict'&gt;
#b = 1
#c = 2
</code></pre> 
<p>可变参数 *</p> 
<p>可变参数不是必须写在最后，但是注意，带*的参数后的所有参数，必须以关键字参数的形式传递</p> 
<p>如果在形参的开头直接写一个*,则要求我们的所有的参数必须以关键字参数的形式传递</p> 
<p>*形参只能接收位置参数，而不能接收关键字参数</p> 
<pre><code>def fn2(*a,b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
fn2(1,b=2,c=3)

def fn2(a,*b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
fn2(1,2,c=3)

def fn3(*a) :
    print('a =',a)
fn3(1,2,3,4)
fn3(b=1)  #错误
</code></pre> 
<h3>
<a id="_1097"></a>高阶函数</h3> 
<p>高阶函数(</p> 
<p>1.参数是函数 体现为map filtter 等等</p> 
<p>2.返回值是函数 体现为闭包 闭包呢又可以导致出装饰器</p> 
<p>)</p> 
<p>zip 和 dict list 的结合</p> 
<p><img src="https://images2.imgbox.com/e0/f6/ZCCp05tG_o.png" alt=""></p> 
<h3>
<a id="_1113"></a>类方法和实例方法</h3> 
<pre><code>实例方法
在类中定义，以self为第一个参数的方法都是实例方法
实例方法在调用时，Python会将调用对象作为self传入 
实例方法可以通过实例和类去调用
当通过实例调用时，会自动将当前调用对象作为self传入
当通过类调用时，不会自动传递self，此时我们必须手动传递self
</code></pre> 
<pre><code>类方法    
在类内部使用 @classmethod 来修饰的方法属于类方法
类方法的第一个参数是cls，也会被自动传递，cls就是当前的类对象
类方法和实例方法的区别，实例方法的第一个参数是self，而类方法的第一个参数是cls
</code></pre> 
<p>实例方法当通过类调用时，不会自动传递self，此时我们必须手动传递self</p> 
<p>类方法可以通过类去调用，也可以通过实例调用，没有区别</p> 
<p>例子</p> 
<pre><code>class A(object):
	def test(self):
        print('这是test方法~~~ ' , self)
    @classmethod
    def test_2(cls):
        print('这是test_2方法，他是一个类方法~~~ ',cls)
        print(cls.count)
       
       
a = A()
a.test() 等价于 A.test(a)
A.test_2() 等价于 a.test_2()
</code></pre> 
<p>json是字典的字符串的格式，两种可以相互转换</p> 
<h3>
<a id="_1156"></a>内置函数</h3> 
<p>find count index isalpha、isdigit、isspace pow abs</p> 
<p><img src="https://images2.imgbox.com/3e/98/9SLFYrRL_o.png" alt=""></p> 
<p>字符串 find count （ps xx.find(‘寻找的字符串’,start,end) 返回找到的第一个下标位置 没有找到则返回-1）</p> 
<p>(ps xx.count(‘寻找的字符串’) 返回对应数量)</p> 
<p><img src="https://images2.imgbox.com/f8/20/8dB64bgg_o.png" alt=""></p> 
<p>join(ps ‘按啥分隔’.join(xx) xx 可以是字符串 列表 元组)</p> 
<pre><code>a = '123456'  #也可以是列表或元组
b = ' '.join(a)
print([b])  #['1 2 3 4 5 6']
print(type(b)) #&lt;class 'str'&gt;
</code></pre> 
<p>round()</p> 
<p><img src="https://images2.imgbox.com/59/f6/RcRzsal1_o.png" alt=""></p> 
<p>eval()</p> 
<pre><code># a = ' 3 * 7 '
# print(eval(a))  #21
</code></pre>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>