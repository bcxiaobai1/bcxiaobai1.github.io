<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Linux——设备树 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux——设备树</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81Linux%20%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E7%94%B1%E6%9D%A5-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81Linux%20%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E7%94%B1%E6%9D%A5">一、Linux 设备树的由来</a></p> 
<p id="%E4%BA%8C%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E7%9B%AE%E7%9A%84-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E7%9B%AE%E7%9A%84">二、Linux设备树的目的</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.%E5%B9%B3%E5%8F%B0%E8%AF%86%E5%88%AB-toc" style="margin-left:40px"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.%E5%B9%B3%E5%8F%B0%E8%AF%86%E5%88%AB">        1.平台识别</a></p> 
<p id="2.%E5%AE%9E%E6%97%B6%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px"><a href="#2.%E5%AE%9E%E6%97%B6%E9%85%8D%E7%BD%AE">2.实时配置</a></p> 
<p id="3.%E8%AE%BE%E5%A4%87%E6%A4%8D%E5%85%A5-toc" style="margin-left:40px"><a href="#3.%E8%AE%BE%E5%A4%87%E6%A4%8D%E5%85%A5">3.设备植入</a></p> 
<p id="%E4%B8%89%E3%80%81Linux%20%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81Linux%20%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E4%BD%BF%E7%94%A8">三、Linux 设备树的使用</a></p> 
<p id="1.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px"><a href="#1.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F">1.基本数据格式</a></p> 
<p id="2.%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px"><a href="#2.%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90">2.设备树实例解析</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%20%E9%A9%B1%E5%8A%A8-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%20%E9%A9%B1%E5%8A%A8">四、使用设备树的LED 驱动</a></p> 
<p id="%E4%BA%94%E3%80%81%E4%B9%A0%E9%A2%98-toc" style="margin-left:0px"><a href="#%E4%BA%94%E3%80%81%E4%B9%A0%E9%A2%98">五、习题</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h1 id="%E4%B8%80%E3%80%81Linux%20%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E7%94%B1%E6%9D%A5">
<br> 一、Linux 设备树的由来</h1> 
<p><br>         在 Linux 内核源码的ARM 体系结构引入设备树之前，相关的 BSP 代码中充斥了大量的平台设备(Platform Device) 代码，而这些代码大多都是重复的、杂乱的。之前的内核移植工作有很大一部分工作就是在复制一份 BSP 代码，并修改BSP 代码中和目标板中与特定硬件相关的平台设备信息。这使得ARM 体系结构的代码维护者和内核维护者在发布一个新版本内核的一段时间内有大量的工作要做。以至于 Linus Torvalds 在 2011年3月17日的ARM Linux 邮件列表中宣称“Gaah.Guys,this whole ARM thing is a f*cking pain in the ass”。这使得整个 ARM 社区不得不重新慎重地考虑这个问题，于是设备树(Device Tree，DT)被ARM 社区所采用。<br>         但需要说明的是，在 Linux 中，PowerPC 和SPARC体系结构很早就使用了设备树这并不是一个最近才提出的概念。设备树最初是由开放固件(Open Firmware)使用的，用来向一个客户程序(通常是一个操作系统)传递数据的通信方法中的一部分内容。在运行时，客户程序通过设备树发现设备的拓扑结构，这样就不需要把硬件信息硬编码到程序中。</p> 
<h1 id="%E4%BA%8C%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E7%9B%AE%E7%9A%84">
<br> 二、Linux设备树的目的</h1> 
<p><br>         设备树是一个描述硬件的数据结构，它并没有什么神奇的地方，也不能把所有硬件配置的问题都解决掉。它只是提供了一种语言，将硬件配置从 Linux 内核源码中提取出来。设备树使得目标板和设备变成数据驱动的，它们必须基于传递给内核的数据进行初始化，而不是像以前一样采用硬编码的方式。理论上，这种方式可以带来较少的代码重复率，使单个内核镜像能够支持很多硬件平台。<br>         Linux使用设备树有以下三个主要原因。</p> 
<h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.%E5%B9%B3%E5%8F%B0%E8%AF%86%E5%88%AB">
<br>         1.平台识别</h2> 
<p><br>         第一且最重要的是，内核使用设备树中的数据去识别特定机器 (目标板，在内核中称为 machine)。最完美的情况是，内核应该与特定硬件平台无关，因为所有硬件平台的细节都由设备树来描述。然而，硬件平台并不是完美的，所以内核必须在早期初始化阶段识别机器，这样内核才有机会运行与特定机器相关的初始化序列。<br>         在大多数情况下，机器识别是与设备树无关的，内核通过机器的 CPU或SOC 来选择初始化代码。以ARM 平台为例，setup_arch 会调用 setup_machine_fdt，后者遍历machine_desc 链表，选择最匹配设备树数据的 machine_desc 结构。这是通过查找设备树根节点的compatible 属性,并把它和 machine_desc 中的 dt_compat 列表中的各项进行比较来决定哪一个machine_desc 结构是最适合的。<br>         compatible 属性包含一个有序的字符串列表，它以确切的机器名开始，紧跟着一个可选的 board 列表，从最匹配到其他匹配类型。以Samsung 的 Exynos4x12 系列的SoC芯片为例，在arch/arm/mach-exynos/mach-exynos4-dt.c 文件中的dt_compat 列表定义如下。<br>  </p> 
<pre><code class="language-cpp">static char const *exynos4_dt_compat[] _initdata = {
    "samsung,exynos4210"
    "samsung,exynos4212"
    "samsung,exynos4412",
    NULl
};</code></pre> 
<p>        而在 origen 目标板的设备树源文件 arch/arm/boot/dts/exynos4412-origen.dts 中包含的exynos4412.dtsi文件中指定的 compatible 属性如下。</p> 
<pre><code class="language-cpp">compatible = "samsung,exynos4412";</code></pre> 
<p><br>         这样在内核启动过程中就可以通过传递的设备树数据找到匹配的机器所对应的machine_desc 结构,如果没找到则返回 NULL。采用这种方式,可以使用一个 machine_desc支持多个机器，从而降低了代码的重复率。当然，对初始化有特殊要求的机器的初始化过程应该有所区别，这可以通过其他的属性或一些钩子函数来解决。</p> 
<h2 id="2.%E5%AE%9E%E6%97%B6%E9%85%8D%E7%BD%AE">
<br> 2.实时配置</h2> 
<p><br>         在大多数情况下，设备树是固件与内核之间进行数据通信的唯一方式，所以也用于传递实时或配置数据给内核，比如内核参数、initrd 镜像的地址等。大多数这种数据被包含在设备树的/chosen节点，形如:</p> 
<pre><code class="language-cpp">chosen { bootargs = "console=ttys0,115200 1oglevel=8";
    initrd-start  = &lt;0xc8000000&gt;;
    initrd-end    = &lt;0xc8200000&gt;;
};</code></pre> 
<p><br>         bootargs 属性包含内核参数，initrd-*属性定义了 initrd 文件的首地址和大小。chosen<br> 节点也有可能包含任意数量的描述平台特殊配置的属性。</p> 
<p>        在早期的初始化阶段，页表建立之前，与体系结构初始化相关的代码会多次联合使用不同的辅助回调函数去调用 of_scan_flat_dt 来解设备数据。of_scan_flat_dt 遍历设备树并利用辅助函数来提取需要的信息。通常，early_init_dt_scan_chosen 辅助函数用于解析包括内核参数的 chosen 节点:early_init_dt_scan_root 辅助函数用于初始化设备树的地址空间模型; early_init_dt_scan_memory 辅助函数用于决定可用内存的大小和地址。</p> 
<p>        在ARM平台,setup_machine_fdt函数负责在选取到正确的machine_desc 结构之后进行早期的设备树遍历。</p> 
<h2 id="3.%E8%AE%BE%E5%A4%87%E6%A4%8D%E5%85%A5">
<br> 3.设备植入</h2> 
<p></p> 
<p>        经过板子识别和早期配置数据解析之后，内核进一步进行初始化。期间unflatten_device_tree 函数被调用，将设备树的数据转换成一种更有效的实时形式。同时机器特殊的启动钩子函数也会被调用，例如machine_desc 中的init_early函数、init_irq函数、init_machine函数等。通过名称我们可以猜想到，init_early函数会在早期初始化时被执行，init_irg 函数用于初始化中断处理。利用设备树并没有改变这些函数的行为和功能。如果设备树被提供那么不管是init_early 函数还是init_irg函数都可以调用任何设备树查找函数去获取额外的平台信息。不过 init_machine 函数却需要更多地关注，在 arch/armmach-exynos/mach-exynos4-dtc 文件中init machine函数有如下一条语句:<br>  </p> 
<pre><code class="language-cpp">of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);</code></pre> 
<p>        of_platform_populate 函数的作用是遍历设备树中的节点，把匹配的节点转换成平台设备，然后注册到内核中。</p> 
<h1 id="%E4%B8%89%E3%80%81Linux%20%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E4%BD%BF%E7%94%A8">
<br> 三、Linux 设备树的使用</h1> 
<h2 id="1.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F">1.基本数据格式</h2> 
<p>        在 Linux 中，设备树文件的类型有,dts、.dtsi和dtb。其中，dtsi 是被包含的设备树源文件，类似于 C 语言中的头文件;.dts 是设备树源文件，可以包含其他.dtsi 文件，由dtc编译生成.dtb 文件。<br>         设备树是一个包含节点和属性的简单树状结构。属性就是键值对，而节点可以同时包含属性和子节点。下面就是一个.dts 格式的简单设备树:</p> 
<pre><code class="language-cpp">/ {
    node1 {
        a-string-property      = "A string";
        a-string-list-property = "first string"，"second string"；
        a-byte-data-property   = [0x01 0x23 0x34 0x56];
        child-nodel {
            first-child-property;
            second-child-property = &lt;1&gt;;
            a-string-property     = "Hello，world";
            };
            child-node2 {
            };
};
    node2 {
        an-empty-property;
        a-cell-property = &lt;1&gt;;/* each number (cell) is uint32 */
        child-node1 {
        };
    };
};</code></pre> 
<p><br> 该设备树包含了下面的内容</p> 
<ul>
<li>一个单独的根节点:/。</li>
<li>两个子节点:node1和node2。</li>
<li>两个nodel的子节点:child-node 和child-node2</li>
<li>一堆分散在设备树中的属性。</li>
</ul> 
<p>        其中，属性是简单的键值对，它的值可以为空或包含一个任意字节流。在设备树源文件中有以下几个基本的数据表示形式。</p> 
<ul>
<li>文本字符串(无结束符):可以用双引号表示，如a-string-property="A string"</li>
<li>cells:32位无符号整数，用角括号限定，如 second-child-property =&lt;l&gt;。</li>
<li>二进制数据:用方括号限定，如a-byte-data-property =[0x010x230x340x56]。</li>
<li>混合表示:使用逗号连在一起，如mixed-property ="astring”,[0x010x230x450x67]，</li>
</ul> 
<p>&lt;0x12345678&gt;。</p> 
<ul><li>字符串列表:使用逗号连在一起，如string-list="red fish","blue fish"。</li></ul> 
<h2 id="2.%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90">2.设备树实例解析</h2> 
<p><br>         下面是从arch/arm/boot/dts/exynos4.dtsi设备树源文件中抽取出来的内容:</p> 
<pre><code class="language-cpp">/*
 * Samsung's Exynos4 SoC series common device tree source
 *
 * Copyright (c) 2010-2011 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 * Copyright (c) 2010-2011 Linaro Ltd.
 *		www.linaro.org
 *
 * Samsung's Exynos4 SoC series device nodes are listed in this file.  Particular
 * SoCs from Exynos4 series can include this file and provide values for SoCs
 * specfic bindings.
 *
 * Note: This file does not include device nodes for all the controllers in
 * Exynos4 SoCs. As device tree coverage for Exynos4 increases, additional
 * nodes can be added to this file.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "skeleton.dtsi"

/ {
	interrupt-parent = &lt;&amp;gic&gt;;

	aliases {
		spi0 = &amp;spi_0;
		spi1 = &amp;spi_1;
		spi2 = &amp;spi_2;
		i2c0 = &amp;i2c_0;
		i2c1 = &amp;i2c_1;
		i2c2 = &amp;i2c_2;
		i2c3 = &amp;i2c_3;
		i2c4 = &amp;i2c_4;
		i2c5 = &amp;i2c_5;
		i2c6 = &amp;i2c_6;
		i2c7 = &amp;i2c_7;
		csis0 = &amp;csis_0;
		csis1 = &amp;csis_1;
		fimc0 = &amp;fimc_0;
		fimc1 = &amp;fimc_1;
		fimc2 = &amp;fimc_2;
		fimc3 = &amp;fimc_3;
	};

	chipid@10000000 {
		compatible = "samsung,exynos4210-chipid";
		reg = &lt;0x10000000 0x100&gt;;
	};

	mipi_phy: video-phy@10020710 {
		compatible = "samsung,s5pv210-mipi-video-phy";
		reg = &lt;0x10020710 8&gt;;
		#phy-cells = &lt;1&gt;;
	};

	pd_mfc: mfc-power-domain@10023C40 {
		compatible = "samsung,exynos4210-pd";
		reg = &lt;0x10023C40 0x20&gt;;
	};

	pd_g3d: g3d-power-domain@10023C60 {
		compatible = "samsung,exynos4210-pd";
		reg = &lt;0x10023C60 0x20&gt;;
	};

	pd_lcd0: lcd0-power-domain@10023C80 {
		compatible = "samsung,exynos4210-pd";
		reg = &lt;0x10023C80 0x20&gt;;
	};

	pd_tv: tv-power-domain@10023C20 {
		compatible = "samsung,exynos4210-pd";
		reg = &lt;0x10023C20 0x20&gt;;
	};

	pd_cam: cam-power-domain@10023C00 {
		compatible = "samsung,exynos4210-pd";
		reg = &lt;0x10023C00 0x20&gt;;
	};

	pd_gps: gps-power-domain@10023CE0 {
		compatible = "samsung,exynos4210-pd";
		reg = &lt;0x10023CE0 0x20&gt;;
	};

	gic: interrupt-controller@10490000 {
		compatible = "arm,cortex-a9-gic";
		#interrupt-cells = &lt;3&gt;;
		interrupt-controller;
		reg = &lt;0x10490000 0x1000&gt;, &lt;0x10480000 0x100&gt;;
	};

	combiner: interrupt-controller@10440000 {
		compatible = "samsung,exynos4210-combiner";
		#interrupt-cells = &lt;2&gt;;
		interrupt-controller;
		reg = &lt;0x10440000 0x1000&gt;;
	};

	sys_reg: syscon@10010000 {
		compatible = "samsung,exynos4-sysreg", "syscon";
		reg = &lt;0x10010000 0x400&gt;;
	};

	camera {
		compatible = "samsung,fimc", "simple-bus";
		status = "disabled";
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;1&gt;;
		ranges;

		clock_cam: clock-controller {
			 #clock-cells = &lt;1&gt;;
		};

		fimc_0: fimc@11800000 {
			compatible = "samsung,exynos4210-fimc";
			reg = &lt;0x11800000 0x1000&gt;;
			interrupts = &lt;0 84 0&gt;;
			clocks = &lt;&amp;clock 256&gt;, &lt;&amp;clock 128&gt;;
			clock-names = "fimc", "sclk_fimc";
			samsung,power-domain = &lt;&amp;pd_cam&gt;;
			samsung,sysreg = &lt;&amp;sys_reg&gt;;
			status = "disabled";
		};

		fimc_1: fimc@11810000 {
			compatible = "samsung,exynos4210-fimc";
			reg = &lt;0x11810000 0x1000&gt;;
			interrupts = &lt;0 85 0&gt;;
			clocks = &lt;&amp;clock 257&gt;, &lt;&amp;clock 129&gt;;
			clock-names = "fimc", "sclk_fimc";
			samsung,power-domain = &lt;&amp;pd_cam&gt;;
			samsung,sysreg = &lt;&amp;sys_reg&gt;;
			status = "disabled";
		};

		fimc_2: fimc@11820000 {
			compatible = "samsung,exynos4210-fimc";
			reg = &lt;0x11820000 0x1000&gt;;
			interrupts = &lt;0 86 0&gt;;
			clocks = &lt;&amp;clock 258&gt;, &lt;&amp;clock 130&gt;;
			clock-names = "fimc", "sclk_fimc";
			samsung,power-domain = &lt;&amp;pd_cam&gt;;
			samsung,sysreg = &lt;&amp;sys_reg&gt;;
			status = "disabled";
		};

		fimc_3: fimc@11830000 {
			compatible = "samsung,exynos4210-fimc";
			reg = &lt;0x11830000 0x1000&gt;;
			interrupts = &lt;0 87 0&gt;;
			clocks = &lt;&amp;clock 259&gt;, &lt;&amp;clock 131&gt;;
			clock-names = "fimc", "sclk_fimc";
			samsung,power-domain = &lt;&amp;pd_cam&gt;;
			samsung,sysreg = &lt;&amp;sys_reg&gt;;
			status = "disabled";
		};

		csis_0: csis@11880000 {
			compatible = "samsung,exynos4210-csis";
			reg = &lt;0x11880000 0x4000&gt;;
			interrupts = &lt;0 78 0&gt;;
			clocks = &lt;&amp;clock 260&gt;, &lt;&amp;clock 134&gt;;
			clock-names = "csis", "sclk_csis";
			bus-width = &lt;4&gt;;
			samsung,power-domain = &lt;&amp;pd_cam&gt;;
			phys = &lt;&amp;mipi_phy 0&gt;;
			phy-names = "csis";
			status = "disabled";
			#address-cells = &lt;1&gt;;
			#size-cells = &lt;0&gt;;
		};

		csis_1: csis@11890000 {
			compatible = "samsung,exynos4210-csis";
			reg = &lt;0x11890000 0x4000&gt;;
			interrupts = &lt;0 80 0&gt;;
			clocks = &lt;&amp;clock 261&gt;, &lt;&amp;clock 135&gt;;
			clock-names = "csis", "sclk_csis";
			bus-width = &lt;2&gt;;
			samsung,power-domain = &lt;&amp;pd_cam&gt;;
			phys = &lt;&amp;mipi_phy 2&gt;;
			phy-names = "csis";
			status = "disabled";
			#address-cells = &lt;1&gt;;
			#size-cells = &lt;0&gt;;
		};
	};

	watchdog@10060000 {
		compatible = "samsung,s3c2410-wdt";
		reg = &lt;0x10060000 0x100&gt;;
		interrupts = &lt;0 43 0&gt;;
		clocks = &lt;&amp;clock 345&gt;;
		clock-names = "watchdog";
		status = "disabled";
	};

	rtc@10070000 {
		compatible = "samsung,s3c6410-rtc";
		reg = &lt;0x10070000 0x100&gt;;
		interrupts = &lt;0 44 0&gt;, &lt;0 45 0&gt;;
		clocks = &lt;&amp;clock 346&gt;;
		clock-names = "rtc";
		status = "disabled";
	};

	keypad@100A0000 {
		compatible = "samsung,s5pv210-keypad";
		reg = &lt;0x100A0000 0x100&gt;;
		interrupts = &lt;0 109 0&gt;;
		clocks = &lt;&amp;clock 347&gt;;
		clock-names = "keypad";
		status = "disabled";
	};

	sdhci@12510000 {
		compatible = "samsung,exynos4210-sdhci";
		reg = &lt;0x12510000 0x100&gt;;
		interrupts = &lt;0 73 0&gt;;
		clocks = &lt;&amp;clock 297&gt;, &lt;&amp;clock 145&gt;;
		clock-names = "hsmmc", "mmc_busclk.2";
		status = "disabled";
	};

	sdhci@12520000 {
		compatible = "samsung,exynos4210-sdhci";
		reg = &lt;0x12520000 0x100&gt;;
		interrupts = &lt;0 74 0&gt;;
		clocks = &lt;&amp;clock 298&gt;, &lt;&amp;clock 146&gt;;
		clock-names = "hsmmc", "mmc_busclk.2";
		status = "disabled";
	};

	sdhci@12530000 {
		compatible = "samsung,exynos4210-sdhci";
		reg = &lt;0x12530000 0x100&gt;;
		interrupts = &lt;0 75 0&gt;;
		clocks = &lt;&amp;clock 299&gt;, &lt;&amp;clock 147&gt;;
		clock-names = "hsmmc", "mmc_busclk.2";
		status = "disabled";
	};

	sdhci@12540000 {
		compatible = "samsung,exynos4210-sdhci";
		reg = &lt;0x12540000 0x100&gt;;
		interrupts = &lt;0 76 0&gt;;
		clocks = &lt;&amp;clock 300&gt;, &lt;&amp;clock 148&gt;;
		clock-names = "hsmmc", "mmc_busclk.2";
		status = "disabled";
	};

	ehci@12580000 {
		compatible = "samsung,exynos4210-ehci";
		reg = &lt;0x12580000 0x100&gt;;
		interrupts = &lt;0 70 0&gt;;
		clocks = &lt;&amp;clock 304&gt;;
		clock-names = "usbhost";
		status = "disabled";
	};

	ohci@12590000 {
		compatible = "samsung,exynos4210-ohci";
		reg = &lt;0x12590000 0x100&gt;;
		interrupts = &lt;0 70 0&gt;;
		clocks = &lt;&amp;clock 304&gt;;
		clock-names = "usbhost";
		status = "disabled";
	};

	mfc: codec@13400000 {
		compatible = "samsung,mfc-v5";
		reg = &lt;0x13400000 0x10000&gt;;
		interrupts = &lt;0 94 0&gt;;
		samsung,power-domain = &lt;&amp;pd_mfc&gt;;
		clocks = &lt;&amp;clock 273&gt;;
		clock-names = "mfc";
		status = "disabled";
	};

	serial@13800000 {
		compatible = "samsung,exynos4210-uart";
		reg = &lt;0x13800000 0x100&gt;;
		interrupts = &lt;0 52 0&gt;;
		clocks = &lt;&amp;clock 312&gt;, &lt;&amp;clock 151&gt;;
		clock-names = "uart", "clk_uart_baud0";
		status = "disabled";
	};

	serial@13810000 {
		compatible = "samsung,exynos4210-uart";
		reg = &lt;0x13810000 0x100&gt;;
		interrupts = &lt;0 53 0&gt;;
		clocks = &lt;&amp;clock 313&gt;, &lt;&amp;clock 152&gt;;
		clock-names = "uart", "clk_uart_baud0";
		status = "disabled";
	};

	serial@13820000 {
		compatible = "samsung,exynos4210-uart";
		reg = &lt;0x13820000 0x100&gt;;
		interrupts = &lt;0 54 0&gt;;
		clocks = &lt;&amp;clock 314&gt;, &lt;&amp;clock 153&gt;;
		clock-names = "uart", "clk_uart_baud0";
		status = "disabled";
	};

	serial@13830000 {
		compatible = "samsung,exynos4210-uart";
		reg = &lt;0x13830000 0x100&gt;;
		interrupts = &lt;0 55 0&gt;;
		clocks = &lt;&amp;clock 315&gt;, &lt;&amp;clock 154&gt;;
		clock-names = "uart", "clk_uart_baud0";
		status = "disabled";
	};

	i2c_0: i2c@13860000 {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		compatible = "samsung,s3c2440-i2c";
		reg = &lt;0x13860000 0x100&gt;;
		interrupts = &lt;0 58 0&gt;;
		clocks = &lt;&amp;clock 317&gt;;
		clock-names = "i2c";
		pinctrl-names = "default";
		pinctrl-0 = &lt;&amp;i2c0_bus&gt;;
		status = "disabled";
	};

	i2c_1: i2c@13870000 {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		compatible = "samsung,s3c2440-i2c";
		reg = &lt;0x13870000 0x100&gt;;
		interrupts = &lt;0 59 0&gt;;
		clocks = &lt;&amp;clock 318&gt;;
		clock-names = "i2c";
		pinctrl-names = "default";
		pinctrl-0 = &lt;&amp;i2c1_bus&gt;;
		status = "disabled";
	};

	i2c_2: i2c@13880000 {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		compatible = "samsung,s3c2440-i2c";
		reg = &lt;0x13880000 0x100&gt;;
		interrupts = &lt;0 60 0&gt;;
		clocks = &lt;&amp;clock 319&gt;;
		clock-names = "i2c";
		status = "disabled";
	};

	i2c_3: i2c@13890000 {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		compatible = "samsung,s3c2440-i2c";
		reg = &lt;0x13890000 0x100&gt;;
		interrupts = &lt;0 61 0&gt;;
		clocks = &lt;&amp;clock 320&gt;;
		clock-names = "i2c";
		status = "disabled";
	};

	i2c_4: i2c@138A0000 {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		compatible = "samsung,s3c2440-i2c";
		reg = &lt;0x138A0000 0x100&gt;;
		interrupts = &lt;0 62 0&gt;;
		clocks = &lt;&amp;clock 321&gt;;
		clock-names = "i2c";
		status = "disabled";
	};

	i2c_5: i2c@138B0000 {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		compatible = "samsung,s3c2440-i2c";
		reg = &lt;0x138B0000 0x100&gt;;
		interrupts = &lt;0 63 0&gt;;
		clocks = &lt;&amp;clock 322&gt;;
		clock-names = "i2c";
		status = "disabled";
	};

	i2c_6: i2c@138C0000 {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		compatible = "samsung,s3c2440-i2c";
		reg = &lt;0x138C0000 0x100&gt;;
		interrupts = &lt;0 64 0&gt;;
		clocks = &lt;&amp;clock 323&gt;;
		clock-names = "i2c";
		status = "disabled";
	};

	i2c_7: i2c@138D0000 {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		compatible = "samsung,s3c2440-i2c";
		reg = &lt;0x138D0000 0x100&gt;;
		interrupts = &lt;0 65 0&gt;;
		clocks = &lt;&amp;clock 324&gt;;
		clock-names = "i2c";
		status = "disabled";
	};

	spi_0: spi@13920000 {
		compatible = "samsung,exynos4210-spi";
		reg = &lt;0x13920000 0x100&gt;;
		interrupts = &lt;0 66 0&gt;;
		dmas = &lt;&amp;pdma0 7&gt;, &lt;&amp;pdma0 6&gt;;
		dma-names = "tx", "rx";
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		clocks = &lt;&amp;clock 327&gt;, &lt;&amp;clock 159&gt;;
		clock-names = "spi", "spi_busclk0";
		pinctrl-names = "default";
		pinctrl-0 = &lt;&amp;spi0_bus&gt;;
		status = "disabled";
	};

	spi_1: spi@13930000 {
		compatible = "samsung,exynos4210-spi";
		reg = &lt;0x13930000 0x100&gt;;
		interrupts = &lt;0 67 0&gt;;
		dmas = &lt;&amp;pdma1 7&gt;, &lt;&amp;pdma1 6&gt;;
		dma-names = "tx", "rx";
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		clocks = &lt;&amp;clock 328&gt;, &lt;&amp;clock 160&gt;;
		clock-names = "spi", "spi_busclk0";
		pinctrl-names = "default";
		pinctrl-0 = &lt;&amp;spi1_bus&gt;;
		status = "disabled";
	};

	spi_2: spi@13940000 {
		compatible = "samsung,exynos4210-spi";
		reg = &lt;0x13940000 0x100&gt;;
		interrupts = &lt;0 68 0&gt;;
		dmas = &lt;&amp;pdma0 9&gt;, &lt;&amp;pdma0 8&gt;;
		dma-names = "tx", "rx";
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		clocks = &lt;&amp;clock 329&gt;, &lt;&amp;clock 161&gt;;
		clock-names = "spi", "spi_busclk0";
		pinctrl-names = "default";
		pinctrl-0 = &lt;&amp;spi2_bus&gt;;
		status = "disabled";
	};

	pwm@139D0000 {
		compatible = "samsung,exynos4210-pwm";
		reg = &lt;0x139D0000 0x1000&gt;;
		interrupts = &lt;0 37 0&gt;, &lt;0 38 0&gt;, &lt;0 39 0&gt;, &lt;0 40 0&gt;, &lt;0 41 0&gt;;
		clocks = &lt;&amp;clock 336&gt;;
		clock-names = "timers";
		#pwm-cells = &lt;2&gt;;
		status = "disabled";
	};

	amba {
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;1&gt;;
		compatible = "arm,amba-bus";
		interrupt-parent = &lt;&amp;gic&gt;;
		ranges;

		pdma0: pdma@12680000 {
			compatible = "arm,pl330", "arm,primecell";
			reg = &lt;0x12680000 0x1000&gt;;
			interrupts = &lt;0 35 0&gt;;
			clocks = &lt;&amp;clock 292&gt;;
			clock-names = "apb_pclk";
			#dma-cells = &lt;1&gt;;
			#dma-channels = &lt;8&gt;;
			#dma-requests = &lt;32&gt;;
		};

		pdma1: pdma@12690000 {
			compatible = "arm,pl330", "arm,primecell";
			reg = &lt;0x12690000 0x1000&gt;;
			interrupts = &lt;0 36 0&gt;;
			clocks = &lt;&amp;clock 293&gt;;
			clock-names = "apb_pclk";
			#dma-cells = &lt;1&gt;;
			#dma-channels = &lt;8&gt;;
			#dma-requests = &lt;32&gt;;
		};

		mdma1: mdma@12850000 {
			compatible = "arm,pl330", "arm,primecell";
			reg = &lt;0x12850000 0x1000&gt;;
			interrupts = &lt;0 34 0&gt;;
			clocks = &lt;&amp;clock 279&gt;;
			clock-names = "apb_pclk";
			#dma-cells = &lt;1&gt;;
			#dma-channels = &lt;8&gt;;
			#dma-requests = &lt;1&gt;;
		};
	};

	fimd: fimd@11c00000 {
		compatible = "samsung,exynos4210-fimd";
		interrupt-parent = &lt;&amp;combiner&gt;;
		reg = &lt;0x11c00000 0x20000&gt;;
		interrupt-names = "fifo", "vsync", "lcd_sys";
		interrupts = &lt;11 0&gt;, &lt;11 1&gt;, &lt;11 2&gt;;
		clocks = &lt;&amp;clock 140&gt;, &lt;&amp;clock 283&gt;;
		clock-names = "sclk_fimd", "fimd";
		samsung,power-domain = &lt;&amp;pd_lcd0&gt;;
		status = "disabled";
	};
};
</code></pre> 
<p><br>         (1)包含其他的“.dtsi”文件，如:        </p> 
<pre><code class="language-cpp">#include "skeleton.dtsi"。</code></pre> 
<p><br>         (2)节点名称，是一个“&lt;名称&gt;[@&lt;设备地址&gt;]”形式的名字。方括号中的内容不是必需的。“名称”是一个不超过 31 位的简单 ascii 字符串，应该根据它所体现的设备来进行命名。如果该节点描述的设备有一个地址就应该加上单元地址，通常，设备地址就是用来访问该设备的主地址，并且该地址也在节点的reg 属性中列出。关于 reg 属性将会在后面描述。同级节点命名必须是唯一的，但只要地址不同，多个节点也可以使用一样的通用名称。节点名称的例子如下:</p> 
<pre><code class="language-cpp">serial@13800000
serial@13810000</code></pre> 
<p><br>         (3)系统中每个设备都表示为一个设备树节点，每个设备树节点都拥有一个compatible 属性。<br>         (4)compatible 属性是操作系统用来决定使用哪个设备驱动来绑定到一个设备上的关键因素。compatible 是一个字符串列表，第一个字符串指定了这个节点所表示的确切的设备，该字符串的格式为:"&lt;制造商&gt;,&lt;型号&gt;"，其余的字符串则表示其他与之兼容的设备</p> 
<p>例如:</p> 
<pre><code class="language-cpp">compatible = "arm,p1330"，"arm,primecell";</code></pre> 
<p><br>         (5)可编址设备使用以下属性将地址信息编码进设备树:</p> 
<pre><code class="language-cpp">reg
#address-cells
#size-cells</code></pre> 
<p><br>         每个可编址设备都有一个reg，它是一个元组表，形式为:reg =&lt;地址1 长度1[地址 2长度 2][地址3 长度3]...&gt;。每个元组都表示该设备使用的一个地址范围。每个地址值是一个或多个 32 位整型数列表，称为 cell。同样，长度值也可以是一个 cell 列表或者为空。由于地址和长度字段都是可变大小的变量，那么父节点的 #address-cells 和#size-cells 属性就用来声明各个字段的 cell 的数量。换话说，正确解释一个 reg 属性需要用到父节点的#address-cells 和#size-cells 的值。如在 arch/arm/boot/dts/exynos4412-origen.dts 文件中I2C 设备的相应描述:</p> 
<pre><code class="language-cpp">        12c@13860000 {
            #address-cells = &lt;1&gt;;
            #size-cells=&lt;0&gt;;
            samsung,12c-sda-delay = &lt;100&gt;;
            samsung,12c-max-bus-freq=&lt;20000&gt;;
            pinctr1-0 = &lt;&amp;i2c0_bus&gt;;
            pinctrl-names = "default";
            status = "okay";

            s5m8767_pmic@66 {
                compatible = "samsung,s5m8767-pmic";
                reg=&lt;0x66&gt;;
......</code></pre> 
<p><br>         其中，I2C 主机控制器是一个父节点，地址的长度为一个 32 位整型数，地址长度为0。s5m8767_pmic是12C 主机控制器下面的一个子节点，其地址为0x66。按照惯例，如果一个节点有 reg 属性，那么该节点的名字就必须包含设备地址，这个设备地址就是 reg属性里第一个地址值。<br>         关于设备地址还要讨论下面三个方面的内容:</p> 
<ol><li>内存映射设备。</li></ol> 
<p>        内存映射的设备应该有地址范围，对于32位的地址可以用1个 cell来指定地址值用一个 cell来指定范围。而对于64 位的地址就应该用两个 cell来指定地址值。还有一种内存映射设备的地址表示方式，就是基地址、偏移和长度。在这种方式中，地址也是用两个cell来表示。</p> 
<p>        2.非内存映射设备。</p> 
<p>        有些设备没有被映射到 CPU 的存储器总线上，虽然这些设备可以有一个地址范围,但它们并不是由CPU直接访问。取而代之的是，父设备的驱动程序会代表 CPU 执行间接访问。这类设备的典型例子就包括上面提到的I2C 设备，NAND Flash 也属于这类设备<br>         3.范围(地址转换)。</p> 
<p>        根节点的地址空间是从CPU 的视角进行描述的，根节点的直接子节点使用的也是这个地址域，如 chipid@10000000。但是非根节点的直接子节点就没有使用这个地址域，于是需要把这个地址进行转换，ranges 这个属性就用于此目的。如在 arch/arm/boot/dts/hi3620.dtsi文件中有下面一段描述。</p> 
<p><br>  </p> 
<pre><code class="language-cpp">        sysctrl: system-controller@802000 {
            compatible = "hisilicon,sysctrl";
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;1&gt;;
            ranges = &lt;0 0x802000 0x1000&gt;;
            reg = &lt;0x802000 0x1000&gt;;
            smp-offset = &lt;0x31c&gt;;
            resume-offset = &lt;0x308&gt;;
            reboot-offset = &lt;0x4&gt;;

            clock:clock@0 {
                compatible = "hisilicon,hi3620-clock";
                reg = &lt;0 0x10000&gt;;
                #clock-cells = &lt;1&gt;;
        };
};</code></pre> 
<p><br>         "sysctrl: system-controller@802000”这个节点是“clock: clock@0”的父节点，在父节点中定义了一个地址范围，这个地址范围由“&lt;子地址 父地址 子地址空间区域大小&gt;”这样一个元组来描述。所以“&lt;0 0x802000 0x1000&gt;”表示的是子地址0 被映射在父地址的0x802000-0x802FFF 处。而“clock: clok@0”这个子节点刚好使用了这个地址。有些时候，这种映射也是一对一的，即子节点使用和父节点一样的地址域，这可以通过-个空的ranges 属性来实现。如:</p> 
<pre><code class="language-cpp">amba {
    #address-cells = &lt;1&gt;;
    #size-cells= &lt;1&gt;;
    compatible="arm,amba-bus";
    interrupt-parent = &lt;&amp;gic&gt;;
    ranges;

    pdma0:pdma@12680000 {
    compatible = "arm,pl330"，"arm,primecell";
    reg = &lt;0x12680000 0x1000&gt;;
    interrupts = &lt;0 35 0&gt;;
    clocks=&lt;&amp;clock 292&gt;;
    clock-names = "apb_pclk";
    #dma-cells = &lt;1&gt;;
    #dma-channels = &lt;8&gt;;
    #dma-requests = &lt;32&gt;;
};</code></pre> 
<p><br> “pdma0: pdma@12680000”子节点使用的就是和“amba”父节点一样的地址域</p> 
<p>        (6)描述中断连接需要四个属性。<br>         interrupt-controller:一个空的属性，用来定义该节点是一个接收中断的设备，即是个中断控制器。<br>         #interrupt-cells:一个中断控制器节点的属性，声明了该中断控制器的中断指示符中cell 的个数，类似于#address-cells。<br>         interrupt-parent:一个设备节点的属性，指向设备所连接的中断控制器。如果这个设备节点没有该属性，那么这个节点继承父节点的这个属性。<br>         interrupts:一个设备节点的属性，含一个中断指示符的列表，对应于该设备上的每个中断输出信号</p> 
<pre><code class="language-cpp">gic:interrupt-controller@10490000 { 
    compatible = "arm,cortex-a9-gic"
    #interrupt-cells = &lt;3&gt;;
    interrupt-controller;
    reg=&lt;0x104900000x1000&gt;，&lt;0x1080000 0x100&gt;;
};</code></pre> 
<p><br>         上面的节点表示一个中断控制器，用于接收中断。中断指示符占3个 cell.</p> 
<pre><code class="language-cpp">amba {
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    compatible = "arm,amba-bus";
    interrupt-parent = &lt;&amp;gic&gt;;
    ranges;

    pdma0: pdma@12680000{
        compatible = "arm,p1330”，"arm,primecell";
        reg = &lt;0x12680000 0x1000&gt;;
        interrupts = &lt;0 35 0&gt;;
        clocks = &lt;&amp;clock 292&gt;;
        clock-names = "apb_pclk";
        #dma-cells=&lt;1&gt;;
        #dma-channels = &lt;8&gt;;
        #dma-requests = &lt;32&gt;;
};</code></pre> 
<p><br>         “amba”节点是一个中断设备，产生的中断连接到“gic”中断控制器，“pdma0:pdma@12680000”是一个“amba”的子节点，继承了父节点的 interrupt-parent 属性，即该设备产生的中断也连接在“gic”中断控制器上。中断指示符占 3 个 cell,“pdma0:pdma@12680000”节点的中断指示符是“&lt;0 35 0&gt;”，其意义是查看内核中的相应文档。因为GIC 是ARM公司开发的一款中断控制器，查看 Documentation/devicetree/bindingsarm/gic.txt 内核文档可知，第一个 cell 是中断类型，0是 SPI，共享的外设中断，即这个中断由外设产生，可以连接到一个 SoC 中的多个ARM核;1是PPI，私有的外设中断即这个中断由外设产生，但只能连接到一个 SoC 中的特定ARM 核。第二个 cell 是中断号。第三个 cell 是中断的触发类型，0表示不关心。<br>         (7)aliases 节点用于指定节点的别名。因为引用一个节点要使用全路径，当子节点离根节点较远时，节点名就会显得比较冗长，定义一个别名则比较方便。下面把 spi 0这个节点定义了一个别名“spi0”。<br>  </p> 
<pre><code class="language-cpp">aliases {
    spi0 = &amp;spi0;
...</code></pre> 
<p>        (8)chosen 节点并不代表一个真正的设备，只是一个为固件和操作系统传递数据的地方，如引导参数。chosen 节点里的数据也不代表硬件。如在 arch/arm/boot/dts/exynos4412-origen.dts 文件中的 chosen 节点定义如下:</p> 
<pre><code class="language-cpp">chosen {
    bootargs = "console=ttySAC2,115200";
};       </code></pre> 
<p><br>         (9)设备特定数据，用于定义特定于某个具体设备的一些属性。这些属性可以自由定义，但是新的设备特定属性的名字都应该使用制造商前缀，以避免和现有标准属性名相冲突。另外，属性和子节点的含义必须存档在 binding 文档中，以便设备驱动程序的程序员知道如何解释这些数据。在内核源码的 Documentation/devicetree/bindings/目录中包含了大量的 binding 文档，当发现设备树中的一些属性不能理解时，在该目录下查看相应的文档都能找到答案。</p> 
<h1 id="%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%20%E9%A9%B1%E5%8A%A8">
<br> 四、使用设备树的LED 驱动</h1> 
<p><br>         使用设备树是内核的一个必然趋势，目前内核中除了较早的目标板在使用平台设备新的目标板几乎都使用了设备树。既然如此，我们接下来就把之前的 LED 驱动改造过来首先要做的就是在设备树源文件中添加相应的 LED设备树节点，修改 arch/armboot/dts/exynos4412-fs4412.dts，加入以下代码。</p> 
<p></p> 
<pre><code class="language-cpp">
fsled2@11000C40{
    compatible = "fs4412,fsled";
    reg = &lt;0x11000C40 0x8&gt;;
    id  = &lt;2&gt;;
    pin = &lt;7&gt;;
};

fsled3@11000C20 {
    compatible = "fs4412,fsled";
    reg = &lt;0x11000C20 0x8&gt;;
    id  = &lt;3&gt;;
    pin = &lt;0&gt;;
};

fsled4@114001E0 {
    compatible = "fs4412,fsled";
    reg = &lt;0x114001E0 0x8&gt;;
    id  = &lt;4&gt;;
    pin = &lt;4&gt;;
};

fsled5@114001E0 {
    compatible = "fs4412,fsled";
    reg = &lt;0x114001E0 0x8&gt;;
    id  = &lt;5&gt;;
    pin = &lt;5&gt;;
};</code></pre> 
<p><br> 上面的代码添加了4个LED 的设备树节点，compatible 都为“fs4412,fsled”;reg 属性是各自的I/O 内存;id 属性是自定义属性，表示设备的d 号;pin 属性也是自定义属性表示使用的 GPIO管脚。<br>         代码修改后，使用下面的命令重新编译设备树文件，并且将编译的结果复制到TFTP服务器指定的目录下。</p> 
<pre><code class="language-cpp"># make ARCH=arm dtbs
# cp arch/arm/boot/dts/exynos4412-fs4412.dtb ~/tftpboot/</code></pre> 
<p>接下来就是针对驱动的修改，主要代码如下</p> 
<pre><code class="language-cpp">#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;

#include &lt;linux/fs.h&gt;
#include &lt;linux/cdev.h&gt;

#include &lt;linux/slab.h&gt;
#include &lt;linux/ioctl.h&gt;
#include &lt;linux/uaccess.h&gt;

#include &lt;linux/io.h&gt;
#include &lt;linux/ioport.h&gt;
#include &lt;linux/platform_device.h&gt;

#include &lt;linux/of.h&gt;

#include "fsled.h"

#define FSLED_MAJOR	256
#define FSLED_DEV_NAME	"fsled"

struct fsled_dev {
	unsigned int __iomem *con;
	unsigned int __iomem *dat;
	unsigned int pin;
	atomic_t available;
	struct cdev cdev;
};

static int fsled_open(struct inode *inode, struct file *filp)
{
	struct fsled_dev *fsled = container_of(inode-&gt;i_cdev, struct fsled_dev, cdev);

	filp-&gt;private_data = fsled;
	if (atomic_dec_and_test(&amp;fsled-&gt;available))
		return 0;
	else {
		atomic_inc(&amp;fsled-&gt;available);
		return -EBUSY;
	}
}

static int fsled_release(struct inode *inode, struct file *filp)
{
	struct fsled_dev *fsled = filp-&gt;private_data;

	writel(readl(fsled-&gt;dat) &amp; ~(0x1 &lt;&lt; fsled-&gt;pin), fsled-&gt;dat);

	atomic_inc(&amp;fsled-&gt;available);
	return 0;
}

static long fsled_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct fsled_dev *fsled = filp-&gt;private_data;

	if (_IOC_TYPE(cmd) != FSLED_MAGIC)
		return -ENOTTY;

	switch (cmd) {
	case FSLED_ON:
		writel(readl(fsled-&gt;dat) | (0x1 &lt;&lt; fsled-&gt;pin), fsled-&gt;dat);
		break;
	case FSLED_OFF:
		writel(readl(fsled-&gt;dat) &amp; ~(0x1 &lt;&lt; fsled-&gt;pin), fsled-&gt;dat);
		break;
	default:
		return -ENOTTY;
	}

	return 0;
}

static struct file_operations fsled_ops = {
	.owner = THIS_MODULE,
	.open = fsled_open,
	.release = fsled_release,
	.unlocked_ioctl = fsled_ioctl,
};

static int fsled_probe(struct platform_device *pdev)
{
	int ret;
	dev_t dev;
	struct fsled_dev *fsled;
	struct resource *res;

	ret = of_property_read_u32(pdev-&gt;dev.of_node, "id", &amp;pdev-&gt;id);
	if (ret)
		goto id_err;

	dev = MKDEV(FSLED_MAJOR, pdev-&gt;id);
	ret = register_chrdev_region(dev, 1, FSLED_DEV_NAME);
	if (ret)
		goto reg_err;

	fsled = kzalloc(sizeof(struct fsled_dev), GFP_KERNEL);
	if (!fsled) {
		ret = -ENOMEM;
		goto mem_err;
	}

	cdev_init(&amp;fsled-&gt;cdev, &amp;fsled_ops);
	fsled-&gt;cdev.owner = THIS_MODULE;
	ret = cdev_add(&amp;fsled-&gt;cdev, dev, 1);
	if (ret)
		goto add_err;

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res) {
		ret = -ENOENT;
		goto res_err;
	}

	fsled-&gt;con = ioremap(res-&gt;start, resource_size(res));
	if (!fsled-&gt;con) {
		ret = -EBUSY;
		goto map_err;
	}
	fsled-&gt;dat = fsled-&gt;con + 1;

	ret = of_property_read_u32(pdev-&gt;dev.of_node, "pin", &amp;fsled-&gt;pin);
	if (ret)
		goto pin_err;

	atomic_set(&amp;fsled-&gt;available, 1);
	writel((readl(fsled-&gt;con) &amp; ~(0xF  &lt;&lt; 4 * fsled-&gt;pin)) | (0x1  &lt;&lt; 4 * fsled-&gt;pin), fsled-&gt;con);
	writel(readl(fsled-&gt;dat) &amp; ~(0x1 &lt;&lt; fsled-&gt;pin), fsled-&gt;dat);
	platform_set_drvdata(pdev, fsled);

	return 0;

pin_err:
	iounmap(fsled-&gt;con);
map_err:
res_err:
	cdev_del(&amp;fsled-&gt;cdev);
add_err:
	kfree(fsled);
mem_err:
	unregister_chrdev_region(dev, 1);
reg_err:
id_err:
	return ret;
}

static int fsled_remove(struct platform_device *pdev)
{
	dev_t dev;
	struct fsled_dev *fsled = platform_get_drvdata(pdev);

	dev = MKDEV(FSLED_MAJOR, pdev-&gt;id);

	iounmap(fsled-&gt;con);
	cdev_del(&amp;fsled-&gt;cdev);
	kfree(fsled);
	unregister_chrdev_region(dev, 1);

	return 0;
}

static const struct of_device_id fsled_of_matches[] = {
	{ .compatible = "fs4412,fsled", },
	{ /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, fsled_of_matches);

struct platform_driver pdrv = { 
	.driver = { 
		.name    = "fsled",
		.owner   = THIS_MODULE,
		.of_match_table = of_match_ptr(fsled_of_matches),
	},  
	.probe   = fsled_probe,
	.remove  = fsled_remove,
};

module_platform_driver(pdrv);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("name &lt;e-mail&gt;");
MODULE_DESCRIPTION("A simple character device driver for LEDs on FS4412 board");
</code></pre> 
<p><br>         代码第 163行至第167 行添加了一个fsled_of_matches 数组，用于和设备树的节点配，并且在平台驱动结构中将of_match_table 进行了相应的赋值。<br>         获得 IO内存资源的方法和以前的一样，但是 id 和 pin 是自定义的属性，要获取这<br> 两个属性的值，使用了of_property_read_u32函数，原型如下。</p> 
<pre><code class="language-cpp">int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value);</code></pre> 
<p><br>         np:设备节点对象地址<br>         propname:属性的名字。<br>         out_value:回传的属性值。<br>         函数返回0表示成功，非0则失败。<br><br>         测试方法和之前类似，只是不用再加载注册平台设备的模块了。设备树和内核及模块是分开编译的，所以，如果硬件发生改变，则只需要修改设备树并重新编译即可，内核和驱动模块都不需要重新编译，这是设备树的一个显著优点。</p> 
<p><img alt="" height="1035" src="https://images2.imgbox.com/15/6a/brLEQxYP_o.png" width="1200"></p> 
<p> </p> 
<h1 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="439" src="https://images2.imgbox.com/09/22/wRD3te3Q_o.png" width="1200"></h1> 
<p> </p> 
<h1 id="%E4%BA%94%E3%80%81%E4%B9%A0%E9%A2%98">
<br> 五、习题</h1> 
<p><br> 1.平台设备的resource 成员用于记录( )。<br> [A] 平台设备的资源信息 [B] 平台设备的状态信息<br> 2.udev 是一个工作在( )的程序。<br> [A]用户空间<br> [B]内核空间<br> 3.mdev 会扫描( )目录下的文件来自动创建设备节点。<br> [A]/dev<br> [B] /sys/block<br> [C] /sys/class<br> 4.Linux 设备树的目的是( )。<br> [A] 平台识别<br> [B] 实时配置<br> [C] 设备植入<br> 5.设备树源文件中常见的基本数据类型有 ( )。<br> [A]文本字符串<br> [B] cells<br> [C] 二进制数据<br> [D]文本字符串和二进制数据的混合<br> [E] 字符串列表<br> 6.编译设备树的命令是 (<br> A] make ulmage<br> [B] make dtbs</p> 
<p></p> 
<p></p> 
<p></p> 
<p><br>  </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>