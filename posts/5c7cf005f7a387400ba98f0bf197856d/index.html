<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Java实现在线聊天 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java实现在线聊天</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%93%95%20%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px"><a href="#%F0%9F%93%95%20%E4%BB%8B%E7%BB%8D">? 介绍</a></p> 
<p id="%C2%A0%E7%89%B9%E7%82%B9-toc" style="margin-left:0px"><a href="#%C2%A0%E7%89%B9%E7%82%B9"> ? 特点</a></p> 
<p id="t-io%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AF%B9%E6%AF%94-toc" style="margin-left:0px"><a href="#t-io%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AF%B9%E6%AF%94">? t-io性能与对比</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px"><a href="#%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">? 使用介绍</a></p> 
<p id="%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A-toc" style="margin-left:40px"><a href="#%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">? 业务数据绑定</a></p> 
<p id="%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E8%A7%A3%E7%BB%91-toc" style="margin-left:40px"><a href="#%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E8%A7%A3%E7%BB%91">?‍♂️ 业务数据解绑</a></p> 
<p id="%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81-toc" style="margin-left:40px"><a href="#%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81">? 异步发送</a></p> 
<p id="%E9%98%BB%E5%A1%9E%E5%8F%91%E9%80%81-toc" style="margin-left:40px"><a href="#%E9%98%BB%E5%A1%9E%E5%8F%91%E9%80%81">?‍? 阻塞发送</a></p> 
<p id="%C2%A0%E8%8E%B7%E5%8F%96ChannelContext-toc" style="margin-left:40px"><a href="#%C2%A0%E8%8E%B7%E5%8F%96ChannelContext"> ? 获取ChannelContext</a></p> 
<p id="%C2%A0%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A7%BB%E9%99%A4%E8%BF%9E%E6%8E%A5-toc" style="margin-left:40px"><a href="#%C2%A0%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A7%BB%E9%99%A4%E8%BF%9E%E6%8E%A5"> ?‍? 断开连接和移除连接</a></p> 
<p id="Tio.remove()%E5%92%8CTio.close()%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px"><a href="#Tio.remove%28%29%E5%92%8CTio.close%28%29%E7%9A%84%E5%8C%BA%E5%88%AB">?Tio.remove()和Tio.close()的区别</a></p> 
<p id="%E6%8B%89%E9%BB%91IP-toc" style="margin-left:40px"><a href="#%E6%8B%89%E9%BB%91IP">? 拉黑IP</a></p> 
<p id="%E5%90%84%E7%A7%8D%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7-toc" style="margin-left:40px"><a href="#%E5%90%84%E7%A7%8D%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7">? 各种流量监控</a></p> 
<p id="ip%E7%9A%84%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px"><a href="#ip%E7%9A%84%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE">? ip的监控数据</a></p> 
<p id="%C2%A0%E8%8E%B7%E5%8F%96TCP%E4%BC%9A%E8%AF%9D%E7%9A%84%E6%B5%81%E9%87%8F%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px"><a href="#%C2%A0%E8%8E%B7%E5%8F%96TCP%E4%BC%9A%E8%AF%9D%E7%9A%84%E6%B5%81%E9%87%8F%E6%95%B0%E6%8D%AE"> ? 获取TCP会话的流量数据</a></p> 
<p id="%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%B5%81%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px"><a href="#%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%B5%81%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE">?‍? 监听端口的流量和数据</a></p> 
<p id="T-io%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF%E8%BF%87%E7%A8%8B%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px"><a href="#T-io%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF%E8%BF%87%E7%A8%8B%E2%80%8B%E7%BC%96%E8%BE%91">✨ T-io收发消息过程​编辑</a></p> 
<p id="TCP%E8%BF%9E%E6%8E%A5%E4%B8%8A%E4%B8%8B%E6%96%87-toc" style="margin-left:40px"><a href="#TCP%E8%BF%9E%E6%8E%A5%E4%B8%8A%E4%B8%8B%E6%96%87">? TCP连接上下文</a></p> 
<p id="TioConfig-toc" style="margin-left:40px"><a href="#TioConfig">? TioConfig</a></p> 
<p id="%C2%A0%E6%B6%88%E6%81%AF%E6%9D%A5%E5%BE%80%E7%9B%91%E5%90%AC-toc" style="margin-left:40px"><a href="#%C2%A0%E6%B6%88%E6%81%AF%E6%9D%A5%E5%BE%80%E7%9B%91%E5%90%AC"> ? 消息来往监听</a></p> 
<p id="%E6%95%B4%E5%90%88JAVA-toc" style="margin-left:0px"><a href="#%E6%95%B4%E5%90%88JAVA">? 整合JAVA</a></p> 
<p id="websocket%20%E9%85%8D%E7%BD%AE%E7%B1%BB-toc" style="margin-left:40px"><a href="#websocket%20%E9%85%8D%E7%BD%AE%E7%B1%BB">? websocket 配置类</a></p> 
<p id="%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E7%B1%BB">? 消息处理类</a></p> 
<p id="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px"><a href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E2%80%8B%E7%BC%96%E8%BE%91">? 启动服务​编辑</a></p> 
<hr id="hr-toc">
<h1>? 介绍</h1> 
<p>注：可以直接看整合java</p> 
<p>t-io是基于java开发的一个开源的网络编程架构，大家都知道现在手机上或者电脑上都装了很多APP，这些APP都不是一个个在手机上或电脑上孤立的使用，而是能访问其他的地方数据或者与其他节点进行实时聊天，故每个APP中都要有一个对外进行通信的模块，这块内容从编程的角度来看就能通过网络编程框架来实现，t-io就是完成这块的内容的最好的编程软件。</p> 
<p>t-io经过创始人谭先生的精心打磨，性能超强，已经达到运营的的级别，用t-io写的程序每秒能处理1000+万条消息，1.9G内存能够支撑30万TCP长连接。</p> 
<p>基于tio开发的即时通讯软件谭聊，目前是业界性能最强的全开源销售即时通讯软件。<img alt="" height="1200" src="https://images2.imgbox.com/8c/98/habEEGx2_o.png" width="1200"></p> 
<hr>
<h1 id="%C2%A0%E7%89%B9%E7%82%B9"> ? 特点</h1> 
<p>t-io是基于JVM的网络编程框架，和netty属同类，所以netty能做的t-io都能做，考虑到t-io是从项目抽象出来的框架，所以t-io提供了更多的和业务相关的API，大体上t-io具有如下特点和能力</p> 
<ul>
<li>内置完备的监控和流控能力</li>
<li>内置半包粘包处理</li>
<li>一骑绝尘的资源管理能力</li>
<li>内置心跳检查和心跳发送能力</li>
<li>内置IP拉黑</li>
<li>一流性能和稳定性（第三方权威平台TFB提供性能测试和稳定性服务）</li>
<li>极其稳定的表现(很多用户还是停在t-io 1.x版本，就是因为太过稳定，不想变动)</li>
<li>内置慢攻击防御</li>
<li>唯一一个内置异步发送、阻塞发送、同步发送的网络框架</li>
<li>唯一内置集群分发消息的能力</li>
<li>独创的多端口资源共享能力（譬如一个端口是websocket协议，一个端口是私有的im协议，这两个端口的资源可以共享，这对协议适配极其有用）</li>
<li>独创协议适配转换能力（让基于websocket和基于socket的应用看起来像是同一个协议）</li>
<li>独一档的资源和业务绑定能力：绑定group、绑定userid、绑定token、绑定bsId，这些绑定几乎囊括了所有业务需求 
  <hr>
<h1 id="t-io%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AF%B9%E6%AF%94">? t-io性能与对比</h1> <p>t-io测试结果：30W长连接并发压力，每秒1051万条聊天消息</p> <p><strong>netty和t-io对比：</strong></p> </li>
<li>netty：100秒内生成10000个连接，每个连接每隔2秒发送一条消息，每个连接总共发送200条消息，发消息请求99%的响应时间在1ms以内，其它请求95%的响应时间在10ms以内<img alt="" height="157" src="https://images2.imgbox.com/a6/b9/TUb3FQo4_o.png" width="1134">
</li>
<li>t-io：100秒内生成10000个连接，每个连接每隔2秒发送一条消息，每个连接总共发送200条消息，发消息请求99%的响应时间在1ms以内<img alt="" height="82" src="https://images2.imgbox.com/82/1c/PPH0YgMr_o.png" width="1130">
</li>
<li><strong>CPU使用率：</strong></li>
<li>netty：CPU使用率在20%左右</li>
<li>t-io：CPU使用率在15%左右</li>
</ul>
<hr>
<h1 id="%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">? 使用介绍</h1> 
<h2 id="%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">? 业务数据绑定</h2> 
<p>资源绑定是指把业务相关的数据和Tcp连接（即ChannelContext）关联起来，譬如ChannelContext-A代表了用户张三，张三的userid是333</p> 
<pre><code class="language-java">Tio.bindUser(ChannelContext-A, "333")  </code></pre> 
<p>t-io目前内置了4种资源绑定，譬如给group加前缀"ios- "，从而标记这个用户使用的是ios</p> 
<pre><code class="language-java">Tio.bindGroup(ChannelContext-A, "333");
Tio.bindGroup(ChannelContext-A, "ios-" + "333");</code></pre> 
<p>内置的4种资源绑定方法中，一个ChannelContext是可以绑定到多个groupid的，其它三个绑定都是一对一或多对一的关系，也就是说一个ChannelContext可以同时属于group-a，group-b… …group-n</p> 
<pre><code class="language-java">/**
   * 绑定业务id
   * @param channelContext
   * @param bsId
   */
  public static void bindBsId(ChannelContext channelContext, String bsId) {
      channelContext.tioConfig.bsIds.bind(channelContext, bsId);
  }
  /**
   * 绑定群组
   * @param channelContext
   * @param group
   */
  public static void bindGroup(ChannelContext channelContext, String group) {
      channelContext.tioConfig.groups.bind(group, channelContext);
  }
  /**
   * 绑定token
   * @param channelContext
   * @param token
   */
  public static void bindToken(ChannelContext channelContext, String token) {
      channelContext.tioConfig.tokens.bind(token, channelContext);
  }
  /**
   * 绑定用户
   * @param channelContext
   * @param userid
   */
  public static void bindUser(ChannelContext channelContext, String userid) {
      channelContext.tioConfig.users.bind(userid, channelContext);
  }</code></pre> 
<hr>
<h2 id="%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E8%A7%A3%E7%BB%91">?‍♂️ 业务数据解绑</h2> 
<p>既然有绑定，就肯定会有解绑，这是个和绑定相反的操作</p> 
<pre><code class="language-java"> /**
   * 解绑业务id
   * @param channelContext
   */
  public static void unbindBsId(ChannelContext channelContext) {
      channelContext.tioConfig.bsIds.unbind(channelContext);
  }
  /**
   * 与所有组解除解绑关系
   * @param channelContext
   */
  public static void unbindGroup(ChannelContext channelContext) {
      channelContext.tioConfig.groups.unbind(channelContext);
  }
  /**
   * 与指定组解除绑定关系
   * @param group
   * @param channelContext
   */
  public static void unbindGroup(String group, ChannelContext channelContext) {
      channelContext.tioConfig.groups.unbind(group, channelContext);
  }
  /**
   * 解除channelContext绑定的token
   * @param channelContext
   */
  public static void unbindToken(ChannelContext channelContext) {
      channelContext.tioConfig.tokens.unbind(channelContext);
  }
  //    org.tio.core.TioConfig.ipBlacklist
  /**
   * 解除channelContext绑定的userid
   * @param channelContext
   */
  public static void unbindUser(ChannelContext channelContext) {
      channelContext.tioConfig.users.unbind(channelContext);
  }
  /**
   * 解除userid的绑定。一般用于多地登录，踢掉前面登录的场景
   * @param tioConfig
   * @param userid
   */
  public static void unbindUser(TioConfig tioConfig, String userid) {
      tioConfig.users.unbind(tioConfig, userid);
  }</code></pre> 
<hr>
<h2 id="%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81">? 异步发送</h2> 
<ul>
<li>异步发送，指的是业务层把Packet丢给t-io后立即返回，返回时Packet并没有被发送，而只是提交到了待发送队列</li>
<li>异步发送都是以send开头的</li>
</ul>
<p><img alt="" height="614" src="https://images2.imgbox.com/d7/c3/hov3oSfo_o.png" width="883"></p> 
<hr>
<h2 id="%E9%98%BB%E5%A1%9E%E5%8F%91%E9%80%81">?‍? 阻塞发送</h2> 
<ul>
<li>阻塞发送：t-io把Packet送给对方后才返回</li>
<li>阻塞发送都是以bSend开头的</li>
</ul>
<p> <img alt="" height="366" src="https://images2.imgbox.com/c1/a5/Hhcjz3UM_o.png" width="883"></p> 
<hr>
<h2 id="%C2%A0%E8%8E%B7%E5%8F%96ChannelContext"> ? 获取ChannelContext</h2> 
<ul>
<li>前面的业务数据绑定，一个重要的目的就是要根据那些业务标识来获取ChannelContext，譬如你绑定了一个userid，那么后面就可以通过这个userid来获取ChannelContext</li>
<li>获取ChannelContext的API都是以get开头的</li>
</ul>
<p> <img alt="" height="472" src="https://images2.imgbox.com/0f/54/aQdgUYhh_o.png" width="883"></p> 
<hr>
<h2 id="%C2%A0%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A7%BB%E9%99%A4%E8%BF%9E%E6%8E%A5"> ?‍? 断开连接和移除连接</h2> 
<p>断开连接都是以close开头的方法，指的是把当前已经连上的TCP连接断开掉</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/0d/0f/wMvlmZgK_o.png" width="884"></p> 
<p>移除连接都是以remove开头的方法，指的是彻底抛弃这个连接<img alt="" height="353" src="https://images2.imgbox.com/b0/cd/cdqJLGM7_o.png" width="884"></p> 
<h3 id="Tio.remove()%E5%92%8CTio.close()%E7%9A%84%E5%8C%BA%E5%88%AB">?Tio.remove()和Tio.close()的区别</h3> 
<p><strong>Tio.remove：</strong>不管是用t-io做TCP服务器还是TCP客户端，调用Tio.remove()后，t-io都会彻底删除TCP连接并释放包括ChannelContext在内的所有和该条TCP连接对应的资源，当然那些和群组、Token的绑定关系也全部释放掉</p> 
<p><strong>Tio.close：</strong></p> 
<ul>
<li>如果是用t-io做TCP服务器，此方法等价于Tio.remove()；</li>
<li>如果是用t-io做TCP客户端 
  <ul>
<li>该方法会断开当前TCP连接</li>
<li>如果业务程序配置了重连策略（就是：ReconnConf）： 
    <ul>
<li>t-io后面会进行重连操作，也就是说并不会抛弃该条TCP连接对应的ChannelContext对象</li>
<li>如果该条TCP连接对应的ChannelContext对象绑定了groupid、userid、token、bsId，那么这些绑定关系会全部释放掉，在重连成功后，业务侧需要再次进行绑定</li>
</ul>
</li>
<li>如果业务程序没有配置重连策略（就是：ReconnConf），此方法等价于Tio.remove()</li>
</ul>
</li>
</ul>
<p><strong>出现网络异常或其它异常时，业务需要主动调用这俩方法吗？</strong></p> 
<p>答：不需要的，出现任何网络异常，t-io都会释放掉该条TCP连接对应的全部资源，这也是t-io如此稳定的一大原因。网络编程的很多坑，都是源于资源没释放</p> 
<p></p> 
<hr>
<h2 id="%E6%8B%89%E9%BB%91IP">? 拉黑IP</h2> 
<p>简单到极致，只需要一行代码</p> 
<pre><code class="language-java">Tio.IpBlacklist.add(tioConfig, channelContext.getClientNode().getIp());</code></pre> 
<hr>
<h2 id="%E5%90%84%E7%A7%8D%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7">? 各种流量监控</h2> 
<h3 id="ip%E7%9A%84%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE">? ip的监控数据</h3> 
<p>ip的监控数据定义在IpStat中</p> 
<pre><code class="language-java">private Date start = new Date();
/**
 * 当前统计了多久，单位：毫秒
 */
private long duration;
/**
 * 时长类型，单位：秒，譬如60，3600等
 */
private Long durationType;
/**
 * 客户端ip
 */
private String ip;
/**
 * 解码异常的次数
 */
private AtomicInteger decodeErrorCount = new AtomicInteger();
/**
 * 收到该IP连接请求的次数
 */
private AtomicInteger requestCount = new AtomicInteger();
/**
 * 本IP已发送的字节数
 */
private AtomicLong sentBytes = new AtomicLong();
/**
 * 本IP已发送的packet数
 */
private AtomicLong sentPackets = new AtomicLong();
/**
 * 本IP已处理的字节数
 */
private AtomicLong handledBytes = new AtomicLong();
/**
 * 本IP已处理的packet数
 */
private AtomicLong handledPackets = new AtomicLong();
/**
 * 处理消息包耗时，单位：毫秒
 */
private AtomicLong handledPacketCosts = new AtomicLong();
/**
 * 本IP已接收的字节数
 */
private AtomicLong receivedBytes = new AtomicLong();
/**
 * 本IP已接收了多少次TCP数据包
 */
private AtomicLong receivedTcps = new AtomicLong();
/**
 * 本IP已接收的packet数
 */
private AtomicLong receivedPackets = new AtomicLong();</code></pre> 
<p>使用步骤</p> 
<ul><li>实现IpStatListener</li></ul>
<pre><code class="language-java">package org.tio.showcase.websocket.server;
public class ShowcaseIpStatListener implements IpStatListener {
    @SuppressWarnings("unused")
    private static Logger log = LoggerFactory.getLogger(ShowcaseIpStatListener.class);
    public static final ShowcaseIpStatListener me = new ShowcaseIpStatListener();
    private ShowcaseIpStatListener() {
    }
    @Override
    public void onExpired(TioConfig tioConfig, IpStat ipStat) {
        //在这里把统计数据入库中或日志
//        if (log.isInfoEnabled()) {
//            log.info("可以把统计数据入库rn{}", Json.toFormatedJson(ipStat));
//        }
    }
    @Override
    public void onAfterConnected(ChannelContext channelContext, boolean isConnected, boolean isReconnect, IpStat ipStat) throws Exception {
//        if (log.isInfoEnabled()) {
//            log.info("onAfterConnectedrn{}", Json.toFormatedJson(ipStat));
//        }
    }
    @Override
    public void onDecodeError(ChannelContext channelContext, IpStat ipStat) {
//        if (log.isInfoEnabled()) {
//            log.info("onDecodeErrorrn{}", Json.toFormatedJson(ipStat));
//        }
    }
    @Override
    public void onAfterSent(ChannelContext channelContext, Packet packet, boolean isSentSuccess, IpStat ipStat) throws Exception {
//        if (log.isInfoEnabled()) {
//            log.info("onAfterSentrn{}rn{}", packet.logstr(), Json.toFormatedJson(ipStat));
//        }
    }
    @Override
    public void onAfterDecoded(ChannelContext channelContext, Packet packet, int packetSize, IpStat ipStat) throws Exception {
//        if (log.isInfoEnabled()) {
//            log.info("onAfterDecodedrn{}rn{}", packet.logstr(), Json.toFormatedJson(ipStat));
//        }
    }
    @Override
    public void onAfterReceivedBytes(ChannelContext channelContext, int receivedBytes, IpStat ipStat) throws Exception {
//        if (log.isInfoEnabled()) {
//            log.info("onAfterReceivedBytesrn{}", Json.toFormatedJson(ipStat));
//        }
    }
    @Override
    public void onAfterHandled(ChannelContext channelContext, Packet packet, IpStat ipStat, long cost) throws Exception {
//        if (log.isInfoEnabled()) {
//            log.info("onAfterHandledrn{}rn{}", packet.logstr(), Json.toFormatedJson(ipStat));
//        }
    }
}</code></pre> 
<ul><li>初始化时添加监听器和监控时段</li></ul>
<pre><code class="language-java">//注意的是：要保证下面两行代码的顺序，不能先addDuration()后setIpStatListener
serverTioConfig.setIpStatListener(ShowcaseIpStatListener.me);
serverTioConfig.ipStats.addDuration(Time.MINUTE_1 * 5);</code></pre> 
<ul><li>OK了，什么时候拉黑IP以及把监控数据入库都在ShowcaseIpStatListener中实现哦</li></ul>
<hr>
<h2 id="%C2%A0%E8%8E%B7%E5%8F%96TCP%E4%BC%9A%E8%AF%9D%E7%9A%84%E6%B5%81%E9%87%8F%E6%95%B0%E6%8D%AE"> ? 获取TCP会话的流量数据</h2> 
<p>一个TCP会话对应一个ChannelContext对象，每个ChannelContext对象都有一个ChannelStat对象，定义如下</p> 
<pre><code class="language-java">public final ChannelStat stat = new ChannelStat();</code></pre> 
<p>ChannelStat包含如下字段和方法（已经略过普通的getter和setter）</p> 
<pre><code class="language-java">/**
     * 本次解码失败的次数
     */
    public int                    decodeFailCount                = 0;
    /**
     * 最近一次收到业务消息包的时间(一个完整的业务消息包，一部分消息不算)
     */
    public long                    latestTimeOfReceivedPacket    = SystemTimer.currTime;
    /**
     * 最近一次发送业务消息包的时间(一个完整的业务消息包，一部分消息不算)
     */
    public long                    latestTimeOfSentPacket        = SystemTimer.currTime;
    /**
     * 最近一次收到业务消息包的时间:收到字节就算
     */
    public long                    latestTimeOfReceivedByte    = SystemTimer.currTime;
    /**
     * 最近一次发送业务消息包的时间：发送字节就算
     */
    public long                    latestTimeOfSentByte        = SystemTimer.currTime;
    /**
     * ChannelContext对象创建的时间
     */
    public long                    timeCreated                    = SystemTimer.currTime;
    /**
     * 第一次连接成功的时间
     */
    public Long                    timeFirstConnected            = null;
    /**
     * 连接关闭的时间
     */
    public long                    timeClosed                    = SystemTimer.currTime;
    /**
     * 进入重连队列时间
     */
    public long                    timeInReconnQueue            = SystemTimer.currTime;
    /**
     * 本连接已发送的字节数
     */
    public final AtomicLong        sentBytes                    = new AtomicLong();
    /**
     * 本连接已发送的packet数
     */
    public final AtomicLong        sentPackets                    = new AtomicLong();
    /**
     * 本连接已处理的字节数
     */
    public final AtomicLong        handledBytes                = new AtomicLong();
    /**
     * 本连接已处理的packet数
     */
    public final AtomicLong        handledPackets                = new AtomicLong();
    /**
     * 处理消息包耗时，单位：毫秒
     * 拿这个值除以handledPackets，就是处理每个消息包的平均耗时
     */
    public final AtomicLong        handledPacketCosts            = new AtomicLong();
    /**
     * 本连接已接收的字节数
     */
    public final AtomicLong        receivedBytes                = new AtomicLong();
    /**
     * 本连接已接收了多少次TCP数据包
     */
    public final AtomicLong        receivedTcps                = new AtomicLong();
    /**
     * 本连接已接收的packet数
     */
    public final AtomicLong        receivedPackets                = new AtomicLong();
/**
     * 平均每次TCP接收到的字节数，这个可以用来监控慢攻击，配置PacketsPerTcpReceive定位慢攻击
     */
    public double getBytesPerTcpReceive() {
        if (receivedTcps.get() == 0) {
            return 0;
        }
        double ret = (double) receivedBytes.get() / (double) receivedTcps.get();
        return ret;
    }
    /**
     * 平均每次TCP接收到的业务包数，这个可以用来监控慢攻击，此值越小越有攻击嫌疑
     */
    public double getPacketsPerTcpReceive() {
        if (receivedTcps.get() == 0) {
            return 0;
        }
        double ret = (double) receivedPackets.get() / (double) receivedTcps.get();
        return ret;
    }
    /**
     * 处理packet平均耗时，单位：毫秒
     * @return
     */
    public double getHandledCostsPerPacket() {
        if (handledPackets.get() &gt; 0) {
            return handledPacketCosts.get() / handledPackets.get();
        }
        return 0;
    }</code></pre> 
<hr>
<h2 id="%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%B5%81%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE">?‍? 监听端口的流量和数据</h2> 
<p>TioConfig对象有个GroupStat成员，定义如下</p> 
<pre><code class="language-java">public GroupStat groupStat = null;</code></pre> 
<p>GroupStat有如下一些字段和方法（去掉了简单的getter和setter）</p> 
<pre><code class="language-java">/**
   * 关闭了多少连接
   */
  public final AtomicLong        closed                = new AtomicLong();
  /**
   * 接收到的消息包
   */
  public final AtomicLong        receivedPackets        = new AtomicLong();
  /**
   * 接收到的消息字节数
   */
  public final AtomicLong receivedBytes = new AtomicLong();
  /**
   * 处理了的消息包数
   */
  public final AtomicLong handledPackets = new AtomicLong();
  /**
   * 处理消息包耗时，单位：毫秒
   */
  public final AtomicLong handledPacketCosts = new AtomicLong();
  /**
   * 处理了多少字节
   */
  public final AtomicLong handledBytes = new AtomicLong();
  /**
   * 发送了的消息包数
   */
  public final AtomicLong sentPackets = new AtomicLong();
  /**
   * 发送了的字节数
   */
  public final AtomicLong sentBytes = new AtomicLong();
  /**
   * 本IP已接收了多少次TCP数据包
   */
  public final AtomicLong receivedTcps = new AtomicLong();
  /**
   * 平均每次TCP接收到的字节数，这个可以用来监控慢攻击，配置PacketsPerTcpReceive定位慢攻击
   */
  public double getBytesPerTcpReceive() {
      if (receivedTcps.get() == 0) {
          return 0;
      }
      double ret = (double) receivedBytes.get() / (double) receivedTcps.get();
      return ret;
  }
  /**
   * 平均每次TCP接收到的业务包数，这个可以用来监控慢攻击，此值越小越有攻击嫌疑
   */
  public double getPacketsPerTcpReceive() {
      if (receivedTcps.get() == 0) {
          return 0;
      }
      double ret = (double) receivedPackets.get() / (double) receivedTcps.get();
      return ret;
  }
  /**
   * 处理packet平均耗时，单位：毫秒
   * @return
   */
  public double getHandledCostsPerPacket() {
      if (handledPackets.get() &gt; 0) {
          return handledPacketCosts.get() / handledPackets.get();
      }
      return 0;
  }</code></pre> 
<p>对于服务器端的groupStat，它是在ServerTioConfig类中的初始化代码在构造函数中，如下</p> 
<pre><code class="language-java">this.groupStat = new ServerGroupStat();</code></pre> 
<p>对于客户端的groupStat，它是在ClientTioConfig类中的初始化代码在构造函数中，如下</p> 
<pre><code class="language-java">this.groupStat = new ClientGroupStat();</code></pre> 
<p>获取GroupStat</p> 
<pre><code class="language-java">GroupStat groupStat = tioConfig.groupStat;
//如果确认是服务器端，则可以用强转方式获得ServerGroupStat对象
ServerGroupStat serverGroupStat = (ServerGroupStat)tioConfig.groupStat;
//如果确认是客户端，则可以用强转方式获得ClientGroupStat对象
ClientGroupStat clientGroupStat = (ClientGroupStat)tioConfig.groupStat;</code></pre> 
<hr>
<h2 id="T-io%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF%E8%BF%87%E7%A8%8B%E2%80%8B%E7%BC%96%E8%BE%91">✨ T-io收发消息过程<img alt="" height="1200" src="https://images2.imgbox.com/ce/57/VyMEorw4_o.png" width="1200">
</h2> 
<p>Packet是用于表述业务数据结构的，我们通过继承Packet来实现自己的业务数据结构，对于各位而言，把Packet看作是一个普通的VO对象即可。</p> 
<p>注意：不建议直接使用Packet对象，而是要继承Packet</p> 
<hr>
<h2 id="TCP%E8%BF%9E%E6%8E%A5%E4%B8%8A%E4%B8%8B%E6%96%87">? TCP连接上下文</h2> 
<p>每一个tcp连接的建立都会产生一个ChannelContext对象，这是个抽象类，如果你是用t-io作tcp客户端，那么就是ClientChannelContext，如果你是用tio作tcp服务器，那么就是ServerChannelContext<img alt="" height="1200" src="https://images2.imgbox.com/2d/76/IMF9XqzZ_o.png" width="1200"></p> 
<p></p> 
<p>用户可以把业务数据通过ChannelContext对象和TCP连接关联起来，像下面这样设置属性</p> 
<pre><code class="language-java">ChannelContext.set(String key, Object value)</code></pre> 
<p>然后用下面的方式获取属性</p> 
<pre><code class="language-java">ChannelContext.get(String key)</code></pre> 
<p>当然最最常用的还是用t-io提供的强到没对手的bind功能，譬如用下面的代码绑定userid</p> 
<pre><code class="language-java">Tio.bindUser(ChannelContext channelContext, String userid)</code></pre> 
<p>然后可以通过userid进行操作，示范代码如下</p> 
<pre><code class="language-java">//获取某用户的ChannelContext集合
SetWithLock&lt;ChannelContext&gt; set = Tio.getChannelContextsByUserid(tioConfig, userid);
//给某用户发消息
Tio.sendToUser(TioConfig, userid, Packet)</code></pre> 
<p>除了可以绑定userid，t-io还内置了如下绑定API</p> 
<ul><li>绑定业务id</li></ul>
<pre><code class="language-java">Tio.bindBsId(ChannelContext channelContext, String bsId)</code></pre> 
<ul><li>绑定token</li></ul>
<pre><code class="language-java">Tio.bindToken(ChannelContext channelContext, String token)</code></pre> 
<ul><li>绑定群组</li></ul>
<pre><code class="language-java">Tio.bindGroup(ChannelContext channelContext, String group)</code></pre> 
<p>ChannelContext对象包含的信息非常多，主要对象见下图<img alt="" height="781" src="https://images2.imgbox.com/2a/1e/hwCrz26A_o.png" width="1155"></p> 
<p> ChannelContext是t-io中非常重要的类，他是业务和连接的沟通桥梁！</p> 
<hr>
<h2 id="TioConfig">? TioConfig</h2> 
<ul>
<li>场景：我们在写TCP Server时，都会先选好一个端口以监听客户端连接，再创建N组线程池来执行相关的任务，譬如发送消息、解码数据包、处理数据包等任务，还要维护客户端连接的各种数据，为了和业务互动，还要把这些客户端连接和各种业务数据绑定起来，譬如把某个客户端绑定到一个群组，绑定到一个userid，绑定到一个token等。</li>
<li>TioConfig</li>
</ul>
<p>就是解决以上场景的：配置线程池、监听端口，维护客户端各种数据等的。</p> 
<ul><li>TioConfig是个抽象类 
  <ul>
<li>如果你是用tio作tcp客户端，那么你需要创建ClientTioConfig对象 
    <ul><li>服务器端对应一个ClientTioConfig对象</li></ul>
</li>
<li>如果你是用tio作tcp服务器，那么你需要创建ServerTioConfig 
    <ul><li>一个监听端口对应一个ServerTioConfig ，一个jvm可以监听多个端口，所以一个jvm可以有多个ServerTioConfig对象</li></ul>
</li>
</ul>
</li></ul>
<hr>
<h2 id="%C2%A0%E6%B6%88%E6%81%AF%E6%9D%A5%E5%BE%80%E7%9B%91%E5%90%AC"> ? 消息来往监听</h2> 
<p>TioListener是处理消息的核心接口，它有两个子接口：TioClientListener和TioServerListener</p> 
<ul>
<li>当用tio作tcp客户端时需要实现TioClientListener</li>
<li>当用tio作tcp服务器时需要实现TioServerListener</li>
</ul>
<p>它主要定义了如下方法</p> 
<pre><code class="language-java">public interface TioListener {
    /**
     * 建链后触发本方法，注：建链不一定成功，需要关注参数isConnected
     * 
     * @param channelContext
     * @param isConnected    是否连接成功,true:表示连接成功，false:表示连接失败
     * @param isReconnect    是否是重连, true: 表示这是重新连接，false: 表示这是第一次连接
     * @throws Exception
     */
    public void onAfterConnected(ChannelContext channelContext, boolean isConnected, boolean isReconnect) throws Exception;
    /**
     * 原方法名：onAfterDecoded 解码成功后触发本方法
     * 
     * @param channelContext
     * @param packet
     * @param packetSize
     * @throws Exception
     */
    public void onAfterDecoded(ChannelContext channelContext, Packet packet, int packetSize) throws Exception;
    /**
     * 处理一个消息包后
     * 
     * @param channelContext
     * @param packet
     * @param cost           本次处理消息耗时，单位：毫秒
     * @throws Exception
     */
    public void onAfterHandled(ChannelContext channelContext, Packet packet, long cost) throws Exception;
    /**
     * 接收到TCP层传过来的数据后
     * 
     * @param channelContext
     * @param receivedBytes  本次接收了多少字节
     * @throws Exception
     */
    public void onAfterReceivedBytes(ChannelContext channelContext, int receivedBytes) throws Exception;
    /**
     * 消息包发送之后触发本方法
     * 
     * @param channelContext
     * @param packet
     * @param isSentSuccess  true:发送成功，false:发送失败
     * @throws Exception     */
    public void onAfterSent(ChannelContext channelContext, Packet packet, boolean isSentSuccess) throws Exception;
    /**
     * 连接关闭前触发本方法
     * 
     * @param channelContext the channelcontext
     * @param throwable      the throwable 有可能为空
     * @param remark         the remark 有可能为空
     * @param isRemove
     * @throws Exception
     */
    public void onBeforeClose(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) throws Exception;
    /**
     * 连接关闭前后触发本方法 警告：走到这个里面时，很多绑定的业务都已经解绑了，所以这个方法一般是空着不实现的
     * 
     * @param channelContext the channelcontext
     * @param throwable      the throwable 有可能为空
     * @param remark         the remark 有可能为空
     * @param isRemove       是否是删除
     * @throws Exception
     */
    // public void onAfterClose(ChannelContext channelContext, Throwable throwable,
    // String remark, boolean isRemove) throws Exception;
}</code></pre> 
<hr>
<h1 id="%E6%95%B4%E5%90%88JAVA">? 整合JAVA</h1> 
<pre><code class="language-XML">&lt;!-- tio-websocket --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.t-io&lt;/groupId&gt;
    &lt;artifactId&gt;tio-websocket-server&lt;/artifactId&gt;
    &lt;version&gt;3.5.9.v20200214-RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>注意：每个版本之前存在差异请查看官方文档</p> 
<h2 id="websocket%20%E9%85%8D%E7%BD%AE%E7%B1%BB">? websocket 配置类</h2> 
<pre><code class="language-java">import com.asurplus.tio.websocket.handle.MyWsMsgHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.tio.server.ServerTioConfig;
import org.tio.websocket.server.WsServerStarter;

import java.io.IOException;

/**
 * websocket 配置类
 */
@Configuration
public class WebSocketConfig {

   /**
     * 注入消息处理器
     */
    @Autowired
    private MyWsMsgHandler myWsMsgHandler;

    /**
     * 启动类配置
     *
     * @return
     * @throws IOException
     */
    @Bean
    public WsServerStarter wsServerStarter() throws IOException {
        // 设置处理器
        WsServerStarter wsServerStarter = new WsServerStarter(6789, myWsMsgHandler);
        // 获取到ServerTioConfig
        ServerTioConfig serverTioConfig = wsServerStarter.getServerTioConfig();
        // 设置心跳超时时间，默认：1000 * 120
        serverTioConfig.setHeartbeatTimeout(1000 * 120);
        // 启动
        wsServerStarter.start();
        return wsServerStarter;
    }
}</code></pre> 
<p>这里我们注入了 WsServerStarter 的 bean，这样在 SpringBoot 启动的时候，就能启动咱们的 websocket 服务</p> 
<ul>
<li>注明了 websocket 的服务端口为：6789</li>
<li>消息处理类为：myWsMsgHandler，在下一步我们将会去实现这个类</li>
<li>设置了心跳的超时时间为：120秒，默认值，可以不设置</li>
</ul>
<h2 id="%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E7%B1%BB">? 消息处理类</h2> 
<pre><code class="language-java">package com.ying.tiiochat.config;

import com.alibaba.fastjson.JSONObject;
import org.springframework.stereotype.Component;
import org.tio.core.ChannelContext;
import org.tio.core.Tio;
import org.tio.http.common.HttpRequest;
import org.tio.http.common.HttpResponse;
import org.tio.websocket.common.WsRequest;
import org.tio.websocket.common.WsResponse;
import org.tio.websocket.server.handler.IWsMsgHandler;

/**
 * 消息处理类
 */
@Component
public class MyWsMsgHandler implements IWsMsgHandler {

   /**
    * &lt;li&gt;对httpResponse参数进行补充并返回，如果返回null表示不想和对方建立连接，框架会断开连接，如果返回非null，框架会把这个对象发送给对方&lt;/li&gt;
    * &lt;li&gt;注：请不要在这个方法中向对方发送任何消息，因为这个时候握手还没完成，发消息会导致协议交互失败。&lt;/li&gt;
    * &lt;li&gt;对于大部分业务，该方法只需要一行代码：return httpResponse;&lt;/li&gt;
    *
    * @param httpRequest
    * @param httpResponse
    * @param channelContext
    * @return
    * @throws Exception
    */
   @Override
   public HttpResponse handshake(HttpRequest httpRequest, HttpResponse httpResponse, ChannelContext channelContext) throws Exception {
      // 可以在此做一些业务逻辑，返回null表示不想连接
      return httpResponse;
   }

   /**
    * 握手成功后触发该方法
    *
    * @param httpRequest
    * @param httpResponse
    * @param channelContext
    * @throws Exception
    */
   @Override
   public void onAfterHandshaked(HttpRequest httpRequest, HttpResponse httpResponse, ChannelContext channelContext) throws Exception {
      // 拿到用户id
      String id = httpRequest.getParam("userId");
      // 绑定用户
      Tio.bindUser(channelContext, id);
      // 给用户发送消息
      JSONObject message = new JSONObject();
      message.put("msg", "连接成功...");
      message.put("sendName", "系统提醒");
      WsResponse wsResponse = WsResponse.fromText(message.toString(), "UTF-8");
      Tio.sendToUser(channelContext.tioConfig, id, wsResponse);
   }

   /**
    * &lt;li&gt;当收到Opcode.BINARY消息时，执行该方法。也就是说如何你的ws是基于BINARY传输的，就会走到这个方法&lt;/li&gt;
    *
    * @param wsRequest
    * @param bytes
    * @param channelContext
    * @return 可以是WsResponse、byte[]、ByteBuffer、String或null，如果是null，框架不会回消息
    * @throws Exception
    */
   @Override
   public Object onBytes(WsRequest wsRequest, byte[] bytes, ChannelContext channelContext) throws Exception {
      System.out.println("我走了onBytes");
      return null;
   }

   /**
    * 当收到Opcode.CLOSE时，执行该方法，业务层在该方法中一般不需要写什么逻辑，空着就好
    *
    * @param wsRequest
    * @param bytes
    * @param channelContext
    * @return 可以是WsResponse、byte[]、ByteBuffer、String或null，如果是null，框架不会回消息
    * @throws Exception
    */
   @Override
   public Object onClose(WsRequest wsRequest, byte[] bytes, ChannelContext channelContext) throws Exception {
      // 关闭连接
      Tio.remove(channelContext, "WebSocket Close");
      return null;
   }

   /**
    * &lt;li&gt;当收到Opcode.TEXT消息时，执行该方法。也就是说如何你的ws是基于TEXT传输的，就会走到这个方法&lt;/li&gt;
    *
    * @param wsRequest
    * @param text
    * @param channelContext
    * @return 可以是WsResponse、byte[]、ByteBuffer、String或null，如果是null，框架不会回消息
    * @throws Exception
    */
   @Override
   public Object onText(WsRequest wsRequest, String text, ChannelContext channelContext) throws Exception {
      JSONObject message = JSONObject.parseObject(text);
      // 接收消息的用户ID
      String receiver = message.getString("receiver");
      // 发送消息者
      String sendName = message.getString("sendName");
      // 消息
      String msg = message.getString("msg");

      // 保存聊天记录到DB等业务逻辑...

      WsResponse wsResponse = WsResponse.fromText(message.toString(), "UTF-8");
      Tio.sendToUser(channelContext.tioConfig, receiver, wsResponse);

      JSONObject resp = new JSONObject();
      resp.put("sendName", "系统提醒");
      resp.put("msg", "发送成功");
      return resp.toString();
   }
}</code></pre> 
<p>我们实现了 IWsMsgHandler 接口，并重写了该接口的 5 个方法，这 5 个方法从 发送握手包，到消息收发，到断开连接等一系列过程</p> 
<h2 id="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E2%80%8B%E7%BC%96%E8%BE%91">? 启动服务<img alt="" height="497" src="https://images2.imgbox.com/76/df/qhwjzi6A_o.png" width="1200">
</h2> 
<p> 启动成功后，可以看出 tio 的打印结果，我们可以看出服务端口为我们设置的 6789，我们便可以连接测试了</p> 
<p>前端代码(用脚写有点丑)：</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;websocket通讯&lt;/title&gt;
&lt;/head&gt;
&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--  连接--&gt;
    var socket;
    var userName;
    // 连接
    function connect() {
        var socketUrl = "ws://localhost:6789/?userId=" + $('#sendName').val();
        if (socket != null) {
            socket.close();
            socket = null;
        }
        socket = new WebSocket(socketUrl);
        //打开事件
        socket.onopen = function () {
            console.log("开始建立链接....")
        };
        //关闭事件
        socket.onclose = function () {
            console.log("websocket已关闭");
        };
        //发生了错误事件
        socket.onerror = function () {
            console.log("websocket发生了错误");
        };
        /**
         * 接收消息
         * @param msg
         */
        socket.onmessage = function (msg) {
            console.log(msg)
            var json = JSON.parse(msg.data);
            if (msg.msg != '连接成功') {
                $("#msgDiv").append('&lt;p class="other" style="color:olivedrab;"&gt;' + json.sendName + '：'+json.msg+'&lt;/p&gt;');
            }
        };
    }


    /**
     * 发送消息
     */
    function sendMessage() {
        var msg = $("#msg").val();
        if (msg == '' || msg == null) {
            alert("消息内容不能为空");
            return;
        }
        var receiver = $("#receiver").val();
        if (receiver == '' || receiver == null) {
            alert("接收人不能为空");
            return;
        }

        var sendName = $("#sendName").val();
        if (sendName == '' || sendName == null) {
            alert("发送人不能为空");
            return;
        }
        var msgObj = {
            "receiver": receiver,
            "sendName": sendName,
            "msg": msg
        };
         $("#msgDiv").append('&lt;p class="user" style="color: red"&gt;' + sendName + '：'+msg+'&lt;/p&gt;');
        try{
            socket.send(JSON.stringify(msgObj));
            $("#msg").val('');
        }catch (e) {
            alert("服务器内部错误");
        }
    }
&lt;/script&gt;
&lt;body&gt;
用户名：&lt;input type="text" id="sendName" value="李四"&gt;
&lt;input type="button" value="连接" onclick="connect()" &gt;&lt;br&gt;
发送者：&lt;input type="text" id="sender" value="李四" &gt;&lt;br&gt;
接受者：&lt;input type="text" id="receiver" value="张三"&gt;&lt;br&gt;&lt;br&gt;
消  息：&lt;textarea id="msg"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;input type="button" value="发送" onclick="sendMessage()"&gt;&lt;br&gt;&lt;br&gt;

消息记录：&lt;div id="msgDiv" style="border: 1px red solid;width: 400px;height: 200px"&gt;&lt;/div&gt;
&lt;br&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><img alt="" height="525" src="https://images2.imgbox.com/39/bf/VMUwpVYv_o.png" width="839"></p> 
<p>  这是小编在开发学习使用和总结，  这中间或许也存在着不足，希望可以得到大家的理解和建议。如有侵权联系小编！</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>