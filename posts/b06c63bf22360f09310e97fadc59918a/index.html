<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>知识工程总结 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">知识工程总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>知识工程部分重点内容</h3>
 <ul>
<li><a href="#1_1">1.知识工程的发展简史</a></li>
<li>
<ul>
<li><a href="#205070_2">知识工程的起源：20世纪50年代-70年代初</a></li>
<li>
<ul>
<li><a href="#_3">图灵奖获得历程</a></li>
<li><a href="#Edward_Feigenbaum_10">爱德华·费根鲍姆(Edward Feigenbaum)介绍</a></li>
<li><a href="#_13">达特茅斯会议后</a></li>
<li><a href="#1956_15">1956年</a></li>
<li><a href="#1960_17">1960年</a></li>
<li><a href="#206070_19">20世纪60年代-70年代初</a></li>
<li><a href="#1977_21">1977年</a></li>
</ul>
   </li>
<li><a href="#207090_23">知识工程的兴起与发展：20世纪70年代-90年代</a></li>
<li>
<ul>
<li><a href="#1977_24">1977年之后</a></li>
<li><a href="#1998_26">1998年-万维网与连接数据</a></li>
</ul>
   </li>
<li><a href="#_28">知识工程新发展时期</a></li>
</ul>
  </li>
<li><a href="#2_30">2.知识图谱的定义</a></li>
<li>
<ul>
<li><a href="#_31">什么是知识图谱</a></li>
<li><a href="#_34">知识图谱概念演变</a></li>
</ul>
  </li>
<li><a href="#3_41">3.知识图谱的代表性项目有哪些，特点是什么</a></li>
<li>
<ul>
<li><a href="#CYC_42">CYC</a></li>
<li><a href="#WordNet_44">WordNet</a></li>
<li><a href="#ConceptNet_46">ConceptNet</a></li>
<li><a href="#FreeBase_48">FreeBase</a></li>
<li><a href="#WikiData_50">WikiData</a></li>
</ul>
  </li>
<li><a href="#4_52">4.常用的知识表示方法有哪些，特点是什么</a></li>
<li>
<ul>
<li><a href="#_53">一阶谓词逻辑</a></li>
<li><a href="#_55">产生式规则</a></li>
<li><a href="#_57">框架系统</a></li>
<li><a href="#_59">语义网络</a></li>
</ul>
  </li>
<li><a href="#5RDFRDFSOWLTrans_61">5.知识图谱的符号化表示(RDF、RDFS、OWL)，向量表示(Trans系列算法)</a></li>
<li>
<ul>
<li><a href="#_62">符号表示</a></li>
<li>
<ul>
<li><a href="#RDF_63">RDF</a></li>
<li><a href="#RDFS_65">RDFS</a></li>
<li><a href="#OWL_67">OWL</a></li>
<li><a href="#Trans_69">Trans系列算法</a></li>
</ul>
  </li>
</ul>
  </li>
<li><a href="#6_71">6.实体识别的三类常用方法，优缺点有哪些</a></li>
<li>
<ul>
<li><a href="#_74">基于模板和规则的方法</a></li>
<li><a href="#HMMCRF_76">基于序列标注的机器学习方法(HMM隐马尔可夫模型和CRF条件随机场)</a></li>
<li><a href="#_79">基于深度学习方法</a></li>
</ul>
  </li>
<li><a href="#7HMMCRF_81">7.基于序列标注的机器学习方法，HMM、CRF的基本原理</a></li>
<li>
<ul>
<li><a href="#HMM_82">HMM</a></li>
<li><a href="#CRF_84">CRF</a></li>
</ul>
  </li>
<li><a href="#8_86">8.关系抽取的三类常用方法，优缺点有哪些(依存句法分析)</a></li>
<li>
<ul>
<li><a href="#_87">基于模板的方法(依存句法分析)</a></li>
<li><a href="#_89">基于传统机器学习的方法</a></li>
<li>
<ul>
<li><a href="#_90">基于特征向量的方法</a></li>
<li><a href="#_92">基于核函数的方法</a></li>
</ul>
   </li>
<li><a href="#_94">基于深度学习的方法</a></li>
</ul>
  </li>
<li><a href="#9_96">9.知识融合两种方式是什么，常用工具有哪些，实体对齐的常用方法有哪些</a></li>
<li>
<ul>
<li><a href="#_98">本体匹配</a></li>
<li><a href="#_101">实体对齐</a></li>
<li>
<ul>
<li><a href="#_104">聚类</a></li>
<li><a href="#_106">表示学习</a></li>
</ul>
  </li>
</ul>
  </li>
<li><a href="#10_108">10.基于关系数据库的存储方案有哪两种，基本原理是什么，优缺点有哪些</a></li>
<li>
<ul>
<li><a href="#_110">水平划分</a></li>
<li><a href="#_113">垂直划分</a></li>
</ul>
  </li>
<li><a href="#11_116">11.基于图模型的存储有何优点，属性图模型如何存储数据，典型系统是什么</a></li>
<li><a href="#12SQLSPARQLCypher_120">12.SQL查询语句、SPARQL的四种查询形式、Cypher查询语句</a></li>
<li>
<ul>
<li><a href="#SQL_121">SQL查询语句</a></li>
<li><a href="#SPARQL_137">SPARQL</a></li>
<li><a href="#Cypher_139">Cypher查询语句</a></li>
<li>
<ul><li><a href="#_144">结果修改器</a></li></ul>
  </li>
</ul>
  </li>
<li><a href="#13_161">13.问答系统的发展简史，不同时期的代表性系统或平台</a></li>
<li><a href="#14_167">14.知识库问答三种常见方法(基本原理)，优缺点有哪些</a></li>
<li>
<ul>
<li><a href="#_168">基于模板的问答方法</a></li>
<li><a href="#_171">基于语义解析的问答方法</a></li>
<li><a href="#_174">基于深度学习的问答方法</a></li>
</ul>
  </li>
<li><a href="#15ElasticsearchgAnswer_176">15.Elasticsearch系统、gAnswer系统的主要算法框架是什么，优缺点有哪些</a></li>
<li>
<ul>
<li><a href="#Elasticsearch_177">Elasticsearch</a></li>
<li><a href="#gAnswer_180">gAnswer</a></li>
</ul>
  </li>
<li><a href="#16_183">16.传统推理的三种形式</a></li>
<li>
<ul>
<li><a href="#_184">演绎推理</a></li>
<li><a href="#_186">归纳推理</a></li>
<li><a href="#_188">溯因推理</a></li>
</ul>
  </li>
<li><a href="#17PRAAMIE_190">17.归纳推理算法PRA，AMIE的基本原理</a></li>
<li>
<ul>
<li><a href="#PRA_191">PRA：路径排序算法</a></li>
<li><a href="#AMIE_197">AMIE：规则挖掘算法</a></li>
</ul>
  </li>
<li><a href="#18TransETransHTransC_199">18.嵌入式模型TransE、TransH、TransC的基本原理和优缺点</a></li>
<li>
<ul>
<li><a href="#TransE_200">TransE</a></li>
<li><a href="#TransH_203">TransH</a></li>
<li><a href="#TransC_206">TransC</a></li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<h1>
<a id="1_1"></a>1.知识工程的发展简史</h1> 
<h2>
<a id="205070_2"></a>知识工程的起源：20世纪50年代-70年代初</h2> 
<h3>
<a id="_3"></a>图灵奖获得历程</h3> 
<p>1969年，Minsky，感知机和框架知识表示；<br> 1971年，McCarthy，LISP语言、Advice Taker系统；<br> 1975年，Newell和Simon，形式化语言、通用问题求解；<br> 1994年，Feigenbaum，知识工程提出者；<br> 2011年，Judea Pearl，概率图模型之父；<br> 2016年，Berners-Lee，语义网；</p> 
<h3>
<a id="Edward_Feigenbaum_10"></a>爱德华·费根鲍姆(Edward Feigenbaum)介绍</h3> 
<p>费根鲍姆带领了专家系统的诞生，其由两部分组成：知识库和推理引擎。第一个成功的专家系统Dendral于1968年问世，在1977年被费根鲍姆正式命名为知识工程。其有一句流传甚广的名言：“Knowledge is the power in AI”。<br> 下面介绍一下具体的时间历程。</p> 
<h3>
<a id="_13"></a>达特茅斯会议后</h3> 
<p>参会者们取得了一系列成果，具有代表性的是由A.Newell、J.Shaw和H.Simon等人编制的逻辑机LT ，它证明了38条数学定理，其中Newell和Simon是符号主义学派的代表人物。</p> 
<h3>
<a id="1956_15"></a>1956年</h3> 
<p>1956年由Samuel研制的具有自学习功能的跳棋程序掀起人工智能发展的第一个高潮。</p> 
<h3>
<a id="1960_17"></a>1960年</h3> 
<p>1960年又定义了GPS的逻辑推理架构，并提出启发式搜索的思路。</p> 
<h3>
<a id="206070_19"></a>20世纪60年代-70年代初</h3> 
<p>人工智能迎来第一次寒冷的冬天。</p> 
<h3>
<a id="1977_21"></a>1977年</h3> 
<p>知识工程诞生，Feigenbaum分析传统人工智能忽略了具体的知识，人工智能必须引进知识。</p> 
<h2>
<a id="207090_23"></a>知识工程的兴起与发展：20世纪70年代-90年代</h2> 
<h3>
<a id="1977_24"></a>1977年之后</h3> 
<p>在知识工程诞生之后，这个领域还在不断往前发展，不断产生新的逻辑语言和方法。美国DEC公司的专家系统XCON在6年内共处理了8万个订单。</p> 
<h3>
<a id="1998_26"></a>1998年-万维网与连接数据</h3> 
<p>1998年，万维网之父蒂姆·伯纳斯·李再次提出语义网。同时由于自顶向下的设计落地困难，学者们将目光转移到数据本身上来，提出了连接数据的概念。</p> 
<h2>
<a id="_28"></a>知识工程新发展时期</h2> 
<p>2012年是知识图谱的提出，其前身是Freebase，与维基百科同时存在。但维基百科的受众是人，而Freebase则强调机器可读。在被收购后谷歌为其起了个响亮的名字“知识图谱”。</p> 
<h1>
<a id="2_30"></a>2.知识图谱的定义</h1> 
<h2>
<a id="_31"></a>什么是知识图谱</h2> 
<p>知识图谱最早由Google在2012年正式提出，是一种表示现实以及认知世界中各种对象之间关联关系的语义网络，可以对现实世界的实物及其相互关系进行形式化地描述。<br> 知识图谱是一种用图模型来描述知识和建模世界万物之间的关联关系的技术方法。由节点和边组成。节点既可以是具体的实物也可以是抽象的概念，边可以用于描述节点的属性，也可以描述节点和节点之间的关系。</p> 
<h2>
<a id="_34"></a>知识图谱概念演变</h2> 
<p>1960年语义网络：语义网络的作用在于表示知识，主要用于自然语言理解领域；<br> 1980s知识表示：提出知识表示方法如：产生式系统、框架系统等/本体论：于人工智能领域引入本体的概念来描述知识；<br> 1989Web：万维网是一个连接信息的系统；<br> 1998语义网：从信息连接到语义网络；<br> 2006连接数据：建立开放的数据之间的链接；<br> 2012知识图谱：谷歌提出知识图谱的概念并应用于智能搜索；</p> 
<h1>
<a id="3_41"></a>3.知识图谱的代表性项目有哪些，特点是什么</h1> 
<h2>
<a id="CYC_42"></a>CYC</h2> 
<p>其特点是基于形式化的知识表示方法来刻画知识，可以支持复杂的推理。</p> 
<h2>
<a id="WordNet_44"></a>WordNet</h2> 
<p>其特点是定义名词、动词、形容词和副词间的语义关系，主要用于语义消歧。</p> 
<h2>
<a id="ConceptNet_46"></a>ConceptNet</h2> 
<p>其特点是依靠互联网、专家创建和游戏三种方法来构建，知识库以三元组形式的关系型知识构成，采用了非形式化、更接近自然语言的描述，同时比较侧重词与词之间的关系。</p> 
<h2>
<a id="FreeBase_48"></a>FreeBase</h2> 
<p>其特点是整合了许多网上的资源，是一个由元数据组成的大型合作知识库。</p> 
<h2>
<a id="WikiData_50"></a>WikiData</h2> 
<p>其特点是起结构化数据中央存储的作用，是一个免费开放的知识库。</p> 
<h1>
<a id="4_52"></a>4.常用的知识表示方法有哪些，特点是什么</h1> 
<h2>
<a id="_53"></a>一阶谓词逻辑</h2> 
<p>其特点是自然性、严密性和易实现性，但其表达能力有限、易出现组合爆炸以及效率低。</p> 
<h2>
<a id="_55"></a>产生式规则</h2> 
<p>其特点是自然性、模块性、有效性和清晰性，但其不能表达结构性知识、易出现组合爆炸以及效率低。</p> 
<h2>
<a id="_57"></a>框架系统</h2> 
<p>其特点是对知识的描述完整全面和允许数值计算，但其构建成本非常高、对知识库质量的要求非常高以及表达形式不灵活。</p> 
<h2>
<a id="_59"></a>语义网络</h2> 
<p>其特点是自然性、结构性和联想性，但其非严格性、不能保证推理正确以及处理上很复杂。</p> 
<h1>
<a id="5RDFRDFSOWLTrans_61"></a>5.知识图谱的符号化表示(RDF、RDFS、OWL)，向量表示(Trans系列算法)</h1> 
<h2>
<a id="_62"></a>符号表示</h2> 
<h3>
<a id="RDF_63"></a>RDF</h3> 
<p>RDF由(Subject(主)，Predicate(谓)，Object(宾))三元组组成。</p> 
<h3>
<a id="RDFS_65"></a>RDFS</h3> 
<p>其包含Class(类)，subClassOf(子类)，type(类型)，Property(属性)，subPropertyOf(子属性)，Domain(定义域)，Range(值域)。</p> 
<h3>
<a id="OWL_67"></a>OWL</h3> 
<p>理想情况下，OWL应该是RDFS的一个扩展，其表达构件有等价性声明、声明属性的传递性、声明两个属性互反、声明属性的函数性、声明属性的对称性和声明属性的局部约束：全称限定。</p> 
<h3>
<a id="Trans_69"></a>Trans系列算法</h3> 
<p>TransE对每个事实(head，relation，tail)将relation看做从head到tail的翻译操作，其优化目标为h+r=t，当三元组(h,r,t)符合h+r≈t时三元组成立。</p> 
<h1>
<a id="6_71"></a>6.实体识别的三类常用方法，优缺点有哪些</h1> 
<h2>
<a id="_74"></a>基于模板和规则的方法</h2> 
<p>其优点是当词汇表足够大时，能够取得不错效果；缺点是总结规则模板花费大量时间，词汇表规模小，且实体识别结果普遍高精度、低召回。</p> 
<h2>
<a id="HMMCRF_76"></a>基于序列标注的机器学习方法(HMM隐马尔可夫模型和CRF条件随机场)</h2> 
<p>HMM更适用于一些对实时性有要求以及像信息检索这样需要处理大量文本的应用；CRF特征灵活，但收敛速度慢，训练时间长。<br> 整体对特征选取的要求高，对语料库的依赖大，可用的语料库较少。</p> 
<h2>
<a id="_79"></a>基于深度学习方法</h2> 
<p>其优点是强大的向量表示能力，神经网络强大的计算能力以及端到端的训练方式。</p> 
<h1>
<a id="7HMMCRF_81"></a>7.基于序列标注的机器学习方法，HMM、CRF的基本原理</h1> 
<h2>
<a id="HMM_82"></a>HMM</h2> 
<p>HMM是有向图模型，由隐状态序列指向观察输出序列，同时假设特征之间是独立的。其任意时刻的隐藏状态只依赖于它前一个隐藏态，且任意时刻的观察状态只依赖于当前时刻的隐藏态。</p> 
<h2>
<a id="CRF_84"></a>CRF</h2> 
<p>随机场是给每个位置按照某种分布都随机赋予一个值，马尔科夫随机场是假设随机场中某一个位置的赋值仅与其相邻位置的赋值有关，CRF则假设马尔科夫随机场中只有X和Y两种变量：X是给定的，Y是在给定X条件下的输出。</p> 
<h1>
<a id="8_86"></a>8.关系抽取的三类常用方法，优缺点有哪些(依存句法分析)</h1> 
<h2>
<a id="_87"></a>基于模板的方法(依存句法分析)</h2> 
<p>其优点是在小规模数据集上容易实现，构件简单；缺点是特定领域的模板需要专家构建、难以维护、可移植性差以及规则集合小的时候召回率低。</p> 
<h2>
<a id="_89"></a>基于传统机器学习的方法</h2> 
<h3>
<a id="_90"></a>基于特征向量的方法</h3> 
<p>其优点是可解释性好；缺点是特征的选择更多依靠构建者的直觉和经验，特征项的选择组合是有限的，无法表示指定语义关系。</p> 
<h3>
<a id="_92"></a>基于核函数的方法</h3> 
<p>其优点是处理高维问题计算代价低，求解的是凸优化问题，核矩阵展现输入在特征空间中相对位置的信息；缺点是随着性能要求的提升，核函数的复合更为复杂，导致训练和测试过慢，对于大规模数据处理能力差。</p> 
<h2>
<a id="_94"></a>基于深度学习的方法</h2> 
<p>同问题6。</p> 
<h1>
<a id="9_96"></a>9.知识融合两种方式是什么，常用工具有哪些，实体对齐的常用方法有哪些</h1> 
<p>知识融合的两种方式是本体匹配和实体对齐。</p> 
<h2>
<a id="_98"></a>本体匹配</h2> 
<p>常用工具为Falcon-AO，是一个自动的本体匹配系统。</p> 
<h2>
<a id="_101"></a>实体对齐</h2> 
<p>常用工具为Dedupe库(Python)以及Silk系统。<br> 相似度计算的常用方法有聚类和表示学习。</p> 
<h3>
<a id="_104"></a>聚类</h3> 
<p>包含层次聚类、相关性聚类和Canopy+K-means聚类。</p> 
<h3>
<a id="_106"></a>表示学习</h3> 
<p>知识嵌入：将实体和关系映射为低维向量，用表达式来获得实体间相似度。不依赖文本信息，只获取数据的深度特征。</p> 
<h1>
<a id="10_108"></a>10.基于关系数据库的存储方案有哪两种，基本原理是什么，优缺点有哪些</h1> 
<p>水平划分和垂直划分。</p> 
<h2>
<a id="_110"></a>水平划分</h2> 
<p>基本原理是使用一张N+1列数据表存储RDF数据集(N为数据集中不同谓词数目)，基于主语对RDF数据集进行划分，每行记录主语的所有谓语和宾语，宾语不存在时使用空值填充。<br> 其优点是将同一主语所有数据存储在一行，有利于星型SPARQL查询；Join减少了，接近于关系数据库。缺点是数据表中可能存在大量空值，引入了存储和查询额外空值的开销；数据表中列数目等于RDF中不同谓语数量，可能超过关系数据库所允许的表中列数目上限。</p> 
<h2>
<a id="_113"></a>垂直划分</h2> 
<p>基本原理是使用N张两列表存储RDF数据集(N为数据集中不同谓词个数)，基于谓词对RDF数据集进行划分，表中每行是该谓词连接的一对主语和宾语。<br> 其优点是仅存储出现在RDF数据集中的三元组，不存储空值；解决了多值问题；基于主语排序，能使用归并排序连接快速执行Join。缺点是两列表数目与谓语个数相等，数量较大时难以维护；对于具有n条边的SPARQL查询，需要读取n张数据表，执行n-1次Join。</p> 
<h1>
<a id="11_116"></a>11.基于图模型的存储有何优点，属性图模型如何存储数据，典型系统是什么</h1> 
<p>优点是自然表达易于建模，便于扩展，关系查询高效以及多跳优化。<br> 属性图模型由顶点集和边集组成：节点可以有一个或多个标签，一组属性，每个属性是一个键值对；边有一个类型和方向，也可以有属性。<br> 属性图模型的典型系统是neo4j。</p> 
<h1>
<a id="12SQLSPARQLCypher_120"></a>12.SQL查询语句、SPARQL的四种查询形式、Cypher查询语句</h1> 
<h2>
<a id="SQL_121"></a>SQL查询语句</h2> 
<p>SQL结构化查询语言，是关系数据库的标准语言，其查询只用SELECT：<br> 1.查询全体学生的学号与姓名<br> SELECT Sno，Sname<br> FROM Student;<br> 2.查询全体学生的详细记录<br> SELECT *<br> FROM Student;<br> 3.查询经过计算的值<br> SELECT Sname，2004-Sge<br> FROM Student;<br> 4.比较大小<br> SELECT Sname，Sage<br> FROM Student<br> WHERE Sage &lt; 20;<br> WHERE后还可加(NOT)BETWEEN…AND…；Sx =/(NOT)LIKE ’ '，字符串可以是固定的，可以含通配符：刘%，欧阳__，__阳%。</p> 
<h2>
<a id="SPARQL_137"></a>SPARQL</h2> 
<p>其四种查询形式分别为：SELECT(任意返回)，CONSTRUCT(返回RDF)，ASK(返回yes/no)，DESCRIBE(返回与给定图形模式匹配的节点的所有信息)</p> 
<h2>
<a id="Cypher_139"></a>Cypher查询语句</h2> 
<p>MATCH+WHERE+RETURN<br> MATCH (emp:Employee)<br> WHERE emp.name = ‘Abc’<br> RETURN emp</p> 
<h3>
<a id="_144"></a>结果修改器</h3> 
<p>1.MATCH+SET+RETURN<br> MATCH (dc:DebitCard)<br> SET dc.atm_pin = 3456<br> RUTURN dc<br> 2.MATCH+RETURN+ORDER BY<br> MATCH (emp:Employee)<br> RETURN emp.empid,emp.name,emp.salary,emp.depyno<br> ORDER BY emp.name DESC<br> 3.MATCH+RETURN+LIMIT<br> MATCH (emp.Employee)<br> RETURN emp<br> LIMIT 2<br> 4.MATCH+WHERE+IN+RETURN<br> MATCH (e:Employee)<br> WHERE e.id IN [123,124]<br> RETURN e.id,e.name,e.sal,e.deptno</p> 
<h1>
<a id="13_161"></a>13.问答系统的发展简史，不同时期的代表性系统或平台</h1> 
<p>1960：基于模板的问答专家系统(BaseBall,LUNAR,MACSYMA,SHRDLE)<br> 1990：基于信息检索的问答(MASQUE TREC)<br> 2000：基于社区的问答(YAHOO,百度,知乎)<br> 2010：基于知识图谱的问答(WolframAlpha)</p> 
<h1>
<a id="14_167"></a>14.知识库问答三种常见方法(基本原理)，优缺点有哪些</h1> 
<h2>
<a id="_168"></a>基于模板的问答方法</h2> 
<p>主要流程为模板定义、模板生成和模板匹配。<br> 其优点是模板查询响应速度快；准确率较高，可以回答相对复杂的问题。缺点是人工定义的模板容易无法与真实的用户问题进行匹配；若要匹配一个问题的不同表述，则需要建立庞大的模板库，耗时且查询效率低。</p> 
<h2>
<a id="_171"></a>基于语义解析的问答方法</h2> 
<p>主要流程为资源映射、Logic Form、候选答案生成和排序。<br> 其优点是可以回答较为复杂的问题，例如时序性问题。缺点是人工编写规则工程量大。</p> 
<h2>
<a id="_174"></a>基于深度学习的问答方法</h2> 
<p>其优点是无需人工编写规则定义模板，整个学习过程都是自动进行。缺点是只能处理简单题和单边关系问题，且深度学习方法不包含聚类操作，无法应对时序性问题。</p> 
<h1>
<a id="15ElasticsearchgAnswer_176"></a>15.Elasticsearch系统、gAnswer系统的主要算法框架是什么，优缺点有哪些</h1> 
<h2>
<a id="Elasticsearch_177"></a>Elasticsearch</h2> 
<p>Elasticsearch是基于Lucene开发的分布式搜索框架。<br> 其优点是分布式索引、搜索；索引自动分片、负载均衡；自动发现机器、组建集群；支持Restful风格接口；配置简单。缺点为只支持简单的自然语句查询，无法回答复杂的问题；在添加新数据与新字段的时候，进行搜索可能需要修改格式；Elasticsearch是基于符号逻辑的，符号匹配会造成语义鸿沟。</p> 
<h2>
<a id="gAnswer_180"></a>gAnswer</h2> 
<p>gAnswer使用关系优先框架和结点优先框架将消歧和查询评估结合在一起：其中关系优先框架解决了歧义问题，结点优先框架解决了查询的模糊性。<br> 其优点是在问题理解阶段允许歧义，在查询评估阶段消歧；有效地解决了模糊问题。缺点是难以解决复杂问题。</p> 
<h1>
<a id="16_183"></a>16.传统推理的三种形式</h1> 
<h2>
<a id="_184"></a>演绎推理</h2> 
<p>从一般的前提出发通过推导得出具体结论的过程(从一般到特殊)。</p> 
<h2>
<a id="_186"></a>归纳推理</h2> 
<p>通过观察客观事实进而总结和归纳抽象知识的推理过程(从特殊到一般)。</p> 
<h2>
<a id="_188"></a>溯因推理</h2> 
<p>将抽象的规则知识与观察现象结合，寻找可能原因的推理过程。</p> 
<h1>
<a id="17PRAAMIE_190"></a>17.归纳推理算法PRA，AMIE的基本原理</h1> 
<h2>
<a id="PRA_191"></a>PRA：路径排序算法</h2> 
<p>通过实体间存在的路径判断实体间是否存在指定关系，具体流程是特征抽取、特征计算以及分类器训练：<br> 1.先对于给定关系生成训练样例，包含正例和负例；<br> 2.从知识图谱采样得到正例和负例的路径，每一路径连接每个样例中的两个实体；<br> 3.对于每个样例，判断步骤2中所有路径是否能连接其包含的两个实体，将可以记为1和不可以记为0作为特征，故每一个样本都能得到一个n维特征向量(n为2中路径总数)；<br> 4.依据训练样本，训练分类器M；</p> 
<h2>
<a id="AMIE_197"></a>AMIE：规则挖掘算法</h2> 
<p>从不完备的知识库中挖掘规则，具体算法是对于每种关系，从规则体为空开始，通过三种扩展操作(添加悬挂边、添加实例边、添加闭合边)，保留支持度大于阈值的规则。评价准则为支持度(同时符合规则体和规则头的实例数目)、置信度(支持度除以仅符合规则体的实例数)和PCA置信度(只将满足规则替补并且存在的三元组才计入分母，考虑了知识图谱的不完备性)。</p> 
<h1>
<a id="18TransETransHTransC_199"></a>18.嵌入式模型TransE、TransH、TransC的基本原理和优缺点</h1> 
<h2>
<a id="TransE_200"></a>TransE</h2> 
<p>把每个三元组(h，r，t)中的关系r看作从实体h到实体t的翻译，通过不断调整h、r和t，使(h+r)和t尽可能相等。<br> 其优点是简单有效，但缺点是存在自反性问题和只适合处理一对一问题，不适合处理一对多、多对一和多对多复杂关系。</p> 
<h2>
<a id="TransH_203"></a>TransH</h2> 
<p>对于每一个关系，都定义一个超平面Wr和一个关系dr，将三元组中的头尾实体分别映射到该超平面中。<br> 其优点是每个实体在不同的关系下有不同的表示，缺点是仍然假设实体和关系处于相同的语义空间中。</p> 
<h2>
<a id="TransC_206"></a>TransC</h2> 
<p>将每个概念编码为球体，将每个实例编码为向量，在相同的语义空间中，使用相对位置对概念和实例、概念和子概念之间的关系进行建模。<br> 其优点是将概念和实例进行了区分，缺点是用球来表示概念，简单模型过于幼稚，存在一定的局限性，一个概念在不同的三元组中可能有不同的含义。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>