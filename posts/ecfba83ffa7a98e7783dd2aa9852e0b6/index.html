<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Online Decision Transformer - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Online Decision Transformer</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="_0"></a>摘要</h1> 
<ul><li>最近的工作表明，离线强化学习 (RL) 可以表述为序列建模问题 (Chen et al., 2021; Janner et al., 2021)，并通过类似于大规模语言建模的方法来解决。 然而，RL 的任何实际实例化还涉及在线组件，其中在被动离线数据集上预训练的策略通过与环境的特定任务交互进行微调。 我们提出了在线决策Transformer(ODT)，这是一种基于序列建模的 RL 算法，<mark>将离线预训练与在线微调融合在一个统一的框架中</mark>。 我们的框架使用序列级熵正则化器与自回归建模目标相结合，以实现样本有效的探索和微调。 根据经验，我们表明 ODT 在 D4RL 基准测试的绝对性能上与最先进的技术具有竞争力，但在微调过程中显示出更显着的收益。</li></ul> 
<h1>
<a id="_2"></a>引言</h1> 
<ul>
<li>序列建模的生成式预训练已成为许多领域和模式中机器学习的统一范式，特别是在语言和视觉方面（Radford 等人，2018；Chen 等人，2020；Brown 等人，2020；Lu 等人， 2022）。 最近，这种预训练范式已扩展到离线强化学习 (RL)（Chen 等人，2021 年；Janner 等人，2021 年），其中训练代理以自回归最大化离线数据集中轨迹的可能性。 在训练期间，这种范式本质上将离线 RL 转换为监督学习问题（Schmidhuber，2019；Srivastava 等人，2019；Emmons 等人，2021）。 然而，这些工作呈现出不完整的画面，因为通过离线 RL 学习的策略受到训练数据集质量的限制，需要通过在线交互对感兴趣的任务进行微调。 这种监督学习范式是否可以扩展到在线环境仍然是一个悬而未决的问题。</li>
<li>与语言和感知不同，RL 的在线微调与预训练阶段根本不同，因为它涉及通过探索获取数据。 对探索的需求使得离线 RL 的传统监督学习目标（例如，均方误差）在在线环境中不足。 此外，据观察，对于标准在线算法，访问离线数据通常会对在线性能产生零甚至负面影响（Nair 等，2020）。 因此，离线预训练的整体流程以及对 RL 策略的在线微调需要仔细考虑训练目标和协议。</li>
<li>我们介绍了在线决策变压器（ODT），这是一种RL的学习框架，它将离线预训练与在线微调相结合，以实现样本高效的策略优化。我们的框架建立在先前为离线RL引入的决策变换器（DT）（Chen et al，2021）架构的基础上，特别适用于在线交互成本高昂的场景，这需要离线预训练和样本有效的微调。我们确定了与DTs不兼容的几个关键缺点，并对其进行了纠正，从而为我们的整体渠道带来了卓越的性能。</li>
<li>首先，我们从<mark>确定性政策转向随机政策</mark>，以确定在线阶段的探索目标。我们<mark>通过类似于最大RL框架的策略熵来量化探索（Levine，2018</mark>。然而，与传统框架不同的是，ODT的策略熵在轨迹的总体水平上受到限制（与单个时间步长相反），并且其双重形式规范了监督学习目标（与直接收益最大化相反）。接下来，我们开发了一种与ODT的体系结构和训练协议一致的<mark>新型重放缓冲区</mark>（Mnih等，2015）。<mark>缓冲区存储轨迹，并通过ODT的在线推出进行填充</mark>。由于ODT参数化返回条件策略，我们进一步研究在在线推出期间指定所需返回的策略。但是，此值可能与推出期间观察到的真实返回不匹配。为了应对这一挑战，我们<mark>将后验experience replay（Andrychowicz等，2017）的概念扩展到我们的设置</mark>，并在增强它们之前用正确的return tokens重新标记推出的轨迹。</li>
<li>根据经验，我们通过将其性能与D4RL基准上的最新算法进行比较来验证我们的整体框架（Fu等，2020）。我们发现，由于我们的微调策略，我们的相对改进优于其他基线（Nair等，2020；Kostrikov等，2021a），同时在考虑基础模型的预训练结果时表现出竞争性的绝对表现。最后，我们通过严格的消融和额外的实验设计来补充我们的主要结果，以证明和验证我们方法的关键组成部分。</li>
</ul> 
<h1>
<a id="_8"></a>相关工作</h1> 
<ul>
<li>我们的工作包括两个广泛的研究途径，我们在这里详细介绍。</li>
<li>
<strong>RL的Transformer</strong>。最近令人兴奋的进展是将离线RL问题制定为上下文条件序列建模问题（Chen等，2021；Janner等，2021）。这些工作建立在强化学习作为监督学习范式（Schmidhuber，2019；Srivastava等，2019；Emmons等，2021）的基础上，其侧重于以任务规范（例如，target goal或return）为条件的动作序列的预测建模，<mark>而不是显式学习Q函数或策略梯度</mark>。Chen等人（2021）将Transformer训练为无模型上下文条件策略，Janner等人（2021）将Transformer训练为策略和模型，并表明波束搜索可用于改进纯无模型性能。然而，这些工作仅探索离线RL设置，其类似于Transformer传统上在自然语言处理应用中训练的固定数据集。我们的工作重点是将这些结果扩展到在线微调环境，显示出与最先进的RL方法的竞争力。</li>
<li>离线RL方法主要将conservative保守组件添加到现有的非策略RL方法中以防止分布外推，但需要对超参数进行许多调整和重新调整才能起作用（Kumar等，2020a；Kostrikov等，2021b））。与我们的工作类似，Fujimoto和Gu（2021）展示了将行为克隆术语添加到离线RL方法的好处，并且该术语的简单添加允许将非策略RL算法以最小的变化移植到离线设置。</li>
<li>
<strong>离线RL与在线微调</strong>。虽然ODT源于与传统RL方法不同的视角，但现有的许多工作都集中在对给定离线数据集进行预训练的相同范例上，并在在线环境中进行微调。Nair等人（2020）表明，将离线或非策略性RL方法应用于离线预培训和在线微调制度往往无助于甚至阻碍绩效。这种政策外方法的不良表现可归因于政策外引导错误积累（Munos，20032005；Farahmand等，2010；Kumar等，2019）。在离线RL方法中，在线微调制度中的不良表现可以通过过度保守来解释，这在离线制度中是必要的，以防止价值高估超出分配状态。Nair等人（2020）首次提出了一种适用于离线和在线培训制度的算法。最近的工作（Kostrikov et al。，2021a）也提出了一种基于期望的离线RL隐式Q学习算法，该算法也显示出强大的在线微调性能，因为该策略是通过避免分发外行为的行为克隆步骤提取的动作。</li>
<li>Lee等人（2021）通过平衡重放方案和一系列功能来解决离线在线设置问题，以在离线培训期间保持保守主义。Lu等人（2021）改进了AWAC（Nair et al。，2020），它在在线微调阶段表现出崩溃，在在线阶段纳入了积极的抽样和探索。我们还发现积极的抽样和探索是良好的在线微调的关键，但是我们将展示ODT中这些特征是如何自然发生的，从而导致一种简单的端到端方法，可以自动适应离线和在线设置。</li>
</ul> 
<h1>
<a id="_14"></a>预赛</h1> 
<ul><li>我们假设我们的环境可以建模为马尔可夫决策过程 (MDP)，可以描述为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         M
        
        
         =
        
        
         &lt;
        
        
         S
        
        
         ,
        
        
         A
        
        
         ,
        
        
         p
        
        
         ,
        
        
         P
        
        
         ,
        
        
         R
        
        
         ,
        
        
         γ
        
        
         &gt;
        
       
       
        M=&lt;S, A, p, P, R, γ&gt;
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.10903em">M</span><span class="mspace" style="margin-right: 0.277778em"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height: 0.5782em;vertical-align: -0.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em"></span></span><span class="base"><span class="strut" style="height: 0.87777em;vertical-align: -0.19444em"></span><span class="mord mathdefault" style="margin-right: 0.05764em">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em"></span><span class="mord mathdefault" style="margin-right: 0.13889em">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em"></span><span class="mord mathdefault" style="margin-right: 0.00773em">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em"></span><span class="mord mathdefault" style="margin-right: 0.05556em">γ</span><span class="mspace" style="margin-right: 0.277778em"></span><span class="mrel">&gt;</span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         S
        
       
       
        S
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.05764em">S</span></span></span></span></span> 是状态空间，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         A
        
       
       
        A
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord mathdefault">A</span></span></span></span></span> 是动作空间，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         P
        
        
         (
        
        
         
          s
         
         
          
           t
          
          
           +
          
          
           1
          
         
        
        
         ∣
        
        
         
          s
         
         
          t
         
        
        
         ，
        
        
         
          a
         
         
          t
         
        
        
         )
        
       
       
        P(s_{t+1}|s_t，a_t)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathdefault" style="margin-right: 0.13889em">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em"><span class=""></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 是转换的概率分布，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         R
        
        
         (
        
        
         
          s
         
         
          t
         
        
        
         ，
        
        
         
          a
         
         
          t
         
        
        
         )
        
       
       
        R(s_t，a_t)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathdefault" style="margin-right: 0.00773em">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 是奖励函数，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         γ
        
       
       
        γ
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em;vertical-align: -0.19444em"></span><span class="mord mathdefault" style="margin-right: 0.05556em">γ</span></span></span></span></span> 是折扣因子（Bellman，1957）。 代理从从固定分布 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         p
        
        
         (
        
        
         
          s
         
         
          1
         
        
        
         )
        
       
       
        p(s_1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 采样的初始状态 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          s
         
         
          1
         
        
       
       
        s_1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span> 开始，然后在每个时间步 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         t
        
       
       
        t
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.61508em;vertical-align: 0em"></span><span class="mord mathdefault">t</span></span></span></span></span> 它从状态 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          s
         
         
          t
         
        
        
         ∈
        
        
         S
        
       
       
        s_t in S
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6891em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em"></span></span><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.05764em">S</span></span></span></span></span> 在 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          a
         
         
          t
         
        
        
         ∈
        
        
         A
        
       
       
        a_t in A
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6891em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em"></span></span><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord mathdefault">A</span></span></span></span></span> 采取行动并移动到下一个状态 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          s
         
         
          
           t
          
          
           +
          
          
           1
          
         
        
        
          
        
        
         P
        
        
         (
        
        
         ⋅
        
        
         ∣
        
        
         
          s
         
         
          t
         
        
        
         ,
        
        
         
          a
         
         
          t
         
        
        
         )
        
       
       
        s_{t+1}~P(cdot |s_t, a_t)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em"><span class=""></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord mathdefault" style="margin-right: 0.13889em">P</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。 在每个动作之后，代理都会收到一个确定性的奖励 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          r
         
         
          t
         
        
        
         =
        
        
         R
        
        
         (
        
        
         
          s
         
         
          t
         
        
        
         ,
        
        
         
          a
         
         
          t
         
        
        
         )
        
       
       
        r_t=R(s_t,a_t)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: -0.02778em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em"></span></span><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathdefault" style="margin-right: 0.00773em">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。 请注意，我们的算法也直接适用于部分可观察马尔可夫决策过程 (POMDP)，但我们使用 MDP 框架以便于阐述。</li></ul> 
<h2>
<a id="31__16"></a>3.1 设置和符号</h2> 
<ul>
<li>我们对决策转换器 (DT) 的在线微调感兴趣（Chen 等人，2020 年），其中代理将可以访问非平稳训练数据分布 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         T
        
       
       
        T
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.13889em">T</span></span></span></span></span>。最初，在预训练期间，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         T
        
       
       
        T
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.13889em">T</span></span></span></span></span> 对应于线数据分布 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          T
         
         
          
           o
          
          
           f
          
          
           f
          
          
           l
          
          
           i
          
          
           n
          
          
           e
          
         
        
       
       
        T_{offline}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.969438em;vertical-align: -0.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em"><span class="" style="margin-left: -0.13889em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right: 0.10764em">f</span><span class="mord mathdefault mtight" style="margin-right: 0.10764em">f</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em"><span class=""></span></span></span></span></span></span></span></span></span></span>，并通过离线数据集 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          T
         
         
          
           o
          
          
           f
          
          
           f
          
          
           l
          
          
           i
          
          
           n
          
          
           e
          
         
        
       
       
        T_{offline}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.969438em;vertical-align: -0.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em"><span class="" style="margin-left: -0.13889em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right: 0.10764em">f</span><span class="mord mathdefault mtight" style="margin-right: 0.10764em">f</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em"><span class=""></span></span></span></span></span></span></span></span></span></span> 访问。 在微调期间，它通过重播缓冲区 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          T
         
         
          
           r
          
          
           e
          
          
           p
          
          
           l
          
          
           a
          
          
           y
          
         
        
       
       
        T_{replay}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.969438em;vertical-align: -0.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em"><span class="" style="margin-left: -0.13889em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right: 0.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em"><span class=""></span></span></span></span></span></span></span></span></span></span> 访问。 令 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         τ
        
       
       
        τ
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.1132em">τ</span></span></span></span></span> 表示轨迹并令 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         ∣
        
        
         τ
        
        
         ∣
        
       
       
        |τ |
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right: 0.1132em">τ</span><span class="mord">∣</span></span></span></span></span> 表示它的长度。 轨迹 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         τ
        
       
       
        τ
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.1132em">τ</span></span></span></span></span> 在时间步长 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         t
        
       
       
        t
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.61508em;vertical-align: 0em"></span><span class="mord mathdefault">t</span></span></span></span></span> 的返回 (RTG)，gt “ř|τ|t1“trt1 ，是该时间步长的未来奖励总和。 让“ pa1, . . . , a|τ|q, s “ ps1, . . . , s|τ|q 和 g “ pg1, . . . , g|τ|q 分别表示 τ 的动作序列、状态和 RTG。</li>
<li>…</li>
<li>…</li>
</ul> 
<h1>
<a id="Online_Decision_Transformer_20"></a>Online Decision Transformer</h1> 
<ul>
<li>由于训练数据的限制，在纯离线数据集上训练的 RL 策略通常不是最优的，因为离线轨迹可能没有高回报并且仅覆盖状态空间的有限部分。 提高性能的一种自然策略是通过在线交互微调预训练的 RL 代理。 然而，标准决策转换器的学习公式不足以进行在线学习，正如我们将在实验消融中展示的那样，当天真地用于在线数据采集时会崩溃。 在本节中，我们介绍了对决策转换器的关键修改，以实现高效采样的在线微调。</li>
<li>作为第一步，我们提出了一个广义的概率学习目标。 我们将扩展此公式以解释在线决策转换器 (ODT) 中的探索。 在概率设置中，我们的目标是学习最大化数据集可能性的随机策略。 例如，对于连续动作空间，我们可以使用具有对角线的多元高斯分布的标准选择（Haarnoja 等人，2018a；Fujimoto &amp; Gu，2021；Kumar 等人，2020b；Emmons 等人，2021） 协方差矩阵，用于模拟以状态和 RTG 为条件的动作分布。 让 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         θ
        
       
       
        θ
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.02778em">θ</span></span></span></span></span> 表示策略参数。 正式地，我们的政策是<br> <img src="https://images2.imgbox.com/8c/b3/PXEGqYIn_o.png" alt="在这里插入图片描述">
</li>
<li>其中协方差矩阵 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          Σ
         
         
          θ
         
        
       
       
        Σ_θ
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em;vertical-align: -0.15em"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span> 假定为对角矩阵。 给定随机策略，我们最大化训练数据集中轨迹的对数似然，或等效地最小化负对数似然 (NLL) 损失。<br> <img src="https://images2.imgbox.com/50/f1/F5GdoiJ8_o.png" alt="在这里插入图片描述">
</li>
<li>我们在这里考虑的策略包含 DT 考虑的确定性策略。 优化目标 (1) 等同于优化 (3)，假设协方差矩阵 Σθ 是对角矩阵并且方差在所有维度上都相同，这是我们假设涵盖的特例。</li>
</ul> 
<h2>
<a id="41__27"></a>4.1 最大熵序列建模</h2> 
<ul>
<li>在线 RL 算法的关键属性是能够平衡探索-开发权衡。 即使使用随机策略，如等式 (3) 中的传统 DT 公式也没有考虑探索。 为了解决这个缺点，我们首先通过定义为的策略熵来量化探索：<br> <img src="https://images2.imgbox.com/85/37/4spvHNWY_o.png" alt="在这里插入图片描述">
</li>
<li>其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         H
        
        
         [
        
        
         
          π
         
         
          θ
         
        
        
         (
        
        
         
          a
         
         
          k
         
        
        
         )
        
        
         ]
        
       
       
        H[π_θ(a_k)]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathdefault" style="margin-right: 0.08125em">H</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em"><span class="" style="margin-left: -0.03588em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span> 表示分布 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          π
         
         
          θ
         
        
        
         (
        
        
         
          a
         
         
          k
         
        
        
         )
        
       
       
        π_θ(a_k)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em"><span class="" style="margin-left: -0.03588em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 的香农熵。 策略熵取决于数据分布 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         T
        
       
       
        T
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.13889em">T</span></span></span></span></span>，它在离线预训练阶段是静态的，但在微调期间是动态的，因为它取决于探索期间获得的在线数据。</li>
<li>类似于许多现有的 max-ent RL 算法 (Levine, 2018)，例如 Soft Actor Critic (SAC, Haarnoja et al. (2018a;b))，我们明确地对策略熵施加一个下限以鼓励探索。 也就是说，我们有兴趣解决以下约束问题：<br> <img src="https://images2.imgbox.com/45/26/0fH62FM0_o.png" alt="在这里插入图片描述">
</li>
<li>其中 β 是一个前缀超参数。 继 Haarnoja 等人 (2018b) 之后，在实践中，我们解决了 (5) 的对偶问题，以避免显式处理不等式约束。 即，我们考虑拉格朗日 Lpθ, λq “ Jpθq `λpβ ´HTθra|s, gsq 并通过交替优化 θ 和 λ 来解决问题 maxλě0minθLpθ, λq。 用固定的 λ 优化 θ 等同于</li>
<li>…</li>
<li>最后，我们就实际优化细节方面与 SAC 的相似性发表了几点评论。 首先，我们没有完全解决子问题（6）和（7）。 对于它们两者，我们每次只进行一次梯度更新，也就是一步交替梯度下降。 其次，HTθ ra|s, gs 的计算涉及积分。 我们使用单样本蒙特卡洛估计来近似每个积分，并且样本被重新参数化以进行低方差梯度计算。 正如 Haarnoja 等人 (2018b) 也指出的那样，我们经常观察到问题 (5) 中的约束很紧，因此实际熵 HTθra|s, gs 与 β 匹配。</li>
</ul> 
<h1>
<a id="Training_Pipeline_36"></a>Training Pipeline</h1> 
<ul>
<li>我们使用变压器架构实例化上述公式。 在线决策转换器 (ODT) 建立在 DT 架构之上，并包含由于随机策略而产生的变化。 我们通过输出端的两个独立的全连接层来预测策略均值和对数方差。 算法 1 总结了 ODT 中的整体微调管道，其中详细的内部训练步骤在算法 2 中进行了描述。我们在下面概述了这些算法的主要组成部分，并在附录 B 中讨论了其他设计选择和超参数。</li>
<li>
<strong>轨迹级回放缓冲器</strong>。我们使用重放缓冲区来记录我们过去的经历并定期更新。对于大多数现有的 RL 算法，重放缓冲区由转换组成。在 rollout 中的每一步在线交互之后，策略或 Q 函数都会通过梯度步骤进行更新，并执行策略以收集新的转换以添加到重放缓冲区中。然而，对于 ODT，我们的回放缓冲区包含轨迹而不是转换。离线预训练后，我们通过离线数据集中回报率最高的轨迹初始化回放缓冲区。每次我们与环境交互时，我们都会使用当前策略完全推出一个情节，然后以先进先出的方式使用收集到的轨迹刷新重播缓冲区。之后，我们再次更新策略并推出，如算法 1 所示。与 Haarnoja 等人 (2018a) 类似，我们还观察到使用平均动作评估策略通常会带来更高的回报，但使用采样更有好处在线探索的行动，因为它会产生更多样化的数据。</li>
<li>
<strong>事后回报重新贴标签</strong>。 Hindsight experience replay (HER) 是一种在奖励稀疏的环境中提高目标条件代理的样本效率的方法（Andrychowicz 等人，2017 年；Rauber 等人，2017 年；Ghosh 等人，2019 年） . 这里的关键思想是将智能体的轨迹重新标记为已实现的目标，而不是预期目标。 对于 ODT，我们正在学习以初始 RTG 为条件的策略。 然而，在政策推出期间获得的回报和诱导的 RTG 可能与预期的 RTG 不同。 受 HER 的启发，我们用实现的回报为展开的轨迹 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         τ
        
       
       
        τ
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.1132em">τ</span></span></span></span></span> 重新标记 RTG 代币，这样在最后一个时间步 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          g
         
         
          
           ∣
          
          
           τ
          
          
           ∣
          
         
        
       
       
        g_{|tau|}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.78576em;vertical-align: -0.3552em"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em"><span class="" style="margin-left: -0.03588em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right: 0.1132em">τ</span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3552em"><span class=""></span></span></span></span></span></span></span></span></span></span> 的 RTG 代币恰好是代理 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          r
         
         
          
           ∣
          
          
           τ
          
          
           ∣
          
         
        
       
       
        r_{|τ|}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.78576em;vertical-align: -0.3552em"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em"><span class="" style="margin-left: -0.02778em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right: 0.1132em">τ</span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3552em"><span class=""></span></span></span></span></span></span></span></span></span></span> 获得的奖励，参见算法 2 的第 6 行。 这种返回重新标记策略适用于奖励稀疏和密集的环境。</li>
<li>
<strong>RTG 调节</strong>。 ODT 需要一个超参数，初始 RTG <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          g
         
         
          
           o
          
          
           n
          
          
           l
          
          
           i
          
          
           n
          
          
           e
          
         
        
       
       
        g_{online}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em;vertical-align: -0.19444em"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em"><span class="" style="margin-left: -0.03588em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span>，用于收集额外的在线数据（参见算法 1 的第 4 行）。 此前，Chen 等人 (2021) 表明，离线 DT 的实际评估回报与经验上的初始 RTG 具有很强的相关性，并且通常可以推断出超过离线数据集中观察到的最大回报的 RTG 值。 对于 ODT，我们发现最好将此超参数设置为专家回报的一个小的、固定的比例（在我们的实验中设置为 2）。 我们还试验了更大的值以及随时间变化的课程（例如，离线和在线数据集中最佳评估回报的分位数），但我们发现这些相对于固定的、缩放的 RTG 而言是次优的。</li>
<li>
<strong>抽样策略</strong>。 与 DT 类似，算法 2 使用两步采样过程来确保重放缓冲区 Treplay 中长度为 K 的子轨迹被均匀采样。 我们首先以与其长度成正比的概率采样单个轨迹，然后统一采样长度为 K 的子轨迹。对于具有非负密集奖励的环境，我们的采样策略类似于重要性采样。 在这些情况下，轨迹的长度与其返回高度相关，正如我们在附录 F 中进一步强调的那样。</li>
</ul> 
<h1>
<a id="_42"></a>动态训练</h1> 
<ul><li>我们评论了一些关于 ODT 训练动态及其影响的经验观察。 我们首先展示一个示例运行，其中 ODT 的在线返回饱和，表明训练已经收敛。 我们将自己限制在算法 1 收敛的情况下，讨论 ODT 的训练动态。 这种收敛假设使我们能够分析学习目标在训练过程中的含义，以及初始 RTG 令牌对 ODT 策略的行为变化。 我们强调算法 1 的收敛保证是一个悬而未决的问题，超出了本文的范围，我们的主张将主要通过实验来指导。</li></ul>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>