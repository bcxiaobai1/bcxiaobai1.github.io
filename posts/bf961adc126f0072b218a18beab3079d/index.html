<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>旋转字符串的秘密 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">旋转字符串的秘密</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p>      最近离谱张童鞋对字符串旋转,翻转等问题非常感兴趣,看了些视频以及做了一些题目,现在有一些新的想法以及后续学习的目标以及规划要分享给大家. </p> 
<p></p> 
<p>目录:</p> 
<p>1：介绍一下整体旋转字符串的2种方法<br> 2：旋转单个字符,设计一个函数(两种方法,第一种是设计函数第二种是三步翻转法:特别巧妙,这里将会画图详细介绍.<br> 3：题目1：旋转一个字符串然后单词也逆序.:</p> 
<p>4：查找字符串,本题会把思路和代码详细的讲一遍.<br> 好，接下来咱们先看这样一个问题</p> 
<p><strong>题目 :完成对一个字符串的逆序.</strong><br> 示例:abcd<br> 输出:dcba<br> (偶数个)</p> 
<p>示例:abcde<br> 输出:edcba<br> (奇数个)</p> 
<p>思路1:可以用循环来实现,把b一个字符串传入数组中,既然是数组,就可以用访问下标的形式来进行访问了,然后再倒序输出就行了<br> 废话不多说,直接上代码(别急每一条代码后面有注释喔)</p> 
<p></p> 
<pre><code class="language-cs">​
/*
方法1:for循环倒序输出:

思路:和倒序输入数字一样的,直接倒序打印就可以

*/

//已在编译器上测试过,没问题
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main()
{
    char s[1000]={0};//创建一个数组用来存放字符串,大小的话,注意题目规范,还有变量初始化,好习惯一定要养成
    scanf("%s",s);//输入字符串,也可以用gets
    int n=strlen(s);//求出有几个字母,顺便可以算出下标
    int i=0;//变量初始化,一定别忘了喔
    for(i=n-1;s[i]!='';i--)//从最后一个字母的下标开始倒序输出.
    {        
        printf("%c",s[i]);
              
      }
        
    return 0;
  }

​</code></pre> 
<p>总结:这就是思路1啦,不难理解,接下来我们看思路1(2).</p> 
<p></p> 
<pre><code class="language-cs">/*

方法2:也是用循环来完成的,但不过这个是用数组来实现字符串交换的,和这个题目有一些些相似,但是本质也还是相同的

这个和鹏哥之前的字符串汇聚蛮相似的,所以我想把他们放到一起来看


*/
//已在编译器上测试过,没问题
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
    char arr[1000]={0};
    int left=0,right=0,i=0;
    scanf("%s",arr);//输入字符串的时候用gets也是可以的哟
    int n=strlen(arr);//这样我是把这样条件都一股脑的写在了for循环里面,大家也可以写在外面
    for(left=0,right=n-1;(right-left)&gt;0;left++,right--)
    {
/*
1:这里注意一点就是,right-left&gt;1可以不可呢?答案是不可以,因为如果你交换的是偶数的话,第五和第六个元素,6-5=1,条件不满足,就退出来了,所以还是当右下标大于左下标的时候,这样就可以啦

2:然后就可以实现字符串的交换了哟
先创建一个临时变量用来存放左下标的元素.这就和交换三个数是一模一样的,大家类比就好啦
由于交换的是字符类型,所以,一定得用char型来创建临时变量的哟

*/
       char t=0;
       t=arr[left];
       arr[left]=arr[right];
       arr[right]=t;
       
      }

//交换完毕之后,最后打印出来就好啦

    printf("%s",arr);
  
   return 0;
 }
 </code></pre> 
<p>现在我们来回顾一下字符串汇聚的那个题目把:题目所示:<br><strong>编写代码，演示从多个字符从两段移动，向中间汇聚。</strong></p> 
<p>思路如下（字多，详细，请大家耐心阅读）：<br> 比如我让arr2的#号变成welcome bit</p> 
<p>首先得创建两个数组arr1和arr2来存储这两个字符串儿</p> 
<p>然后字符串的话,已经存放到了数组里面了,然后就可以采用访问数组下标的形式,定义左下标为0,右下标为sz-1.<br> ,但是他不能算sz,因为他是个字符串,这时候就要了解一下strlen函数了,str是string是字符串,len是lengh是表示长度的的意思,所以,这个是strlen函数是这么由来的</p> 
<p>那么所以left和right都应该等于什么呢？<br> int left=0;<br> int right=strlen(arr2)-1;</p> 
<p>首先明确题目,是让arr1的每一个元素来传到arr2中对吧,所以就是让arr1的左下标来放入到arr2的左下标,同理的右坐标也是一样的.</p> 
<p>因为咱们是每传一次,咱们看一下他这个变化对吧,就是在交换了之后面加一个打印就行了,</p> 
<p>然后这个是一次,我让left++,和right减减,他是不是就可以向中间汇聚了呢？</p> 
<p>所以是不是得加一个while循环啊,是不是,这个和二分查找是一样的,二分查得查找很多次啊.</p> 
<p>好了,思路以及有了,代码如下</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
//已经在编译器上测试过
int main()
{
    char arr1[]="welcome bit";
    char arr2[]="###########";
    int left=0;
    int right=strlen(arr2)-1;
    while(left&lt;=right)
    {
        arr2[left]=arr1[left];//一定要注意,不是(),是[]
        arr2[right]=arr1[right];
        printf("%sn",arr2);//这样就每打印一行,加一下,效果是从中间汇聚的.
      //  sleep(1000);//手机上不能实现,停留,因为手机没有windows.h
        left++;
        right--;
    }
    return 0;
   }</code></pre> 
<p> 好了,回过神来了,好了这个数组交换的方法,大家肯定会了,然后现在来看函数是如何实现的吧</p> 
<p></p> 
<p></p> 
<p>方法三,用一个函数来实现,这个函数我们就把他定义为字符交换函数把,</p> 
<p><strong>字符交换函数</strong></p> 
<p>思路就是:要想交换一个字符串,就得把这个字符串的首尾地址传给这个交换函数,然后用指针的形式来进行交换,而我们定义的这个函数就得用两个指针来进行接收啦</p> 
<p>好了,这个思路大致有了以后,咱们就来说敲代码了嗷</p> 
<p>(1):首尾地址&gt;可以用数组名来表示,因为数组名就代表着首元素的地址,而末尾元素的地址,则是字符串长度-1</p> 
<p>(2):当把参数传给自定义函数里面,我们可以用左下标指针和右下标指针来进行接收他们,</p> 
<p>(3)可以用while循环,或者是for循环来进行交换,</p> 
<p>那条件是什么呢,我们可以这样想,就是当我们的左下标&lt;=右下标的时候,这样是不是就停止了交换了呢？</p> 
<p>好，思路有了，代码如下：</p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void my_string_reverse(char*left,char*right)
{
//交换,这里的*和[]是一样哒
    while(left&lt;right)
    {
        char t=*left;
        *left=*right;
        *right=t;
//交换这一步一定要写对
        left++;
        right--;
     }
       
}    
int main()
{
    char arr[1000]={0};//好习惯的初始化
    scanf("%s",arr);
    int n=strlen(arr);
    my_string_reverse(arr,arr+n-1);//传首尾元素的地址
//完成之后呢,我们来打印一下就ok啦,来看看他是否完成了交换
    printf("%s",arr); 
    return 0;
 }</code></pre> 
<p>ok,这是整体交换的方法,我们再来聊聊,更近一步的,如何才能使交换一串儿字符的两个字符呢？这样可以是左交换,或者是右交换;</p> 
<p>题目如下:加照片</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/ea/2f/b5HdCLN3_o.jpg"></p> 
<p> </p> 
<p>其实每一个题目的思路都可以是这样的，首先要明确题目内容是什么,要把某个东西干什么,最终要完成什么目的,可以用到的工具是什么,依次来进行思路的搭建,</p> 
<p>交换一个字符串中的两个(k个)字符,也称为左旋字符串.</p> 
<p>要旋转的字符串会发生改变,所以我们可以存放在数组中,因为数组元素才可以被改变,<br> 万万不可用char*p="ABCDEF"来改变常量字符串.</p> 
<p>然后我们就要自定义函数啦,my_string_left(arr,k)再把arr这个数组传过去,k为旋转的个数,<br> 然后用char*str来接收arr,int k来接收k.</p> 
<p>既然传参部分都解决了,那么我们就开始想他如何实现吧,</p> 
<p>现在有一个字符串ABCDEF,旋转的话我们可以这样想,把其中的一个A字母用一个临时变量存起来,然后BCDEF整体往前移动,往前移动嘛,那就是用一个for循环a[i-1]=a[i](如果是下标为0的，格式还可以这么写a[i]=a[i+1]就可以搞定啦,</p> 
<p>最后在这个循环里面完成交换之后,把这个临时变量再放回到最后一位就行了。</p> 
<p>好了，这就是大体思路,现在我们转为代码看看呗,</p> 
<p></p> 
<pre><code class="language-cs">
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void my_string_left(char*str,int k)
{
    int i=0,j=0;//初始化
    int n=strlen(str);//st为首元素的地址,这里不懂的话,可以去查一查strlen接收的参数类型,这里为大家奉上:unsigned int strlen(const char *str);很明显,str是字符型指针,一会儿得接收地址
  
    for(i=0;i&lt;k;i++)//在for循环里面完成交换,一共有n个元素,现在拿出去第一个元素用于以后的存放,还剩下n-1要向前移动,然后要想把长度求出来,就得用strlen来求一下
    {
        char t=*str;//首先:把第一个元素存放到一个临时变量里面,放到for循环里面的目的是为了本次循环结束之后,下次循环,获得的是新的一个字符,如果放在for循环外面的话,每次获取的斗只是第一个字符
        for(j=0;j&lt;n-1;j++)
        {
            *(str+j)=*(str+j+1);//其次:这里的*(str)是解引用,把找第一个元素的地址来找到第一个首元素,而且不能没有*str,如果没有首元素的地址那你怎么能找到末尾的元素呢？      
         }
     
    //最后:空出的这个位置有了,那就存放第一个元素吧
        *(str+n-1)=t;             
     }
}  
 
int main()
{
    
   char arr[1000]={0};//初始化,好习惯
   scanf("%s",arr);//输入字符串的时候，可不需要取地址喔，而且还可以用gets
   int k=2;//把要旋转的字符传过去
//传左旋
   my_string_left(arr,k);//自定义函数
   printf("%s",arr);//最后打印
   
   return 0;
 }</code></pre> 
<p>好的,那么既然左旋会了,那右旋是不是也一样呢,这里大家先自行思考一会儿,不许看代码喔嘿嘿</p> 
<p>右旋:同左旋一一模一样的,稍微改变一下就行.<br> 大家自行思考，再看代码</p> 
<p><strong>右旋字符串</strong></p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
void my_string_right(char*str,int k)
{
    int i=0,j=0;
    int n=strlen(str);//str为首元素的地址,这里不懂的话,可以去查一查strlen接收的参数类型,这里为大家奉上:    
    for(i=0;i&lt;k;i++)//第二步,在for循环里面完成交换,一共有n个元素,现在拿出去第一个元素用于以后的存放,还剩下n-1要向后移动,然后要想把长度求出来,就得用strlen来求一下
    {
        char t=*(str+n-1);//首先把最后一个元素存放到一个临时变量里面,放到for循环里面的目的是为了本次循环结束之后,下次循环,获得的是新的一个字符,如果放在for循环外面的话,每次获取的只是第一个字符
        for(j=n-2;j&gt;=0;j--)
        {
            *(str+j+1)=*(str+j);//往后移动啦    
         }
     
    //第三步:空出的这个位置有了,那就存放最后一个元素吧
        *(str)=t;
             
     }
}  

int main()
{
    char arr[1000]={0};
   scanf("%s",arr);//输入字符串的时候，可不需要取地址喔，而且还可以用gets
   int k=2;//把要旋转的字符传过去
//右旋两个
   my_string_right(arr,k);//自定义函数喔
   printf("%s",arr);

   
     return 0;
 }</code></pre> 
<p>好了，思路回来,以上的两个代码,都是旋转一个字符串的左边或者右边的两个字符,但是我们这样想一下,右旋一个字符=左旋三个字符<br> eg1:<br> abcd &gt;&gt; 右旋一个 &gt;&gt;dabc<br> == 左旋三个&gt;&gt;dabc</p> 
<p>eg2:<br> abcd &gt;&gt; 右旋二个&gt;&gt;cdab<br> == 左旋六个&gt;&gt;cdab<br> 已经测试过了,没问题的.兄弟们,放心用</p> 
<p>接下来让我我们回到那个最初的问题上…<br> 接下来给大家介绍一种方法,三步翻转法,这样也可以进行字符串的翻转,很妙,很值得品味</p> 
<p><strong>三步翻转法</strong><br> 1左翻转<br> 2右翻转<br> 3整体翻转<br> 如图所示:</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/8e/a8/lwecJD2I_o.jpg"></p> 
<p> </p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
void my_string_right(char*str,int k)
{
    int i=0,j=0;
    int n=strlen(str);//str为首元素的地址,这里不懂的话,可以去查一查strlen接收的参数类型,这里为大家奉上:    
    for(i=0;i&lt;k;i++)//第二步,在for循环里面完成交换,一共有n个元素,现在拿出去第一个元素用于以后的存放,还剩下n-1要向后移动,然后要想把长度求出来,就得用strlen来求一下
    {
        char t=*(str+n-1);//首先把最后一个元素存放到一个临时变量里面,放到for循环里面的目的是为了本次循环结束之后,下次循环,获得的是新的一个字符,如果放在for循环外面的话,每次获取的只是第一个字符
        for(j=n-2;j&gt;=0;j--)
        {
            *(str+j+1)=*(str+j);//往后移动啦    
         }
     
    //第三步:空出的这个位置有了,那就存放最后一个元素吧
        *(str)=t;
             
     }
}  

int main()
{
    char arr[1000]={0};
   scanf("%s",arr);//输入字符串的时候，可不需要取地址喔，而且还可以用gets
   int k=2;//把要旋转的字符传过去
//右旋两个
   my_string_right(arr,k);//自定义函数喔
   printf("%s",arr);

   
     return 0;
 }</code></pre> 
<p></p> 
<p>好啦,到这里,旋转字符串,不管是多个,还是任意个字符的旋转,大家肯定都会了,然后来一道题目来巩固一下吧</p> 
<p>题目如下:</p> 
<p><img alt="" src="https://images2.imgbox.com/b1/c6/VdG1FfjH_o.jpg"></p> 
<p> </p> 
<p><strong>方法一:暴力穷举法</strong>:把能想到的可能都列出来,然后进行一一比对</p> 
<p>就是判断s2是否由s1旋转得到的,就可以让s1先旋转一个,比一下,然后再旋转一个,比一下,这里用for循环就可.</p> 
<p>外层for循环每次循环一次,就说明了已经完成了一次交换,这时候用strcmp函数来比较一下,看看是否相等,如果相等的话呢？那就跳出来就好了啦</p> 
<p> </p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
char is_pd_string_rotate(char*str1,char*str2)//最前面的类型,char可以,int也可以
//char*str1来接收arr1,char*str2来接收arr2
{
    assert(str1);
    assert(str2);
    int i=0,j=0;
    int n=strlen(str1);
    for(i=0;i&lt;n;i++)
    {
        char t=*str1;//第一步:记录起始位置
        for(j=0;j&lt;n-1;j++)
        {
            *(str1+j)=*(str1+j+1);//第二步往前移动:就是前面的比后面的小,那就往前移动
          
        }
       *(str1+n-1)=t;//第三步:把第一个元素放在最后面
//每一次完了之后进行一次比较,如果相同,那就返回1就好了啦     
      if(strcmp(str1,str2)==0)
      {
          return 1;
       }    
   }//这层for循环如果停止的话,说明已经旋转了每一个了,就没有匹配的,说明s2不是由s1旋转的来的,那咱们return 0就好了
   return 0;
   
}
int main()
{
    
    char arr1[]="AABCD";//记得数组一定一定要初始化喔
    char arr2[]="BCDAA";
    int ret=is_pd_string_rotate(arr1,arr2);
    if(ret==1)
    {
        printf("yes");
     }
    else
    {
        printf("no");
     } 
    
    
    
    return 0;
 }</code></pre> 
<p>好了,到这里,我们的代码就实现啦,还有一个注意点就是这个如图,大家一定写函数类型的时候要小心,一定要小心谨慎<br> 不要犯我这个小错误</p> 
<p><strong>方法二:追加自己的字符串，判断字符串是否包含的问题</strong></p> 
<p>思路:就是我们能不能把这一个字符串来变化一下,让它包含所有的情况呢？,答案是可以的,</p> 
<p>首先:我们用字符串追加就可以了。<br> 其次:到了最后，判断arr2是不是arr1的子串儿就好了。</p> 
<pre><code class="language-cs">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
char is_pd_string_rotate(char*str1,char*str2)//char可以,int也可以
{
    assert(str1);
    assert(str2);
    if(strlen(str1)!=strlen(str2))
    { 
//二者长度不一样,肯定旋转返回0就ok了
        return 0;
     }
//首先进行了字符串的追加,
       int len=strlen(str1);
       strncat(str1,str1,len);

    
//完成之后用strstr函数来看看是不是子串儿,如果是子串儿的话,就返回空指针(具体的话,大家可以自行查一下strstr函数
    char*ret=strstr(str1,str2);
    if(ret==NULL)
   {
       return 0;//那就是找不到子串儿
    }
    else
    {
        return 1;//如果找到了,那就返回1
     }
 //此时还有一个例外就是,如果他们的字符串长度原本就不想等,那么肯定不是旋转得来的
    //所以啊,在前面加一个if判断就好了啦  
   
}

int main()
{    
    char arr1[]="AABCD";//记得数组一定一定要初始化喔
    char arr2[]="BCDAA";
    int ret=is_pd_string_rotate(arr1,arr2);
    if(ret==1)
    {
        printf("yes");
     }
    else
    {
        printf("no");
     } 
    
        
    return 0;
 }</code></pre> 
<p>总结：本题用了C语言的库函数比较多，所以在执行方面和书写方面会比较快。比前面的自定义函数方便一些。</p> 
<p>============================================================<br> 接下来,我们来看下一道题吧(大家先自行思考10min再看代码)<br> 题目如图所示:</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/2e/16/oD0PFpMP_o.jpg"></p> 
<p> 先说整体思路：</p> 
<p>思路:1先写一个可以逆序的函数(咱们之前的文章已经有啦)(把这一句话的首元素地址和末尾元素的地址传过去)<br> 2传过去之后,那就看看单个单词的逆序就好啦,</p> 
<p></p> 
<p>具体思路:<br> 先把整个字符串逆序，设计了一个翻转函数，然后再逆序每一个单词，要逆序单词的话，就得有每一个单词的下标，<br> 要下标的话，得拿指针（或者left，right下标来算，做法是最后把下标传递给数组来算的。然后就是用到找下标的<br> 方法了，找下标的话，如果遇到’’的话那就是最后一个单词的末尾了，然后接下来就是每一个单词的后面的空格了<br> ，如果循环到不等于空格的时候，那就继续往下找，直到遇到一个单词的空格，那就开始走else了，else的话，传的<br> 就是左下标为0和右下标减一，这样就是这一个单词的逆序了，然后else完了之后，走for循环right＋＋，这样就是<br> 下一个单词了，依次类推，就完成了逆序。</p> 
<p>方法是用到了for循环和数组来进行逆序</p> 
<p>但是本质还是找到这个单词逆序的关键点还有如何找到下一个单词，以及空格和的处理</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void my_string_fz_reverse(char a[],char left,char right)
{
//for前面的条件1就是char left来接受的0,和char right 接受的n-1
    for(;(right-left)&gt;0;)//条件3是放到了后面,当然兄弟们放到前面也行
  {
     char t=a[left];
     a[left]=a[right];
     a[right]=t;
     
     left++;
     right--;  
    }    
}
int main()
{
    
    char s[10000]={0};//初始化为0,好习惯
    gets(s);
    int n=strlen(s);
//一次性传3个元素,1数组,因为上面要用for循环来实现翻转;2left左下标,3:right右下标
    my_string_fz_reverse(s,0,n-1);
    int left,right;
    for(left=0,right=0;s[right]!='';right++)
    {
//接下来的if如果不对懂的话,前面有详细的叙述,兄弟们可以翻过去好好看看
        if(s[right]!=' ') 
           continue;
        else
        {
            
            my_string_fz_reverse(s,left,right-1);
            left=right+1;
          }
          
     }
     my_string_fz_reverse(s,left,right-1);
     printf("%s",s);
    return 0;
  }</code></pre> 
<p>好啦，这就是方法一。<br> 再来看方法二：</p> 
<p><strong>方法二:指针加循环</strong>和方法一差不多,只是换一种形式而已</p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void reverse(char*left,char*right)
{
    while(left&lt;right)
    {
      char t=*left;
      *left=*right;
      *right=t;
      left++;
      right--;
    }
        
}    
int main()
{
    
   char arr[1000]={0};
   int left,right;
   get(arr);//输入一串儿单词
   int n=strlen(arr);
   reverse(arr,arr+n-1);//这是交换整体的逆序
//   然后再进行单个单词的逆序,就得用双指针
   char*start=arr;
   while(*start)
   {
       char*end=start;
       while(*end!=' ' &amp;&amp; *end!='')
       {
            end++;//这样是地址的++,然后指向下一个地址;然后才能以便后续的解引用来进行找到元素
            
        }
       reverse(start,end-1);
       if(*end==' ')
         start=end+1;
       else
         start=end;       
     }
     
   printf("%s",arr);
    return 0;
 }</code></pre> 
<p></p> 
<p></p> 
<p>好了，这就是今天的内容了，最后这个题跟今天内容没有关系，但是可以很好的去锻炼我们的思维：<br> 题目如下：</p> 
<p></p> 
<p> </p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/c4/6b/gtFpbD5z_o.jpg"></p> 
<p>用三层for循环来进行一步一步的筛选<br> 前提是注意for里面的内层嵌套还有if的使用</p> 
<p>如果在本字符串中找到一个c,那就看看下一个是不是h,如果是h,那再看看是不是n,如果他们都满足的话,count++,这个一个chn,同理其他情况.</p> 
<p>如图所示：</p> 
<p></p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/02/57/XbWaq9CY_o.jpg"></p> 
<p><strong> 方法一：三层for循环的嵌套以及if语句和continue的用法</strong></p> 
<pre><code class="language-cs">
/*
方法一：用三层for循环来进行一步一步的筛选
前提是注意for里面的内层嵌套还有if的使用


eg：要找CCHNCHN中的CHN的个数，先找C，然后再进行判断，下一个字母如果是H，就往下走，如果不是的话，

就第一层for循环在进行下一个单词的查询，当找到H之后，再定位到下一个单词看看是不是N，如果是N的话，

那就count++，进行基数，如果第一个H的后面仍然有N的话，那z循环就会继续往后找，continue的作用就是

这样，跳过本次循环，进行下一次循环，如果下一次循环条件满足的话，就进行判断，再看看是否满足z循环，




*/
#include &lt;stdio.h&gt;
int main()
{
   int count=0,i=0,j=0,z=0;
   char s[100]={0};
   scanf("%s",s);   
   for(i=0;s[i]!='';i++)
   {
       if(s[i]!='C')
         continue;
       if(s[i]=='C')
      {
          for(j=i+1;s[j]!='';j++)
          {
              if(s[j]!='H')
                 continue;
              if(s[j]=='H')
             {
                 for(z=j+1;s[z]!='';z++)
                 {
                     if(s[z]!='N')
                       continue;
                     if(s[z]=='N')
                       count++;
                   }
              }
          }
      }
   }
   
   printf("%d",count);
  return 0;
 }</code></pre> 
<pre><code class="language-cs">/*方法二：要查找一个字符串对吧,可以用指针来指向这个字符串,然后用for循环,或者if循环来挨个指向
比如还是要查找CCHNCHN中有几个CHN

C C H N C H N
0 1 2 3 4 5 6 

进入循环，*p指向的是第一个元素，不是0，所以往后走

紧接着是if的判断部分，第一个C,说明找到了，c=1，跳出循环，p++开始指向下一个元素，还是C，然后c变成

2了，再p++往后找，发现第三个是H，走else if 此次的ch=2，然后p++开始找第二个元素，，发现是N,然后

此时的CHN=2，再往下走，发现指向了C，此时的c变成了3，然后继续走，遇到了N，此时此刻的CH=2+3=5，最

后一个字符遇到了N，然后走CHN，这个语句，现在的CHN=2+5=7，所以就是7个CHN啦。






*/
#include&lt;stdio.h&gt;
int main()
{
   int c=0;
   long int ch=0;
   long long int chn=0;
   char arr[100]={0};
   scanf("%s",arr);
   char*p=arr;//用指针变量p来接收一个arr的数组名
   while(*p)//*p会指向,因为会往后移动
   {
       if(*p=='C')
         c++;
       else if(*p=='H')
         ch+=c;
       else if(*p=='N')
         chn+=ch;
      
      p++;
    }
    printf("%d",chn);   
   return 0;
  }
  



*/
#include&lt;stdio.h&gt;
int main()
{
   int c=0;
   long int ch=0;
   long long int chn=0;
   char arr[100]={0};
   scanf("%s",arr);
   char*p=arr;//用指针变量p来接收一个arr的数组名
   while(*p)//*p会指向,因为会往后移动
   {
       if(*p=='C')
         c++;
       else if(*p=='H')
         ch+=c;
       else if(*p=='N')
         chn+=ch;
      
      p++;
    }
    printf("%d",chn);   
   return 0;
  }
  </code></pre> 
<p></p> 
<p></p> 
<p>好啦，这就是今天的分享的题目啦，然后可能我叙述的会有一些冗杂和重复，希望大家可以耐着性子读下去，希望本篇博客对大家有所帮助，里面的思路可以帮助大家处理一些相似的问题。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p style="text-align:center"></p> 
<p> </p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>