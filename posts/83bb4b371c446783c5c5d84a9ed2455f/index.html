<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>功能齐全的屏幕截图C&#43;&#43;实现详解 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">功能齐全的屏幕截图C&#43;&#43;实现详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px"><a href="#1%E3%80%81%E6%A6%82%E8%BF%B0" title="1、概述">1、概述</a></p> 
<p id="2%E3%80%81%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E7%82%B9-toc" style="margin-left:40px"><a href="#2%E3%80%81%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E7%82%B9" title="2、屏幕截图的主要功能点">2、屏幕截图的主要功能点</a></p> 
<p id="3%E3%80%81%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E7%9A%84%E4%B8%BB%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px"><a href="#3%E3%80%81%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E7%9A%84%E4%B8%BB%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF" title="3、屏幕截图的主体实现思路">3、屏幕截图的主体实现思路</a></p> 
<p id="3.1%E3%80%81%E6%88%AA%E5%9B%BE%E4%B8%BB%E7%AA%97%E5%8F%A3%E5%85%A8%E5%B1%8F%E7%BD%AE%E9%A1%B6-toc" style="margin-left:80px"><a href="#3.1%E3%80%81%E6%88%AA%E5%9B%BE%E4%B8%BB%E7%AA%97%E5%8F%A3%E5%85%A8%E5%B1%8F%E7%BD%AE%E9%A1%B6" title="3.1、截图主窗口全屏置顶">3.1、截图主窗口全屏置顶</a></p> 
<p id="3.2%E3%80%81%E6%A1%8C%E9%9D%A2%E7%81%B0%E5%8C%96-toc" style="margin-left:80px"><a href="#3.2%E3%80%81%E6%A1%8C%E9%9D%A2%E7%81%B0%E5%8C%96" title="3.2、桌面灰化">3.2、桌面灰化</a></p> 
<p id="3.3%E3%80%81%E7%AA%97%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%A5%97%E7%B4%A2-toc" style="margin-left:80px"><a href="#3.3%E3%80%81%E7%AA%97%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%A5%97%E7%B4%A2" title="3.3、窗口自动套索">3.3、窗口自动套索</a></p> 
<p id="3.4%E3%80%81%E5%8C%BA%E5%9F%9F%E6%94%BE%E5%A4%A7-toc" style="margin-left:80px"><a href="#3.4%E3%80%81%E5%8C%BA%E5%9F%9F%E6%94%BE%E5%A4%A7" title="3.4、区域放大">3.4、区域放大</a></p> 
<p id="3.5%E3%80%81%E6%88%AA%E5%8F%96%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%80%89%E6%8B%A9-toc" style="margin-left:80px"><a href="#3.5%E3%80%81%E6%88%AA%E5%8F%96%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%80%89%E6%8B%A9" title="3.5、截取区域的选择">3.5、截取区域的选择</a></p> 
<p id="3.5%E3%80%81%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7%E6%9D%A1-toc" style="margin-left:80px"><a href="#3.5%E3%80%81%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7%E6%9D%A1" title="3.5、截图工具条">3.5、截图工具条</a></p> 
<p id="3.6%E3%80%81%E7%9F%A9%E5%BD%A2%E7%AD%89%E5%9B%BE%E5%85%83%E7%9A%84%E7%BB%98%E5%88%B6-toc" style="margin-left:80px"><a href="#3.6%E3%80%81%E7%9F%A9%E5%BD%A2%E7%AD%89%E5%9B%BE%E5%85%83%E7%9A%84%E7%BB%98%E5%88%B6" title="3.6、矩形等图元的绘制">3.6、矩形等图元的绘制</a></p> 
<p id="4%E3%80%81%20%E6%A1%8C%E9%9D%A2%E7%81%B0%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82-toc" style="margin-left:40px"><a href="#4%E3%80%81%20%E6%A1%8C%E9%9D%A2%E7%81%B0%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82" title="4、桌面灰化的实现细节">4、桌面灰化的实现细节</a></p> 
<p id="5%E3%80%81%E7%AA%97%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%A5%97%E7%B4%A2%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px"><a href="#5%E3%80%81%E7%AA%97%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%A5%97%E7%B4%A2%E5%AE%9E%E7%8E%B0" title="5、窗口自动套索实现">5、窗口自动套索实现</a></p> 
<p id="6%E3%80%81%E5%8C%BA%E5%9F%9F%E6%94%BE%E5%A4%A7%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px"><a href="#6%E3%80%81%E5%8C%BA%E5%9F%9F%E6%94%BE%E5%A4%A7%E5%AE%9E%E7%8E%B0" title="6、区域放大实现">6、区域放大实现</a></p> 
<p id="%C2%A07%E3%80%81%E6%88%AA%E5%8F%96%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%80%89%E6%8B%A9-toc" style="margin-left:40px"><a href="#%C2%A07%E3%80%81%E6%88%AA%E5%8F%96%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%80%89%E6%8B%A9" title="7、截取区域的选择">7、截取区域的选择</a></p> 
<p id="8%E3%80%81%E7%9F%A9%E5%BD%A2%E7%AD%89%E5%9B%BE%E5%85%83%E7%9A%84%E7%BB%98%E5%88%B6-toc" style="margin-left:40px"><a href="#8%E3%80%81%E7%9F%A9%E5%BD%A2%E7%AD%89%E5%9B%BE%E5%85%83%E7%9A%84%E7%BB%98%E5%88%B6" title="8、矩形等图元的绘制">8、矩形等图元的绘制</a></p> 
<p id="9%E3%80%81%E6%88%AA%E5%9B%BE%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px"><a href="#9%E3%80%81%E6%88%AA%E5%9B%BE%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6" title="9、截图窗口的绘制机制">9、截图窗口的绘制机制</a></p> 
<p id="10%E3%80%81%E6%88%AA%E5%9B%BE%E9%80%80%E5%87%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px"><a href="#10%E3%80%81%E6%88%AA%E5%9B%BE%E9%80%80%E5%87%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1" title="10、截图退出类型的详细设计">10、截图退出类型的详细设计</a></p> 
<p id="11%E3%80%81%E5%88%9B%E5%BB%BA%E4%BD%8D%E5%9B%BE%E6%97%B6%E5%B0%86CreateCompatibleBitmap%E6%9B%BF%E6%8D%A2%E6%88%90CreateDIBSection-toc" style="margin-left:40px"><a href="#11%E3%80%81%E5%88%9B%E5%BB%BA%E4%BD%8D%E5%9B%BE%E6%97%B6%E5%B0%86CreateCompatibleBitmap%E6%9B%BF%E6%8D%A2%E6%88%90CreateDIBSection" title="11、创建位图时将CreateCompatibleBitmap替换成CreateDIBSection">11、创建位图时将CreateCompatibleBitmap替换成CreateDIBSection</a></p> 
<p id="%C2%A012%E3%80%81%E6%9C%80%E5%90%8E-toc" style="margin-left:40px"><a href="#%C2%A012%E3%80%81%E6%9C%80%E5%90%8E" title="12、最后">12、最后</a></p> 
<hr id="hr-toc">
<p>       屏幕截图已经成为了所有IM即时通讯软件的必备模块，也是日常办公中使用最频繁的功能之一。今天我们从C++开发的角度，来看看屏幕截图的主要功能点是如何实现的，在此给大家分享一下屏幕截图的诸多实现细节。</p> 
<blockquote> 
 <p>开发工具：Visual Studio 2010</p> 
 <p>开发语言：C++</p> 
 <p>UI框架：MFC（也可以基于开源的duilib框架，其实在duilib中是调用Windows API）</p> 
</blockquote> 
<h2 id="1%E3%80%81%E6%A6%82%E8%BF%B0">1、概述</h2> 
<p>       要使用屏幕截图，其实很容易，装一款聊天软件或者办公软件就可以了，比如QQ、企业微信、钉钉、飞书等。但要开发出类似这些软件的屏幕截图模块，则没那么容易。其实实现屏幕截图的技术并不复杂，主要是在各个细节问题的处理上。</p> 
<p>       有人可能会说，我并不需要自己开发这些功能，我可以去<span style="color:#be191c"><span style="background-color:#fef2f0">搜一些开源的代码</span></span>，也可以到网上搜<span style="color:#be191c"><span style="background-color:#fef2f0">一堆关于屏幕截图的文章或下载资源</span></span>，应该可以找到能用的代码或资源了。我想说的是，<span style="color:#fe2c24">你大可以去试一试，很多都只是讲到了一点皮毛，基本没有一个实现了完备的截图功能，没有一个能拿到实际的项目中去使用的。简单的写几句代码，玩玩还可以，离真正商用到项目中，差的太远了！</span>真正项目级的代码，要考虑各种场景和细节，要考虑性能和稳定性，是经过多轮测试锤炼出来的，不是随便写写就能搞出来的！</p> 
<p>       本文将结合开发屏幕截图的实际项目经历，详细介绍一下屏幕截图各个主要功能点的实现细节与方法，给大家提供一个借鉴和参考。</p> 
<h2 id="2%E3%80%81%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E7%82%B9">2、屏幕截图的主要功能点</h2> 
<p style="text-align:center"><img alt="" height="1024" src="https://images2.imgbox.com/50/3b/7sO3ziXI_o.png" width="654"></p> 
<p>       一个具有完备功能的屏幕截图应该包含以上多个功能点，比如桌面灰化、窗口自动套索、区域放大、矩形等多个图元绘制、输入文字等。</p> 
<h2 id="3%E3%80%81%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E7%9A%84%E4%B8%BB%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">3、屏幕截图的主体实现思路</h2> 
<p>       网上很难找到一篇详细介绍屏幕截图完整功能的实现思路的，那屏幕截图的主体实现思路到底是什么样子的呢？下面我们就来简单地描述一下。<span style="color:#fe2c24"><strong>我们实现的一套屏幕截图的效果如下（文章末尾处提供C++源码下载）：</strong></span></p> 
<p style="text-align:center"><img alt="" height="372" src="https://images2.imgbox.com/7b/62/WZKM69dP_o.png" width="661"></p> 
<p>       下面基于我们实现的屏幕截图，详细介绍一下屏幕截图主要的一些功能点和实现思路。 </p> 
<h3 id="3.1%E3%80%81%E6%88%AA%E5%9B%BE%E4%B8%BB%E7%AA%97%E5%8F%A3%E5%85%A8%E5%B1%8F%E7%BD%AE%E9%A1%B6">3.1、截图主窗口全屏置顶</h3> 
<p>       我们需要创建一个截图的主窗口，开启截图后将该截图主窗口全屏，覆盖整个屏幕，并且给窗口设置TopMost置顶属性。然后我们后续操作都是在这个全屏置顶的窗口上进行绘图出来的，即<span style="color:#fe2c24">截图时截图窗口中看到的所有内容（比如桌面灰化、窗口套索、区域放大、各个图元等）都是绘制上去的！</span></p> 
<h3 id="3.2%E3%80%81%E6%A1%8C%E9%9D%A2%E7%81%B0%E5%8C%96">3.2、桌面灰化</h3> 
<p style="text-align:center"><img alt="" height="358" src="https://images2.imgbox.com/2d/a9/9fvmBkmf_o.png" width="636"></p> 
<p>       在开启截图时，先将当前桌面上的图像保存到位图对象中，保存两份位图，一份是亮色的桌面图像，一份是经过灰化后的桌面图像。先将灰化的位图绘制到截图对话框上，实现灰化的遮罩。然后根据用户拉动鼠标选择的区域，从亮色位图中抠出对应区域的亮色图像绘制到对话框上，就能达到区域选择的效果了。</p> 
<h3 id="3.3%E3%80%81%E7%AA%97%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%A5%97%E7%B4%A2">3.3、窗口自动套索</h3> 
<p style="text-align:center"><img alt="" height="364" src="https://images2.imgbox.com/4a/f0/dBN7D4oW_o.png" width="647"></p> 
<p>       在启动截图时，需要遍历当前系统中所有打开的窗口，以及这些窗口中的子窗口，把这些窗口的坐标位置记录下来保存到内存中。当鼠标移动时，看鼠标移动到哪个最上层的窗口，然后在该窗口的区域绘制上套索的边界，并将该窗口区域“亮”起来。亮起来其实很简单，根据该窗口的坐标到内存中保存的亮色位图中将对应的区域抠出来，绘制到窗口上，然后再在窗口边界上绘制出套索边界线即可。</p> 
<h3 id="3.4%E3%80%81%E5%8C%BA%E5%9F%9F%E6%94%BE%E5%A4%A7">3.4、区域放大</h3> 
<p style="text-align:center"><img alt="" height="356" src="https://images2.imgbox.com/7e/51/clFQ6Qqs_o.png" width="468"></p> 
<p>       其实实现这个功能并不难，可以仔细观察以下主流IM软件的显示细节，就能找到思路和答案了！区域放大是实时地将鼠标移动到的位置的周围区域放大，放大的区域是以鼠标点为中心的一小片矩形区域，然后将该区域放大4倍，将放大的效果绘制到截图对话框上。</p> 
<h3 id="3.5%E3%80%81%E6%88%AA%E5%8F%96%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%80%89%E6%8B%A9">3.5、截取区域的选择</h3> 
<p style="text-align:center"><img alt="" height="368" src="https://images2.imgbox.com/38/13/NMhKowjZ_o.png" width="654"></p> 
<p>       可以使用微软MFC库中提供的橡皮筋类CRectTracker来实现区域的选择。该橡皮筋类对应一个选择边框，通过拉动鼠标，绘制出选择区域的橡皮筋边框，橡皮筋边框支持拖动，改变橡皮筋边框的大小。根据橡皮经选择的区域，到内存中保存的亮色位图中抠出亮色选择区域，绘制到截图窗口上就好了。</p> 
<h3 id="3.5%E3%80%81%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7%E6%9D%A1">3.5、截图工具条</h3> 
<p>        截图工具条一般做成一个紧贴截图选择区域的窗口，窗口中包含一排功能按钮，一般包括矩形工具、椭圆工具、带箭头直线工具、曲线工具、Undo工具、关闭截图、完成截图这几个功能按钮。选择矩形工具、椭圆工具、带箭头直线工具和曲线工具这四个按钮后，鼠标在截图窗口上绘制的就是对应类型的图元。Undo按钮是回撤上一次绘制的图元。</p> 
<h3 id="3.6%E3%80%81%E7%9F%A9%E5%BD%A2%E7%AD%89%E5%9B%BE%E5%85%83%E7%9A%84%E7%BB%98%E5%88%B6">3.6、矩形等图元的绘制</h3> 
<p style="text-align:center"><img alt="" height="453" src="https://images2.imgbox.com/99/32/tMUydZ5c_o.png" width="585"></p> 
<p>       我们需要设计图元类型对应的C++类，这些类统一继承于一个CSharp的基类，基类中保存当前绘制图元的线条颜色、起点和终点坐标，还有一个用于绘制图元内容的纯虚接口Draw，具体的Draw操作都在具体的图元中实现。这其实使用C++中多态的概念。</p> 
<p>        对于矩形、椭圆和带箭头的直线，我们只需要记录图元的起点和终点坐标就可以了，对于曲线，则由多个直线线段构成的，我们要记录绘制过程中的多个点。当用户左键按下时开始绘制图元，记录此时图元起点坐标，在左键弹起时截图当前图元的绘制，记录图元的终点坐标，然后创建对应类型的图元对象，将起点及终点坐标保存到对象中，然后把这些图元对象保存到图元列表中。窗口需要刷新时，调用列表中这些图像的Draw接口将所有图元绘制到截图窗口上。</p> 
<h2 id="4%E3%80%81%20%E6%A1%8C%E9%9D%A2%E7%81%B0%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82">4、桌面灰化的实现细节</h2> 
<p>       开启截图时，将桌面的图像保存到亮色位图对象中，同时对图像进行灰化处理，将处理后的图像保存到暗色位图对象中。保存桌面图像的代码如下所示：</p> 
<pre><code class="language-cpp">// 拷贝桌面，lpRect 代表选定区域，bSave 标记是否将图片内容保存到剪切板中
HBITMAP CScreenCatchDlg::CopyScreenToBitmap( LPRECT lpRect ) 
{                           
    // 确保选定区域不为空矩形
    if ( IsRectEmpty( lpRect ) )
    {
        return NULL;
    }
    
    CString strLog;

    // 为屏幕创建设备描述表
    HDC hScrDC = ::CreateDC( _T("DISPLAY"), NULL, NULL, NULL ); 
    if ( hScrDC == NULL )
    {
        strLog.Format( _T("[CCatchScreenDlg::CopyScreenToBitmap] 创建DISPLAY失败, GetLastError: %d"), 
            GetLastError() );
        WriteScreenCatchLog( strLog );

        return NULL;
    }

    // 为屏幕设备描述表创建兼容的内存设备描述表
    HDC hMemDC = ::CreateCompatibleDC( hScrDC ); 
    if ( hMemDC == NULL )
    {
        strLog.Format( _T("[CCatchScreenDlg::CopyScreenToBitmap]创建与hScrDC兼容的hMemDC失败, GetLastError: %d"), 
            GetLastError() );
        WriteScreenCatchLog( strLog );

        ::DeleteDC( hScrDC );
        return NULL;
    }

    int nX = 0;
    int nY = 0;
    int nX2 = 0;
    int nY2 = 0;   
    int nWidth = 0; 
    int nHeight = 0;

    // 保证left小于right，top小于bottom
    LONG lTemp = 0;
    if ( lpRect-&gt;left &gt; lpRect-&gt;right )
    {
        lTemp = lpRect-&gt;left;
        lpRect-&gt;left = lpRect-&gt;right;
        lpRect-&gt;right = lTemp;
    }
    if ( lpRect-&gt;top &gt; lpRect-&gt;bottom )
    {
        lTemp = lpRect-&gt;top;
        lpRect-&gt;top = lpRect-&gt;bottom;
        lpRect-&gt;bottom = lTemp;
    }
    
    // 获得选定区域坐标
    nX = lpRect-&gt;left;
    nY = lpRect-&gt;top;
    nX2 = lpRect-&gt;right;
    nY2 = lpRect-&gt;bottom;
    
    // 确保选定区域是可见的
    if ( nX &lt; 0 )
    {
        nX = 0;
    }

    if ( nY &lt; 0 )
    {
        nY = 0;
    }

    if ( nX2 &gt; m_xScreen )
    {
        nX2 = m_xScreen;
    }

    if ( nY2 &gt; m_yScreen )
    {
        nY2 = m_yScreen;
    }

    nWidth = nX2 - nX;
    nHeight = nY2 - nY;
    // 创建一个与屏幕设备描述表兼容的位图
    HBITMAP hBitmap = ::CreateCompatibleBitmap( hScrDC, nWidth, nHeight ); 
    if ( hBitmap == NULL )
    {
        strLog.Format( _T("[CCatchScreenDlg::CopyScreenToBitmap]创建与hScrDC兼容的Bitmap失败, GetLastError: %d"), 
            GetLastError() );
        WriteScreenCatchLog( strLog );

        ::DeleteDC( hScrDC );
        ::DeleteDC( hMemDC );
        return NULL;
    }
    // 把新位图选到内存设备描述表中
    ::SelectObject( hMemDC, hBitmap );     
    
    BOOL bRet = ::BitBlt( hMemDC, 0, 0, nWidth, nHeight, hScrDC, nX, nY, SRCCOPY | CAPTUREBLT );  // CAPTUREBLT - 该参数保证能够截到透明窗口
    if ( !bRet )
    {
        strLog.Format( _T("[CCatchScreenDlg::CopyScreenToBitmap]将hScrDC拷贝到hMemDC失败, GetLastError: %d"), 
            GetLastError() );
        WriteScreenCatchLog( strLog );

        ::DeleteDC( hScrDC );
        ::DeleteDC( hMemDC );
        ::DeleteObject( hBitmap );
        return NULL;
    }
    
    if ( hScrDC != NULL )
    {
        ::DeleteDC( hScrDC );
    }

    if ( hMemDC != NULL )
    {
        ::DeleteDC( hMemDC );
    }

    return hBitmap; // hBitmap资源不能释放，因为函数外部要使用
}</code></pre> 
<p>        如何将桌面图像进行灰化处理呢？其实很简单，只要将保存的桌面位图中的每个像素值的RGB读出来，将每个像素中的R、G、B值都乘以一个系数，然后再将这些值设置回位图中即可，相关代码如下：</p> 
<pre><code class="language-cpp">void CScreenCatchDlg::GrayLightBmp()
{
    CString strLog;

    CDC *pDC = GetDC();
    ASSERT( pDC );
    if ( pDC == NULL )
    {
        strLog.Format( _T("[CCatchScreenDlg::DoGrayLightBmp] GetDC失败, GetLastError: %d"), 
            GetLastError() );
        WriteScreenCatchLog( strLog );
        return;
    }

    CBitmap cbmp; 
    cbmp.Attach( m_hGreyBitmap ); // 此处使用临时保存亮色位图的m_hDarkBitmap
    BITMAP bmp; 
    cbmp.GetBitmap( &amp;bmp ); 
    cbmp.Detach(); // 需要将对象和句柄分离，m_hDarkBitmap位图资源需要保存在内存中，如不分离，则当对象消亡时，m_hDarkBitmap位图资源会自动被释放掉
    UINT *pData = new UINT[bmp.bmWidth * bmp.bmHeight]; 
    if ( pData == NULL )
    {
        int nSize = bmp.bmWidth * bmp.bmHeight;
        strLog.Format( _T("[CCatchScreenDlg::DoGrayLightBmp]pData通过new申请%s字节的内存失败，直接return"), nSize );
        WriteScreenCatchLog( strLog );

        ReleaseDC( pDC );
        return;
    }

    BITMAPINFO bmpInfo; 
    bmpInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER); 
    bmpInfo.bmiHeader.biWidth = bmp.bmWidth; 
    bmpInfo.bmiHeader.biHeight = -bmp.bmHeight; 
    bmpInfo.bmiHeader.biPlanes = 1; 
    bmpInfo.bmiHeader.biCompression = BI_RGB; 
    bmpInfo.bmiHeader.biBitCount = 32; 
    
    int nRet = GetDIBits( pDC-&gt;m_hDC, m_hGreyBitmap, 0, bmp.bmHeight, pData, &amp;bmpInfo, DIB_RGB_COLORS );
    if ( 0 == nRet )
    {
        strLog.Format( _T("[CCatchScreenDlg::DoGrayLightBmp]GetDIBits失败 nRet == 0, GetLastError: %d"), 
            GetLastError() );
        WriteScreenCatchLog( strLog );
    }

    // 将图像中的所有像素点的RGB值都乘以0.4，即实现了图像的灰化
    UINT color, r, g, b; 
    for ( int i = 0; i &lt; bmp.bmWidth * bmp.bmHeight; i++ ) 
    { 
        color = pData[i]; 
        b = ( color &lt;&lt; 8 &gt;&gt; 24 ) * 0.4; 
        g = ( color &lt;&lt; 16 &gt;&gt; 24 ) * 0.4; 
        r = ( color &lt;&lt; 24 &gt;&gt; 24 ) * 0.4; 
        pData[i] = RGB(r, g, b); 
    } 

    // 如果函数成功，那么返回值就是复制的扫描线数；如果函数失败，那么返回值是0。
    nRet = SetDIBits( pDC-&gt;m_hDC, m_hGreyBitmap, 0, bmp.bmHeight, pData, &amp;bmpInfo, DIB_RGB_COLORS ); 
    if ( 0 == nRet )
    {
        strLog.Format( _T("[CCatchScreenDlg::DoGrayLightBmp]SetDIBits失败 nRet == 0, GetLastError: %d"), 
            GetLastError() );
        WriteScreenCatchLog( strLog );
    }

    delete []pData;
    pData = NULL;
    ReleaseDC( pDC );
}</code></pre> 
<p>        内存中要保留两份位图，一份是亮色的桌面图像，一份是经过灰化后的桌面图像。先将灰化的位图绘制到截图对话框上，实现灰化的遮罩。然后根据用户拉动鼠标选择的区域，从亮色位图中抠出对应区域的亮色图像绘制到对话框上，就能达到区域选择的效果了。</p> 
<h2 id="5%E3%80%81%E7%AA%97%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%A5%97%E7%B4%A2%E5%AE%9E%E7%8E%B0">5、窗口自动套索实现</h2> 
<p>       在启动截图时，需要遍历当前系统中所有打开的窗口，以及这些窗口中的子窗口，把这些窗口的坐标位置记录下来保存到内存中。先调用系统API函数EnumWindows，将系统中打开的窗口都枚举出来：</p> 
<pre><code class="language-cpp">	// 使用EnumWindows来枚举当前系统打开的所有大窗口
	::EnumWindows( EnumWindowsProc, NULL );


BOOL CEnumWindows::EnumWindowsProc( HWND hWnd, LPARAM lParam )
{
	TCHAR achWndName[MAX_PATH+1] = {0};

	if ( ::IsWindow(hWnd) &amp;&amp; ::IsWindowVisible(hWnd) &amp;&amp; !::IsIconic(hWnd) )
	{
		// 保存所有有效窗口
		EnumedWindowInfo tWndInfo;
		tWndInfo.m_hWnd = hWnd;

		::GetWindowText( hWnd, achWndName, sizeof(achWndName)/sizeof(TCHAR) );
		tWndInfo.m_strWndName = achWndName;

		 将桌面区域过滤掉
		//if ( !_tcscmp( tWndInfo.m_strWndName, _T("Program Manager") ) )
		//{
		//	return TRUE;
		//}

		::GetWindowRect( hWnd, &amp;(tWndInfo.m_rcWnd) );
		m_listWindows.push_back( tWndInfo );
	}

	return TRUE;
}</code></pre> 
<p>然后再遍历这些窗口，使用递归调用的方式找出这些主窗口的各个子窗口，记录下这些子窗口的信息。</p> 
<p>       当鼠标移动时，根据鼠标的位置坐标，到窗口信息列表中去遍历，看鼠标移动到哪个最上层的窗口，然后在该窗口的区域绘制上套索的边界，并将该窗口区域“亮”起来。亮起来其实很简单，根据该窗口的坐标到内存中保存的亮色位图中将对应的区域抠出来，绘制到窗口上，然后再在窗口边界上绘制出套索边界线即可。</p> 
<h2 id="6%E3%80%81%E5%8C%BA%E5%9F%9F%E6%94%BE%E5%A4%A7%E5%AE%9E%E7%8E%B0">6、区域放大实现</h2> 
<p>        实现这点也不难，可以仔细观察以下主流IM软件的显示细节，就能找到思路与方法了！区域放大是实时地将鼠标移动到的位置的周围区域放大，放大的区域是以鼠标点为中心的一小片矩形区域。</p> 
<p>       确定待放大区域的坐标后，从内存中保存的桌面亮色位图中抠出亮色的待放大区域，然后调用StretchBlt将放大后的图像绘制到截图窗口上，相关代码如下：</p> 
<pre><code class="language-cpp">// 在内存pMemDC中绘制自动套索窗口
void CScreenCatchDlg::DrawAutoLassoWndArea( CDC* pMemDC, CDC* pLightDC )
{
	if ( pMemDC == NULL || pLightDC == NULL )
	{
		return;
	}

	if ( m_rcTargetWnd.IsRectEmpty() )
	{
		return;
	}

	// 先从亮色图片将目标窗口抠出
	CRect rcArea = m_rcTargetWnd;
	BOOL bRet = pMemDC-&gt;BitBlt( rcArea.left, rcArea.top, rcArea.Width(), rcArea.Height(),
		pLightDC, rcArea.left, rcArea.top, SRCCOPY );
	if ( !bRet )
	{
		WriteScreenCatchLog( _T("[CCatchScreenDlg::DrawAutoLassoWndPic]pMemDC-&gt;BitBlt(rcArea.left,rcArea.top…失败") );
	}

	rcArea.left = (rcArea.left-4&lt;0) ? 4 : rcArea.left;
	rcArea.top = (rcArea.top-4&lt;0) ? 4 : rcArea.top;
	rcArea.right = (rcArea.right+4&gt;m_xScreen) ? (m_xScreen-4) : rcArea.right;
	rcArea.bottom = (rcArea.bottom+4&gt;m_yScreen) ? (m_yScreen-4) : rcArea.bottom;

	// 再在目标窗口周边画上自动套索边界线
    CPen pen( PS_SOLID, 1, RGB( 0, 174, 255 ) );
	CPen* pOldPen = pMemDC-&gt;SelectObject( &amp;pen );
	CBrush* pOldBrush = ( CBrush* )pMemDC-&gt;SelectStockObject( NULL_BRUSH ); // 使用NULL_BRUSH调用SelectStockObject可以实现透明画刷的效果
	rcArea.InflateRect( 1, 1 );
	pMemDC-&gt;Rectangle( &amp;rcArea );
	rcArea.InflateRect( 1, 1 );
	pMemDC-&gt;Rectangle( &amp;rcArea );
	rcArea.InflateRect( 1, 1 );
	pMemDC-&gt;Rectangle( &amp;rcArea );
	rcArea.InflateRect( 1, 1 );
	pMemDC-&gt;Rectangle( &amp;rcArea );
	//rcArea.DeflateRect( 1, 1 );
	//rcArea.DeflateRect( 1, 1 );
	//pMemDC-&gt;Rectangle( &amp;rcArea );
	//rcArea.DeflateRect( 1, 1 );
	//pMemDC-&gt;Rectangle( &amp;rcArea );
	//rcArea.DeflateRect( 1, 1 );
	//pMemDC-&gt;Rectangle( &amp;rcArea );

	pMemDC-&gt;SelectObject( pOldBrush );
	pMemDC-&gt;SelectObject( pOldPen );
}</code></pre> 
<h2 id="%C2%A07%E3%80%81%E6%88%AA%E5%8F%96%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%80%89%E6%8B%A9">7、截取区域的选择</h2> 
<p>        微软MFC库中的橡皮筋类CRectTracker是个好东西，绘制出来的是个有边框线的矩形边界线，边框线上有八个点可以用鼠标点击拖动来改变矩形边界线的大小。我们正可以使用这个橡皮筋类来实现截图区域的选择。</p> 
<p>       橡皮筋类CRectTracker实现的有点复杂，也很巧妙，我们将该类的代码从MFC库中拿出来，对其进行一些简单灵活的改造，就可以用到截图模块中。添加一些消息通知和额外的处理机制。抠出来的类，我们命名为CCatchTracker，其头文件如下所示：</p> 
<pre><code class="language-cpp">/
// CCatchTracker - simple rectangular tracking rectangle w/resize handles


// CCatchTracker类从MFC源文件COPY过来，根据自身的需要做了修改，对消息机制
// 做了点改动，增加了部分接口


#ifndef CATCH_SCREEN_TRACKER_H
#define CATCH_SCREEN_TRACKER_H

#define CX_BORDER   1
#define CY_BORDER   1

#define WM_UPDATE_TOOLBAR_POS ( WM_USER+700 ) // 更新截图工具条位置消息，当截取区域发生变化时要向界面发送该消息

#define CRIT_RECTTRACKER    5
void AFXAPI AfxLockGlobals(int nLockType);
void AFXAPI AfxUnlockGlobals(int nLockType);
void AFXAPI AfxDeleteObject(HGDIOBJ* pObject);

enum TrackerHit
{
	hitNothing = -1,
	hitTopLeft = 0, hitTopRight = 1, hitBottomRight = 2, hitBottomLeft = 3,
	hitTop = 4, hitRight = 5, hitBottom = 6, hitLeft = 7, hitMiddle = 8
};

class CCatchTracker
{
public:
// Constructors
	CCatchTracker();
	CCatchTracker(LPCRECT lpSrcRect, UINT nStyle);

// Style Flags
	enum StyleFlags
	{
		solidLine = 1, dottedLine = 2, hatchedBorder = 4,
		resizeInside = 8, resizeOutside = 16, hatchInside = 32,
		resizeMiddle =80 //设置中间
	};

// Hit-Test codes
	//enum TrackerHit
	//{
	//	hitNothing = -1,
	//	hitTopLeft = 0, hitTopRight = 1, hitBottomRight = 2, hitBottomLeft = 3,
	//	hitTop = 4, hitRight = 5, hitBottom = 6, hitLeft = 7, hitMiddle = 8
	//};

// Operations
	void Draw(CDC* pDC) const;
	void GetTrueRect(LPRECT lpTrueRect) const;
	BOOL SetCursor(CWnd* pWnd, UINT nHitTest) const;
	BOOL Track(CWnd* pWnd, CPoint point, BOOL bAllowInvert =TRUE,
		CWnd* pWndClipTo = NULL);
	BOOL TrackRubberBand(CWnd* pWnd, CPoint point, BOOL bAllowInvert = TRUE);
	int HitTest(CPoint point) const;
	int NormalizeHit(int nHandle) const;

// Overridables
	virtual void DrawTrackerRect(LPCRECT lpRect, CWnd* pWndClipTo,
		CDC* pDC, CWnd* pWnd);
	virtual void AdjustRect(int nHandle, LPRECT lpRect);
	virtual void OnChangedRect(const CRect&amp; rectOld);
	virtual UINT GetHandleMask() const;

// Implementation
public:
	virtual ~CCatchTracker();

public:
	// 设置调整光标
	void SetResizeCursor(UINT nID_N_S,UINT nID_W_E,UINT nID_NW_SE, UINT nID_NE_SW,UINT nIDMiddle);
	// 创建画刷,内部调用
	void CreatePen();
	// 设置矩形颜色
	void SetRectColor(COLORREF rectColor);
	// 设置该矩形tracker是否可以移动，当点击截图工具条中的按钮后即不可移动
	void SetMovable( BOOL bMoveable );
	BOOL GetMovable(){ return m_bMovable; };

	// implementation helpers
	int HitTestHandles(CPoint point) const;
	void GetHandleRect(int nHandle, CRect* pHandleRect) const;
	void GetModifyPointers(int nHandle, int**ppx, int**ppy, int* px, int*py);
	virtual int GetHandleSize(LPCRECT lpRect = NULL) const;
	BOOL TrackHandle(int nHandle, CWnd* pWnd, CPoint point, CWnd* pWndClipTo);
	void Construct();
    void SetMsgHwnd(HWND hwnd);

public:
	// Attributes
	UINT m_nStyle;          // current state
	CRect m_rect;           // current position (always in pixels)
	CSize m_sizeMin;        // minimum X and Y size during track operation
	int m_nHandleSize;      // size of resize handles (default from WIN.INI)
	BOOL m_bAllowInvert;    // flag passed to Track or TrackRubberBand
	CRect m_rectLast;
	CSize m_sizeLast;
	BOOL m_bErase;          // TRUE if DrawTrackerRect is called for erasing
	BOOL m_bFinalErase;     // TRUE if DragTrackerRect called for final erase

	COLORREF m_rectColor;   // 当前矩形颜色
    HWND m_hMsgWnd;         // 向界面发送消息的窗口句柄
    BOOL m_bMovable;        // 标记该矩形tracker是否可以移动，当点击截图工具条中的按钮后即不可移动
};

#endif</code></pre> 
<p>       根据橡皮经选择的区域，到内存中保存的亮色位图中抠出亮色选择区域，绘制到截图窗口上就好了。截图工具条是紧贴着橡皮筋选择区域的，位于该区域的下方，当橡皮筋区域大小发生变化时，要通知截图工具条窗口跟着截图区域一起动，使截图工具条紧跟着橡皮筋选择区域。所以我们在橡皮筋类中抛出如下的通知消息：</p> 
<pre><code class="language-cpp">		switch (msg.message)
		{
		// handle movement/accept messages
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			rectOld = m_rect;
			// handle resize cases (and part of move)
			if (px != NULL)
				*px = (int)(short)LOWORD(msg.lParam) - xDiff;
			if (py != NULL)
				*py = (int)(short)HIWORD(msg.lParam) - yDiff;

			// handle move case
			if (nHandle == hitMiddle)
			{
				m_rect.right = m_rect.left + nWidth;
				m_rect.bottom = m_rect.top + nHeight;
			}

			// 发送矩形区域的左上角和右下角的坐标给界面，一方面在移动矩形时要用到，
			// 一方面在更新界面中的截图工具条的位置时要用到
			if ( IsWindow( m_hMsgWnd ) ) // 检验是否是有效的窗口句柄
			{
				BOOL bLBtnUp = FALSE;
				if ( msg.message == WM_LBUTTONUP )
				{
					bLBtnUp = TRUE;
				}
				::SendMessage(m_hMsgWnd, WM_UPDATE_TOOLBAR_POS, (WPARAM)&amp;m_rect, (LPARAM)bLBtnUp );
			}</code></pre> 
<h2 id="8%E3%80%81%E7%9F%A9%E5%BD%A2%E7%AD%89%E5%9B%BE%E5%85%83%E7%9A%84%E7%BB%98%E5%88%B6">8、矩形等图元的绘制</h2> 
<p>        截图中要支持矩形、椭圆、带箭头直线和曲线四种图元的绘制，我们分别设计了与图元类型对应的C++类，这些类统一继承于一个CSharp的基类，基类中保存当前绘制图元的线条颜色、起点和终点坐标，还有一个用于绘制图元内容的纯虚接口Draw：</p> 
<pre><code class="language-cpp">// 形状基类
class CShape
{
public:
	CShape();
	virtual ~CShape();

	virtual void Draw( CDC* pDC ) = 0;

protected:
	CPoint m_startPt;  // 起点
	CPoint m_endPt;    // 终点
    COLORREF m_color;  // 当前使用颜色
};</code></pre> 
<p>具体的Draw操作都在具体的图元中实现。这其实使用C++中多态的概念。</p> 
<p>       以矩形图元为例，矩形类CRectangle的头文件如下：</p> 
<pre><code class="language-cpp">// 矩形
class CRectangle : public CShape
{
public:
	CRectangle( CPoint startPt, CPoint endPt );
	~CRectangle();

	void Draw( CDC* pDC );
};</code></pre> 
<p> cpp源文件的代码如下：</p> 
<pre><code class="language-cpp">CRectangle::CRectangle( CPoint startPt, CPoint endPt )
{
	m_startPt = startPt;
	m_endPt = endPt;
}

CRectangle::~CRectangle()
{

}

void CRectangle::Draw( CDC* pDC )
{
	if ( pDC == NULL )
	{
		return;
	}

	Pen pen( Color(255, 0, 0), 2.0 );
	pen.SetLineCap(LineCapRound, LineCapRound, DashCapRound);
	Graphics graphics( pDC-&gt;GetSafeHdc() );
	//graphics.SetSmoothingMode( SmoothingModeAntiAlias );
	//graphics.DrawRectangle( &amp;pen, m_startPt.x, m_startPt.y, m_endPt.x-m_startPt.x, m_endPt.y-m_startPt.y );

	CRect rcTemp(  m_startPt.x, m_startPt.y, m_endPt.x, m_endPt.y );
	rcTemp.NormalizeRect();
	Status stRet = graphics.DrawRectangle( &amp;pen, rcTemp.left, rcTemp.top, 
		rcTemp.Width(), rcTemp.Height() );
}</code></pre> 
<p>        对于矩形、椭圆和带箭头的直线，我们只需要记录图元的起点和终点坐标就可以了，对于曲线，则由多个直线线段构成的，我们要记录绘制过程中的多个点。当用户左键按下时开始绘制图元，记录此时图元起点坐标，在左键弹起时截图当前图元的绘制，记录图元的终点坐标，然后创建对应类型的图元对象，将起点及终点坐标保存到对象中，然后把这些图元对象保存到图元列表中。窗口需要刷新时，调用列表中这些图像的Draw接口将所有图元绘制到截图窗口上。</p> 
<p>       最开始我们是使用GDI函数绘制图元的，比如GDI中的API函数Reactangle（绘制矩形）、Ellipse（绘制椭圆）等，但在绘制带箭头的直线和曲线时，GDI函数绘制出来的结果中有明显的锯齿，效果很不好。所以后来我们将图元的绘制全部改成使用GDI+库来处理，GDI+中的Graphics类在绘制图元时，可以设置反锯齿的模式：</p> 
<pre><code class="language-cpp">	case emBtnEllipse: // 画椭圆
		{
			// 为了抗锯齿，均使用GDI+来绘制图元（GDI绘制直线和曲线时有明显的锯齿）
			Pen pen( Color(255, 0, 0), WIDTH_DRAW_PEN );
			Graphics graphics( m_tmpDrawDC.GetSafeHdc() );
			graphics.SetSmoothingMode( SmoothingModeAntiAlias );
			graphics.DrawEllipse( &amp;pen, m_drawStartPt.x/*-m_rectTracker.m_rect.left*/, m_drawStartPt.y/*-m_rectTracker.m_rect.top*/, 
				point.x-m_drawStartPt.x/*+m_rectTracker.m_rect.left*/, 
				point.y-m_drawStartPt.y/*+m_rectTracker.m_rect.top*/ );
		}
		break;</code></pre> 
<h2 id="9%E3%80%81%E6%88%AA%E5%9B%BE%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6">9、截图窗口的绘制机制</h2> 
<p>       整个全屏置顶的截图主窗口上面显示的所有内容都是都是我们在截图窗口中绘制出来的，比如窗口的自动套索效果、区域放大效果、截图区域的橡皮筋选择框、各种图元的绘制等。</p> 
<p>        我们要在截图窗口上接管所有内容的绘制，需要拦截截图窗口的WM_ERASEBKGND和WM_PAINT消息。首先在收到WM_ERASEBKGND消息后，直接return TRUE，不需要系统帮我们绘制背景：</p> 
<pre><code class="language-cpp">BOOL CScreenCatchDlg::OnEraseBkgnd( CDC* pDC ) 
{
	return TRUE;
}</code></pre> 
<p>       在收到WM_PAINT消息时，使用双缓冲绘制去绘制截图窗口上要绘制的内容。所谓双缓冲绘图的思想是，先将所有需要绘制的内容绘制到内存DC上，这些绘制可能需要时间，然后再将内存DC中的内容绘制到窗口（DC）上。双缓冲绘图是解决绘制时窗口闪烁的有效方法。</p> 
<p>       在处理WM_PAINT消息时，需要调用BeginPaint和EndPaint在绘制完窗口后将窗口的无效区域清空，切记要记得调用这两个函数。如果不调用这两个接口，会导致窗口一直有无效区域，这样系统一直都检测到窗口有无效区域，一直在不断地产生WM_PAINT消息，这样程序一直在忙于处理WM_PAINT消息，导致低优先的WM_TIMER消息被淹没被丢弃，界面由于在不断绘制会产生严重的闪烁问题。在我们的OnPaint函数中，我们使用到了CPaintDC类，该类中封装了对BeginPaint和EndPaint的调用：</p> 
<pre><code class="language-cpp">CPaintDC::CPaintDC(CWnd* pWnd)
{
	ASSERT_VALID(pWnd);
	ASSERT(::IsWindow(pWnd-&gt;m_hWnd));

	if (!Attach(::BeginPaint(m_hWnd = pWnd-&gt;m_hWnd, &amp;m_ps)))
		AfxThrowResourceException();
}

CPaintDC::~CPaintDC()
{
	ASSERT(m_hDC != NULL);
	ASSERT(::IsWindow(m_hWnd));

	::EndPaint(m_hWnd, &amp;m_ps);
	Detach();
}
</code></pre> 
<p>        有时我们在某些操作后，我们想让窗口立即刷新，可以组合调用InvalidateRect和UpdateWindow，InvalidateRect是让窗口无效，UpdateWindow是让系统立即产生WM_PAINT消息，并将WM_PAINT投递到窗口过程（不是将WM_PAINT放到消息队列中等待处理），这样窗口能立即刷新。调用UpdateWindow就相当于让窗口立即强制刷新。<br>        至于WM_PAINT、BeginPaint、InvalidateRect和UpdateWindow之间的关系，可以参见我之前专门写的一篇主题文章：<a class="link-info" href="https://blog.csdn.net/chenlycly/article/details/120931704">https://blog.csdn.net/chenlycly/article/details/120931704</a>，里面有详细地讲述这些对象的关系。</p> 
<h2 id="10%E3%80%81%E6%88%AA%E5%9B%BE%E9%80%80%E5%87%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1">10、截图退出类型的详细设计</h2> 
<p>       有多种退出截图的场景，不同的退出场景可能需要有不同的后续处理，所以我们定义了多种退出截图时的类型：</p> 
<pre><code class="language-cpp">enum EmQuitType
{
	emQuitInvalid = -1,     // 无效退出类型
	emESCQuit   = 0,        // 按ESC键退出
	emRClickQuit,           // 右键单击退出
	emLDClickQuit,          // 左键双击退出
	emSendtoBlogQuit,       // 发送到微博退出
	emSaveQuit,             // 保存截图后退出
	emCancelQuit,           // 取消截图退出
	emCompleteQuit,         // 完成截图退出
	emMemoryLackQuit,       // 内存不足引起的gdi操作失败退出
	emCutRectEmptyQuit      // 截取区域为空退出       
};</code></pre> 
<p><strong>1）按下ESC键退出、右键点击退出、保存图片退出、点击取消按钮退出、截取区域为空退出</strong><br>        这些场景下退出截图，截图模块不需要任何处理，都是单纯的退出截图。</p> 
<p><strong>2）双击截图区域退出截图、点击完成按钮退出截图</strong><br>        这些场景下,在退出截图之前，会将截取区域的图片位图保存到剪切板中，同时将截图保存到磁盘文件中。退出截图后，如果是聊天框中的截图入口触发的，需要将截取的图片自动插入到聊天框中。</p> 
<p><strong>3）内存不足截图失败退出</strong></p> 
<p><strong>        </strong>这种场景是因为系统内存不足导致GDI函数调用失败，外部需要弹出“截图失败，可能是系统内存不足引起的，退出部分程序后再试”的提示。<br>         所以我们根据这些退出的场景设计了对应的退出类型，在退出截图时设置退出类型，并提供获取退出截图时退出类型的接口GetQuitType，这样在退出截图后，外部调用GetQuitType获取当前截图退出的类型，看是否需要进行后续的处理。</p> 
<h2 id="11%E3%80%81%E5%88%9B%E5%BB%BA%E4%BD%8D%E5%9B%BE%E6%97%B6%E5%B0%86CreateCompatibleBitmap%E6%9B%BF%E6%8D%A2%E6%88%90CreateDIBSection">11、创建位图时将CreateCompatibleBitmap替换成CreateDIBSection</h2> 
<p>       最开始我们再代码中创建位图时调用的是CreateCompatibleBitmap，但是该接口在系统内存不是很充足的时候会经常返回失败，在日常的测试中经常遇到。通过GetLastError获取到CreateCompatibleBitmap调用失败后的错误码是8：</p> 
<p style="text-align:center"><img alt="" height="178" src="https://images2.imgbox.com/2f/3e/qLWrKqzU_o.png" width="298"></p> 
<p>该错误码的描述如上，意思就是当前系统的可用内存空间不多了，而调用CreateCompatibleBitmap创建位图时需要申请一定的内存空间，空间不够时该函数就会返回失败了。</p> 
<p>       经后来查阅相关资料得知，袁峰老师在他编写的《Windows图形编程》一书中提过，CreateCompatibleBitmap创建的文图是DDB位图，是依赖设备的设备相关位图，是从内核地址空间中分配的，而内核内存资源比较有限，建议使用CreateDIBSection来创建位图，书中的具体描述如下：</p> 
<p style="text-align:center"><img alt="" height="565" src="https://images2.imgbox.com/32/5d/RsU8Imle_o.png" width="672"></p> 
<p>       CreateDIBSection创建的位图是DIB位图，是不依赖于设备的设备无关位图，是从用户态地址空间中的虚拟内存中分配的，限制比较少，一般都会成功。所以后来我们封装了一个创建位图的接口，如下：</p> 
<pre><code class="language-cpp">// 创建设备无关位图，解决调用CreateCompatibleBitmap API函数因内存不足创建位图
// 失败的问题
HBITMAP CreateDIBBitmap( const int nWidth, const int nHeight )
{
	BITMAPINFO bmi;
	::ZeroMemory( &amp;bmi, sizeof(bmi) );
	bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
	bmi.bmiHeader.biWidth = nWidth;
	bmi.bmiHeader.biHeight = nHeight;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biBitCount = 32;
	bmi.bmiHeader.biCompression = BI_RGB;
	bmi.bmiHeader.biSizeImage = nWidth * nHeight * 4;//4=bmi.bmiHeader.biBitCount/8

	void* pvBits = NULL;
	return ::CreateDIBSection( NULL, &amp;bmi, DIB_RGB_COLORS, &amp;pvBits, NULL, 0 );
}</code></pre> 
<h2 id="%C2%A012%E3%80%81%E6%9C%80%E5%90%8E">12、最后</h2> 
<p>       本文讲述了屏幕截图中的一些实现思路与细节，但在实际实现时的细节比上面说的多的多！</p> 
<p><strong><span style="color:#fe2c24">此处，我们提供一个工程级、高质量的完整屏幕截图的C++实现源码下载链接：</span></strong><a class="link-info has-card" href="https://download.csdn.net/download/chenlycly/38061403"><span class="link-card-box"><span class="link-title">功能齐全的屏幕截图C++实现源码 - ScreenCatch.zip</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/3f/91/WFKH6EaU_o.png" alt="icon-default.png?t=LA46">https://download.csdn.net/download/chenlycly/38061403</span></span></a></p> 
<p>在源码中，我们将截图模块封装成一个dll，并提供了一个调用dll接口的工程TestScreenCatch（该工程和截图dll均提供完整的C++源码），调用截图dll接口的代码如下：</p> 
<pre><code class="language-cpp">void CTestScreenCatchDlg::OnBnClickedBtnStartCapture()
{
	CString strPath = GetModuleFullPath();

	// 该接口中会弹出截图的模态框，截图对话框关闭后该接口才会返回
	// 接口弹出模块框，不会堵塞整个线程，模态框内部会接管消息循环，会分发消息
	DoScreenCatch( (LPCTSTR)strPath );

	EmQuitType emQuitType = GetQuitType();
	if ( emQuitType == emLDClickQuit || emQuitType == emCompleteQuit )
	{
		if ( IsPicFileSaved() )
		{
			TCHAR achPciPath[MAX_PATH] = { 0 };
			GetPicFileSavedPath( achPciPath, sizeof(achPciPath)/sizeof(TCHAR) );

			CString strTip;
			strTip.Format( _T("截图保存到路径：%s"), achPciPath );
			AfxMessageBox( strTip );
		}
	}
	else if ( emQuitType == emMemoryLackQuit )
	{
		AfxMessageBox( _T("截图失败，可能是内存不足引起的，退出部分程序后再试！") );
	}
}
</code></pre>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>