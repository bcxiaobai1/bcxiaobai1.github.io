<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Kubernetes架构与组件详解 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kubernetes架构与组件详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>Kubernetes架构与组件详解</h3> 
 <ul>
<li><a href="#Kubernetes__4">一、Kubernetes 简介</a></li>
<li>
<ul>
<li><a href="#1__Kubernetes_5">1 什么是 Kubernetes</a></li>
<li><a href="#2_Kubernetes__8">2 Kubernetes 的优势</a></li>
<li><a href="#3_Kubernetes__16">3 Kubernetes 的应用场景</a></li>
</ul> 
  </li>
<li><a href="#Kubernetes__23">二、Kubernetes 架构</a></li>
<li>
<ul>
<li><a href="#1_Kubernetes__24">1 Kubernetes 架构概述</a></li>
<li><a href="#2_Kubernetes__27">2 Kubernetes 架构组件介绍</a></li>
<li>
<ul>
<li><a href="#21__28">2.1 控制面板组件</a></li>
<li><a href="#22_API_Server_31">2.2 API Server</a></li>
<li><a href="#23_etcd_34">2.3 etcd</a></li>
<li><a href="#24_kubelet_37">2.4 kubelet</a></li>
<li><a href="#25_kubeproxy_40">2.5 kube-proxy</a></li>
<li><a href="#26_CNI__43">2.6 CNI 插件</a></li>
<li><a href="#27__46">2.7 容器运行时</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#Kubernetes__50">三、Kubernetes 应用管理</a></li>
<li>
<ul>
<li><a href="#1_Pod__54">1 Pod 概述</a></li>
<li>
<ul>
<li><a href="#11_Pod__56">1.1 Pod 概念</a></li>
<li><a href="#12_Pod__60">1.2 Pod 的生命周期</a></li>
</ul> 
   </li>
<li><a href="#2_Kubernetes__69">2 Kubernetes 模型简介</a></li>
<li>
<ul>
<li><a href="#21_Deployment__73">2.1 Deployment 模型</a></li>
<li><a href="#22_StatefulSet__101">2.2 StatefulSet 模型</a></li>
<li><a href="#23_DaemonSet__130">2.3 DaemonSet 模型</a></li>
<li><a href="#24_Job__157">2.4 Job 模型</a></li>
</ul> 
   </li>
<li><a href="#3_Kubernetes__181">3 Kubernetes 配置管理</a></li>
<li>
<ul>
<li><a href="#31_ConfigMap_185">3.1 ConfigMap</a></li>
<li><a href="#32_Secret_208">3.2 Secret</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#_Kubernetes__228">四、 Kubernetes 网络模型</a></li>
<li>
<ul>
<li><a href="#1_Kubernetes__232">1 Kubernetes 网络概述</a></li>
<li><a href="#2_Kubernetes__242">2 Kubernetes 网络方案</a></li>
<li>
<ul>
<li><a href="#21__Docker__246">2.1 单节点 Docker 桥接模式</a></li>
<li><a href="#22_CNI__250">2.2 CNI 模式</a></li>
<li><a href="#23_Service__254">2.3 Service 模式</a></li>
</ul> 
   </li>
<li><a href="#3_Kubernetes__258">3 Kubernetes 网络管理工具</a></li>
<li>
<ul>
<li><a href="#31_kuberouter_262">3.1 kube-router</a></li>
<li><a href="#32_Cilium_266">3.2 Cilium</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#_Kubernetes__270">五、 Kubernetes 存储管理</a></li>
<li>
<ul>
<li><a href="#1_Kubernetes__274">1 Kubernetes 存储概述</a></li>
<li><a href="#2_Kubernetes__278">2 Kubernetes 存储模型</a></li>
<li>
<ul>
<li><a href="#21_Volume_280">2.1 Volume</a></li>
<li><a href="#22_PersistentVolumeClaim_284">2.2 PersistentVolume/Claim</a></li>
</ul> 
   </li>
<li><a href="#53_Kubernetes__288">53 Kubernetes 存储管理工具</a></li>
<li>
<ul>
<li><a href="#31_Ceph_292">3.1 Ceph</a></li>
<li><a href="#32_GlusterFS_296">3.2 GlusterFS</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#_Kubernetes__300">六、 Kubernetes 安全策略</a></li>
<li>
<ul>
<li><a href="#1_Kubernetes__302">1 Kubernetes 安全概述</a></li>
<li><a href="#2_Kubernetes__306">2 Kubernetes 安全模型</a></li>
<li>
<ul>
<li><a href="#21__Namespace_310">2.1 命名空间 Namespace</a></li>
<li><a href="#22_ServiceAccount_314">2.2 ServiceAccount</a></li>
<li><a href="#23_RBAC_318">2.3 RBAC</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#_Kubernetes__322">七、 Kubernetes 高可用方案</a></li>
<li>
<ul>
<li><a href="#1_Kubernetes__324">1 Kubernetes 高可用概述</a></li>
<li><a href="#2_Kubernetes__328">2 Kubernetes 高可用方案</a></li>
<li>
<ul>
<li><a href="#21__330">2.1 多个控制节点</a></li>
<li><a href="#22__etcd__334">2.2 基于 etcd 集群的高可用</a></li>
<li><a href="#23_IP_338">2.3 基于虚拟IP的高可用</a></li>
</ul> 
   </li>
<li><a href="#3_Kubernetes__342">3 Kubernetes 高可用工具</a></li>
<li>
<ul>
<li><a href="#31_kubeadm__344">3.1 kubeadm 集群安装工具</a></li>
<li><a href="#32_kubespray__348">3.2 kubespray 集群安装工具</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#_Kubernetes__353">八、 Kubernetes 故障排查</a></li>
<li>
<ul>
<li><a href="#1_Kubernetes__357">1 Kubernetes 故障排查概述</a></li>
<li><a href="#2_Kubernetes__361">2 Kubernetes 常见故障原因分析</a></li>
<li>
<ul>
<li><a href="#21__363">2.1 网络不通</a></li>
<li><a href="#22__394">2.2 节点异常</a></li>
<li><a href="#23_Pod__405">2.3 Pod 异常</a></li>
</ul> 
   </li>
<li><a href="#3_Kubernetes__416">3 Kubernetes 故障排查技巧</a></li>
</ul> 
 </li>
</ul> 
</div> 
<p></p> 
<h1>
<a id="Kubernetes__4"></a>一、Kubernetes 简介</h1> 
<h2>
<a id="1__Kubernetes_5"></a>1 什么是 Kubernetes</h2> 
<p>Kubernetes是由Google开源的容器编排系统，用于自动化部署、扩展和管理容器化应用程序的平台。Kubernetes充分利用了云计算和容器化技术，可以大幅简化应用程序的开发、部署和运行过程。</p> 
<h2>
<a id="2_Kubernetes__8"></a>2 Kubernetes 的优势</h2> 
<p>Kubernetes的优势主要包括以下几点：</p> 
<ol>
<li>
<strong>高可用性</strong>：Kubernetes可以在多个地理位置和云平台上运行，确保高可用性和业务连续性。</li>
<li>
<strong>易于扩展</strong>：Kubernetes通过添加/删除节点进行扩展，从而更好地满足业务需求，还可以自动进行负载和流量管理。</li>
<li>
<strong>便捷的部署管理</strong>：Kubernetes可以帮助用户轻松地创建和管理容器镜像、部署容器应用程序，并释放资源。</li>
<li>
<strong>自动化</strong>：因为 Kubernetes 是一个自动化的平台，它可以自动管理负载均衡、扩展、滚动更新、健康检查等任务，从而释放更多时间来关注核心业务。</li>
<li>
<strong>可扩展的生态系统</strong>：Kubernetes具有丰富的插件、应用程序、工具和社区支持，可以为用户提供更加丰富和可扩展的生态系统。</li>
</ol> 
<h2>
<a id="3_Kubernetes__16"></a>3 Kubernetes 的应用场景</h2> 
<p>Kubernetes主要适用于以下几个场景：</p> 
<ol>
<li>云原生应用程序：使用Kubernetes可以轻松地部署和管理云原生应用程序，提高开发效率和应用程序的可靠性。</li>
<li>DevOps：Kubernetes可以帮助开发团队更快更安全地将应用程序部署到生产环境。</li>
<li>分布式计算和分布式数据存储、处理：使用Kubernetes可以帮助用户轻松地搭建分布式计算和数据存储集群，从而提高大数据处理的效率。</li>
<li>容器构建和线上部署管理：通过Kubernetes可以方便地构建和管理容器镜像，并进行线上部署和管理。</li>
</ol> 
<h1>
<a id="Kubernetes__23"></a>二、Kubernetes 架构</h1> 
<h2>
<a id="1_Kubernetes__24"></a>1 Kubernetes 架构概述</h2> 
<p>Kubernetes是一个分布式系统，它的核心是将容器化的应用程序分配到一组机器上，并管理它们的生命周期，从而可以高效、稳定地运行应用程序。 Kubernetes的架构支持将一个容器化的应用程序部署在一个节点上，也支持它跨多个节点和多台机器部署。</p> 
<h2>
<a id="2_Kubernetes__27"></a>2 Kubernetes 架构组件介绍</h2> 
<h3>
<a id="21__28"></a>2.1 控制面板组件</h3> 
<p>控制面板组件是 Kubernetes 系统的核心，用于管理整个系统。其中包括kube-apiserver，etcd，kube-controller-manager和kube-scheduler等组件。这些组件都是通过API Server进行交互，从而处理集群中的工作。</p> 
<h3>
<a id="22_API_Server_31"></a>2.2 API Server</h3> 
<p>API Server是Kubernetes 提供的一种RESTful API，是Kubernetes系统的中心组件。它是 Kubernetes 控制面板的前端组件，用于处理集群中的所有请求并将请求转发给正确的组件，以便它们可以协同工作。</p> 
<h3>
<a id="23_etcd_34"></a>2.3 etcd</h3> 
<p>etcd是Kubernetes系统采用的数据存储系统，用于存储集群中的配置和状态信息等。etcd是一个高可用的分布式键值存储系统，可以确保在整个系统中保持一致的状态。</p> 
<h3>
<a id="24_kubelet_37"></a>2.4 kubelet</h3> 
<p>kubelet是每台机器上运行的代理程序，它的任务是对Pod进行创建、调度和维护。kubelet还负责与Control Plane交互，从而接收集群中的任务和工作。</p> 
<h3>
<a id="25_kubeproxy_40"></a>2.5 kube-proxy</h3> 
<p>kube-proxy是在每个节点上运行的网络代理程序，它负责为Pod对象提供服务发现和负载均衡功能。kube-proxy通过传递请求并根据规则将请求路由到正确的Pod，从而将请求从一个服务端口路由到相应的Pod。</p> 
<h3>
<a id="26_CNI__43"></a>2.6 CNI 插件</h3> 
<p>CNI（容器网络接口）插件是Kubernetes中用于管理容器网络的插件系统。CNI插件为Kubernetes提供支持，可以为Kubernetes管理的每个Pod对象分配IP地址和网络。CNI插件的使用使得Kubernetes的网络模型非常灵活。</p> 
<h3>
<a id="27__46"></a>2.7 容器运行时</h3> 
<p>容器运行时是Kubernetes中用于运行容器的组件，支持Docker，rkt等多种容器运行时。Kubernetes提供了一个容器运行时接口，从而可以很容易地切换到其他容器运行时。容器运行时支持管理容器的启动、停止、暂停等操作，实现了容器级别的资源管理和隔离。</p> 
<h1>
<a id="Kubernetes__50"></a>三、Kubernetes 应用管理</h1> 
<p>在 Kubernetes 中应用程序通过 Pod、Deployment、StatefulSet、DaemonSet 和 Job 等模型进行管理。本文将介绍这些模型的概念、使用方法以及注意事项，以帮助您更好地理解和使用 Kubernetes。</p> 
<h2>
<a id="1_Pod__54"></a>1 Pod 概述</h2> 
<h3>
<a id="11_Pod__56"></a>1.1 Pod 概念</h3> 
<p>Pod 是 Kubernetes 中最基本的调度单位，也是容器化的最小单位。它是由一个或多个紧密相连的容器组成的，这些容器共享同一个 IP 地址和网络命名空间，可以共享访问相同的存储卷和主机上的资源。Pod 是 Kubernetes 进行调度和管理的基本对象，一个 Pod 实例在一个节点上只会运行一次。</p> 
<h3>
<a id="12_Pod__60"></a>1.2 Pod 的生命周期</h3> 
<p>在 Kubernetes 中一个 Pod 实例的生命周期包括以下几个阶段：</p> 
<ol>
<li>创建阶段：Kubernetes API server 创建并初始化 Pod，根据 Pod 中的容器规范创建容器，并为 Pod 设置状态。</li>
<li>运行阶段：Pod 中的容器被初始化后，就开始运行了。在运行过程中，Kubernetes会对容器的运行状态进行监控，如容器是否运行正常，或者容器是否已经退出。</li>
<li>容器异常：如果 Pod 中的容器异常终止，Kubernetes 将根据定义的容器重启策略来决定是否重新启动容器，或者终止 Pod 实例。</li>
<li>删除阶段：当 Pod 不再需要时，可以通过 Kubernetes API 删除 Pod 实例。</li>
</ol> 
<h2>
<a id="2_Kubernetes__69"></a>2 Kubernetes 模型简介</h2> 
<p>Kubernetes 提供多种模型用于部署和管理应用程序，包括 Deployment、StatefulSet、DaemonSet 和 Job 等</p> 
<h3>
<a id="21_Deployment__73"></a>2.1 Deployment 模型</h3> 
<p>Deployment 是 Kubernetes 最常用的模型之一，用于部署和更新应用程序。Deployment 可以使用 ReplicaSet 和 Pod 来进行管理，实现应用程序的水平伸缩和升级。创建一个 Deployment，需要定义一个描述 Deployment 的 YAML 文件，下面是一个简单的 Nginx 部署示例：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3 </span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre> 
<p>该 YAML 文件定义了一个名为 nginx-deployment 的 Deployment 对象，该对象将使用 nginx:1.7.9 镜像来运行一个名为 nginx 的容器。该 Deployment 将会启动 3 个 Pod 进程，每个 Pod 进程都会包含一个 nginx 容器。</p> 
<h3>
<a id="22_StatefulSet__101"></a>2.2 StatefulSet 模型</h3> 
<p>StatefulSet 用于部署有状态应用程序它能够提供有序的 Pod 管理和服务发现，保证应用程序在多个 Pod 实例之间的稳定性。以下是一个 StatefulSet 的 YAML 文件示例：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>statefulset
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>app
  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>service
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>app
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>pod
        <span class="token key atrule">image</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>image
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8181</span>
</code></pre> 
<p>在上述 YAML 文件中定义了一个名为 my-statefulset 的 StatefulSet 对象，它使用 my-image 镜像来运行一个名为 my-pod 的容器。该 StatefulSet 对象将会启动 3 个 Pod 进程，并为每个 Pod 进程生成一个唯一的稳定标识符。</p> 
<h3>
<a id="23_DaemonSet__130"></a>2.3 DaemonSet 模型</h3> 
<p>DaemonSet 用于部署在集群中每个节点上运行的守护进程。DaemonSet 可以确保在每个节点上都有一个 Pod 实例，从而实现节点级别的服务发现和监控。以下是一个 DaemonSet 的 YAML 文件示例：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> fluentd
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> fluentd
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> fluentd
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> fluentd
        <span class="token key atrule">image</span><span class="token punctuation">:</span> fluentd<span class="token punctuation">:</span>v1.0.2
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">24224</span>
</code></pre> 
<p>在上述 YAML 文件中定义了一个名为 fluentd 的 DaemonSet 对象，它使用 fluentd:v1.0.2 镜像来运行一个名为 fluentd 的容器。每个节点上都会运行一个 Pod 进程，每个 Pod 进程都包含一个 fluentd 容器</p> 
<h3>
<a id="24_Job__157"></a>2.4 Job 模型</h3> 
<p>Job 用于周期性地执行批处理任务可以在 Kubernetes 中实现一次性任务和定时任务。以下是一个 Job 的 YAML 文件示例：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>job
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>job
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> OnFailure
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>job<span class="token punctuation">-</span>container
        <span class="token key atrule">image</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>image
        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"echo hello; sleep 30; echo world"</span><span class="token punctuation">]</span>
  <span class="token key atrule">backoffLimit</span><span class="token punctuation">:</span> <span class="token number">2</span>
</code></pre> 
<p>在上述 YAML 文件中定义了一个名为 my-job 的 Job 对象，它使用 my-image 镜像来运行一个名为 my-job-container 的容器。该容器将会执行命令 <code>echo hello; sleep 30; echo world</code></p> 
<h2>
<a id="3_Kubernetes__181"></a>3 Kubernetes 配置管理</h2> 
<p>Kubernetes 提供 ConfigMap 和 Secret 两种机制用于注入配置信息和敏感数据。在使用这些机制时可以将应用程序的配置和密钥集中存储在 Kubernetes 中，方便进行管理和更新</p> 
<h3>
<a id="31_ConfigMap_185"></a>3.1 ConfigMap</h3> 
<p>ConfigMap 可以用于以配置文件的形式将应用程序的相关配置信息注入到 Pod 中。 ConfigMap 配置信息可以被多个 Pod 共享，从而方便进行集中式配置管理和更新维护。</p> 
<p>以下是一个 ConfigMap 的 YAML 文件示例：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>config
<span class="token key atrule">data</span><span class="token punctuation">:</span>
  <span class="token key atrule">database.properties</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
    database.url=jdbc:mysql://127.0.0.1:3306/test
    database.username=test
    database.password=password</span>
  <span class="token key atrule">server.properties</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
    server.port=8080
    server.timeout=300</span>
</code></pre> 
<p>在上述 YAML 文件中定义了一个名为 my-config 的 ConfigMap 对象，并定义了一个 database.properties 文件和一个 server.properties 文件</p> 
<h3>
<a id="32_Secret_208"></a>3.2 Secret</h3> 
<p>Secret 可以用于将敏感信息以加密的形式注入到 Pod 中。Secret 与 ConfigMap 一样也可以实现多个 Pod 共享的配置信息的管理</p> 
<p>以下是一个 Secret 的 YAML 文件示例：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>secret
<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque
<span class="token key atrule">stringData</span><span class="token punctuation">:</span>
  <span class="token key atrule">username</span><span class="token punctuation">:</span> admin
  <span class="token key atrule">password</span><span class="token punctuation">:</span> myPassword
</code></pre> 
<p>在上述 YAML 文件中定义了一个名为 my-secret 的 Secret 对象，并定义了一个 username 和 password。在实际使用中，Secret 中的数据将会被加密并存储在 etcd 中，在初始化 Pod 时进行解密并注入到容器中。</p> 
<h1>
<a id="_Kubernetes__228"></a>四、 Kubernetes 网络模型</h1> 
<p>网络是 Kubernetes 中至关重要的一环它是 Kubernetes 能够实现跨多个节点的负载均衡和服务发现的基础。在 Kubernetes 中，主要有三种网络模型：单节点 Docker 桥接模式、CNI 模式和 Service 模式。</p> 
<h2>
<a id="1_Kubernetes__232"></a>1 Kubernetes 网络概述</h2> 
<p>Kubernetes 支持多种网络模型但它们都需要协同工作以确保网络可用性和性能。在 Kubernetes 中网络主要用于以下三个方面：</p> 
<ul>
<li>Pod 之间的网络通信</li>
<li>容器和宿主机之间的网络通信</li>
<li>外部访问 Kubernetes 集群提供的服务</li>
</ul> 
<p>为了实现这些网络功能 Kubernetes 需要在每个节点上配置一些网络组件和解决方案。</p> 
<h2>
<a id="2_Kubernetes__242"></a>2 Kubernetes 网络方案</h2> 
<p>Kubernetes 中有多种网络方案可以根据不同的需求选择不同的方案</p> 
<h3>
<a id="21__Docker__246"></a>2.1 单节点 Docker 桥接模式</h3> 
<p>单节点 Docker 桥接模式是 Kubernetes 中最简单和最常见的网络方案之一。在这种方案中每个 Docker 容器都有自己的 IP 地址，Kubernetes 使用一个名为 Docker0 的网桥将这些 IP 地址连接在一起，实现容器和宿主机之间的通信</p> 
<h3>
<a id="22_CNI__250"></a>2.2 CNI 模式</h3> 
<p>CNI 模式是 Kubernetes 中的一个更高级的网络方案，它使用一种名为 Container Network Interface（CNI）的标准接口来管理容器网络。CNI 可以在 Kubernetes 中启用多种网络插件，如 Flannel、Calico 和 Canal 等，以实现不同的网络功能</p> 
<h3>
<a id="23_Service__254"></a>2.3 Service 模式</h3> 
<p>Service 模式是 Kubernetes 中用于为容器提供负载均衡和服务发现的网络方案。在 Kubernetes 中，Service 是一组 Pod 的抽象，它们使用统一的 DNS 名称和虚拟 IP 地址，Kubernetes 通过 Service 实现了应用程序的服务发现和负载均衡</p> 
<h2>
<a id="3_Kubernetes__258"></a>3 Kubernetes 网络管理工具</h2> 
<p>在 Kubernetes 中网络管理是一个重要的任务，需要使用专门的工具来进行管理和维护</p> 
<h3>
<a id="31_kuberouter_262"></a>3.1 kube-router</h3> 
<p>kube-router 是 Kubernetes 中一个完整的网络解决方案，它提供了 Pod 网络、Service 网络和外部网络的解决方案。kube-router 还提供了完整的 IPv6 支持，可以为 Kubernetes 中的 IPv6 网络提供支持</p> 
<h3>
<a id="32_Cilium_266"></a>3.2 Cilium</h3> 
<p>Cilium 是一个用于 Kubernetes 中的网络和安全解决方案，它使用 Linux 内核技术提供了高性能的网络 I/O 服务。Cilium 还提供了完整的安全策略、安全插件和安全日志，可以增强 Kubernetes 网络的安全性和可靠性</p> 
<h1>
<a id="_Kubernetes__270"></a>五、 Kubernetes 存储管理</h1> 
<p>存储是 Kubernetes 中的另一个重要组成部分它可以提供可靠的持久化存储和数据管理。在 Kubernetes 中，主要有两种存储模型：Volume 和 PersistentVolume/Claim</p> 
<h2>
<a id="1_Kubernetes__274"></a>1 Kubernetes 存储概述</h2> 
<p>Kubernetes 的存储模型是为容器化应用程序设计的，它提供了多种可插拔的存储后端，如本地存储、NFS 存储和云存储等。Kubernetes 将存储资源抽象为 PersistentVolume（PV）和 PersistentVolumeClaim（PVC）。</p> 
<h2>
<a id="2_Kubernetes__278"></a>2 Kubernetes 存储模型</h2> 
<h3>
<a id="21_Volume_280"></a>2.1 Volume</h3> 
<p>Volume 是 Kubernetes 中用于为 Pod 提供持久化存储的基本组件，它可以将容器中的数据存储到 Pod 中。Kubernetes 中支持多种 Volume 类型，如 EmptyDir、HostPath、NFS 和 GlusterFS 等，可以根据不同的需求选择不同的 Volume 类型</p> 
<h3>
<a id="22_PersistentVolumeClaim_284"></a>2.2 PersistentVolume/Claim</h3> 
<p>PersistentVolume（PV）是 Kubernetes 中用于描述物理存储资源的组件，它提供了抽象层，将存储资源与应用程序分离开来。PersistentVolumeClaim（PVC）是用于向 Kubernetes 请求存储资源的组件，它可以将 Pod 和 PersistentVolume 进行绑定，从而为容器提供持久化存储</p> 
<h2>
<a id="53_Kubernetes__288"></a>53 Kubernetes 存储管理工具</h2> 
<p>在 Kubernetes 中存储管理是一项关键任务，需要使用专门的工具进行管理和维护</p> 
<h3>
<a id="31_Ceph_292"></a>3.1 Ceph</h3> 
<p>Ceph 是一个开源的分布式存储系统它提供了高可用性和高可扩展性的存储服务。在 Kubernetes 中，可以将 Ceph 集群与 Kubernetes 集成，从而为容器提供可靠的存储解决方案</p> 
<h3>
<a id="32_GlusterFS_296"></a>3.2 GlusterFS</h3> 
<p>GlusterFS 是一个开源的分布式文件系统，它可以将多台服务器上的存储设备汇聚成一个大型存储池，以提供高可用性和高可扩展性的存储服务。在 Kubernetes 中，可以将 GlusterFS 集群与 Kubernetes 集成，从而为容器提供可靠的存储解决方案</p> 
<h1>
<a id="_Kubernetes__300"></a>六、 Kubernetes 安全策略</h1> 
<h2>
<a id="1_Kubernetes__302"></a>1 Kubernetes 安全概述</h2> 
<p>在 Kubernetes 中应用程序和数据的安全是至关重要的。Kubernetes 提供了多种安全机制和工具，以帮助实现应用程序和数据的保护和隔离。Kubernetes 安全主要包括身份认证、授权、准入控制、网络安全和机密管理等方面。</p> 
<h2>
<a id="2_Kubernetes__306"></a>2 Kubernetes 安全模型</h2> 
<p>Kubernetes 中的安全模型涵盖了多个方面，包括命名空间、ServiceAccount 和 RBAC 等</p> 
<h3>
<a id="21__Namespace_310"></a>2.1 命名空间 Namespace</h3> 
<p>命名空间是 Kubernetes 中的一种资源分类机制，它将一组资源隔离开来，以实现资源管理和权限控制。每个命名空间都拥有自己的资源列表，而且命名空间之间的资源是相互隔离的。Kubernetes 中预定义了一些命名空间，如 default、kube-system 等，用户也可以自定义命名空间</p> 
<h3>
<a id="22_ServiceAccount_314"></a>2.2 ServiceAccount</h3> 
<p>ServiceAccount 是 Kubernetes 中用于身份验证和授权的一种机制，它为 Pod 提供了默认的身份认证信息。在 Kubernetes 中，每个 Pod 都有自己的 ServiceAccount，通过 ServiceAccount 可以为 Pod 提供不同的身份认证和授权策略。Kubernetes 还提供了多种身份验证和授权机制，如 OAuth、Webhook 等。</p> 
<h3>
<a id="23_RBAC_318"></a>2.3 RBAC</h3> 
<p>RBAC 是 Kubernetes 中用于授权的一种机制，它可以将权限分配给特定的用户或用户组，并在整个 Kubernetes 群集中实施授权策略。RBAC 可以定义角色（Role）和角色绑定（RoleBinding），以将权限授予特定的用户或用户组，并限制其访问群集中的特定资源。</p> 
<h1>
<a id="_Kubernetes__322"></a>七、 Kubernetes 高可用方案</h1> 
<h2>
<a id="1_Kubernetes__324"></a>1 Kubernetes 高可用概述</h2> 
<p>在 Kubernetes 中，高可用是实现应用程序可靠部署和管理的重要前提条件。通过部署高可用 Kubernetes 集群，可以实现容错性、负载均衡和自动故障切换等功能</p> 
<h2>
<a id="2_Kubernetes__328"></a>2 Kubernetes 高可用方案</h2> 
<h3>
<a id="21__330"></a>2.1 多个控制节点</h3> 
<p>Kubernetes 中的控制节点（Control Plane）是用于管理整个 Kubernetes 群集的关键组件之一，包括 kube-apiserver、kube-controller-manager 和 kube-scheduler 等。为了实现高可用，可以在 Kubernetes 群集中部署多个控制节点，以实现容错和负载均衡</p> 
<h3>
<a id="22__etcd__334"></a>2.2 基于 etcd 集群的高可用</h3> 
<p>etcd 是 Kubernetes 中用于存储群集状态的关键组件，它为整个 Kubernetes 群集提供了数据存储和共享功能。为了实现高可用，可以通过部署 etcd 集群来实现数据的冗余和自动故障切换。</p> 
<h3>
<a id="23_IP_338"></a>2.3 基于虚拟IP的高可用</h3> 
<p>在 Kubernetes 中可以使用虚拟IP（VIP）来实现高可用。通过使用 VIP，可以将多个 Kubernetes 节点组成一个冗余集群，以实现容错和自动故障切换等功能。</p> 
<h2>
<a id="3_Kubernetes__342"></a>3 Kubernetes 高可用工具</h2> 
<h3>
<a id="31_kubeadm__344"></a>3.1 kubeadm 集群安装工具</h3> 
<p>kubeadm 是 Kubernetes 官方提供的集群安装工具，它可以快速部署高可用 Kubernetes 集群，并提供了多种可插拔的组件和插件，以扩展和定制 Kubernetes 群集</p> 
<h3>
<a id="32_kubespray__348"></a>3.2 kubespray 集群安装工具</h3> 
<p>kubespray 是一个开源的 Kubernetes 集群安装工具，它基于 Ansible 自动化工具和 Kubernetes 官方指南进行开发。kubespray 可以快速部署高可用 Kubernetes 集群，并提供了多种可插拔的组件和插件，以扩展和定制 Kubernetes 群集。</p> 
<h1>
<a id="_Kubernetes__353"></a>八、 Kubernetes 故障排查</h1> 
<p>在 Kubernetes 中故障排查是系统维护和调试的重要一环。本文将从三个方面介绍 Kubernetes 故障排查：概述、常见故障原因分析和排查技巧。</p> 
<h2>
<a id="1_Kubernetes__357"></a>1 Kubernetes 故障排查概述</h2> 
<p>Kubernetes 故障排查通常涉及到多种组件和技术，包括网络、节点和 Pod 等。在排查问题时，需要先定位故障的范围和具体原因，然后采取相应的措施进行排除。针对不同类型的故障，通常需要采用不同的排查技巧和工具</p> 
<h2>
<a id="2_Kubernetes__361"></a>2 Kubernetes 常见故障原因分析</h2> 
<h3>
<a id="21__363"></a>2.1 网络不通</h3> 
<p>网络问题是 Kubernetes 中常见的故障原因之一。当集群中的容器无法与其他容器或外部网络通信时，可能是由于网络配置问题、网络故障或跨主机通信错误等引起的。解决网络故障的方法包括检查网络拓扑、配置和路由，以及检查 Kubernetes 中的网络策略和安全组等。</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 示例：检查 Pod IP 和服务 IP 是否冲突</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
<span class="token punctuation">---</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>service
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> test
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP
</code></pre> 
<h3>
<a id="22__394"></a>2.2 节点异常</h3> 
<p>Kubernetes 节点异常是另一个常见的故障原因。当节点无法正常运行或访问时，可能会导致 Pod 启动失败、容器无法运行或数据丢失等问题。解决节点异常的方法包括检查节点状态、硬件故障、资源利用率和容器日志等</p> 
<pre><code class="prism language-shell"><span class="token comment"># 示例：查看节点状态和资源利用率</span>
$ kubectl get nodes
$ kubectl describe node <span class="token operator">&lt;</span>nodename<span class="token operator">&gt;</span>
$ kubectl <span class="token function">top</span> node
</code></pre> 
<h3>
<a id="23_Pod__405"></a>2.3 Pod 异常</h3> 
<p>在 Kubernetes 中Pod 异常通常包括容器崩溃、镜像拉取失败、容器资源不足等问题。当 Pod 无法正常启动或执行命令时，可能会导致服务不可用、数据损失或负载过重等问题。解决 Pod 异常的方法包括检查容器状态、Pod 生命周期、容器资源配额和日志等。</p> 
<pre><code class="prism language-shell"><span class="token comment"># 示例：查看 Pod 状态和容器日志</span>
$ kubectl get pods
$ kubectl describe pod <span class="token operator">&lt;</span>podname<span class="token operator">&gt;</span>
$ kubectl logs <span class="token operator">&lt;</span>podname<span class="token operator">&gt;</span> -c <span class="token operator">&lt;</span>containername<span class="token operator">&gt;</span>
</code></pre> 
<h2>
<a id="3_Kubernetes__416"></a>3 Kubernetes 故障排查技巧</h2> 
<p>在排查 Kubernetes 故障时，需要掌握一些技巧和工具，以提高排查效率。其中包括：</p> 
<ul>
<li>使用 kubectl 命令查询资源状态、获取日志和执行故障排查命令。</li>
<li>在节点和容器中安装监控和诊断工具，如 Prometheus、Grafana 和 sysdig 等。</li>
<li>使用 Kubernetes Dashboard 或其他资源管理工具来查看和管理集群资源。</li>
<li>记录故障排查过程和结果，并及时更新相关文档和资料。</li>
</ul>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>