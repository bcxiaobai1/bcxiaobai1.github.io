<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>人工智能最新研究发展方向——OCR文字识别简述 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">人工智能最新研究发展方向——OCR文字识别简述</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="1__0"></a>1 研究背景</h1> 
<p>人工智能是研究开发能够模拟、延伸和扩展人类智能的理论、方法、技术及应用系统的一门新的技术科学，研究目的是促使智能机器会听（语音识别、机器翻译等）、会看（图像识别、文字识别等）、会说（语音合成、人机对话等）、会思考（人机对弈、定理证明等）、会学习（机器学习、知识表示等）、会行动（机器人、自动驾驶汽车等）。<br> 人工智能充满未知的探索道路曲折起伏。如何描述人工智能自1956年以来60余年的发展历程，学术界可谓仁者见仁、智者见智。通过查阅资料将人工智能的发展历程划分为以下6个阶段：<br> 一是起步发展期：1956年—20世纪60年代初。人工智能概念提出后，相继取得了一批令人瞩目的研究成果，如机器定理证明、跳棋程序等，掀起人工智能发展的第一个高潮。<br> 二是反思发展期：20世纪60年代—70年代初。人工智能发展初期的突破性进展大大提升了人们对人工智能的期望，人们开始尝试更具挑战性的任务，并提出了一些不切实际的研发目标。然而，接二连三的失败和预期目标的落空（例如，无法用机器证明两个连续函数之和还是连续函数、机器翻译闹出笑话等），使人工智能的发展走入低谷。<br> 三是应用发展期：20世纪70年代初—80年代中。20世纪70年代出现的专家系统模拟人类专家的知识和经验解决特定领域的问题，实现了人工智能从理论研究走向实际应用、从一般推理策略探讨转向运用专门知识的重大突破。专家系统在医疗、化学、地质等领域取得成功，推动人工智能走入应用发展的新高潮。<br> 四是低迷发展期：20世纪80年代中—90年代中。随着人工智能的应用规模不断扩大，专家系统存在的应用领域狭窄、缺乏常识性知识、知识获取困难、推理方法单一、缺乏分布式功能、难以与现有数据库兼容等问题逐渐暴露出来。<br> 五是稳步发展期：20世纪90年代中—2010年。由于网络技术特别是互联网技术的发展，加速了人工智能的创新研究，促使人工智能技术进一步走向实用化。1997年国际商业机器公司（简称IBM）深蓝超级计算机战胜了国际象棋世界冠军卡斯帕罗夫，2008年IBM提出“智慧地球”的概念。以上都是这一时期的标志性事件。<br> 六是蓬勃发展期：2011年至今。随着大数据、云计算、互联网、物联网等信息技术的发展，泛在感知数据和图形处理器等计算平台推动以深度神经网络为代表的人工智能技术飞速发展，大幅跨越了科学与应用之间的“技术鸿沟”，诸如图像分类、语音识别、知识问答、人机对弈、无人驾驶等人工智能技术实现了从“不能用、不好用”到“可以用”的技术突破，迎来爆发式增长的新高潮。</p> 
<h1>
<a id="2_OCR_9"></a>2 OCR文字识别</h1> 
<h2>
<a id="21OCR_10"></a>2.1什么是OCR？</h2> 
<p><img src="https://images2.imgbox.com/7b/54/pEJwIMHl_o.png" alt="在这里插入图片描述"><br> 图 自然场景OCR文字识别<br> OCR英文全称是Optical Character Recognition，中文叫做光学字符识别。它是利用光学技术和计算机技术把印在或写在纸上的文字读取出来，并转换成一种计算机能够接受、人又可以理解的格式。文字识别是计算机视觉研究领域的分支之一，而且这个课题已经是比较成熟了，并且在商业中已经有很多落地项目了。比如汉王OCR，百度OCR，阿里OCR等等，很多企业都有能力都是拿OCR技术开始挣钱了。其实我们自己也能感受到，OCR技术确实也在改变着我们的生活：比如一个手机APP就能帮忙扫描名片、身份证，并识别出里面的信息；汽车进入停车场、收费站都不需要人工登记了，都是用车牌识别技术；我们看书时看到不懂的题，拿个手机一扫，APP就能在网上帮你找到这题的答案。太多太多的应用了，OCR的应用在当今时代确实是百花齐放。</p> 
<h2>
<a id="22_OCR_15"></a>2.2 OCR的分类</h2> 
<p>如果要给OCR进行分类分为两类：手写体识别和印刷体识别。<br> 这两个可以认为是OCR领域两个大主题了，当然印刷体识别较手写体识别要简单得多，也能从直观上理解，印刷体大多都是规则的字体，因为这些字体都是计算机自己生成再通过打印技术印刷到纸上。在印刷体的识别上有其独特的干扰：在印刷过程中字体很可能变得断裂或者墨水粘连，使得OCR识别异常困难。当然这些都可以通过一些图像处理的技术帮他尽可能的还原，进而提高识别率。总的来说，单纯的印刷体识别在业界已经能做到很不错了，但说100%识别是肯定不可能的，但是说识别得不错那是没毛病。<br> <img src="https://images2.imgbox.com/bf/46/QsDazoao_o.png" alt="在这里插入图片描述"></p> 
<p>图 手写字体展示<br> 印刷体已经识别得不错了，那么手写体呢？手写体识别一直是OCR界一直想攻克的难关，但是时至今天，感觉这个难关还没攻破，还有很多学者和公司在研究。为什么手写体识别的难度在于因为人类手写的字往往带有个人特色，每个人写字的风格基本不一样，印刷体一般都比较规则，字体都基本就那几十种，机器学习这几十种字体并不是一件难事，但是手写体，每个人都有一种字体的话，那机器该学习大量字体，这就是难度所在。</p> 
<h2>
<a id="23_OCR_22"></a>2.3 OCR流程</h2> 
<p>假如输入系统的图像是一页文本，那么识别时的第一件事情是判断页面上的文本朝向，因为得到的这页文档往往都不是很完美的，很可能带有倾斜或者污渍，那么要做的第一件事就是进行图像预处理，做角度矫正和去噪。然后要对文档版面进行分析，进每一行进行行分割，把每一行的文字切割下来，最后再对每一行文本进行列分割，切割出每个字符，将该字符送入训练好的OCR识别模型进行字符识别，得到结果。但是模型识别结果往往是不太准确的，需要对其进行识别结果的矫正和优化，比如可以设计一个语法检测器，去检测字符的组合逻辑是否合理。比如，考虑单词Because，设计的识别模型把它识别为8ecause，那么就可以用语法检测器去纠正这种拼写错误，并用B代替8并完成识别矫正。这样子，整个OCR流程就走完了。从大的模块总结而言，一套OCR流程可以分为：<br> <img src="https://images2.imgbox.com/7b/7a/duh0RPlM_o.png" alt="在这里插入图片描述"></p> 
<p>从上面的流程图可以看出，要做字符识别并不是单纯一个OCR模块就能实现的（如果单纯的OCR模块，识别率相当低），都要各个模块的组合来保证较高的识别率。上面的流程分的比较粗，每个模块下还是有很多更细节的操作，每个操作都关系着最终识别结果的准确性。做过OCR的童鞋都知道，送入OCR模块的图像越清晰（即预处理做的越好），识别效果往往就越好。那现在对这流程中最为重要的字符识别技术做一个总结。</p> 
<h2>
<a id="24_OCR_27"></a>2.4 OCR的简单应用</h2> 
<p><img src="https://images2.imgbox.com/e6/16/9KNLVpwD_o.png" alt="在这里插入图片描述"><br> 图 瓶盖的生产日期识别<br> 在一些简单环境下OCR的准确度已经比较高了（比如电子文档），但是在一些复杂环境下的字符识别，在当今还没有人敢说自己能做的很好。现在大家都很少会把目光还放在如何对电子文档的文字识别该怎么进一步提高准确率了，因为他们把目光放在更有挑战性的领域。OCR传统方法在应对复杂图文场景的文字识别显得力不从心，越来越多人把精力都放在研究如何把文字在复杂场景读出来，并且读得准确作为研究课题，用学界术语来说，就是场景文本识别（文字检测+文字识别）。<br> <img src="https://images2.imgbox.com/53/8b/JzYNW7Fw_o.png" alt="在这里插入图片描述"></p> 
<p>图 人工智能课本识别图</p> 
<h2>
<a id="3CTPN_34"></a>3文本检测CTPN</h2> 
<p>2016年出了一篇很有名的文本检测的论文：《Detecting Text in Natural Image withConnectionist Text Proposal Network》，这个深度神经网络叫做CTPN，直到今天这个网络框架一直是OCR系统中做文本检测的一个常用网络，极大地影响了后面文本检测算法的方向。<br> 回顾一下Faster RCNN做目标检测的一个缺点就是，没有考虑带文本自身的特点。文本行一般以水平长矩形的形式存在，而且文本行中每个字都有间隔。针对这个特点，CTPN剔除一个新奇的想法，把文本检测的任务拆分，第一步检测文本框中的一部分，判断它是不是一个文本的一部分，当对一幅图里所有小文本框都检测之后，将属于同一个文本框的小文本框合并，合并之后得到一个完整的、大的文本框了，也就完成了文本的检测任务。这个想法很有创造性，有点像“分治法”，先检测大物体的一小部分，等所有小部分都检测出来，大物体也就可以检测出来了。<br> <img src="https://images2.imgbox.com/bf/fd/ZTtk7MVt_o.png" alt="在这里插入图片描述"><br> 图 RPN和CTPN对比<br> 如图所示，左边的图是直接使用Faster RCNN中的RPN来进行候选框提取，可以看出，这种候选框太粗糙了，效果并不好。而右图是利用许多小候选框来合并成一个大文本预测框，可以看出这个算法的效果非常不错，需要说明的是，红色框表示这个小候选框的置信度比较高，而其他颜色的候选框的置信度比较低，可以看到，一个大文本的边界都是比较难预测的，那怎么解决这个边界预测不准的问题呢？后面会提到。<br> 刚提到CTPN的其中一个闪光点，即检测小框代替直接检测大文本框。除了这个新意，CTPN还提出了在文本检测中应加入RNN来进一步提升效果。为什么要用RNN来提升检测效果？文本具有很强的连续字符，其中连续的上下文信息对于做出可靠决策来说很重要。RNN常用于序列模型，比如事件序列，语言序列等等，那CTPN算法中，把一个完整的文本框拆分成多个小文本框集合，其实这也是一个序列模型，可以利用过去或未来的信息来学习和预测，所以同样可以使用RNN模型。而且，在CTPN中，用的还是BiLSTM（双向LSTM），因为一个小文本框，对于它的预测，不仅与其左边的小文本框有关系，而且还与其右边的小文本框有关系！这个解释就很有说服力了，如果仅仅根据一个文本框的信息区预测该框内含不含有文字其实是很草率的，应该多参考这个框的左边和右边的小框的信息后（尤其是与其紧挨着的框）再做预测准确率会大大提升。<br> <img src="https://images2.imgbox.com/8f/64/B6T0Myhb_o.png" alt="在这里插入图片描述"></p> 
<p>图 CTPN候选框<br> 如上图所示，如果单纯依靠1号框内的信息来直接预测1号框中否存在文字（或者说是不是文本的一部分），其实难度相当大，因为1号框只包含文字的很小一部分。但是如果把2号框和3号框的信息都用上，来预测1号框是否存在文字，那么就会有比较大的把握来预测1号框确实有文字。还可以看看为什么边缘的文本框的置信度会较中间的低呢？个人认为很大一部分原因就在于因为这些框都位于总文本的边缘，没有办法充分利用左右相邻序列的信息做预测（比如位于最左的文本框丢失了其右边的信息）。这就是双向LSTM的作用，把左右两个方向的序列信息都加入到学习的过程中去。<br> CTPN借助了Faster RCNN中anchor回归机制，使得RPN能有效地用单一尺寸的滑动窗口来检测多尺寸的物体。当然CTPN根据文本检测的特点做了比较多的创新。比如RPN中anchor机制是直接回归预测物体的四个参数（x,y,w,h），但是CTPN采取之回归两个参数(y,h)，即anchor的纵向偏移以及该anchor的文本框的高度，因为每个候选框的宽度w已经规定为16个像素，不需要再学习，而x坐标直接使用anchor的x坐标，也不用学习，所以CTPN的思路就是只学习y和h这两个参数来完成小候选框的检测！跟RPN相类似，CTPN中对于每个候选框都使用了K个不同的anchors（k在这里默认是10），但是与RPN不同的是，这里的anchors的width是固定的16个像素，而height的高度范围为11~273（每次对输入图像的height除以0.7，一共K个高度）。当然CTPN中还是保留了RPN大多数的思路，比如还是需要预测候选框的分数score（该候选框有文本和无文本的得分）。<br> 文本行构建很简单，通过将那些text/no-text score &gt; 0.7的连续的text proposals相连接即可。文本行的构建如下。首先，为一个proposal Bi定义一个邻居（Bj）：Bj−&gt;Bi，其中，Bj在水平距离上离Bi最近，该距离小于50 pixels它们的垂直重叠(vertical overlap) &gt; 0.7，另外，如果同时满足Bj−&gt;Bi和Bi−&gt;Bj，会将两个proposals被聚集成一个pair。接着，一个文本行会通过连续将具有相同proposal的pairs来进行连接来构建。<br> <img src="https://images2.imgbox.com/92/ad/gvqP6O2F_o.png" alt="在这里插入图片描述"></p> 
<p>图 CTPN网络架构<br> 首先CTPN的基础网络使用了VGG16用于特征提取，在VGG的最后一个卷积层CONV5，CTPN用了3×3的卷积核来对该feature map做卷积，这个CVON5 特征图的尺寸由输入图像来决定，而卷积时的步长却限定为16，感受野被固定为228个像素。卷积后的特征将送入BLSTM继续学习，最后接上一层全连接层FC输出要预测的参数：2K个纵向坐标y，2k个分数，k个x的水平偏移量。看到这里大家可能有个疑问，这个x的偏移到底是什么，为什么需要回归这个参数？如果需要X的参数，为什么不在候选框参数回归时直接预测成（x,y,h）三个参数呢，而要多此一举把该参数单独预测，这个X的作用作者提到这也是他们论文的一大亮点，称之为Side-refinement，可以理解为文本框边缘优化。回顾一下上面提到的一个问题，文本框检测中边缘部分的预测并不准确。那么改咋办，CTPN就是用这个X的偏移量来精修边缘问题。这个X是指文本框在水平方向的左边界和右边界，通过回归这个左边界和右边界参数进而可以使得对文本框的检测更为精准。在这里想举个例子说明一下回归这个x参数的重要性。<br> 通过观察下图，第一幅图张看到有很多小候选框，位于左边的候选框我标记为1、2、3、4号框,1号框和2号框为蓝色，表明得分不高就不把这两个框合并到大文本框内，对于3号框和4号框那就比较尴尬了，如果取3号框作为文本框的边缘框，那么显然左边边缘留白太多，精准度不够，但如果去掉3号框而使用4号框作为左边缘框，则有些字体区域没有检测出来，同样检测精度不足。这种情况其实非常容易出现，所以CTPN采取了Side-refinement 思路进一步优化边缘位置的预测即引入回归X参数，X参数直接标定了完整文本框的左右边界，做到精确的边界预测。第二幅图中的红色框就是经过Side-refinement后的检测结果，可以看出检测准确率有了很大的提升。 side-refinement确实可以进一步提升位置准确率，在SWT的Multi-Lingual datasets上产生2%的效果提升。<br> <img src="https://images2.imgbox.com/54/37/08quxvWk_o.png" alt="在这里插入图片描述"><br> 再看多几幅图，体验一下Side-refinement后的效果。<br> <img src="https://images2.imgbox.com/38/ba/sKBstd40_o.png" alt="在这里插入图片描述"></p> 
<p>最后总结一下CTPN这个流行的文本检测框架的三个闪光点：</p> 
<ul>
<li>将文本检测任务转化为一连串小尺度文本框的检测；</li>
<li>引入RNN提升文本检测效果；</li>
<li>Side-refinement（边界优化）提升文本框边界预测精准度。</li>
</ul> 
<p>当然，CTPN也有一个很明显的缺点：对于非水平的文本的检测效果并不好。CTPN论文中给出的文本检测效果图都是文本位于水平方向的，显然CTPN并没有针对多方向的文本检测有深入的探讨。</p> 
<h2>
<a id="4_62"></a>4总结</h2> 
<p>通过查阅相关资料学习什么是OCR并且查阅了如何实现OCR文字识别中的文字检测，并且通过理论实现流程并且用代码对CPTN文字检测进行复现。通过对文字数据预处理并且进行文字字符分割，看似简单，做起来其实很难做得很好，我们也对此查阅了很多论文，发现其实很多论文也谈到了，汉字确实很那做到一个高正确率的分割，直至现在还没有一统江湖的解决方案。汉字切割的失败，就会直接导致了后面OCR识别的失败，这也是当前很多一些很厉害的OCR公司都没法把汉字做到100%识别的一个原因。所以这个问题就必须得到很好的解决。最后我们解决汉字切割的较好方法是，在OCR识别中再把它修正。并且通过文字分割后对数据进行数据增强生成了大量数据防止模型的过拟合。并且通过学习CPTN论文，学习到了思路上的创新，在检测水平上的文字置信度很高，但是也有一些弊端对于非水平的文本检测效果并不好。</p> 
<h2>
<a id="5_64"></a>5引用文献</h2> 
<p>[1] Detecting Text in Natural Image with Connectionist Text Proposal Network.作者: Zhi Tian; Weilin Huang; Tong He; Pan He; Yu Qiao 0001<br> [2]基于深度学习的汉字识别方法研究[D].任凤丽.东华大学. 2021<br> [3]基于深度学习的光学字符识别技术研究[D].冯亚南.南京邮电大学 2020<br> [4]基于卷积神经网络的手写数字识别研究与设计[D].刘辰雨.成都理工大学2018<br> [5]基于CRNN的中文手写识别方法研究[J]. 石鑫,董宝良,王俊丰.信息技术. 2019(11)</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>