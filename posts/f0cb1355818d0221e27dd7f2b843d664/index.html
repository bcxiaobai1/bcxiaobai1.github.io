<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C&#43;&#43;从零实现神经网络 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;从零实现神经网络</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <h2>一、Net类的设计与神经网络初始化</h2> 
<p>既然是要用C++来实现，那么我们自然而然的想到设计一个神经网络类来表示神经网络，这里我称之为Net类。由于这个类名太过普遍，很有可能跟其他人写的程序冲突，所以我的所有程序都包含在namespace liu中，由此不难想到我姓刘。在之前的博客反向传播算法资源整理中，我列举了几个比较不错的资源。对于理论不熟悉而且学习精神的同学可以出门左转去看看这篇文章的资源。这里假设读者对于神经网络的基本理论有一定的了解。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/28/7d/ByCQBCFW_o.gif"></p> 
<p>神经网络的要素</p> 
<p>在真正开始coding之前还是有必要交代一下神经网络基础，其实也就是设计类和写程序的思路。简而言之，神经网络的包含几大要素：</p> 
<ul>
<li> <p>神经元节点</p> </li>
<li> <p>层（layer）</p> </li>
<li> <p>权值（weights）</p> </li>
<li> <p>偏置项（bias）</p> </li>
</ul>
<p>神经网络的两大计算过程分别是前向传播和反向传播过程。每层的前向传播分别包含加权求和（卷积？）的线性运算和激活函数的非线性运算。反向传播主要是用BP算法更新权值。虽然里面还有很多细节，但是对于作为第一章节来说，以上内容足够了。</p> 
<h3>Net类的设计</h3> 
<p><strong>Net类——基于Mat</strong></p> 
<p>神经网络中的计算几乎都可以用矩阵计算的形式表示，这也是我用OpenCV的Mat类的原因之一，它提供了非常完善的、充分优化过的各种矩阵运算方法；另一个原因是我最熟悉的库就是OpenCV......有很多比较好的库和框架在实现神经网络的时候会用很多类来表示不同的部分。比如Blob类表示数据，Layer类表示各种层，Optimizer类来表示各种优化算法。但是这里没那么复杂，主要还是能力有限，只用一个Net类表示神经网络。还是直接让程序说话，Net类包含在Net.h中，大致如下。</p> 
<pre>
</pre> 
<p>#ifndef NET_H  <br> #define NET_H  <br> #endif // NET_H  <br> #pragma once  <br> #include &lt;iostream&gt;  <br> #include&lt;opencv2\core\core.hpp&gt;  <br> #include&lt;opencv2\highgui\highgui.hpp&gt;  <br> //#include&lt;iomanip&gt;  <br> #include"Function.h"  <br> namespace liu  <br> {  <br>     class Net  <br>     {  <br>     public:  <br>         std::vector&lt;int&gt; layer_neuron_num;  <br>         std::vector&lt;cv::Mat&gt; layer;  <br>         std::vector&lt;cv::Mat&gt; weights;  <br>         std::vector&lt;cv::Mat&gt; bias;  <br>     public:  <br>         Net() {};  <br>         ~Net() {};  <br>         //Initialize net:genetate weights matrices、layer matrices and bias matrices  <br>         // bias default all zero  <br>         void initNet(std::vector&lt;int&gt; layer_neuron_num_);  <br>         //Initialise the weights matrices.  <br>         void initWeights(int type = 0, double a = 0., double b = 0.1);  <br>         //Initialise the bias matrices.  <br>         void initBias(cv::Scalar&amp; bias);  <br>         //Forward  <br>         void forward();  <br>         //Forward  <br>         void backward();  <br>     protected:  <br>         //initialise the weight matrix.if type =0,Gaussian.else uniform.  <br>         void initWeight(cv::Mat &amp;dst, int type, double a, double b);  <br>         //Activation function  <br>         cv::Mat activationFunction(cv::Mat &amp;x, std::string func_type);  <br>         //Compute delta error  <br>         void deltaError();  <br>         //Update weights  <br>         void updateWeights();  <br>     };  <br> }  </p> 
<p><strong>说明：</strong>以上不是Net类的完整形态，只是对应于本文内容的一个简化版，简化之后看起来会更加清晰明了。</p> 
<h3>成员变量与成员函数</h3> 
<p>现在Net类只有四个成员变量，分别是：</p> 
<ul>
<li> <p>每一层神经元数目（layer__neuron__num）</p> </li>
<li> <p>层（layer）</p> </li>
<li> <p>权值矩阵（weights）</p> </li>
<li> <p>偏置项（bias）</p> </li>
</ul>
<p>权值用矩阵表示就不用说了，需要说明的是，为了计算方便，这里每一层和偏置项也用Mat表示，每一层和偏置都用一个单列矩阵来表示。Net类的成员函数除了默认的构造函数和析构函数，还有：</p> 
<ul>
<li> <p>initNet()：用来初始化神经网络</p> </li>
<li> <p>initWeights()：初始化权值矩阵，调用initWeight()函数</p> </li>
<li> <p>initBias()：初始化偏置项</p> </li>
<li> <p>forward()：执行前向运算，包括线性运算和非线性激活，同时计算误差</p> </li>
<li> <p>backward()：执行反向传播，调用updateWeights()函数更新权值。</p> </li>
</ul>
<p>这些函数已经是神经网络程序核心中的核心。剩下的内容就是慢慢实现了，实现的时候需要什么添加什么，逢山开路，遇河架桥。</p> 
<h3>神经网络初始化</h3> 
<p><strong>initNet()函数</strong></p> 
<p>先说一下initNet()函数，这个函数只接受一个参数——每一层神经元数目，然后借此初始化神经网络。这里所谓初始化神经网络的含义是：生成每一层的矩阵、每一个权值矩阵和每一个偏置矩阵。听起来很简单，其实也很简单。</p> 
<p>实现代码在Net.cpp中。</p> 
<p>这里生成各种矩阵没啥难点，唯一需要留心的是权值矩阵的行数和列数的确定。值得一提的是这里把权值默认全设为0。</p> 
<pre>
</pre> 
<p>    //Initialize net<br>     void Net::initNet(std::vector&lt;int&gt; layer_neuron_num_)<br>     {<!-- --><br>         layer_neuron_num = layer_neuron_num_;<br>         //Generate every layer.<br>         layer.resize(layer_neuron_num.size());<br>         for (int i = 0; i &lt; layer.size(); i++)<br>         {<!-- --><br>             layer[i].create(layer_neuron_num[i], 1, CV_32FC1);<br>         }<br>         std::cout &lt;&lt; "Generate layers, successfully!" &lt;&lt; std::endl;<br>         //Generate every weights matrix and bias<br>         weights.resize(layer.size() - 1);<br>         bias.resize(layer.size() - 1);<br>         for (int i = 0; i &lt; (layer.size() - 1); ++i)<br>         {<!-- --><br>             weights[i].create(layer[i + 1].rows, layer[i].rows, CV_32FC1);<br>             //bias[i].create(layer[i + 1].rows, 1, CV_32FC1);<br>             bias[i] = cv::Mat::zeros(layer[i + 1].rows, 1, CV_32FC1);<br>         }<br>         std::cout &lt;&lt; "Generate weights matrices and bias, successfully!" &lt;&lt; std::endl;<br>         std::cout &lt;&lt; "Initialise Net, done!" &lt;&lt; std::endl;<br>     }</p> 
<h3>权值初始化</h3> 
<p><strong>initWeight()函数</strong></p> 
<p>权值初始化函数initWeights()调用initWeight()函数，其实就是初始化一个和多个的区别。偏置初始化是给所有的偏置赋相同的值。这里用Scalar对象来给矩阵赋值。</p> 
<pre>
</pre> 
<p>    //initialise the weights matrix.if type =0,Gaussian.else uniform.<br>     void Net::initWeight(cv::Mat &amp;dst, int type, double a, double b)<br>     {<!-- --><br>         if (type == 0)<br>         {<!-- --><br>             randn(dst, a, b);<br>         }<br>         else<br>         {<!-- --><br>             randu(dst, a, b);<br>         }<br>     }<br>     //initialise the weights matrix.<br>     void Net::initWeights(int type, double a, double b)<br>     {<!-- --><br>         //Initialise weights cv::Matrices and bias<br>         for (int i = 0; i &lt; weights.size(); ++i)<br>         {<!-- --><br>             initWeight(weights[i], 0, 0., 0.1);<br>         }<br>     }</p> 
<p><strong>偏置初始化是给所有的偏置赋相同的值。这里用Scalar对象来给矩阵赋值。</strong></p> 
<pre>
</pre> 
<p>    //Initialise the bias matrices.<br>     void Net::initBias(cv::Scalar&amp; bias_)<br>     {<!-- --><br>         for (int i = 0; i &lt; bias.size(); i++)<br>         {<!-- --><br>             bias[i] = bias_;<br>         }<br>     }</p> 
<p>至此，神经网络需要初始化的部分已经全部初始化完成了。</p> 
<h3>初始化测试</h3> 
<p>我们可以用下面的代码来初始化一个神经网络，虽然没有什么功能，但是至少可以测试下现在的代码是否有BUG:</p> 
<pre>
</pre> 
<p>#include"../include/Net.h"<br> //&lt;opencv2opencv.hpp&gt;<br> using namespace std;<br> using namespace cv;<br> using namespace liu;<br> int main(int argc, char *argv[])<br> {<!-- --><br>     //Set neuron number of every layer<br>     vector&lt;int&gt; layer_neuron_num = { 784,100,10 };<br>     // Initialise Net and weights<br>     Net net;<br>     net.initNet(layer_neuron_num);<br>     net.initWeights(0, 0., 0.01);<br>     net.initBias(Scalar(0.05));<br>     getchar();<br>     return 0;<br> }</p> 
<p></p> 
<h2>二、前向传播与反向传播</h2> 
<h3>前言</h3> 
<p>前一章节中，大部分还是比较简单的。因为最重要事情就是生成各种矩阵并初始化。神经网络中的重点和核心就是本文的内容——前向和反向传播两大计算过程。每层的前向传播分别包含加权求和（卷积？）的线性运算和激活函数的非线性运算。反向传播主要是用BP算法更新权值。本文也分为两部分介绍。</p> 
<h3>前向过程</h3> 
<p>如前所述，前向过程分为线性运算和非线性运算两部分。</p> 
<p>相对来说比较简单。线型运算可以用<code>Y = WX+b</code>来表示，其中X是输入样本，这里即是第N层的单列矩阵，W是权值矩阵，Y是加权求和之后的结果矩阵，大小与N+1层的单列矩阵相同。b是偏置，默认初始化全部为0。不难推知，W的大小是<code>(N+1).rows * N.rows</code>。正如上一篇中生成weights矩阵的代码实现一样:</p> 
<pre>
</pre> 
<p>weights[i].create(layer[i + 1].rows, layer[i].rows, CV_32FC1);</p> 
<p>非线性运算可以用<code>O=f(Y)</code>来表示。Y就是上面得到的Y。O就是第N+1层的输出。f就是我们一直说的激活函数。激活函数一般都是非线性函数。它存在的价值就是给神经网络提供非线性建模能力。激活函数的种类有很多，比如sigmoid函数，tanh函数，ReLU函数等。各种函数的优缺点可以参考更为专业的论文和其他更为专业的资料。我们可以先来看一下前向函数forward()的代码：</p> 
<pre>
</pre> 
<p>    //Forward<br>     void Net::forward()<br>     {<!-- --><br>         for (int i = 0; i &lt; layer_neuron_num.size() - 1; ++i)<br>         {<!-- --><br>             cv::Mat product = weights[i] * layer[i] + bias[i];<br>             layer[i + 1] = activationFunction(product, activation_function);<br>         }<br>     }</p> 
<p>for循环里面的两句就分别是上面说的线型运算和激活函数的非线性运算。</p> 
<p>激活函数<code>activationFunction()</code>里面实现了不同种类的激活函数，可以通过第二个参数来选取用哪一种。代码如下：</p> 
<pre>
</pre> 
<p>   //Activation function  <br>     cv::Mat Net::activationFunction(cv::Mat &amp;x, std::string func_type)  <br>     {  <br>         activation_function = func_type;  <br>         cv::Mat fx;  <br>         if (func_type == "sigmoid")  <br>         {  <br>             fx = sigmoid(x);  <br>         }  <br>         if (func_type == "tanh")  <br>         {  <br>             fx = tanh(x);  <br>         }  <br>         if (func_type == "ReLU")  <br>         {  <br>             fx = ReLU(x);  <br>         }  <br>         return fx;  <br>     }</p> 
<p>各个函数更为细节的部分在<code>Function.h</code>和<code>Function.cpp</code>文件中。在此略去不表，感兴趣的请君移步Github。</p> 
<p>需要再次提醒的是，上一篇博客中给出的Net类是精简过的，下面可能会出现一些上一篇Net类里没有出现过的成员变量。完整的Net类的定义还是在Github里。</p> 
<h3>反向传播过程</h3> 
<p>反向传播原理是链式求导法则，其实就是我们高数中学的复合函数求导法则。这只是在推导公式的时候用的到。具体的推导过程我推荐看看下面这一篇教程，用图示的方法，把前向传播和反向传播表现的清晰明了，强烈推荐！<strong>Principles of training multi-layer neural network using backpropagation</strong>。</p> 
<p>一会将从这一篇文章中截取一张图来说明权值更新的代码。在此之前，还是先看一下反向传播函数backward()的代码是什么样的：</p> 
<pre>
</pre> 
<p>    //Backward<br>     void Net::backward()<br>     {<!-- --><br>         calcLoss(layer[layer.size() - 1], target, output_error, loss);<br>         deltaError();<br>         updateWeights();<br>     }</p> 
<p>可以看到主要是是三行代码，也就是调用了三个函数：</p> 
<ul>
<li> <p>第一个函数<code>calcLoss()</code>计算输出误差和目标函数，所有输出误差平方和的均值作为需要最小化的目标函数。</p> </li>
<li> <p>第二个函数<code>deltaError()</code>计算delta误差，也就是下图中delta1*df()那部分。</p> </li>
<li> <p>第三个函数<code>updateWeights()</code>更新权值，也就是用下图中的公式更新权值。</p> </li>
</ul>
<p>下面是从前面强烈推荐的文章中截的一张图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6a/0b/FSZGQc4I_o.jpg"></p> 
<p>再看下updateWeights()函数的代码：</p> 
<pre>
</pre> 
<p>    //Update weights<br>     void Net::updateWeights()<br>     {<!-- --><br>         for (int i = 0; i &lt; weights.size(); ++i)<br>         {<!-- --><br>             cv::Mat delta_weights = learning_rate * (delta_err[i] * layer[i].t());<br>             weights[i] = weights[i] + delta_weights;<br>         }<br>     }</p> 
<p>核心的两行代码应该还是能比较清晰反映上图中的那个权值更新的公式的。图中公式里的eta常被称作学习率。训练神经网络调参的时候经常要调节这货。计算输出误差和delta误差的部分纯粹是数学运算，乏善可陈。但是把代码贴在下面吧。<code>calcLoss()</code>函数在<code>Function.cpp</code>文件中：</p> 
<pre>
</pre> 
<p>    //Objective function<br>     void calcLoss(cv::Mat &amp;output, cv::Mat &amp;target, cv::Mat &amp;output_error, float &amp;loss)<br>     {<!-- --><br>         if (target.empty())<br>         {<!-- --><br>             std::cout &lt;&lt; "Can't find the target cv::Matrix" &lt;&lt; std::endl;<br>             return;<br>         }<br>         output_error = target - output;<br>         cv::Mat err_sqrare;<br>         pow(output_error, 2., err_sqrare);<br>         cv::Scalar err_sqr_sum = sum(err_sqrare);<br>         loss = err_sqr_sum[0] / (float)(output.rows);<br>     }</p> 
<p><code>deltaError()</code>在<code>Net.cpp</code>中：</p> 
<pre>
</pre> 
<p>    //Compute delta error<br>     void Net::deltaError()<br>     {<!-- --><br>         delta_err.resize(layer.size() - 1);<br>         for (int i = delta_err.size() - 1; i &gt;= 0; i--)<br>         {<!-- --><br>             delta_err[i].create(layer[i + 1].size(), layer[i + 1].type());<br>             //cv::Mat dx = layer[i+1].mul(1 - layer[i+1]);<br>             cv::Mat dx = derivativeFunction(layer[i + 1], activation_function);<br>             //Output layer delta error<br>             if (i == delta_err.size() - 1)<br>             {<!-- --><br>                 delta_err[i] = dx.mul(output_error);<br>             }<br>             else  //Hidden layer delta error<br>             {<!-- --><br>                 cv::Mat weight = weights[i];<br>                 cv::Mat weight_t = weights[i].t();<br>                 cv::Mat delta_err_1 = delta_err[i];<br>                 delta_err[i] = dx.mul((weights[i + 1]).t() * delta_err[i + 1]);<br>             }<br>         }<br>     }</p> 
<h3>注意</h3> 
<p>需要注意的就是计算的时候输出层和隐藏层的计算公式是不一样的。另一个需要注意的就是......难道大家没觉得本系列文章的代码看起来非常友好吗至此，神经网络最核心的部分已经实现完毕。剩下的就是想想该如何训练了。这个时候你如果愿意的话仍然可以写一个小程序进行几次前向传播和反向传播。还是那句话，鬼知道我在能进行传播之前到底花了多长时间调试！</p> 
<p></p> 
<h2>三、神经网络的训练和测试</h2> 
<h3>前言</h3> 
<p>在之前的章节中我们已经实现了Net类的设计和前向传播和反向传播的过程。可以说神经网络的核心的部分已经完成。接下来就是应用层面了。要想利用神经网络解决实际的问题，比如说进行手写数字的识别，需要用神经网络对样本进行迭代训练，训练完成之后，训练得到的模型是好是坏，我们需要对之进行测试。这正是我们现在需要实现的部分的内容。</p> 
<h3>完善后的Net类</h3> 
<p>需要知道的是现在的Net类已经相对完善了，为了实现接下来的功能，不论是成员变量还是成员函数都变得更加的丰富。现在的Net类看起来是下面的样子：</p> 
<pre>
</pre> 
<p>    class Net<br>     {<!-- --><br>     public:<br>         //Integer vector specifying the number of neurons in each layer including the input and output layers.<br>         std::vector&lt;int&gt; layer_neuron_num;<br>         std::string activation_function = "sigmoid";<br>         double learning_rate;<br>         double accuracy = 0.;<br>         std::vector&lt;double&gt; loss_vec;<br>         float fine_tune_factor = 1.01;<br>     protected:<br>         std::vector&lt;cv::Mat&gt; layer;<br>         std::vector&lt;cv::Mat&gt; weights;<br>         std::vector&lt;cv::Mat&gt; bias;<br>         std::vector&lt;cv::Mat&gt; delta_err;<br><br>         cv::Mat output_error;<br>         cv::Mat target;<br>         float loss;<br><br>     public:<br>         Net() {};<br>         ~Net() {};<br><br>         //Initialize net:genetate weights matrices、layer matrices and bias matrices<br>         // bias default all zero<br>         void initNet(std::vector&lt;int&gt; layer_neuron_num_);<br><br>         //Initialise the weights matrices.<br>         void initWeights(int type = 0, double a = 0., double b = 0.1);<br><br>         //Initialise the bias matrices.<br>         void initBias(cv::Scalar&amp; bias);<br><br>         //Forward<br>         void forward();<br><br>         //Forward<br>         void backward();<br><br>         //Train,use loss_threshold<br>         void train(cv::Mat input, cv::Mat target_, float loss_threshold, bool draw_loss_curve = false);        //Test<br>         void test(cv::Mat &amp;input, cv::Mat &amp;target_);<br><br>         //Predict,just one sample<br>         int predict_one(cv::Mat &amp;input);<br><br>         //Predict,more  than one samples<br>         std::vector&lt;int&gt; predict(cv::Mat &amp;input);<br><br>         //Save model;<br>         void save(std::string filename);<br><br>         //Load model;<br>         void load(std::string filename);<br><br>     protected:<br>         //initialise the weight matrix.if type =0,Gaussian.else uniform.<br>         void initWeight(cv::Mat &amp;dst, int type, double a, double b);<br><br>         //Activation function<br>         cv::Mat activationFunction(cv::Mat &amp;x, std::string func_type);<br><br>         //Compute delta error<br>         void deltaError();<br><br>         //Update weights<br>         void updateWeights();<br>     };</p> 
<p>可以看到已经有了训练的函数train()、测试的函数test()，还有实际应用训练好的模型的predict()函数，以及保存和加载模型的函数save()和load()。大部分成员变量和成员函数应该还是能够通过名字就能够知道其功能的。</p> 
<h3>训练</h3> 
<p><strong>训练函数train()</strong></p> 
<p>本文重点说的是训练函数train()和测试函数test()。这两个函数接受输入（input）和标签（或称为目标值target）作为输入参数。其中训练函数还要接受一个阈值作为迭代终止条件，最后一个函数可以暂时忽略不计，那是选择要不要把loss值实时画出来的标识。训练的过程如下：</p> 
<ol>
<li> <p>接受一个样本（即一个单列矩阵）作为输入，也即神经网络的第一层；</p> </li>
<li> <p>进行前向传播，也即forward()函数做的事情。然后计算loss；</p> </li>
<li> <p>如果loss值小于设定的阈值loss_threshold，则进行反向传播更新阈值；</p> </li>
<li> <p>重复以上过程直到loss小于等于设定的阈值。</p> </li>
</ol>
<p>train函数的实现如下：</p> 
<pre>
</pre> 
<p>    //Train,use loss_threshold<br>     void Net::train(cv::Mat input, cv::Mat target_, float loss_threshold, bool draw_loss_curve)<br>     {<!-- --><br>         if (input.empty())<br>         {<!-- --><br>             std::cout &lt;&lt; "Input is empty!" &lt;&lt; std::endl;<br>             return;<br>         }<br><br>         std::cout &lt;&lt; "Train,begain!" &lt;&lt; std::endl;<br><br>         cv::Mat sample;<br>         if (input.rows == (layer[0].rows) &amp;&amp; input.cols == 1)<br>         {<!-- --><br>             target = target_;<br>             sample = input;<br>             layer[0] = sample;<br>             forward();<br>             //backward();<br>             int num_of_train = 0;<br>             while (loss &gt; loss_threshold)<br>             {<!-- --><br>                 backward();<br>                 forward();<br>                 num_of_train++;<br>                 if (num_of_train % 500 == 0)<br>                 {<!-- --><br>                     std::cout &lt;&lt; "Train " &lt;&lt; num_of_train &lt;&lt; " times" &lt;&lt; std::endl;<br>                     std::cout &lt;&lt; "Loss: " &lt;&lt; loss &lt;&lt; std::endl;<br>                 }<br>             }<br>             std::cout &lt;&lt; std::endl &lt;&lt; "Train " &lt;&lt; num_of_train &lt;&lt; " times" &lt;&lt; std::endl;<br>             std::cout &lt;&lt; "Loss: " &lt;&lt; loss &lt;&lt; std::endl;<br>             std::cout &lt;&lt; "Train sucessfully!" &lt;&lt; std::endl;<br>         }<br>         else if (input.rows == (layer[0].rows) &amp;&amp; input.cols &gt; 1)<br>         {<!-- --><br>             double batch_loss = loss_threshold + 0.01;<br>             int epoch = 0;<br>             while (batch_loss &gt; loss_threshold)<br>             {<!-- --><br>                 batch_loss = 0.;<br>                 for (int i = 0; i &lt; input.cols; ++i)<br>                 {<!-- --><br>                     target = target_.col(i);<br>                     sample = input.col(i);<br>                     layer[0] = sample;<br><br>                     farward();<br>                     backward();<br><br>                     batch_loss += loss;<br>                 }<br><br>                 loss_vec.push_back(batch_loss);<br><br>                 if (loss_vec.size() &gt;= 2 &amp;&amp; draw_loss_curve)<br>                 {<!-- --><br>                     draw_curve(board, loss_vec);<br>                 }<br>                 epoch++;<br>                 if (epoch % output_interval == 0)<br>                 {<!-- --><br>                     std::cout &lt;&lt; "Number of epoch: " &lt;&lt; epoch &lt;&lt; std::endl;<br>                     std::cout &lt;&lt; "Loss sum: " &lt;&lt; batch_loss &lt;&lt; std::endl;<br>                 }<br>                 if (epoch % 100 == 0)<br>                 {<!-- --><br>                     learning_rate *= fine_tune_factor;<br>                 }<br>             }<br>             std::cout &lt;&lt; std::endl &lt;&lt; "Number of epoch: " &lt;&lt; epoch &lt;&lt; std::endl;<br>             std::cout &lt;&lt; "Loss sum: " &lt;&lt; batch_loss &lt;&lt; std::endl;<br>             std::cout &lt;&lt; "Train sucessfully!" &lt;&lt; std::endl;<br>         }<br>         else<br>         {<!-- --><br>             std::cout &lt;&lt; "Rows of input don't cv::Match the number of input!" &lt;&lt; std::endl;<br>         }<br>     }</p> 
<p>这里考虑到了用单个样本和多个样本迭代训练两种情况。而且还有另一种不用loss阈值作为迭代终止条件，而是用正确率的train()函数，内容大致相同，此处略去不表。</p> 
<p>在经过train()函数的训练之后，就可以得到一个模型了。所谓模型，可以简单的认为就是权值矩阵。简单的说，可以把神经网络当成一个超级函数组合，我们姑且认为这个超级函数就是y = f(x) = ax +ｂ。那么权值就是ａ和ｂ。反向传播的过程是把ａ和ｂ当成自变量来处理的，不断调整以得到最优值或逼近最优值。在完成反向传播之后，训练得到了参数ａ和ｂ的最优值，是一个固定值了。这时自变量又变回了ｘ。我们希望ａ、ｂ最优值作为已知参数的情况下，对于我们的输入样本ｘ，通过神经网络计算得到的结果ｙ，与实际结果相符合是大概率事件。</p> 
<h3>测试</h3> 
<p><strong>测试函数test()</strong></p> 
<p>test()函数的作用就是用一组训练时没用到的样本，对训练得到的模型进行测试，把通过这个模型得到的结果与实际想要的结果进行比较，看正确来说到底是多少，我们希望正确率越多越好。test()的步骤大致如下几步：</p> 
<ol>
<li> <p>用一组样本逐个输入神经网络；</p> </li>
<li> <p>通过前向传播得到一个输出值；</p> </li>
<li> <p>比较实际输出与理想输出，计算正确率。</p> </li>
</ol>
<p>test()函数的实现如下：</p> 
<pre>
</pre> 
<p>    //Test<br>     void Net::test(cv::Mat &amp;input, cv::Mat &amp;target_)<br>     {<!-- --><br>         if (input.empty())<br>         {<!-- --><br>             std::cout &lt;&lt; "Input is empty!" &lt;&lt; std::endl;<br>             return;<br>         }<br>         std::cout &lt;&lt; std::endl &lt;&lt; "Predict,begain!" &lt;&lt; std::endl;<br><br>         if (input.rows == (layer[0].rows) &amp;&amp; input.cols == 1)<br>         {<!-- --><br>             int predict_number = predict_one(input);<br><br>             cv::Point target_maxLoc;<br>             minMaxLoc(target_, NULL, NULL, NULL, &amp;target_maxLoc, cv::noArray());        <br>             int target_number = target_maxLoc.y;<br><br>             std::cout &lt;&lt; "Predict: " &lt;&lt; predict_number &lt;&lt; std::endl;<br>             std::cout &lt;&lt; "Target:  " &lt;&lt; target_number &lt;&lt; std::endl;<br>             std::cout &lt;&lt; "Loss: " &lt;&lt; loss &lt;&lt; std::endl;<br>         }<br>         else if (input.rows == (layer[0].rows) &amp;&amp; input.cols &gt; 1)<br>         {<!-- --><br>             double loss_sum = 0;<br>             int right_num = 0;<br>             cv::Mat sample;<br>             for (int i = 0; i &lt; input.cols; ++i)<br>             {<!-- --><br>                 sample = input.col(i);<br>                 int predict_number = predict_one(sample);<br>                 loss_sum += loss;<br><br>                 target = target_.col(i);<br>                 cv::Point target_maxLoc;<br>                 minMaxLoc(target, NULL, NULL, NULL, &amp;target_maxLoc, cv::noArray());<br>                 int target_number = target_maxLoc.y;<br><br>                 std::cout &lt;&lt; "Test sample: " &lt;&lt; i &lt;&lt; "   " &lt;&lt; "Predict: " &lt;&lt; predict_number &lt;&lt; std::endl;<br>                 std::cout &lt;&lt; "Test sample: " &lt;&lt; i &lt;&lt; "   " &lt;&lt; "Target:  " &lt;&lt; target_number &lt;&lt; std::endl &lt;&lt; std::endl;<br>                 if (predict_number == target_number)<br>                 {<!-- --><br>                     right_num++;<br>                 }<br>             }<br>             accuracy = (double)right_num / input.cols;<br>             std::cout &lt;&lt; "Loss sum: " &lt;&lt; loss_sum &lt;&lt; std::endl;<br>             std::cout &lt;&lt; "accuracy: " &lt;&lt; accuracy &lt;&lt; std::endl;<br>         }<br>         else<br>         {<!-- --><br>             std::cout &lt;&lt; "Rows of input don't cv::Match the number of input!" &lt;&lt; std::endl;<br>             return;<br>         }<br>     }</p> 
<p>这里在进行前向传播的时候不是直接调用forward()函数，而是调用了predict_one()函数，predict函数的作用是给定一个输入，给出想要的输出值。其中包含了对forward()函数的调用。还有就是对于神经网络的输出进行解析，转换成看起来比较方便的数值。</p> 
<h2>四、神经网络的预测和输出输出解析</h2> 
<h3>神经网络的预测</h3> 
<p><strong>预测函数predict()</strong></p> 
<p>在上一篇的结尾提到了神经网络的预测函数predict()，说道predict调用了forward函数并进行了输出的解析，输出我们看起来比较方便的值。</p> 
<p><code>predict()</code>函数和<code>predict_one()</code>函数的区别相信很容易从名字看出来，那就是输入一个样本得到一个输出和输出一组样本得到一组输出的区别，显然<code>predict()</code>应该是循环调用<code>predict_one()</code>实现的。所以我们先看一下<code>predict_one()</code>的代码：</p> 
<pre>
</pre> 
<p>    int Net::predict_one(cv::Mat &amp;input)<br>     {<!-- --><br>         if (input.empty())<br>         {<!-- --><br>             std::cout &lt;&lt; "Input is empty!" &lt;&lt; std::endl;<br>             return -1;<br>         }<br><br>         if (input.rows == (layer[0].rows) &amp;&amp; input.cols == 1)<br>         {<!-- --><br>             layer[0] = input;<br>             forward();<br><br>             cv::Mat layer_out = layer[layer.size() - 1];<br>             cv::Point predict_maxLoc;<br><br>             minMaxLoc(layer_out, NULL, NULL, NULL, &amp;predict_maxLoc, cv::noArray());<br>             return predict_maxLoc.y;<br>         }<br>         else<br>         {<!-- --><br>             std::cout &lt;&lt; "Please give one sample alone and ensure input.rows = layer[0].rows" &lt;&lt; std::endl;<br>             return -1;<br>         }<br>     }            forward();<br>             ...<br>             ...<br>             minMaxLoc(layer_out, NULL, NULL, NULL, &amp;predict_maxLoc, cv::noArray());            forward();<br>             ...<br>             ...<br>             minMaxLoc(layer_out, NULL, NULL, NULL, &amp;predict_maxLoc, cv::noArray());</p> 
<p>可以在第二个if语句里面看到最主要的内容就是两行：分别是前面提到的前向传播和输出解析。</p> 
<pre>
</pre> 
<p>            forward();<br>             ...<br>             ...<br>             minMaxLoc(layer_out, NULL, NULL, NULL, &amp;predict_maxLoc, cv::noArray());</p> 
<p>前向传播得到最后一层输出层layer__out，然后从layer__out中提取最大值的位置，最后输出位置的y坐标。</p> 
<h3>输出的组织方式和解析</h3> 
<p>之所以这么做，就不得不提一下标签或者叫目标值在这里是以何种形式存在的。以激活函数是sigmoid函数为例，sigmoid函数是把实数映射到[0,1]区间，所以显然最后的输出y：0&lt;=y&lt;=1。如果激活函数是tanh函数，则输出区间是[-1,1]。如果是sigmoid，而且我们要进行手写字体识别的话，需要识别的数字一共有十个：0-9。显然我们的神经网络没有办法输出大于1的值，所以也就不能直观的用0-9几个数字来作为神经网络的实际目标值或者称之为标签。</p> 
<p>这里采用的方案是，把输出层设置为一个单列十行的矩阵，标签是几就把第几行的元素设置为1，其余都设为0。由于编程中一般都是从0开始作为第一位的，所以位置与0-9的数字正好一一对应。我们到时候只需要找到输出最大值所在的位置，也就知道了输出是几。</p> 
<p>当然上面说的是激活函数是sigmoid的情况。如果是tanh函数呢？那还是是几就把第几位设为1，而其他位置全部设为-1即可。</p> 
<p>如果是ReLU函数呢？ReLU函数的至于是0到正无穷。所以我们可以标签是几就把第几位设为几，其他为全设为0。最后都是找到最大值的位置即可。</p> 
<p>这些都是需要根据激活函数来定。代码中是调用opencv的<code>minMaxLoc()</code>函数来寻找矩阵中最大值的位置。</p> 
<h3>输入的组织方式和读取方法</h3> 
<p>既然说到了输出的组织方式，那就顺便也提一下输入的组织方式。生成神经网络的时候，每一层都是用一个单列矩阵来表示的。显然第一层输入层就是一个单列矩阵。所以在对数据进行预处理的过程中，这里就是把输入样本和标签一列一列地排列起来，作为矩阵存储。标签矩阵的第一列即是第一列样本的标签。以此类推。</p> 
<p>值得一提的是，输入的数值全部归一化到0-1之间。</p> 
<p>由于这里的数值都是以<code>float</code>类型保存的，这种数值的矩阵Mat不能直接保存为图片格式，所以这里我选择了把预处理之后的样本矩阵和标签矩阵保存到xml文档中。在源码中可以找到把原始的csv文件转换成xml文件的代码。在<code>csv2xml.cpp</code>中。而我转换完成的MNIST的部分数据保存在data文件夹中，可以在Github上找到。</p> 
<p>在opencv中xml的读写非常方便，如下代码是写入数据：</p> 
<pre>
</pre> 
<p>    string filename = "input_label.xml";<br>     FileStorage fs(filename, FileStorage::WRITE);<br>     fs &lt;&lt; "input" &lt;&lt; input_normalized;<br>     fs &lt;&lt; "target" &lt;&lt; target_; // Write cv::Mat<br>     fs.release();</p> 
<p>而读取代码的一样简单明了：</p> 
<pre>
</pre> 
<p>        cv::FileStorage fs;<br>         fs.open(filename, cv::FileStorage::READ);<br>         cv::Mat input_, target_;<br>         fs["input"] &gt;&gt; input_;<br>         fs["target"] &gt;&gt; target_;<br>         fs.release();</p> 
<h3>读取样本和标签</h3> 
<p>我写了一个函数<code>get_input_label()</code>从xml文件中从指定的列开始提取一定数目的样本和标签。默认从第0列开始读取，只是上面函数的简单封装：</p> 
<pre>
</pre> 
<p>    //Get sample_number samples in XML file,from the start column.<br>     void get_input_label(std::string filename, cv::Mat&amp; input, cv::Mat&amp; label, int sample_num, int start)<br>     {<!-- --><br>         cv::FileStorage fs;<br>         fs.open(filename, cv::FileStorage::READ);<br>         cv::Mat input_, target_;<br>         fs["input"] &gt;&gt; input_;<br>         fs["target"] &gt;&gt; target_;<br>         fs.release();<br>         input = input_(cv::Rect(start, 0, sample_num, input_.rows));<br>         label = target_(cv::Rect(start, 0, sample_num, target_.rows));<br>     }</p> 
<p>至此其实已经可以开始实践，训练神经网络识别手写数字了。只有一部分还没有提到，那就是模型的保存和加载。下一篇将会讲模型的save和load，然后就可以实际开始进行例子的训练了。等不及的小伙伴可以直接去github下载完整的程序开始跑了。</p> 
<h2>五、模型的保存和加载及实时画出输出曲线</h2> 
<h3>模型的保存和加载</h3> 
<p>在我们完成对神经网络的训练之后，一般要把模型保存起来。不然每次使用模型之前都需要先训练模型，对于data hungry的神经网络来说，视数据多寡和精度要求高低，训练一次的时间从几分钟到数百个小时不等，这是任何人都耗不起的。把训练好的模型保存下来，当需要使用它的时候，只需要加载就行了。</p> 
<p>现在需要考虑的一个问题是，保存模型的时候，我们到底要保存哪些东西？</p> 
<p>之前有提到，可以简单的认为权值矩阵就是所谓模型。所以权值矩阵一定要保存。除此之外呢？不能忘记的一点是，我们保存模型是为了加载后能使用模型。显然要求加载模型之后，输入一个或一组样本就能开始前向运算和反向传播。这也就是说，之前实现的时候，forward()之前需要的，这里也都需要，只是权值不是随意初始化了，而是用训练好的权值矩阵代替。基于以上考虑，最终决定要保存的内容如下4个：</p> 
<ol>
<li> <p><code>layer_neuron_num</code>，各层神经元数目，这是生成神经网络需要的唯一参数。</p> </li>
<li> <p><code>weights</code>，神经网络初始化之后需要用训练好的权值矩阵去初始化权值。</p> </li>
<li> <p><code>activation_function</code>，使用神经网络的过程其实就是前向计算的过程，显然需要知道激活函数是什么。</p> </li>
<li> <p><code>learning_rate</code>，如果要在现有模型的基础上继续训练以得到更好的模型，更新权值的时候需要用到这个函数。</p> </li>
</ol>
<p>再决定了需要保存的内容之后，接下来就是实现了，仍然是保存为<code>xml</code>格式，上一篇已经提到了保存和加载<code>xml</code>是多么的方便：</p> 
<pre>
</pre> 
<p>    //Save model;<br>     void Net::save(std::string filename)<br>     {<!-- --><br>         cv::FileStorage model(filename, cv::FileStorage::WRITE);<br>         model &lt;&lt; "layer_neuron_num" &lt;&lt; layer_neuron_num;<br>         model &lt;&lt; "learning_rate" &lt;&lt; learning_rate;<br>         model &lt;&lt; "activation_function" &lt;&lt; activation_function;<br><br>         for (int i = 0; i &lt; weights.size(); i++)<br>         {<!-- --><br>             std::string weight_name = "weight_" + std::to_string(i);<br>             model &lt;&lt; weight_name &lt;&lt; weights[i];<br>         }<br>         model.release();<br>     }<br><br>     //Load model;<br>     void Net::load(std::string filename)<br>     {<!-- --><br>         cv::FileStorage fs;<br>         fs.open(filename, cv::FileStorage::READ);<br>         cv::Mat input_, target_;<br><br>         fs["layer_neuron_num"] &gt;&gt; layer_neuron_num;<br>         initNet(layer_neuron_num);<br><br>         for (int i = 0; i &lt; weights.size(); i++)<br>         {<!-- --><br>             std::string weight_name = "weight_" + std::to_string(i);<br>             fs[weight_name] &gt;&gt; weights[i];<br>         }<br><br>         fs["learning_rate"] &gt;&gt; learning_rate;<br>         fs["activation_function"] &gt;&gt; activation_function;<br><br>         fs.release();<br>     }</p> 
<h3>实时画出输出曲线</h3> 
<p>有时候我们为了有一个直观的观察，我们希望能够是实时的用一个曲线来表示输出误差。但是没有找到满意的程序可用，于是自己就写了一个非常简单的函数，用来实时输出训练时的loss。理想的输出大概像下面这样：</p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/24/39/DkgrmH9d_o.jpg" width="764"></p> 
<p> </p> 
<p>为什么说是理想的输出呢，因为一般来说误差很小，可能曲线直接就是从左下角开始的，上面一大片都没有用到。不过已经能够看出loss的大致走向了。这个函数的实现其实就是先画俩个作为坐标用的直线，然后把相邻点用直线连接起来：</p> 
<pre>
</pre> 
<p>    //Draw loss curve<br>     void draw_curve(cv::Mat&amp; board, std::vector&lt;double&gt; points)<br>     {<!-- --><br>         cv::Mat board_(620, 1000, CV_8UC3, cv::Scalar::all(200));<br>         board = board_;<br>         cv::line(board, cv::Point(0, 550), cv::Point(1000, 550), cv::Scalar(0, 0, 0), 2);<br>         cv::line(board, cv::Point(50, 0), cv::Point(50, 1000), cv::Scalar(0, 0, 0), 2);<br><br>         for (size_t i = 0; i &lt; points.size() - 1; i++)<br>         {<!-- --><br>             cv::Point pt1(50 + i * 2, (int)(548 - points[i]));<br>             cv::Point pt2(50 + i * 2 + 1, (int)(548 - points[i + 1]));<br>             cv::line(board, pt1, pt2, cv::Scalar(0, 0, 255), 2);<br>             if (i &gt;= 1000)<br>             {<!-- --><br>                 return;<br>             }<br>         }<br>         cv::imshow("Loss", board);<br>         cv::waitKey(10);<br>     }</p> 
<p>至此，神经网络已经实现完成了。完整的代码可以在Github上找到。</p> 
<p>下一步，就是要用编写的神经网络，用实际样本开始训练了。</p> 
<h2>六、实战手写数字识别</h2> 
<p>之前的五个章节讲述的内容应该覆盖了如何编写神经网络的大部分内容，在经过之前的一系列努力之后，终于可以开始实战了。试试写出来的神经网络怎么样吧。</p> 
<h3>数据准备</h3> 
<p><strong>MNIST数据集</strong></p> 
<p>有人说MNIST手写数字识别是机器学习领域的Hello World，所以我这一次也是从手写字体识别开始。我是从Kaggle找的手写数字识别的数据集。数据已经被保存为csv格式，相对比较方便读取。延庆川北小区45孙老师 收卖废品破烂垃圾炒股 废品孙 再回收</p> 
<p>数据集包含了数字0-9是个数字的灰度图。但是这个灰度图是展开过的。展开之前都是28x28的图像，展开后成为1x784的一行。csv文件中，每一行有785个元素，第一个元素是数字标签，后面的784个元素分别排列着展开后的184个像素。看起来像下面这样：</p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/de/46/cY9RjTzz_o.jpg" width="1072"></p> 
<p> </p> 
<p>也许你已经看到了第一列0-9的标签，但是<strong>会疑惑为啥像素值全是0</strong>，那是因为这里能显示出来的，甚至不足28x28图像的一行。而数字一般应该在图像中心位置，所以边缘位置当然是啥也没有，往后滑动就能看到非零像素值了。像下面这样：</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/62/fc/fm4s5A9A_o.jpg" width="1120"></p> 
<p> </p> 
<p><strong>这里需要注意到的是，像素值的范围是0-255</strong>。一般在数据预处理阶段都会归一化，全部除以255，把值转换到0-1之间。</p> 
<p>csv文件中包含42000个样本，这么多样本，对于我七年前买的4000元级别的破笔记本来说，单单是读取一次都得半天，更不要提拿这么多样本去迭代训练了，简直是噩梦（兼论一个苦逼的学生几年能挣到换电脑的钱！）。所以我只是提取了前1000个样本，然后把归一化后的样本和标签都保存到一个xml文件中。在前面的一篇博客中已经提到了输入输出的组织形式，偷懒直接复制了。</p> 
<blockquote> 
 <p>既然说到了输出的组织方式，那就顺便也提一句输入的组织方式。生成神经网络的时候，每一层都是用一个单列矩阵来表示的。显然第一层输入层就是一个单列矩阵。所以在对数据进行预处理的过程中，我就是把输入样本和标签一列一列地排列起来，作为矩阵存储。标签矩阵的第一列即是第一列样本的标签。以此类推。把输出层设置为一个单列十行的矩阵，标签是几就把第几行的元素设置为1，其余都设为0。由于编程中一般都是从0开始作为第一位的，所以位置与0-9的数字正好一一对应。我们到时候只需要找到输出最大值所在的位置，也就知道了输出是几。”</p> 
</blockquote> 
<p>这里只是重复一下，这一部分的代码在<code>csv2xml.cpp</code>中：</p> 
<pre>
</pre> 
<p>#include&lt;opencv2opencv.hpp&gt;<br> #include&lt;iostream&gt;<br> using namespace std;<br> using namespace cv;<br><br><br> //int csv2xml()<br> int main()<br> {<!-- --><br>     CvMLData mlData;<br>     mlData.read_csv("train.csv");//读取csv文件<br>     Mat data = cv::Mat(mlData.get_values(), true);<br>     cout &lt;&lt; "Data have been read successfully!" &lt;&lt; endl;<br>     //Mat double_data;<br>     //data.convertTo(double_data, CV_64F);<br><br>     Mat input_ = data(Rect(1, 1, 784, data.rows - 1)).t();<br>     Mat label_ = data(Rect(0, 1, 1, data.rows - 1));<br>     Mat target_(10, input_.cols, CV_32F, Scalar::all(0.));<br><br>     Mat digit(28, 28, CV_32FC1);<br>     Mat col_0 = input_.col(3);<br>     float label0 = label_.at&lt;float&gt;(3, 0);<br>     cout &lt;&lt; label0;<br>     for (int i = 0; i &lt; 28; i++)<br>     {<!-- --><br>         for (int j = 0; j &lt; 28; j++)<br>         {<!-- --><br>             digit.at&lt;float&gt;(i, j) = col_0.at&lt;float&gt;(i * 28 + j);<br>         }<br>     }<br><br>     for (int i = 0; i &lt; label_.rows; ++i)<br>     {<!-- --><br>         float label_num = label_.at&lt;float&gt;(i, 0);<br>         //target_.at&lt;float&gt;(label_num, i) = 1.;<br>         target_.at&lt;float&gt;(label_num, i) = label_num;<br>     }<br><br>     Mat input_normalized(input_.size(), input_.type());<br>     for (int i = 0; i &lt; input_.rows; ++i)<br>     {<!-- --><br>         for (int j = 0; j &lt; input_.cols; ++j)<br>         {<!-- --><br>             //if (input_.at&lt;double&gt;(i, j) &gt;= 1.)<br>             //{<!-- --><br>             input_normalized.at&lt;float&gt;(i, j) = input_.at&lt;float&gt;(i, j) / 255.;<br>             //}<br>         }<br>     }<br><br>     string filename = "input_label_0-9.xml";<br>     FileStorage fs(filename, FileStorage::WRITE);<br>     fs &lt;&lt; "input" &lt;&lt; input_normalized;<br>     fs &lt;&lt; "target" &lt;&lt; target_; // Write cv::Mat<br>     fs.release();<br><br><br>     Mat input_1000 = input_normalized(Rect(0, 0, 10000, input_normalized.rows));<br>     Mat target_1000 = target_(Rect(0, 0, 10000, target_.rows));<br><br>     string filename2 = "input_label_0-9_10000.xml";<br>     FileStorage fs2(filename2, FileStorage::WRITE);<br><br>     fs2 &lt;&lt; "input" &lt;&lt; input_1000;<br>     fs2 &lt;&lt; "target" &lt;&lt; target_1000; // Write cv::Mat<br>     fs2.release();<br><br>     return 0;<br> }</p> 
<p>这是我最近用ReLU的时候的代码，标签是几就把第几位设为几，其他为全设为0。最后都是找到最大值的位置即可。whaosoft aiot <a href="http://143ai.com/" title="http://143ai.com">http://143ai.com</a></p> 
<p>在代码中<code>Mat digit</code>的作用是，检验下转换后的矩阵和标签是否对应正确这里是把col(3)，也就是第四个样本从一行重新变成28x28的图像，看上面的第一张图的第一列可以看到，第四个样本的标签是4。那么它转换回来的图像时什么样呢？是下面这样：</p> 
<p><img alt="" height="456" src="https://images2.imgbox.com/c0/eb/48rZhm0I_o.jpg" width="488"></p> 
<p> </p> 
<p><strong>这里也证明了为啥第一张图看起来像素全是0。边缘全黑能不是0吗？</strong> 然后在使用的时候用前面提到过的get__input__label()获取一定数目的样本和标签。</p> 
<h3>实战数字识别</h3> 
<p>没想到前面数据处理说了那么多。。。。废话少说，直接说训练的过程：</p> 
<ol>
<li> <p>给定每层的神经元数目，初始化神经网络和权值矩阵</p> </li>
<li> <p>从input_label_1000.xml文件中取前800个样本作为训练样本，后200作为测试样本。</p> </li>
<li> <p>这是神经网络的一些参数：训练时候的终止条件，学习率，激活函数类型</p> </li>
<li> <p>前800样本训练神经网络，直到满足loss小于阈值loss_threshold，停止。</p> </li>
<li> <p>后200样本测试神经网络，输出正确率。</p> </li>
<li> <p>保存训练得到的模型。</p> </li>
</ol>
<p>以sigmoid为激活函数的训练代码如下：</p> 
<pre>
</pre> 
<p>#include"../include/Net.h"<br> //&lt;opencv2opencv.hpp&gt;<br><br> using namespace std;<br> using namespace cv;<br> using namespace liu;<br><br> int main(int argc, char *argv[])<br> {<!-- --><br>     //Set neuron number of every layer<br>     vector&lt;int&gt; layer_neuron_num = { 784,100,10 };<br><br>     // Initialise Net and weights<br>     Net net;<br>     net.initNet(layer_neuron_num);<br>     net.initWeights(0, 0., 0.01);<br>     net.initBias(Scalar(0.5));<br><br>     //Get test samples and test samples<br>     Mat input, label, test_input, test_label;<br>     int sample_number = 800;<br>     get_input_label("data/input_label_1000.xml", input, label, sample_number);<br>     get_input_label("data/input_label_1000.xml", test_input, test_label, 200, 800);<br><br>     //Set loss threshold,learning rate and activation function<br>     float loss_threshold = 0.5;<br>     net.learning_rate = 0.3;<br>     net.output_interval = 2;<br>     net.activation_function = "sigmoid";<br><br>     //Train,and draw the loss curve(cause the last parameter is ture) and test the trained net<br>     net.train(input, label, loss_threshold, true);<br>     net.test(test_input, test_label);<br><br>     //Save the model<br>     net.save("models/model_sigmoid_800_200.xml");<br><br>     getchar();<br>     return 0;<br><br> }</p> 
<p>对比前面说的六个过程，代码应该是很清晰的了。参数output_interval是间隔几次迭代输出一次，这设置为迭代两次输出一次。如果按照上面的参数来训练，正确率是0.855：</p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/75/a8/qRvumnSN_o.jpg" width="936"></p> 
<p> </p> 
<p>在只有800个样本的情况下，这个正确率我认为还是可以接受的。如果要直接使用训练好的样本，那就更加简单了：</p> 
<pre>
</pre> 
<p>    //Get test samples and the label is 0--1<br>     Mat test_input, test_label;<br>     int sample_number = 200;<br>     int start_position = 800;<br>     get_input_label("data/input_label_1000.xml", test_input, test_label, sample_number, start_position);<br><br>     //Load the trained net and test.<br>     Net net;<br>     net.load("models/model_sigmoid_800_200.xml");<br>     net.test(test_input, test_label);<br><br>     getchar();<br>     return 0;</p> 
<p>如果激活函数是tanh函数，由于tanh函数的值域是[-1,1]，所以在训练的时候要把标签矩阵稍作改动，需要改动的地方如下：</p> 
<pre>
</pre> 
<p>    //Set loss threshold,learning rate and activation function<br>     float loss_threshold = 0.2;<br>     net.learning_rate = 0.02;<br>     net.output_interval = 2;<br>     net.activation_function = "tanh";<br><br>     //convert label from 0---1 to -1---1,cause tanh function range is [-1,1]<br>     label = 2 * label - 1;<br>     test_label = 2 * test_label - 1;</p> 
<p>这里不光改了标签，还有几个参数也是需要改以下的，<strong>学习率比sigmoid的时候要小一个量级，效果会比较好</strong>。这样训练出来的正确率大概在0.88左右，也是可以接受的。<img alt="" height="566" src="https://images2.imgbox.com/fa/2f/DxOy6XQF_o.jpg" width="950"></p> 
<p> </p> 
<h3><strong>完整的代码可以在Github上找到，源码链接如下：</strong></h3> 
<p>https://github.com/LiuXiaolong19920720/simple_net</p> 
<p>再抄袭一下网路上大哥的代码 -- 不知道本站有没人发啊 反正分享一下人家代码</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>