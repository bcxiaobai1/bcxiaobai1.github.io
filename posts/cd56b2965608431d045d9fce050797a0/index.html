<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>HTTP的一些概念 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP的一些概念</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>文章目录</h3> 
 <ul><li>
<ul>
<li><a href="#HTTP_1">HTTP定义</a></li>
<li>
<ul><li><a href="#URIURL_3">URI&amp;URL</a></li></ul> 
   </li>
<li><a href="#HTTP__7">HTTP 常见的状态码</a></li>
<li><a href="#http__9">http 首部</a></li>
<li>
<ul>
<li><a href="#_10">请求首部字段</a></li>
<li><a href="#_19">响应首部字段</a></li>
<li><a href="#cookie_27">为cookie服务的首部字段</a></li>
<li><a href="#getpost_31">get请求和post请求及区别</a></li>
<li><a href="#GET__POST__43">GET 和 POST 方法是否安全和幂等</a></li>
</ul> 
   </li>
<li><a href="#HTTP_50">HTTP特性</a></li>
<li>
<ul>
<li><a href="#HTTP11__53">HTTP（1.1） 的优点有哪些</a></li>
<li><a href="#HTTP11__59">HTTP/1.1 的缺点</a></li>
<li><a href="#HTTP11__80">HTTP/1.1 的性能</a></li>
<li>
<ul><li><a href="#HTTP11__HTTP10__116">HTTP/1.1 相比 HTTP/1.0 提高了什么性能</a></li></ul> 
    </li>
<li><a href="#HTTP__HTTPS_127">HTTP 与 HTTPS</a></li>
<li>
<ul>
<li><a href="#HTTP__HTTPS__128">HTTP 与 HTTPS 有哪些区别</a></li>
<li><a href="#HTTPS__HTTP__138">HTTPS 解决了 HTTP 的哪些问题</a></li>
<li><a href="#HTTPS___149">HTTPS 是如何建立连接的</a></li>
<li><a href="#SSLTLS__162">SSL/TLS 协议建立的详细流程：</a></li>
<li><a href="#HTTPS_212">HTTPS的缺点</a></li>
</ul> 
    </li>
<li><a href="#HTTP11HTTP2HTTP3__225">HTTP/1.1、HTTP/2、HTTP/3 演变</a></li>
<li>
<ul>
<li><a href="#1_HTTP10HTTP11_226">1.相比 HTTP/1.0，HTTP/1.1提高了什么性能？</a></li>
<li><a href="#2HTTP11_HTTP2__236">2.对于HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？</a></li>
<li><a href="#HTTP2_HTTP3__262">HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</a></li>
</ul> 
   </li>
</ul> 
  </li>
</ul> 
 </li></ul> 
</div> 
<p></p> 
<h2>
<a id="HTTP_1"></a>HTTP定义</h2> 
<blockquote> 
 <p>超文本传输协议，是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。超文本包含文字、图片、视频等。</p> 
</blockquote> 
<h3>
<a id="URIURL_3"></a>URI&amp;URL</h3> 
<blockquote> 
 <p>URI:统一资源标识符，不仅可以标识http，ftp等其他的网络资源<br> URL:统一资源定位符，使用web浏览器访问web页面时需要输入的网页地址</p> 
 <ul><li>URI用字符串标识某一互联网资源，而URL表示资源的地点（在互联网上所处的位置）。可见URL是URI的子集</li></ul> 
</blockquote> 
<h2>
<a id="HTTP__7"></a>HTTP 常见的状态码</h2> 
<p><img src="https://images2.imgbox.com/6e/7c/PjJL81o4_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="http__9"></a>http 首部</h2> 
<h3>
<a id="_10"></a>请求首部字段</h3> 
<blockquote> 
 <p>客户端发送到服务端的 HTTP 请求，这个数据包称为请求报文。其中的头字段，就是请求头字段。<br> Accept：客户端希望获得资源的类型<br> Accept-Encoding：客户端支持的压缩算法<br> Accept-Language：客户端支持的语言<br> Host：当前请求的域名<br> Connection：客户端是否希望使用 TCP 长连接，如keep-alive 表示长连接；close 表示短连接<br> User-Agent：用户代理。该字段标注了发送方的一些信息，你可以通过它来知道请求方是浏览器、爬虫、postman 还是 cURL。</p> 
</blockquote> 
<h3>
<a id="_19"></a>响应首部字段</h3> 
<blockquote> 
 <p>服务端响应客户端的请求报文，会返回响应报文，响应报文的头字段，就是所谓的响应头字段。<br> Content-Type：服务端返回的资源类型，可以带上使用的编码格式<br> Content-Encoding：返回资源使用的压缩格式<br> Content-Length：HTTP 消息体的长度<br> Date：HTTP 响应报文生成的时间<br> Connection：服务端决定使用长连接还是短连接<br> Server：使用了哪种服务器</p> 
</blockquote> 
<h3>
<a id="cookie_27"></a>为cookie服务的首部字段</h3> 
<blockquote> 
 <ul>
<li>Set-Cookie</li>
<li>Cookie</li>
</ul> 
</blockquote> 
<h3>
<a id="getpost_31"></a>get请求和post请求及区别</h3> 
<blockquote> 
 <p><strong>get请求</strong>:从指定的资源请求数据，用于获取数据，一般用于搜索排序和筛选之类的操作。<br> <strong>post请求</strong>:向指定的资源提交要被处理的数据，用于将数据发送给服务器，一般用于修改和写入数据。<br> get请求和post请求<strong>本质上</strong>就是TCP连接，并无差别。但是<font color="red">由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同</font>。</p> 
 <p>（1）post请求更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中，get请求的是静态资源，则会缓存，如果是数据，则不会缓存）<br> （2）post请求发送的数据更大（get请求有url长度限制，http协议本身不限制，请求长度限制是由浏览器和web服务器决定和设置）<br> （3）post请求能发送更多的数据类型（get请求只能发送ASCII字符）<br> （4）传参方式不同（get请求参数通过url传递，post请求放在request body中传递）<br> （5）get请求产生一个TCP数据包；post请求产生两个TCP数据包（get请求，浏览器会把http header和data一并发送出去，服务器响应200返回数据；post请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 返回数据）<br> 注意：在发送 POST 的时候都没有带 Expect 头，server 也自然不会发 100 continue。</p> 
</blockquote> 
<h3>
<a id="GET__POST__43"></a>GET 和 POST 方法是否安全和幂等</h3> 
<blockquote> 
 <ul>
<li>在 HTTP 协议里，「<strong>安全</strong>」是指请求方法不会「破坏」服务器上的资源。</li>
<li>「<strong>幂等</strong>」是多次执行相同的操作，结果都是「相同」的</li>
<li>结论：<br> <font color="red">GET 方法是安全且幂等的</font>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。<br> <font color="red">POST既不安全也不幂等</font>，因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的</li>
</ul> 
</blockquote> 
<h2>
<a id="HTTP_50"></a>HTTP特性</h2> 
<p><img src="https://images2.imgbox.com/d6/b1/ilqJGijH_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="HTTP11__53"></a>HTTP（1.1） 的优点有哪些</h3> 
<blockquote> 
 <p>HTTP 最凸出的优点是「<strong>简单、灵活和易于扩展、应用广泛和跨平台</strong>」<br> <strong>简单</strong>：HTTP 基本的报文格式就是 <strong>header + body</strong>，头部信息也是 <strong>key-value</strong> 简单文本的形式，易于理解，降低了学习和使用的门槛<br> <strong>灵活和易于扩展</strong>：HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong><br> <strong>应用广泛和跨平台</strong>：HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，天然具有跨平台的优越性</p> 
</blockquote> 
<h3>
<a id="HTTP11__59"></a>HTTP/1.1 的缺点</h3> 
<blockquote> 
 <p>HTTP 协议里有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不安全」<br> <strong>无状态双刃剑</strong></p> 
 <ul>
<li>无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务</li>
<li>无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。<br> 例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。<br> 这样每操作一次，都要验证信息。<br> 对于无状态的问题，<strong>解法方案</strong>有很多种，其中比较简单的方式<strong>用 Cookie 技术</strong>。<br> <strong>Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态</strong>
</li>
</ul> 
</blockquote> 
<blockquote> 
 <p><strong>明文传输双刃剑</strong></p> 
 <ul>
<li>明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</li>
<li>但是这正是这样，HTTP 的所有信息都暴露出来。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取</li>
</ul> 
</blockquote> 
<blockquote> 
 <p><strong>不安全</strong><br> HTTP 比较严重的缺点就是不安全：</p> 
 <ul>
<li>通信使用明文（不加密），内容可能会被窃听。</li>
<li>不验证通信方的身份，因此有可能遭遇伪装。</li>
<li>无法证明报文的完整性，所以有可能已遭篡改。</li>
<li>
<strong>HTTP 的安全问题，可以用 HTTPS 的方式解决</strong>，也就是<strong>通过引入 SSL/TLS 层</strong>，使得在安全上达到了极致。</li>
</ul> 
</blockquote> 
<h3>
<a id="HTTP11__80"></a>HTTP/1.1 的性能</h3> 
<p>HTTP 协议是<strong>基于 TCP/IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这两点里。</p> 
<p><strong>1.长连接</strong></p> 
<p>早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p> 
<p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>长连接</strong>的通信方式。这种方式的好处在于<strong>减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</strong>。</p> 
<p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p> 
<p>当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。<br> <img src="https://images2.imgbox.com/85/aa/1clQ3auX_o.png" alt="在这里插入图片描述"></p> 
<p><strong>2.管道网络传输</strong></p> 
<p>HTTP/1.1 采用了<strong>长连接的方式，这使得管道（pipeline）网络传输成为了可能</strong>。</p> 
<p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p> 
<p>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。</p> 
<p>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「<strong>队头堵塞</strong>」。</p> 
<p>所以，<strong>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。<br> <img src="https://images2.imgbox.com/5b/e8/b5NyF7JC_o.png" alt="在这里插入图片描述"></p> 
<p><strong>3. 队头阻塞</strong></p> 
<p>「请求 - 应答」的模式加剧了 HTTP 的性能问题。</p> 
<p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。<br> <img src="https://images2.imgbox.com/0f/a2/gmQ7tbxH_o.png" alt="在这里插入图片描述"></p> 
<h4>
<a id="HTTP11__HTTP10__116"></a>HTTP/1.1 相比 HTTP/1.0 提高了什么性能</h4> 
<blockquote> 
 <ul>
<li>使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li>
<li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul> 
</blockquote> 
<p>但 HTTP/1.1 还是有性能瓶颈：</p> 
<blockquote> 
 <ul>
<li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应</li>
</ul> 
</blockquote> 
<h3>
<a id="HTTP__HTTPS_127"></a>HTTP 与 HTTPS</h3> 
<h4>
<a id="HTTP__HTTPS__128"></a>HTTP 与 HTTPS 有哪些区别</h4> 
<p>1.HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p> 
<p>2.HTTP 连接建立相对简单，是无状态的， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</p> 
<p>3.使用的是完全不同的连接方式，用的端口也不一样，HTTP 的端口号是 <strong>80</strong>，HTTPS 的端口号是 <strong>443</strong>。</p> 
<p>4.HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。<br> HTTP与HTTPS：<br> <img src="https://images2.imgbox.com/72/e3/XsvnyQUK_o.png" alt="在这里插入图片描述"></p> 
<h4>
<a id="HTTPS__HTTP__138"></a>HTTPS 解决了 HTTP 的哪些问题</h4> 
<blockquote> 
 <p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p> 
 <ul><li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没<br> 篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎<br> 冒充风险，比如冒充淘宝网站，用户钱容易没</li></ul> 
</blockquote> 
<blockquote> 
 <p>HTTPS解决了上述的风险：</p> 
 <ul><li>信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。<br> 校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。<br> 身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没</li></ul> 
</blockquote> 
<h4>
<a id="HTTPS___149"></a>HTTPS 是如何建立连接的</h4> 
<p>SSL/TLS 协议基本流程：</p> 
<p>客户端向服务器索要并验证服务器的公钥。</p> 
<p>双方协商生产「会话秘钥」。</p> 
<p>双方采用「会话秘钥」进行加密通信。</p> 
<p>前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。</p> 
<p>SSL/TLS 的「握手阶段」涉及四次通信，可见下图：<br> <img src="https://images2.imgbox.com/8a/88/UNsRra2I_o.png" alt="在这里插入图片描述"></p> 
<h4>
<a id="SSLTLS__162"></a>SSL/TLS 协议建立的详细流程：</h4> 
<p><strong>1. ClientHello</strong></p> 
<p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。</p> 
<p>在这一步，客户端主要向服务器发送以下信息：</p> 
<p>（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</p> 
<p>（2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。</p> 
<p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p> 
<p><strong>2. SeverHello</strong></p> 
<p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</p> 
<p>（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p> 
<p>（2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。</p> 
<p>（3）确认的密码套件列表，如 RSA 加密算法。</p> 
<p>（4）服务器的数字证书。</p> 
<p><strong>3.客户端回应</strong></p> 
<p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p> 
<p>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p> 
<p>（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。</p> 
<p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p> 
<p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p> 
<p>上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</p> 
<p><strong>4. 服务器的最后回应</strong></p> 
<p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：</p> 
<p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p> 
<p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p> 
<p>至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p> 
<h4>
<a id="HTTPS_212"></a>HTTPS的缺点</h4> 
<p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p> 
<p>（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p> 
<p>（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p> 
<p>（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p> 
<p>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p> 
<p>（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p> 
<h3>
<a id="HTTP11HTTP2HTTP3__225"></a>HTTP/1.1、HTTP/2、HTTP/3 演变</h3> 
<blockquote> 
 <h4>
<a id="1_HTTP10HTTP11_226"></a>1.相比 HTTP/1.0，HTTP/1.1提高了什么性能？</h4> 
 <ul>
<li>使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li>
<li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul> 
 <blockquote> 
  <p>但 HTTP/1.1 还是有性能瓶颈：</p> 
  <ul>
<li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <h4>
<a id="2HTTP11_HTTP2__236"></a>2.对于HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？</h4> 
 <p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p> 
 <ol>
<li>头部压缩<br> HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的分</strong>。<br> 这就是 <strong>HPACK 算法</strong>：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</li>
<li>二进制格式<br> HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是<strong>全面采用了二进制格式</strong>。<br> 头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧和数据帧</strong>。<br> 报文差异：<br> <img src="https://images2.imgbox.com/e2/55/Mih9Pvhw_o.png" alt="在这里插入图片描述"><br> 这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</li>
<li>数据流<br> HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br> 每个请求或回应的所有数据包，称为一个数据流（Stream）。<br> 每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数<br> 客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。<br> <img src="https://images2.imgbox.com/01/98/U0Ul0GgX_o.png" alt="在这里插入图片描述">
</li>
<li>多路复用<br> HTTP/2 是可以<strong>在一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。<br> 移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。<br> 举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。多路复用：<br> <img src="https://images2.imgbox.com/fd/0d/krZvI0Rp_o.png" alt="在这里插入图片描述">
</li>
<li>服务器推送<br> HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。<br> 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送（Server Push，也叫 Cache Push）。</li>
</ol> 
</blockquote> 
<blockquote> 
 <h4>
<a id="HTTP2_HTTP3__262"></a>HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</h4> 
 <ol><li>HTTP/2 主要的问题在于：<br> 多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。<br> 所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</li></ol> 
 <ul>
<li>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li>
<li>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li>
</ul> 
</blockquote> 
<p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</strong>！<br> <img src="https://images2.imgbox.com/2b/94/S4wmHazM_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。<br> 大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p> 
 <ul>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li>
<li>TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。</li>
<li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。<br> TCP HTTPS（TLS/1.3） 和 QUIC HTTPS:<br> <img src="https://images2.imgbox.com/ef/b0/9xOJrYff_o.png" alt="在这里插入图片描述"><br> 所以， QUIC 是<strong>一个在 UDP 之上</strong>的<strong>伪 TCP + TLS + HTTP/2 的多路复用的协议</strong>。<br> QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</li>
</ul> 
</blockquote> 
<p>参考：</p> 
<ul>
<li>小林coding</li>
<li><a href="https://zhuanlan.zhihu.com/p/389041095">https://zhuanlan.zhihu.com/p/389041095</a></li>
</ul>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>