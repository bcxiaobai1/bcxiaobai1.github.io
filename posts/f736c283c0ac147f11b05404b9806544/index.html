<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>大数据之Java基础（二）：Java基础语法 [上] - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大数据之Java基础（二）：Java基础语法 [上]</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <h2 id="1%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97">1、关键字</h2> 
<p><strong>        <span style="color:#0d0016">关键字 </span></strong>：被Java语言赋予特定含义的单词</p> 
<p><strong>        特点</strong> ：组成关键字的字母全部小写</p> 
<p><strong>        注意事项</strong> ：<span style="color:#0d0016">goto和const作为保留字存在,目前并不使用 ，类似IDEA这样的集成工具,针对关键字有特殊的颜色标记，非常直观。加上下列50个共有52个关键字：</span></p> 
<p style="text-align:center"><img alt="" height="224" src="https://images2.imgbox.com/de/a8/Z482UgUJ_o.png" width="521"></p> 
<p style="text-align:center"><img alt="" height="310" src="https://images2.imgbox.com/35/c8/z6LwVHoo_o.png" width="529"></p> 
<p></p> 
<h2 id="2%E3%80%81%E5%B8%B8%E8%A7%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">2、常见命名规则</h2> 
<h3 id="%EF%BC%881%EF%BC%89%E6%A0%87%E8%AF%86%E7%AC%A6">2.1、标识符</h3> 
<p><strong>       <span style="color:#0d0016"> 标识符</span></strong>：给类，接口，方法，变量等起名字时使用的字符序列<br><strong>        组成</strong>：1、英文大小写字母<br>                    2、数字<br>                    3、$和_</p> 
<p><strong>         注意事项</strong>：  <br>                 1、不能以数字开头<br>                 2、不能有除$和_以外的特殊字符出现<br>                 3、不能是java关键字</p> 
<h3 id="%C2%A0%EF%BC%882%EF%BC%89%E5%85%B6%E4%BB%96"> 2.2、其他</h3> 
<h3 id="%C2%A0%20%C2%A0%202.2.1%E5%8C%85%EF%BC%88%E7%90%86%E8%A7%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%2F%E7%9B%AE%E5%BD%95%EF%BC%89">    2.2.1、<strong>包（理解为一个文件夹/目录）</strong>
</h3> 
<p>              单级文件夹（所有字母全部小写）</p> 
<p>                 举例：bigdata</p> 
<p>              多级文件夹（所有字母全部小写，文件夹之间用<strong> . </strong>分开）</p> 
<p>                 举例：com.bigdata.rz</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%202.2.2%E3%80%81%E7%B1%BB%E6%88%96%E8%80%85%E6%8E%A5%E5%8F%A3">         <strong>  2.2.2、类或者接口</strong>
</h3> 
<p>               一个单词组成（首字母大写其余字母小写）</p> 
<p>                  举例：Hello</p> 
<p>               多个单词组成（所有单词的首字母大写，其余字母小写）</p> 
<p>                   举例：HelloWorld</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.3%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%8F%98%E9%87%8F">            2.2.<strong>3、方法和变量</strong>
</h3> 
<p>                一个单词组成（所有字母小写）</p> 
<p>                   举例：eat</p> 
<p>                多个单词组成（第一个单词全部小写，从第二个单词开始，首字母大写，其余字母小写）</p> 
<p>                   举例：playGame</p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%C2%A02.2.4%E3%80%81%E5%B8%B8%E9%87%8F">          <strong>   2.2.4、常量</strong>
</h3> 
<p>                  一个单词组成（所有字母全部大写）</p> 
<p>                    举例：NAME</p> 
<p>                   多个单词组成（所有字母全部大写，单词与单词之间用下划线连接）</p> 
<p>                     举例：FIRST_NAME</p> 
<h2 id="3%E3%80%81%E6%B3%A8%E9%87%8A">3、注释</h2> 
<p><strong>      <span style="color:#fe2c24"> </span><span style="color:#0d0016"> 注释</span></strong><span style="color:#0d0016"> </span>：用于解释说明程序的文字 Java中注释分类格式</p> 
<p>        单行注释格式： // 注释文字</p> 
<p>        多行注释格式： /*  注释文字  */</p> 
<p>        文档注释格式：/** 注释文字 */</p> 
<p>                注释是一个程序员必须要具有的良好编程习惯。 初学者编写程序可以养成习惯：先写注释再写代码。 将自己的思想通过注释先整理出来，在用代码去体现。 因为代码仅仅是思想的一种体现形式而已。</p> 
<pre><code class="language-java">// 声明一个类，类名为HelloWoeld
class HelloWorld {
    // 定义main函数，使程序能被jvm调用
    public static void main(String[] args){
        // 调用输出函数，输出:HelloWorld!
        System.out.println("HelloWorld!");
    }
}</code></pre> 
<h2 id="4%E3%80%81%E5%B8%B8%E9%87%8F">4、常量</h2> 
<p><strong>       <span style="color:#fe2c24"> </span><span style="color:#0d0016">常量</span>：</strong>在程序执行的过程中其值不可以发生改变 。Java中常量分为<span style="color:#0d0016"><strong>字面值常量</strong>和<strong>自定义常量</strong></span></p> 
<h3 id="4.1%E3%80%81%E5%B8%B8%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB">4.1、常量的分类</h3> 
<p><strong><span style="color:#0d0016">（1）字面值常量</span></strong></p> 
<p><span style="color:#0d0016">字符串常量    用双引号括起来的内容    "abc"</span></p> 
<p><span style="color:#0d0016">整数常量        所有整数                         12,23 </span></p> 
<p><span style="color:#0d0016">小数常量        所有小数                         12.34,56.78 </span></p> 
<p><span style="color:#0d0016">字符常量        用单引号括起来的内容    ‘a’,’A’,’0’ </span></p> 
<p><span style="color:#0d0016">布尔常量        较为特有，只有true和false </span></p> 
<p><span style="color:#0d0016">空常量           null(数组部分讲解)</span></p> 
<p><strong><span style="color:#0d0016">（2）自定义常量</span></strong><span style="color:#0d0016">（面向对象部分讲解）</span></p> 
<h3 id="4.2%E3%80%81%E8%BF%9B%E5%88%B6"><strong><span style="color:#0d0016">4.2、进制</span></strong></h3> 
<h3 id="4.2.1%E3%80%81%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%84%E6%88%90"><strong><span style="color:#0d0016">4.2.1、不同进制的数据组成</span></strong></h3> 
<p><strong><span style="color:#0d0016">二进制：</span></strong><span style="color:#0d0016">由0，1组成，以0b开头</span></p> 
<p><strong><span style="color:#0d0016">八进制：</span></strong><span style="color:#0d0016">由0，1，...，7组成，以0开头</span></p> 
<p><span style="color:#0d0016"><strong>十进制</strong>：由0，...，9组成，整数默认是十进制的</span></p> 
<p><strong><span style="color:#0d0016">十六进制：</span></strong><span style="color:#0d0016">有0，1，...，9，a，b，c，d，e，f组成，以0x开头</span></p> 
<h3 id="4.2.2%E3%80%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%C2%A0"><strong><span style="color:#0d0016">4.2.2、进制转换 </span></strong></h3> 
<p>其他进制转十进制：系数*基数^权的和</p> 
<p>十进制转其他进制：除基取余，直到商为0，余数反转</p> 
<p>二进制与十进制的快速转换：8421码</p> 
<p>任意进制之间的转换：1、以十进制为桥梁   <br>                                     2、拆分组合法<br>                                           a: 八进制3位为一组<br>                                           b: 十六进制4位为一组</p> 
<pre><code class="language-java">/*
        Java针对整数常量提供了4种表现形式:
            二进制
                由0，1组成。以0b开头
            八进制
                由0，1，2，3，4，5，6，7组成。以0开头
            十进制
                由0，1，2，3，4，5，6，7，8，9组成。整数默认就是十进制的
            十六进制
                由0，1，2，3，4，5，6，7，8，9，a，b，c，d，e，f组成。以0x开头

        1、求32的二进制，八进制，十六进制。
        32的二进制：
            32/2 = 16 .....  0
            16/2 = 8  .....  0
            8/2  = 4  .....  0
            4/2  = 2  .....  0
            2/2  = 1  .....  0
            1/2  = 0  .....  1

            32的二进制为：0b100000

       32的八进制：
            32/8 = 4  ..... 0
            4/8  = 0  ..... 4

            32的八进制为：040

       32的十六进制：
            32/16 = 2  ..... 0
            2/16  = 0  ..... 2

            32的十六进制为：0x20

        2、0b10010的十进制
        二进制：                                               十进制：18
        0b10010  = 1*2^4 + 0*2^3 + 0*2^2 + 1*2^1 + 0*2^0
                 = 16 + 0 + 0 + 2 + 0
                 = 18

        3、求下面各进制对应的十进制
        0b10101 = 1*2^4 + 0*2^3 + 1*2^2 + 0*2^1 + 1*2^0
                = 16 + 0 + 4 + 0 + 1
                = 21

        0123 = 1*8^2 + 2*8^1 + 3*8^0
             = 64 + 16 + 3
             = 83

        0x3c = 3*16^1 + 12*16^0
             = 48 + 12
             = 60
        4、0b100110的八进制      046
           100 110
             4   6 
        5、0b100110的十六进制    0x26
           10   0110
            2      6
 */</code></pre> 
<h3 id="%C2%A04.3%E3%80%81%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%B3%95"> 4.3、有符号数据表示法</h3> 
<p>        在计算机内，有符号数有3种表示法：原码、反码和补码。所有数据的运算都是采用补码进行的。</p> 
<p><strong>        原码</strong>：就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。</p> 
<p><strong>        反码</strong>：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</p> 
<p><strong>        补码</strong>：正数的补码与其原码相同；负数的补码是在其反码的末位加1。    </p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/4d/d6/X4r0YCLc_o.png" width="694"></p> 
<p style="text-align:center"><img alt="" height="157" src="https://images2.imgbox.com/a5/65/rcYLI0KJ_o.png" width="292"></p> 
<h2 id="5%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">5、数据类型</h2> 
<p style="text-align:center"><img alt="" height="283" src="https://images2.imgbox.com/84/ae/oZnFnlrH_o.png" width="596"></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%205.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%EF%BC%89">    5.1、基本数据类型（从小到大）</h3> 
<p>       整数类型：<br>         byte          1个字节         -2^7~2^7-1<br>         short         2个字节         -2^15~2^15-1<br>         int             4个字节         -2^31~2^15-1<br>         long          8个字节         -2^63~2^63-1</p> 
<p>       浮点类型：<br>         float          4个字节         -3.403*10^38 ~ 3.403*10^38<br>         double      8个字节         -1.798*10^308 ~ 1.798*10^308</p> 
<p>       字符型：<br>         char          2个字节</p> 
<p>        布尔型：</p> 
<p>        boolean    1个字节</p> 
<h3 id="%C2%A0%20%C2%A0%205.2%E3%80%81%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%83%A8%E5%88%86%E8%AE%B2%E8%A7%A3%EF%BC%89">
<br>     5.2、引用数据类型（面向对象部分讲解）</h3> 
<h3 id="%C2%A0%20%C2%A0%205.3%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">    5.3、数据类型转换</h3> 
<p>     自动类型转换：<br>         byte,short,char在参与运算的时候会自动提升到int类型<br>         由大的数据类型接收小的数据类型，会自动转换，不会报错。<br>     强制类型转换<br>         由小的数据类型接收大的数据类型，会报错，接收不了，这时候需要强制类型转换<br>         格式：目标数据类型 目标变量名 = (目标数据类型)要转换的数值/变量</p> 
<pre><code class="language-java">/*
        byte b = 130;有没有问题?如果我想让赋值正确，可以怎么做?结果是多少呢?
            有问题，因为byte数据类型的范围是在-128~127之间，而130超出了范围。


 */
public class DataTypeDemo{
    public static void main(String[] args) {
//        byte b = 130;

        byte b = (byte)130;
        System.out.println(b);  // -126
        b = (byte)131;
        System.out.println(b);

        byte b1 = (byte)300;
        System.out.println(b1); // 44
    }
}

/*
        我们知道数据在计算机中运算的时候是采用补码的形式参数运算的，所以要知道130的补码
        而想要知道补码，就得知道反码，原码，所以得求出130的二进制的表示：
        130的二进制：10000010
        由于整数默认是int类型，所以扩大字节
        130的原码为：00000000 00000000 00000000 10000010
        又由于最高位是0，所以它的原码，反码，补码都一样
        130的补码：00000000 00000000 00000000 10000010
        做截取操作：10000010 这是补码

        已知补码，求原码：
               符号位   数值位
        补码：    1     0000010
        反码：    1     0000001
        原码：    1     1111110

        最终结果为：11111110
        将它换算成十进制就是我们看到的结果：-126



 */
</code></pre> 
<h2 id="6%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6">6、运算符</h2> 
<h3 id="6.1%E3%80%81%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6">6.1、算数运算符</h3> 
<p style="text-align:center"><img alt="" height="328" src="https://images2.imgbox.com/49/c5/OFP79rvA_o.png" width="485"></p> 
<h3 id="%C2%A06.1.1%E3%80%81%2B%EF%BC%8C-%EF%BC%8C*%EF%BC%8C%2F%EF%BC%8C%25"> 6.1.1、+，-，*，/，%</h3> 
<pre><code class="language-java">/*
        System.out.println(“hello”+’a’+1);
        System.out.println(‘a’+1+”hello”);
        System.out.println(“5+5=”+5+5);
        System.out.println(5+5+”=5+5”);

        +号的用法：
            1、当加号两边都是数字或者是数字和字符的时候，这时候的+号做的是加法运算
            2、当加号两边其中是字符串的时候，做的是字符串拼接，拼接后是一个新的字符串
            3、字符串与任何数值做加法，做的是字符串拼接，拼接后是一个新的字符串

 */
public class DataTypeDemo{
    public static void main(String[] args) {
        System.out.println("hello"+'a'+1); // helloa1
        System.out.println('a'+1+"hello"); // 98hello
        System.out.println("5+5="+5+5); // 5+5=55
        System.out.println(5+5+"=5+5"); // 10=5+5

        //System.out.println("5+5="+5+5); // 5+5=55 我想先计算后面的5+5怎么办？
        //小括号可以改变运算的顺序优先级
        System.out.println("5+5="+(5+5));
    }
}
</code></pre> 
<pre><code class="language-java">/*
        运算：
            对常量和变量进行操作的过程称为运算。

        运算符：
            对常量和变量进行操作的符号称为运算符

        操作数：
            参与运算的数据

        表达式：
            用运算符把常量或者变量连接起来符号并且符合java语法的式子就可以称为表达式。
            不同运算符连接的式子体现的是不同类型的表达式。

        算术运算符：
            +，-，*，/，%，++，--
 */
public class OptArithmeticDemo{
    public static void main(String[] args) {
        //+ 加法运算
        System.out.println(1+1);    //2

        //-减法运算
        System.out.println(5-2);    //3

        //* 乘法运算
        System.out.println(2*2);    //4

        //  / 整除运算,只获取整数部分
        System.out.println(5/2);    //2
        // 我就想获取小数怎么办？将其中的某一个数的数据类型变成double
        System.out.println((5*1.0)/2); // 2.5

        // %  取余运算
        // 5/2=2 .... 1
        System.out.println(5%2);    //1

    }
}
</code></pre> 
<p style="text-align:center"></p> 
<h3 id="6.1.2%E3%80%81%2B%2B%EF%BC%8C--">6.1.2、++，--</h3> 
<pre><code class="language-java">/*
        1:基本小题目
	        int a = 10;
	        int b = 10;
	        int c = 10;

	        a = b++;
	        c = --a;
	        b = ++a;
	        a = c--;
	请分别计算出a,b,c的值

 */
public class OptArithmeticDemo{
    public static void main(String[] args) {
        int a = 10;
        int b = 10;
        int c = 10;

        a = b++; // a=10  ,b=11  ,c=10
        c = --a; // a=9  ,b=11  ,c=9
        b = ++a; // a=10  ,b=10  ,c=9
        a = c--; // a=9  ,b=10  ,c=8

        System.out.println(a); // 9
        System.out.println(b); // 10
        System.out.println(c); // 8
    }
}
</code></pre> 
<pre><code class="language-java">/*
                int a = 4;
                int b = (a++)+(++a)+(a*10);

 */
public class OptArithmeticDemo{
    public static void main(String[] args) {
        int a = 4;
        int b = (a++)+(++a)+(a*10);
        //        4     6      60
        //       a=5   a=6    a=6

        System.out.println(a);//6
        System.out.println(b);//70
    }
}
</code></pre> 
<h3 id="6.2%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">6.2、赋值运算符</h3> 
<p>    short s=1, s = s+1;<br>     short s=1, s += 1;<br>     上面两个代码有没有问题，如果有，那里有问题？<br>             第一个有问题，因为变量参与运算，首先会提升数据类型，然后做运算。所以 s = s+1;s会提升到int类型然后再做加法运算，最终的结果是int类型，所以拿short类型接收会报错，所以要想成功赋值，就得强制类型转换。</p> 
<p>            第二个代码没有问题，是因为内部自动包含了强制类型转换，s+=1 ===&gt;  s = (s的数据类型)(s+1)</p> 
<pre><code class="language-java">/*
        赋值运算符：  = , +=, -=, *=, /=, %=
        其中我们一直在使用的也是最常用的：=
 */
public class OptFuZhiDemo{
    public static void main(String[] args) {
//        int a = 10;
//        int b = a;
//        System.out.println(a);
//        System.out.println(b);

        // +=
//        int a += 10;
        int a = 10;
        a += 20; //这里实际上可以看作为a的值加上了一个20再赋值给a
                 //但是不能完全等于 a = a + 20
                 //因为a += 20等价于a = (int)(a + 20)
        System.out.println(a);

        //-=
        a-=10;
        System.out.println(a); //20

        //*=
        a*=2;
        System.out.println(a); //40

        // /=
        a/=2;
        System.out.println(a); //20

        // %=
        a%=3;
        System.out.println(a); //2


    }
}
</code></pre> 
<h3 id="6.3%E3%80%81%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">6.3、关系运算符</h3> 
<p>关系运算符： ==,!=,&gt;,&lt;,&gt;=,&lt;=</p> 
<p>       注意事项：<br>             1、关系运算符的表达式的结果是一个boolean类型，要么是true，要么是false<br>             2、==不能少写，一个=是赋值运算符，==才是关系运算符<br>             3、赋值的时候要注意类型问题,关系运算符表达式的结果是boolean类型，所以接收的时候只能是boolean类型的变量接收。</p> 
<pre><code class="language-java">public class OptGuanXiDemo{
    public static void main(String[] args) {
        int a = 3;
        int b = 4;
        boolean flag = (a == b);
        System.out.println(flag);    //false

        //!=
        System.out.println(a != b);    //true

        //&gt;
        System.out.println(a&gt;b);    //false

        //&lt;
        System.out.println(a&lt;b);    //true

        //&gt;=
        a = 4;
        System.out.println(a&gt;=b);    //true

        //&lt;=
        System.out.println(a&lt;=b);    //true

        System.out.println(a==b);    //true
        System.out.println(a=b);     //4
    }
}
</code></pre> 
<h3 id="6.4%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">6.4、逻辑运算符</h3> 
<p>逻辑运算符： &amp;,|,^,!,&amp;&amp;,||</p> 
<p>       逻辑运算符的两边放的是boolean类型的值，计算的结果也是一个boolean类型的值</p> 
<p>       &amp;: 参与运算的时候，有false,则false,两边都做运算<br>        |: 参与运算的时候，有true,则true,两边都做运算<br>        ^: 参与运算的时候，相同为false，不同为true,两边都做运算<br>        !: 将true变成false,false变成true</p> 
<p>      &amp;&amp;: 短路与，结果和单个与结果一样，有false则false，但是执行的东西不一样,<br>             当&amp;&amp;左边的表达式结果为false的时候，结果是false，右边不执行<br>        ||: 短路或，结果和单个或结果一样，有true则true,但是执行的东西不一样,<br>             当||左边是true的时候，右边不执行，结果是true.</p> 
<p>        逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6</p> 
<h3 id="6.5%E3%80%81%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6">6.5、三目运算符</h3> 
<p>三目运算符：又称之为三元运算符<br>      格式：<strong>(关系表达式)?表达式1:表达式2</strong>;<br>         如果关系表达式的结果为true，运算后的结果是表达式1；<br>         如果关系表达式的结果为false，运算后的结果是表达式2；</p> 
<p>    注意事项：<br>         1、三目运算符表达式的结果数据类型由三目运算符表达式1和表达式2中最大的数据类型决定的。<br>         2、关系表达式一定只能是boolean类型</p> 
<pre><code class="language-java">public class OptSanMuDemo{
    public static void main(String[] args) {
        //求出a,b中的最大值
        int a = 10;
        int b = 30;
        //三目运算符解决
        int c = (a&gt;b)?a:b;
        System.out.println(c);    //30


      /*面试题：
        int a1 = 20;
        double b1 = 30.0;
        double c1 = (a1&gt;b1)?a1:b1;
        System.out.println(c1);    //30.0,数据类型取决于a1,b1最大的数据类型
      */

    }</code></pre> 
<h3 id="6.6%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">6.6、位运算符</h3> 
<p><img alt="" height="590" src="https://images2.imgbox.com/bf/bb/S1Pco71x_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-java">/*
        位运算符：
            &lt;&lt;,&gt;&gt;,&gt;&gt;&gt;,&amp;,|,^,~
 */
public class OptWeiDemo{
    public static void main(String[] args) {
        byte a = 3;
        byte b = 4;
        System.out.println(a&amp;b);
        System.out.println(a|b);
        System.out.println(a^b);
        System.out.println(~a); //-4
    }
}
/*
        由于数据在计算机中参与运算的都是补码，而想要知道补码，就得知道反码，原码，就得求出二进制
        3的二进制：00000011
        4的二进制：00000100
        又由于3和4都是正数
        3的补码：00000011
        4的补码：00000100

        &amp; 运算：有0则0
            00000011
         &amp;
            00000100
        ---------------
            00000000

        结果是 ： 0

        ====================================

        | 运算：有1则1
            00000011
         |
            00000100
        --------------
            00000111

        结果是：7

        ====================================

        ^ 运算：相同则0，不同则1
            00000011
         ^
            00000100
        --------------
            00000111

        结果是：7

        ====================================

        ~ 运算：1变成0，0变成1
            00000011
        ~
        -------------
        补码：     11111100
        已知补码求原码：
        反码：     11111011
        原码：     10000100

        结果是：-4

 */
</code></pre> 
<pre><code class="language-java">/*
        位运算符：
        &lt;&lt;: 左移，二进制左移，右边用0补齐,多出来的丢弃
        &gt;&gt;: 右移，最左边最高位是0用0补齐，最高位是1就用1补齐，多出来的丢弃。
        &gt;&gt;&gt;: 无符号右移，无论左边最高是0还是1，都用0补齐，多出来的丢弃。

 */
public class OptWeiDemo2 {
    public static void main(String[] args) {
        System.out.println(3&lt;&lt;2); //12 = 3*4 = 3*2^2
        System.out.println(24&gt;&gt;2); //6 = 24/(2*2)
        System.out.println(-24&gt;&gt;2);// -6
        System.out.println(-24&gt;&gt;&gt;2);//1073741818

        System.out.println(3&lt;&lt;3); // 3*2^3

    }
}

/*
       &lt;&lt;: 左移，二进制左移，右边用0补齐
       3的二进制：00000000 00000000 00000000 00000011
       由于3是正数，所以原码，反码，补码都一样
       3的补码：00000000 00000000 00000000 00000011
       左移：
            00000000 00000000 00000000 00000011
        (00)00000000 00000000 00000000 00001100   （补码）
      由于最高位是0，既是补码也是原码，所以结果是：  12

      ================================================================
      &gt;&gt;: 右移，最左边最高位是0用0补齐，最高位是1就用1补齐，多出来的丢弃。
      24的二进制：00000000 00000000 00000000 00011000
      由于24是正数，所以原码，反码，补码都一样
      24的补码：00000000 00000000 00000000 00011000
      右移：
              00000000 00000000 00000000 00011000
              0000000000 00000000 00000000 000110(00)  (补码)
      由于最高位是0，既是补码也是原码，所以结果是：6

      ================================================================
      &gt;&gt;: 右移，最左边最高位是0用0补齐，最高位是1就用1补齐，多出来的丢弃。
      -24的二进制：10000000 00000000 00000000 00011000
      已知原码求补码：
        原码：10000000 00000000 00000000 00011000
        反码：11111111 11111111 11111111 11100111
        补码：11111111 11111111 11111111 11101000
      右移：
            11111111 11111111 11111111 11101000
            1111111111 11111111 11111111 111010(00)  (补码)
      已知补码求原码：
        补码：11111111 11111111 11111111 11111010
        反码：11111111 11111111 11111111 11111001
        原码：10000000 00000000 00000000 00000110
        最终结果是：-6

        ==============================================================
        &gt;&gt;&gt;: 无符号右移，无论左边最高是0还是1，都用0补齐，多出来的丢弃。
        -24的二进制：10000000 00000000 00000000 00011000
      已知原码求补码：
        原码：10000000 00000000 00000000 00011000
        反码：11111111 11111111 11111111 11100111
        补码：11111111 11111111 11111111 11101000
        无符号右移2位：
             11111111 11111111 11111111 11101000
             0011111111 11111111 11111111 111010(00)   (补码)
        由于最高位是0，所以它的原码，反码，补码都是一样的。
        最终结果位：0011111111 11111111 11111111 111010 = 1073741818


 */
</code></pre> 
<p style="text-align:center"><img alt="" height="333" src="https://images2.imgbox.com/87/28/D5bl7aLd_o.png" width="611"></p> 
<p> <strong>面试题： </strong>请用最有效率的方式写出计算2乘以8的结果<br>      a&lt;&lt;b  ==  a*2^b</p> 
<p>     a&gt;&gt;b  ==  a/2^b</p> 
<pre><code class="language-java">/*错误答案：System.out.println(2*8);

  正确答案：System.out.println(2&lt;&lt;3);
*/</code></pre> 
<hr id="hr-toc">
<p>                                                                                                                             <em>  --2022.1.4</em></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>