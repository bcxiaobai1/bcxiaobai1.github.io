<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>合约广告平台架构演进实践 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">合约广告平台架构演进实践</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p><img src="https://images2.imgbox.com/2d/2f/SX1xPuNp_o.png" alt="在这里插入图片描述"></p> 
<p>作者 | 王悦凯</p> 
<blockquote> 
 <p>导读</p> 
 <p>从事B端业务系统研发多年，不免会有这样的思考：B端系统的技术挑战是什么？什么样的业务架构算好架构？本文结合百度合约广告业务的发展历程，介绍广告投放平台从单体架构到微服务架构演进过程中碰到的问题和思考。希望通过本文的介绍，让大家更全面的理解B端系统的技术挑战。</p> 
 <p><em>全文11653字，预计阅读时间30分钟。</em></p> 
</blockquote> 
<h2>
<a id="_16"></a><strong>一、背景</strong>
</h2> 
<h3>
<a id="11__18"></a><strong>1.1</strong> <strong>合约广告概念</strong>
</h3> 
<p>合约广告相比竞价广告，最大的特点是预先约定好广告价格，即价格是预先确定的。基于这样的特点，合约广告的投放流程大致可以概括为四个步骤：询价 -&gt; 下单 -&gt; 投放 -&gt; 结算。</p> 
<ol>
<li> <p>询价，销售根据客户的营销目标选择合适的营销产品，并提交具体的投放定向和时长，系统结合销售政策，自动计算产出各资源价格</p> </li>
<li> <p>下单，客户按照 1 中的报价结果，确认需要购买的资源和具体的付款方式，完成下单后生成订单，每个订单的金额是确认的</p> </li>
<li> <p>投放，2 中的订单完成审批后，系统按照事先约定的价格进行广告投放，客户在投中可通过系统进行投放和创意的管理，并可以实时获取投放数据</p> </li>
<li> <p>结算，合约广告按照投放模式分为按时间计费和展现量计费，两种计费方式的频次都是天，最终实现在投放周期内逐步地扣除订单全部金额。按天结算是对已产生投放部分的权益保障，毕竟合约广告存在更改甚至退款的场景。</p> </li>
</ol> 
<p>通常来说，合约广告这种广告采买方式更适合品牌展示类广告，效果类广告更多会采用实时竞价。相比竞价广告，合约广告在业务流程上更重投前。下面结合品牌广告业务发展的三个阶段，介绍下投放平台的变化历程。</p> 
<h3>
<a id="12__35"></a><strong>1.2 业务发展</strong>
</h3> 
<h4>
<a id="_37"></a><strong>第一阶段，品牌广告业务高速发展期</strong>
</h4> 
<p>2011年，品牌专区产品开始平台化售卖，并逐步建立品牌投放平台：锦囊。在2013-2018 6年间，品牌业务高速发展，诞生了Ax、Bx、Cx等10+条产品线，虽然锦囊平台做为投放的统一入口，但各产品线的投放能力仍旧是独立建设，拥有各自的独立投放平台。在这种模式下，快速灵活地应对了市场的变化和需求，但同时也造成了投放平台多，业务流程割裂的问题。</p> 
<h4>
<a id="_43"></a><strong>第二阶段，寻求产品整合和流程统一</strong>
</h4> 
<p>2019年开始尝试对合约类平台进行整合，统一各产品售卖流程，包括产品线关停并转、投放平台融合、账户统一、资金池统一、标准化下单等项目。逐步落地合约广告一站式平台的建设 - 天启平台，真正实现合约广告的标准化投放流程，提升规模化投放效率，支撑业务发展。在这个阶段，各广告的投放平台入口逐步收敛，实现了操作入口的统一。</p> 
<h4>
<a id="_49"></a><strong>第三阶段，满足复杂营销场景，整合营销</strong>
</h4> 
<p>随着合约整合售卖（根据营销场景选择不同广告产品的组合售卖方案，即同一个合同下可下单多类广告，并享有对应的优惠政策）整体趋势的加速增长，原本非标断点式的支持方式已经无法满足业务的增长，平台化的解决方案是整合售卖规模化的必要条件。从2021年Q3起正式启动，天启平台正式定位：统一的合约产品整合售卖平台，满足从简单场景到复杂营销场景的全投放链路服务能力。从技术视角看，旨在通过一个平台（天启），实现多资源广告售卖场景下的统一，包括一个流程、一套账户、一套资金体系、一套投放表达。</p> 
<h3>
<a id="13__55"></a><strong>1.3 架构演进</strong>
</h3> 
<p>对应上述业务发展的三个阶段，合约平台的技术架构也经历了多个版本的演进，浓缩后，可以概括为2大类，2019年前的单体架构和之后的微服务架构。</p> 
<h4>
<a id="_61"></a><strong>单体架构</strong>
</h4> 
<p>2019年前的单体架构（简称『1.0架构』）图如下所示，整体上分三层，1）统一入口层，提供用户权限管理功能；2）各类广告投放平台独立建设，服务独立部署；3）抽象并沉淀基础工具库，避免各投放平台的重复开发。</p> 
<p><img src="https://images2.imgbox.com/8e/0d/jHmgjM6W_o.png" alt="在这里插入图片描述"><br> <em><strong>△1.0 烟囱式架构</strong></em></p> 
<p>品牌 1.0 架构本质是一个<strong>烟囱式架构</strong>，各产品线通过独立平台进行投放，开发、测试、上线互不影响，都能做到产品线维度的隔离，包括开发规范和迭代周期。这种架构配合当时品牌团队的组织架构，在品牌产品野蛮式生长的初期起到了很重要的作用，成功孵化了一些创新产品。但是烟囱式架构一个很大的弊端就是『信息孤岛』，随着业务的发展，各投放平台发散式迭代，逐步形成了一个一个的孤岛。从技术视角看，各平台大流程相似，但在实现细节上都不同，更严重的是，存在大量的重复性建设工作，从维护成本和人效上都有很大的优化空间。从业务视角看，各产品的打法也是各自为阵，横向缺少联动，没有形成1+1&gt;2的局面，缺少整体视角的规划。</p> 
<h4>
<a id="_73"></a><strong>微服务架构</strong>
</h4> 
<p>业务方面，合约广告场景化营销和精细化服务的需求显著；团队方面，各合约类广告平台深度融合，孤岛边界逐步打破。原本烟囱式架构无论在业务复杂度的应对，还是服务稳定性及质量的保障，亦或是研发效能的提升，都已经遇到了瓶颈。基于软件设计的最大目标：『<strong>设计符合业务的构造定律的演进方式，一种可以以最小的开发维护成本， 使业务更快更好的流动发展的方式</strong>』，19年后，合约平台架构逐步向微服务架构演进，以领域驱动设计为准则，按照合约广告的领域模型划分微服务，构建了业务前台、业务中台、技术组件、基础设施的四层业务架构。另外，基于消息机制解耦各服务，辅以组装式业务流程的理念，拆解各种繁杂的业务流程，抽象并沉淀系统的 meta feature，灵活构造多种差异化的业务解决方案，提升系统的『可玩性』，从架构层面管理了系统风险和业务复杂度（<strong>百级别</strong>不同类型的售卖和投放场景）。</p> 
<p>说到这，有些人会有疑问，对于品牌业务，微服务架构演进是否是必须的呢？是否存在过度设计？</p> 
<p>当然，假如不考虑性能、健壮性、可移植性、可修改性、开发成本、时间约束等因素，用任何的架构、任何的方法，系统的功能总是可以实现的，项目总是能开发完成的，只是开发时间、以后的维护成本、功能扩展的容易程度不同。从后验来看（包括系统可用性、扩展性、灵活性三方面），采用微服务架构的决策是正确的，或者说利远大于弊。</p> 
<p>在架构的演进过程中遇到了很多技术挑战，后面的内容重点挑了几个方面进行详细阐述。</p> 
<h2>
<a id="_85"></a><strong>二、技术实现</strong>
</h2> 
<h3>
<a id="21__87"></a><strong>2.1 服务架构</strong>
</h3> 
<p>首先，整体看下合约广告平台的微服务架构，如下图：<br> <img src="https://images2.imgbox.com/04/f2/0cPw8RLK_o.png" alt="在这里插入图片描述"><br> <em><strong>△合约广告平台微服务架构</strong></em></p> 
<p>总共分为四层，业务前台、业务中台、技术组件（PAAS）、基础设施（IAAS）。</p> 
<ol><li>
<strong>业务前台</strong>，总共分三个模块，天启平台、运营平台、业务前台。</li></ol> 
<ul>
<li> <p><strong>天启平台</strong>：面向广告主，提供合约广告询价、资源预订、资源下单、投放设置、物料制作等核心能力，支持品专矩阵、展示矩阵、品牌全景3大类产品矩阵，多达300+广告资源的售卖。</p> </li>
<li> <p><strong>运营平台</strong>：面向销售和内部运营，帮助他们精细化运营广告售卖各阶段，目前售中的投放干预和运营管控能力建设相对完善，在开屏大促和品牌广告日常运营工作中大幅提升操作的效率和安全性，让原本一些『非标』操作通过平台能力让运营实现自助化。</p> </li>
<li> <p><strong>业务前台</strong>：主要两个作用，1）对天启平台和运营平台的公共部分进行抽象并下沉，避免重复的业务逻辑和流程散布在两个模块，减少开发和运维成本；2) 对各业务中台的公共部分进行上抽，统一沉淀至此模块，比如批量处理，让各业务中台的职责更加纯粹，关注自己领域的建模。另外，针对跨多中台的读写逻辑也统一在这一层实现，起到业务流程编排的作用。</p> </li>
</ul> 
<ol start="2">
<li> <p><strong>业务中台</strong>，按照合约广告的业务流程和领域知识，划分各业务服务，总共分为9个业务中心和2个技术中心，每个业务中心都围绕特定的业务领域展开，业务边界非常明确。需要注意的是，9大业务中心仅仅是从业务视角进行定义和划分，并不代表每个中心就只有一个服务。基于技术架构和业务职责，每个业务中心可以继续划分为多个模块，例如投放中心又被划分为 检索适配服务、物料审核服务、实验投放服务等。另外，服务之间严格划定上下游关系（按照响应数据流向定义上下游概念），下游服务可以调用上游服务，上游服务严禁调用下游服务，上游服务的变更对下游服务产生影响必须通过领域事件（异步）的方式来实现，避免服务循环依赖（在服务治理章节中会展开介绍）。因此在整体系统中大量采用异步消息的方式，将业务实体的状态变更视为事件，驱动上游服务，虽然增加了测试阶段的复杂度，但是有效保障了服务间关系的有序性。</p> </li>
<li> <p><strong>技术组件</strong>，微服务架构后，各模块的代码库也是独立的，对于一些公共能力，如何能够让各服务低成本、无门槛的接入，从而达到统一各模块业务解决方案的目标，减缓业务架构的腐化和熵增。鉴于此，通过 springboot starter 的方式构建了品牌团队的业务中间件 brand-starters，成功收敛了30+模块的实现细节，在系统稳定性和架构健康度方面做出巨大贡献，包括消息发送和消费、异步事件处理、异常报警、分布式锁、分级缓存、常用工具及辅助类等。</p> </li>
<li> <p><strong>基础设施</strong>，主要指部门级别的基础设施和中台，比如微服务解决方案 ，包括RPC框架、注册中心、全链路追踪、服务网关、虚拟化容器部署、FAAS。</p> </li>
</ol> 
<h3>
<a id="22__115"></a><strong>2.2 模块结构</strong>
</h3> 
<p>上一节从整体视角介绍了合约广告平台的业务架构，这节从微观视角介绍每个中台的业务架构。各业务中台采用多模块的代码结构，具体模块划分如下：</p> 
<p><img src="https://images2.imgbox.com/c6/6c/XgvKQoTE_o.png" alt="在这里插入图片描述"><br> 各模块的依赖关系如下：</p> 
<p><img src="https://images2.imgbox.com/c1/fa/P5H0ccbV_o.png" alt="在这里插入图片描述"><br> <em><strong>△模块结构</strong></em></p> 
<p>值得注意的是：</p> 
<ol>
<li> <p>各模块间的依赖关系，demo-web、demo-task、demo-consumer 做为顶层模块，非常薄，这一层的主要作用是<strong>独立发布及部署，实现应用级别的隔离</strong>。顶层模块调用 demo-app，app模块作为服务的实现，存放了各个业务的实现类，主要分command和query（CQRS 理念）。demo-app 可以调用 demo-domain，也可以调用基础设施层 demo-infrastructure，domain做为领域层主要分3块，model 领域实体，可以是充血模型（DDD的概念）；ability 领域能力，是领域对外暴露的服务能力；gateway 领域网关，主要是接口定义，这里的接口可以粗略的理解成一种SPI，也就是交给infrastructure层去实现的接口。</p> </li>
<li> <p>demo-client 是服务对外透出的 API，API 的实现存放于 demo-app 模块。出于运维考虑，或者读写分离的设计，可以方便的将需要独立部署的 API 从 app 模块上抽至顶层，做为独立模块进行流水线发布和部署。<strong>实现服务的隔离部署，同时又能获得共享同一个代码库的好处</strong>。</p> </li>
<li> <p>前面提到的domain和infrastructure层的<strong>依赖倒置</strong>，是一个非常有用的设计，进一步解耦了取数逻辑的实现。domain层依赖接口，不感知具体实现，例如 CustomerGateway 里定义了接口 getByById，要求 infrastructure 的实现类必须定义如何通过消费者Id获取消费者实体信息，而 infrastructure 层可以实现任何数据源逻辑，比如，从 MySQL 获取，从 Redis 获取，还是从外部 API 获取等等。</p> </li>
<li> <p>领域与功能的分包策略，每个模块的分包策略都遵循准则：<strong>先按照领域分包，再按照功能分包</strong>，这样做的其中一点好处是能将腐烂控制在该业务域内。比如消费者 customer 和订单 order两个领域，在 domain 模块下先分成 customer 和 order 两个包，然后再按照 model、ability、gateway 进行功能划分。假设 customer 和 order 是两个后端开发并行开发，两个人对于 dto，util 这些文件夹的命名习惯都不同，那么只会腐烂在各自的业务包下面，而不会将 dto，util，config 等文件夹放在一起，极容易引发文件冲突。</p> </li>
</ol> 
<p>通过上面的应用架构划分，统一了各业务中台的分模块和分包策略，成功降低了各模块的学习和上手成本，较好控制了业务架构和模块代码的腐化程度。同时通过顶层模块的划分，灵活实现了同一代码库多应用部署的能力，从物理层面隔离web服务、定时任务、消息消费、rpc服务，使服务具备灵活按需扩展的能力，进一步提升服务的稳定性。</p> 
<h3>
<a id="23__143"></a><strong>2.3 服务治理</strong>
</h3> 
<p>微服务架构后，服务之间的交互通过网络进行而非单体时代的内存方式，所以整体来说系统会变得更加脆弱，服务治理就是为了解决此类问题。常规的服务治理有四板斧：第一，一定要设置服务调用的超时时间；第二，要考虑重试的逻辑；第三，考虑熔断的逻辑，不要被下游拖死；第四，一定要有限流的逻辑，不要被上游打死。即超时、重试、熔断和限流。没错，这四板斧的确是服务治理中的常规手段，但在我看来，服务治理并不局限于此。我们以终为始，看看服务治理的终极目标是什么？我认为主要3个方面：<strong>服务可用性、系统可观测、架构防腐化。</strong></p> 
<h4>
<a id="_149"></a><strong>可用性</strong>
</h4> 
<p>服务可用性的建设包括系统性能优化、服务自愈和自检能力建设。</p> 
<h5>
<a id="_153"></a><strong>服务性能</strong>
</h5> 
<p><strong>1.微服务框架升级</strong></p> 
<p>服务 RPC 框架整体迁移至部门最新的云原生解决方案 gravity+starlight，取代了原先的 zookeeper+stargate。在服务性能和治理方面有了大幅提升：</p> 
<ul>
<li> <p>通信性能提升：starlight采用新版的网络通信库与更灵活的线程池模型。提升2倍通信交互性能</p> </li>
<li> <p>稳定性增强：starlight基于gravity做更高效稳定的注册中心，定制无损升级、异常实例摘除等能力。轻松赋能达标99.99%+稳定性。</p> </li>
<li> <p>跨语言能力：starlight采用设计更合理的brpc协议作为主协议，可跨语言与C++ Go等brpc服务通信。降低跨语言通信学习成本。</p> </li>
<li> <p>云原生治理：starlight+gravity支持更云原生的治理能力，接入统一控制中心增强可控性、实现灰度发布。</p> </li>
<li> <p>日志规范排查提速：规范化的日志。秒级定位超时问题、序列化失败问题</p> </li>
</ul> 
<p>迁移过程中，gravity 与 zk 双向同步服务注册信息，实现业务的平滑无感迁移。</p> 
<p><strong>2.系统性能深度优化</strong></p> 
<p>对合约广告系统进行了全面的性能盘点和优化，性能整体提升2倍，总结为如下7个优化点：</p> 
<ul>
<li> <p>单元化，对单个服务进行拆分瘦身（模块结构章节中提到的顶层模块，将定时任务、消息消费与web服务剥离），实现资源隔离，降低等待获取连接的耗时</p> </li>
<li> <p>网络传输，统一团队服务部署至北方机房，平响降低60%</p> </li>
<li> <p>循环IO，IO 包括远程服务调用和数据库操作，通过批量化改造、多线程并发的手段大幅缩短耗时</p> </li>
<li> <p>多级缓存，通过本地 + redis 构建二级缓存，大幅降低读接口耗时</p> </li>
<li> <p>异步化，对于耗时的写操作，采用eventlog组件实现异步化 + 自动重试（后面一节会详细展开），例如物料送审、批量创建投放等</p> </li>
<li> <p>慢SQL，基于业务查询场景，优化数据表索引定义</p> </li>
<li> <p>接口拆分，联合前端，对于非主干流程的耗时数据进行接口拆分，实现非阻塞请求</p> </li>
</ul> 
<h5>
<a id="_193"></a><strong>服务自愈和自检</strong>
</h5> 
<p>为了更好的保障系统的可用性，服务需要具备自愈和自检能力。服务自愈能力主要通过幂等处理 + 事件持久化 + 逻辑重试来实现，通过自愈能力的建设，可以大幅降低微服务架构升级后带来的 IO 通信不稳定问题，同时让系统对性能和稳定性较差的外部服务有更好的容忍性，有效提升系统的整体可用性。系统的自愈能力主要解决的是『偶发性』技术问题，比如网络抖动导致的远程调用失败、事务并发导致的乐观锁冲突等，对于代码bug、业务逻辑错误、数据不一致等问题无能为力。所以除了自愈能力，服务还需要具备自检能力，能够将错误自动检测出来，并及时通知到对应人员进行处理。</p> 
<p>服务的幂等处理这里简单提一下，不做过多展开，主要有几种方案：</p> 
<ol>
<li> <p>数据库唯一键，通过数据库的约束实现新增和删除操作的幂等。</p> </li>
<li> <p>数据库乐观锁，通过增加额外字段（版本号）实现更新操作的幂等。</p> </li>
<li> <p>防重token令牌，调用方在调用接口的时候先向后端请求一个全局ID做为token，后续请求的时候都带有此token（建议放到 Headers 中），可以解决客户端连续点击或者调用方超时重试等情况，适用于新增、更新和删除操作</p> </li>
<li> <p>下游传递唯一序列号，与3不同的是，这个唯一序列号由调用方生成，生成方式可以是无业务含义的全局ID，也可以是带有业务含义的ID，比如订单行ID。服务方通过此ID记录进行存在和不存在的操作（结合redis实现操作的记录），适用于新增、更新和删除操作</p> </li>
</ol> 
<h6>
<a id="__eventlog__208"></a><strong>自愈能力 - eventlog 基础组件</strong>
</h6> 
<p>利用 springboot-starter 机制沉淀 eventlog 基础组件，让业务方低成本接入，使服务具备自愈能力。组件整体架构图如下：</p> 
<p><img src="https://images2.imgbox.com/9f/ab/NoBLOOeu_o.png" alt="在这里插入图片描述"><br> <em><strong>△eventlog 基础组件</strong></em></p> 
<p>步骤1是同步持久化事件，由业务方引入组件后调用现成方法实现；步骤2是异步消费处理事件，整体处理流程采用模板模式+ 策略模式，通过模板模式实现处理流程的业务编排，对事件处理前、中、后都设置扩展点，兼顾业务模块的接入成本和扩展灵活度。事件处理采用策略模式，将事件类型做为策略路由，实现各类事件处理的互相隔离和高扩展性。另外通过可视化配置（amis配置，即爱速搭，低代码前端页面搭建平台），统一监控事件日志表，对超时处理的事件进行报警、清理等操作。</p> 
<p>事件日志实体模型采用 event_type + biz_code 的二级模型，event_type 唯一标识了一类事件，是事件处理时的策略路由key，biz_code 由业务方自定义，用来唯一标识某类实体。attach是扩展字段，供业务方自定义，attach不宜过大，如果过大，建议通过biz_code后反查业务数据。</p> 
<h6>
<a id="___220"></a><strong>自检能力 - 核检中心</strong>
</h6> 
<p>服务的自检能力主要通过核检中心来实现，核检中心功能上分两部分，核检任务 + 消息中心。核检任务按业务场景对数据进行核对校验，解决微服务架构后分布式事务造成的数据不一致，同时，端到端的核检也可以做为在线监控，第一时间感知系统bug；然后通过消息中心将异常通知到对应人员。同时，面对大量的报警信息（系统错误、数据一致性、业务正确性等），消息中心做为统一的管理端，提供了按场景分组报警、历史报警信息查询、报警优先级设定、误报热屏蔽、报警群进组热修改等功能，提升监控的有效性和处理效率。</p> 
<p>核检中心整体模块图如下：</p> 
<p><img src="https://images2.imgbox.com/59/41/QNifhtpc_o.png" alt="在这里插入图片描述"><br> <em><strong>△核检中心模块图</strong></em></p> 
<ul>
<li> <p>应用层，两块主要功能，客户端接入和可视化管理。</p> </li>
<li> <p>客户端接入，对于 springboot 应用，和 eventlog 组件相同，通过引入starter，低成本实现报警消息的通知（声明式注解和命令式sdk两种方式）。</p> </li>
<li> <p>可视化管理，通过消息中心控制台，将散布的核检任务进行收拢，大幅提升日程维护效率。同时对于历史消息，可以进行查询，做到消息的可回溯和追踪。</p> </li>
<li> <p>能力层，对应核检中心服务端，整体模块结构遵循上述提到的 COLA，并使用CQRS和事件驱动的设计理念，提升模块的可用性。在消息发送事件的处理模块中，采用策略模式实现多种类型的消息发送，大幅提升模块扩展性，遵循开闭原则。</p> </li>
<li> <p>实体层，按照十亿级别数据量进行模型设计和数据库选型。在实体设计中，抽象消息场景的业务概念，较好的聚合了一类共同特征的消息，『共同特征』完全交由业务方定义，很好的平衡了业务灵活性和消息可管理。在数据库选型方面，采用部门开源解决方案BaikalDB（一个分布式可扩展的HTAP存储系统，采用类spanner的架构，支持PB级结构化数据的随机实时读写）。</p> </li>
</ul> 
<h4>
<a id="_246"></a><strong>可观测</strong>
</h4> 
<p>系统的可观测程度也是服务治理的一个非常重要目标。提到服务的可观测性，大家容易想到的一般都是：微服务调用关系（拓扑图呈现）、接口性能（各种分位值指标，性能优化利器）、系统异常（各种监控配置）、资源利用率、日志链路追踪（线上排查必不可少）等，这部分主要依托于部门的微服务解决方案 Jarvis平台实现，所以在这里不做过多介绍，这里主要想介绍的服务可观测主要是指上层业务应用。</p> 
<blockquote> 
 <p>企业级微服务解决方案Jarvis是商业平台部基础技术团队研发的面向复杂业务系统的应用托管平台，为商业应用提供高可用和分布式的微服务架构解决方案。Jarvis提供了一系列强大的功能，充分利用百度资源虚拟化能力，提供分布式服务框架、服务治理、统一配置管理、分布式链路跟踪、容量规划、高可用及数据化运营等功能。</p> 
</blockquote> 
<p>前面其实已经提到过，合约广告的整体业务链路比较长，经历了售前询价 -&gt; 下单 -&gt; 合同审批 -&gt; 物料制作 -&gt; 投放 -&gt; 计费，每个环节都可能成为广告投放的卡点，如果出现问题，比如流程阻塞，如何能够快速定位问题，甚至提前感知问题，做到整个流程的透明化、可观测呢？</p> 
<p>整体思路是以业务实体为中心，记录实体全生命周期的变化，当某个阶段（实体状态）停留时间超出预期，就有可能存在潜在的异常，通过服务看板和消息中心，及时通知对应的运营进行处理跟进。通过追踪业务实体的生命周期，实现系统业务流程的可观测性，为后续流程优化、业务提效提供数据分析基础。</p> 
<p>业务实体生命周期的追踪实现方案主要如下图：</p> 
<p><img src="https://images2.imgbox.com/ff/a2/f0Sj1J39_o.png" alt="在这里插入图片描述"><br> <em><strong>△业务实体生命周期追踪</strong></em></p> 
<p>总结来说就是三种方案：</p> 
<ol>
<li> <p>通过订阅 mysql binlong，监控业务实体的核心状态字段（对应部门已有解决方案 WATT），一旦字段变更就会触发增量消息，服务端消费后持久化，再以服务看板的形式对外呈现。这种方式的优势是对业务模块无侵入，劣势是依赖业务模块的数据库设计，另外有些实体的生命周期并不一定体现在数据表的字段变更，无法通过订阅 binglog 的方式感知</p> </li>
<li> <p>通过日志打印 -&gt; 采集 -&gt; 解析的方式实现实体全生命周期的追踪。这个方式的优势是百度已有一整套现成的解决方案，可以直接复用；劣势是需要侵入业务代码，按照规范打印日志，同时日志采集和解析的配置门槛较高，调试较困难，不容易上手</p> </li>
<li> <p>提供用于追踪实体生命周期的埋点 sdk，在需要监控的地方埋点。这个方式的优势是灵活度非常高，可以实现任何追踪需求；劣势是侵入业务代码，需要业务模块显式进行调用</p> </li>
</ol> 
<p>最终我们采用了 1 和 3，业务实体的追踪主要通过方案 3来实现埋点，一些额外辅助信息通过 方案 1 进行同步。</p> 
<h4>
<a id="_277"></a><strong>防腐化</strong>
</h4> 
<p>很多科学家提到的熵增定律非常好的揭示了自然现象的本质：任何孤立系统，在没有外力作用的情况下，其总混乱度（熵）会不断增大。当然软件系统也是如此，随着软件系统的功能不断增加，系统的混乱度也在不断增大。为了降低软件系统混乱的速度，必须要对其施以外力。那么这里的『外力』可以从哪些角度入手呢？</p> 
<ol>
<li> <p>分析每个应用的修改频次，哪些应用频繁修改，哪些应用相对稳定。对于频繁修改的应用，是否引起修改的业务需求是相同的。那么这些大概率绑定在一起修改的服务被拆分在不同的应用，是否是不合理的，值得进一步商榷。如果一个应用，无论什么需求都需要升级，那么这个应用是否已经足够小，是否需要进一步拆分，剥离变与不变，将不变的部分进行抽离和沉淀？</p> </li>
<li> <p>定期观察每个服务的调用情况，包括次数、性能和拓扑。是否存在一些冗余服务可以清理？是否存在一些服务性能呈现恶化趋势，需要及时介入优化？是否存在某些业务流程中存在重复调用的情况？如果有，需要制定计划进行治理，否则就会成立历史债务，让业务架构逐步腐化。</p> </li>
<li> <p>需要定期去扫描检查应用代码，包括重复逻辑是否散布于多个应用、是否存在不规范的代码逻辑（每个团队根据实践总结沉淀，比如 枚举类的使用、IO 循环调用等）、是否存在冗余代码需要清理、模块结构和分包策略是否符合规范</p> </li>
<li> <p>定期的CR各应用代码，是否存在跨领域的逻辑，比如报价中心处理了订单中心的逻辑（非报价域的逻辑），导致微服务的划分边界模糊</p> </li>
</ol> 
<p>防腐化这块工作其实很重要，目前也还处于初级的摸索阶段，需要进一步结合业务实际，沉淀最佳实践。这里先以微服务循环依赖治理为例，做个简单介绍。</p> 
<p>当微服务中的循环依赖形成闭环后会造成2类主要危害：</p> 
<ol>
<li> <p>服务间强耦合导致各服务很难独立部署，违反了微服务『自治与隔离』的设计初衷，最终微服务架构会逐步演变为『分布式大单体』，失去了微服务架构演进的意义。</p> </li>
<li> <p>循环依赖可能会导致一些循环调用或并发问题，造成一些复杂难以定位的问题，下面以用户中心和订单中心为例来说明</p> </li>
</ol> 
<p><img src="https://images2.imgbox.com/34/74/VJpqwpMU_o.png" alt="在这里插入图片描述"><br> <em><strong>△循环依赖导致的并发问题</strong></em></p> 
<p>上述图中有两个服务，订单和用户中心，蓝色箭头表示订单中心对外提供的服务 ，实现订单状态更新，其中会调用用户服务更新客户状态，标记此客户已有下单记录。红色箭头表示用户中心调用订单中心，用户服务在标记完客户状态后反过来会调用订单服务，持久化订单上客户信息。上述调用形成了闭环，最终会引起订单数据库中的版本冲突，导致更新失败。那么如何避免这种循环依赖呢？总结以下几个准则：</p> 
<ol>
<li> <p>明确服务边界和定位，划分上下游服务，下游服务可以调用上游服务，但是上游服务不能依赖下游，如果要进行通信，采用领域事件的方式，比如消息通知。</p> </li>
<li> <p>数据不要过多冗余，尽量通过数据 id（能够唯一代表数据且不变的属性）来进行关联，即只存引用。</p> </li>
<li> <p>如果存在必须要通过上游服务同步调用下游服务才能完成的功能，得反思是否上游服务缺少了相应的业务域。如果不是，可以借业务前台来实现各服务的调用编排，或者肯能存在微服务拆分不合理，这种场景需要重新规划，拆分出一个更上游的服务供调用。</p> </li>
</ol> 
<p>回到刚才的实际例子，治理方案是采用领域事件的改造方式，订单服务是下游服务，用户服务是上游服务，用户服务更新订单客户信息从同步调用方式改为消息通知，不感知具体的订阅方，实现解耦。</p> 
<h3>
<a id="24__316"></a><strong>2.4 服务迭代</strong>
</h3> 
<p>微服务架构改造后，原来单体架构的迭代方式已经不再适用，我们看一个实际例子：</p> 
<p><img src="https://images2.imgbox.com/62/46/sXHst3gT_o.png" alt="在这里插入图片描述"></p> 
<p>从上述例子中可以看到，微服务架构后，一个业务需求会涉及多个模块，复杂度不尽相同，如果中台服务的每个升级无法做到向前兼容，那么势必会导致需求间的耦合，一旦并行开发的分支增多，因模块间的耦合导致的整体回滚概率将会指数级增长。仍旧是上述这个例子，如果需求1中的中台B有BUG，需要回滚，那么是否导致需求2中的所有模块都要回滚，包括中台D，即使它的改动点非常小。</p> 
<p>总结以下，造成上述局面的2个主要原因：</p> 
<ol>
<li> <p>迭代升级的视角只有需求维度，中台服务被割裂，缺少另一个以中台为主的视角</p> </li>
<li> <p>自动化测试能力不足，过度依赖黑盒测试会导致风险后置</p> </li>
</ol> 
<p>针对这两个问题，我们的解法主要有3个方向：</p> 
<ol>
<li> <p>规范需求迭代流程，强化以中台为轴的虚拟团队。</p> </li>
<li> <p>从需求评审、技术详设、开发、联调、测试到上线，制定详细的全流程规范，保障团队有序运转。同时，强调各中台的自治，迭代升级必须做到向前兼容，依赖模块的回滚不影响自身的上线计划，反复强调容错、兼容、演进式的设计理念。</p> </li>
<li> <p>加强自动化测试能力，达到自动准出标准。自动化测试能力包括各模块的单测和集成测试。模块单测通过插件集成至流水线，对于没有达到覆盖率的代码禁止合入，特殊情况下，可以说明理由，让模块负责人豁免。集成测试从业务前台出发，按照业务场景优先级逐步建设，触发方式分为每日例行任务和回归测试时的手动触发。</p> </li>
<li> <p>提供服务 mock 能力，在合适的场景下可以解耦对其他服务的依赖。落地联调中心，实现服务级别的动态 mock 能力，并通过 starter 方式让业务模块低成本接入。整体设计分为两部分，client端和server端，如下图：</p> </li>
</ol> 
<p><img src="https://images2.imgbox.com/10/ea/DO96s9XH_o.png" alt="在这里插入图片描述"></p> 
<p><em><strong>△mock 中心</strong></em></p> 
<p>其中，服务端的可视化 mock 规则配置支持动态规则，对于一些无法用动态规则描述的需求也可以通过低成本的代码开发实现定制化逻辑。</p> 
<p>最终期望能够让每个中台服务达到『自治与隔离』，从而解耦各需求点的上线，如下图：</p> 
<p><img src="https://images2.imgbox.com/f5/a9/pG0VfqEC_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到，上线粒度从需求维度细化到了中台 fetaure，使整体交付风险指数级下降。当然，对于微服务架构系统，如何做到高效联调和测试仍是一个正在不断探索的方向。</p> 
<h2>
<a id="_358"></a><strong>三、总结</strong>
</h2> 
<p>本文主要介绍了合约广告微服务架构演进中的一些最佳实践，做一个简单的总结。</p> 
<ol>
<li> <p><strong>服务拆分</strong>：从实际业务出发，基于领域驱动模型的理念，建立合适的业务模型。这部分一定要深入业务细节，理解业务运转原理，抽象出业务本质。通过合理服务拆分，可以更高效地解决复杂业务问题，如果将7个业务中台类比为正交的坐标轴，那么原来低维的复杂问题（单体架构）投射到高维后（微服务架构），大概率会变得没那么复杂；另外，对于本质业务复杂度问题，通过服务拆分，可以很好的将复杂性隔离至对应领域服务，更好地管理复杂度，防止外溢。</p> </li>
<li> <p><strong>模块结构</strong>：借鉴COLA架构，结合实际情况，制定规范，其中包含了多种设计理念：DDD、事件驱动模式、CQRS模式、依赖倒置。相比服务拆分，模块结构是从微观视角制定各微服务的代码组织，减缓腐化速度。</p> </li>
<li> <p><strong>服务治理</strong>：总结了系统性能、业务可观测性和防腐化三个方面的一些心得和最佳实践，在我看来，一个好的业务架构，能够很好的管控业务复杂度，甄别业务中的『变』和『不变』。所以，定期梳理分析各服务的升级频率、调用关系等是非常重要的。</p> </li>
<li> <p><strong>服务迭代</strong>：服务及架构的迭代需要平滑有序，做到容错、兼容、演进式，避免大量应用改造。同时各微服务要做到自治与隔离，降低相互之间的耦合，做到在架构演进过程中每个服务都能顺利地『死去』与『重生』，就像生物进化一样。（本文多次提到的领域事件方式是降低服务耦合的有效手段）</p> </li>
</ol> 
<p>所以回到本文开头的2个问题，B端系统最大的技术挑战我认为是<strong>业务复杂度的治理</strong>，通过合适的技术选型在赋能业务的同时又能很好地管控技术和业务复杂度。我心目中好的业务架构标准就是<strong>提升效率</strong>，这里的效率包括交付效率、运维效率以及演进效率。</p> 
<p>最后想说：没有完美的业务架构，贴合业务实际的就是好架构，一个好的业务架构一定是结合业务实际演进而来的。</p> 
<p><strong>————END————</strong></p> 
<p><strong>推荐阅读</strong>：</p> 
<p><a href="https://mp.weixin.qq.com/s/BSg3Y2b7rm_pZxL9U0kCDg">AI技术在基于风险测试模式转型中的应用</a></p> 
<p><a href="https://mp.weixin.qq.com/s/VS7DZg9qb_QmqAKqm_zc-Q">Go语言躲坑经验总结</a></p> 
<p><a href="https://mp.weixin.qq.com/s/o-ZoRnAMnINGHVALj7DQRA">PaddleBox：百度基于GPU的超大规模离散DNN模型训练解决方案</a></p> 
<p><a href="https://mp.weixin.qq.com/s/CXFB337vdq8NuDTrjzCxmw">聊聊机器如何"写"好广告文案?</a></p> 
<p><a href="https://mp.weixin.qq.com/s/a2uPFEqtpHN5djZudQ_6sA">百度工程师教你玩转设计模式（适配器模式）</a></p> 
<p><a href="https://mp.weixin.qq.com/s/iSSjQq1PL4G18Cu6xdfpOA">百度搜索业务交付无人值守实践与探索</a></p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>