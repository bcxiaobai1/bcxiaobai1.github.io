<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>机器学习中的七种分类算法 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习中的七种分类算法</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p><a class="link-info has-card" href="https://www.projectpro.io/article/7-types-of-classification-algorithms-in-machine-learning/435" title="c 机器学习中的 7 种分类算法https://www.projectpro.io/article/7-types-of-classification-algorithms-in-machine-learning/435https://www.projectpro.io/article/7-types-of-classification-algorithms-in-machine-learning/435"><span class="link-card-box"><span class="link-title">c 机器学习中的 7 种分类算法https://www.projectpro.io/article/7-types-of-classification-algorithms-in-machine-learning/435https://www.projectpro.io/article/7-types-of-classification-algorithms-in-machine-learning/435</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/73/1f/lsMvp56U_o.png" alt="icon-default.png?t=LA92">https://www.projectpro.io/article/7-types-of-classification-algorithms-in-machine-learning/435</span></span></a>以上为参考链接。</p> 
<hr>
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%20%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px"><a href="#1%20%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B" title="1 分类任务的类型">1 分类任务的类型</a></p> 
<p id="1.1%20%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#1.1%20%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB" title="1.1 二元分类">1.1 二元分类</a></p> 
<p id="1.2%20%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#1.2%20%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB" title="1.2 多元分类">1.2 多元分类</a></p> 
<p id="1.3%20%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#1.3%20%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB" title="1.3 多标签分类">1.3 多标签分类</a></p> 
<p id="1.4%20%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%88%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#1.4%20%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%88%86%E7%B1%BB" title="1.4 不平衡分类">1.4 不平衡分类</a></p> 
<p id="2%20%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C-toc" style="margin-left:0px"><a href="#2%20%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C" title="2 分类算法如何工作">2 分类算法如何工作</a></p> 
<p id="3%20%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86-toc" style="margin-left:0px"><a href="#3%20%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86" title="3 数据预处理">3 数据预处理</a></p> 
<p id="4%20%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%9B%86%E5%92%8C%E8%AE%AD%E7%BB%83%E9%9B%86-toc" style="margin-left:0px"><a href="#4%20%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%9B%86%E5%92%8C%E8%AE%AD%E7%BB%83%E9%9B%86" title="4 创建测试集和训练集">4 创建测试集和训练集</a></p> 
<p id="5%20%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px"><a href="#5%20%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B" title="5 选择模型">5 选择模型</a></p> 
<p id="3%20%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px"><a href="#3%20%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B" title="6 分类算法的类型">6 分类算法的类型</a></p> 
<p id="6.1%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8-toc" style="margin-left:40px"><a href="#6.1%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8" title="6.1 朴素贝叶斯分类器">6.1 朴素贝叶斯分类器</a></p> 
<p id="6.1.1%20%E4%BC%98%E7%82%B9-toc" style="margin-left:80px"><a href="#6.1.1%20%E4%BC%98%E7%82%B9" title="6.1.1 优点">6.1.1 优点</a></p> 
<p id="6.1.2%20%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px"><a href="#6.1.2%20%E7%BC%BA%E7%82%B9" title="6.1.2 缺点">6.1.2 缺点</a></p> 
<p id="6.1.3%20%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#6.1.3%20%E5%BA%94%E7%94%A8" title="6.1.3 应用">6.1.3 应用</a></p> 
<p id="6.2%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-toc" style="margin-left:40px"><a href="#6.2%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92" title="6.2 逻辑回归">6.2 逻辑回归</a></p> 
<p id="6.2.1%20%E4%BC%98%E7%82%B9-toc" style="margin-left:80px"><a href="#6.2.1%20%E4%BC%98%E7%82%B9" title="6.2.1 优点">6.2.1 优点</a></p> 
<p id="6.2.2%20%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px"><a href="#6.2.2%20%E7%BC%BA%E7%82%B9" title="6.2.2 缺点">6.2.2 缺点</a></p> 
<p id="6.2.3%20%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#6.2.3%20%E5%BA%94%E7%94%A8" title="6.2.3 应用">6.2.3 应用</a></p> 
<p id="6.3%20%E5%86%B3%E7%AD%96%E6%A0%91%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95-toc" style="margin-left:40px"><a href="#6.3%20%E5%86%B3%E7%AD%96%E6%A0%91%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95" title="6.3 决策树分类算法">6.3 决策树分类算法</a></p> 
<p id="6.3.1%20%E4%BC%98%E7%82%B9-toc" style="margin-left:80px"><a href="#6.3.1%20%E4%BC%98%E7%82%B9" title="6.3.1 优点">6.3.1 优点</a></p> 
<p id="6.3.2%20%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px"><a href="#6.3.2%20%E7%BC%BA%E7%82%B9" title="6.3.2 缺点">6.3.2 缺点</a></p> 
<p id="6.3.3%20%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#6.3.3%20%E5%BA%94%E7%94%A8" title="6.3.3 应用">6.3.3 应用</a></p> 
<p id="6.4%20%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95-toc" style="margin-left:40px"><a href="#6.4%20%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95" title="6.4 随机森林分类算法">6.4 随机森林分类算法</a></p> 
<p id="6.4.1%20%E4%BC%98%E7%82%B9-toc" style="margin-left:80px"><a href="#6.4.1%20%E4%BC%98%E7%82%B9" title="6.4.1 优点">6.4.1 优点</a></p> 
<p id="6.4.2%20%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px"><a href="#6.4.2%20%E7%BC%BA%E7%82%B9" title="6.4.2 缺点">6.4.2 缺点</a></p> 
<p id="6.4.3%20%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#6.4.3%20%E5%BA%94%E7%94%A8" title="6.4.3 应用">6.4.3 应用</a></p> 
<p id="6.5%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-toc" style="margin-left:40px"><a href="#6.5%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA" title="6.5 支持向量机">6.5 支持向量机</a></p> 
<p id="%C2%A06.5.1%20%E4%BC%98%E7%82%B9-toc" style="margin-left:80px"><a href="#%C2%A06.5.1%20%E4%BC%98%E7%82%B9" title=" 6.5.1 优点"> 6.5.1 优点</a></p> 
<p id="6.5.2%20%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px"><a href="#6.5.2%20%E7%BC%BA%E7%82%B9" title="6.5.2 缺点">6.5.2 缺点</a></p> 
<p id="6.5.3%20%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#6.5.3%20%E5%BA%94%E7%94%A8" title="6.5.3 应用">6.5.3 应用</a></p> 
<p id="6.6%20K%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95-toc" style="margin-left:40px"><a href="#6.6%20K%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95" title="6.6 K最近邻分类算法">6.6 K最近邻分类算法</a></p> 
<p id="%C2%A06.6.1%20%E4%BC%98%E7%82%B9-toc" style="margin-left:80px"><a href="#%C2%A06.6.1%20%E4%BC%98%E7%82%B9" title=" 6.6.1 优点"> 6.6.1 优点</a></p> 
<p id="6.6.2%20%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px"><a href="#6.6.2%20%E7%BC%BA%E7%82%B9" title="6.6.2 缺点">6.6.2 缺点</a></p> 
<p id="6.6.3%20%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#6.6.3%20%E5%BA%94%E7%94%A8" title="6.6.3 应用">6.6.3 应用</a></p> 
<p id="6.7%20K-Means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95-toc" style="margin-left:40px"><a href="#6.7%20K-Means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95" title="6.7 K-Means聚类算法">6.7 K-Means聚类算法</a></p> 
<p id="6.7.1%20%E4%BC%98%E7%82%B9-toc" style="margin-left:80px"><a href="#6.7.1%20%E4%BC%98%E7%82%B9" title="6.7.1 优点">6.7.1 优点</a></p> 
<p id="6.7.2%20%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px"><a href="#6.7.2%20%E7%BC%BA%E7%82%B9" title="6.7.2 缺点">6.7.2 缺点</a></p> 
<p id="6.7.3%20%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#6.7.3%20%E5%BA%94%E7%94%A8" title="6.7.3 应用">6.7.3 应用</a></p> 
<p id="4%20%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95-toc" style="margin-left:0px"><a href="#4%20%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95" title="7 如何决定选择哪种分类算法">7 如何决定选择哪种分类算法</a></p> 
<hr id="hr-toc">
<h1 id="1%20%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B">1 分类任务的类型</h1> 
<h2 id="1.1%20%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB">1.1 二元分类</h2> 
<p>主要将数据集分类两类，也意味着输出变量只有两个值。比如将邮件标记为“垃圾邮件”还是“非垃圾邮件”。</p> 
<h2 id="1.2%20%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB">1.2 多元分类</h2> 
<p>数据集分为多个种类，输出变量也有多个值。比如经典的Iris数据集，根据花的花瓣长度、萼片长度、花瓣宽度和萼片宽度，分成三种花。</p> 
<h2 id="1.3%20%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB">1.3 多标签分类</h2> 
<p>一种特殊类型的分类任务，对于数据集中的每个实例具有多个输出变量，也就是说，一个实例可以有多个标签。比如在图像分类中，单个的图像可能包含多个对象，这些对象可以通过算法进行标记，例如公共汽车、红绿灯、斑马线等。</p> 
<h2 id="1.4%20%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%88%86%E7%B1%BB">1.4 不平衡分类</h2> 
<p>不平衡分类是指数据集的实例中具有偏向或者偏态分布的分类问题，也就是一类输入变量的频率高于其他输入变量。比如通过交易数据集中的信用卡检测欺诈交易。通常，此类交易的数量要少得多，因此这会使机器难以学习此类交易。</p> 
<h1 id="2%20%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C">2 分类算法如何工作</h1> 
<p style="text-align:left"><span style="color:#4d5356">为了解决分类问题，我们使用称为机器学习分类算法的数学模型。他们的任务是找出目标变量如何与输入特征 xi 和输出值 yi 相关联。在数学方面，估计函数 f(xi) 通过将相关特征作为输入来预测输出变量的值。我们可以这样写，</span></p> 
<p style="text-align:center"><span style="color:#4d5356"><img alt="{y}'_{i}= text{f} left ( x_{i} right )" class="gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/39/da/Jlv0SmQE_o.gif"></span></p> 
<p></p> 
<p style="text-align:left"><span style="color:#4d5356">其中 y'i 表示输出变量的预测响应。</span></p> 
<h1 id="3%20%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86" style="text-align:left"><span style="color:#4d5356">3 数据预处理</span></h1> 
<p>在将任何统计算法应用于数据集之前，我们必须彻底了解输入变量和输出变量。在分类问题中，目标总是定性的，但有时，甚至输入值也可以是分类的，例如著名的 Mall Customer Dataset 中客户的性别。由于分类算法是从数学上推导出来的，因此必须将所有变量转换为数值。分类算法工作的第一步是确保变量，无论是输入还是输出，都已正确编码。</p> 
<h1 id="4%20%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%9B%86%E5%92%8C%E8%AE%AD%E7%BB%83%E9%9B%86">4 创建测试集和训练集</h1> 
<p>处理完数据集后，下一步是将数据集分为两部分：测试数据集和训练数据集。这一步允许使用训练数据集让我们的机器学习输入和输出值之间的模式。另一方面，测试数据集测试模型的准确性，我们将尝试将其放入我们的数据集中。</p> 
<h1 id="5%20%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B">5 选择模型</h1> 
<p>一旦我们将数据集拆分为训练和测试，下一个任务就是选择最适合我们问题的模型。为此，我们需要了解流行的分类算法。因此，让我们深入研究不同类型的分类算法池并探索我们的选择。</p> 
<h1 id="3%20%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B">6 分类算法的类型</h1> 
<p style="text-align:left"><span style="color:#4d5356">以下是您将了解的不同类型分类算法的列表：</span></p> 
<ol>
<li>朴素贝叶斯分类器</li>
<li>逻辑回归</li>
<li>决策树</li>
<li>随机森林</li>
<li>支持向量机</li>
<li>K-最近邻</li>
<li>K-均值聚类</li>
</ol>
<h2 id="6.1%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8">6.1 朴素贝叶斯分类器</h2> 
<p style="text-align:left"><span style="color:#4d5356">朴素贝叶斯分类器，最简单有效的分类算法之一。它的基础是贝叶斯定理，它描述了如何根据可能与事件相关的条件的先验知识来评估事件的概率。在数学上，这个定理指出——</span></p> 
<p style="text-align:center"><span style="color:#4d5356"><img alt="text{P}left ( Y|Xright )=frac{Pleft ( X|Yright )Pleft ( Yright )}{Pleft ( Xright )}" class="gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/3f/e8/B1XTFQ96_o.gif"></span></p> 
<p style="text-align:left"><span style="color:#4d5356">其中 P(Y|X) 是事件 Y 的概率，假设 X 已经发生。 </span></p> 
<p style="text-align:left"><span style="color:#4d5356">P(X) 是事件 X 的概率，</span></p> 
<p style="text-align:left"><span style="color:#4d5356">P(Y) 是事件 Y 的概率，</span></p> 
<p style="text-align:left"><span style="color:#4d5356">P(X|Y) 是给定 Y 的固定值时事件 X 的可能性。</span></p> 
<p style="text-align:left"><span style="color:#4d5356">如果 X 代表一个特征变量，Y 代表一个目标变量，那么贝叶斯分类器会将该标签分配给产生最高概率的特征。为简单起见，考虑一个二分类问题，其中特征变量只能有两个可能的值，Y=1 或 Y=0。然后，如果 Pr(Y=1|X=x0) &gt; 0.5，贝叶斯分类器将预测类别 1，否则预测类别 2。</span></p> 
<p style="text-align:left"><span style="color:#4d5356">在不止一个特征的情况下，我们可以使用以下公式来评估概率，</span></p> 
<p style="text-align:center"><span style="color:#4d5356"><img alt="Pleft ( Y|X_{1}=x_{1},X_{2}=x_{2} right )=frac{Pleft ( X_{1}=x_{1},X_{2} =x_{2}|Y right )Pleft ( Y right )}{Pleft ( X_{1}=x_{1},X_{2}=x_{2} right )}" class="gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/66/5e/3VZObnNU_o.gif"></span></p> 
<p style="text-align:left"><span style="color:#4d5356">我们假设两个特征 X1 和 X2 是相互独立的。事实上，由于这个假设，“朴素”这个词被附加到贝叶斯的分类器上。</span></p> 
<h3 id="6.1.1%20%E4%BC%98%E7%82%B9" style="text-align:left"><span style="color:#4d5356">6.1.1 优点</span></h3> 
<p style="text-align:left"></p> 
<ol>
<li>它很简单，实现也很简单。</li>
<li>机器使用这个分类器学习模式所需的时间更少。</li>
<li>它在输入变量具有分类值的情况下表现良好。</li>
<li>它为复杂的现实世界问题提供了良好的结果。</li>
<li>它在多类分类的情况下表现良好。</li>
</ol>
<h3 id="6.1.2%20%E7%BC%BA%E7%82%B9">6.1.2 缺点</h3> 
<ol>
<li>它假设特征变量之间的独立性，但情况并非总是如此。</li>
<li>我们经常将其称为坏估计，因此概率并不总是很重要。</li>
<li>如果在训练期间模型不知道任何分类变量并且该变量在测试期间通过，则模型分配 0（零）似然并因此替换称为“零频率”的零概率。可以通过使用平滑程序（例如拉普拉斯估计）来避免这种情况。</li>
</ol>
<h3 id="6.1.3%20%E5%BA%94%E7%94%A8">6.1.3 应用</h3> 
<ol>
<li>
<strong>垃圾邮件分类：</strong> 根据电子邮件的内容识别电子邮件是否为垃圾邮件</li>
<li>
<strong>实时预测系统：</strong> 该模型相对较快，因此可以实时预测目标变量。</li>
<li>
<strong>情绪分析：</strong> 识别产品的反馈并将其分类为“正面”或“负面”。</li>
<li>
<strong>多类预测：</strong> 朴素贝叶斯适用于多类分类问题。</li>
</ol>
<h2 id="6.2%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92">6.2 逻辑回归</h2> 
<p style="text-align:left"><span style="color:#4d5356">该算法类似于贝叶斯分类器，因为它也预测 Y 与输入变量 X 相关联的概率。它使用逻辑函数，</span></p> 
<p style="text-align:center"><span style="color:#4d5356"><img alt="large Pleft ( X right )=frac{e^{beta _{0}+beta _{1}X}}{1+e^{beta _{0}+beta _{ 1}X}}" class="gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/46/05/kzzbCrNX_o.gif"></span></p> 
<p style="text-align:left"><span style="color:#4d5356">并使用最大似然技术拟合参数 ð??›ƒ0 和 ð??›ƒ1。该技术涉及最大化由下式给出的似然函数</span></p> 
<p style="text-align:center"><span style="color:#4d5356"><img alt="lleft ( beta _{0},beta _{1} right )=prod_{l:y_{i}=1}pleft ( x_{i} right )prod_{​{l} ':y_{​{i}'}=1}left ( 1-pleft ( x_{i} right ) right )" class="gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/42/c2/OnVrxiun_o.gif"></span></p> 
<p style="text-align:left"><span style="color:#4d5356">在评估这两个参数后，可以轻松地使用逻辑函数来预测给定输入 xi 的目标变量概率 p(xi)。 </span></p> 
<p style="text-align:left"><span style="color:#4d5356">对于不止一个特征变量（X1, X2,..., XP），公式可以概括为</span></p> 
<p style="text-align:center"><span style="color:#4d5356"><img alt="Pleft ( X right )= frac{e^{beta _{0}+beta _{1}X_{1}+cdots+beta _{p}X_{p}}}{1+ {e^{beta _{0}+beta _{1}X_{1}+cdots+beta _{p}X_{p}}}" class="gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/dd/50/Q4hyAcme_o.gif"></span></p> 
<h3 id="6.2.1%20%E4%BC%98%E7%82%B9">6.2.1 优点</h3> 
<ol>
<li>这是一个简单的模型，因此训练所需的时间很少。</li>
<li>它可以处理大量的特征。</li>
</ol>
<h3 id="6.2.2%20%E7%BC%BA%E7%82%B9">6.2.2 缺点</h3> 
<ol>
<li>虽然它的名字中有回归这个词，但我们只能将它用于分类问题，因为它的范围总是在 0 和 1 之间。</li>
<li>只能用于二分类问题，对多分类问题响应较差</li>
</ol>
<h3 id="6.2.3%20%E5%BA%94%E7%94%A8">6.2.3 应用</h3> 
<ol>
<li>
<strong>信用评分：</strong> 根据年收入、账户余额等一些特征来预测个人的信用（偿还借入贷款的能力）。</li>
<li>
<strong>预测用户行为：</strong> 许多网站使用逻辑回归来预测用户行为并引导他们点击可能感兴趣的链接。</li>
<li>
<strong>离散选择分析：</strong>  逻辑回归是预测人们分类偏好的绝佳选择。这方面的例子可能是买哪辆车、上哪所学校或大学等，这取决于人们的属性和他们可用的各种选择。</li>
</ol>
<h2 id="6.3%20%E5%86%B3%E7%AD%96%E6%A0%91%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95">6.3 决策树分类算法</h2> 
<p style="text-align:left"><span style="color:#4d5356">该算法涉及根据数据集中的某些特征变量将数据集划分为多个段。这些划分的阈值通常是各自特征变量的平均值或众数（如果它们是数字）。由于树可以表示用于分割数据集的一组分割规则，因此该算法称为决策树。</span></p> 
<p style="text-align:left"><span style="color:#4d5356">查看下面的示例以更好地理解它。</span></p> 
<p style="text-align:center"><img alt="多类分类算法" class="gm-loaded gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/5e/2b/QaKAv32d_o.png"></p> 
<p style="text-align:left"><span style="color:#4d5356">红色文本表示如何根据输出变量将数据集拆分为多个段。结果是具有最高比例的班级。</span></p> 
<p style="text-align:left"><span style="color:#4d5356">现在，很自然要问的问题是该算法使用什么标准来分割数据。有两种广泛使用的度量来测试分割的纯度（如果数据集的片段只有一个类的数据点，则它是纯的）。</span></p> 
<p style="text-align:left"><span style="color:#4d5356">第一个是定义的基尼指数</span></p> 
<p style="text-align:center"><span style="color:#4d5356"><img alt="G= -sum_{k=1}^{k}p_{mk}left ( 1-p_{mk} right )" class="gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/13/a5/trWKOsOD_o.gif"></span></p> 
<p style="text-align:left"><span style="color:#4d5356">测量 N 个类别的总方差。另一种度量是交叉熵，定义为</span></p> 
<p style="text-align:center"><span style="color:#4d5356"><img alt="D= -sum_{k=1}^{k}p_{mk}log left ( p_{mk} right )" class="gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/f4/d2/EuecLI7z_o.gif"></span></p> 
<p style="text-align:left"><span style="color:#4d5356">在两个等式中，pmk 表示第 m 个片段中属于第 k 个类别的训练变量的比例。</span></p> 
<p style="text-align:left"><span style="color:#4d5356">我们根据该特征将数据集拆分为多个段，从而产生熵或基尼指数的最小值。</span></p> 
<h3 id="6.3.1%20%E4%BC%98%E7%82%B9">6.3.1 优点</h3> 
<ol>
<li>该算法允许数据的简单表示。因此，更容易向高管解释和解释它。</li>
<li>决策树模仿人类在日常生活中做出决策的方式。</li>
<li>他们顺利处理定性目标变量。</li>
<li>它们有效地处理非线性数据。</li>
</ol>
<h3 id="6.3.2%20%E7%BC%BA%E7%82%B9">6.3.2 缺点</h3> 
<ol>
<li>它们可能会创建有时变得无关紧要的复杂树。</li>
<li>与其他算法相比，它们的预测精度水平不同。</li>
</ol>
<h3 id="6.3.3%20%E5%BA%94%E7%94%A8">6.3.3 应用</h3> 
<ol>
<li>情感分析：它用作文本挖掘中的分类算法，以确定客户对产品的情感。</li>
<li>产品选择：公司可以使用决策树来了解哪种产品在推出时会给他们带来更高的利润。</li>
</ol>
<h2 id="6.4%20%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95">6.4 随机森林分类算法</h2> 
<p style="text-align:left"><span style="color:#4d5356">森林由大量的树木组成。同样，随机森林涉及处理许多决策树。每棵树预测目标变量的概率值。然后我们对产生最终输出的概率进行平均。 </span></p> 
<p style="text-align:left"><span style="color:#4d5356">我们评估每棵树如下：</span></p> 
<ol>
<li>通过选择有替换的数据点来创建数据集的第一个样本。</li>
<li>接下来，我们不使用所有输入变量来创建决策树。我们只使用可用的一个子集。</li>
<li>每棵树都被允许长到尽可能大的长度，并且不涉及修剪。</li>
</ol>
<h3 id="6.4.1%20%E4%BC%98%E7%82%B9">6.4.1 优点</h3> 
<ol>
<li>对于大型数据集，它是有效的。</li>
<li>它允许估计输入变量在分类中的重要性。</li>
<li>它比决策树更准确。</li>
</ol>
<h3 id="6.4.2%20%E7%BC%BA%E7%82%B9">6.4.2 缺点</h3> 
<ol><li>在实施方面更为复杂，因此需要更多时间进行评估。</li></ol>
<h3 id="6.4.3%20%E5%BA%94%E7%94%A8">6.4.3 应用</h3> 
<ol>
<li>
<strong>信用卡违约：</strong> 信用卡公司使用随机森林来预测持卡人是否会违约。</li>
<li>
<strong>股票市场预测：</strong> 股票投资者使用它来指示特定股票的趋势并分析其损失和利润。</li>
<li>
<strong>产品推荐：</strong> 可以根据用户的喜好使用它向用户推荐产品。</li>
</ol>
<h2 id="6.5%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA">6.5 支持向量机</h2> 
<p style="text-align:left"><span style="color:#4d5356">该算法利用具有令人兴奋的变化的支持向量分类器，使其适用于评估非线性决策边界。通过使用称为<em>kernels 的</em>特殊函数扩大特征变量空间，这成为可能 。该算法考虑的决策边界允许将特征变量标记为目标变量。它用于评估边界的数学函数由下式给出</span></p> 
<p style="text-align:center"><span style="color:#4d5356"><img alt="fleft ( x right )= beta _{0}-sum_{i in s }alpha _{i}Kleft ( x,x_{i} right )" class="gm-observing gm-observing-cb img-fluid" src="https://images2.imgbox.com/9e/eb/eUw1oSyC_o.gif"></span></p> 
<p style="text-align:left"><span style="color:#4d5356">其中 K 代表核函数。</span></p> 
<h3 id="%C2%A06.5.1%20%E4%BC%98%E7%82%B9"> 6.5.1 优点</h3> 
<ol>
<li>它使训练数据集变得容易。</li>
<li>当数据是高维时，它表现良好。</li>
</ol>
<h3 id="6.5.2%20%E7%BC%BA%E7%82%B9">6.5.2 缺点</h3> 
<ol>
<li>当数据包含噪声元素时，它表现不佳。</li>
<li>它对核函数很敏感，因此必须明智地选择它们。</li>
</ol>
<h3 id="6.5.3%20%E5%BA%94%E7%94%A8">6.5.3 应用</h3> 
<ol>
<li>
<strong>人脸检测：</strong> 用于读取图像（像素数数组）并根据通常的人类特征识别是否包含人脸。</li>
<li>
<strong>图像分类：</strong>  SVM 是用于根据图像特征对图像进行分类的图像分类算法之一。</li>
<li>
<strong>手写字符识别：</strong> 我们可以用它来识别手写字符。</li>
</ol>
<h2 id="6.6%20K%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95">6.6 K最近邻分类算法</h2> 
<p style="text-align:left"><span style="color:#4d5356">KNN 算法通过识别给定观察点的 K 个最近邻居来工作。然后它使用 K 个点评估每种类型的目标变量的比例，然后预测具有最高比例的目标变量。例如，考虑以下情况，我们必须将目标值标记为点 X。然后，如果我们在它周围取四个邻居，该模型将预测该点属于粉红色的类。</span></p> 
<p style="text-align:center"></p> 
<p> <img alt="" height="280" src="https://images2.imgbox.com/c4/98/bwG0pXmV_o.png" width="271"></p> 
<p></p> 
<h3 id="%C2%A06.6.1%20%E4%BC%98%E7%82%B9"> 6.6.1 优点</h3> 
<ol>
<li>可以将其应用于任何分布的数据集。</li>
<li>它很容易理解并且非常直观。</li>
</ol>
<h3 id="6.6.2%20%E7%BC%BA%E7%82%B9">6.6.2 缺点</h3> 
<ol>
<li>它很容易受到异常值的影响。</li>
<li>它偏向于在数据集中具有更多实例的类。</li>
<li>有时很难找到 K 的最佳数字。</li>
</ol>
<h3 id="6.6.3%20%E5%BA%94%E7%94%A8">6.6.3 应用</h3> 
<ol>
<li>
<strong>检测异常值：</strong> 由于该算法对异常值很敏感，因此可以检测异常值。</li>
<li>
<strong>识别相似文档：</strong> 识别语义相似的文档。</li>
</ol>
<h2 id="6.7%20K-Means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95">6.7 K-Means聚类算法</h2> 
<p style="text-align:left"><span style="color:#4d5356">K-Means Clustering 是一种将数据集划分为 K 个不重叠的组的聚类算法。该算法的第一步是指定预期的簇数 K。然后，任务是将数据集划分为 K 个簇，以使簇内变化尽可能小。算法过程如下：</span></p> 
<ol>
<li>为每个输入变量随机分配一个从 1 到 K 的数字。这些是变量的初始聚类标签。</li>
<li>重复该步骤，直到集群分配保持不变：</li>
<li>为 K 个集群中的每一个评估集群质心。 </li>
<li>将每个输入变量集分配给质心最近的簇（这里最接近可以用欧氏距离来定义）</li>
</ol>
<p style="text-align:left"><span style="color:#4d5356">总之，该算法最小化输入点与相应聚类质心之间的偏差平方和。将其命名为 K 均值聚类的原因是步骤 2a) 将属于特定聚类的观测值的均值评估为聚类质心。 </span></p> 
<h3 id="6.7.1%20%E4%BC%98%E7%82%B9" style="text-align:left">6.7.1 优点</h3> 
<ol>
<li>我们可以将其应用于大型数据集。</li>
<li>实施起来毫不费力。</li>
<li>它保证了定位集群的收敛性。</li>
</ol>
<h3 id="6.7.2%20%E7%BC%BA%E7%82%B9" style="text-align:left">6.7.2 缺点</h3> 
<ol>
<li>它有一个限制，因为必须首先提供 K 的值。</li>
<li>它对异常值很敏感。</li>
</ol>
<h3 id="6.7.3%20%E5%BA%94%E7%94%A8" style="text-align:left">6.7.3 应用</h3> 
<ol>
<li>
<strong>添加推荐：</strong> 公司可以识别共享金钱消费习惯的客户群，并展示他们更有可能购买的广告。</li>
<li>
<strong>识别城市中的犯罪区域：</strong> 使用 K 均值聚类，我们可以识别更容易发生犯罪案件的区域。</li>
<li>
<strong>文档分类：</strong> 识别写在类似主题上的文档</li>
</ol>
<p style="text-align:left"></p> 
<p></p> 
<h1 id="4%20%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95">7 如何决定选择哪种分类算法</h1> 
<p style="text-align:left"><span style="color:#4d5356">下面我们有一个列表，可以帮助您了解应该使用哪些分类算法来解决业务问题。</span></p> 
<ol>
<li>
<strong>问题识别：</strong> 首先要做的是彻底了解手头的任务。如果是有监督的分类案例，可以使用逻辑回归、随机森林、决策树等算法。另一方面，如果是无监督的分类案例，则应该使用聚类算法。</li>
<li>
<strong>数据集</strong>  的大小<strong>：数据集</strong>的大小也是您在选择算法时应该考虑的一个参数。由于很少有算法相对较快，因此最好切换到那些算法。如果数据集的大小很小，您可以坚持使用像朴素贝叶斯这样的低偏差/高方差算法。相反，如果数据集很大，特征数量很多，那么你应该使用高偏差/低方差算法，如 KNN、决策树和 SVM。</li>
<li>
<strong>预测准确度：</strong> 模型的准确度是测试分类器好坏的参数。它反映了预测输出值与正确输出值的匹配程度。当然，更高的精度是可取的，但还应检查模型是否过拟合。</li>
<li>
<strong>训练时间：</strong> 有时，像 SVM 和随机森林这样的复杂算法可能会占用大量计算时间。此外，更高的准确性和大数据集无论如何需要更多时间来学习模式。像逻辑回归这样的简单算法更容易实现并节省时间。</li>
<li>
<strong>数据集的线性： </strong>输入变量和目标变量之间并不总是存在线性关系。因此，必须分析这种关系并仔细选择算法，因为其中一些仅限于线性数据集。检查线性的最佳方法是拟合线性线或运行逻辑回归或 SVM 并查找残差。较高的误差表明数据是非线性的，需要实施复杂的算法。</li>
<li>
<strong>特征数量：</strong> 有时，数据集可能包含不必要的许多特征，并且并非所有特征都相关。然后可以使用最适合这种情况的 SVM 等算法，或者使用主成分分析来确定哪些特征是重要的。</li>
</ol>
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>