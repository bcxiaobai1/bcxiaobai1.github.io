<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C语言获取当前系统时间的几种方式 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言获取当前系统时间的几种方式</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">C</span><span style="color:#000000">语言中如何获取时间？精度如何？</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">1 </span><span style="color:#000000">使用</span><span style="color:#000000">time_t time( time_t * timer ) </span><span style="color:#000000">精确到秒</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">2 </span><span style="color:#000000">使用</span><span style="color:#000000">clock_t clock() </span><span style="color:#000000">得到的是</span><span style="color:#000000">CPU</span><span style="color:#000000">时间精确到</span><span style="color:#000000">1/CLOCKS_PER_SEC</span><span style="color:#000000">秒</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">3 </span><span style="color:#000000">计算时间差使用</span><span style="color:#000000">double difftime( time_t timer1, time_t timer0 )</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">4 </span><span style="color:#000000">使用</span><span style="color:#000000">DWORD GetTickCount() </span><span style="color:#000000">精确到毫秒</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">5 </span><span style="color:#000000">如果使用</span><span style="color:#000000">MFC</span><span style="color:#000000">的</span><span style="color:#000000">CTime</span><span style="color:#000000">类，可以用</span><span style="color:#000000">CTime::GetCurrentTime() </span><span style="color:#000000">精确到秒</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">6 </span><span style="color:#000000">要获取高精度时间，可以使用</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">获取系统的计数器的频率</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">获取计数器的值</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">然后用两次计数器的差除以</span><span style="color:#000000">Frequency</span><span style="color:#000000">就得到时间。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">7 Multimedia Timer Functions</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">The following functions are used with multimedia timers.</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">timeBeginPeriod/timeEndPeriod/timeGetDevCaps/timeGetSystemTime</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">//*********************************************************************</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">//</span><span style="color:#000000">用标准</span><span style="color:#000000">C</span><span style="color:#000000">实现获取当前系统时间的函数</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">一</span><span style="color:#000000">.time()</span><span style="color:#000000">函数</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time(&amp;rawtime)</span><span style="color:#000000">函数获取当前时间距</span><span style="color:#000000">1970</span><span style="color:#000000">年</span><span style="color:#000000">1</span><span style="color:#000000">月</span><span style="color:#000000">1</span><span style="color:#000000">日的秒数，以秒计数单位，存于</span><span style="color:#000000">rawtime </span><span style="color:#000000">中。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">#include "time.h"</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">void main ()</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">{<!-- --></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time_t rawtime;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">struct tm * timeinfo;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time ( &amp;rawtime );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">timeinfo = localtime ( &amp;rawtime );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">printf ( "07The current date/time is: %s", asctime (timeinfo) );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">exit(0);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">}</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">=================</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">#include -- </span><span style="color:#000000">必须的时间函数头文件</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time_t -- </span><span style="color:#000000">时间类型（</span><span style="color:#000000">time.h </span><span style="color:#000000">定义是</span><span style="color:#000000">typedef long time_t; </span><span style="color:#000000">追根溯源，</span><span style="color:#000000">time_t</span><span style="color:#000000">是</span><span style="color:#000000">long</span><span style="color:#000000">）</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">struct tm -- </span><span style="color:#000000">时间结构，</span><span style="color:#000000">time.h </span><span style="color:#000000">定义如下：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int tm_sec;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int tm_min;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int tm_hour;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int tm_mday;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int tm_mon;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int tm_year;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int tm_wday;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int tm_yday;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int tm_isdst;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time ( &amp;rawtime ); -- </span><span style="color:#000000">获取时间，以秒计，从</span><span style="color:#000000">1970</span><span style="color:#000000">年</span><span style="color:#000000">1</span><span style="color:#000000">月一日起算，存于</span><span style="color:#000000">rawtime</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">localtime ( &amp;rawtime ); -- </span><span style="color:#000000">转为当地时间，</span><span style="color:#000000">tm </span><span style="color:#000000">时间结构</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">asctime </span><span style="color:#000000">（）</span><span style="color:#000000">-- </span><span style="color:#000000">转为标准</span><span style="color:#000000">ASCII</span><span style="color:#000000">时间格式：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">星期</span> <span style="color:#000000">月</span> <span style="color:#000000">日</span> <span style="color:#000000">时：分：秒</span> <span style="color:#000000">年</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">-----------------------------------------------------------------------------</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">二</span><span style="color:#000000">.clock()</span><span style="color:#000000">函数</span><span style="color:#000000">,</span><span style="color:#000000">用</span><span style="color:#000000">clock()</span><span style="color:#000000">函数，得到系统启动以后的毫秒级时间，然后除以</span><span style="color:#000000">CLOCKS_PER_SEC</span><span style="color:#000000">，就可以换成</span><span style="color:#000000">“</span><span style="color:#000000">秒</span><span style="color:#000000">”</span><span style="color:#000000">，标准</span><span style="color:#000000">c</span><span style="color:#000000">函数。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">clock_t clock ( void );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">#include</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">clock_t t = clock();</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">long sec = t / CLOCKS_PER_SEC;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">他是记录时钟周期的，实现看来不会很精确，需要试验验证；</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">---------------------------------------------------------------------------</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">三</span><span style="color:#000000">.gettime(&amp;t); </span><span style="color:#000000">据说</span><span style="color:#000000">tc2.0</span><span style="color:#000000">的</span><span style="color:#000000">time</span><span style="color:#000000">结构含有毫秒信息</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">#include</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">#include</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int main(void)</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">{<!-- --></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">struct time t;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">gettime(&amp;t);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">printf("The current time is: -:d:d.dn",</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">t.ti_hour, t.ti_min, t.ti_sec, t.ti_hund);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">return 0;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">}</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time </span><span style="color:#000000">是一个结构体，，</span> <span style="color:#000000">其中成员函数</span><span style="color:#000000"> ti_hund </span><span style="color:#000000">是毫秒。。。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">--------------------------------------------------------------------------------</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">四</span><span style="color:#000000">.GetTickCount(),</span><span style="color:#000000">这个是</span><span style="color:#000000">windows</span><span style="color:#000000">里面常用来计算程序运行时间的函数；</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">DWORD dwStart = GetTickCount();</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">//</span><span style="color:#000000">这里运行你的程序代码</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">DWORD dwEnd = GetTickCount();</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">则</span><span style="color:#000000">(dwEnd-dwStart)</span><span style="color:#000000">就是你的程序运行时间</span><span style="color:#000000">, </span><span style="color:#000000">以毫秒为单位</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">这个函数只精确到</span><span style="color:#000000">55ms</span><span style="color:#000000">，</span><span style="color:#000000">1</span><span style="color:#000000">个</span><span style="color:#000000">tick</span><span style="color:#000000">就是</span><span style="color:#000000">55ms</span><span style="color:#000000">。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">--------------------------------------------------------------------------------</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">五</span><span style="color:#000000">.timeGetTime()t,imeGetTime()</span><span style="color:#000000">基本等于</span><span style="color:#000000">GetTickCount()</span><span style="color:#000000">，但是精度更高</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">DWORD dwStart = timeGetTime();</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">//</span><span style="color:#000000">这里运行你的程序代码</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">DWORD dwEnd = timeGetTime();</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">则</span><span style="color:#000000">(dwEnd-dwStart)</span><span style="color:#000000">就是你的程序运行时间</span><span style="color:#000000">, </span><span style="color:#000000">以毫秒为单位</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">虽然返回的值单位应该是</span><span style="color:#000000">ms,</span><span style="color:#000000">但传说精度只有</span><span style="color:#000000">10ms</span><span style="color:#000000">。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">=========================================</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">//*****************************************************************Unix</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">##unix</span><span style="color:#000000">时间相关</span><span style="color:#000000">,</span><span style="color:#000000">也是标准库的</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">//*********************************************************************</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">1.timegm</span><span style="color:#000000">函数只是将</span><span style="color:#000000">struct tm</span><span style="color:#000000">结构转成</span><span style="color:#000000">time_t</span><span style="color:#000000">结构</span><span style="color:#000000">,</span><span style="color:#000000">不使用时区信息</span><span style="color:#000000">;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time_t timegm(struct tm *tm);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">2.mktime</span><span style="color:#000000">使用时区信息</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time_t mktime(struct tm *tm);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">timelocal </span><span style="color:#000000">函数是</span><span style="color:#000000">GNU</span><span style="color:#000000">扩展的与</span><span style="color:#000000">posix</span><span style="color:#000000">函数</span><span style="color:#000000">mktime</span><span style="color:#000000">相当</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time_t timelocal (struct tm *tm);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">3.gmtime</span><span style="color:#000000">函数只是将</span><span style="color:#000000">time_t</span><span style="color:#000000">结构转成</span><span style="color:#000000">struct tm</span><span style="color:#000000">结构</span><span style="color:#000000">,</span><span style="color:#000000">不使用时区信息</span><span style="color:#000000">;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">struct tm * gmtime(const time_t *clock);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">4.localtime</span><span style="color:#000000">使用时区信息</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">struct tm * localtime(const time_t *clock);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">1.time</span><span style="color:#000000">获取时间，</span><span style="color:#000000">stime</span><span style="color:#000000">设置时间</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time_t t</span><span style="color:#000000">；</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">t = time(&amp;t);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">2.stime</span><span style="color:#000000">其参数应该是</span><span style="color:#000000">GMT</span><span style="color:#000000">时间</span><span style="color:#000000">,</span><span style="color:#000000">根据本地时区设置为本地时间</span><span style="color:#000000">;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int stime(time_t *tp)</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">3.UTC=true </span><span style="color:#000000">表示采用夏时制</span><span style="color:#000000">;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">4.</span><span style="color:#000000">文件的修改时间等信息全部采用</span><span style="color:#000000">GMT</span><span style="color:#000000">时间存放</span><span style="color:#000000">,</span><span style="color:#000000">不同的系统在得到修改时间后通过</span><span style="color:#000000">localtime</span><span style="color:#000000">转换成本地时间</span><span style="color:#000000">;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">5.</span><span style="color:#000000">设置时区推荐使用</span><span style="color:#000000">setup</span><span style="color:#000000">来设置</span><span style="color:#000000">;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">6.</span><span style="color:#000000">设置时区也可以先更变</span><span style="color:#000000">/etc/sysconfig/clock</span><span style="color:#000000">中的设置再将</span><span style="color:#000000">ln -fs /usr/share/zoneinfo/xxxx/xxx /etc/localtime </span><span style="color:#000000">才能重效</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time_t</span><span style="color:#000000">只能表示</span><span style="color:#000000">68</span><span style="color:#000000">年的范围，即</span><span style="color:#000000">mktime</span><span style="color:#000000">只能返回</span><span style="color:#000000">1970-2038</span><span style="color:#000000">这一段范围的</span><span style="color:#000000">time_t</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">看看你的系统是否有</span><span style="color:#000000">time_t64</span><span style="color:#000000">，它能表示更大的时间范围</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">//***************************************************************windows</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">##Window</span><span style="color:#000000">里面的一些不一样的</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">//*********************************************************************</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">一</span><span style="color:#000000">.CTime () </span><span style="color:#000000">类</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">VC</span><span style="color:#000000">编程一般使用</span><span style="color:#000000">CTime</span><span style="color:#000000">类</span> <span style="color:#000000">获得当前日期和时间</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">CTime t = GetCurrentTime();</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">SYSTEMTIME </span><span style="color:#000000">结构包含毫秒信息</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">typedef struct _SYSTEMTIME {<!-- --></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">WORD wYear;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">WORD wMonth;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">WORD wDayOfWeek;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">WORD wDay;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">WORD wHour;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">WORD wMinute;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">WORD wSecond;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">WORD wMilliseconds;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">} SYSTEMTIME, *PSYSTEMTIME;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">SYSTEMTIME t1;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">GetSystemTime(&amp;t1)</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">CTime curTime(t1);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">WORD ms = t1.wMilliseconds;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">SYSTEMTIME sysTm;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">::GetLocalTime(&amp;sysTm);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">在</span><span style="color:#000000">time.h</span><span style="color:#000000">中的</span><span style="color:#000000">_strtime() //</span><span style="color:#000000">只能在</span><span style="color:#000000">windows</span><span style="color:#000000">中用</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">char t[11];</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">_strtime(t);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">puts(t);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">//*****************************</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">获得当前日期和时间</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">CTime tm=CTime::GetCurrentTime();</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">CString str=tm.Format("%Y-%m-%d");</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">在</span><span style="color:#000000">VC</span><span style="color:#000000">中，我们可以借助</span><span style="color:#000000">CTime</span><span style="color:#000000">时间类，获取系统当前日期，具体使用方法如下：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">CTime t = CTime::GetCurrentTime(); //</span><span style="color:#000000">获取系统日期，存储在</span><span style="color:#000000">t</span><span style="color:#000000">里面</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int d=t.GetDay(); //</span><span style="color:#000000">获得当前日期</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int y=t.GetYear(); //</span><span style="color:#000000">获取当前年份</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int m=t.GetMonth(); //</span><span style="color:#000000">获取当前月份</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int h=t.GetHour(); //</span><span style="color:#000000">获取当前为几时</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int mm=t.GetMinute(); //</span><span style="color:#000000">获取当前分钟</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int s=t.GetSecond(); //</span><span style="color:#000000">获取当前秒</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int w=t.GetDayOfWeek(); //</span><span style="color:#000000">获取星期几，注意</span><span style="color:#000000">1</span><span style="color:#000000">为星期天，</span><span style="color:#000000">7</span><span style="color:#000000">为星期六</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">二</span><span style="color:#000000">.CTimeSpan</span><span style="color:#000000">类</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">如果想计算两段时间的差值，可以使用</span><span style="color:#000000">CTimeSpan</span><span style="color:#000000">类，具体使用方法如下：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">CTime t1( 1999, 3, 19, 22, 15, 0 );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">CTime t = CTime::GetCurrentTime();</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">CTimeSpan span=t-t1; //</span><span style="color:#000000">计算当前系统时间与时间</span><span style="color:#000000">t1</span><span style="color:#000000">的间隔</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int iDay=span.GetDays(); //</span><span style="color:#000000">获取这段时间间隔共有多少天</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int iHour=span.GetTotalHours(); //</span><span style="color:#000000">获取总共有多少小时</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int iMin=span.GetTotalMinutes();//</span><span style="color:#000000">获取总共有多少分钟</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">int iSec=span.GetTotalSeconds();//</span><span style="color:#000000">获取总共有多少秒</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">------------------------------------------------------------------------------</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">三</span><span style="color:#000000">._timeb()</span><span style="color:#000000">函数</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">_timeb</span><span style="color:#000000">定义在</span><span style="color:#000000">SYSTIMEB.H</span><span style="color:#000000">，有四个</span><span style="color:#000000">fields</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">dstflag</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">millitm</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">time</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">timezone</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">void _ftime( struct _timeb *timeptr );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">struct _timeb timebuffer;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">_ftime( &amp;timebuffer );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">取当前时间</span><span style="color:#000000">:</span><span style="color:#000000">文档讲可以到</span><span style="color:#000000">ms,</span><span style="color:#000000">有人测试</span><span style="color:#000000">,</span><span style="color:#000000">好象只能到</span><span style="color:#000000">16ms!</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">四</span><span style="color:#000000">.</span><span style="color:#000000">设置计时器</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">定义</span><span style="color:#000000">TIMER ID</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">#define TIMERID_JISUANFANGSHI 2</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">在适当的地方设置时钟</span><span style="color:#000000">,</span><span style="color:#000000">需要开始其作用的地方</span><span style="color:#000000">;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">SetTimer(TIMERID_JISUANFANGSHI,200,NULL);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">在不需要定时器的时候的时候销毁掉时钟</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">KillTimer(TIMERID_JISUANFANGSHI);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">对应</span><span style="color:#000000">VC</span><span style="color:#000000">程序的消息映射</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">void CJisuan::OnTimer(UINT nIDEvent)</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">{switch(nIDEvent)}</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">---------------------------------------------------------------------------------------</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">##</span><span style="color:#000000">如何设定当前系统时间</span><span style="color:#000000">---------------------------------------windows</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">SYSTEMTIME m_myLocalTime,*lpSystemTime;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wYear=2003;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wM;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wDay=1;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wHour=0;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wMinute=0;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wSec;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wMillisec;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">lpSystemTime=&amp;m_myLocalTime;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">if( SetLocalTime(lpSystemTime) ) //</span><span style="color:#000000">此处换成</span><span style="color:#000000"> SetSystemTime( )</span><span style="color:#000000">也不行</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">MessageBox("OK !");</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">else</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">MessageBox("Error !");</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">SYSTEMTIME m_myLocalTime,*lpSystemTime;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wYear=2003;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wM;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_myLocalTime.wDay=1;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">lpSystemTime=&amp;m_myLocalTime;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">if( SetDate(lpSystemTime) ) //</span><span style="color:#000000">此处换成</span><span style="color:#000000"> SetSystemTime( )</span><span style="color:#000000">也不行</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">MessageBox("OK !");</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">else</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">MessageBox("Error !");</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p>  </p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">一种制作微秒级精度定时器的方法</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">当使用定时器时，在很多情况下只用到毫秒级的时间间隔，所以只需用到下面的两种常用方式就满足要求了。一是用</span><span style="color:#000000">SetTimer</span><span style="color:#000000">函数建立一个定时器后，在程序中通过处理由定时器发送到线程消息队列中的</span><span style="color:#000000">WM_TIMER</span><span style="color:#000000">消息，而得到定时的效果（退出程序时别忘了调用和</span><span style="color:#000000">SetTimer</span><span style="color:#000000">配对使用的</span><span style="color:#000000">KillTimer</span><span style="color:#000000">函数）。二是利用</span><span style="color:#000000">GetTickCount</span><span style="color:#000000">函数可以返回自计算机启动后的时间，通过两次调用</span><span style="color:#000000">GetTickCount</span><span style="color:#000000">函数，然后控制它们的差值来取得定时效果，此方式跟第一种方式一样，精度也是毫秒级的。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">用这两种方式取得的定时效果虽然在许多场合已经满足实际的要求，但由于它们的精度只有毫秒级的，而且在要求定时时间间隔小时，实际定时误差大。下面介绍一种能取得高精度定时的方法。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">在一些计算机硬件系统中，包含有高精度运行计数器（</span><span style="color:#000000">high-resolution performance counter</span><span style="color:#000000">），利用它可以获得高精度定时间隔，其精度与</span><span style="color:#000000">CPU</span><span style="color:#000000">的时钟频率有关。采用这种方法的步骤如下：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">1</span><span style="color:#000000">、首先调用</span><span style="color:#000000">QueryPerformanceFrequency</span><span style="color:#000000">函数取得高精度运行计数器的频率</span><span style="color:#000000">f</span><span style="color:#000000">。单位是每秒多少次（</span><span style="color:#000000">n/s</span><span style="color:#000000">），此数一般很大。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">2</span><span style="color:#000000">、在需要定时的代码的两端分别调用</span><span style="color:#000000">QueryPerformanceCounter</span><span style="color:#000000">以取得高精度运行计数器的数值</span><span style="color:#000000">n1</span><span style="color:#000000">，</span><span style="color:#000000">n2</span><span style="color:#000000">。两次数值的差值通过</span><span style="color:#000000">f</span><span style="color:#000000">换算成时间间隔，</span><span style="color:#000000">t=(n2-n1)/f</span><span style="color:#000000">。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">下面举一个例子来演示这种方法的使用及它的精确度。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">在</span><span style="color:#000000">VC 6.0 </span><span style="color:#000000">下用</span><span style="color:#000000">MFC</span><span style="color:#000000">建立一个对话框工程，取名为</span><span style="color:#000000">HightTimer.</span><span style="color:#000000">在对话框面板中控件的布局如下图：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">其中包含两个静态文本框，两个编辑框和两个按纽。上面和下面位置的编辑框的</span><span style="color:#000000">ID</span><span style="color:#000000">分别为</span><span style="color:#000000">IDC_E_TEST</span><span style="color:#000000">和</span><span style="color:#000000">IDC_E_ACTUAL</span><span style="color:#000000">，通过</span><span style="color:#000000">MFC ClassWizard</span><span style="color:#000000">添加的成员变量也分别对应为</span><span style="color:#000000">DWORD m_dwTest</span><span style="color:#000000">和</span><span style="color:#000000">DWORD m_dwAct. “</span><span style="color:#000000">退出</span><span style="color:#000000">”</span><span style="color:#000000">按纽的</span><span style="color:#000000">ID</span><span style="color:#000000">为</span><span style="color:#000000">IDOK</span><span style="color:#000000">，</span><span style="color:#000000">“</span><span style="color:#000000">开始测试</span><span style="color:#000000">”</span><span style="color:#000000">按纽</span><span style="color:#000000">ID</span><span style="color:#000000">为</span><span style="color:#000000">IDC_B_TEST</span><span style="color:#000000">，用</span><span style="color:#000000">MFC ClassWizard</span><span style="color:#000000">添加此按纽的单击消息处理函数如下：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">void CHightTimerDlg::OnBTest()</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">{<!-- --></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">// TODO: Add your control notification handler code here</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">UpdateData(TRUE); //</span><span style="color:#000000">取输入的测试时间值到与编辑框相关联的成员变量</span><span style="color:#000000">m_dwTest</span><span style="color:#000000">中</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">LARGE_INTEGER frequence;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">if(!QueryPerformanceFrequency( &amp;frequence)) //</span><span style="color:#000000">取高精度运行计数器的频率，若硬件不支持则返回</span><span style="color:#000000">FALSE</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">MessageBox("Your computer hardware doesn't support the high-resolution performance counter",</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">"Not Support", MB_ICONEXCLAMATION | MB_OK);</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">LARGE_INTEGER test, ret;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">test.QuadPart = frequence.QuadPart * m_dwTest / 1000000; //</span><span style="color:#000000">通过频率换算微秒数到对应的数量（与</span><span style="color:#000000">CPU</span><span style="color:#000000">时钟有关），</span><span style="color:#000000">1</span><span style="color:#000000">秒</span><span style="color:#000000">=1000000</span><span style="color:#000000">微秒</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">ret = MySleep( test ); //</span><span style="color:#000000">调用此函数开始延时，返回实际花销的数量</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">m_dwAct = (DWORD)(1000000 * ret.QuadPart / frequence.QuadPart ); //</span><span style="color:#000000">换算到微秒数</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">UpdateData(FALSE); //</span><span style="color:#000000">显示到对话框面板</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">}</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">其中上面调用的</span><span style="color:#000000">MySleep</span><span style="color:#000000">函数如下：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">LARGE_INTEGER CHightTimerDlg::MySleep(LARGE_INTEGER Interval)</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">/</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">// </span><span style="color:#000000">功能：执行实际的延时功能</span><br><span style="color:#000000">// </span><span style="color:#000000">参数：</span><span style="color:#000000">Interval </span><span style="color:#000000">参数为需要执行的延时与时间有关的数量</span><br><span style="color:#000000">// </span><span style="color:#000000">返回值：返回此函数执行后实际所用的时间有关的数量</span><br><span style="color:#000000">///</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">{ </span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">LARGE_INTEGER privious, current, Elapse;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">QueryPerformanceCounter( &amp;privious );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">current = privious;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">while( current.QuadPart - privious.QuadPart &lt; Interval.QuadPart )</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">QueryPerformanceCounter( ¤t );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">Elapse.QuadPart = current.QuadPart - privious.QuadPart;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">return Elapse;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">}</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">注：别忘了在头文件中为此函数添加函数声明。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">至此，可以编译和执行此工程了，结果如上图所示。在本人所用的机上</span><span style="color:#000000">(</span><span style="color:#000000">奔腾</span><span style="color:#000000">366</span><span style="color:#000000">，</span><span style="color:#000000"> 64M</span><span style="color:#000000">内存</span><span style="color:#000000">)</span><span style="color:#000000">测试，当测试时间超过</span><span style="color:#000000">3</span><span style="color:#000000">微秒时，准确度已经非常高了，此时机器执行本身延时函数代码的时间对需要延时的时间影响很小了。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">上面的函数由于演示测试的需要，没有在函数级封装，下面给出的函数基本上可以以全局函数的形式照搬到别的程序中。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">BOOL MySleep(DWORD dwInterval)</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">/</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">// </span><span style="color:#000000">功能：执行微秒级的延时功能</span><br><span style="color:#000000">// </span><span style="color:#000000">参数：</span><span style="color:#000000">Interval </span><span style="color:#000000">参数为需要的延时数（单位：微秒）</span><br><span style="color:#000000">// </span><span style="color:#000000">返回值：若计算机硬件不支持此功能，返回</span><span style="color:#000000">FALSE</span><span style="color:#000000">，若函数执行成功，返回</span><span style="color:#000000">TRUE<br> /// </span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">{<!-- --></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">BOOL bNormal = TRUE;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">LARGE_INTEGER frequence, privious, current, interval;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">if(!QueryPerformanceFrequency( &amp;frequence))</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">{<!-- --></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">::MessageBox(NULL, "Your computer hardware doesn't support the high-resolution performance counter",</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">"Not Support", MB_ICONEXCLAMATION | MB_OK); //</span><span style="color:#000000">或其它的提示信息</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">return FALSE;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">}</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">interval.QuadPart = frequence.QuadPart * dwInterval / 1000000;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">bNormal = bNormal &amp;&amp; QueryPerformanceCounter( &amp;privious );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">current = privious;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">while( current.QuadPart - privious.QuadPart &lt; interval.QuadPart )</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">bNormal = bNormal &amp;&amp; QueryPerformanceCounter( ¤t );</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">return bNormal;</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">}</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">需要指出的是，由于在此函数中的代码很多，机器在执行这些代码所花费的时间也很长，所以在需要几个微秒的延时时，会影响精度。实际上，读者在熟悉这种方法后，只要使用</span><span style="color:#000000">QueryPerformanceFrequency</span><span style="color:#000000">和</span><span style="color:#000000">QueryPerformanceCounter</span><span style="color:#000000">这两个函数就能按实际需要写出自己的延时代码了。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">使用</span><span style="color:#000000">CPU</span><span style="color:#000000">时间戳进行高精度计时</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">在</span><span style="color:#000000">Windows</span><span style="color:#000000">平台下，常用的计时器有两种，一种是</span><span style="color:#000000">timeGetTime</span><span style="color:#000000">多媒体计时器，它可以提供毫秒级的计时。但这个精度对很多应用场合而言还是太粗糙了。另一种是</span><span style="color:#000000">QueryPerformanceCount</span><span style="color:#000000">计数器，随系统的不同可以提供微秒级的计数。对于实时图形处理、多媒体数据流处理、或者实时系统构造的程序员，善用</span><span style="color:#000000">QueryPerformanceCount/QueryPerformanceFrequency</span><span style="color:#000000">是一项基本功。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">本文要介绍的，是另一种直接利用</span><span style="color:#000000">Pentium CPU</span><span style="color:#000000">内部时间戳进行计时的高精度计时手段。以下讨论主要得益于《</span><span style="color:#000000">Windows</span><span style="color:#000000">图形编程》一书，第</span><span style="color:#000000">15</span><span style="color:#000000">页－</span><span style="color:#000000">17</span><span style="color:#000000">页，有兴趣的读者可以直接参考该书。关于</span><span style="color:#000000">RDTSC</span><span style="color:#000000">指令的详细讨论，可以参考</span><span style="color:#000000">Intel</span><span style="color:#000000">产品手册。本文仅仅作抛砖之用。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">在</span><span style="color:#000000">Intel Pentium</span><span style="color:#000000">以上级别的</span><span style="color:#000000">CPU</span><span style="color:#000000">中，有一个称为</span><span style="color:#000000">“</span><span style="color:#000000">时间戳（</span><span style="color:#000000">Time Stamp</span><span style="color:#000000">）</span><span style="color:#000000">”</span><span style="color:#000000">的部件，它以</span><span style="color:#000000">64</span><span style="color:#000000">位无符号整型数的格式，记录了自</span><span style="color:#000000">CPU</span><span style="color:#000000">上电以来所经过的时钟周期数。由于目前的</span><span style="color:#000000">CPU</span><span style="color:#000000">主频都非常高，因此这个部件可以达到纳秒级的计时精度。这个精确性是上述两种方法所无法比拟的。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">在</span><span style="color:#000000">Pentium</span><span style="color:#000000">以上的</span><span style="color:#000000">CPU</span><span style="color:#000000">中，提供了一条机器指令</span><span style="color:#000000">RDTSC</span><span style="color:#000000">（</span><span style="color:#000000">Read Time Stamp Counter</span><span style="color:#000000">）来读取这个时间戳的数字，并将其保存在</span><span style="color:#000000">EDX:EAX</span><span style="color:#000000">寄存器对中。由于</span><span style="color:#000000">EDX:EAX</span><span style="color:#000000">寄存器对恰好是</span><span style="color:#000000">Win32</span><span style="color:#000000">平台下</span><span style="color:#000000">C++</span><span style="color:#000000">语言保存函数返回值的寄存器，所以我们可以把这条指令看成是一个普通的函数调用。像这样：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">inline unsigned __int64 GetCycleCount()</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">{ </span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">__asm RDTSC </span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">} </span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">但是不行，因为</span><span style="color:#000000">RDTSC</span><span style="color:#000000">不被</span><span style="color:#000000">C++</span><span style="color:#000000">的内嵌汇编器直接支持，所以我们要用</span><span style="color:#000000">_emit</span><span style="color:#000000">伪指令直接嵌入该指令的机器码形式</span><span style="color:#000000">0X0F</span><span style="color:#000000">、</span><span style="color:#000000">0X31</span><span style="color:#000000">，如下：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="color:#000000">inline unsigned __int64 GetCycleCount()<br> {<!-- --><br> __asm _emit 0x0F<br> __asm _emit 0x31<br> } </span><br><br><span style="color:#000000">以后在需要计数器的场合，可以像使用普通的</span><span style="color:#000000">Win32 API</span><span style="color:#000000">一样，调用两次</span><span style="color:#000000">GetCycleCount</span><span style="color:#000000">函数，比较两个返回值的差，像这样：</span><br><br><span style="color:#000000">unsigned long t;<br> t = (unsigned long)GetCycleCount();<br> //Do Something time-intensive ...<br> t -= (unsigned long)GetCycleCount(); </span><br><br><span style="color:#000000">　　《</span><span style="color:#000000">Windows</span><span style="color:#000000">图形编程》第</span><span style="color:#000000">15</span><span style="color:#000000">页编写了一个类，把这个计数器封装起来。有兴趣的读者可以去参考那个类的代码。作者为了更精确的定时，做了一点小小的改进，把执行</span><span style="color:#000000">RDTSC</span><span style="color:#000000">指令的时间，通过连续两次调用</span><span style="color:#000000">GetCycleCount</span><span style="color:#000000">函数计算出来并保存了起来，以后每次计时结束后，都从实际得到的计数中减掉这一小段时间，以得到更准确的计时数字。但我个人觉得这一点点改进意义不大。在我的机器上实测，这条指令大概花掉了几十到</span><span style="color:#000000">100</span><span style="color:#000000">多个周期，在</span><span style="color:#000000">Celeron 800MHz</span><span style="color:#000000">的机器上，这不过是十分之一微秒的时间。对大多数应用来说，这点时间完全可以忽略不计；而对那些确实要精确到纳秒数量级的应用来说，这个补偿也过于粗糙了。</span><br><br><span style="color:#000000">这个方法的优点是：</span><br><br><span style="color:#000000">1.</span><span style="color:#000000">高精度。可以直接达到纳秒级的计时精度（在</span><span style="color:#000000">1GHz</span><span style="color:#000000">的</span><span style="color:#000000">CPU</span><span style="color:#000000">上每个时钟周期就是一纳秒），这是其他计时方法所难以企及的。</span><br><br><span style="color:#000000">2.</span><span style="color:#000000">成本低。</span><span style="color:#000000">timeGetTime </span><span style="color:#000000">函数需要链接多媒体库</span><span style="color:#000000">winmm.lib</span><span style="color:#000000">，</span><span style="color:#000000">QueryPerformance* </span><span style="color:#000000">函数根据</span><span style="color:#000000">MSDN</span><span style="color:#000000">的说明，需要硬件的支持（虽然我还没有见过不支持的机器）和</span><span style="color:#000000">KERNEL</span><span style="color:#000000">库的支持，所以二者都只能在</span><span style="color:#000000">Windows</span><span style="color:#000000">平台下使用（关于</span><span style="color:#000000">DOS</span><span style="color:#000000">平台下的高精度计时问题，可以参考《图形程序开发人员指南》，里面有关于控制定时器</span><span style="color:#000000">8253</span><span style="color:#000000">的详细说明）。但</span><span style="color:#000000">RDTSC</span><span style="color:#000000">指令是一条</span><span style="color:#000000">CPU</span><span style="color:#000000">指令，凡是</span><span style="color:#000000">i386</span><span style="color:#000000">平台下</span><span style="color:#000000">Pentium</span><span style="color:#000000">以上的机器均支持，甚至没有平台的限制（我相信</span><span style="color:#000000">i386</span><span style="color:#000000">版本</span><span style="color:#000000">UNIX</span><span style="color:#000000">和</span><span style="color:#000000">Linux</span><span style="color:#000000">下这个方法同样适用，但没有条件试验），而且函数调用的开销是最小的。</span><br><br><span style="color:#000000">3.</span><span style="color:#000000">具有和</span><span style="color:#000000">CPU</span><span style="color:#000000">主频直接对应的速率关系。一个计数相当于</span><span style="color:#000000">1/(CPU</span><span style="color:#000000">主频</span><span style="color:#000000">Hz</span><span style="color:#000000">数</span><span style="color:#000000">)</span><span style="color:#000000">秒，这样只要知道了</span><span style="color:#000000">CPU</span><span style="color:#000000">的主频，可以直接计算出时间。这和</span><span style="color:#000000">QueryPerformanceCount</span><span style="color:#000000">不同，后者需要通过</span><span style="color:#000000">QueryPerformanceFrequency</span><span style="color:#000000">获取当前计数器每秒的计数次数才能换算成时间。</span><br><br><span style="color:#000000">这个方法的缺点是：</span><br><br><span style="color:#000000">1.</span><span style="color:#000000">现有的</span><span style="color:#000000">C/C++</span><span style="color:#000000">编译器多数不直接支持使用</span><span style="color:#000000">RDTSC</span><span style="color:#000000">指令，需要用直接嵌入机器码的方式编程，比较麻烦。</span><br><br><span style="color:#000000">2.</span><span style="color:#000000">数据抖动比较厉害。其实对任何计量手段而言，精度和稳定性永远是一对矛盾。如果用低精度的</span><span style="color:#000000">timeGetTime</span><span style="color:#000000">来计时，基本上每次计时的结果都是相同的；而</span><span style="color:#000000">RDTSC</span><span style="color:#000000">指令每次结果都不一样，经常有几百甚至上千的差距。这是这种方法高精度本身固有的矛盾。</span><br><br><span style="color:#000000">关于这个方法计时的最大长度，我们可以简单的用下列公式计算：</span><br><br><span style="color:#000000">自</span><span style="color:#000000">CPU</span><span style="color:#000000">上电以来的秒数</span><span style="color:#000000"> = RDTSC</span><span style="color:#000000">读出的周期数</span><span style="color:#000000"> / CPU</span><span style="color:#000000">主频速率（</span><span style="color:#000000">Hz</span><span style="color:#000000">）</span><br><br><span style="color:#000000">64</span><span style="color:#000000">位无符号整数所能表达的最大数字是</span><span style="color:#000000">1.8×10^19</span><span style="color:#000000">，在我的</span><span style="color:#000000">Celeron 800</span><span style="color:#000000">上可以计时大约</span><span style="color:#000000">700</span><span style="color:#000000">年（书中说可以在</span><span style="color:#000000">200MHz</span><span style="color:#000000">的</span><span style="color:#000000">Pentium</span><span style="color:#000000">上计时</span><span style="color:#000000">117</span><span style="color:#000000">年，这个数字不知道是怎么得出来的，与我的计算有出入）。无论如何，我们大可不必关心溢出的问题。</span><br><br><span style="color:#000000">下面是几个小例子，简要比较了三种计时方法的用法与精度</span><br><br><span style="color:#000000">//Timer1.cpp </span><span style="color:#000000">使用了</span><span style="color:#000000">RDTSC</span><span style="color:#000000">指令的</span><span style="color:#000000">Timer</span><span style="color:#000000">类</span><span style="color:#000000">//KTimer</span><span style="color:#000000">类的定义可以参见《</span><span style="color:#000000">Windows</span><span style="color:#000000">图形编程》</span><span style="color:#000000">P15<br> //</span><span style="color:#000000">编译行：</span><span style="color:#000000">CL Timer1.cpp /link USER32.lib<br> #include &lt;stdio.h&gt;<br> #include "KTimer.h"<br> main()<br> {<!-- --><br> unsigned t;<br> KTimer timer;<br> timer.Start();<br> Sleep(1000);<br> t = timer.Stop();<br> printf("Lasting Time: %dn",t);<br> }<br><br> //Timer2.cpp </span><span style="color:#000000">使用了</span><span style="color:#000000">timeGetTime</span><span style="color:#000000">函数</span><br><span style="color:#000000">//</span><span style="color:#000000">需包含</span><span style="color:#000000">&lt;mmsys.h&gt;</span><span style="color:#000000">，但由于</span><span style="color:#000000">Windows</span><span style="color:#000000">头文件错综复杂的关系</span><br><span style="color:#000000">//</span><span style="color:#000000">简单包含</span><span style="color:#000000">&lt;windows.h&gt;</span><span style="color:#000000">比较偷懒：）</span><br><span style="color:#000000">//</span><span style="color:#000000">编译行：</span><span style="color:#000000">CL timer2.cpp /link winmm.lib<br> #include &lt;windows.h&gt;<br> #include &lt;stdio.h&gt;<br><br> main()<br> {<!-- --><br> DWORD t1, t2;<br> t1 = timeGetTime();<br> Sleep(1000);<br> t2 = timeGetTime();<br> printf("Begin Time: %un", t1);<br> printf("End Time: %un", t2);<br> printf("Lasting Time: %un",(t2-t1));<br> }<br><br> //Timer3.cpp </span><span style="color:#000000">使用了</span><span style="color:#000000">QueryPerformanceCounter</span><span style="color:#000000">函数</span><br><span style="color:#000000">//</span><span style="color:#000000">编译行：</span><span style="color:#000000">CL timer3.cpp /link KERNEl32.lib<br> #include &lt;windows.h&gt;<br> #include &lt;stdio.h&gt;<br><br> main()<br> {<!-- --><br> LARGE_INTEGER t1, t2, tc;<br> QueryPerformanceFrequency(&amp;tc);<br> printf("Frequency: %un", tc.QuadPart);<br> QueryPerformanceCounter(&amp;t1);<br> Sleep(1000);<br> QueryPerformanceCounter(&amp;t2);<br> printf("Begin Time: %un", t1.QuadPart);<br> printf("End Time: %un", t2.QuadPart);<br> printf("Lasting Time: %un",( t2.QuadPart- t1.QuadPart));<br> }<br><br> <br> //</span><span style="color:#000000">以上三个示例程序都是测试</span><span style="color:#000000">1</span><span style="color:#000000">秒钟休眠所耗费的时间</span><br><span style="color:#000000">file://</span><span style="color:#000000">测</span><span style="color:#000000">/</span><span style="color:#000000">试环境：</span><span style="color:#000000">Celeron 800MHz / 256M SDRAM<br> // Windows 2000 Professional SP2<br> // Microsoft Visual C++ 6.0 SP5<br> </span><br><br><span style="color:#000000">以下是</span><span style="color:#000000">Timer1</span><span style="color:#000000">的运行结果，使用的是高精度的</span><span style="color:#000000">RDTSC</span><span style="color:#000000">指令</span><br><span style="color:#000000">Lasting Time: 804586872 </span><br><br><span style="color:#000000">以下是</span><span style="color:#000000">Timer2</span><span style="color:#000000">的运行结果，使用的是最粗糙的</span><span style="color:#000000">timeGetTime API<br> Begin Time: 20254254<br> End Time: 20255255<br> Lasting Time: 1001 </span><br><br><span style="color:#000000">以下是</span><span style="color:#000000">Timer3</span><span style="color:#000000">的运行结果，使用的是</span><span style="color:#000000">QueryPerformanceCount API<br> Frequency: 3579545<br> Begin Time: 3804729124<br> End Time: 3808298836<br> Lasting Time: 356971﻿2</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>