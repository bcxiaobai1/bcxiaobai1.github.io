<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>JavaSE（基础篇）——异常机制 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaSE（基础篇）——异常机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>每日一语：<span style="background-color:#a2e043">穿透石头的水滴，它的力量来源于日积月累</span></strong></p> 
</blockquote> 
<p><strong>前言：</strong></p> 
<p><strong>引用的狂神Java基础视频</strong>——<a class="link-info" href="https://www.bilibili.com/video/BV12J41137hu?p=1" title="狂神Java基础视频">狂神Java基础视频</a> </p> 
<p> <strong>目录</strong></p> 
<p id="%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-toc" style="margin-left:0px"><a href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" title="异常体系结构">异常体系结构</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB-toc" style="margin-left:0px"><a href="#%E5%BC%82%E5%B8%B8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB" title="异常之间的区别与联系">异常之间的区别与联系</a></p> 
<p id="1.Error-toc" style="margin-left:40px"><a href="#1.Error" title="1.Error">1.Error</a></p> 
<p id="2.Exception-toc" style="margin-left:40px"><a href="#2.Exception" title="2.Exception">2.Exception</a></p> 
<p id="3.%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%8D%E5%8F%97%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px"><a href="#3.%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%8D%E5%8F%97%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8" title="3.检查异常和不受检查异常">3.检查异常和不受检查异常</a></p> 
<p id="Java%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-toc" style="margin-left:0px"><a href="#Java%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8" title="Java处理异常">Java处理异常</a></p> 
<p id="1.try-catch-toc" style="margin-left:40px"><a href="#1.try-catch" title="1.try-catch">1.try-catch</a></p> 
<p id="2.throw-toc" style="margin-left:40px"><a href="#2.throw" title="2.throw">2.throw</a></p> 
<p id="3.throws-toc" style="margin-left:40px"><a href="#3.throws" title="3.throws">3.throws</a></p> 
<p id="4.finally-toc" style="margin-left:40px"><a href="#4.finally" title="4.finally">4.finally</a></p> 
<p id="try%20catch%20finally%20return%20%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-toc" style="margin-left:40px"><a href="#try%20catch%20finally%20return%20%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" title="try catch finally return 的执行顺序">try catch finally return 的执行顺序</a></p> 
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8-toc" style="margin-left:0px"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8" title="自定义异常">自定义异常</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px"><a href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></p> 
<hr id="hr-toc">
<p> </p> 
<h1 id="%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">异常体系结构</h1> 
<p>Java<span style="color:#333333">把异常当作对象来处理，并定义一个基类<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">java.lang.Throwable </span></span><span style="color:#333333">作为所有异常的超类。</span></p> 
<p>在<span style="color:#333333">Java API</span><span style="color:#333333">中已经定义了许多异常类，这些异常类分为两大类，</span><span style="color:#333333"><strong>错误</strong></span><span style="color:#333333"><strong>Error</strong></span><span style="color:#333333"><strong>和异常</strong></span><span style="color:#333333"><strong>Exception</strong></span><span style="color:#333333">。</span></p> 
<p>Java<span style="color:#333333">异常层次结构图：</span></p> 
<p><img alt="" height="719" src="https://images2.imgbox.com/43/c9/GK8gj0zv_o.png" width="1138"></p> 
<p>从图中<span style="color:#333333">可以看出所有异常类型都是内置类<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">Throwable </span></span><span style="color:#333333">的子类，因而<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">Throwable </span></span><span style="color:#333333">在异常类的层次结 构的顶层。</span></p> 
<p> 接下来<span style="color:#ffffff"><span style="background-color:#1a439c">Throwable </span></span><span style="color:#333333">分成了两个不同的分支，</span><span style="color:#333333"><strong>一个分支是</strong></span><span style="color:#333333"><strong>Error</strong></span><span style="color:#333333"><strong>，它表示不希望被程序捕获或者是程序 </strong></span><span style="color:#333333"><strong>无法处理的错误</strong></span><span style="color:#333333">。</span><span style="color:#333333"><strong>另一个分支是</strong></span><span style="color:#333333"><strong>Exception</strong></span><span style="color:#333333"><strong>，它表示用户程序可能捕捉的异常情况或者说是程序可以处</strong></span><span style="color:#333333"><strong>理的异常</strong></span><span style="color:#333333">。</span></p> 
<p>其中<span style="color:#333333">异常类<span style="background-color:#333333"> </span></span><span style="color:#ffffff"><span style="background-color:#333333">Exception </span></span><span style="color:#333333">又分为运行时异常</span>(<span style="color:#f3f3f4"><span style="background-color:#1c7331"> RuntimeException </span></span>)<span style="color:#333333">和非运行时异常。</span><span style="color:#333333">Java</span><span style="color:#333333">异常又可以 分为不受检查异常（<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">Unchecked Exception </span></span><span style="color:#333333">）和检查异常（<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">Checked Exception </span></span><span style="color:#333333">）。</span></p> 
<hr>
<p></p> 
<h1 id="%E5%BC%82%E5%B8%B8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB">异常之间的区别与联系</h1> 
<h2 id="1.Error"><strong>1.Error</strong></h2> 
<p><span style="color:#be191c"><strong>error类</strong></span><span style="color:#333333">对象由</span><span style="color:#333333"> Java </span><span style="color:#333333">虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</span></p> 
<p>比如所：</p> 
<p>Java<span style="color:#333333">虚拟机运行错误（ </span><span style="color:#ffffff"><span style="background-color:#1a439c">Virtual MachineError </span></span><span style="color:#333333">），当</span><span style="color:#333333">JVM</span><span style="color:#333333">不再有继续执行操作所需的内存资源时， 将出现<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">OutOfMemoryError </span></span><span style="color:#333333">。这些异常发生时，</span><span style="color:#333333">Java</span><span style="color:#333333">虚拟机（</span><span style="color:#333333">JVM</span><span style="color:#333333">）一般会选择线程终止； </span></p> 
<p> 还有<span style="color:#333333">发生在虚拟机试图执行应用时，如类定义错误（<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">NoClassDefFoundError </span></span><span style="color:#333333">）、链接错误 （<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">LinkageError </span></span><span style="color:#333333">）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大 多数是程序运行时不允许出现的状况。 </span></p> 
<p>对于<span style="color:#333333">设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在Java</span><span style="color:#333333">中，错误通常是使用<span style="background-color:#ad720d"> </span></span><span style="color:#ffffff"><span style="background-color:#ad720d">Error </span></span><span style="color:#333333">的子类描述。</span></p> 
<h2 id="2.Exception"><strong>2.Exception</strong></h2> 
<p></p> 
<p> 在<span style="color:#ffffff"><span style="background-color:#1c7892">Exception </span></span><span style="color:#333333">分支中有一个重要的子类<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">RuntimeException </span></span><span style="color:#333333">（运行时异常），该类型的异常自动 为你所编写的程序定义<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">ArrayIndexOutOfBoundsException </span></span><span style="color:#333333">（数组下标越界）</span><span style="color:#ffffff"><span style="background-color:#be191c">NullPointerException </span></span><span style="color:#333333">（空指针异常）、</span><span style="color:#ffffff"><span style="background-color:#1c7331">ArithmeticException </span></span><span style="color:#333333">（算术异常）、<span style="background-color:#be191c"> </span></span><span style="color:#ffffff"><span style="background-color:#be191c">MissingResourceException </span></span><span style="color:#333333">（丢失资源）、 </span><span style="color:#ffffff"><span style="background-color:#956fe7">ClassNotFoundException </span></span><span style="color:#333333">（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</span></p> 
<p></p> 
<p>这些<span style="color:#333333">异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而 </span><span style="color:#ffffff"><span style="background-color:#1c7331">RuntimeException </span></span><span style="color:#333333">之外的异常我们统称为非运行时异常，类型上属于<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">Exception </span></span><span style="color:#333333">类及其子类， 从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如</span><span style="color:#ffffff"><span style="background-color:#be191c">IOException </span></span><span style="color:#333333"><span style="background-color:#be191c">、 </span></span><span style="color:#ffffff"><span style="background-color:#be191c">SQLException </span></span><span style="color:#333333">等以及用户自定义的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">Exception </span></span><span style="color:#333333">异常，一般情况下不自定义检查异常。 </span></p> 
<p></p> 
<p> 注意：<span style="color:#ffffff"><span style="background-color:#1c7331">Error</span> </span><span style="color:#333333">和 </span><span style="color:#ffffff"><span style="background-color:#511b78">Exception </span></span><span style="color:#333333">的区别：<span style="background-color:#be191c"> </span></span><span style="color:#ffffff"><span style="background-color:#be191c">Error </span></span><span style="color:#333333">通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java</span><span style="color:#333333">虚拟机（</span><span style="color:#333333">JVM</span><span style="color:#333333">）一般会选择终止线程；<span style="background-color:#e6b223"> </span></span><span style="color:#ffffff"><span style="background-color:#e6b223">Exception</span> </span><span style="color:#333333">通常情况下是可 以被程序处理的，并且在程序中应该尽可能的去处理这些异常。 </span></p> 
<p></p> 
<h2 id="3.%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%8D%E5%8F%97%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><strong>3.<span style="color:#333333">检查异常和不受检查异常</span></strong></h2> 
<p>检查异常:<span style="color:#333333">在正确的程序运行过程中，很容易出现的、情理可容的异常状况，在一定程度上这种异常的发生是可以预测的，并且一旦发生该种异常，就必须采取某种方式进行处理。</span></p> 
<p>解析：<span style="color:#333333"><strong>除了</strong></span><span style="color:#333333"><strong>RuntimeException</strong></span><span style="color:#333333"><strong>及其子类以外，其他的</strong></span><span style="color:#333333"><strong>Exception</strong></span><span style="color:#333333"><strong>类及其子类都属于检查异常</strong></span><span style="color:#333333">，当程序中可能出现这类异常，<strong>要么使用</strong></span><span style="color:#333333"><strong>try-catch</strong></span><span style="color:#333333"><strong>语句进行捕获，要么用</strong></span><span style="color:#333333"><strong>throws</strong></span><span style="color:#333333"><strong>子句抛出</strong></span><span style="color:#333333">，否则编译无法通过。 </span></p> 
<p>不接受检查异常：<span style="color:#333333">包</span><span style="color:#333333"><strong>括</strong></span><span style="color:#333333"><strong>RuntimeException</strong></span><span style="color:#333333"><strong>及其子类和</strong></span><span style="color:#333333"><strong>Error</strong></span><span style="color:#333333">。</span></p> 
<p>分析：<span style="color:#ffffff"><span style="background-color:#1c7331">不受检查异常 </span></span><span style="color:#333333">为编译器不要求强制处理的异常，<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">检查异常 </span></span><span style="color:#333333">则是编译器要求必须处置的异常。</span></p> 
<hr>
<h1 id="Java%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">Java处理异常</h1> 
<h2 id="1.try-catch">1.try-catch</h2> 
<pre><code class="language-java">try{
//code that might generate exceptions 
}catch(Exception e){ 
//the code of handling exception1 
}catch(Exception e){ 
//the code of handling exception2 
}</code></pre> 
<p>要明白<span style="color:#333333">异常捕获，还要理解 </span><span style="color:#ffffff"><span style="background-color:#1c7331">监控区域 </span></span><span style="color:#333333">（guarded region</span><span style="color:#333333">）的概念。它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。</span></p> 
<p>因<span style="color:#333333">而可知，上述 </span><span style="color:#ffffff"><span style="background-color:#1c7331">try</span></span><span style="color:#ffffff"><span style="background-color:#1c7331">-</span></span><span style="color:#ffffff"><span style="background-color:#1c7331">catch </span></span><span style="color:#333333">所描述的即是监控区域，关键词<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">try </span></span><span style="color:#333333">后的一对大括号将一块可能发生异常的代码包起来，即为监控区域。Java</span><span style="color:#333333">方法在运行过程中发生了异常，则创建异常对象。</span></p> 
<p> 将<span style="color:#333333">异常抛出监控区域之外，由Java</span><span style="color:#333333">运行时系统负责寻找匹配的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句来捕获异常。若有一个 </span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">语句匹配到了，则执行该<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">块中的异常处理代码，就不再尝试匹配别的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">块了。</span></p> 
<p>匹配原则：<span style="color:#333333">如果抛出的异常对象属于<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句的异常类，或者属于该异常类的子类，则认为生成 的异常对象与<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">块捕获的异常类型相匹配。</span></p> 
<p></p> 
<pre><code class="language-java">public class TestException {
 public static void main(String[] args) {
 int a = 1; int b = 0;
 try {
 // try监控区域 
 if (b == 0) throw new ArithmeticException();
 // 通过throw语句抛出 异常
 System.out.println("a/b的值是：" + a / b);
 System.out.println("this will not be printed!");
 }catch (ArithmeticException e) {
 // catch捕捉异常
 System.out.println("程序出现异常，变量b不能为0！");
 }
System.out.println("程序正常结束。");
 } 
}
//输出 
程序出现异常，变量b不能为0！ 
程序正常结束。</code></pre> 
<p> 注意：<span style="color:#333333">显示一个异常的描述，<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">Throwable </span></span><span style="color:#333333">重载了<span style="background-color:#b95514"> </span></span><span style="color:#ffffff"><span style="background-color:#b95514">toString() </span></span><span style="color:#333333">方法（由 </span><span style="color:#ffffff"><span style="background-color:#1c7892">Object </span></span><span style="color:#333333">定义），所以它将返回一个包含异常描述的字符串。例如，将前面的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch</span> </span><span style="color:#333333">块重写成：</span></p> 
<pre><code class="language-java">catch (ArithmeticException e) { 
// catch捕捉异常 
System.out.println("程序出现异常"+e);
 }
//输出 程序出现异常java.lang.ArithmeticException 
程序正常结束。</code></pre> 
<p>算数<span style="color:#333333">异常属于运行时异常，因而实际上该异常不需要程序抛出，运行时系统自动抛出。如果不用try-catch程序就不会往下执行了。</span></p> 
<p></p> 
<pre><code class="language-java">public class TestException { 
public static void main(String[] args) { 
int a = 1; int b = 0; 
System.out.println("a/b的值是：" + a / b); 
System.out.println("this will not be printed!");
 } 
}
结果： Exception in thread "main" java.lang.ArithmeticException: / by zero 
at TestException.main(TestException.java:7)</code></pre> 
<p><strong>使用</strong><span style="color:#333333"><strong>多重的</strong></span><span style="color:#333333"><strong>catch</strong></span><span style="color:#333333"><strong>语句</strong></span><span style="color:#333333">：很多情况下，由单个的代码段可能引起多个异常。处理这种情况，我们需要定义两个或者更多的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句，每个子句捕获一种类型的异常，当异常被引发时，每个<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch</span> </span><span style="color:#333333">子句被依次检查，第一个匹配异常类型的子句执行，当一个<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句执行以后，其他的子句将被旁路。 </span></p> 
<p>编<span style="color:#333333">写多重</span><span style="color:#333333">catch</span><span style="color:#333333">语句块注意事项：</span></p> 
<blockquote> 
 <p><strong>顺序问题：</strong><span style="color:#333333"><strong>先小后大，即先子类后父类</strong> </span></p> 
</blockquote> 
<p><strong>注意：</strong></p> 
<p>Java<span style="color:#333333">通过异常类描述异常类型。对于有多个 </span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句的异常程序而言，应该尽量将捕获底层异常类的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句放在前面，同时尽量将捕获相对高层的异常类的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句放在后面。否则，捕获 底层异常类的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句将可能会被屏蔽。 </span></p> 
<p><strong>嵌套 try 语句：</strong><span style="color:#ffffff"><span style="background-color:#1c7892">try</span> </span><span style="color:#333333">语句可以被嵌套。也就是说，一个<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">语句可以在另一个<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">块的内部。每次进入<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">语句，异常的前后关系都会被推入堆栈。如果一个内部的<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">语句不含特殊异常的</span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">处理程序，堆栈将弹出，下一个<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">语句的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">处理程序将检查是否与之匹配。这个过程将继续直到一个 </span><span style="color:#ffffff"><span style="background-color:#511b78">catch</span> </span><span style="color:#333333">语句被匹配成功，或者是直到所有的嵌套<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">语句被检查完毕。如果没有<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">语句匹配，</span><span style="color:#333333">Java</span><span style="color:#333333">运行时系统将处理这个异常。 </span></p> 
<p></p> 
<pre><code class="language-java">class NestTry{ 
public static void main(String[] args){ 
   try{  
        int a = args.length; 
        int b = 42 / a; 
        System.out.println("a = "+ a);
        try{if(a == 1){
            a = a/(a-a);
 }
         if(a == 2){
             int c[] = {1};
             c[42] =99;
 } 
}catch(ArrayIndexOutOfBoundsException e){
       System.out.println("ArrayIndexOutOfBounds :"+e);
 }
}catch(ArithmeticException e){ 
       System.out.println("Divide by 0"+ e);
   } 
}
}
//分析运行： 
D:java&gt;java NestTry one 
a = 1 
Divide by 0java.lang.ArithmeticException: / by zero D:java&gt;java NestTry one two 
a = 2 
ArrayIndexOutOfBounds :java.lang.ArrayIndexOutOfBoundsException: 42</code></pre> 
<p><strong>分析</strong>：<span style="color:#333333">正如程序中所显示的，该程序在一个try</span><span style="color:#333333">块中嵌套了另一个<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">块。程序工作如下：当你在没 有命令行参数的情况下执行该程序，外面的<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">块将产生一个被</span><span style="color:#333333">0</span><span style="color:#333333">除的异常。</span></p> 
<p> 程序<span style="color:#333333">在有一个命令行参数条件下执行，由嵌套的<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">块产生一个被</span><span style="color:#333333">0</span><span style="color:#333333">除的异常，由于内部的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch</span> </span><span style="color:#333333">块不匹配这个异常，它将把异常传给外部的<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">块，在外部异常被处理。如果你在具有两个命令行参数的条件下执行该程序，将由内部<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">块产生一个数组边界异常。</span></p> 
<p><strong>注意</strong>：<span style="color:#333333">当有方法调用时， </span><span style="color:#ffffff"><span style="background-color:#1c7892">try</span> </span><span style="color:#333333">语句的嵌套可以很隐蔽的发生。例如，我们可以将对方法的调用放在一个<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">块中。在该方法的内部，有另一个<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">语句。</span></p> 
<p> 在这种情况下<span style="color:#333333">，方法内部的<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">仍然是嵌套在外部调用该方法的<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">块中的。下面我们将对上述例子进行修改，嵌套的<span style="background-color:#1c7892"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7892">try </span></span><span style="color:#333333">块移到方法</span><span style="color:#333333">nesttry()</span><span style="color:#333333">的内部：结果依旧相同！</span><br>  </p> 
<pre><code class="language-java">class NestTry{ 
static void nesttry(int a){ 
    try{if(a == 1){ 
        a = a/(a-a);
        }
    if(a == 2){ 
          int c[] = {1};
          c[42] =99;
    }
      }catch(ArrayIndexOutOfBoundsException e){ 
             System.out.println("ArrayIndexOutOfBounds :"+e);
          }
        }
        public static void main(String[] args){ 
             try{ 
                 int a = args.length; 
                 int b = 42 / a; 
                 System.out.println("a = "+ a); 
                 nesttry(a); }catch(ArithmeticException e){ 
                 System.out.println("Divide by 0"+ e);
      }
   } 
}</code></pre> 
<hr>
<h2 id="2.throw">2.throw</h2> 
<p>到目前为止，<span style="color:#333333">我们只是获取了被Java</span><span style="color:#333333">运行时系统引发的异常。然而，我们还可以用<span style="background-color:#1a439c"> </span></span><span style="color:#ffffff"><span style="background-color:#1a439c">throw </span></span><span style="color:#333333">语句抛出明确的异常。 </span></p> 
<p>语法形式：</p> 
<pre><code class="language-java">throw ThrowableInstance;</code></pre> 
<blockquote> 
 <p><strong>这<span style="color:#333333">里的ThrowableInstance</span><span style="color:#333333">一定是 </span><span style="color:#ffffff"><span style="background-color:#e6b223">Throwable</span> </span><span style="color:#333333">类类型或者 </span><span style="color:#ffffff"><span style="background-color:#e6b223">Throwable </span></span><span style="color:#333333">子类类型的一个对象。简单 的数据类型，例如<span style="background-color:#1a439c"> </span></span><span style="color:#ffffff"><span style="background-color:#1a439c">int </span></span><span style="color:#333333">，<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">char </span></span><span style="color:#333333">,</span><span style="color:#333333">以及非<span style="background-color:#e6b223"> </span></span><span style="color:#ffffff"><span style="background-color:#e6b223">Throwable</span> </span><span style="color:#333333">类，例如<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">String</span> </span><span style="color:#333333">或 </span><span style="color:#ffffff"><span style="background-color:#1a439c">Objec</span>t </span><span style="color:#333333">，不能用作异常。</span></strong></p> 
</blockquote> 
<p> 有<span style="color:#333333">两种方法可以获取<span style="background-color:#e6b223"> </span></span><span style="color:#ffffff"><span style="background-color:#e6b223">Throwable</span> </span><span style="color:#333333">对象：在<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句中使用参数或者使用<span style="background-color:#be191c"> </span></span><span style="color:#ffffff"><span style="background-color:#be191c">new </span></span><span style="color:#333333">操作符创建。程序执行完</span><span style="color:#1a439c"><strong> throw</strong> </span><span style="color:#333333">语句之后立即停止；<span style="background-color:#1a439c"> </span></span><span style="color:#ffffff"><span style="background-color:#1a439c">throw </span></span><span style="color:#333333">后面的任何语句不被执行，最邻近的</span><span style="color:#1c7331"> try </span><span style="color:#333333">块用来检查它是否含有一个与异常类型匹配的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch</span> </span><span style="color:#333333">语句。</span></p> 
<p>如果<span style="color:#333333">发现了匹配的块，控制转向该语句；如果没有发现，次包围的<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">try </span></span><span style="color:#333333">块来检查，以此类推。如果没有发现匹配的<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">块，默认异常处理程序中断程序的执行并且打印堆栈轨迹。</span></p> 
<p> </p> 
<pre><code class="language-java">class TestThrow{ 
    static void proc(){ 
        try{
            throw new NullPointerException("demo");
        }catch(NullPointerException e){ 
            System.out.println("Caught inside proc");
            throw e;
        } 
    }
    public static void main(String [] args){
        try{proc();
         }catch(NullPointerException e){ 
            System.out.println("Recaught: "+e);
        }
    } 
}</code></pre> 
<p>该程<span style="color:#333333">序两次处理相同的错误，首先， </span><span style="color:#ffffff"><span style="background-color:#be191c">main() </span></span><span style="color:#333333">方法设立了一个异常关系然后调用</span><span style="color:#333333">proc()</span><span style="color:#333333">。</span><span style="color:#333333">proc()</span><span style="color:#333333">方法设立了另一个异常处理关系并且立即抛出一个<span style="background-color:#494949"> </span></span><span style="color:#ffffff"><span style="background-color:#494949">NullPointerException </span></span><span style="color:#333333">实例，</span><span style="color:#ffffff"><span style="background-color:#511b78">NullPointerException</span> </span><span style="color:#333333">在<span style="background-color:#be191c"> </span></span><span style="color:#ffffff"><span style="background-color:#be191c">main()</span> </span><span style="color:#333333">中被再次捕获。</span></p> 
<p> 该<span style="color:#333333">程序阐述了怎样创建</span><span style="color:#333333">Java</span><span style="color:#333333">的标准异常对象，特别注意这一行： </span></p> 
<pre><code class="language-java">throw new NullPointerException("demo");</code></pre> 
<p>分析：<span style="color:#333333">此处<span style="background-color:#ad720d"> </span></span><span style="color:#ffffff"><span style="background-color:#ad720d">new</span> </span><span style="color:#333333">用来构造一个<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">NullPointerException </span></span><span style="color:#333333">实例，所有的</span><span style="color:#333333">Java</span><span style="color:#333333">内置的运行时异常有两 </span></p> 
<div>
 <span style="color:#333333">个构造方法：一个没有参数，一个带有一个字符串参数。</span>
</div> 
<p> </p> 
<p>当<span style="color:#333333">用第二种形式时，参数指定描述异常的字符串。如果对象用作<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">print() </span></span><span style="color:#333333">或者<span style="background-color:#98c091"> </span></span><span style="color:#ffffff"><span style="background-color:#98c091">println() </span></span><span style="color:#333333">的参数时，该字符串被显示。这同样可以通过调用getMessage()</span><span style="color:#333333">来实现，</span><span style="color:#333333">getMessage()</span><span style="color:#333333">是由<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">Throwable</span> </span><span style="color:#333333">定义的。</span></p> 
<p> </p> 
<hr>
<h2 id="3.throws">3.throws</h2> 
<p>如果<span style="color:#333333">一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。要做到这点，我们可以在方法声明中包含一个<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">throws </span></span><span style="color:#333333">子句。 </span></p> 
<p>一个<span style="color:#ffffff"><span style="background-color:#1c7331">throws </span></span><span style="color:#333333">子句列举了一个方法可能引发的所有异常类型。这对于除了<span style="background-color:#be191c"> </span></span><span style="color:#ffffff"><span style="background-color:#be191c">Error </span></span><span style="color:#333333">或</span><span style="color:#ffffff"><span style="background-color:#1a439c">RuntimeException </span></span><span style="color:#333333">及它们子类以外类型的所有异常是必要的。一个方法可以引发的所有其他类型的异常必须在<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">throws </span></span><span style="color:#333333">子句中声明，否则会导致编译错误。 </span></p> 
<p> </p> 
<pre><code class="language-java">public void info() throws Exception {
 //body of method 
}</code></pre> 
<p>Exception<span style="color:#333333">是该方法可能引发的所有的异常</span><span style="color:#333333">,</span><span style="color:#333333">也可以是异常列表，中间以逗号隔开。</span> </p> 
<p>【例子】</p> 
<pre><code class="language-java">class TestThrows{
    static void throw1(){
        System.out.println("Inside throw1 . ");
        throw new IllegalAccessException("demo");
    }
    public static void main(String[] args){ throw1();
    }
}</code></pre> 
<p>该<span style="color:#333333">例子中存在两个错误，首先，throw1()</span><span style="color:#333333">方法不想处理所导致的异常，因而它必须声明 </span><span style="color:#ffffff">throws </span><span style="color:#333333">子句来列举可能引发的异常即<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">IllegalAccessException </span></span><span style="color:#333333">；其次，<span style="background-color:#be191c"> </span></span><span style="color:#ffffff"><span style="background-color:#be191c">main()</span> </span><span style="color:#333333">方法必须定义</span><span style="color:#ffffff"><span style="background-color:#333333">try/catch </span></span><span style="color:#333333">语句来捕获该异常。</span></p> 
<p> 正确例子如下：</p> 
<pre><code class="language-java">class TestThrows{ 
    static void throw1() throws IllegalAccessException { 
        System.out.println("Inside throw1 . ");
        throw new IllegalAccessException("demo");
    }
    public static void main(String[] args){ 
        try {
            throw1();
        }catch(IllegalAccessException e ){ 
            System.out.println("Caught " + e);
        }
    } 
}</code></pre> 
<p><span style="color:#be191c"><strong> throws抛出异常规则</strong></span></p> 
<blockquote> 
 <p><strong>1.如果<span style="color:#333333">是不受检查异常（<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">unchecked exception </span></span><span style="color:#333333">），即<span style="background-color:#1a439c"> </span></span><span style="color:#ffffff"><span style="background-color:#1a439c">Error </span></span><span style="color:#333333">、<span style="background-color:#ad720d"> </span></span><span style="color:#ffffff"><span style="background-color:#ad720d">RuntimeException </span></span><span style="color:#333333">或它们的子类，那么可以不使用<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">throws</span> </span><span style="color:#333333">关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</span></strong></p> 
 <p><strong><span style="color:#333333">2.必须声明方法可抛出的任何检查异常（<span style="background-color:#ad720d"> </span></span><span style="color:#ffffff"><span style="background-color:#ad720d">checked exception </span></span><span style="color:#333333">）。即如果一个方法可能出现受可查异常，要么用<span style="background-color:#333333"> </span></span><span style="color:#ffffff"><span style="background-color:#333333">try</span></span><span style="color:#ffffff"><span style="background-color:#333333">-</span></span><span style="color:#ffffff"><span style="background-color:#333333">catch </span></span><span style="color:#333333">语句捕获，要么用<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">throws </span></span><span style="color:#333333">子句声明将它抛出，否则会导致编译错误。</span></strong></p> 
 <p><strong><span style="color:#333333">3.仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</span></strong></p> 
 <p><strong>4.<span style="color:#333333">调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。 </span></strong></p> 
</blockquote> 
<hr>
<p> </p> 
<h2 id="4.finally">4.finally</h2> 
<p>当<span style="color:#333333">异常发生时，通常方法的执行将做一个陡峭的非线性的转向，它甚至会过早的导致方法返回。例如，如果一个方法打开了一个文件并关闭，然后退出，你不希望关闭文件的代码被异常处理机制旁路。</span><span style="color:#f3f3f4"><span style="background-color:#1c7892">finally </span></span><span style="color:#333333">关键字为处理这种意外而设计。</span></p> 
<p><span style="color:#1c7331"><strong>finally</strong></span><span style="color:#333333">创建的代码块在<span style="background-color:#333333"> </span></span><span style="color:#ffffff"><span style="background-color:#333333">try/catch</span> </span><span style="color:#333333">块完成之后另一个<span style="background-color:#333333"> </span></span><span style="color:#ffffff"><span style="background-color:#333333">try/catch </span></span><span style="color:#333333">出现之前执行。</span></p> 
<p><span style="color:#1c7331"><strong>finally</strong></span><span style="color:#333333">块无论有没有异常抛出都会执行。如果抛出异常，即使没有<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">子句匹配，</span><span style="color:#1c7331">finally </span><span style="color:#333333">也会执行。</span></p> 
<p><span style="color:#333333">一个方法将从一个<span style="background-color:#333333"> </span></span><span style="color:#ffffff"><span style="background-color:#333333">try/catch</span> </span><span style="color:#333333">块返回到调用程序的任何时候，经过一个未捕获的异常或者是一个明 确的返回语句，<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">finally </span></span><span style="color:#333333">子句在方法返回之前仍将执行。这在关闭文件句柄和释放任何在方法开始时 被分配的其他资源是很有用。</span></p> 
<p>注意：<span style="color:#ffffff"><span style="background-color:#1c7331">finally </span></span><span style="color:#333333">子句是可选项，可以有也可以无，但是每个 </span><span style="color:#ffffff"><span style="background-color:#1a439c">try </span></span><span style="color:#333333">语句至少需要一个<span style="background-color:#511b78"> </span></span><span style="color:#ffffff"><span style="background-color:#511b78">catch </span></span><span style="color:#333333">或者 </span><span style="color:#ffffff"><span style="background-color:#1c7331">finally </span></span><span style="color:#333333">子句。</span></p> 
<p><span style="color:#333333">【例子】</span></p> 
<pre><code class="language-java">class TestFinally{
    static void proc1(){
        try{System.out.println("inside proc1");
            throw new RuntimeException("demo");
        }finally{
            System.out.println("proc1's finally");
        }
    }
    static void proc2(){
        try{System.out.println("inside proc2");
            return ;
        } finally{
            System.out.println("proc2's finally");
        }
    }
    static void proc3(){
        try{
            System.out.println("inside proc3");
        }finally{
            System.out.println("proc3's finally");
        }
    }
    public static void main(String [] args){
        try{
            proc1();
        }catch(Exception e){
            System.out.println("Exception caught");
        }
        proc2();
        proc3();
    }
}</code></pre> 
<p> 【结果】</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/f7/bf/HhAjCdPX_o.png" width="556"></p> 
<p> </p> 
<p>注：<span style="color:#333333">如果<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">finally </span></span><span style="color:#333333">块与一个<span style="background-color:#1a439c"> </span></span><span style="color:#ffffff"><span style="background-color:#1a439c">try </span></span><span style="color:#333333">联合使用， </span><span style="color:#ffffff"><span style="background-color:#1c7331">finally</span> </span><span style="color:#333333">块将在<span style="background-color:#1a439c"> </span></span><span style="color:#ffffff"><span style="background-color:#1a439c">try </span></span><span style="color:#333333">结束之前执行。 </span> </p> 
<hr>
<h2 id="try%20catch%20finally%20return%20%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">try catch finally return 的执行顺序</h2> 
<blockquote> 
 <p><strong>1.<span style="color:#333333">执行</span><span style="color:#333333">try</span><span style="color:#333333">，</span><span style="color:#333333">catch </span><span style="color:#333333">， 给返回值赋值 </span></strong></p> 
 <p><strong>2.<span style="color:#333333">执行</span><span style="color:#333333">finally</span></strong></p> 
 <p><strong>3.<span style="color:#333333">return</span></strong></p> 
</blockquote> 
<h1 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">自定义异常</h1> 
<p>使用<span style="color:#333333">Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承<span style="background-color:#1a439c"> </span></span><span style="color:#ffffff"><span style="background-color:#1a439c">Exception </span></span><span style="color:#333333">类即可。 </span></p> 
<p> 在<span style="color:#333333">程序中使用自定义异常类，大体可分为以下几个步骤</span><span style="color:#333333">:</span></p> 
<blockquote> 
 <p><strong>1.<span style="color:#333333">创建自定义异常类。</span></strong></p> 
 <p><strong><span style="color:#333333">2.在方法中通过<span style="background-color:#ad720d"> </span></span><span style="color:#ffffff"><span style="background-color:#ad720d">throw </span></span><span style="color:#333333">关键字抛出异常对象。</span></strong></p> 
 <p><strong><span style="color:#333333">3.如果在当前抛出异常的方法中处理异常，可以使用<span style="background-color:#333333"> </span></span><span style="color:#ffffff"><span style="background-color:#333333">try</span></span><span style="color:#ffffff"><span style="background-color:#333333">-</span></span><span style="color:#ffffff"><span style="background-color:#333333">catch </span></span><span style="color:#333333">语句捕获并处理；否则在方法的声明处通过<span style="background-color:#1c7331"> </span></span><span style="color:#ffffff"><span style="background-color:#1c7331">throws </span></span><span style="color:#333333">关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</span></strong></p> 
 <p><strong>4.<span style="color:#333333">在出现异常方法的调用者中捕获并处理异常。</span> </strong></p> 
</blockquote> 
<p>【举例】</p> 
<pre><code class="language-java">class MyException extends Exception {
    private int detail;
    MyException(int a){
        detail = a;
    }
    public String toString(){
        return "MyException ["+ detail + "]";
    }
}
class TestMyException{
    static void compute(int a) throws MyException{
        System.out.println("Called compute(" + a + ")");
        if(a &gt; 10){ throw new MyException(a);
        }
        System.out.println("Normal exit!");
    }
    public static void main(String [] args){
        try{
            compute(1);
            compute(20);
        } catch(MyException me){
            System.out.println("Caught " + me);
        }
    }
}</code></pre> 
<p> <img alt="" height="231" src="https://images2.imgbox.com/89/8e/BYHUIWGi_o.png" width="830"></p> 
<p> </p> 
<hr>
<h1 id="%E6%80%BB%E7%BB%93">总结</h1> 
<p><img alt="" height="835" src="https://images2.imgbox.com/7f/b7/zdRaiOOT_o.png" width="1135"></p> 
<p> </p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>