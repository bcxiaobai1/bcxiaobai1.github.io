<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【项目实战】日志系统 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【项目实战】日志系统</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px"><a href="#%E5%89%8D%E8%A8%80">前言</a></p> 
<p id="%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-toc" style="margin-left:0px"><a href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">整体架构</a></p> 
<p id="%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px"><a href="#%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0">工具类的实现</a></p> 
<p id="%E6%97%A5%E6%9C%9F%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%97%A5%E6%9C%9F%E7%B1%BB">日期类</a></p> 
<p id="%E6%96%87%E4%BB%B6%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%96%87%E4%BB%B6%E7%B1%BB">文件类</a></p> 
<p id="%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8-toc" style="margin-left:40px"><a href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8">判断文件存在</a></p> 
<p id="%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84-toc" style="margin-left:40px"><a href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">获取文件路径</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95-toc" style="margin-left:40px"><a href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95">创建目录</a></p> 
<p id="%E6%97%A5%E5%BF%97%E7%AD%89%E7%BA%A7%E7%9A%84%E8%A7%84%E5%88%92-toc" style="margin-left:0px"><a href="#%E6%97%A5%E5%BF%97%E7%AD%89%E7%BA%A7%E7%9A%84%E8%A7%84%E5%88%92">日志等级的规划</a></p> 
<p id="%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px"><a href="#%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF%E6%A8%A1%E5%9D%97">日志信息模块</a></p> 
<p id="%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px"><a href="#%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9D%97">消息格式化模块</a></p> 
<p id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px"><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%BB%84%E4%BB%B6">格式化组件</a></p> 
<p id="%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB-toc" style="margin-left:80px"><a href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB">抽象基类</a></p> 
<p id="%E6%B4%BE%E7%94%9F%E5%AD%90%E7%B1%BB-toc" style="margin-left:80px"><a href="#%E6%B4%BE%E7%94%9F%E5%AD%90%E7%B1%BB">派生子类</a></p> 
<p id="%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%90%E7%B1%BB%C2%A0-toc" style="margin-left:120px"><a href="#%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%90%E7%B1%BB%C2%A0">日期格式化子类 </a></p> 
<p id="%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%90%E7%B1%BB-toc" style="margin-left:120px"><a href="#%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%90%E7%B1%BB">其他内容格式化子类</a></p> 
<p id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB">格式化类</a></p> 
<p id="%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px"><a href="#%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1">根据字符创建不同对象</a></p> 
<p id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%90-toc" style="margin-left:80px"><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%90">格式化字符串的解析</a></p> 
<p id="%E5%87%BD%E6%95%B0%E6%95%B4%E4%BD%93-toc" style="margin-left:120px"><a href="#%E5%87%BD%E6%95%B0%E6%95%B4%E4%BD%93">函数整体</a></p> 
<p id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0">格式化函数</a></p> 
<p id="%E6%97%A5%E5%BF%97%E8%90%BD%E5%9C%B0%E7%B1%BB%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px"><a href="#%E6%97%A5%E5%BF%97%E8%90%BD%E5%9C%B0%E7%B1%BB%E6%A8%A1%E5%9D%97">日志落地类模块</a></p> 
<p id="%E5%9F%BA%E7%B1%BB%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px"><a href="#%E5%9F%BA%E7%B1%BB%E5%AE%9E%E7%8E%B0">基类实现</a></p> 
<p id="%E6%A0%87%E5%87%86%E8%90%BD%E5%9C%B0%E5%AD%90%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%A0%87%E5%87%86%E8%90%BD%E5%9C%B0%E5%AD%90%E7%B1%BB">标准落地子类</a></p> 
<p id="%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%AD%90%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%AD%90%E7%B1%BB">文件落地子类</a></p> 
<p id="%E6%BB%9A%E5%8A%A8%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%AD%90%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%BB%9A%E5%8A%A8%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%AD%90%E7%B1%BB">滚动文件落地子类</a></p> 
<p id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></p> 
<p id="%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%93%E5%B1%95%E5%90%8D-toc" style="margin-left:80px"><a href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%93%E5%B1%95%E5%90%8D">获取文件的拓展名</a></p> 
<p id="%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99-toc" style="margin-left:80px"><a href="#%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">虚函数重写</a></p> 
<p id="%E8%90%BD%E5%9C%B0%E7%B1%BB%E5%B7%A5%E5%8E%82-toc" style="margin-left:40px"><a href="#%E8%90%BD%E5%9C%B0%E7%B1%BB%E5%B7%A5%E5%8E%82">落地类工厂</a></p> 
<p id="%E6%97%A5%E5%BF%97%E5%99%A8%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px"><a href="#%E6%97%A5%E5%BF%97%E5%99%A8%E6%A8%A1%E5%9D%97">日志器模块</a></p> 
<p id="%E6%97%A5%E5%BF%97%E5%99%A8%E5%9F%BA%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%97%A5%E5%BF%97%E5%99%A8%E5%9F%BA%E7%B1%BB">日志器基类</a></p> 
<p id="%E6%97%A5%E5%BF%97%E5%99%A8%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#%E6%97%A5%E5%BF%97%E5%99%A8%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">日志器外部接口实现</a></p> 
<p id="%E5%9F%BA%E7%B1%BB%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px"><a href="#%E5%9F%BA%E7%B1%BB%E4%BB%A3%E7%A0%81">基类代码</a></p> 
<p id="%E5%90%8C%E6%AD%A5%E6%97%A5%E5%BF%97%E5%99%A8-toc" style="margin-left:40px"><a href="#%E5%90%8C%E6%AD%A5%E6%97%A5%E5%BF%97%E5%99%A8">同步日志器</a></p> 
<p id="%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E5%99%A8-toc" style="margin-left:40px"><a href="#%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E5%99%A8">异步日志器</a></p> 
<p id="%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B-toc" style="margin-left:80px"><a href="#%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B">异步工作线程</a></p> 
<p id="%E7%BC%93%E5%86%B2%E5%8C%BA-toc" style="margin-left:120px"><a href="#%E7%BC%93%E5%86%B2%E5%8C%BA">缓冲区</a></p> 
<p id="%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-toc" style="margin-left:160px"><a href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C">缓冲区的基础操作</a></p> 
<p id="%E4%BF%9D%E8%AF%81%E8%B6%B3%E5%A4%9F%E7%A9%BA%E9%97%B4%E5%86%99%E5%85%A5-toc" style="margin-left:160px"><a href="#%E4%BF%9D%E8%AF%81%E8%B6%B3%E5%A4%9F%E7%A9%BA%E9%97%B4%E5%86%99%E5%85%A5">保证足够空间写入</a></p> 
<p id="%E5%90%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:160px"><a href="#%E5%90%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">向缓冲区插入数据</a></p> 
<p id="%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA-toc" style="margin-left:120px"><a href="#%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA">开始搭建</a></p> 
<p id="%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5-toc" style="margin-left:160px"><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">生产者的数据写入</a></p> 
<p id="%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-toc" style="margin-left:160px"><a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">消费者的数据处理</a></p> 
<p id="%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">外部函数的实现</a></p> 
<p id="%E6%97%A5%E5%BF%97%E5%99%A8%E5%BB%BA%E9%80%A0%E8%80%85-toc" style="margin-left:40px"><a href="#%E6%97%A5%E5%BF%97%E5%99%A8%E5%BB%BA%E9%80%A0%E8%80%85">日志器建造者</a></p> 
<p id="%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB-toc" style="margin-left:80px"><a href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB">抽象基类</a></p> 
<p id="%E5%B1%80%E9%83%A8%E6%97%A5%E5%BF%97%E5%99%A8%E5%BB%BA%E9%80%A0-toc" style="margin-left:80px"><a href="#%E5%B1%80%E9%83%A8%E6%97%A5%E5%BF%97%E5%99%A8%E5%BB%BA%E9%80%A0">局部日志器建造</a></p> 
<p id="%E5%85%A8%E5%B1%80%E6%97%A5%E5%BF%97%E5%99%A8%E5%BB%BA%E9%80%A0%E8%80%85-toc" style="margin-left:80px"><a href="#%E5%85%A8%E5%B1%80%E6%97%A5%E5%BF%97%E5%99%A8%E5%BB%BA%E9%80%A0%E8%80%85">全局日志器建造者</a></p> 
<p id="%E6%97%A5%E5%BF%97%E5%99%A8%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px"><a href="#%E6%97%A5%E5%BF%97%E5%99%A8%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97">日志器管理模块</a></p> 
<p id="%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96-toc" style="margin-left:40px"><a href="#%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96">单例对象的获取</a></p> 
<p id="%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86-toc" style="margin-left:40px"><a href="#%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86">日志器的管理</a></p> 
<p id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></p> 
<p id="%E4%BB%A3%E7%90%86%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px"><a href="#%E4%BB%A3%E7%90%86%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%A3">代理日志器的接口</a></p> 
<p id="%E6%8F%90%E4%BE%9B%E6%8C%87%E5%AE%9A%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E5%85%A8%E5%B1%80%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px"><a href="#%E6%8F%90%E4%BE%9B%E6%8C%87%E5%AE%9A%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E5%85%A8%E5%B1%80%E6%8E%A5%E5%8F%A3">提供指定日志器的全局接口</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%87%BD%E6%95%B0%E5%AF%B9%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%90%86-toc" style="margin-left:80px"><a href="#%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%87%BD%E6%95%B0%E5%AF%B9%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%90%86">使用宏函数对日志器的接口进行代理</a></p> 
<p id="%E6%8F%90%E4%BE%9B%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA-toc" style="margin-left:80px"><a href="#%E6%8F%90%E4%BE%9B%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA">提供宏函数直接进行日志的标准输出</a></p> 
<p id="%E6%8B%93%E5%B1%95-toc" style="margin-left:0px"><a href="#%E6%8B%93%E5%B1%95">拓展</a></p> 
<p id="%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px"><a href="#%E6%B5%8B%E8%AF%95">测试</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px"><a href="#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">测试函数的实现</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%C2%A0-toc" style="margin-left:40px"><a href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%C2%A0">测试结果 </a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px"><a href="#%E6%80%BB%E7%BB%93">总结</a></p> 
<p id="%E6%BA%90%E7%A0%81-toc" style="margin-left:0px"><a href="#%E6%BA%90%E7%A0%81">源码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p><span style="color:#9c8ec1"><strong>一般而言，业务的服务都是周而复始的运行，若程序出现问题而未进行记录，则在后期修复时会出现无从下手的情况。</strong></span></p> 
<p><span style="color:#9c8ec1"><strong>因此，本次我们将实现一个日志系统用于记录程序运行状态的信息，以便程序员随时根据信息进行分析。</strong></span></p> 
<p><span style="color:#9c8ec1"><strong>该系统拥有以下功能：</strong></span></p> 
<ul>
<li><span style="color:#1c7892"><strong>支持多级别日志消息</strong></span></li>
<li><span style="color:#1c7892"><strong>支持同步日志和异步日志</strong></span></li>
<li><span style="color:#1c7892"><strong>支持可靠写入日志到控制台、文件和滚动文件中</strong></span></li>
<li><span style="color:#1c7892"><strong>支持多线程程序并发写日志</strong></span></li>
<li><span style="color:#1c7892"><strong>支持拓展不同的日志落地方向</strong></span></li>
</ul> 
<h2 id="%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">整体架构</h2> 
<p><strong>?<span style="color:#79c6cd">一个项目的实现，离不开各个模块的共同合作，我们将根据功能划分几个模块。</span></strong></p> 
<ul>
<li><span style="color:#1c7892"><strong>日志信息模块：记录日志输出所需的相关信息</strong></span></li>
<li><span style="color:#1c7892"><strong>消息格式化模块：设置日志输出格式，并提供对日志信息进行格式化</strong></span></li>
<li><span style="color:#1c7892"><strong>日志落地模块：将格式化文成后的日志消息字符串输出到指定的位置</strong></span></li>
<li><span style="color:#1c7892"><strong>日志器模块：由以上模块组建，进行各个等级日志的输出操作</strong></span></li>
<li><span style="color:#1c7892"><strong>日志器管理模块：对所有创建的日志器进行管理</strong></span></li>
</ul> 
<p><strong>?<span style="color:#6eaad7">接下来就一起来看看代码实现吧。</span></strong></p> 
<h2 id="%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0">工具类的实现</h2> 
<p><strong>?<span style="color:#79c6cd">在落实具体模块前，我们先对常用的工具类进行一个实现。</span></strong></p> 
<h3 id="%E6%97%A5%E6%9C%9F%E7%B1%BB">日期类</h3> 
<p><strong>?<span style="color:#79c6cd">在之后的日志输出中，我们便经常需要使用到时间这个信息，所以将其封装起来，之后直接调用即可。</span></strong></p> 
<pre><code class="language-cpp">namespace Alpaca
{
    namespace util
    {
        class Date
        {
        public:
            static time_t now()
            {
                return time(nullptr);
            }
        };
    }
}</code></pre> 
<h3 id="%E6%96%87%E4%BB%B6%E7%B1%BB">文件类</h3> 
<h3 id="%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8">判断文件存在</h3> 
<p><strong>?<span style="color:#79c6cd">有一个结构体叫做 </span><span style="color:#9c8ec1">stat</span></strong><span style="color:#79c6cd"><strong> </strong><strong>用于记录文件的状态，我们可以试图通过</strong></span><span style="color:#9c8ec1"><strong>获取文件状态</strong></span><span style="color:#79c6cd"><strong>来验证该文件是否存在。</strong></span></p> 
<p><strong>?<span style="color:#79c6cd">或是使用 Linux 下的 </span><span style="color:#9c8ec1">acces</span></strong><span style="color:#79c6cd"><strong>s</strong><strong> 函数同样也能够达到同样的效果。</strong></span></p> 
<pre><code class="language-cpp">static bool exists(const std::string &amp;pathname)
{
    // 多操作系统共用
    struct stat st;
    if (stat(pathname.c_str(), &amp;st) &lt; 0)
        return false;

    return true;

    // Linux专用
    // return access(pathname.c_str(), F_OK) == 0;
}
</code></pre> 
<h3 id="%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">获取文件路径</h3> 
<p><span style="color:#79c6cd"><strong>?对于一个整体文件名而言，从末尾开始第一个</strong><strong> </strong></span><span style="color:#9c8ec1"><strong>/(Linux)</strong></span><span style="color:#79c6cd"><strong> </strong><strong>或</strong><strong> </strong></span><span style="color:#9c8ec1"><strong>(Windows) </strong></span><span style="color:#79c6cd"><strong>前的字符串都是文件的路径。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?所以我们只要检索对应的字符，之前的字符串便是该文件的路径。若查找不到对应字符则说明该文件是存在</strong></span><span style="color:#9c8ec1"><strong>根目录</strong></span><span style="color:#79c6cd"><strong>下。</strong></span></p> 
<pre><code class="language-cpp">static std::string path(const std::string &amp;pathname)
{
    size_t pos = pathname.find_last_of("/\");    //匹配其中的任意字符
    if (pos == std::string::npos)
        return ".";        //返回根目录
    return pathname.substr(0, pos + 1);            //截取对应的字符串
}</code></pre> 
<h3 id="%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95">创建目录</h3> 
<p><strong>?<span style="color:#79c6cd">这个接口我们需要根据传进来的路径进行目录的创建，而创建一个文件需要</span><span style="color:#9c8ec1">保证前路径的目录存在</span></strong><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?因此，我们从头开始遍历路径名，若找到</strong><strong> /</strong><strong> 或</strong><strong> </strong><strong> 便能确定前路径的目录，我们需要</strong></span><span style="color:#9c8ec1"><strong>判断该目录是否存在，若不存在则创建</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?当再找不到前路径便可以直接创建目标目录。</strong></span></p> 
<pre><code class="language-cpp">static void create_directory(const std::string&amp; pathname)
{
    if (pathname.empty())        //路径为空
        return;
    if (exists(pathname))        //路径已存在
        return;
    size_t pos = 0, idx = 0;
    while (idx &lt; pathname.size())
    {
        pos = pathname.find_first_of("/\", idx);
        if (pos == std::string::npos)    //已无前路径,直接创建目录
        {
            mkdir(pathname.c_str(), 0755);    //记得设置文件权限
            return;
        }
        if (pos == idx)        //避免符号连续的情况
        {
            idx = pos + 1;
            continue;
        }

        std::string parent_dir = pathname.substr(0, pos);    //截取前路径
        if (parent_dir == "." || parent_dir == "..")      // . 或 .. 必定存在不用考虑
        {
            idx = pos + 1;
            continue;
        }

        if (exists(parent_dir))        //判断前路径是否存在
        {
            idx = pos + 1;
            continue;
        }
        mkdir(pathname.c_str(), 0755);    //创建前路径
        idx = pos + 1;                    //迭代
    }
}</code></pre> 
<h2 id="%E6%97%A5%E5%BF%97%E7%AD%89%E7%BA%A7%E7%9A%84%E8%A7%84%E5%88%92">日志等级的规划</h2> 
<p><strong>?<span style="color:#79c6cd">我们创建一个日志等级类，在其中使用枚举设定出不同的日志等级。</span></strong></p> 
<p><span style="color:#79c6cd"><strong>?由于我们都是以字符串的形式在外部使用，因而还需要实现一个函数用于枚举类型与字符串间的转换。</strong></span></p> 
<pre><code class="language-cpp">namespace Alpaca
{
    class LogLevel
    {
    public:
        enum value
        {
            UNKNOW = 0,
            DEBUG,
            INFO,
            WARN,
            ERROR,
            FATAL,
            OFF
        };

        static const char *Tostring(LogLevel::value level)
        {
            switch (level)
            {
            case LogLevel::value::DEBUG:
                return "DEBUG";
            case LogLevel::value::INFO:
                return "INFO";
            case LogLevel::value::WARN:
                return "WARN";
            case LogLevel::value::ERROR:
                return "ERROR";
            case LogLevel::value::FATAL:
                return "FATAL";
            case LogLevel::value::OFF:
                return "OFF";
            }
            return "UNKNOW";
        }
    };
}</code></pre> 
<h2 id="%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF%E6%A8%A1%E5%9D%97">日志信息模块</h2> 
<p><span style="color:#79c6cd"><strong>?该模块用于存储记录</strong></span><span style="color:#9c8ec1"><strong>日志输出所需的相关信息</strong></span><span style="color:#79c6cd"><strong>，根据使用的需要可以列举出以下信息：</strong></span></p> 
<ul>
<li>
<span style="color:#1c7892"><strong>输出时间：</strong></span><span style="color:#9c8ec1"><strong>_time</strong></span>
</li>
<li>
<span style="color:#1c7892"><strong>日志等级：</strong></span><span style="color:#9c8ec1"><strong>_level</strong></span>
</li>
<li>
<span style="color:#1c7892"><strong>源文件名称：</strong></span><span style="color:#9c8ec1"><strong>_file</strong></span>
</li>
<li>
<span style="color:#1c7892"><strong>源文件行号：</strong></span><span style="color:#9c8ec1"><strong>_line</strong></span>
</li>
<li>
<span style="color:#1c7892"><strong>线程id：</strong></span><span style="color:#9c8ec1"><strong>_tid</strong></span>
</li>
<li>
<span style="color:#1c7892"><strong>日志的主体信息：</strong></span><span style="color:#9c8ec1"><strong>_logger</strong></span>
</li>
<li>
<span style="color:#1c7892"><strong>日志器名称：</strong></span><span style="color:#9c8ec1"><strong>_payload</strong></span>
</li>
</ul> 
<p><strong>?<span style="color:#79c6cd">而对应的构造函数只需要将对应的信息依次填入成员变量中即可。</span></strong></p> 
<pre><code class="language-cpp">namespace Alpaca
{
    struct LogMsg
    {
        time_t _time;
        LogLevel::value _level;
        std::string _file;
        size_t _line;
        std::thread::id _tid;
        std::string _logger;
        std::string _payload;

        LogMsg(LogLevel::value level, std::string file, size_t line,
               std::string logger, std::string msg)
            : _time(util::Date::now()), _level(level), _file(file)
            , _line(line), _tid(std::this_thread::get_id())
            , _logger(logger), _payload(msg){}
    };
}</code></pre> 
<h2 id="%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9D%97">消息格式化模块</h2> 
<p><span style="color:#79c6cd"><strong>?平时我们在使用 printf 时也常常进行</strong></span><span style="color:#9c8ec1"><strong>格式化操作</strong></span><span style="color:#79c6cd"><strong>，这里同样借鉴了该方式。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?在该模块中，首先需要由外部传入输出的格式，接着</strong></span><span style="color:#9c8ec1"><strong>根据格式化字符串进行解析</strong></span><span style="color:#79c6cd"><strong>，最终将信息模块的数据填充进需要返回的字符串之中。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?同样，我们也同样规定了对应格式化字符所对应的意义：</strong></span></p> 
<ul>
<li><span style="color:#1c7892"><strong>%d表示日期，包含子格式 {%H:%M:%S}</strong></span></li>
<li><span style="color:#1c7892"><strong>%t表示线程ID</strong></span></li>
<li><span style="color:#1c7892"><strong>%p表示日志等级</strong></span></li>
<li><span style="color:#1c7892"><strong>%c表示日志器名称</strong></span></li>
<li><span style="color:#1c7892"><strong>%f表示文件名</strong></span></li>
<li><span style="color:#1c7892"><strong>%l表示行号</strong></span></li>
<li><span style="color:#1c7892"><strong>%T表示制表符缩进</strong></span></li>
<li><span style="color:#1c7892"><strong>%m表示有效载荷</strong></span></li>
<li><span style="color:#1c7892"><strong>%n表示换行</strong></span></li>
</ul> 
<h3 id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%BB%84%E4%BB%B6">格式化组件</h3> 
<h4 id="%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB">抽象基类</h4> 
<p><span style="color:#79c6cd"><strong>?对于数据填充操作，我们想用统一的眼光看待，</strong></span><span style="color:#9c8ec1"><strong>通过同一函数调用，但最终的结果根据对象的不同而不同</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?经这么一说，很自然就能联想到</strong></span><span style="color:#9c8ec1"><strong>多态</strong></span><span style="color:#79c6cd"><strong>，因此格式化类的业务就很明了了。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?经由解析格式化字符串，我们获得了一个</strong></span><span style="color:#9c8ec1"><strong>父类指针数组</strong></span><span style="color:#79c6cd"><strong>，之后遍历这个数组时对虚函数进行调用即可。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?因此这个基类必须拥有一个</strong></span><span style="color:#9c8ec1"><strong>虚函数</strong></span><span style="color:#79c6cd"><strong>以便子类进行重写，而这个虚函数的参数为</strong></span><span style="color:#9c8ec1"><strong>流插入</strong></span><span style="color:#79c6cd"><strong>和</strong></span><span style="color:#9c8ec1"><strong>信息类</strong></span><span style="color:#79c6cd"><strong>的对象，方便我们直接添加数据。</strong></span></p> 
<pre><code class="language-cpp">namespace Alpaca
{
    class FormatItem
    {
    public:
        using ptr = std::shared_ptr&lt;FormatItem&gt;;        //外部类中可能使用到该对象，声明一个智能指针类型方便使用
        virtual void format(std::ostream&amp; out, LogMsg&amp; msg) = 0;    //为了严谨这里定义成纯虚函数最佳
    };
}
</code></pre> 
<h4 id="%E6%B4%BE%E7%94%9F%E5%AD%90%E7%B1%BB">派生子类</h4> 
<p>  <span style="color:#79c6cd"><strong>?对于派生子类而言，就</strong></span><span style="color:#9c8ec1"><strong>只需要重写上面的 format 函数</strong></span><span style="color:#79c6cd"><strong>，后根据对应的类将对应的数据插入进流中即可。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?不同的类的数据类型不同，一定要保证插入进流的为</strong></span><span style="color:#9c8ec1"><strong>字符串</strong></span><span style="color:#79c6cd"><strong>即可。</strong></span>  </p> 
<pre><code class="language-cpp">class LineFormatItem : public FormatItem
{
public:
    virtual void format(std::ostream&amp; out, LogMsg&amp; msg) override
    {
        out &lt;&lt; msg._line;
    }
};</code></pre> 
<h5 id="%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%90%E7%B1%BB%C2%A0">日期格式化子类 </h5> 
<p><span style="color:#79c6cd"><strong>?而凡是总有例外，日期的格式化还有包含</strong></span><span style="color:#9c8ec1"><strong>子串</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?因此需要在构造函数中保存对应的字符串(不能加到虚函数中，这样将不构成重写)。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?之后我们从信息类中获取对应日志的时间，在此基础上使用 </strong></span><span style="color:#9c8ec1"><strong>strftime</strong></span><span style="color:#79c6cd"><strong> 将其转换成字符串，由于 </strong></span><span style="color:#9c8ec1"><strong>strftime</strong></span><span style="color:#79c6cd"><strong> 的参数为 </strong></span> <strong><span style="color:#9c8ec1">struct tm*</span> </strong> <span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><img alt="" height="64" src="https://images2.imgbox.com/96/46/hYEmw7U9_o.png" width="649"></p> 
<p><span style="color:#79c6cd"><strong>?因此需要先</strong></span><span style="color:#9c8ec1"><strong> time_t </strong></span><span style="color:#79c6cd"><strong>类型的数据转换成 </strong></span><span style="color:#9c8ec1"><strong>struct tm </strong></span><span style="color:#79c6cd"><strong>，而</strong></span><span style="color:#9c8ec1"><strong> localtime_r </strong></span><span style="color:#79c6cd"><strong>函数便能帮助我们实现。</strong></span></p> 
<p><img alt="" height="38" src="https://images2.imgbox.com/e3/1c/gQV2XiKO_o.png" width="786"></p> 
<p><span style="color:#79c6cd"><strong>?获取到格式化日期字符串后，直接将其插入流中即可。</strong></span></p> 
<pre><code class="language-cpp">class TimeFormatItem : public FormatItem
{
public:
    TimeFormatItem(const std::string&amp; fmt = "%H:%M:%S") : _time_fmt(fmt) {}

    void format(std::ostream&amp; out, LogMsg&amp; msg) override
    {
        struct tm t;
        localtime_r(&amp;msg._time, &amp;t);
        char tmp[32] = { 0 };
        strftime(tmp, sizeof(tmp) - 1, _time_fmt.c_str(), &amp;t);
        out &lt;&lt; tmp;
    }

private:
    std::string _time_fmt;
};</code></pre> 
<h5 id="%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%90%E7%B1%BB">其他内容格式化子类</h5> 
<p><span style="color:#79c6cd"><strong>?在格式化字串中也常有</strong></span><span style="color:#9c8ec1"><strong>其他字符</strong></span><span style="color:#79c6cd"><strong>用作分隔或其他用途，但这些字符</strong></span><span style="color:#9c8ec1"><strong>并不在信息类中</strong></span><span style="color:#79c6cd"><strong>，而是</strong></span><span style="color:#9c8ec1"><strong>需要外部传入</strong></span><span style="color:#79c6cd"><strong>，因此做法</strong></span><span style="color:#9c8ec1"><strong>与上面日期子类相同</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">class OtherFormatItem : public FormatItem
{
public:
    OtherFormatItem(const std::string&amp; str) : _str(str) {}

    virtual void format(std::ostream&amp; out, LogMsg&amp; msg) override    //检查重写
    {
        out &lt;&lt; _str;
    }

private:
    std::string _str;
};</code></pre> 
<p><strong>?<span style="color:#6eaad7">该部分代码参考如下。</span></strong></p> 
<pre><code class="language-cpp">namespace Alpaca
{
    class FormatItem
    {
    public:
        using ptr = std::shared_ptr&lt;FormatItem&gt;;
        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) = 0;
    };

    class LevelFormatItem : public FormatItem
    {
    public:
        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            out &lt;&lt; LogLevel::Tostring(msg._level);
        }
    };

    class LineFormatItem : public FormatItem
    {
    public:
        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            out &lt;&lt; msg._line;
        }
    };

    class FileFormatItem : public FormatItem
    {
    public:
        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            out &lt;&lt; msg._file;
        }
    };

    class ThreadFormatItem : public FormatItem
    {
    public:
        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            out &lt;&lt; msg._tid;
        }
    };

    class LoggerFormatItem : public FormatItem
    {
    public:
        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            out &lt;&lt; msg._logger;
        }
    };

    class MsgFormatItem : public FormatItem
    {
    public:
        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            out &lt;&lt; msg._payload;
        }
    };

    class TimeFormatItem : public FormatItem
    {
    public:
        TimeFormatItem(const std::string &amp;fmt = "%H:%M:%S") : _time_fmt(fmt) {}

        void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            struct tm t;
            localtime_r(&amp;msg._time, &amp;t);
            char tmp[32] = {0};
            strftime(tmp, sizeof(tmp) - 1, _time_fmt.c_str(), &amp;t);
            out &lt;&lt; tmp;
        }

    private:
        std::string _time_fmt;
    };

    class TableFormatItem : public FormatItem
    {
    public:
        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            out &lt;&lt; "t";
        }
    };

    class NLineFormatItem : public FormatItem
    {
    public:
        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            out &lt;&lt; "n";
        }
    };

    class OtherFormatItem : public FormatItem
    {
    public:
        OtherFormatItem(const std::string &amp;str) : _str(str) {}

        virtual void format(std::ostream &amp;out, LogMsg &amp;msg) override
        {
            out &lt;&lt; _str;
        }

    private:
        std::string _str;
    };
}</code></pre> 
<h3 id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB">格式化类</h3> 
<p><strong>?<span style="color:#79c6cd">日志输出的格式一旦确定后便不再改变了，如此操作便是为了</span><span style="color:#9c8ec1">避免每次都进行格式的解析</span></strong><span style="color:#79c6cd"><strong>，只需要</strong></span><span style="color:#9c8ec1"><strong>变换传入的信息对象</strong></span><span style="color:#79c6cd"><strong>即可。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?因此格式化字符串在</strong></span><span style="color:#9c8ec1"><strong>构造函数</strong></span><span style="color:#79c6cd"><strong>中接收，而在</strong></span><span style="color:#9c8ec1"><strong>成员函数</strong></span><span style="color:#79c6cd"><strong>中每次接收不同的信息对象。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?从而可以编写出该结构的大概框架。</strong></span></p> 
<pre><code class="language-cpp">class Formatter
{
public:
    using ptr = std::shared_ptr&lt;Formatter&gt;;
    Formatter(const std::string&amp; pattern = "[%d{%H:%M:%S}][%t][%c][%f:%l][%p]%T%m%n")
        : _patter(pattern)
    {}

    std::string format(LogMsg&amp; msg);    //外部调用

    void format(std::ostream&amp; out, LogMsg&amp; msg);    //内部嵌套

    // 解析格式化规则字符串
    bool ParsePattern();

private:
    // 根据格式化字符创建不同的格式化对象
    FormatItem::ptr createItem(const std::string&amp; key, const std::string&amp; val);

private:
    std::string _patter; // 格式化字符串
    std::vector&lt;FormatItem::ptr&gt; _items;   //父类指针数组
};</code></pre> 
<h4 id="%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1">根据字符创建不同对象</h4> 
<p><strong>?<span style="color:#79c6cd">在解析格式化字符串前，我们需要先实现这个接口，用于根据我们传入的格式化字符</span><span style="color:#9c8ec1">创建不同的格式化对象</span></strong><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?早在父类组件实现时，便声明了父类智能指针这个类型，而成员中的数组中存的便是这个</strong></span><span style="color:#9c8ec1"><strong>智能指针</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?因此，该函数只需要</strong></span><span style="color:#9c8ec1"><strong>返回对应派生类对象的智能指针</strong></span><span style="color:#79c6cd"><strong>即可，且使用智能指针还可以帮助我们完成空间的释放，无需我们手动管理。</strong></span></p> 
<pre><code class="language-cpp">FormatItem::ptr createItem(const std::string&amp; key, const std::string&amp; val)
{
    if (key == "d")
        return std::make_shared&lt;TimeFormatItem&gt;(val);
    if (key == "T")
        return std::make_shared&lt;TableFormatItem&gt;();
    if (key == "t")
        return std::make_shared&lt;ThreadFormatItem&gt;();
    if (key == "p")
        return std::make_shared&lt;LevelFormatItem&gt;();
    if (key == "c")
        return std::make_shared&lt;LoggerFormatItem&gt;();
    if (key == "f")
        return std::make_shared&lt;FileFormatItem&gt;();
    if (key == "l")
        return std::make_shared&lt;LineFormatItem&gt;();
    if (key == "m")
        return std::make_shared&lt;MsgFormatItem&gt;();
    if (key == "n")
        return std::make_shared&lt;NLineFormatItem&gt;();
    if (key.empty())
        return std::make_shared&lt;OtherFormatItem&gt;(val);

    std::cout &lt;&lt; "使用非法格式化字符: %" &lt;&lt; key &lt;&lt; std::endl;
    abort();
    return FormatItem::ptr();
}</code></pre> 
<h4 id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%90">格式化字符串的解析</h4> 
<p><strong>?<span style="color:#79c6cd">接下来我们就可以进行</span><span style="color:#9c8ec1">格式化字符串</span><span style="color:#79c6cd">的解析了。</span></strong></p> 
<p><span style="color:#79c6cd"><strong>?在创建个别子项中需要</strong></span><span style="color:#9c8ec1"><strong>参数的传入</strong></span><span style="color:#79c6cd"><strong>，因而我们需要将格式化字符串中相应的内容</strong></span><span style="color:#9c8ec1"><strong>保存下来</strong></span><span style="color:#79c6cd"><strong>(例如日期的子串)。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?我们不妨使用一个</strong></span><span style="color:#9c8ec1"><strong> pair</strong></span><span style="color:#79c6cd"><strong> 为成员的数组进行保存，若是有参数就将参数保存，若无对应参数则第二个位置留空。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?其中的每组对象都对应着函数调用时的两个参数。</strong></span></p> 
<pre><code class="language-cpp">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; fmt_order;</code></pre> 
<p><span style="color:#79c6cd"><strong>?接着便开始循环解析，只需要在格式化字符串中查找 </strong></span><span style="color:#9c8ec1"><strong>%</strong></span><span style="color:#79c6cd"><strong> ，遇到</strong></span> <strong> % </strong> <span style="color:#79c6cd"><strong>前的所有字符</strong></span><span style="color:#9c8ec1"><strong>都是原始字符</strong></span><span style="color:#79c6cd"><strong>，我们暂时将他们保留起来</strong></span></p> 
<pre><code class="language-cpp">if (_patter[pos] != '%')
{
    val.push_back(_patter[pos++]);
    continue;
}</code></pre> 
<p><strong>?<span style="color:#79c6cd">遇到两个 </span><span style="color:#9c8ec1">%</span><span style="color:#79c6cd"> 的情况我们将其视为</span><span style="color:#9c8ec1">转义字符</span><span style="color:#79c6cd">，表示一个</span><span style="color:#9c8ec1"> %</span><span style="color:#79c6cd">  的原始字符，同样存于原始字符串中。</span></strong></p> 
<pre><code class="language-cpp">if (pos + 1 &lt; _patter.size() &amp;&amp; _patter[pos + 1] == '%')
{
    val.push_back('%');
    pos += 2;
    continue;
}</code></pre> 
<p><strong> <span style="color:#79c6cd">?若都未能满足上面两个判断的条件，那么当下</span><span style="color:#9c8ec1"> pos</span><span style="color:#79c6cd"> 位置一定为</span><span style="color:#79c6cd"><strong> </strong></span><span style="color:#9c8ec1">%</span></strong><span style="color:#79c6cd"><strong> ，因此我们需要先将之前保存起来的原始字符串转移至解析数组之中。</strong></span></p> 
<pre><code class="language-cpp">// 走到这说明原始字符串结束，先推送
if (!val.empty())
{
    fmt_order.push_back(std::make_pair("", val));
    val.clear();
}</code></pre> 
<p><span style="color:#79c6cd"><strong>?接下来我们让 </strong></span><span style="color:#9c8ec1"><strong>pos</strong></span><span style="color:#79c6cd"><strong> 向下移动一位，若此时越界则说明 </strong></span><span style="color:#9c8ec1"><strong>%</strong></span><span style="color:#79c6cd"><strong> 匹配失败，直接返回</strong></span><span style="color:#9c8ec1"><strong> false</strong></span><span style="color:#79c6cd"><strong> 即可。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?匹配成功，那么当前位置的字符就是我们在查找的</strong></span><span style="color:#9c8ec1"><strong>格式化字符</strong></span><span style="color:#79c6cd"><strong>，我们将其存到</strong><strong> </strong></span><span style="color:#9c8ec1"><strong>key</strong></span><span style="color:#79c6cd"><strong> </strong><strong>中。</strong></span></p> 
<pre><code class="language-cpp">pos++;
if (pos &gt;= _patter.size())  //检查越界
{
    std::cout &lt;&lt; "%后未有对应的格式化字符" &lt;&lt; std::endl;
    return false;
}
key = _patter[pos];</code></pre> 
<p><strong>?<span style="color:#79c6cd">接下来，还需要考虑字符后面可能还带着的</span><span style="color:#9c8ec1">子串</span></strong><span style="color:#79c6cd"><strong>，往下一位判断是否为 </strong></span><span style="color:#9c8ec1"><strong>{<!-- --></strong></span><span style="color:#79c6cd"><strong> </strong><strong>，接着进行对</strong></span><span style="color:#9c8ec1"><strong> }</strong></span><span style="color:#79c6cd"><strong> 的查找。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?若查找不到 </strong></span><span style="color:#9c8ec1"><strong>}</strong></span><span style="color:#79c6cd"><strong> 进行匹配，便直接返回</strong></span><span style="color:#9c8ec1"><strong> false</strong></span><span style="color:#79c6cd"><strong> ，否则就不断往</strong><strong> </strong></span><span style="color:#9c8ec1"><strong>val</strong></span><span style="color:#79c6cd"><strong> </strong><strong>中存入数据。</strong></span></p> 
<pre><code class="language-cpp">// 考虑子规则的情况
pos++;
if (pos &lt; _patter.size() &amp;&amp; _patter[pos] == '{')
{
    pos++;
    while (pos &lt; _patter.size() &amp;&amp; _patter[pos] != '}')
    {
        val.push_back(_patter[pos++]);
    }

    if (pos &gt;= _patter.size())
    {
        std::cout &lt;&lt; "子规则{}匹配出错" &lt;&lt; std::endl;
        return false;
    }
    pos++;
}</code></pre> 
<p><strong>?<span style="color:#79c6cd">能平安走到这里，就代表以获取一个</span><span style="color:#9c8ec1">格式化字符</span></strong><span style="color:#79c6cd"><strong>的相关内容，接下来我们便可以将对应的 </strong></span> <strong><span style="color:#9c8ec1">key val</span> </strong> <span style="color:#79c6cd"><strong>的值推送到数组之中了。</strong></span></p> 
<pre><code class="language-cpp">// 走出子规则,推送上方解析的数据
fmt_order.push_back(std::make_pair(key, val));
key.clear();
val.clear();</code></pre> 
<p><strong>?<span style="color:#79c6cd">最后循环结束，我们便可以根据解析出来的数组，</span><span style="color:#9c8ec1">获取对应对象的指针</span><span style="color:#79c6cd">并填充</span><span style="color:#9c8ec1">成员数组</span><span style="color:#79c6cd">。 </span></strong></p> 
<pre><code class="language-cpp">// 根据解析到的数据，初始化成员
for (auto&amp; it : fmt_order)
{
    _items.push_back(createItem(it.first, it.second));
}
return true;</code></pre> 
<h5 id="%E5%87%BD%E6%95%B0%E6%95%B4%E4%BD%93">函数整体</h5> 
<pre><code class="language-cpp">// 解析格式化规则字符串
bool ParsePattern()
{
    std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; fmt_order;
    int pos = 0;
    std::string key, val;
    while (pos &lt; _patter.size())
    {
        if (_patter[pos] != '%')
        {
            val.push_back(_patter[pos++]);
            continue;
        }

        // 走到当前pos当前便指向一个%
        if (pos + 1 &lt; _patter.size() &amp;&amp; _patter[pos + 1] == '%')
        {
            val.push_back('%');
            pos += 2;
            continue;
        }

        // 走到这说明原始字符串结束，先推送
        if (!val.empty())
        {
            fmt_order.push_back(std::make_pair("", val));
            val.clear();
        }

        // 现在进行格式化字符的处理，此时pos指向%
        pos++;
        if (pos &gt;= _patter.size())  //检查越界
        {
            std::cout &lt;&lt; "%后未有对应的格式化字符" &lt;&lt; std::endl;
            return false;
        }
        key = _patter[pos];

        // 考虑子规则的情况
        pos++;
        if (pos &lt; _patter.size() &amp;&amp; _patter[pos] == '{')
        {
            pos++;
            while (pos &lt; _patter.size() &amp;&amp; _patter[pos] != '}')
            {
                val.push_back(_patter[pos++]);
            }

            if (pos &gt;= _patter.size())
            {
                std::cout &lt;&lt; "子规则{}匹配出错" &lt;&lt; std::endl;
                return false;
            }
            pos++;
        }
        // 走出子规则,推送上方解析的数据
        fmt_order.push_back(std::make_pair(key, val));
        key.clear();
        val.clear();
    }

    // 根据解析到的数据，初始化成员
    for (auto&amp; it : fmt_order)
    {
        _items.push_back(createItem(it.first, it.second));
    }
    return true;
}</code></pre> 
<h4 id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0">格式化函数</h4> 
<p><strong>?<span style="color:#79c6cd">实现了对格式化字符串的解析，我们只需要</span><span style="color:#9c8ec1">在构造函数调用一次即可</span></strong><span style="color:#79c6cd"><strong>，之后都使用格式化子项数组即可，而这次解析务必成功否则直接出错。</strong></span></p> 
<pre><code class="language-cpp">Formatter(const std::string&amp; pattern = "[%d{%H:%M:%S}][%t][%c][%f:%l][%p]%T%m%n")
    : _patter(pattern)
{
    assert(ParsePattern());
}</code></pre> 
<p><span style="color:#79c6cd"><strong>?还记得上方定义时写的两个</strong></span> <strong> <span style="color:#9c8ec1">format</span> </strong> <span style="color:#79c6cd"><strong>函数吗？外部就是通过这个函数进行格式化后的字符串的获取。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?而我们上面写的格式化子项都是将对应的数据插入到</strong></span><span style="color:#9c8ec1"><strong>流</strong></span><span style="color:#79c6cd"><strong>之中，</strong><strong>且因我们最后要获取的是一个字符串，那么不妨使用 </strong></span><span style="color:#9c8ec1"><strong>stringstream</strong></span><span style="color:#79c6cd"><strong> 进行信息的获取。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?同时，</strong></span><span style="color:#9c8ec1"><strong>stringstream</strong></span><span style="color:#79c6cd"><strong> 为</strong><strong> </strong></span><span style="color:#9c8ec1"><strong>ostream</strong></span><span style="color:#79c6cd"><strong> </strong><strong>的子类可以进行</strong></span><span style="color:#9c8ec1"><strong>赋值转换</strong></span><span style="color:#79c6cd"><strong>，因此可以作为参数。</strong></span></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/18/9f/WZBT8stH_o.png" width="979"></p> 
<p><strong>?<span style="color:#6eaad7">因此，通过对子项数组的遍历，同样调用 log 函数便可完成字符串的组合，遍历结束将流中的数据返回即可</span><span style="color:#79c6cd">。</span></strong></p> 
<pre><code class="language-cpp">std::string format(LogMsg&amp; msg)        //外部调用
{
    std::stringstream ss;
    format(ss, msg);
    return ss.str();
}

void format(std::ostream&amp; out, LogMsg&amp; msg)    //遍历操作
{
    for (auto it : _items)
    {
        it-&gt;format(out, msg);
    }
}</code></pre> 
<h2 id="%E6%97%A5%E5%BF%97%E8%90%BD%E5%9C%B0%E7%B1%BB%E6%A8%A1%E5%9D%97">日志落地类模块</h2> 
<p><span style="color:#79c6cd"><strong>?该模块用于将格式化后的日志消息字符串输出到指定的位置，因为有多种不同的落地方式，我们不妨再次使用</strong></span><span style="color:#9c8ec1"><strong>多态</strong></span><span style="color:#79c6cd"><strong>的方式进行模块的搭建。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?同时，外部拓展新落地方向时只需要继承基类并</strong></span><span style="color:#9c8ec1"><strong>重写虚函数</strong></span><span style="color:#79c6cd"><strong>即可。</strong></span></p> 
<h3 id="%E5%9F%BA%E7%B1%BB%E5%AE%9E%E7%8E%B0">基类实现</h3> 
<p><span style="color:#79c6cd"><strong>?这里需要注意，</strong></span><span style="color:#9c8ec1"><strong>析构函数也要定义成虚函数</strong></span><span style="color:#79c6cd"><strong>，这样即使在外部用父类指针进行管理但最后调用析构函数时会触发多态</strong></span><span style="color:#9c8ec1"><strong>调用派生类的析构函数</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?而这个 </strong><strong>log</strong><strong> 函数则是我们接下来要进行重写的</strong></span><span style="color:#9c8ec1"><strong>主要落地函数</strong></span><span style="color:#79c6cd"><strong>，而参数使用了字符串和长度的形式则是借鉴了文件操作</strong><strong>。</strong></span></p> 
<pre><code class="language-cpp">namespace Alpaca
{
    class LogSink
    {
    public:
        using ptr = std::shared_ptr&lt;LogSink&gt;;
        LogSink() {}
        virtual ~LogSink() {}
        virtual void log(const char* data, size_t len) = 0;    //定义成纯虚函数
    };
}</code></pre> 
<h3 id="%E6%A0%87%E5%87%86%E8%90%BD%E5%9C%B0%E5%AD%90%E7%B1%BB">标准落地子类</h3> 
<p><strong>?<span style="color:#79c6cd">标准落地自然不用多说，以防万一我们根据</span><span style="color:#9c8ec1">指定长度写入</span></strong><span style="color:#79c6cd"><strong>，因此要使用</strong></span><span style="color:#9c8ec1"><strong> write </strong></span><span style="color:#79c6cd"><strong>这个成员函数。</strong></span></p> 
<pre><code class="language-cpp">class StdoutSink : public LogSink
{
public:
    void log(const char* data, size_t len)
    {
        std::cout.write(data, len);
    }
};</code></pre> 
<h3 id="%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%AD%90%E7%B1%BB">文件落地子类</h3> 
<p><span style="color:#79c6cd"><strong>?这个落地子类，我们需要将日志消息写入到一个文件中，那么需要知道文件的路径，而因为</strong></span><span style="color:#9c8ec1"><strong>一个子类只对应一个文件</strong></span><span style="color:#79c6cd"><strong>，所以文件路径这一信息在</strong></span><span style="color:#9c8ec1"><strong>构造函数</strong></span><span style="color:#79c6cd"><strong>中传入即可。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?而打开文件前还需要</strong></span><span style="color:#9c8ec1"><strong>确保文件前路径存在</strong></span><span style="color:#79c6cd"><strong>，因此我们可以调用之前在工具类中实现的 </strong></span> <strong><span style="color:#9c8ec1">create_directory</span> </strong> <span style="color:#79c6cd"><strong>函数，对传入文件的路径进行创建。若前段目录未存在则创建，而若存在便会直接返回。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?这些前置操作完成后，使用 </strong></span><span style="color:#9c8ec1"><strong>ofstream</strong></span><span style="color:#79c6cd"><strong> 成员打开对应的文件(记得加追加选项，不然就是覆盖写入)，如此我们的构造函数便算完成。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?而重写的虚函数也是直接往文件中写入数据即可，写入后判断一下</strong></span><span style="color:#9c8ec1"><strong>是否写入成功</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">class FileSink : public LogSink
{
public:
    // 构造时需要文件名打开文件,并保留句柄
    FileSink(const std::string&amp; pathname) : _pathname(pathname)
    {
        // 创建文件所在路径，存在即返回
        util::File::create_directory(util::File::path(pathname));
        // 打开文件
        _ofs.open(pathname, std::ios::binary | std::ios::app);
        assert(_ofs.is_open());    //检查打开成功
    }

    // 将日志信息写入文件
    void log(const char* data, size_t len)
    {
        _ofs.write(data, len);
        assert(_ofs.good());
    }

private:
    std::string _pathname;
    std::ofstream _ofs;
};</code></pre> 
<p><strong>?<span style="color:#6eaad7">再补充一点，当 ofstream 对象被销毁时，任何打开的文件都会自动关闭，因此无需我们手动关闭。</span></strong></p> 
<h3 id="%E6%BB%9A%E5%8A%A8%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%AD%90%E7%B1%BB">滚动文件落地子类</h3> 
<p><strong>?<span style="color:#79c6cd">日志输出的频率极快，若是只在一个文件中输出，查看起来可能会造成不便，因此我们可以使用</span><span style="color:#9c8ec1">滚动文件</span></strong><span style="color:#79c6cd"><strong>的方式。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?例如，我们可以设置成当一个文件写入数据量已达</strong></span><span style="color:#9c8ec1"><strong> 1Mb</strong></span><span style="color:#79c6cd"><strong>，便打开新文件往新文件中写入。</strong></span></p> 
<h4 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</h4> 
<p><strong>?<span style="color:#79c6cd">这里我们使用的便是实现文件大<span style="background-color:#f9eda6">小达到一定程度便打开新文件</span>的策略即</span><span style="color:#9c8ec1"> rollbysize</span></strong><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?因此，我们需要有成员分别记录当前</strong></span><span style="color:#9c8ec1"><strong>文件的大小</strong></span><span style="color:#79c6cd"><strong>和</strong></span><span style="color:#9c8ec1"><strong>文件的最大值</strong></span><span style="color:#79c6cd"><strong>，除此以外我们还为文件增加一个<span style="background-color:#f9eda6">唯一标识</span>，</strong></span><span style="color:#9c8ec1"><strong>_name_count</strong></span><span style="color:#79c6cd"><strong> 表示落地类直到现在打开了多少个滚动文件，最后便是基础文件名和 </strong></span><span style="color:#9c8ec1"><strong>ofsream</strong></span><span style="color:#79c6cd"><strong> 句柄。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?而构造函数的内部与上一个文件落地类似，都是先保证路径上的目录存在，接着</strong></span><span style="color:#9c8ec1"><strong>打开完整拓展名的文件</strong></span><span style="color:#79c6cd"><strong>即可。</strong></span></p> 
<pre><code class="language-cpp">class RollBySizeSink : public LogSink
{
public:
    RollBySizeSink(const std::string&amp; basename, size_t max_size)
        : _basename(basename), _max_size(max_size), _cur_size(0), _name_count(1)
    {
        std::string pathname = createNewFile();

        // 创建文件所在路径
        util::File::create_directory(util::File::path(pathname));
        // 打开文件
        _ofs.open(pathname, std::ios::binary | std::ios::app);
        assert(_ofs.is_open());
    }
private:
    size_t _name_count;         //文件标识
    std::string _basename;      //基础文件名
    std::ofstream _ofs;
    size_t _max_size;           //最大文件大小
    size_t _cur_size;           //当前文件大小
};</code></pre> 
<h4 id="%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%93%E5%B1%95%E5%90%8D">获取文件的拓展名</h4> 
<p><strong>?<span style="color:#79c6cd">因为我们使用的是</span><span style="color:#9c8ec1">滚动文件</span></strong><span style="color:#79c6cd"><strong>落地，因此会涉及到</strong></span><span style="color:#9c8ec1"><strong>打开不同名的文件</strong></span><span style="color:#79c6cd"><strong>，因此在构造时只需传入</strong></span><span style="color:#9c8ec1"><strong>基础文件名</strong></span><span style="color:#79c6cd"><strong>即可，而拓展名由我们</strong></span><span style="color:#9c8ec1"><strong>根据唯一变量</strong></span><span style="color:#79c6cd"><strong>进行添加。</strong></span></p> 
<pre><code class="language-cpp">//拓展名 = 基础文件名 + 时间信息 + 滚动文件的计数器
std::string createNewFile()
{
    time_t t = util::Date::now();
    struct tm lt;
    localtime_r(&amp;t, &amp;lt);
    std::stringstream filename;
    filename &lt;&lt; _basename;            //基础文件名
    filename &lt;&lt; lt.tm_year + 1900 &lt;&lt; lt.tm_mon + 1     //时间信息
        &lt;&lt; lt.tm_mday &lt;&lt; lt.tm_hour
        &lt;&lt; lt.tm_min &lt;&lt; lt.tm_sec;
    filename &lt;&lt; "-";
    filename &lt;&lt; _name_count++;    //滚动文件的计数器
    filename &lt;&lt; ".log";
    return filename.str();
}</code></pre> 
<h4 id="%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">虚函数重写</h4> 
<p><strong>?<span style="color:#79c6cd">在每次落地前，我们都需要计算一下当前文件大小</span><span style="color:#9c8ec1">是否超过了文件的限制</span></strong><span style="color:#79c6cd"><strong>，若超过了则获取一个新文件名，接着关闭原文件的流并打开文件的流。(</strong></span><span style="color:#9c8ec1"><strong>一定要先关闭原文件</strong></span><span style="color:#79c6cd"><strong>，否则可能导致文件描述符被占用完了，进而导致程序崩溃)</strong></span></p> 
<pre><code class="language-cpp">void log(const char* data, size_t len)
{
    // 文件过大时创建一个新文件
    if (_cur_size &gt; _max_size)
    {
        std::string pathname = createNewFile();
        _ofs.close();        //先关闭再打开
        _ofs.open(pathname, std::ios::binary | std::ios::app);
        assert(_ofs.is_open());
        _cur_size = 0;
    }
    _ofs.write(data, len);
    assert(_ofs.good());
    _cur_size += len;
}</code></pre> 
<h3 id="%E8%90%BD%E5%9C%B0%E7%B1%BB%E5%B7%A5%E5%8E%82">落地类工厂</h3> 
<p><strong>?<span style="color:#79c6cd">最后我们需要一个</span></strong><span style="color:#79c6cd"><strong>工厂</strong><strong>专门负责</strong></span><span style="color:#9c8ec1"><strong>落地对象的获取</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?但我们不能写死，因为我们</strong></span><span style="color:#9c8ec1"><strong>还要支持新落地方式的拓展</strong></span><span style="color:#79c6cd"><strong>，因此我们使用模板的方式进行对应对象的获取。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?同时，又由于各个对象初始化所需的参数不同，便还需要</strong></span><span style="color:#9c8ec1"><strong>可变参数列表</strong></span><span style="color:#79c6cd"><strong>接收不同数量的参数。</strong></span></p> 
<pre><code class="language-cpp">class SinkFactory
{
public:
    template &lt;class Sinktype, class... Args&gt;
    static LogSink::ptr create(Args &amp;&amp;...args)
    {
        return std::make_shared&lt;Sinktype&gt;(std::forward&lt;Args&gt;(args)...);    //将可变参数包展开
    }
};</code></pre> 
<p><strong>?<span style="color:#6eaad7">之后只要在外部指定落地类类型调用该函数并传入对应参数即可获取为对应的落地对象。</span></strong></p> 
<h2 id="%E6%97%A5%E5%BF%97%E5%99%A8%E6%A8%A1%E5%9D%97">日志器模块</h2> 
<p><strong>?<span style="color:#79c6cd">我们实现的日志器还分作</span><span style="color:#9c8ec1">同步日志器</span></strong><span style="color:#79c6cd"><strong>和</strong></span><span style="color:#9c8ec1"><strong>异步日志器</strong></span><span style="color:#79c6cd"><strong>两种。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?同步写日志时，是以串行的模式进行运行，日志完成前不可以进行接下来的业务处理。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?而异步日志器中则有专门的</strong></span><span style="color:#9c8ec1"><strong>线程</strong></span><span style="color:#79c6cd"><strong>负责日志的输出操作。</strong></span></p> 
<h3 id="%E6%97%A5%E5%BF%97%E5%99%A8%E5%9F%BA%E7%B1%BB">日志器基类</h3> 
<p><strong>?<span style="color:#79c6cd">同样，我们先抽象出一个</span><span style="color:#9c8ec1">日志器基类</span></strong><span style="color:#79c6cd"><strong>，之后的各个日志器类型都是在此基础上建立的。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?我们先梳理一下该类需要的相关成员，首先便是日志的限制等级，对于一个日志器设定有对应的等级限制，写日志时</strong></span><span style="color:#9c8ec1"><strong>若输出等级小于限制等级将不会输出</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?接着，在下一个模块我们会将日志器管理起来，作为</strong></span><span style="color:#9c8ec1"><strong>标识符</strong></span><span style="color:#79c6cd"><strong>，我们需要对每个日志器进行</strong></span><span style="color:#9c8ec1"><strong>命名</strong></span><span style="color:#79c6cd"><strong>。这样一个个日志器组合起来，便成为了一个庞大的日志系统。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?不仅如此，</strong></span><span style="color:#9c8ec1"><strong>前几个模块都是这个模块的一部分</strong></span><span style="color:#79c6cd"><strong>，在日志器中我们还要有专属的</strong></span><span style="color:#9c8ec1"><strong>格式化模块</strong></span><span style="color:#79c6cd"><strong>和</strong></span><span style="color:#9c8ec1"><strong>落地模块数组</strong></span><span style="color:#79c6cd"><strong>(一个日志器可能有多种落地方式)。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?最后，为了保证该日志系统能够</strong></span><span style="color:#9c8ec1"><strong>被线程并发访问</strong></span><span style="color:#79c6cd"><strong>，因而在成员中还需要一个</strong></span><span style="color:#9c8ec1"><strong>互斥锁</strong></span><span style="color:#79c6cd"><strong>来保证不会出现冲突。</strong></span></p> 
<pre><code class="language-cpp">namespace Alpaca
{
    class Logger
    {
    public:
        using ptr = std::shared_ptr&lt;Logger&gt;;

        Logger(const std::string&amp; logger_name, LogLevel::value limit_level,
            Formatter::ptr&amp; formatter, std::vector&lt;LogSink::ptr&gt;&amp; sinks)
            : _logger_name(logger_name), _limit_level(limit_level),
            _formatter(formatter), _sinks(sinks.begin(), sinks.end()) {}

        // 通过传入的参数构建一个msg对象，且调用目标方法所生成的日志等级一定与该方法一致
        void debug(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...);

        void info(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...);

        void warn(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...);

        void error(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...);

        void fatal(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...);

        std::string GetLoggerName(); // 不返回引用防止外界修改

    protected:
        virtual void log(const char* data, size_t len) = 0;

        void serialize(LogLevel::value level, const std::string&amp; file, size_t line, char* str);

    protected:
        std::mutex _mutex;
        std::string _logger_name;
        std::atomic&lt;LogLevel::value&gt; _limit_level;
        Formatter::ptr _formatter;
        std::vector&lt;LogSink::ptr&gt; _sinks;
    };
}</code></pre> 
<p><strong>?<span style="color:#6eaad7">这里将日志等级定义成了原子性的了，因此之后对其访问就不用加锁了。</span></strong></p> 
<p><strong>?<span style="color:#79c6cd">其中，各个</span><span style="color:#9c8ec1">日志等级</span></strong><span style="color:#79c6cd"><strong>的成员函数是给到</strong></span><span style="color:#9c8ec1"><strong>外部调用</strong></span><span style="color:#79c6cd"><strong>的，而在该函数内部，我们需要完成对</strong></span><span style="color:#9c8ec1"><strong>限制等级的判断</strong></span><span style="color:#79c6cd"><strong>，获取传入参数并进行格式化，<span style="background-color:#f9eda6">最后基于落地类数组进行实际落地</span>。</strong></span></p> 
<h4 id="%E6%97%A5%E5%BF%97%E5%99%A8%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">日志器外部接口实现</h4> 
<p><strong>?<span style="color:#79c6cd">需要注意的一点是，参数需要传入对应的</span><span style="color:#9c8ec1">文件名</span></strong><span style="color:#79c6cd"><strong>和</strong></span><span style="color:#9c8ec1"><strong>日志输出时的行号</strong></span><span style="color:#79c6cd"><strong>(如果在类内获取，就失去了对应定位的效果)。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?函数刚进入时，我们需要对限制等级进行一次判断，同时因为我们使用</strong></span><span style="color:#9c8ec1"><strong>枚举</strong></span><span style="color:#79c6cd"><strong>定义的日志等级，因此<span style="background-color:#f9eda6">可以直接比较</span>(下面以 debug 等级进行演示)。</strong></span></p> 
<pre><code class="language-cpp">if (LogLevel::value::DEBUG &lt; _limit_level)
    return;</code></pre> 
<p><strong>?<span style="color:#79c6cd">接下来我们便需要</span><span style="color:#9c8ec1">解析不定参数</span></strong><span style="color:#79c6cd"><strong>，需要 </strong></span><span style="color:#9c8ec1"><strong>va_list</strong></span><span style="color:#79c6cd"><strong> 这个类型协助我们进行解析操作。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?值得注意的一点是，这个传入的不定参数，外部用于</strong></span><span style="color:#9c8ec1"><strong>对日志正文的格式化</strong></span><span style="color:#79c6cd"><strong>。因此这里我们根据对应的格式化字符串将其转化成对应的字符串，</strong></span><span style="color:#9c8ec1"><strong>作为日志内容</strong></span><span style="color:#79c6cd"><strong>用于接下来日志信息类的构建，而这个操作刚好由</strong><strong> </strong></span><span style="color:#9c8ec1"><strong>vasprintf </strong></span><span style="color:#79c6cd"><strong>完成。</strong></span></p> 
<p><img alt="" height="58" src="https://images2.imgbox.com/93/03/D6HZGivl_o.png" width="816"></p> 
<p><strong>?<span style="color:#79c6cd">关于这个  </span><span style="color:#9c8ec1">va_list</span></strong><span style="color:#79c6cd"><strong> </strong><strong>可以将其看作一个指针，我们通过</strong></span><span style="color:#9c8ec1"><strong>转换指向</strong></span><span style="color:#79c6cd"><strong>从而获得不定参数中的各个成员。</strong></span></p> 
<pre><code class="language-cpp">// 解析不定参数
va_list ap;            //定义类型
va_start(ap, fmt);     //让ap指向不定参数开始
char* res;             //定义一个指针用于接收数据
int ret = vasprintf(&amp;res, fmt.c_str(), ap);    //转化成字符串
if (ret == -1)         //失败则输出相关信息
{
    std::cout &lt;&lt; "vasprintf failed" &lt;&lt; std::endl;
    return;
}
va_end(ap);            //让ap指向不定参数的结尾</code></pre> 
<p><strong>?<span style="color:#79c6cd">而格式化并落地部分，我们将其封装到了</span><span style="color:#9c8ec1"> serialize</span></strong><span style="color:#79c6cd"><strong> 函数中，下面一起看看如何实现吧。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?根据传入的参数，我们创建出对应的</strong></span><span style="color:#9c8ec1"><strong>信息对象</strong></span><span style="color:#79c6cd"><strong>，紧接着传入格式化模块中</strong></span><span style="color:#9c8ec1"><strong>转换成字符串</strong></span><span style="color:#79c6cd"><strong>，最后交由 </strong></span><span style="color:#9c8ec1"><strong>log</strong></span><span style="color:#79c6cd"><strong> 函数处理。</strong></span></p> 
<pre><code class="language-cpp">void serialize(LogLevel::value level, const std::string&amp; file, size_t line, char* str)
{
    // 构建Logmsg对象
    LogMsg msg(level, file, line, _logger_name, str);

    // 获取格式化后的字符串
    std::stringstream ss;
    _formatter-&gt;format(ss, msg);

    // 日志落地
    log(ss.str().c_str(), ss.str().size());
}</code></pre> 
<p><strong>?<span style="color:#79c6cd">正因两种日志器的落地方式，因此这个</span><span style="color:#79c6cd"><strong> </strong></span><span style="color:#9c8ec1">log</span></strong><span style="color:#79c6cd"><strong> 函数则是接下来子类需要重写的虚函数。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?走完</strong></span> <strong> <span style="color:#9c8ec1">serialize</span> </strong> <span style="color:#79c6cd"><strong>函数后，回到原输出函数，因为</strong></span><span style="color:#9c8ec1"><strong> vsprintf </strong></span><span style="color:#79c6cd"><strong>内部会动态开辟空间给 </strong></span><span style="color:#9c8ec1"><strong>res</strong></span><span style="color:#79c6cd"><strong> ，在函数结束前</strong></span><span style="color:#9c8ec1"><strong>还需要释放对应的空间</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">free(res); // vsprintf内部会动态开辟空间给res</code></pre> 
<p><strong>?<span style="color:#6eaad7">由此，debug 部分功能便已实现，而其他等级的函数只需要在该函数的基础上更改其中的等级即可。</span></strong></p> 
<h4 id="%E5%9F%BA%E7%B1%BB%E4%BB%A3%E7%A0%81">基类代码</h4> 
<pre><code class="language-cpp">namespace Alpaca
{
    class Logger
    {
    public:
        using ptr = std::shared_ptr&lt;Logger&gt;;

        Logger(const std::string&amp; logger_name, LogLevel::value limit_level,
            Formatter::ptr&amp; formatter, std::vector&lt;LogSink::ptr&gt;&amp; sinks)
            : _logger_name(logger_name), _limit_level(limit_level),
            _formatter(formatter), _sinks(sinks.begin(), sinks.end()) {}

        // 通过传入的参数构建一个msg对象，且调用目标方法所生成的日志等级一定与该方法一致
        void debug(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...)
        {
            // 判断输出等级
            if (LogLevel::value::DEBUG &lt; _limit_level)
                return;

            // 解析不定参数
            va_list ap;
            va_start(ap, fmt);
            char* res;
            int ret = vasprintf(&amp;res, fmt.c_str(), ap);
            if (ret == -1)
            {
                std::cout &lt;&lt; "vasprintf failed" &lt;&lt; std::endl;
                return;
            }
            va_end(ap);

            serialize(LogLevel::value::DEBUG, file, line, res);
            free(res); // vsprintf内部会动态开辟空间给res
        }

        void info(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...)
        {
            // 判断输出等级
            if (LogLevel::value::INFO &lt; _limit_level)
                return;

            // 解析不定参数
            va_list ap;
            va_start(ap, fmt);
            char* res;
            int ret = vasprintf(&amp;res, fmt.c_str(), ap);
            if (ret == -1)
            {
                std::cout &lt;&lt; "vasprintf failed" &lt;&lt; std::endl;
                return;
            }
            va_end(ap);

            serialize(LogLevel::value::INFO, file, line, res);
            free(res); // vsprintf内部会动态开辟空间给res
        }

        void warn(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...)
        {
            // 判断输出等级
            if (LogLevel::value::WARN &lt; _limit_level)
                return;

            // 解析不定参数
            va_list ap;
            va_start(ap, fmt);
            char* res;
            int ret = vasprintf(&amp;res, fmt.c_str(), ap);
            if (ret == -1)
            {
                std::cout &lt;&lt; "vasprintf failed" &lt;&lt; std::endl;
                return;
            }
            va_end(ap);

            serialize(LogLevel::value::WARN, file, line, res);
            free(res); // vsprintf内部会动态开辟空间给res
        }

        void error(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...)
        {
            // 判断输出等级
            if (LogLevel::value::ERROR &lt; _limit_level)
                return;

            // 解析不定参数
            va_list ap;
            va_start(ap, fmt);
            char* res;
            int ret = vasprintf(&amp;res, fmt.c_str(), ap);
            if (ret == -1)
            {
                std::cout &lt;&lt; "vasprintf failed" &lt;&lt; std::endl;
                return;
            }
            va_end(ap);

            serialize(LogLevel::value::ERROR, file, line, res);
            free(res); // vsprintf内部会动态开辟空间给res
        }

        void fatal(const std::string&amp; file, size_t line, const std::string&amp; fmt, ...)
        {
            // 判断输出等级
            if (LogLevel::value::FATAL &lt; _limit_level)
                return;

            // 解析不定参数
            va_list ap;
            va_start(ap, fmt);
            char* res;
            int ret = vasprintf(&amp;res, fmt.c_str(), ap);
            if (ret == -1)
            {
                std::cout &lt;&lt; "vsprintf failed" &lt;&lt; std::endl;
                return;
            }
            va_end(ap);

            serialize(LogLevel::value::FATAL, file, line, res);
            free(res); // vsprintf内部会动态开辟空间给res
        }

        std::string GetLoggerName() // 不返回引用防止外界修改
        {
            return _logger_name;
        }

    protected:
        virtual void log(const char* data, size_t len) = 0;

        void serialize(LogLevel::value level, const std::string&amp; file, size_t line, char* str)
        {
            // 构建Logmsg对象
            LogMsg msg(level, file, line, _logger_name, str);

            // 获取格式化后的字符串
            std::stringstream ss;
            _formatter-&gt;format(ss, msg);

            // 日志落地
            log(ss.str().c_str(), ss.str().size());
        }

    protected:
        std::mutex _mutex;
        std::string _logger_name;
        std::atomic&lt;LogLevel::value&gt; _limit_level;
        Formatter::ptr _formatter;
        std::vector&lt;LogSink::ptr&gt; _sinks;
    };
}</code></pre> 
<h3 id="%E5%90%8C%E6%AD%A5%E6%97%A5%E5%BF%97%E5%99%A8">同步日志器</h3> 
<p><strong>?<span style="color:#79c6cd">同步日志器不需要增加新的成员，对于</span><span style="color:#9c8ec1"> log</span><span style="color:#79c6cd"> 函数的重写只需要遍历</span><span style="color:#9c8ec1">落地类的数组</span><span style="color:#79c6cd">将对应的数据进行落地即可。</span></strong></p> 
<pre><code class="language-cpp">class SyncLogger : public Logger
{
public:
    SyncLogger(const std::string&amp; logger_name, LogLevel::value limit_level,
        Formatter::ptr&amp; formatter, std::vector&lt;LogSink::ptr&gt;&amp; sinks)
        : Logger(logger_name, limit_level, formatter, sinks) {}

protected:
    // 直接通过落地模块的句柄进行日志落地
    void log(const char* data, size_t len)
    {
        std::unique_lock&lt;std::mutex&gt; lock(_mutex);    //加锁
        if (_sinks.empty())
            return;
        for (auto sink : _sinks)        //实际落地
        {
            sink-&gt;log(data, len);
        }
    }
};</code></pre> 
<h3 id="%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E5%99%A8">异步日志器</h3> 
<p><strong>?<span style="color:#79c6cd">在异步日志器实现前，还有一个重要的拼图还未凑齐，那就是负责</span><span style="color:#9c8ec1">异步写日志的线程</span></strong><span style="color:#79c6cd"><strong>。</strong></span></p> 
<h4 id="%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B">异步工作线程</h4> 
<p><strong>?<span style="color:#79c6cd">我们将该线程封装进一个类中，为类中的一个成员在</span><span style="color:#9c8ec1">构造函数中创建线程 </span></strong><span style="color:#79c6cd"><strong>，在</strong></span><span style="color:#9c8ec1"><strong>析构函数中进行线程关闭的工作</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?该类的成员负责数据的输入，而成员中的工作线程负责日志的</strong></span><span style="color:#9c8ec1"><strong>实际落地</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">AsyncLooper(func_t func, AsyncType looper_type = AsyncType::ASYNC_SAFE)
    : _stop(false),
    _looper_type(looper_type),
    _thread(std::thread(&amp;AsyncLooper::threadEntry, this)),    //设置一个工作线程的入口函数
    _func(func) {}

~AsyncLooper()
{
    stop();
}

void stop()
{
    _stop = true;
    _cond_con.notify_all();
    _thread.join(); // 等待工作线程退出
}</code></pre> 
<p><strong>?<span style="color:#79c6cd">在实际开发中，写日志操作<span style="background-color:#f9eda6">并不会分配太多的资源</span>，因此工作线程只需要</span><span style="color:#9c8ec1">一个</span></strong><span style="color:#79c6cd"><strong>就够了。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?那么我们传入进来的每条信息都是</strong></span><span style="color:#9c8ec1"><strong>立刻输出</strong></span><span style="color:#79c6cd"><strong>的吗？在文件系统时我们学过，</strong></span><span style="color:#9c8ec1"><strong>系统调用是十分低效的</strong></span><span style="color:#79c6cd"><strong>，若是每有一条就直接输出到文件中，便会严重影响整体线程的效率。因此，我们需要实现一个</strong></span><span style="color:#9c8ec1"><strong>缓冲区模块</strong></span><span style="color:#79c6cd"><strong>，临时存放传入进来的日志消息。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?现在我们一起来分析一下，在运行过程中可能涉及的冲突问题，</strong></span><span style="color:#9c8ec1"><strong>生产者</strong></span><span style="color:#79c6cd"><strong>和</strong></span><span style="color:#9c8ec1"><strong>生产者</strong></span><span style="color:#79c6cd"><strong>之间的冲突(<span style="background-color:#f9eda6">写入线程间</span>)，</strong></span><span style="color:#9c8ec1"><strong>生产者</strong></span><span style="color:#79c6cd"><strong>和</strong></span><span style="color:#9c8ec1"><strong>消费者</strong></span><span style="color:#79c6cd"><strong>之间的冲突(<span style="background-color:#f9eda6">写入线程和异步工作线程间</span>)。当前的问题便是，</strong></span><span style="color:#9c8ec1"><strong>锁冲突较为严重</strong></span><span style="color:#79c6cd"><strong>，</strong></span><span style="color:#9c8ec1"><strong>所有线程间都存在互斥关系</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?不如，我们的缓冲区模块就使用两个缓冲区组成，如此便有效地减少了锁冲突。</strong></span></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/5a/64/hg5YWYCK_o.png" width="657"></p> 
<p><strong>?<span style="color:#6eaad7">经由改变结构，优化了生产者和消费者之间的冲突，只有在交换缓冲区的过程中才需要进行锁的申请。</span></strong></p> 
<h5 id="%E7%BC%93%E5%86%B2%E5%8C%BA">缓冲区</h5> 
<p><strong>?<span style="color:#79c6cd">现在一起来看看单个缓冲区类是如何实现的吧。</span></strong></p> 
<p><span style="color:#79c6cd"><strong>?首先便是如何存放一条条日志信息了，因为此时写入已经是</strong></span><span style="color:#9c8ec1"><strong>格式化后的字符串</strong></span><span style="color:#79c6cd"><strong>，我们直接使用</strong><strong> </strong></span><span style="color:#9c8ec1"><strong>vector&lt;char&gt;</strong></span><span style="color:#79c6cd"><strong> </strong><strong>进行存储即可。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?接着，我们这个缓冲区是一个</strong></span><span style="color:#9c8ec1"><strong>单向的缓冲区</strong></span><span style="color:#79c6cd"><strong>，<span style="background-color:#f9eda6">只有缓冲区的数据被清空后才会从头开始写入</span>，当缓冲区被写满后会根据</strong></span><span style="color:#9c8ec1"><strong>异步线程的设定</strong></span><span style="color:#79c6cd"><strong>决定是</strong></span><span style="color:#9c8ec1"><strong>阻塞</strong></span><span style="color:#79c6cd"><strong>还是</strong></span><span style="color:#9c8ec1"><strong>扩容</strong></span><span style="color:#79c6cd"><strong>，因此需要两个指针，分别告诉我们从哪里开始读、哪里开始写，以便进一步操作。</strong></span></p> 
<pre><code class="language-cpp">namespace Alpaca
{
#define DEFAULT_BUFFER_SIZE (1 * 1024 * 1024)    //默认大小
#define THRESHOLD_BUFFER_SIZE (8 * 1024 * 1024)  //小于这个大小每次扩容 *2
#define INCREASE_BUFFER_SIZE (1 * 1024 * 1024)   //大于上方大小每次扩容增加这个数
    class Buffer
    {
    public:
        Buffer()
            : _buffer(DEFAULT_BUFFER_SIZE),
            _read_idx(0), _write_idx(0) {}
    private:
        std::vector&lt;char&gt; _buffer;
        size_t _read_idx;
        size_t _write_idx;
    };
}</code></pre> 
<h6 id="%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C">缓冲区的基础操作</h6> 
<p><strong>?<span style="color:#79c6cd">对于这个缓冲区而言，我们需要获取一些</span><span style="color:#9c8ec1">基础信息</span><span style="color:#79c6cd">或</span><span style="color:#9c8ec1">偏移读写指针</span></strong><span style="color:#79c6cd"><strong>，不妨将其作为接口封装起来。</strong></span></p> 
<pre><code class="language-cpp">const char* begin()      //返回可读数据的起始地址
{
    return &amp;_buffer[_read_idx];
}

size_t ReadAbleSize()     //能读取的数据量
{
    return (_write_idx - _read_idx);
}
size_t WriteAbleSize()    //还能写的空间
{
    return (_buffer.size() - _write_idx);
}

void MoveReader(size_t len)    //移动读端
{
    assert(len &lt;= ReadAbleSize());
    _read_idx += len;
}
void MoveWriter(size_t len)    //移动写端
{
    assert(len + _write_idx &lt;= _buffer.size());
    _write_idx += len;
}

void reset()        //将偏移量初始化
{
    _write_idx = 0;
    _read_idx = 0;
}

void swap(Buffer&amp; buffer)        //交换缓冲区
{
    _buffer.swap(buffer._buffer);
    std::swap(buffer._read_idx, _read_idx);
    std::swap(buffer._write_idx, _write_idx);
}

bool empty()        //缓冲区判空
{
    return (_read_idx == _write_idx);
}</code></pre> 
<h6 id="%E4%BF%9D%E8%AF%81%E8%B6%B3%E5%A4%9F%E7%A9%BA%E9%97%B4%E5%86%99%E5%85%A5">保证足够空间写入</h6> 
<p><strong>?<span style="color:#79c6cd">该函数用于<span style="background-color:#f9eda6">确保缓冲区有足够的空间进行写入</span>，本质上为一种扩容函数。</span></strong></p> 
<p><span style="color:#79c6cd"><strong>?缓冲区的数据若经过几次扩容则可能变得相当庞大，因此</strong></span><span style="color:#9c8ec1"><strong>不能每次都以两倍进行增长</strong></span><span style="color:#79c6cd"><strong>，我们可以设置当空间大于某个数值后，缓冲区每次扩容成</strong></span><span style="color:#9c8ec1"><strong>线性增长</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">void ensureEnoughSize(size_t len)
{
    if (len &lt; WriteAbleSize())    //空间足够直接返回
        return;
    size_t newsize = 0;
    while (newsize &lt; len)
    {
        if (_buffer.size() &lt; THRESHOLD_BUFFER_SIZE)        //小于指定数值每次扩容两倍
            newsize = _buffer.size() * 2;
        else
            newsize = _buffer.size() + INCREASE_BUFFER_SIZE;    //大于指定数值每次线性扩容
    }

    _buffer.resize(newsize);
}</code></pre> 
<h6 id="%E5%90%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">向缓冲区插入数据</h6> 
<p><strong>?<span style="color:#79c6cd">在外部我们会进行根据异步日志的模式对线程进行限制，因此我们这里</span><span style="color:#9c8ec1">直接确保空间足够</span></strong><span style="color:#79c6cd"><strong>即可。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?往缓冲区写入数据后还要记得把</strong></span><span style="color:#9c8ec1"><strong>可写指针向后偏移</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">void push(const char* data, size_t len)
{
    //将是否扩容的决定权交给用户,因此这里只扩容
    ensureEnoughSize(len);

    std::copy(data, data + len, &amp;_buffer[_write_idx]);

    // 将可写位置向后偏移
    MoveWriter(len);
}</code></pre> 
<h5 id="%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA">开始搭建</h5> 
<p><strong>?<span style="color:#6eaad7">现在，我们已经完成了缓冲区的实现，接下来便可以进行异步线程部分的搭建了。</span></strong></p> 
<p><strong>?<span style="color:#79c6cd">于日志器而言，成员需要一个</span><span style="color:#9c8ec1">异步类型的标志</span><span style="color:#79c6cd">，一个</span><span style="color:#9c8ec1">运行标识符</span><span style="color:#79c6cd">，</span><span style="color:#9c8ec1">两个缓冲区</span><span style="color:#79c6cd">，与之对应的</span><span style="color:#9c8ec1">条件变量</span><span style="color:#79c6cd">，为了使用条件变量还需要一个</span><span style="color:#9c8ec1">互斥锁</span><span style="color:#79c6cd">，以及异步</span><span style="color:#9c8ec1">线程</span><span style="color:#79c6cd">和其中的</span><span style="color:#9c8ec1">回调函数</span><span style="color:#79c6cd">。</span></strong></p> 
<pre><code class="language-cpp">namespace Alpaca
{
    enum class AsyncType
    {
        ASYNC_SAFE,  // 缓冲区满了则阻塞
        ASYNC_UNSAFE // 无限扩容
    };
    class AsyncLooper
    {
    private:
        AsyncType _looper_type;
        std::atomic&lt;bool&gt; _stop;    //运行标识符
        Buffer _pro_buf; // 生产者缓冲区
        Buffer _con_buf; // 消费者缓冲区
        std::mutex _mutex;
        std::condition_variable _cond_pro;
        std::condition_variable _cond_con;
        std::thread _thread; // 异步工作器对应的工作线程
        func_t _func;        // 回调函数
    };
}</code></pre> 
<p><strong>?<span style="color:#79c6cd">接下来将分成两部分进行实现，分别是</span><span style="color:#9c8ec1">生产者写入数据</span></strong><span style="color:#79c6cd"><strong>，与</strong></span><span style="color:#9c8ec1"><strong>消费者处理数据</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<h6 id="%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">生产者的数据写入</h6> 
<p><strong>?<span style="color:#79c6cd">对生产者而言，数据的写入即将</span><span style="color:#9c8ec1">对应数据拷贝到缓冲区</span><span style="color:#79c6cd">中即可，首先缓冲区可能处于一个</span><span style="color:#9c8ec1">并发访问</span><span style="color:#79c6cd">的状态，需要先加上</span><span style="color:#9c8ec1">锁</span><span style="color:#79c6cd">。</span></strong></p> 
<p><span style="color:#79c6cd"><strong>?接着判断日志器的写入方式为<span style="background-color:#f9eda6">无限扩容</span>还是<span style="background-color:#f9eda6">阻塞</span>，若是阻塞模式下则进行判断缓冲区中的数据是否足够写入，为否则阻塞。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?我们实现的 push 函数内部会</strong></span><span style="color:#9c8ec1"><strong>保证缓冲区中的空间足够写入</strong></span><span style="color:#79c6cd"><strong>，因此直接拷贝数据即可，最后</strong></span><span style="color:#9c8ec1"><strong>唤醒消费者处理数据</strong></span><span style="color:#79c6cd"><strong>即可。</strong></span></p> 
<pre><code class="language-cpp">void push(const char* data, size_t len)
{
    // 1.无限扩容  --非安全 2.固定大小

    std::unique_lock&lt;std::mutex&gt; lock(_mutex);
    if (_looper_type == AsyncType::ASYNC_SAFE)
        _cond_pro.wait(lock, [&amp;]()
            { return _pro_buf.WriteAbleSize() &gt;= len; })    //使用lambda表达式;

    // 走到这说明缓冲区中有足够空间够我们写入 或是处于无限扩容状态下
    _pro_buf.push(data, len);
    _cond_con.notify_one(); // 唤醒消费者对缓冲区进行处理
}</code></pre> 
<h6 id="%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">消费者的数据处理</h6> 
<p><strong>?<span style="color:#79c6cd">消费者即</span><span style="color:#9c8ec1">异步线程</span></strong><span style="color:#79c6cd"><strong>，一开始异步线程所属的缓冲区便是空的，因此每次都需要</strong></span><span style="color:#9c8ec1"><strong>先获取新的数据</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?由此需要先</strong></span><span style="color:#9c8ec1"><strong>对生产者的缓冲区状态进行判断</strong></span><span style="color:#79c6cd"><strong>，若该缓冲区为空，交换过来也没有意义。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?进入临界区，我们先对运行状态判断一下，但别着急 </strong></span><span style="color:#9c8ec1"><strong>break</strong></span><span style="color:#79c6cd"><strong> </strong><strong><span style="background-color:#f9eda6">万一生产者中还有数据</span>，还是要进行处理的。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?接着根据条件变量进行阻塞，若成功走到下面说明</strong></span><span style="color:#9c8ec1"><strong>生产者缓冲区满足条件</strong></span><span style="color:#79c6cd"><strong>，可以交换，交换后唤醒生产者继续填充数据。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?走出临界区，说明数据已经准备好了，接着调用</strong></span><span style="color:#9c8ec1"><strong>回调函数</strong></span><span style="color:#79c6cd"><strong>进行数据落地即可，最后</strong></span><span style="color:#9c8ec1"><strong>清空缓冲区的偏移量</strong></span><span style="color:#79c6cd"><strong>，等待获取新数据。</strong></span></p> 
<pre><code class="language-cpp">void threadEntry() // 线程入口函数
{
    while (1)
    {
        //判断生产者的缓冲区是否满足交换要求
        { 
            std::unique_lock&lt;std::mutex&gt; lock(_mutex);    //加上{}使锁的临界区就在{}内部分内容
            // 避免生产缓冲区中有数据但没有被完全处理的情况
            if (_stop &amp;&amp; _pro_buf.empty())
                break;
            
            //运行状态下，生产者缓冲区为空阻塞，非运行状态下不阻塞
            _cond_con.wait(lock, [&amp;]()
                    { return _stop || !_pro_buf.empty(); });
            _con_buf.swap(_pro_buf);
            _cond_pro.notify_all();
        }
        _func(_con_buf);
        _con_buf.reset();
    }
}</code></pre> 
<h4 id="%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">外部函数的实现</h4> 
<p><strong>?<span style="color:#79c6cd">异步线程实现后，剩下的最后一步便是外部函数的实现，在这里我们需要实现一个用于</span><span style="color:#9c8ec1">插入日志</span></strong><span style="color:#79c6cd"><strong>的接口，以及异步线程中的</strong></span><span style="color:#9c8ec1"><strong>回调函数</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?首先为插入日志的接口，因为内部帮我们加锁了，所以</strong></span><span style="color:#9c8ec1"><strong>直接调用异步线程对象的成员函数</strong></span><span style="color:#79c6cd"><strong>即可。</strong></span></p> 
<pre><code class="language-cpp">void log(const char* data, size_t len)
{
    _looper-&gt;push(data, len);
}</code></pre> 
<p><strong> ?<span style="color:#79c6cd">而回调函数也很简单，像同步日志器那样，</span><span style="color:#9c8ec1">遍历落地对象数据进行落地操作即可</span></strong><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">void realLog(Buffer&amp; buf)   //实际落地函数
{
    if (_sinks.empty())
        return;
    for (auto sink : _sinks)
    {
        sink-&gt;log(buf.begin(), buf.ReadAbleSize());
    }
}</code></pre> 
<p><strong>?<span style="color:#6eaad7">最后需要注意一点，我们在类内写的函数都是默认带有 this 指针的，因此在传入前需要先绑定参数。</span></strong></p> 
<pre><code class="language-cpp">_looper(std::make_shared&lt;AsyncLooper&gt;(std::bind(&amp;AsyncLogger::realLog, this, std::placeholders::_1), logger_type)</code></pre> 
<h3 id="%E6%97%A5%E5%BF%97%E5%99%A8%E5%BB%BA%E9%80%A0%E8%80%85">日志器建造者</h3> 
<p><strong>?<span style="color:#79c6cd">经过上面模块的实现，我们希望通过一个统一的方式进行</span><span style="color:#9c8ec1">日志器的建造</span></strong><span style="color:#79c6cd"><strong>，接下来我们实现一个</strong></span><span style="color:#9c8ec1"><strong>日志器建造者</strong></span><span style="color:#79c6cd"><strong>负责各个类型日志器的建造。</strong></span></p> 
<h4>抽象基类</h4> 
<p><strong>?<span style="color:#79c6cd">为了方便同步与异步日志器的创建，我们创建了</span>  <span style="color:#9c8ec1">LoggerType</span> </strong> <span style="color:#79c6cd"><strong>字段用于二者的区分。</strong></span></p> 
<pre><code class="language-cpp">enum LoggerType
{
    LOGGER_SYNC,
    LOGGER_ASYNC
};
</code></pre> 
<p><strong>?<span style="color:#79c6cd">在构造函数完成部分成员的初始化，而其他成员则在成员函数中传入即可，而 </span><span style="color:#9c8ec1">build </span><span style="color:#79c6cd">为纯虚函数，需要子类进行重写。 </span></strong></p> 
<pre><code class="language-cpp">class LoggerBuilder
{
public:
    LoggerBuilder()
        : _logger_type(LoggerType::LOGGER_SYNC),
        _limit_level(LogLevel::value::DEBUG),
        _looper_type(AsyncType::ASYNC_SAFE) {}

    void BuildLoggerType(LoggerType type)
    {
        _logger_type = type;
    }

    void BuildLoggerName(std::string name)
    {
        _logger_name = name;
    }

    void BuildLoggerLevel(LogLevel::value level)
    {
        _limit_level = level;
    }

    void BuildEnableUsafeAsync()
    {
        _looper_type = AsyncType::ASYNC_UNSAFE;
    }

    void BuildFormatter(const std::string&amp; pattern)

    {
        _formatter = std::make_shared&lt;Formatter&gt;(pattern);
    }

    template &lt;class SinkType, class... Args&gt;
    void BuildSinks(Args &amp;&amp;...args)
    {
        LogSink::ptr psink = SinkFactory::create&lt;SinkType&gt;(std::forward&lt;Args&gt;(args)...);
        _sinks.push_back(psink);
    }

    virtual Logger::ptr build() = 0;

protected:
    AsyncType _looper_type;         //异步线程模式
    LoggerType _logger_type;        //日志器模式
    std::string _logger_name;       //日志器名称 
    std::atomic&lt;LogLevel::value&gt; _limit_level;    //日志限制等级
    Formatter::ptr _formatter;           //格式化模块
    std::vector&lt;LogSink::ptr&gt; _sinks;    //落地模块
};</code></pre> 
<p><strong>?<span style="color:#6eaad7">局部日志器和全局日志器的区别就是在</span><span style="color:#9c8ec1">  build</span> </strong> <span style="color:#6eaad7"><strong>函数中全局日志器会被保存起来，而局部日志器不会。</strong></span></p> 
<h4 id="%E5%B1%80%E9%83%A8%E6%97%A5%E5%BF%97%E5%99%A8%E5%BB%BA%E9%80%A0">局部日志器建造</h4> 
<p><strong>?<span style="color:#79c6cd">首先我们需要对部分重要对象先进行检测，若不存在则使用默认的设置，但</span><span style="color:#9c8ec1">日志器的名字不能没有</span></strong><span style="color:#79c6cd"><strong>，若检测到未传入名字则直接报错。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?之后根据日志器的模式返回对应的日志器指针即可。</strong></span></p> 
<pre><code class="language-cpp">class LocalLoggerBuilder : public LoggerBuilder
{
public:
    Logger::ptr build() override
    {
        assert(_logger_name.empty() == false);
        if (_formatter.get() == nullptr)
        {
            _formatter = std::make_shared&lt;Formatter&gt;();
        }
        if (_sinks.empty())
        {
            BuildSinks&lt;StdoutSink&gt;();
        }
        if (_logger_type == LOGGER_ASYNC)
        {
            return std::make_shared&lt;AsyncLogger&gt;(_logger_name, _limit_level, _formatter, _sinks, _looper_type);
        }

        return std::make_shared&lt;SyncLogger&gt;(_logger_name, _limit_level, _formatter, _sinks);
    }
};</code></pre> 
<h4 id="%E5%85%A8%E5%B1%80%E6%97%A5%E5%BF%97%E5%99%A8%E5%BB%BA%E9%80%A0%E8%80%85">全局日志器建造者</h4> 
<p><strong>?<span style="color:#79c6cd">全局相比局部只需要多加一步，那么就是</span><span style="color:#9c8ec1">将获取的日志器指针添加到管理模块的单例对象</span></strong><span style="color:#79c6cd"><strong>中，而管理模块接下来我们会进行实现。</strong></span></p> 
<pre><code class="language-cpp">class GlobalLoggerBuilder : public LoggerBuilder
{
public:
    Logger::ptr build() override
    {
        assert(_logger_name.empty() == false);
        if (_formatter.get() == nullptr)
        {
            _formatter = std::make_shared&lt;Formatter&gt;();
        }
        if (_sinks.empty())
        {
            BuildSinks&lt;StdoutSink&gt;();
        }
        Logger::ptr logger;
        if (_logger_type == LOGGER_ASYNC)
            logger = std::make_shared&lt;AsyncLogger&gt;(_logger_name, _limit_level, _formatter, _sinks, _looper_type);
        else
            logger = std::make_shared&lt;SyncLogger&gt;(_logger_name, _limit_level, _formatter, _sinks);

        LoggerManager::getInstance().AddLogger(logger);        //添加到单例对象中
        return logger;
    }
};</code></pre> 
<h2 id="%E6%97%A5%E5%BF%97%E5%99%A8%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97">日志器管理模块</h2> 
<p><strong>?<span style="color:#79c6cd">对日志器的管理我们采取 </span><span style="color:#9c8ec1">KV</span></strong><span style="color:#79c6cd"><strong> 模型，以</strong></span><span style="color:#9c8ec1"><strong>日志器名称</strong></span><span style="color:#79c6cd"><strong>作为定义一个日志器的唯一标识。</strong><strong>为了处理并发访问的问题，成员中还需要增加一个互斥锁。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?同时，我们还要将这个管理模块设计成单例模式，使其在全局函数中只有一份。而另一个成员则是自动生成的默认日志器。</strong></span></p> 
<pre><code class="language-cpp">class LoggerManager
{
public:
private:
    LoggerManager()    //构造函数私有化
    {}
private:
    std::mutex _mutex;
    Logger::ptr _root_logger;
    std::unordered_map&lt;std::string, Logger::ptr&gt; _loggers;
};</code></pre> 
<h3 id="%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96">单例对象的获取</h3> 
<p><strong>?<span style="color:#79c6cd">在</span><span style="color:#79c6cd"><strong> </strong></span><span style="color:#9c8ec1">C++11</span></strong><span style="color:#79c6cd"><strong> 中直接获取</strong></span> <strong> <span style="color:#9c8ec1">static</span> </strong> <span style="color:#79c6cd"><strong>变量是线程安全的，我们可以直接用这种方式进行</strong></span><span style="color:#9c8ec1"><strong>单例对象</strong></span><span style="color:#79c6cd"><strong>的获取。</strong></span></p> 
<pre><code class="language-cpp">static LoggerManager&amp; getInstance()    //返回引用
{
    static LoggerManager eton;
    return eton;
}</code></pre> 
<h3 id="%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86">日志器的管理</h3> 
<p><strong>?<span style="color:#79c6cd">对于日志器的管理，我们需要实现日志器的</span><span style="color:#9c8ec1">添加</span></strong><span style="color:#79c6cd"><strong>、</strong></span><span style="color:#9c8ec1"><strong>判断存在</strong></span><span style="color:#79c6cd"><strong>和</strong></span><span style="color:#9c8ec1"><strong>获取</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?判空非常简单，加锁后直接对名字进行查找最后判断结果即可，同时<span style="background-color:#f9eda6">哈希表的查找效率极高</span>，因此消耗并不大。</strong></span></p> 
<pre><code class="language-cpp">bool IsLoggerExist(const std::string&amp; name)
{
    std::unique_lock&lt;std::mutex&gt; lock(_mutex);
    auto pos = _loggers.find(name);
    if (pos == _loggers.end())
        return false;
    return true;
}</code></pre> 
<p><strong>?<span style="color:#79c6cd">增加时，我们先判断对应名称的日志器是否存在，若存在直接返回即可，之后加锁往哈希表中插入数据即可。</span></strong></p> 
<pre><code class="language-cpp">void AddLogger(Logger::ptr&amp; logger)
{
    if (IsLoggerExist(logger-&gt;GetLoggerName()))
    {
        std::cout &lt;&lt; "该名称的日志器以存在" &lt;&lt; std::endl;
        return;
    }
    std::unique_lock&lt;std::mutex&gt; lock(_mutex);
    _loggers[logger-&gt;GetLoggerName()] = logger;
}
</code></pre> 
<p><strong>?<span style="color:#79c6cd">获取日志器时，若查找不到对应日志器的话，可以选择</span><span style="color:#9c8ec1">直接报错</span></strong><span style="color:#79c6cd"><strong>也可以</strong></span><span style="color:#9c8ec1"><strong>返回默认的日志器</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">Logger::ptr GetLogger(const std::string&amp; name)
{
    std::unique_lock&lt;std::mutex&gt; lock(_mutex);
    auto pos = _loggers.find(name);
    if (pos == _loggers.end())
    {
        std::cout &lt;&lt; "no such name logger" &lt;&lt; std::endl;
        assert(false);
    }
    return pos-&gt;second;
}</code></pre> 
<h3>构造函数</h3> 
<p><strong>?<span style="color:#79c6cd">之前成员中就定义了一个默认的日志器，而构造函数主要便是进行该</span><span style="color:#9c8ec1">默认日志器的初始化</span><span style="color:#79c6cd">。</span></strong></p> 
<pre><code class="language-cpp">LoggerManager()
{
    std::unique_ptr&lt;LoggerBuilder&gt; builder(new LocalLoggerBuilder());    //获取建造者
    builder-&gt;BuildLoggerName("root");        //填充默认日志器名称
    _root_logger = builder-&gt;build();         //日志器建造，并保存在成员变量中
    _loggers["root"] = _root_logger;         //全局化
}</code></pre> 
<p><strong>?<span style="color:#79c6cd">而默认日志器的获取，直接返回</span><span style="color:#9c8ec1">成员变量</span></strong><span style="color:#79c6cd"><strong>即可。</strong></span></p> 
<pre><code class="language-cpp">Logger::ptr rootLogger()
{
    return _root_logger;
}</code></pre> 
<h3 id="%E4%BB%A3%E7%90%86%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%A3">代理日志器的接口</h3> 
<h4 id="%E6%8F%90%E4%BE%9B%E6%8C%87%E5%AE%9A%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E5%85%A8%E5%B1%80%E6%8E%A5%E5%8F%A3">提供指定日志器的全局接口</h4> 
<p><strong>?<span style="color:#79c6cd">若是不进行一层封装，那么用户在使用时会感到</span><span style="color:#9c8ec1">十分的不便</span></strong><span style="color:#79c6cd"><strong>，需要<span style="background-color:#f9eda6">先获取单例对象再调用函数</span>。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?这里直接提供两个</strong></span><span style="color:#9c8ec1"><strong>全局接口</strong></span><span style="color:#79c6cd"><strong>，在函数中帮我们完成了上述操作，使用户可以直接获得指定的日志器。</strong></span></p> 
<pre><code class="language-cpp">// 1.提供指定日志器的全局接口
Logger::ptr Getlogger(const std::string&amp; name)
{
    return LoggerManager::getInstance().GetLogger(name);
}

Logger::ptr GetRoot()
{
    return LoggerManager::getInstance().rootLogger();
}</code></pre> 
<h4 id="%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%87%BD%E6%95%B0%E5%AF%B9%E6%97%A5%E5%BF%97%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%90%86">使用宏函数对日志器的接口进行代理</h4> 
<p><strong>?<span style="color:#79c6cd">接着我们可以使用</span><span style="color:#9c8ec1">宏函数</span></strong><span style="color:#79c6cd"><strong>对</strong></span><span style="color:#9c8ec1"><strong>原本日志器的接口</strong></span><span style="color:#79c6cd"><strong>进行代理，接下来调用对应的函数就不用手动传入文件名和行号了。</strong></span></p> 
<p><span style="color:#79c6cd"><strong><span style="background-color:#f9eda6">其中，##__VA_ARGS__ 代表的是可变参数列表。</span></strong></span></p> 
<pre><code class="language-cpp">// 2.使用宏函数对日志器的接口进行代理
#define debug(fmt, ...) debug(__FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define info(fmt, ...) info(__FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define warn(fmt, ...) warn(__FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define error(fmt, ...) error(__FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define fatal(fmt, ...) fatal(__FILE__, __LINE__, fmt, ##__VA_ARGS__)</code></pre> 
<h4 id="%E6%8F%90%E4%BE%9B%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA">提供宏函数直接进行日志的标准输出</h4> 
<p><strong>?<span style="color:#79c6cd">同样提供宏函数直接调用默认日志器进行日志输出。</span></strong></p> 
<pre><code class="language-cpp">// 3.提供宏函数直接进行日志的标准输出
#define DEBUG(fmt, ...) GetRoot()-&gt;debug(fmt, ##__VA_ARGS__)
#define INFO(fmt, ...) GetRoot()-&gt;info(fmt, ##__VA_ARGS__)
#define WARN(fmt, ...) GetRoot()-&gt;warn(fmt, ##__VA_ARGS__)
#define ERROR(fmt, ...) GetRoot()-&gt;error(fmt, ##__VA_ARGS__)
#define FATAL(fmt, ...) GetRoot()-&gt;fatal(fmt, ##__VA_ARGS__)
</code></pre> 
<h2 id="%E6%8B%93%E5%B1%95">拓展</h2> 
<p><strong>?<span style="color:#79c6cd">我们实现的日志系统支持</span><span style="color:#9c8ec1">落地类的拓展</span></strong><span style="color:#79c6cd"><strong>，因此我们在外部自己实现一个</strong></span><span style="color:#9c8ec1"><strong>落地类</strong></span><span style="color:#79c6cd"><strong>，该落地类是</strong></span><span style="color:#9c8ec1"><strong>根据时间进行滚动文件</strong></span><span style="color:#79c6cd"><strong>的。</strong></span></p> 
<pre><code class="language-cpp">enum TimeGap
{
    GAP_SECOND,
    GAP_MIN,
    GAP_HOUR,
    GAP_DAY
};

class RollByTimeSink : public LogSink
{
public:
    RollByTimeSink(const std::string &amp;basename, TimeGap gap_type)
        : _basename(basename)
    {
        switch (gap_type)
        {
        case GAP_SECOND:
            _gap_size = 1;
            break;
        case GAP_MIN:
            _gap_size = 60;
            break;
        case GAP_HOUR:
            _gap_size = 3600;
            break;
        case GAP_DAY:
            _gap_size = 3600 * 24;
            break;
        }
        std::string filename = createNewFile();
        // 创建文件所在路径
        util::File::create_directory(util::File::path(filename));
        // 打开文件
        _ofs.open(filename, std::ios::binary | std::ios::app);
        assert(_ofs.is_open());
    }
    void log(const char *data, size_t len)
    {
        time_t t = util::Date::now();
        // 判断当前文件是否在该时间段中，否则创建新文件
        if (t / _gap_size != _cur_size)
        {
            std::string pathname = createNewFile();
            _ofs.close();
            _ofs.open(pathname, std::ios::binary | std::ios::app);
            assert(_ofs.is_open());
            _cur_size = t / _gap_size;
        }

        _ofs.write(data, len);
        assert(_ofs.good());
    }

private:
    std::string createNewFile()
    {
        time_t t = util::Date::now();
        struct tm lt;
        localtime_r(&amp;t, &amp;lt);
        std::stringstream filename;
        filename &lt;&lt; _basename;
        filename &lt;&lt; lt.tm_year + 1900 &lt;&lt; lt.tm_mon + 1
                 &lt;&lt; lt.tm_mday &lt;&lt; lt.tm_hour
                 &lt;&lt; lt.tm_min &lt;&lt; lt.tm_sec;
        filename &lt;&lt; "-";
        filename &lt;&lt; _name_count++;
        filename &lt;&lt; ".log";
        return filename.str();
    }

private:
    size_t _name_count;
    std::string _basename;
    std::ofstream _ofs;
    size_t _cur_size;
    size_t _gap_size;
};</code></pre> 
<p><strong>?<span style="color:#79c6cd">在主函数中，我们搭建出对应的日志器，接着进行五秒的日志输出。</span></strong></p> 
<pre><code class="language-cpp">int main()
{
    std::unique_ptr&lt;LoggerBuilder&gt; builder(new GlobalLoggerBuilder());
    builder-&gt;BuildLoggerLevel(LogLevel::value::WARN);
    builder-&gt;BuildLoggerName("Async_logger");
    builder-&gt;BuildLoggerType(LoggerType::LOGGER_ASYNC);
    builder-&gt;BuildFormatter("[%c][%f:%l]%m%n");
    builder-&gt;BuildSinks&lt;RollByTimeSink&gt;("./logfile/roll-async-by-time", GAP_SECOND);
    Logger::ptr logger = builder-&gt;build();

    size_t cur = util::Date::now();
    while (util::Date::now() &lt; cur + 5)
    {
        logger-&gt;fatal("%s", "this is a test log");
        usleep(1000);
    }
    return 0;
}</code></pre> 
<p><strong>?<span style="color:#79c6cd">可以看到生成了 </span><span style="color:#9c8ec1">0~6</span><span style="color:#79c6cd"> 的文件，而 </span><span style="color:#9c8ec1">0</span><span style="color:#79c6cd"> 和</span><span style="color:#9c8ec1"> 6</span><span style="color:#79c6cd"> 号文件因为位于计时的开始和结束</span><span style="color:#9c8ec1">并没有写入数据</span></strong><span style="color:#79c6cd"><strong>，</strong><strong>实际的数据主要写入在 </strong></span><span style="color:#9c8ec1"><strong>1~5</strong></span><span style="color:#79c6cd"><strong> 号文件中。</strong></span></p> 
<p> <img alt="" height="196" src="https://images2.imgbox.com/67/c7/lkw7EmCo_o.png" width="275"></p> 
<h2 id="%E6%B5%8B%E8%AF%95">测试</h2> 
<p><strong>?<span style="color:#79c6cd">在项目总体完成后，我们接下来我们将对该日志系统的性能进行测试。</span></strong></p> 
<p><strong><span style="color:#79c6cd">?测试环境: </span><span style="color:#6eaad7">2核2G 云服务器 CentOS 7.6.181</span><span style="color:#79c6cd">0 。</span></strong></p> 
<h3 id="%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">测试函数的实现</h3> 
<p><strong>?<span style="color:#79c6cd">为了测试该日志系统在</span><span style="color:#9c8ec1">多线程环境</span></strong><span style="color:#79c6cd"><strong>下的运行状态，因此该测试函数内部需要</strong></span><span style="color:#9c8ec1"><strong>创建多个线程</strong></span><span style="color:#79c6cd"><strong>同时进行写日志的操作。</strong></span></p> 
<p><span style="color:#79c6cd"><strong>?而线程的数量交由外部用户决定，首先</strong></span><span style="color:#9c8ec1"><strong>计算每个线程需要输出几条日志</strong></span><span style="color:#79c6cd"><strong>，接着创建线程输出日志并开始计时，任务完成后进行</strong></span><span style="color:#9c8ec1"><strong>时间的计算</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">void bench(const std::string&amp; logger_name, size_t thread_num, size_t msg_num, size_t msg_len)
{
    // 获取日志器
    Logger::ptr logger = Getlogger(logger_name);
    if (logger.get() == nullptr)
    {
        return;
    }
    std::cout &lt;&lt; "测试日志: " &lt;&lt; msg_num &lt;&lt; " 条,总大小: " &lt;&lt; msg_num * msg_len / 1024 &lt;&lt; "KB" &lt;&lt; std::endl;
    // 组织指定长度的日志消息
    std::string msg(msg_len - 1, 'A'); //-1是为了添加n

    // 创建指定数量的线程
    std::vector&lt;std::thread&gt; threads;
    std::vector&lt;double&gt; cost_array(thread_num);    //记录各个线程的消耗时间
    size_t per_num = msg_num / thread_num;
    for (int i = 0; i &lt; thread_num; i++)
    {
        threads.emplace_back([&amp;, i]()
            {
                // 开始测试
                int num = per_num;
                if (i + 1 == thread_num)
                    num += (msg_num % thread_num);
                auto start = std::chrono::high_resolution_clock::now();
                for (int i = 0; i &lt; num; i++)
                {
                    logger-&gt;fatal("%s", msg.c_str());
                }
                auto end = std::chrono::high_resolution_clock::now();
                std::chrono::duration&lt;double&gt; cost = end - start;
                cost_array[i] = cost.count(); });
    }
    for (int i = 0; i &lt; thread_num; i++)
    {
        threads[i].join();
    }
    // 计算总耗时,求并发最大值
    double max_cost = 0;
    for (int i = 0; i &lt; cost_array.size(); i++)
    {
        if (cost_array[i] &gt; max_cost)
            max_cost = cost_array[i];
        if (i + 1 == thread_num)
            per_num += (msg_num % thread_num);
        std::cout &lt;&lt; "线程" &lt;&lt; i + 1 &lt;&lt; ": "
            &lt;&lt; "t输出日志数量: " &lt;&lt; per_num &lt;&lt; ",耗时: " &lt;&lt; cost_array[i] &lt;&lt; "s" &lt;&lt; std::endl;
    }

    size_t per_sec_msg = msg_num / max_cost;
    size_t per_sec_size = per_sec_msg * msg_len / 1024;

    std::cout &lt;&lt; "t总耗时: " &lt;&lt; max_cost &lt;&lt; "s" &lt;&lt; std::endl;
    std::cout &lt;&lt; "t每秒输出日志数量: " &lt;&lt; per_sec_msg &lt;&lt; "条" &lt;&lt; std::endl;
    std::cout &lt;&lt; "t每秒输出日志大小: " &lt;&lt; per_sec_size &lt;&lt; "KB" &lt;&lt; std::endl;
}</code></pre> 
<p><strong>?<span style="color:#79c6cd">我们还可以对日志器的创建进行封装，分成</span><span style="color:#9c8ec1">同步日志测试函数</span></strong><span style="color:#79c6cd"><strong>和</strong></span><span style="color:#9c8ec1"><strong>异步日志测试函数</strong></span><span style="color:#79c6cd"><strong>。</strong></span></p> 
<pre><code class="language-cpp">void sync_bench()
{
    std::unique_ptr&lt;LoggerBuilder&gt; builder(new GlobalLoggerBuilder());
    builder-&gt;BuildLoggerName("sync_logger");
    builder-&gt;BuildLoggerType(LoggerType::LOGGER_SYNC);
    builder-&gt;BuildFormatter("%m%n");
    builder-&gt;BuildSinks&lt;FileSink&gt;("./logfile/sync.log");
    builder-&gt;build();

    bench("sync_logger", 5, 1000000, 100);
}

void async_bench()
{
    std::unique_ptr&lt;LoggerBuilder&gt; builder(new GlobalLoggerBuilder());
    builder-&gt;BuildLoggerName("Async_logger");
    builder-&gt;BuildLoggerType(LoggerType::LOGGER_ASYNC);
    builder-&gt;BuildEnableUsafeAsync(); // 排除实际落地时间造成的影响
    builder-&gt;BuildFormatter("%m%n");
    builder-&gt;BuildSinks&lt;FileSink&gt;("./logfile/async.log");
    builder-&gt;build();

    bench("Async_logger", 5, 1000000, 100);
}</code></pre> 
<h3 id="%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%C2%A0">测试结果 </h3> 
<p><strong>?<span style="color:#6eaad7">图一为同步日志器，图二为异步日志器。</span></strong></p> 
<p><img alt="" height="187" src="https://images2.imgbox.com/f5/f2/YTtTQ8BX_o.png" width="423">        <img alt="" height="180" src="https://images2.imgbox.com/9b/d5/MOY4OQc9_o.png" width="429"></p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p><strong>? <span style="color:#6eaad7">在该项目中我们频繁地使用</span><span style="color:#9c8ec1">继承</span><span style="color:#6eaad7">和</span><span style="color:#9c8ec1">多态</span><span style="color:#6eaad7">的相关操作，因此需要熟练掌握对应的操作方法，理解</span><span style="color:#9c8ec1">底层原理</span><span style="color:#6eaad7">。</span></strong></p> 
<p><strong><span style="color:#6eaad7">?同时，我们还用到了多种设计模式，例如</span><span style="color:#9c8ec1">单例模式</span><span style="color:#6eaad7">、</span><span style="color:#9c8ec1">工厂模式</span><span style="color:#6eaad7">、</span><span style="color:#9c8ec1">建造者模式</span><span style="color:#6eaad7">、</span><span style="color:#9c8ec1">代理模式</span><span style="color:#6eaad7">，同样需要学习对应模式的思想。</span></strong></p> 
<p><strong><span style="color:#6eaad7">?在函数实现时还使用到了</span><span style="color:#9c8ec1">不定参数列表</span><span style="color:#6eaad7">，一样需要熟悉它的使用方法，例如可变参数包的展开方式，及</span><span style="color:#9c8ec1">可变模板参数列表</span><span style="color:#6eaad7">的使用。</span></strong></p> 
<p><strong><span style="color:#6eaad7">?而对于</span><span style="color:#9c8ec1">双缓冲区</span><span style="color:#6eaad7">的运行逻辑也要十分的清晰，它是如何实现数据写入，如何保证线程安全的。</span></strong></p> 
<p><strong><span style="color:#6eaad7">?最后就是可以对整体项目进行</span><span style="color:#9c8ec1">结构的梳理</span><span style="color:#6eaad7">，可以先尝试画出项目的各个模块，再在此基础上进行消息的拓展。</span></strong> </p> 
<h2 id="%E6%BA%90%E7%A0%81">源码</h2> 
<p><span style="color:#79c6cd"><strong>?好了，今天的项目分享到这里就结束了，下面是对应的</strong></span><span style="color:#9c8ec1"><strong>源码</strong></span><span style="color:#79c6cd"><strong>可以进行参考。</strong></span></p> 
<p><a href="https://gitee.com/LinAlpaca/linux-code-library/tree/master/A_LOG" title="日志系统">日志系统</a></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>