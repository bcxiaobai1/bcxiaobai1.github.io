<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Linux--进程控制 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux--进程控制</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h2 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h2> 
<p>        这篇文章主要是讲解Linux下的进程控制，我们会学习到进程等待，进程程序替换, 微型shell，重新认识shell运行原理 。最后也编写了一个属于我们自己的shell，尽管功能不够齐全，但是还是感觉挺有意思，挺好玩的。这里也希望大家学的开心！</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:40px"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px"><a href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA">进程创建</a></p> 
<p id="%E9%87%8D%E6%B8%A9fork%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#%E9%87%8D%E6%B8%A9fork%E5%87%BD%E6%95%B0">重温fork函数</a></p> 
<p id="%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px"><a href="#%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D">写时拷贝</a></p> 
<p id="fork%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:80px"><a href="#fork%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0">fork调用失败的原因</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2-toc" style="margin-left:40px"><a href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2">进程终止</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px"><a href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%9C%BA%E6%99%AF">进程退出场景</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%80%80%E5%87%BA%E6%96%B9%E6%B3%95-toc" style="margin-left:80px"><a href="#%E8%BF%9B%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%80%80%E5%87%BA%E6%96%B9%E6%B3%95">进程常见退出方法</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85-toc" style="margin-left:40px"><a href="#%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85">进程等待</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%BF%85%E8%A6%81%E6%80%A7-toc" style="margin-left:80px"><a href="#%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%BF%85%E8%A6%81%E6%80%A7">进程等待必要性</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:80px"><a href="#%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E7%9A%84%E6%96%B9%E6%B3%95">进程等待的方法</a></p> 
<p id="%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E-toc" style="margin-left:80px"><a href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E">阻塞与非阻塞</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%9B%BF%E6%8D%A2-toc" style="margin-left:40px"><a href="#%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%9B%BF%E6%8D%A2">进程程序替换</a></p> 
<p id="%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%90%86-toc" style="margin-left:80px"><a href="#%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%90%86">替换原理</a></p> 
<p id="%E6%9B%BF%E6%8D%A2%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#%E6%9B%BF%E6%8D%A2%E5%87%BD%E6%95%B0">替换函数</a></p> 
<p id="%E6%88%91%E7%9A%84shell-toc" style="margin-left:40px"><a href="#%E6%88%91%E7%9A%84shell">我的shell</a></p> 
<p id="%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C-toc" style="margin-left:80px"><a href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C">第一步：获取命令行</a></p> 
<p id="%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C-toc" style="margin-left:80px"><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C">第二步：解析命令行</a></p> 
<p id="%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%BB%BA%E7%AB%8Bfork%EF%BC%8Cexecvp%E6%9B%BF%E6%8D%A2%E5%AD%90%E8%BF%9B%E7%A8%8B-toc" style="margin-left:80px"><a href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%BB%BA%E7%AB%8Bfork%EF%BC%8Cexecvp%E6%9B%BF%E6%8D%A2%E5%AD%90%E8%BF%9B%E7%A8%8B">第三步：建立fork，execvp替换子进程</a></p> 
<p id="%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%EF%BC%88wait%EF%BC%89-toc" style="margin-left:80px"><a href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%EF%BC%88wait%EF%BC%89">第四步：父进程等待子进程退出（wait）</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E6%80%BB%E6%8B%AC-toc" style="margin-left:80px"><a href="#%E4%BB%A3%E7%A0%81%E6%80%BB%E6%8B%AC">代码总括</a></p> 
<hr id="hr-toc">
<p></p> 
<h2 id="%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA">进程创建</h2> 
<hr>
<h3 id="%E9%87%8D%E6%B8%A9fork%E5%87%BD%E6%95%B0"><strong>重温fork函数</strong></h3> 
<p>在前面<a class="link-info" href="http://t.csdn.cn/2nDnv" title="进程概念">进程概念</a>的时候，就已经用到了fork函数。所以我们知道在linux中fork函数时非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。我们通过查man手册，也知道了运用fork函数，需要包含头文件 &lt;unistd.h&gt;。</p> 
<blockquote> 
 <p>#include &lt;unistd.h&gt; </p> 
 <p>pid_t fork(void);</p> 
 <p>返回值：自进程中返回0，父进程返回子进程id，出错返回-1</p> 
</blockquote> 
<p><strong>进程调用fork，当控制转移到内核中的fork代码后，内核做：  </strong></p> 
<p>1.分配新的内存块和内核数据结构给子进程</p> 
<p>2.将父进程部分数据结构内容拷贝至子进程</p> 
<p>3.添加子进程到系统进程列表当中</p> 
<p>4.fork返回，开始调度器调度</p> 
<p><strong>过程图</strong></p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/0f/69/fd9SPsix_o.png" width="720"></p> 
<p>当一个进程调用fork之后，就有两个二进制代码相同的进程。而且它们都运行到相同的地方。但每个进程都将可以 开始它们自己的旅程，看如下程序。</p> 
<pre><code>#include &lt;stdio.h&gt;    
#include &lt;unistd.h&gt;    
#include &lt;stdlib.h&gt;    
    
int main(void)    
{    
  pid_t pid;    
  printf("Before: pid is %dn", getpid());    
  if ((pid=fork())==-1)perror("fork()"),exit(1);                                                                                                                                           
  printf("After:pid is %d, fork return %dn", getpid(), pid);    
 sleep(1);    
 return 0;    
}    </code></pre> 
<blockquote> 
 <p><strong>运行结果：</strong></p> 
 <p>[qhx@VM-8-2-centos 12-14]$ ./test<br> Before: pid is 1853<br> After:pid is 1853, fork return 1854<br> After:pid is 1854, fork return 0</p> 
</blockquote> 
<p>这里看到了三行输出，一行before，两行after。进程1853先打印before消息，然后它有打印after。另一个after消息有1854打印的。注意到进程1854没有打印before，为什么呢？如下图所示</p> 
<p><img alt="" height="312" src="https://images2.imgbox.com/45/f2/hAF38dwC_o.png" width="862"></p> 
<p>所以这段代码想让我们知道：<strong>fork之前父进程独立执行，fork之后，父子两个执行流分别执行。注意，fork之后，谁先执行完全由<span style="color:#fe2c24">调度器</span>决定。</strong></p> 
<p><span style="color:#fe2c24">调度器：</span></p> 
<p>调度器是CPU中央处理器的管理员，主要负责完成做两件事情：</p> 
<p>1.选择某些就绪进程来执行，</p> 
<p>2.是打断某些执行的进程让它们变为就绪状态。</p> 
<p><strong>fork函数返回值</strong></p> 
<p>子进程返回0， 父进程返回的是子进程的pid。</p> 
<p><strong>fork常规用法</strong></p> 
<p>一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子 进程来处理请求。</p> 
<p>一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数。</p> 
<h3 id="%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D">写时拷贝</h3> 
<p><strong>当父子代码只读时，父子的代码和数据是共享的。但是任意一方试图写入时，便以写时拷贝的方式各自一份副本。</strong>具体见下图:</p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/17/a9/FohwKriq_o.png" width="1109"></p> 
<p>我们发现最开始父子进程都是指向的同一物理内存，但是当发生写入时。我们发现通过写时拷贝，子进程重新指向一块物理内存。</p> 
<h3 id="fork%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0">fork调用失败的原因</h3> 
<p>关于fork调用失败的两个原因</p> 
<p><strong>1.系统中有太多的进程</strong></p> 
<p><strong>2.实际用户的进程数超过了限制</strong></p> 
<p>这段代码是测试你的用户能跑好多个进程，<strong>但是不建议跑</strong>。因为跑了之后就会影响bash，会导致系统出错！代码如下：</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    int cnt = 0;
    while(1)
    {
        int ret = fork();
        if(ret &lt; 0){
            printf("fork error!, cnt: %dn", cnt);
            break;
        }
        else if(ret == 0){
            //child
            while(1) sleep(1);
        }
        //partent
        cnt++;
    }
    return 0;
}</code></pre> 
<p>当运行后就会出现如下错误：</p> 
<blockquote> 
 <p>-bash: fork: retry: No child processes<br> -bash: fork: retry: No child processes<br> -bash: fork: retry: No child processes<br> -bash: fork: retry: No child processes<br> -bash: fork: Resource temporarily unavailable<br> -bash-4.2$ </p> 
</blockquote> 
<p><strong>解决方法：</strong></p> 
<blockquote> 
 <p>1.kill -9 -1 //将进程全部杀死</p> 
 <p>2.重新增加一个用户使用</p> 
</blockquote> 
<h2></h2> 
<h2 id="%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2">进程终止</h2> 
<hr>
<h3 id="%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%9C%BA%E6%99%AF">进程退出场景</h3> 
<blockquote> 
 <p>代码运行完毕，结果正确 --return 0；</p> 
 <p>代码运行完毕，结果不正确 --return ！0；退出码</p> 
 <p>代码异常终止 --退出码无意义</p> 
</blockquote> 
<h3 id="%E8%BF%9B%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%80%80%E5%87%BA%E6%96%B9%E6%B3%95"><strong>进程常见退出方法</strong></h3> 
<p><strong>正常终止（可以通过 echo $? 查看进程退出码）</strong>：</p> 
<p>1. 从main返回--return 返回</p> 
<p>2. 调用exit --任意地方调用</p> 
<p>3. _exit</p> 
<p><strong>异常退出：</strong></p> 
<p>ctrl + c，信号终止</p> 
<p><strong>return退出</strong></p> 
<p>return是一种更常见的退出进程方法。执行return n等同于执行exit(n),因为调用main的运行时函数会将main的返回值当做 exit的参数。</p> 
<p>我们通过return返回0为正确，返回其他为错误，代码如下：</p> 
<pre><code>#include &lt;stdio.h&gt;    
    
int addToTarget(int from, int to)    
{    
    
    int sum = 0;    
    int i=0;    
    for(i = from; i &lt; to; i++)    
    {    
         sum += i;    
    }    
    return sum;    
}    
    
                                                                                                                                                                                           
int main()    
{    
    //进程退出的时候，对应的退出码    
    //标定进程执行结果是否正确    
    
    int num = addToTarget(1, 100);    
    if(num == 5050)    
        return 0;    
    else    
        return 1;    
    
    return 0;    
}</code></pre> 
<blockquote> 
 <p><strong>运行结果：</strong></p> 
 <p>[hongxin@VM-8-2-centos 12-14]$ ./mytest <br> [hongxin@VM-8-2-centos 12-14]$ echo $?<br> 1<br> [hongxin@VM-8-2-centos 12-14]$ echo $?<br> 0</p> 
</blockquote> 
<blockquote> 
 <p><strong>代码解释：</strong></p> 
 <p>./mytest：运行一个进程</p> 
 <p>echo：显示</p> 
 <p>$?：永远记录最近的一个在命令行中执行完毕时对应的退出码（main-&gt;return ?:）</p> 
 <p>这里的1：标识错误，是mytest进程中代码不正确</p> 
 <p>这里的0：标识正确，因为echo $?本来都是一个进程</p> 
</blockquote> 
<p>前面也说过退出码0标识成功，其他表示不正确，但是不同的数字可以描述不同错误，对于计算机来说很好识别数字，但对于程序员来说语言描述是更加友好。所以在学习c语言的时候，我们就学习过strerror，就是用字符串进行描述，它大概有134种标识；</p> 
<blockquote> 
 <p><strong>运行代码：</strong></p> 
 <p> for(int i=0;i&lt;200;i++)<br>    {<!-- --><br>          printf("%d:%sn",i,strerror(i) );<br>     }</p> 
</blockquote> 
<blockquote> 
 <p><strong>运行结果：</strong></p> 
 <p>[hongxin@VM-8-2-centos 12-14]$ ./mytest <br> 0:Success</p> 
 <p>1:Operation not permitted<br> 2:No such file or directory<br> 3:No such process<br> 4:Interrupted system call<br> 5:Input/output error<br> 6:No such device or address</p> 
 <p>....................................</p> 
 <p>127:Key has expired<br> 128:Key has been revoked<br> 129:Key was rejected by service<br> 130:Owner died<br> 131:State not recoverable<br> 132:Operation not possible due to RF-kill<br> 133:Memory page has hardware error<br> 134:Unknown error 134</p> 
</blockquote> 
<p><strong>exit函数</strong></p> 
<blockquote> 
 <p>#include &lt;unistd.h&gt; </p> 
 <p>void exit(int status);</p> 
 <p>参数：status 定义了进程的终止状态，父进程通过wait来获取该值</p> 
 <p>说明：虽然status是int，但是仅有低8位可以被父进程所用。所以_exit(-1)时，在终端执行$?发现返回值 是255。</p> 
</blockquote> 
<p> 当exit(-1)时，结果如下</p> 
<blockquote> 
 <p><strong>运行结果：</strong></p> 
 <p>[hongxin@VM-8-2-centos 12-14]$ ./mytest <br> hello bit![hongxin@VM-8-2-centos 12-14]$ echo $?<br> 255</p> 
</blockquote> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int addToTarget(int from, int to)
{    
    
    int sum = 0;    
    int i=0;    
    for(i = from; i &lt; to; i++)    
    {    
         sum += i;    
    }    
//    return sum;    
    exit(12);                                                                                                                                                                              
}    
    
    
int main()    
{    
    
     printf("hello world!n");    
     int ret = addToTarget(0, 100);    
     printf("sum=%dn", ret);    
    
    while(1) sleep(1);    
}</code></pre> 
<blockquote> 
 <p>[hongxin@VM-8-2-centos 12-14]$ ./mytest  <br> hello world!                                   //exit在调用addToTarget函数时直接退出</p> 
 <p>[hongxin@VM-8-2-centos 12-14]$ echo $?<br> 12</p> 
</blockquote> 
<p><strong>_exit函数与exit函数</strong></p> 
<p>使用方法不变，exit是库函数，_exit系统调用。他们本质就是上下层关系。</p> 
<p>实例：</p> 
<blockquote> 
 <p>int main()</p> 
 <p>{<!-- --></p> 
 <p>printf("hello");</p> 
 <p>exit(0);</p> 
 <p>}</p> 
 <p>运行结果:</p> 
 <p>[root@localhost linux]# ./a.out</p> 
 <p>hello[root@localhost linux]#</p> 
 <p>//前面两秒没有数据，后两秒显示数据</p> 
 <p>------------------------------------------------------------------------------------------------------</p> 
 <p>int main()</p> 
 <p>{<!-- --></p> 
 <p>printf("hello");</p> 
 <p>_exit(0);</p> 
 <p>}</p> 
 <p>运行结果:</p> 
 <p>[root@localhost linux]# ./a.out</p> 
 <p>[root@localhost linux]#</p> 
 <p>//前两秒没有数据，两秒后程序直接退出</p> 
</blockquote> 
<p><strong>结论：</strong><span style="color:#494949">exit 终止进程，主动刷新缓冲区；_exit终止进程，不会刷新缓冲区</span></p> 
<p>那么缓存区再哪儿呢？</p> 
<p>我们发现如果缓冲区在操作系统层，不管是exit还是_eixt都会刷新缓冲区。实则是在用户级的缓存区，后面基础I/O会将。</p> 
<p><strong>exit最后也会调用exit, 但在调用exit之前，还做了其他工作：</strong></p> 
<p>1. 执行用户通过 atexit或on_exit定义的清理函数。</p> 
<p>2. 关闭所有打开的流，所有的缓存数据均被写入</p> 
<p>3. 调用_exit</p> 
<p><img alt="" height="430" src="https://images2.imgbox.com/44/6c/J4rqP5AX_o.png" width="767"></p> 
<h2></h2> 
<h2 id="%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85">进程等待</h2> 
<hr>
<h3 id="%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%BF%85%E8%A6%81%E6%80%A7">进程等待必要性</h3> 
<p>之前讲过，子进程退出，父进程如果不管不顾，就可能造成‘僵尸进程’的问题，进而造成内存泄漏。</p> 
<p>另外，进程一旦变成僵尸状态，那就刀枪不入，“杀人不眨眼”的kill -9 也无能为力，因为谁也没有办法 杀死一个已经死去的进程。</p> 
<p>最后，父进程派给子进程的任务完成的如何，我们需要知道。如，子进程运行完成，结果对还是不对， 或者是否正常退出。</p> 
<p>父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息</p> 
<h3 id="%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E7%9A%84%E6%96%B9%E6%B3%95">进程等待的方法</h3> 
<p><strong>wait方法</strong></p> 
<p></p> 
<blockquote> 
 <p>#include &lt;sys/types.h&gt;</p> 
 <p>#include &lt;sys/wait.h&gt;</p> 
 <p>pid_t wait(int*status);</p> 
 <p>返回值：</p> 
 <p>成功返回被等待进程pid，失败返回-1。</p> 
 <p>参数：</p> 
 <p>输出型参数，获取子进程退出状态,不关心则可以设置成为NULL</p> 
</blockquote> 
<p>通过fork创建进程， 每次打印时睡眠1秒，观察这5秒的状态。等子进程结束后，睡眠10秒，观察该进程的状态，最后wiat等待后，父进程接受到子进程后的状态。</p> 
<blockquote> 
 <p><strong>脚本：</strong></p> 
 <p>while :; do  ps axj | head -1 &amp;&amp; ps axj | grep mytest| grep -v grep ;sleep 1; done</p> 
</blockquote> 
<pre><code>#include &lt;stdio.h&gt;    
#include &lt;unistd.h&gt;    
#include &lt;string.h&gt;    
#include &lt;stdlib.h&gt;    
#include &lt;sys/types.h&gt;    
#include &lt;sys/wait.h&gt;    
    
int main()    
{    
    pid_t id = fork();    
    if(id == 0)    
    {    
        //子进程    
        int cnt = 5;    
        while(cnt)    
        {    
            printf("我是子进程: %d, 父进程: %d, cnt: %dn", getpid(), getppid(), cnt--);            sleep(1);
        }                
        exit(0); //进程退出
    }                          
    sleep(10);                                                                             

    pid_t ret = wait(NULL);
    if(id &gt; 0)                 
    {             
        printf("wait success: %d", ret);
    }                                       
         
    sleep(5);
} </code></pre> 
<p><img alt="" height="321" src="https://images2.imgbox.com/4e/cd/6Qtzyw0s_o.png" width="696"></p> 
<p> 通过观察我们发现最开始为S状态--等待状态，子进程结束后未被父进程接受变成Z状态--僵尸状态，最后通过等待后返回子进程信息，子进程结束，父进程运行。</p> 
<p><strong>waitpid方法</strong></p> 
<blockquote> 
 <p>pid_ t waitpid(pid_t pid, int *status, int options);</p> 
 <p>返回值：</p> 
 <p>当正常返回的时候waitpid返回收集到的子进程的进程ID；</p> 
 <p>如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；</p> 
 <p>如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；</p> 
 <p>参数：</p> 
 <p>        pid：</p> 
 <p>                Pid=-1,等待任一个子进程。与wait等效。</p> 
 <p>                Pid&gt;0.等待其进程ID与pid相等的子进程。</p> 
 <p>        status:</p> 
 <p>                WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）</p> 
 <p>                WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）</p> 
 <p>        options:</p> 
 <p>                 WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。</p> 
</blockquote> 
<p><strong>获取子进程status</strong></p> 
<p>wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充。</p> 
<p>如果传递NULL，表示不关心子进程的退出状态信息。 否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程。</p> 
<p>status不能简单的当作整形来看待，可以当作位图来看待，具体细节如下图（只研究status低16比特位）：</p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/81/61/uZcG1bzT_o.png" width="728"></p> 
<p><strong> 代码测试：</strong></p> 
<pre><code>int main()    
{    
    pid_t id = fork();    
    if(id == 0)    
    {    
        //子进程    
        int cnt = 5;    
        while(cnt)    
        {    
            printf("我是子进程: %d, 父进程: %d, cnt: %dn", getpid(), getppid(), cnt--);    
           int *p = NULL;    
            *p = 100;    
            sleep(1);    
        }    
        // 运行完    
        // 1. 代码完，结果对    
        // 2. 代码完，结果不对    
        // 异常    
        // 3. 代码没跑完，出异常了    
        exit(12); //进程退出    
       //`` exit(0); //进程退出    
    }       
                                                                                                                                                                                           
    int status = 0; // 不是被整体使用的，有自己的位图结构    
    pid_t ret = waitpid(id, &amp;status, 0);    
    if(id &gt; 0)                  
    {                           
        printf("wait success: %d, sig number: %d, child exit code: %dn", ret, (status &amp; 0x7F), (status&gt;&gt;8)&amp;0xFF);    
    }                           
                                
    sleep(5);                   
} </code></pre> 
<blockquote> 
 <p><strong>运行结果：</strong></p> 
 <p> [hongxin@VM-8-2-centos 12-15]$ ./mytest <br> 我是子进程: 6347, 父进程: 6346, cnt: 5<br> wait success: 6347, sig number: 11, child exit code: 0 </p> 
</blockquote> 
<p><img alt="" height="269" src="https://images2.imgbox.com/8d/02/pQAxmOgi_o.png" width="802"></p> 
<p>通过kill手册可以明确地得到是野指针的问题！</p> 
<h3 id="%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><strong>阻塞与非阻塞</strong></h3> 
<p>如果子进程已经退出，调用wait/waitpid时，wait/waitpid会立即返回，并且释放资源，获得子进程退出信息。</p> 
<p>如果在任意时刻调用wait/waitpid，子进程存在且正常运行，则进程可能阻塞。</p> 
<p>如果不存在该子进程，则立即出错返回。</p> 
<p><img alt="" height="427" src="https://images2.imgbox.com/25/0a/nYLYDliu_o.png" width="752"></p> 
<p> 用更直白的话就是：在子进程运行的时候，父进程一直处于等待状态，这个时候父进程一直检测子进程状态，这个时候父进程没有干其他事情，这个过程就叫做---阻塞。</p> 
<p>相反的，如果在子进程运行的时候，父进程一直处于等待状态，这个时候父进程一直检测子进程状态，如果没有就绪，那么就直接返回，这个时候父进程能干一其他的事，这个过程就叫---非阻塞。每一次都是一次非阻塞等待；多次非阻塞等待就叫--轮询</p> 
<p>那么非阻塞有什么好处呢！如果当父进程检查到子进程未就绪，那么父进程就可以做一些其他的任务。</p> 
<p>非阻塞的好处就是：不会占用父进程的所有精力，可以在轮询期间，做其他任务。</p> 
<p><strong>非阻塞</strong></p> 
<p>代码测试：</p> 
<pre><code class="hljs">#include &lt;assert.h&gt;

#define NUM 10

typedef void (*func_t)(); //函数指针

func_t handlerTask[NUM];

//样例任务
void task1()
{
    printf("handler task1n");
}
void task2()
{
    printf("handler task1n");
}
void task3()
{
    printf("handler task1n");
}

void loadTask()
{
    memset(handlerTask, 0, sizeof(handlerTask));
    handlerTask[0] = task1;
    handlerTask[1] = task1;                                                                                                                                                                
    handlerTask[2] = task1;
}

void addtask()
{}
int main()
{
    pid_t id = fork();
    assert(id != -1);
    if(id == 0)
    {                                                                                                                                                                                      
        //child
        int cnt = 10;
        while(cnt)
        {
            printf("child running, pid: %d, ppid: %d, cnt: %dn", getpid(), getppid(), cnt--);
            sleep(1);
        //    int *p = 0;
        //    *p = 100; //野指针问题
        }

        exit(10);
    }

    loadTask();
    // parent
    int status = 0;
    while(1)
    {
        pid_t ret = waitpid(id, &amp;status, WNOHANG); //WNOHANG: 非阻塞-&gt; 子进程没有退出, 父进程检测时候，立即返回
        if(ret == 0)
        {
            // waitpid调用成功 &amp;&amp; 子进程没退出
            //子进程没有退出，我的waitpid没有等待失败，仅仅是监测到了子进程没退出.
            printf("wait done, but child is running...., parent running other thingsn");
            for(int i = 0; handlerTask[i] != NULL; i++)
            {
                handlerTask[i](); //采用回调的方式，执行我们想让父进程在空闲的时候做的事情
            }
        }
        else if(ret &gt; 0)
        {
            // 1.waitpid调用成功 &amp;&amp; 子进程退出了
  printf("wait success, exit code: %d, sig: %dn", (status&gt;&gt;8)&amp;0xFF, status &amp; 0x7F);
            break;
        }
        else
        {
            // waitpid调用失败
            printf("waitpid call failedn");
        //    break;
        }
        sleep(1);
    }
    return 0;

}
</code></pre> 
<blockquote> 
 <p><strong>运行结果：</strong></p> 
 <p>[hongxin@VM-8-2-centos 12-16]$ make<br> gcc -o mychild mychild.c -std=c99<br> [hongxin@VM-8-2-centos 12-16]$ ./mychild <br> wait done, but child is running...., parent running other things<br> handler task1<br> handler task1<br> handler task1<br> child running, pid: 22206, ppid: 22205, cnt: 10<br> wait done, but child is running...., parent running other things<br> handler task1<br> handler task1<br> handler task1</p> 
 <p>.......................................................................................................................</p> 
 <p>wait done, but child is running...., parent running other things<br> handler task1<br> handler task1<br> handler task1<br> wait done, but child is running...., parent running other things<br> handler task1<br> handler task1<br> handler task1<br> wait success, exit code: 10, sig: 0</p> 
</blockquote> 
<h2 id="%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%9B%BF%E6%8D%A2">进程程序替换</h2> 
<hr>
<h3 id="%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%90%86"><strong>替换原理</strong></h3> 
<p>用fork创建子进程后执行的是和父进程相同的程序(但有可能执行不同的代码分支),子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时,该进程的用户空间代码和数据完全被新程序替换,从新程序的启动例程开始执行。调用exec并不创建新进程,所以调用exec前后该进程的id并未改变。  </p> 
<p><img alt="" height="539" src="https://images2.imgbox.com/1f/13/K0NCfhkY_o.png" width="1198"></p> 
<p><strong>代码测试</strong></p> 
<pre><code class="hljs">#include &lt;stdio.h&gt;    
#include &lt;stdlib.h&gt;    
#include &lt;sys/types.h&gt;    
#include &lt;sys/wait.h&gt;    
#include &lt;assert.h&gt;    
#include &lt;unistd.h&gt;    
    
    
int main()    
{    
    printf("process is running..n");    
    
    execl("/usr/bin/ls","ls","-a",NULL);                                                                                                                                                   
    
    
    printf("process is running..n");    
    return 0;    
} </code></pre> 
<blockquote> 
 <p><strong>测试结果：</strong></p> 
 <p>[hongxin@VM-8-2-centos 12-16_1]$ ./myexec <br> process is running..<br> .  ..  Makefile  myexec  myexec.c</p> 
</blockquote> 
<p>通过测试结果我们发现没有打印最后的printf，这个原因就是因为printf在execl之后，当execl执行完之后，代码和数据已经完全被覆盖，开始执行新的代码了，所以printf就无法执行了！</p> 
<p>当我们写错后，又会是怎样的结果呢？</p> 
<blockquote> 
 <p><strong>测试代码：</strong></p> 
 <p>execl("/usr/bin/djhalshl","ls","-a",NULL);                                                                                   <strong>测试结果：</strong></p> 
 <p>[hongxin@VM-8-2-centos 12-16_1]$ ./myexec <br> process is running..<br> process is running..</p> 
</blockquote> 
<p>因为我们输入时是错误的地址，检测不到，这个时候execl函数就会调用失败，那么代码和数据就没有被替换，下面代码就继续执行。</p> 
<p>我们通过查man手册，我们又发现execl只有错误时返回值，而没有正确时的返回值。</p> 
<blockquote> 
 <p>RETURE VALUE<br>        The exec() functions return only if an error has occurred.  The return value is -1, and errno is set to indicate the error.</p> 
</blockquote> 
<p>这是因为成功后代码和数据就被覆盖了，再对下面判断就毫无意义，只要返回就一定是错误！</p> 
<p><strong>通常写法 </strong></p> 
<pre><code class="hljs">int main()    
{    
    printf("process is running..n");    
                                                                                                                                                                                           
    pid_t id  = fork();    
    assert(id != -1);    
    
    if(id == 0)    
    {    
        execlp("ls", "ls", "-a", "-l", "--color=auto", NULL);    
         exit(1);    
    
    }    
    
    int status = 0;    
    pid_t ret = waitpid(id, &amp;status, 0);    
    if(ret&gt;0) printf("wait success: exit code: %d, sig: %dn", (status&gt;&gt;8)&amp;0xFF, status &amp; 0x7F);    
    
    printf("process is running..n");    
    return 0;    
}</code></pre> 
<p>为了使execl不影响父进程的代码和数据，让子进程来执行来执行父进程的一部分代码。因为虚拟地址空间加页表保证了进程的独立性，一旦有执行流想要替换代码和数据，就会发生写时拷贝。</p> 
<blockquote> 
 <p><strong>运行结果：</strong></p> 
 <p>wait success: exit code: 0, sig: 0<br> process is running..</p> 
</blockquote> 
<p><strong>总结：创建子进程就是想让子进程执行一个全新的程序</strong></p> 
<h3 id="%E6%9B%BF%E6%8D%A2%E5%87%BD%E6%95%B0">替换函数</h3> 
<blockquote> 
 <p>#include &lt;unistd.h&gt; </p> 
 <p></p> 
 <p>int exec<strong>l</strong>(const char *path, const char *arg, ...);</p> 
 <p>l--list：将参数一个一个传入execl*中</p> 
 <p></p> 
 <p>int execl<strong>p</strong>(const char *file, const char *arg, ...);</p> 
 <p>p--path：不用告诉execl程序的路径，只需要告诉是谁,就会自动在环境变量PATH，进行可执行程序的查找</p> 
 <p></p> 
 <p>int execle , const char *arg, ...,char *const envp[]);</p> 
 <p>e：环境变量</p> 
 <p></p> 
 <p>int exec<strong>v</strong>(const char *path, char *const argv[]);</p> 
 <p>v--vector：可以将所有的执行参数，放入数组中，统一传递，而不用进行使用可变参数方案</p> 
 <p></p> 
 <p>int execvp(const char *file, char *const argv[]);</p> 
</blockquote> 
<p><strong>函数解释</strong></p> 
<blockquote> 
 <p>这些函数如果调用成功则加载新的程序从启动代码开始执行,不再返回。</p> 
 <p>如果调用出错则返回-1</p> 
 <p>所以exec函数只有出错的返回值而没有成功的返回值</p> 
</blockquote> 
<p><strong>命名理解</strong></p> 
<p>这些函数原型看起来很容易混,但只要掌握了规律就很好记。</p> 
<blockquote> 
 <p>l(list) : 表示参数采用列表</p> 
 <p>v(vector) : 参数用数组</p> 
 <p>p(path) : 有p自动搜索环境变量PATH</p> 
 <p>e(env) : 表示自己维护环境变量</p> 
</blockquote> 
<p><img alt="" height="195" src="https://images2.imgbox.com/ad/6d/JPCCRxQp_o.png" width="694"></p> 
<p><strong> exec调用举例如下:</strong></p> 
<blockquote> 
 <p></p> 
 <p>#include &lt;unistd.h&gt; </p> 
 <p>int main()</p> 
 <p>{<!-- --></p> 
 <p>        char *const argv[] = {"ps", "-ef", NULL};</p> 
 <p>        char *const envp[] = {"PATH=/bin:/usr/bin", "TERM=console", NULL};</p> 
 <p>        execl("/bin/ps", "ps", "-ef", NULL); // 带p的，可以使用环境变量PATH，无需写全路径</p> 
 <p>        execlp("ps", "ps", "-ef", NULL); // 带e的，需要自己组装环境变量</p> 
 <p>        execle("ps", "ps", "-ef", NULL, envp);</p> 
 <p>        execv("/bin/ps", argv); // 带p的，可以使用环境变量PATH，无需写全路径</p> 
 <p>        execvp("ps", argv); // 带e的，需要自己组装环境变量</p> 
 <p>        execve("/bin/ps", argv, envp);</p> 
 <p>        exit(0);</p> 
 <p>}</p> 
</blockquote> 
<p>事实上,只有execve是真正的系统调用,其它五个函数最终都调用 execve,所以execve在man手册 第2节,其它函数在man手册第3节。这些函数之间的关系如下图所示。 下图exec函数族 一个完整的例子:</p> 
<p><img alt="" height="334" src="https://images2.imgbox.com/2d/fd/BOvpZog2_o.png" width="693"></p> 
<p>结合以上知识，我们就可以用自己的程序调用自己的程序了</p> 
<p><strong>测试代码：</strong></p> 
<p> myexecl.c</p> 
<pre><code class="hljs">#include &lt;stdio.h&gt;    
#include &lt;stdlib.h&gt;    
#include &lt;sys/types.h&gt;    
#include &lt;sys/wait.h&gt;    
#include &lt;assert.h&gt;    
#include &lt;unistd.h&gt;    
    
    
int main()    
{    
    printf("process is running..n");    
    
    pid_t id  = fork();    
    assert(id != -1);    
    
    if(id == 0)    
    {    
        execlp("./mybin", "mybin", NULL);                                                                                                                                                  
         exit(1);    
    
    }    
    
    int status = 0;    
    pid_t ret = waitpid(id, &amp;status, 0);    
    if(ret&gt;0) printf("wait success: exit code: %d, sig: %dn", (status&gt;&gt;8)&amp;0xFF, status &amp; 0x7F);    
    
    printf("process is running..n");    
    return 0;    
} </code></pre> 
<p>mybin.c</p> 
<pre><code class="hljs">#include &lt;stdio.h&gt;    
    
int main()    
{    
    printf("这是另一个C程序n");    
    printf("这是另一个C程序n");    
    printf("这是另一个C程序n");    
    printf("这是另一个C程序n");    
     
    return 0;                                                                                                                                                                              
}</code></pre> 
<p>Makefile</p> 
<pre><code class="hljs">.PHONY:all    
all: mybin myexec    
    
mybin:mybin.c    
    gcc -o $@ $^ -std=c99    
myexec:myexec.c    
    gcc -o $@ $^ -std=c99    
.PHONY:clean    
clean:    
    rm -f myexec mybin                                                                                                                                                                     
~
</code></pre> 
<blockquote> 
 <p><strong>运行结果：</strong></p> 
 <p>[hongxin@VM-8-2-centos 12-16_1]$ ./myexec <br> process is running..<br> 这是另一个C程序<br> 这是另一个C程序<br> 这是另一个C程序<br> 这是另一个C程序<br> wait success: exit code: 0, sig: 0<br> process is running..</p> 
</blockquote> 
<p>既然我们可以用自己的程序调用自己的程序，main函数也是一个程序，它也需要被调用，也要被传参。</p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/a0/1b/d588stM3_o.png" width="708"></p> 
<h2 id="%E6%88%91%E7%9A%84shell">我的shell</h2> 
<hr>
<h3 id="%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C">
<strong>第一步：</strong>获取命令行</h3> 
<p>我们在使用shell的时候，发现我们在输入命令是，前面会有：有用户名，版本，当前路径等信息。</p> 
<blockquote> 
 <p>[hongxin@VM-8-2-centos Myshell]$</p> 
</blockquote> 
<p>这里我们可以用硬输入来直接写，这个完成后就是需要接受键盘输入的命令了。</p> 
<pre><code class="hljs">int main()
{
        // 输出提示符
        printf("用户名@主机名 当前路径# ");
        fflush(stdout);
        (void)s;
        // 清除最后一个n , abcdn
        lineCommand[strlen(lineCommand)-1] = 0; // ?
}</code></pre> 
<p>在打印的时候因为没有"n",所以就会造成缓冲区不刷新的问题，所以我就应该调用fflush刷新缓冲区。 </p> 
<p>我们通过打印测试发现：因为我们输入结束的时候，都会输入"n"那么就会造成多''n"。那么在字符数组lineCommand中最后一个删除即可。</p> 
<blockquote> 
 <p>[hongxin@VM-8-2-centos Myshell]$ ./myshell <br> 用户名@主机名 当前路径# ll<br> test : ll</p> 
 <p></p> 
 <p>[hongxin@VM-8-2-centos Myshell]$ </p> 
</blockquote> 
<h3 id="%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C">
<strong>第二步：</strong>解析命令行</h3> 
<p>我们在输入命令行时，可能不仅仅只输入"ls"，也有可能直接"ls -a -l -i"。那么在这个过程中，命令行解释器得到应该是"ls" "-a" "-l" "-i",所以我们需要分割字符串</p> 
<pre><code class="hljs">// 字符串切割
        myargv[0] = strtok(lineCommand, " ");
        int i = 1;
        if(myargv[0] != NULL &amp;&amp; strcmp(myargv[0], "ls") == 0)
        {
            myargv[i++] = (char*)"--color=auto";
        }

        // 如果没有子串了，strtok-&gt;NULL, myargv[end] = NULL
        while(myargv[i++] = strtok(NULL, " "));

 
        if(myargv[0] != NULL &amp;&amp; strcmp(myargv[0], "cd") == 0)
        {
            if(myargv[1] != NULL) chdir(myargv[1]);
            continue;
        }
        if(myargv[0] != NULL &amp;&amp; myargv[1] != NULL &amp;&amp; strcmp(myargv[0], "echo") == 0)
        {
            if(strcmp(myargv[1], "$?") == 0)
            {
                printf("%d, %dn", lastCode, lastSig);
            }
            else
            {
                printf("%sn", myargv[1]);
            }
            continue;
        }</code></pre> 
<p>这里会有几个特殊的点：</p> 
<p>1.首先我们是输入字符串，这里我们会用到strtok，关于strtok的用法我们需要注意的是，当我们第一次用strtok时：</p> 
<blockquote> 
 <p>myargv[0] = strtok(lineCommand, " ");</p> 
</blockquote> 
<p>那么第二次：就应该从null开始分割</p> 
<blockquote> 
 <p>  while(myargv[i++] = strtok(NULL, " ")); </p> 
</blockquote> 
<p>2.在输入ls的时候，我们都需要得到有颜色文件名--而是不需要输入系统默认的，它是为了更好识别不同文件的不同性质。那么我们就可以对myargv进行判断，如果命令是ls的时候--用是strcmp进行比较，我就增加"--color=auto”即可</p> 
<blockquote> 
 <p> if(myargv[0] != NULL &amp;&amp; strcmp(myargv[0], "ls") == 0)<br>         {<!-- --><br>             myargv[i++] = (char*)"--color=auto";<br>         }</p> 
</blockquote> 
<p>3.关于cd命令，如果直接执行cd命令我们会发现：cd没有改变当前路径</p> 
<blockquote> 
 <p>[hongxin@VM-8-2-centos Myshell]$ ./myshell <br> 用户名@主机名 当前路径# pwd<br> /home/hongxin/Myshell<br> 用户名@主机名 当前路径# cd ..<br> 用户名@主机名 当前路径# pwd<br> /home/hongxin/Myshell<br> 用户名@主机名 当前路径# cd ..<br> 用户名@主机名 当前路径# ^C<br> [hongxin@VM-8-2-centos Myshell]$ </p> 
</blockquote> 
<p>这里是因为我们只是子进程中进行操作，cd命令需要改变当前进程的工作目录，不改变当前执行的磁盘下的工作目录，那么这里我们就可以用chdir。</p> 
<blockquote> 
 <p>lrwxrwxrwx   1 hongxin hongxin 0 Dec 17 15:55 cwd -&gt; /home/hongxin/Myshell</p> 
 <p>-----当前进程的工作目录<br> -r--------   1 hongxin hongxin 0 Dec 17 15:55 environ<br> lrwxrwxrwx   1 hongxin hongxin 0 Dec 17 15:55 exe -&gt; /home/hongxin/Myshell/test<br> -----当前进程执行的磁盘下的那个一程序</p> 
</blockquote> 
<p>又因为我们更改的是子进程的工作目录，执行完毕后，我们还是继续用的是父进程。最后我用strcmp判断是cd命令，然后用chdir改变子进程的工作目录，再用continue执行父进程，因为外层是while循环，所以又可以在另一个工作目录进行操作。</p> 
<blockquote> 
 <p> if(myargv[0] != NULL &amp;&amp; strcmp(myargv[0], "cd") == 0)<br>         {<!-- --><br>             if(myargv[1] != NULL) chdir(myargv[1]);<br>             continue;<br>         }</p> 
</blockquote> 
<p>4.关于echo命令，它是需要输入之后显示的，那么直接打印即可，但是$?需要获取status,因为我们程序肯定是正确的，我们直接定义退出状态和终止信号为0就好。</p> 
<blockquote> 
 <p> if(myargv[0] != NULL &amp;&amp; myargv[1] != NULL &amp;&amp; strcmp(myargv[0], "echo") == 0)<br>         {<!-- --><br>             if(strcmp(myargv[1], "$?") == 0)<br>             {<!-- --><br>                 printf("%d, %dn", lastCode, lastSig);<br>             }<br>             else<br>             {<!-- --><br>                 printf("%sn", myargv[1]);<br>             }<br>             continue;<br>         }</p> 
</blockquote> 
<h3 id="%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%BB%BA%E7%AB%8Bfork%EF%BC%8Cexecvp%E6%9B%BF%E6%8D%A2%E5%AD%90%E8%BF%9B%E7%A8%8B">
<strong>第三步：建立fork，</strong>execvp替换子进程</h3> 
<p>这里我们需要知道为什么选择vp，因为这里用到了指针数组，所以我应该选择v：参数用数组；又因为我们需要自动搜索环境变量，所以会用到p：PATH。</p> 
<pre><code class="hljs">pid_t id = fork();
        assert(id != -1); 
if(id == 0)
        {
            execvp(myargv[0], myargv);
            exit(1);
        }</code></pre> 
<h3 id="%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%EF%BC%88wait%EF%BC%89">第四步：父进程等待子进程退出（wait）</h3> 
<p>最后一步就是为预防进程变成了僵尸进程</p> 
<pre><code class="hljs"> int status = 0;
        pid_t ret = waitpid(id, &amp;status, 0);
        assert(ret &gt; 0);
        (void)ret;
        lastCode = ((status&gt;&gt;8) &amp; 0xFF);
        lastSig = (status &amp; 0x7F);</code></pre> 
<h3 id="%E4%BB%A3%E7%A0%81%E6%80%BB%E6%8B%AC">代码总括</h3> 
<pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;assert.h&gt;

#define NUM 1024
#define OPT_NUM 64

char lineCommand[NUM];
char *myargv[OPT_NUM]; //指针数组
int  lastCode = 0;
int  lastSig = 0;

int main()
{
    while(1)
    {
        // 输出提示符
        printf("用户名@主机名 当前路径# ");
        fflush(stdout);

        // 获取用户输入, 输入的时候，输入n
        char *s = fgets(lineCommand, sizeof(lineCommand)-1, stdin);
        assert(s != NULL);
        (void)s;
        // 清除最后一个n , abcdn
        lineCommand[strlen(lineCommand)-1] = 0; // ?
        //printf("test : %sn", lineCommand);
        
        // "ls -a -l -i" -&gt; "ls" "-a" "-l" "-i" -&gt; 1-&gt;n
        // 字符串切割
        myargv[0] = strtok(lineCommand, " ");
        int i = 1;
        if(myargv[0] != NULL &amp;&amp; strcmp(myargv[0], "ls") == 0)
        {
            myargv[i++] = (char*)"--color=auto";
        }

        // 如果没有子串了，strtok-&gt;NULL, myargv[end] = NULL
        while(myargv[i++] = strtok(NULL, " "));

        // 如果是cd命令，不需要创建子进程,让shell自己执行对应的命令，本质就是执行系统接口
        // 像这种不需要让我们的子进程来执行，而是让shell自己执行的命令 --- 内建/内置命令
        if(myargv[0] != NULL &amp;&amp; strcmp(myargv[0], "cd") == 0)
        {
            if(myargv[1] != NULL) chdir(myargv[1]);
            continue;
        }
        if(myargv[0] != NULL &amp;&amp; myargv[1] != NULL &amp;&amp; strcmp(myargv[0], "echo") == 0)
        {
            if(strcmp(myargv[1], "$?") == 0)
            {
                printf("%d, %dn", lastCode, lastSig);
            }
            else
            {
                printf("%sn", myargv[1]);
            }
            continue;
        }
        // 测试是否成功, 条件编译
#ifdef DEBUG
        for(int i = 0 ; myargv[i]; i++)
        {
            printf("myargv[%d]: %sn", i, myargv[i]);
        }
#endif
        // 内建命令 --&gt; echo

        // 执行命令
        pid_t id = fork();
        assert(id != -1);

        if(id == 0)
        {
            execvp(myargv[0], myargv);
            exit(1);
        }
        int status = 0;
        pid_t ret = waitpid(id, &amp;status, 0);
        assert(ret &gt; 0);
        (void)ret;
        lastCode = ((status&gt;&gt;8) &amp; 0xFF);
        lastSig = (status &amp; 0x7F);
    }
}</code></pre> 
<blockquote> 
 <p><strong>运行测试：</strong></p> 
 <p>hongxin@VM-8-2-centos Myshell]$ ./myshell <br> 用户名@主机名 当前路径# pwd<br> /home/hongxin/Myshell<br> 用户名@主机名 当前路径# ls<br> Makefile  myshell  myshell.c  test  test.c<br> 用户名@主机名 当前路径# ls -a<br> .  ..  Makefile  myshell  myshell.c  test  test.c</p> 
 <p>用户名@主机名 当前路径# echo "hello"<br> "hello"<br> 用户名@主机名 当前路径# pwd<br> /home/hongxin/Myshell<br> 用户名@主机名 当前路径# cd ..<br> 用户名@主机名 当前路径# pwd<br> /home/hongxin<br> 用户名@主机名 当前路径# ^C<br> [hongxin@VM-8-2-centos Myshell]$ </p> 
</blockquote> 
<p><span style="color:#0d0016"><strong>                                                                       完结！</strong></span></p> 
<hr>
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/f8/88/e2kM6TcK_o.gif"></p> 
<p> </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>