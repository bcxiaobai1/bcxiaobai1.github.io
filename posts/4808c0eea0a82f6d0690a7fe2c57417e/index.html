<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>新手入门linux必看 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">新手入门linux必看</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="_0"></a>写在前面</h1> 
<p>这是本linux纯小白的linux学习笔记，主要听b站韩顺平老师的课程，更加详细的知识点来源于各种博客与百度大佬的介绍供自己及时复习，现供大家参考。以后更加深度学习linux后会继续写相关进阶博客。</p> 
<h1>
<a id="_2"></a>一些骚话</h1> 
<p>操作系统是覆盖在裸机之上的第一层软件，直接控制管理各种硬件资源，所以操作系统是整个计算机系统的控制管理中心。</p> 
<p>linux内核kernel是系统的心脏，是运行程序，管理磁盘和操作计算机硬件设备的核心程序，实现操作系统的基本功能，包括cpu调度，作业管理，内存管理，文件管理，磁盘管理。</p> 
<p>shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。接收用户的命令，并且把它送到内核去执行。</p> 
<p>linux应用程序，包括文本编辑器，编程语言，办公套件，数据库等。</p> 
<p>linux系统特点：开放性，多用户，多任务，界面友好，设备独立，网络强，安全性，可移植，兼容性，支持多种文件系统。</p> 
<p>linux内核版本号由三个数字组成r.x.y 目前发布的kernel版本（主版本号）.偶数：稳定版本，奇数：开发中版本（次版本号）.错误修补次数</p> 
<p>$表示普通用户，输入su再按回车再输入密码切换为超级用户。su fzh 回车切换到普通用户。</p> 
<p>重启或关闭系统时超级用户下输入以下命令：shutdown -r 10 Attention:System will be reboot in 10 minites,Please save your work</p> 
<p>shell是系统的用户界面。提供了用户与内核进行交互的一种接口，接受用户的命令并把他送入内核去执行。</p> 
<h1>
<a id="_24"></a>虚拟机克隆</h1> 
<p>方式一：直接拷贝安装好的虚拟机文件到别的盘，再用vmware打开。文件-&gt;打开-&gt;找到.vmx文件</p> 
<p>方式二：使用vmware的克隆操作。（克隆时，需要先关闭linux系统）</p> 
<blockquote> 
 <p>右键想要克隆的虚拟机-&gt;管理-&gt;克隆-&gt;创建完整克隆</p> 
</blockquote> 
<h1>
<a id="_32"></a>虚拟机迁移和删除</h1> 
<p>虚拟系统本质上是文件（放在文件夹里），因此迁移就是将安装好的虚拟系统这个文件夹整体拷贝或者剪切到另外位置使用。</p> 
<p>删除用vmware进行移除，再点击菜单-&gt;从磁盘删除即可，或者手动删除虚拟系统对应的文件夹即可。</p> 
<h1>
<a id="_38"></a>虚拟机快照</h1> 
<p>使用虚拟机想要回到原先一个状态，vmware有个快照管理的功能。</p> 
<p>担心有些误操作，需要回到原先的某个正常运行状态。</p> 
<p>选中虚拟机，右键，快照，创建快照，变化的时候打开快照管理</p> 
<h1>
<a id="linux_46"></a>安装linux的三种网络连接模式</h1> 
<p>1.桥接模式：虚拟系统可以和外部系统通讯，但是容易造成ip冲突</p> 
<p>2.NAT模式：网络地址转换模式，虚拟系统可以和外部系统通讯，不会造成ip冲突</p> 
<p>3.主机模式：独立系统，不和外界发生联系。</p> 
<h1>
<a id="linux_54"></a>linux下一切都是文件</h1> 
<p>/bin (binaries)存放二进制可执行文件，存放经常使用的命令<br> /sbin (super user binaries)存放二进制可执行文件，只有root才能访问<br> /etc (etcetera)存放系统配置文件<br> /usr (unix shared resources)用于存放共享的系统资源，类似win的program files目录<br> /home 存放普通用户文件的根目录<br> /root 超级用户目录<br> /dev (devices)用于存放设备文件<br> /lib (library)存放跟文件系统中的应用程序运行所需要的动态连接共享库及内核模块，类似windows的dll文件<br> /mnt (mount)系统管理员安装临时文件系统的安装点，可以将外部的存储挂载/mnt上，共享文件夹在这里<br> /boot 存放用于系统引导时使用的各种文件，存放系统启动相关文件，包括一些连接文件，镜像文件，不要动<br> /tmp (temporary)用于存放各种临时文件<br> /var (variable)用于存放运行时需要改变数据的文件<br> /opt 给主机额外安装软件所摆放的目录<br> /lost+found 这个目录一般情况下是空的，当系统非法关机后，里面就存放一些文件**<br> 在linux下隐藏文件是拿.开头的</p> 
<h1>
<a id="linuxvi_vimvi_72"></a>linux系统内置vi文本编辑器 vim是vi的增强版</h1> 
<ol>
<li> <p>登录xShell （使用XShell来连接并使用安装好Linux系统的虚拟机）</p> </li>
<li> <p>vim Hello.java回车后进入正常模式（好像每次vim都创建一个新文件，后来懂了，原来不存在的时候才会创建新的），按下ioar任何一个字母进入插入（编辑）模式，即可写代码</p> </li>
<li> <p>为保存文件需要进入命令行模式，按下esc，再输入：，再输入wq（写入并退出write，quit），回车</p> </li>
<li> <p>命令行模式下 输入vim He哎等等！现在咱们按下tab键就可以自动补全了，重新进入文件</p> <h4>
<a id="_82"></a>各种模式切换</h4> <p>命令行模式-&gt;一般（正常）模式 ❀ vim xxx 执行这个最先进入的就是一般模式</p> <p>一般模式-&gt;编辑（插入）模式 ❀ ioar（一般ia，懂我意思把，哈哈），回退 esc</p> <p>一般-&gt;命令行 ❀按：或者/ ，回退esc ， 在输入（wq或q！）q！不保存退出</p> </li>
</ol> 
<h4>
<a id="_90"></a>一般模式下的快捷键</h4> 
<ul>
<li>拷贝当前行 yy，多行xyy 并粘贴（输入p)</li>
<li>删除当前行dd，多行xdd（5dd删光标下五行）</li>
<li>vim /etc/profile 进入一般模式，编辑/etc/profile文件，到文件首行gg，末行G</li>
<li>插入模式下想撤回刚刚动作，按下esc进入一般模式，按u撤回</li>
<li>定位到第20行： 输入20（我们是看不到我们的输入的！）再shift+g</li>
</ul> 
<h4>
<a id="_98"></a>命令行模式下快捷键</h4> 
<ul>
<li>一般模式下，输入/进入命令行模式，输入要查找的单词，回车，按n查找下一个</li>
<li>set nu设置文件行号，set nonu 删除行号，每次执行操作时都要再次输入：（不能使用‘/’不知道为啥）</li>
<li>编辑etc/profile文件，到文件首行</li>
</ul> 
<h1>
<a id="_104"></a>关机&amp;重启命令</h1> 
<p>shutdown</p> 
<blockquote> 
 <p>-h now 立即关机 h ：halt停止</p> 
 <p>-h 1 1分钟后关机</p> 
 <p>-r now 选中重启 rehoot 重启</p> 
</blockquote> 
<p>rehoot 重启</p> 
<p>halt 关机</p> 
<p>sync 把内存从数据同步到磁盘。关机，重启之前最好执行多次这个命令</p> 
<h1>
<a id="_120"></a>用户和组相关的文件（命令行模式下输入）</h1> 
<ul>
<li>/etc/passwd 文件: 记录用户的各种信息，每增加一个用户，增加到这个文件里，每行含义：（笔记后面有详细介绍）<br> 用户名：口令（看不到x)：用户标识符：组标识符：注释性描述：主目录：登录shell</li>
<li>/etc/shadow 文件 ：记录口令信息，每行含义：登录名：密码：中间各种时间：标志</li>
<li>/etc/group 文件: 记录组信息</li>
</ul> 
<p>shell：命令解释器，将指令翻译解释后发给内核，shell是操作系统最外面的一层，种类很多bash（bashell），csh(Unix,linux系统），cmd.exe(windows NT系统），同时它又是一程序设计命令语言，它交互式的解释和执行用户输入的命令。排序算法中，shell是希尔排序的名称。命令行式shell（command line interface shell,即CLI shell)</p> 
<p>dos：Disk Operating System,磁盘操作系统，</p> 
<p>su - 用普通用户登陆后，再用“su - 用户名”切换成系统管理员</p> 
<p>logout 注销用户，在图形界面无效，在运行级别3下有效 或者exit</p> 
<p>useradd 默认该用户家目录在/home/xxx</p> 
<blockquote> 
 <p>-d 指定目录，给新的用户指定家目录 directory目录</p> 
 <p>eg; useradd -d /home/test king</p> 
</blockquote> 
<p>userdel</p> 
<blockquote> 
 <p>1.删除该用户，但保留家目录</p> 
 <p>userdel fan<br> [root@fanzhenhua home]# ls<br> abc.txt ahh apple.txt fan</p> 
 <p>2.不保留家目录 -r</p> 
</blockquote> 
<p>passwd xxx 给xxx设置密码</p> 
<p>pwd指令 ：print working directory,显示当前工作目录的绝对路径(从根目录开始/home/tom/a.txt，相对路径是从当前目录开始，若在home中，则tom/a.txt)</p> 
<p>id xxx 查询该用户信息,组名啥的</p> 
<p>whoami 此时运行的用户信息</p> 
<p>groupadd groupdel</p> 
<blockquote> 
 <p>useradd -g 用户组 用户名</p> 
 <p>usermod -g用户组 用户名 修改用户的组</p> 
</blockquote> 
<h1>
<a id="_169"></a>一些命令</h1> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">/</span><span class="token punctuation">]</span><span class="token comment"># uname -r            #查看版本信息</span>
<span class="token number">3.10</span><span class="token number">.0</span><span class="token operator">-</span><span class="token number">957.</span>el7<span class="token punctuation">.</span>x86_64
uname <span class="token operator">-</span>m <span class="token comment">#显示所用机器类型</span>
uname <span class="token operator">-</span>i <span class="token comment">#显示所用硬件平台</span>
uname <span class="token operator">-</span>v <span class="token comment">#显示操作系统版本</span>
</code></pre> 
<ul><li>ln 快捷方式</li></ul> 
<p>⚪软连接（符号链接）</p> 
<p>ln -s(soft软连接) 链接目标文件 链接名 *cat 链接名 就相当于:cat 目标文件</p> 
<p>⚪硬链接（保护文件不被错误删除），删除文件后，硬链接还可以找到文件</p> 
<p>ln 链接目标文件 链接名</p> 
<p>一个文件定位一个文件，最主要找inode（stat命令显示）</p> 
<p>硬链接直接指向inode，软连接先指向目标文件后，目标文件才指向inode</p> 
<ul><li>重定向<br> <strong>这个关于重定向的笔记是我学习一大佬的，原文翻找不到了</strong>
</li></ul> 
<p>输出重定向是指命令的结果不再输出到显示器上，而是输出到其它地方，一般是文件中。这样做的最大好处就是把命令的结果保存起来，当我们需要的时候可以随时查询。</p> 
<p>ll /root &gt; test<br> ll /opt &gt;test *最后test显示/opt里面信息，因为是覆盖性追加</p> 
<p>为了表示和区分已经打开的文件，Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。</p> 
<table>
<thead><tr>
<th>文件描述符</th>
<th>文件名</th>
<th>类型</th>
<th>硬件</th>
</tr></thead>
<tbody>
<tr>
<td>0</td>
<td>stdin</td>
<td>标准输入文件</td>
<td>键盘</td>
</tr>
<tr>
<td>1</td>
<td>stdout</td>
<td>标准输出文件</td>
<td>显示器</td>
</tr>
<tr>
<td>2</td>
<td>stderr</td>
<td>标准错误输出文件</td>
<td>显示器</td>
</tr>
</tbody>
</table>
<p>Linux 程序在执行任何形式的 I/O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。stdin、stdout、stderr 默认都是打开的，在重定向的过程中，0、1、2 这三个文件描述符可以直接使用。</p> 
<table>
<thead><tr>
<th>类 型</th>
<th>符 号</th>
<th>作 用</th>
</tr></thead>
<tbody>
<tr>
<td>标准输出重定向</td>
<td>command &gt;file</td>
<td>以覆盖的方式，把 command 的正确输出结果输出到 file 文件中。</td>
</tr>
<tr>
<td></td>
<td>command &gt;&gt;file</td>
<td>以追加的方式，把 command 的正确输出结果输出到 file 文件中。</td>
</tr>
<tr>
<td>标准错误输出重定向</td>
<td>command 2&gt;file</td>
<td>以覆盖的方式，把 command 的错误信息输出到 file 文件中。</td>
</tr>
<tr>
<td></td>
<td>command 2&gt;&gt;file</td>
<td>以追加的方式，把 command 的错误信息输出到 file 文件中。</td>
</tr>
<tr>
<td>正确输出和错误信息同时保存</td>
<td>command &gt;file 2&gt;&amp;1</td>
<td>以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（file）中。</td>
</tr>
<tr>
<td></td>
<td>command &gt;&gt;file 2&gt;&amp;1</td>
<td>以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中。</td>
</tr>
<tr>
<td></td>
<td>command &gt;file1 2&gt;file2</td>
<td>以覆盖的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。</td>
</tr>
<tr>
<td></td>
<td>command &gt;&gt;file1 2&gt;&gt;file2</td>
<td>以追加的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。</td>
</tr>
</tbody>
</table>
<p>当文件描述符为 1 时，一般都省略不写，如上表所示；当然，如果你愿意，也可以将<code>command &gt;file</code>写作<code>command 1&gt;file</code>，但这样做是多此一举。</p> 
<p>文件描述符和&gt;之间不能有空格（反正&lt;两边都不加空格，默认为1或者0不写的时候就为空格）</p> 
<pre><code>[c.biancheng.net]$ ls -l  #先预览一下输出结果
总用量 16
drwxr-xr-x. 2 root     root      21 7月   1 2016 abc
-rw-r--r--. 1 mozhiyan mozhiyan 399 3月  11 17:12 demo.sh
-rw-rw-r--. 1 mozhiyan mozhiyan  67 3月  22 17:16 demo.txt
[c.biancheng.net]$ ls -l &gt;demo.txt  #重定向
[c.biancheng.net]$ cat demo.txt  #查看文件内容
总用量 12
drwxr-xr-x. 2 root     root      21 7月   1 2016 abc
-rw-r--r--. 1 mozhiyan mozhiyan 399 3月  11 17:12 demo.sh
-rw-rw-r--. 1 mozhiyan mozhiyan   0 3月  22 17:21 demo.txt
</code></pre> 
<ul><li>错误输出重定向举例</li></ul> 
<p>命令正确执行是没有错误信息的，我们必须刻意地让命令执行出错，如下所示：</p> 
<pre><code>[c.biancheng.net]$ ls java  #先预览一下错误信息
ls: 无法访问java: 没有那个文件或目录
[c.biancheng.net]$ ls java 2&gt;err.log  #重定向
[c.biancheng.net]$ cat err.log  #查看文件
ls: 无法访问java: 没有那个文件或目录
</code></pre> 
<ul><li>正确输出和错误信息同时保存</li></ul> 
<p>【实例1】把正确结果和错误信息都保存到一个文件中，例如：</p> 
<pre><code>[c.biancheng.net]$ ls -l &gt;out.log 2&gt;&amp;1
[c.biancheng.net]$ ls java &gt;&gt;out.log 2&gt;&amp;1
[c.biancheng.net]$ cat out.log
总用量 12
drwxr-xr-x. 2 root     root      21 7月   1 2016 abc
-rw-r--r--. 1 mozhiyan mozhiyan 399 3月  11 17:12 demo.sh
ls: 无法访问java: 没有那个文件或目录
</code></pre> 
<p>out.log 的最后一行是错误信息，其它行都是正确的输出结果。</p> 
<p>上面的实例将正确结果和错误信息都写入同一个文件中，这样会导致视觉上的混乱，不利于以后的检索，所以我建议把正确结果和错误信息分开保存到不同的文件中，也即写成下面的形式：</p> 
<pre><code>ls -l &gt;&gt;out.log 2&gt;&gt;err.log
</code></pre> 
<p>这样一来，正确的输出结果会写入到 out.log，而错误的信息则会写入到 err.log。</p> 
<h4>
<a id="devnull__278"></a>/dev/null 文件</h4> 
<p>如果你既不想把命令的输出结果保存到文件，也不想把命令的输出结果显示到屏幕上，干扰命令的执行，那么可以把命令的所有结果重定向到 /dev/null 文件中。如下所示：</p> 
<pre><code>ls -l &amp;&gt;/dev/null
</code></pre> 
<p>可以把 /dev/null 当成 Linux 系统的垃圾箱，任何放入垃圾箱的数据都会被丢弃，不能恢复。</p> 
<ul><li>输入重定向就是改变输入的方向，不再使用键盘作为命令输入的来源，而是使用文件作为命令的输入。</li></ul> 
<table>
<thead><tr>
<th>符号</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>command &lt;file</td>
<td>将 file 文件中的内容作为 command 的输入。</td>
</tr>
<tr>
<td>command &lt;&lt;END</td>
<td>从标准输入（键盘）中读取数据，直到遇见分界符 END 才停止（分界符可以是任意的字符串，用户自己定义）。</td>
</tr>
<tr>
<td>command file2</td>
<td>将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2。</td>
</tr>
</tbody>
</table>
<p>和输出重定向类似，输入重定向的完整写法是<code>fd&lt;file</code>，其中 fd 表示文件描述符，如果不写，默认为 0，也就是标准输入文件。</p> 
<h1>
<a id="_299"></a>运行级别</h1> 
<p>init 【012345】 0：关机 3：多用户状态下有网络服务 5：图像界面</p> 
<p>systemctl get-default 查询当前级别（graphical.target图像，multi-user.target 多用户有网络服务级别）</p> 
<p>systemctl set-default multi-user.target 进入多用户有网络服务级别</p> 
<h1>
<a id="_307"></a>文件目录类</h1> 
<h3>
<a id="_309"></a>选项</h3> 
<ul>
<li>-l long</li>
<li>-a all</li>
<li>-t time</li>
<li>-p 父目录不存在情况下先生成父目录parents</li>
<li>-r 递归处理。将指定目录下的文件与子目录一并拷贝recursive</li>
<li>-f 强制删除文件或目录（rm -f）force</li>
</ul> 
<h3>
<a id="_318"></a>快捷键</h3> 
<p>ctrl+c 停止当前进程</p> 
<p>ctrl+r 查看历史命令</p> 
<p>ctrl+l清屏，与clear命令作用相同</p> 
<p>ls： 显示文件和目录列表，ls -l 详细内容。ls -lh让文件大小的格式不是字节的形式显示出来eg：200M h=human人比较容易看</p> 
<p>cd：change directory, 切换到指定目录, cd ~，cd：回到家目录, 若是登录用的root，就到/root，若用tom登录，就到/home<br> cd …回到当前目录的上一级目录</p> 
<blockquote> 
 <pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">/</span><span class="token punctuation">]</span><span class="token comment"># cd ~fzh  # 代表去fzh这个用户的家目录，亦即cd /home/fzh</span>
<span class="token punctuation">[</span>root@fanzhenhua fzh<span class="token punctuation">]</span><span class="token comment"># cd ~    # 代表回到自己家目录</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cd ~fzh</span>
<span class="token punctuation">[</span>root@fanzhenhua fzh<span class="token punctuation">]</span><span class="token comment"># cd       # 没有加上任何路径，还是代表回到自己家目录</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cd ~fzh</span>
<span class="token punctuation">[</span>root@fanzhenhua fzh<span class="token punctuation">]</span><span class="token comment"># cd ..   # 代表去到目前的上层目录</span>
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># cd -   # 代表回到刚刚那个目录，看下面输出，回到了fzh</span>
<span class="token operator">/</span>home<span class="token operator">/</span>fzh

</code></pre> 
</blockquote> 
<ul>
<li> <p>用绝对路径到fan目录(本来在root)：/home/fan</p> </li>
<li> <p>用相对路径到/root : cd …/…/(回到根目录)root(找到)，完整的就是：cd …/…/root</p> </li>
<li> <p>mkdir 创建目录 ：mkdir /home/dog(home已存在，故相当于创建一个目录) -p创建多级目录:mkdir -p /home/dog/air</p> </li>
<li> <p>rmdir 删除空目录 -rf删除非空目录（谨慎）</p> </li>
<li> <p>touch 创建空文件 touch hello.txt hello2.txt</p> </li>
<li> <p>cp copy拷贝文件到指定目录(copy)<br> cp [选项] source(文件) dest(要拷贝到的地方)<br> -r递归复制整个文件夹 强制覆盖不提示 /cp</p> </li>
<li> <p>rm 删除文件或目录 -r(recursion)递归删除整个<u>文件夹</u>， -f 强制删除不提示</p> </li>
<li> <p>mv 移动文件与目录或重命名 ，</p> </li>
</ul> 
<blockquote> 
 <p>mv 旧名 新名</p> 
 <p>mv pig.txt /root/ 移动</p> 
 <p>mv pig.txt /root/cow.txt 移动并且改名</p> 
 <p>将opt的bbb目录下全部移动到home目录下 mv bbb/ /home/ 此时进入opt目录，bbb/是相对路径</p> 
</blockquote> 
<ul>
<li> <p>cat 查看文件内容 -n显示行号 ,<br> 为了浏览方便，一般带上管道命令 |more <strong>管道就是将前面得到的结果传给后面进行操作</strong><br> cat -n /etc/profile | more ，enter换行 空格换页 全部显示完毕退出来 catenate</p> </li>
<li> <p>more 基于vim编辑器的文本过滤器，以全屏幕的方式按页显示文本文件的内容。<br> 交互指令：enter换行， 空格换页 ，q 退出，ctrl+f向下滚动一屏，ctrl+b返回上一屏，=输出当前行号，：f输出文件名和当前行的行号</p> </li>
<li> <p>less 分屏查看文件内容，比more强大，支持各种显示终端，并不是把整个文件加载出来才显示的，而是根据显示加载，对大型文件有较高的效率。<br> 空格：向下翻页，[pagedown]:向下翻页，[gapeup]：向上翻页，/字串或者？字串： n：向下查找，N向上查找，q退出</p> </li>
<li> <p>echo 输出内容到控制台，相当于print<br> eg：echo $PATH 输出 /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin<br> echo $HOSTNAME 输出 hspEdu01<br> echo “hello” &gt;/home/ahh.txt把hello写入ahh.txt中</p> </li>
<li> <p>head 显示文件的开头部分，默认前十行head 文件名，head -n 5 文件名 ：前五行</p> </li>
<li> <p>tail 显示文件尾部，除了与上面差不多的两个外，tail -f 文件：实时追踪该文档的所有更新 循环读取（follow）<br> 实时监控mydate.txt 看看文件有变化时，实时的追加 “变化” ctrl+c退出</p> </li>
</ul> 
<pre><code class="prism language-linux">[root@fanzhenhua home]# touch mydate.txt
[root@fanzhenhua home]# tail -f mydate.txt
hello
eyigeo

虚拟器终端如此操作
[root@fanzhenhua ~]# echo "hello" &gt; /home/mydate.txt
[root@fanzhenhua ~]# echo "wzaixieyigeo" &gt; /home/mydate.txt 

</code></pre> 
<ul><li>wc : word count,统计文本的行数，字数，字符数</li></ul> 
<blockquote> 
 <p>-m 统计文本字符数</p> 
 <p>-w 统计文本字数</p> 
 <p>-l 统计文本行数</p> 
</blockquote> 
<p>ln 软链接也叫符号链接,类似windows里的快捷方式,主要存放链接其他文件的路径 link<br> ln -s [原文件或目录 软连接名 功能：给原文件创建一个软连接<br> eg：/home 目录下创建一个软连接myboot 连接到/root目录</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># ln -s /root/   /home/myboot </span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># ls -l /home</span>
总用量 <span class="token number">36</span>
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">1</span> <span class="token number">1000</span> root      <span class="token number">0</span> <span class="token number">7</span>月  <span class="token number">12</span> <span class="token number">11</span><span class="token punctuation">:</span><span class="token number">03</span> abc<span class="token punctuation">.</span>txt
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">1</span> <span class="token number">1003</span> root      <span class="token number">0</span> <span class="token number">7</span>月  <span class="token number">11</span> <span class="token number">00</span><span class="token punctuation">:</span><span class="token number">07</span> apple<span class="token punctuation">.</span>txt
drwx<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span> <span class="token number">16</span> fzh  fzh    <span class="token number">4096</span> <span class="token number">10</span>月  <span class="token number">9</span> <span class="token number">16</span><span class="token punctuation">:</span><span class="token number">36</span> fzh
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">1</span> root root     <span class="token number">30</span> <span class="token number">7</span>月  <span class="token number">10</span> <span class="token number">23</span><span class="token punctuation">:</span><span class="token number">26</span> hello<span class="token punctuation">.</span>txt
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">1</span> root root    <span class="token number">668</span> <span class="token number">10</span>月 <span class="token number">20</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">26</span> info<span class="token punctuation">.</span>txt
drwxrwx<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">5</span> jack police <span class="token number">4096</span> <span class="token number">7</span>月  <span class="token number">12</span> <span class="token number">11</span><span class="token punctuation">:</span><span class="token number">48</span> jack
lrwxrwxrwx<span class="token punctuation">.</span>  <span class="token number">1</span> root root      <span class="token number">6</span> <span class="token number">10</span>月 <span class="token number">20</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">36</span> myboot <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token operator">/</span>root<span class="token operator">/</span>    <span class="token comment">#得到这个，前面l代表link</span>

<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cd /home/myboot/   #相当于进入了root目录</span>
<span class="token punctuation">[</span>root@fanzhenhua myboot<span class="token punctuation">]</span><span class="token comment"># ll            #将会显示root的文件</span>
</code></pre> 
<blockquote> 
 <p>-s对源文件建立符号链接，而非硬链接</p> 
</blockquote> 
<ul><li>history 查看已经执行过的历史命令，也可以执行历史命令</li></ul> 
<blockquote> 
 <p>显示所有 history</p> 
 <p>最近10个 history 10</p> 
 <p>执行历史编号为5的指令 ！5</p> 
</blockquote> 
<ul>
<li> <p>top 显示当前系统中耗费资源最多的进程</p> </li>
<li> <p>ps 显示瞬间的进程状态</p> </li>
</ul> 
<blockquote> 
 <p>-e/-A 显示所有进程，环境变量</p> 
 <p>-f 全格式</p> 
 <p>-a 显示所有用户的所有进程</p> 
 <p>-u 按用户名和启动时间的顺序来显示进程</p> 
 <p>-x 显示无控制终端的进程</p> 
</blockquote> 
<ul>
<li> <p>kill 杀死一个进程</p> </li>
<li> <p>df 显示文件系统磁盘空间的使用情况</p> </li>
<li> <p>du 显示指定的文件已使用的磁盘空间的总文件大小</p> </li>
<li> <p>free 显示当前内存和交换空间的使用情况</p> </li>
<li> <p>netstat 显示网络状态信息</p> </li>
</ul> 
<blockquote> 
 <p>-a 显示所有连接和监听端口</p> 
 <p>-t （tcp） 仅显示tcp相关选项</p> 
 <p>-u udp 仅显示udp相关选项</p> 
 <p>-n 拒绝显示别名，能显示数字的全部转化数字</p> 
 <p>-p 显示建立相关链接的程序名</p> 
</blockquote> 
<ul>
<li> <p>ifconfig 网卡网络配置详解</p> </li>
<li> <p>ping 测试网络连通性</p> </li>
<li> <p>locate指令。which指令可查看某个指令在那个目录下。grep指令（过滤查找）。</p> </li>
</ul> 
<h3>
<a id="_483"></a>时间指令</h3> 
<blockquote> 
 <p>date 显示当前时间</p> 
 <p>date +%Y年份</p> 
 <p>date +%m月份</p> 
 <p>date +%d哪一天</p> 
 <p>date "+%Y-%m-%d %H:%M:%S"显示年月日时分秒</p> 
 <p>date -s “2021-11-11 20：02：10 ” 设置系统当前日期为这个</p> 
</blockquote> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># date "+%Y-%m-%d"</span>
<span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">20</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># date "+%Y%m%d"</span>
<span class="token number">20211020</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># date "+%Y %m %d"</span>
<span class="token number">2021</span> <span class="token number">10</span> <span class="token number">20</span>

</code></pre> 
<ul><li>cal</li></ul> 
<blockquote> 
 <p>cal 显示本月日历</p> 
 <p>cal 2020 显示2020整年日历</p> 
</blockquote> 
<h3>
<a id="_513"></a>查找命令</h3> 
<ul><li>find 将从指定目录向下递归的遍历各个子目录，将满足条件的文件或目录显示在终端 基本语法： find 搜索范围 选项</li></ul> 
<blockquote> 
 <p>-name find /home -name hello.txt 按名称查找/home目录下的hello.txt文件</p> 
 <p>-user find /opt -user mick 查找/opt目录下用户mick创建的文件</p> 
 <p>-size find / -size +200M 在根目录下查找大于200兆的文件 k M G</p> 
</blockquote> 
<ul><li>locate 快速定位文件路径 ，该基于数据库进行查询，第一次运行前，必须使用updatedb指令创建locate数据库，使得查询速度大大增加。</li></ul> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># updatedb</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># locate hello.txt</span>
<span class="token operator">/</span>home<span class="token operator">/</span>hello<span class="token punctuation">.</span>txt
</code></pre> 
<ul>
<li> <p><strong>which</strong> 可以查看某个指令在哪个目录下</p> </li>
<li> <p><strong>grep</strong>指定文件中查找指定的字符串，过滤查找，将前一个命令的处理结果输出传递给后面的命令处理<br> 语法： grep 【选项】 查找内容 源文件 i忽略字母大小写，n显示行号</p> </li>
</ul> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cat /home/hello.txt</span>
hello
yes
ok
yes
jjj
ojk
hhh
yes
yes
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cat /home/hello.txt | grep "yes"</span>
yes
yes
yes
yes
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cat /home/hello.txt | grep -n "yes"</span>
<span class="token number">2</span><span class="token punctuation">:</span>yes
<span class="token number">4</span><span class="token punctuation">:</span>yes
<span class="token number">8</span><span class="token punctuation">:</span>yes
<span class="token number">9</span><span class="token punctuation">:</span>yes
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># grep -n "yes" /home/hello.txt</span>
<span class="token number">2</span><span class="token punctuation">:</span>yes
<span class="token number">4</span><span class="token punctuation">:</span>yes
<span class="token number">8</span><span class="token punctuation">:</span>yes
<span class="token number">9</span><span class="token punctuation">:</span>yes

</code></pre> 
<h3>
<a id="_567"></a>压缩和解压命令</h3> 
<ul>
<li>
<strong>gzip/gunzip</strong>压缩/解压文件命令。</li>
<li>
<strong>zip/unzip</strong>压缩/解压文件或者目录命令（在项目打包中有用）。</li>
</ul> 
<blockquote> 
 <p>-r 递归压缩，即压缩目录时写这个 zip -r myhome.zip /home/ 将home文件夹全部压缩</p> 
 <p>-d 指定压缩后文件的存放目录 unzip -d /opt/tmp /home/myhome.zip</p> 
</blockquote> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># gzip /home/hello.txt</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># ls /home/</span>
abc<span class="token punctuation">.</span>txt  apple<span class="token punctuation">.</span>txt  fzh  hello<span class="token punctuation">.</span>txt<span class="token punctuation">.</span>gz 
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># gunzip /home/hello.txt.gz</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># ls /home/</span>
abc<span class="token punctuation">.</span>txt  apple<span class="token punctuation">.</span>txt  fzh  hello<span class="token punctuation">.</span>txt 
</code></pre> 
<ul><li>
<strong>tar</strong> 语法：tar [选项] xxx.tar.gz 打包的内容</li></ul> 
<blockquote> 
 <p>-c 产生.tar打包文件</p> 
 <p>-v 显示详细信息</p> 
 <p>-f 指定压缩后的文件名</p> 
 <p>-z 打包同时压缩</p> 
 <p>-x 解压</p> 
</blockquote> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># tar -zcvf   pc.tar.gz   /home/pig.txt   /home/cat.txt</span>
tar<span class="token punctuation">:</span> 从成员名中删除开头的“<span class="token operator">/</span>”         压缩后的文件夹名
<span class="token operator">/</span>home<span class="token operator">/</span>pig<span class="token punctuation">.</span>txt
<span class="token operator">/</span>home<span class="token operator">/</span>cat<span class="token punctuation">.</span>txt
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># ls</span>
abc<span class="token punctuation">.</span>txt  apple<span class="token punctuation">.</span>txt  cat<span class="token punctuation">.</span>txt  fzh  hello<span class="token punctuation">.</span>txt  info<span class="token punctuation">.</span>txt  jack  mydir  my<span class="token punctuation">.</span>sh  orange<span class="token punctuation">.</span>txt  <span class="token operator">*</span>pc<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz<span class="token operator">*</span>
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># rm cat.txt pig.txt              删掉他两个</span>
rm：是否删除普通空文件 <span class="token string">"cat.txt"</span>？y
rm：是否删除普通空文件 <span class="token string">"pig.txt"</span>？y
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># ls</span>
abc<span class="token punctuation">.</span>txt  apple<span class="token punctuation">.</span>txt  fzh  hello<span class="token punctuation">.</span>txt  info<span class="token punctuation">.</span>txt  jack  mycal  mydate<span class="token punctuation">.</span>txt  mydir  my<span class="token punctuation">.</span>sh  orange<span class="token punctuation">.</span>txt  pc<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz  
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># tar -zxvf pc.tar.gz                 *解压</span>
home<span class="token operator">/</span>pig<span class="token punctuation">.</span>txt
home<span class="token operator">/</span>cat<span class="token punctuation">.</span>txt
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># ls</span>
abc<span class="token punctuation">.</span>txt  apple<span class="token punctuation">.</span>txt  fzh  hello<span class="token punctuation">.</span>txt  home【多了这个】  info<span class="token punctuation">.</span>txt  jack  mycal  mydate<span class="token punctuation">.</span>txt  mydir  my<span class="token punctuation">.</span>sh  orange<span class="token punctuation">.</span>txt  pc<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># cd home/</span>
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># ls</span>
cat<span class="token punctuation">.</span>txt  pig<span class="token punctuation">.</span>txt

</code></pre> 
<h2>
<a id="linux_622"></a>linux组</h2> 
<p>在linux中的每个用户必须属于一个组，不能独立于组外。</p> 
<p>具有一定关联性用户的集合形成组，给该组赋权限，该组所有成员都享有该权限</p> 
<p>文件的所有者：ls -ahl查看文件所有者，与ll差不多<br> 修改文件所有者：chown 用户名 文件名</p> 
<p>所在组：文件所在组就是文件所有者所在的组。</p> 
<ul><li>chgrp 组名 文件名</li></ul> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># groupadd monster</span>
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># useradd -g monster fox                创建用户并且指定组</span>
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># ll</span>
总用量 <span class="token number">48</span>
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">1</span> <span class="token number">1000</span> root       <span class="token number">0</span> <span class="token number">7</span>月  <span class="token number">12</span> <span class="token number">11</span><span class="token punctuation">:</span><span class="token number">03</span> abc<span class="token punctuation">.</span>txt
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">1</span> jack root       <span class="token number">0</span> <span class="token number">10</span>月 <span class="token number">21</span> <span class="token number">07</span><span class="token punctuation">:</span><span class="token number">14</span> apple<span class="token punctuation">.</span>txt
drwx<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">3</span> fox  monster <span class="token number">4096</span> <span class="token number">10</span>月 <span class="token number">21</span> <span class="token number">07</span><span class="token punctuation">:</span><span class="token number">16</span> fox
</code></pre> 
<ul>
<li> <p>改变用户所在组：usermod -g 新组名 用户名<br> usermod -d 目录名 用户名 改变用户登录的初始目录</p> </li>
<li> <p>cat /etc/group 查看所有组名 cat /etc/group | grep wudang 就看wudang这个组</p> </li>
<li> <p>ls -l的别名Ubuntu默认不支持此命令……</p> </li>
</ul> 
<p>ll 输出的 0-9 位</p> 
<blockquote> 
 <p>第0位 确定文件类型</p> 
 <blockquote> 
  <p>l是链接 相当于wins的快捷方式</p> 
  <p>d是目录，相当于windows的文件夹</p> 
  <p>c 字符设备文件，鼠标，键盘</p> 
  <p>b 块设备，硬盘</p> 
  <p>-普通文件</p> 
 </blockquote> 
 <p>1-3 文件所有者 User</p> 
 <p>4-6 所属组 Group</p> 
 <p>7-9 其他用户Other</p> 
</blockquote> 
<p>10位 文件数或者目录下的文件数</p> 
<p>11位 用户</p> 
<p>12位 组4096字节</p> 
<p>13位 文件大小，如果是文件夹，显示</p> 
<p>然后是 最后修改日期</p> 
<p>最后文件名</p> 
<p>rwx read,write,exectute</p> 
<h3>
<a id="_688"></a>修改权限</h3> 
<ul>
<li> <p><strong>chmod可以修改文件或者目录的权限</strong><br> u：所有者<br> g：所有组<br> o：其他人<br> a：所有人<br> <strong>±=变更</strong><br> eg:chmod a-x 文件/目录名<br> <strong>通过数字变更</strong><br> eg:chmod 751 文件/目录名</p> </li>
<li> <p><strong>修改文件所有者-chown</strong><br> chown 新所有者 文件/目录<br> chown -R 新所有者：新组 文件/目录<br> -R 如果是目录，要使得其下的所有文件和目录递归生效</p> </li>
<li> <p><strong>修改所在组-chgrp</strong></p> </li>
</ul> 
<h1>
<a id="______crond_707"></a>任务调度 crond</h1> 
<p>比如有的重要工作需要周而复始的执行，如病毒扫描。就需要任务调度。复杂的、分布式的、工作流式的调度可以通过azkaban来进行调度，除了执行调度任务之外，它还能进行定时调度。而对于简单的服务器任务，如执行一个小脚本，发送邮件等，可以使用crontab命令直接进行。linux 系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另 外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。</p> 
<p>crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p> 
<p>Linux下的任务调度分为两类，系统任务调度和用户任务调度。</p> 
<p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。/etc/crontab文件包括下面几行：</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cat /etc/crontab也可以 vim /etc/crontab</span>
<span class="token comment">#前 四行是用来配置crond任务运行的环境变量</span>
SHELL<span class="token operator">=</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>bash                             <span class="token comment">#指定了系统要使用哪个shell，这里是bash</span>
PATH<span class="token operator">=</span><span class="token operator">/</span>sbin<span class="token punctuation">:</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token punctuation">:</span><span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token punctuation">:</span><span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">bin</span>          <span class="token comment">#指定了系统执行 命令的路径</span>
MAILTO<span class="token operator">=</span>root                            <span class="token comment">#crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行</span>
                                          <span class="token comment">#HOME变量指定了在执行命令或者脚本时使用的主目录</span>
<span class="token comment"># For details see man 4 crontabs</span>

<span class="token comment"># Example of job definition:</span>
<span class="token comment"># .---------------- minute (0 - 59)</span>
<span class="token comment"># |  .------------- hour (0 - 23)</span>
<span class="token comment"># |  |  .---------- day of month (1 - 31)</span>
<span class="token comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span>
<span class="token comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span>
<span class="token comment"># |  |  |  |  |</span>
<span class="token comment"># *  *  *  *  * user-name  command to be executed</span>

</code></pre> 
<ul>
<li> <p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p> </li>
<li> <p>使用者权限文件：/etc/cron.deny该文件中所列用户不允许使用crontab命令</p> </li>
</ul> 
<p>​ /etc/cron.allow说明：该文件中所列用户允许使用crontab命令</p> 
<p>​ /var/spool/cron/说明：所有用户crontab文件存放的目录,以用户名命名</p> 
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：minute hour day month week command</p> 
<ul><li>特殊字符</li></ul> 
<blockquote> 
 <p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p> 
 <p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“0 8,12 *** 命令”代表在每天八点零分，十二点零分都执行一次</p> 
 <p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p> 
 <p>正斜线（/）：可以用正斜线指定时间的间隔频率。同时正斜线可以和星号一起使用，例如*/10****，如果用在minute字段，表示每十分钟执行一次。</p> 
</blockquote> 
<p>*/10 4 *** 每天凌晨四点，每隔十分钟执行一次命令</p> 
<p><strong>crontab</strong> 进行定时任务的设置<br> -e 编辑crontab定时任务edit<br> -l 查询crontab任务list<br> -r 删除当前用户所有的crontab任务,终止任务调度<br> service crond restart 重启任务调度<br> service crond status 查看 crond 服务的运行状态<br> service crond stop //关闭服务<br> service crond reload //重新载入配置</p> 
<h3>
<a id="crontab_man_768"></a>crontab -man命令可以查看简单的帮助手册！</h3> 
<p>https://www.cnblogs.com/yepei/p/6694735.html</p> 
<p>小例子</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># vim da.sh</span>
<span class="token operator">*</span><span class="token operator">/</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">/</span>home<span class="token operator">/</span>da<span class="token punctuation">.</span>sh

<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># ll</span>
总用量 <span class="token number">52</span>
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">1</span> root root      <span class="token number">20</span> <span class="token number">10</span>月 <span class="token number">24</span> <span class="token number">21</span><span class="token punctuation">:</span><span class="token number">22</span> da<span class="token punctuation">.</span>sh
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># chmod u+x da.sh</span>
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># ll</span>
总用量 <span class="token number">48</span>
<span class="token operator">-</span>rwxr<span class="token operator">-</span><span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span>  <span class="token number">1</span> root root      <span class="token number">20</span> <span class="token number">10</span>月 <span class="token number">24</span> <span class="token number">21</span><span class="token punctuation">:</span><span class="token number">22</span> da<span class="token punctuation">.</span>sh
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># cat mycal</span>
<span class="token number">2021</span>年 <span class="token number">10</span>月 <span class="token number">24</span>日 星期日 <span class="token number">21</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">:</span><span class="token number">26</span> CST
<span class="token punctuation">[</span>root@fanzhenhua home<span class="token punctuation">]</span><span class="token comment"># cat mycal</span>
<span class="token number">2021</span>年 <span class="token number">10</span>月 <span class="token number">24</span>日 星期日 <span class="token number">21</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">:</span><span class="token number">26</span> CST
<span class="token number">2021</span>年 <span class="token number">10</span>月 <span class="token number">24</span>日 星期日 <span class="token number">21</span><span class="token punctuation">:</span><span class="token number">28</span><span class="token punctuation">:</span><span class="token number">01</span> CST

        
<span class="token comment"># 每天凌晨两点，将mysql数据库testdb，备份到文件中</span>
<span class="token comment"># 步骤一</span>
crontab <span class="token operator">-</span>e
<span class="token comment"># 步骤二          指令为mysqldump -u root -p密码 数据库 &gt;/home/db.bak</span>
<span class="token number">0</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">*</span> mysqldump <span class="token operator">-</span>u root <span class="token operator">-</span>proot testdb <span class="token operator">&gt;</span><span class="token operator">/</span>home<span class="token operator">/</span>db<span class="token punctuation">.</span>bak


<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># crontab -l</span>
<span class="token operator">*</span><span class="token operator">/</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">/</span>home<span class="token operator">/</span>da<span class="token punctuation">.</span>sh
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># crontab -r</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># crontab -l</span>
no crontab <span class="token keyword">for</span> root

</code></pre> 
<h3>
<a id="at_____807"></a>at定时任务 执行一次性的定时任务</h3> 
<p>要想使用 at 命令，读者需提前安装好 at 软件包，并开启 atd 服务。因此，首先来看看如何安装 at 软件包。</p> 
<p>在 Linux 系统中，查看 at 软件包是否已安装，可以使用 rpm -q 命令，如下所示：</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># rpm -q at</span>
at<span class="token operator">-</span><span class="token number">3.1</span><span class="token number">.13</span><span class="token operator">-</span><span class="token number">20.</span>el7x86_64                       <span class="token comment"># 可以看到，当前系统已经安装 at 软件包</span>
</code></pre> 
<p>若读者所用系统未安装，可使用如下命令进行安装：</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># yum -y install at</span>
<span class="token comment">#省略输出信息，最终出现 Complete!，证明安装成功</span>
</code></pre> 
<p>除此之外，at 命令要想正确执行，还需要 atd 服务的支持。atd 服务是独立的服务，启动的命令如下：</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># service atd start</span>
正在启动 atd： <span class="token punctuation">[</span>确定<span class="token punctuation">]</span>
</code></pre> 
<p>如果想让 atd 服务开机时自启动，则可以使用如下命令：[root@localhost ~]# chkconfig atd on</p> 
<p>安装好 at 软件包并开启 atd 服务之后，at 命令才可以正常使用，不过在此之前，我们还要学习一下 at 命令的访问控制。<strong>访问控制</strong>指的是允许哪些用户使用 at 命令设定定时任务，或者不允许哪些用户使用 at 命令。大家可以将其想象成设定黑名单或白名单，这样更容易理解。</p> 
<p>at 命令的访问控制是依靠 /etc/at.allow（白名单）和 /etc/at.deny（黑名单）这两个文件来实现的，具体规则如下：</p> 
<ul>
<li>如果系统中有 /etc/at.allow 文件，那么只有写入 /etc/at.allow 文件（白名单）中的用户可以使用 at 命令，其他用户不能使用 at 命令（注意，/etc/at.allow 文件的优先级更高，也就是说，如果同一个用户既写入 /etc/at.allow 文件，又写入 /etc/at.deny 文件，那么这个用户是可以使用 at 命令的）。</li>
<li>如果系统中没有 /etc/at.allow 文件，只有 /etc/at.deny 文件，那么写入 /etc/at.deny 文件（黑名单）中的用户不能使用 at 命令，其他用户可以使用 at 命令。不过这个文件对 root 用户不生效。</li>
<li>如果系统中这两个文件都不存在，那么只有 root 用户可以使用 at 命令。</li>
</ul> 
<p>系统中默认只有 /etc/at.deny 文件，而且这个文件是空的，因此，系统中所有的用户都可以使用 at 命令。不过，如果我们打算控制用户的 at 命令权限，那么只需把用户写入 /etc/at.deny 文件即可。</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># ls -l /etc/at*</span>
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">.</span> <span class="token number">1</span> root root <span class="token number">1</span> <span class="token number">10</span>月 <span class="token number">31</span> <span class="token number">2018</span> <span class="token operator">/</span>etc<span class="token operator">/</span>at<span class="token punctuation">.</span>deny
<span class="token comment">#系统中默认只有at.deny文件</span>
<span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># echo user1 &gt;&gt; /etc/at.deny</span>
<span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cat /etc/at.deny</span>
user1<span class="token comment">#把user1用户写入/etc/at.deny文件</span>
<span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># su - user1</span>
<span class="token punctuation">[</span>user1@localhost <span class="token operator">~</span><span class="token punctuation">]</span>$ at <span class="token number">02</span>：<span class="token number">00</span>
You do <span class="token keyword">not</span> have permission to use at<span class="token punctuation">.</span>
<span class="token comment">#没有权限使用at命令，切换成user1用户，这个用户已经不能执行at命令了</span>
<span class="token punctuation">[</span>user1@localhost <span class="token operator">~</span><span class="token punctuation">]</span>$ exit
logout
<span class="token comment">#返回root身份</span>
<span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># echo user1 &gt;&gt; /etc/at.allow</span>
<span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cat /etc/at.allow</span>
user1<span class="token comment">#建立/etc/at.allow文件，并在文件中写入user1用户</span>
<span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># su - user1</span>
<span class="token punctuation">[</span>user1@localhost <span class="token operator">~</span><span class="token punctuation">]</span>$ at <span class="token number">02</span>：<span class="token number">00</span>
at<span class="token operator">&gt;</span>
<span class="token comment">#切换成user1用户，user1用户可以执行at命令。这时user1用户既在/etc/at.deny文件中，又在/etc/at.allow文件中，但是/etc/at.allow文件的优先级更高</span>
<span class="token punctuation">[</span>user1@localhost <span class="token operator">~</span><span class="token punctuation">]</span>$ exit
logout
<span class="token comment">#返回root身份</span>
<span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># at 02：00</span>
at<span class="token operator">&gt;</span>
<span class="token comment">#root用户虽然不在/etc/at.allow文件中，但是也能执行at命令，</span>
<span class="token comment">#root用户虽然不在/etc/at.allow文件中，但是也能执行at命令，</span>
<span class="token comment">#说明root用户不受这两个文件的控制</span>
</code></pre> 
<p>这个实验说明了 /etc/at.allow 文件的优先级更高，如果 /etc/at.allow 文件存在，则 /etc/at.deny 文件失效。/etc/at.allow 文件的管理更加严格，因为只有写入这个文件的用户才能使用 at 命令，如果需要禁用 at 命令的用户较多，则可以把少数用户写入这个文件。/etc/at.deny 文件的管理较为松散，如果允许使用 at 命令的用户较多，则可以把禁用的用户写入这个文件。不过这两个文件都不能对 root 用户生效。</p> 
<pre><code class="prism language-python">ps <span class="token operator">-</span>ef 检测当前运行的进程             <span class="token comment"># 过滤一下，就查看atd是否在运行</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># ps -ef | grep atd</span>
root       <span class="token number">8105</span>      <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">17</span><span class="token punctuation">:</span><span class="token number">08</span> ?        <span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>atd <span class="token operator">-</span>f
root      <span class="token number">10642</span>  <span class="token number">10177</span>  <span class="token number">0</span> <span class="token number">17</span><span class="token punctuation">:</span><span class="token number">43</span> pts<span class="token operator">/</span><span class="token number">0</span>    <span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> grep <span class="token operator">-</span><span class="token operator">-</span>color<span class="token operator">=</span>auto atd

</code></pre> 
<p>at [选项] [时间] ctrl+d 结束at命令的输入</p> 
<table>
<thead><tr>
<th align="left">-m</th>
<th>当 at 工作完成后，无论命令是否输出，都用 E-mail 通知执行 at 命令的用户。</th>
</tr></thead>
<tbody>
<tr>
<td align="left">-c 工作标识号</td>
<td>显示该 at 工作的实际内容。</td>
</tr>
<tr>
<td align="left">-t 时间</td>
<td>在指定时间提交工作并执行，时间格式为 [[CC]YY]MMDDhhmm。</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">-d</td>
<td>删除某个工作，需要提供相应的工作标识号（ID），同 atrm 命令的作用相同。</td>
</tr>
<tr>
<td align="left">-l</td>
<td>列出当前所有等待运行的工作，和 atq 命令具有相同的额作用。</td>
</tr>
<tr>
<td align="left">-f 脚本文件</td>
<td>指定所要提交的脚本文件。</td>
</tr>
</tbody>
</table> 
<table>
<thead><tr>
<th>格式</th>
<th>用法</th>
</tr></thead>
<tbody>
<tr>
<td>HH:MM</td>
<td>比如 04:00 AM。如果时间已过，则它会在第二天的同一时间执行。</td>
</tr>
<tr>
<td>Midnight（midnight）</td>
<td>代表 12:00 AM（也就是 00:00）。</td>
</tr>
<tr>
<td>Noon（noon）</td>
<td>代表 12:00 PM（相当于 12:00）。</td>
</tr>
<tr>
<td>Teatime（teatime）</td>
<td>代表 4:00 PM（相当于 16:00）。</td>
</tr>
<tr>
<td>英文月名 日期 年份</td>
<td>比如 January 15 2018 表示 2018 年 1 月 15 号，年份可有可无。</td>
</tr>
<tr>
<td>MMDDYY、MM/DD/YY、MM.DD.YY</td>
<td>比如 011518 表示 2018 年 1 月 15 号。</td>
</tr>
<tr>
<td>now+时间</td>
<td>以 minutes、hours、days 或 weeks 为单位，例如 now+5 days 表示命令在 5 天之后的此时此刻执行。</td>
</tr>
<tr>
<td>today，tomorrow</td>
<td>指定完成命令的时间</td>
</tr>
</tbody>
</table>
<p>案例</p> 
<pre><code class="prism language-python"><span class="token comment"># 两天后下午五点执行/bin/ls /home</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># at 5pm + 2days</span>
at<span class="token operator">&gt;</span>  <span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>ls <span class="token operator">/</span>home<span class="token operator">&lt;</span>EOT<span class="token operator">&gt;</span>          <span class="token comment">#此处ctrl+d按了两次</span>
job <span class="token number">2</span> at Wed Oct <span class="token number">27</span> <span class="token number">17</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token number">2021</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># atq</span>
<span class="token number">2</span>	Wed Oct <span class="token number">27</span> <span class="token number">17</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token number">2021</span> a root
<span class="token comment"># 明天17点，输出时间到指定文件内</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># at 5pm tomorrow</span>
at<span class="token operator">&gt;</span> date <span class="token operator">&gt;</span> <span class="token operator">/</span>root<span class="token operator">/</span>date100<span class="token punctuation">.</span>log<span class="token operator">&lt;</span>EOT<span class="token operator">&gt;</span>
job <span class="token number">3</span> at Tue Oct <span class="token number">26</span> <span class="token number">17</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token number">2021</span>
<span class="token punctuation">[</span>root@fanzhenhua <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># atq</span>
<span class="token number">2</span>	Wed Oct <span class="token number">27</span> <span class="token number">17</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token number">2021</span> a root
<span class="token number">3</span>	Tue Oct <span class="token number">26</span> <span class="token number">17</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token number">2021</span> a root

</code></pre> 
<p>【例 1】</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>coot@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># cat /root/hello.sh</span>
#!<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>bash
echo <span class="token string">"hello world!!"</span>
#该脚本会打印<span class="token string">"hello world!!"</span>
<span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># at now +2 minutes</span>
at<span class="token operator">&gt;</span> <span class="token operator">/</span>root<span class="token operator">/</span>hello<span class="token punctuation">.</span>sh <span class="token operator">&gt;&gt;</span> <span class="token operator">/</span>root<span class="token operator">/</span>hello<span class="token punctuation">.</span>log
#执行hello<span class="token punctuation">.</span>sh脚本，并把输出写入<span class="token operator">/</span>root<span class="token operator">/</span>hello<span class="token punctuation">.</span>log文件
at<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>EOT<span class="token operator">&gt;</span>
#使用Ctrl<span class="token operator">+</span>D快捷键保存at任务
job <span class="token number">8</span> at <span class="token number">2013</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">25</span> <span class="token number">20</span><span class="token punctuation">:</span><span class="token number">54</span> <span class="token comment">#这是第8个at任务,会在2013年7月25日20:54执行</span>
<span class="token punctuation">[</span>root@localhost <span class="token operator">~</span><span class="token punctuation">]</span><span class="token comment"># at -c 8</span>
#查询第<span class="token number">8</span>个at任务的内容
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略部分内容<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
#主要定义系统的环境变量
<span class="token operator">/</span>root<span class="token operator">/</span>hello<span class="token punctuation">.</span>sh <span class="token operator">&gt;&gt;</span> <span class="token operator">/</span>root<span class="token operator">/</span>hello<span class="token punctuation">.</span>log
#可以看到at执行的任务
</code></pre> 
<p>【例 2】</p> 
<p>[root@localhost ~J# at 02:00 2013-07-26<br> at&gt; /bin/sync<br> at&gt; /sbin/shutdown -h now<br> at&gt; <br> job 9 at 2013-07-26 02:00<br> #在指定的时间关机。在一个at任务中是可以执行多个系统命令的</p> 
<p>在使用系统定时任务时，不论执行的是系统命令还是 Shell 脚本，最好使用绝对路径来写命令，这样不容易报错。at 任务一旦使用 <code>Ctrl+D</code> 快捷键保存，实际上写入了 /var/spool/at/ 这个目录，这个目录内的文件可以直接被 atd 服务调用和执行。</p> 
<p>表 1 中提到了 atq 命令和 atrm 命令。atq 命令用于查看当前等待运行的工作，atrm 命令后者用于删除指定的工作，它们的使用方法也很简单，这里给大家举几个简单的例子。</p> 
<p>【例 3】atq 命令的用法。</p> 
<p>[root@localhost ~]# atq<br> 9 2013-07-26 02：00 a root<br> #说明root用户有一个at任务在2013年7月26日02：00执行，工作号是9<br> [root@localhost ~]# atrm [工作号]<br> #删除指定的at任务</p> 
<p>【例 4】atrm 命令的用法。</p> 
<p>[root@localhost ~]# atrm 9<br> [root@localhost ~]# atq<br> #删除9号at任务，再查询就没有at任务存在了</p> 
<h1>
<a id="_983"></a>磁盘应用</h1> 
<h3>
<a id="_985"></a>查看所有设备挂载情况：</h3> 
<p>ide硬盘，hda1表示第一个硬盘的第一个主分区，scsi硬盘，标识符为“sdx~”，sda1代表第一块硬盘第一个分区，2代表第1款硬盘第二个分区…4代表第1块硬盘第四个分区…，sdb代表第二块硬盘</p> 
<pre><code class="prism language-linux命令">[root@hspEdu01 ~]#  lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   20G  0 disk 
├─sda1   8:1    0    1G  0 part /boot
├─sda2   8:2    0    2G  0 part [SWAP]
└─sda3   8:3    0   17G  0 part /
sdb      8:16   0    1G  0 disk 
sr0     11:0    1  4.3G  0 rom  /run/media/root/CentOS 7 x86_64

[root@hspEdu01 ~]# lsblk -f ❀查看的完全设备挂载情况
NAME   FSTYPE  LABEL           UUID ❀每个分区的40位的唯一标识符      MOUNTPOINT❀挂载点
sda   ❀分区情况                   ❀格式化后为每个分区分配那唯一字符串，表示他已经格式化                              
├─sda1 ext4                    22dddfbb-4515-463b-bb50-d79f69571026 /boot
├─sda2 swap                    f0ccf5ba-c68c-4ae1-9ca0-af47d67ead5a [SWAP]
└─sda3 ext4                    95b68be7-28c6-4d13-b5f2-e2aa70b43b0e /
sdb                                                                 
sr0    iso9660 CentOS 7 x86_64 2018-11-25-23-54-16-00               /run/media/root/CentOS 7 x86_64

</code></pre> 
<ul><li>虚拟机添加硬盘</li></ul> 
<p>在虚拟机里——&gt;设置——&gt;添加硬盘 sdb 重启后reboot，显示出硬盘</p> 
<ul><li>硬盘分区</li></ul> 
<p>分区命令：fdisk /dev/sdb</p> 
<pre><code>[root@hspEdu01 ~]# fdisk /dev/sdb
欢迎使用 fdisk (util-linux 2.23.2)。
Device does not contain a recognized partition table
使用磁盘标识符 0x0de8215b 创建新的 DOS 磁盘标签。

命令(输入 m 获取帮助)：m
命令操作
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition                   ❀删除分区
   g   create a new empty GPT partition table
   G   create an IRIX (SGI) partition table
   l   list known partition types
   m   print this menu                      ❀显示命令列表
   n   add a new partition                  ❀新增分区
   o   create a new empty DOS partition table
   p   print the partition table            ❀显示磁盘分区,同fdisk -l
   w   write table to disk and exit         ❀写入退出  


1、命令(输入 m 获取帮助)：n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
2、Select (default p): p
分区号 (1-4，默认 1)：1
起始 扇区 (2048-2097151，默认为 2048)：      ❀回车，默认全部剩余空间
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-2097151，默认为 2097151)：❀同上
将使用默认值 2097151
分区 1 已设置为 Linux 类型，大小设为 1023 MiB

命令(输入 m 获取帮助)：w    ❀写入并退出，若不想保存，直接写q

正在同步磁盘。

[root@hspEdu01 ~]# lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   20G  0 disk 
├─sda1   8:1    0    1G  0 part  /boot
├─sda2   8:2    0    2G  0 part  [SWAP]
└─sda3   8:3    0   17G  0 part  /
sdb      8:16   0    1G  0 disk 
└─sdb1   8:17   0 1023M  0 part   ❀分区已经有了，但是还未格式化，不能挂载
sr0     11:0    1  4.3G  0 rom  /run/media/root/CentOS 7 x86_64

</code></pre> 
<ul><li>格式化磁盘</li></ul> 
<p>mkfs -t ext4 /dev/sdb1</p> 
<p>ext4是分区类型</p> 
<h3>
<a id="_1074"></a>卸载掉挂载</h3> 
<pre><code class="prism language-linux命令">挂载： mount 设备名称 挂载目录 
卸载： umount 设备名或者挂载目录 umount /dev/sdb1  或者umount /newdisk

umount: /newdisk：目标忙。
        (有些情况下通过 lsof(8) 或 fuser(1) 可以找到有关使用该设备的进程的有用信息)
   
mkdir newdisk  # 创建新的被挂载的地方，在newdisk里创建的文件就在磁盘sdb1里
mount  /dev/sdb1  /newdisk
</code></pre> 
<h3>
<a id="_1087"></a>永久挂载</h3> 
<p>修改/etc/fstab实现挂载，添加后执行mount -a立即生效</p> 
<pre><code>用命令挂载重启后会失效
进入：vim /etc/fstab
yyp拷贝
或者把拷贝的改为：/dev/sdb1          /newdisk          ext4  defaults 0 0
</code></pre> 
<p>紧急模式解决：重启后输入root密码回车，去到root终端，然后vim /ect/fstab ,修改回正确的，然后reboot</p> 
<h3>
<a id="_1100"></a>磁盘情况查询</h3> 
<pre><code class="prism language-linux命令">查询整体磁盘使用情况: df -h
查询指定目录： du -h 目录 （没有带目录时默认情况下查询的是当前目录）
	-s 指定目录的磁盘占用情况
	-h带计量单位
	-c列出明细的同时，增加汇总值
	-a含文件
	--max-depth=1 子目录的深度
	
案例查询opt目录下的磁盘占用情况
[root@hspEdu01 ~]# cd /opt/
[root@hspEdu01 opt]# ls
rh  VMwareTools-10.3.23-17030940.tar.gz  vmware-tools-distrib
[root@hspEdu01 opt]# du -h --max-depth=1 /opt
4.0K	/opt/rh
154M	/opt/vmware-tools-distrib
205M	/opt

[root@hspEdu01 opt]# du -ha --max-depth=1 /opt
4.0K	/opt/rh
52M	/opt/VMwareTools-10.3.23-17030940.tar.gz
154M	/opt/vmware-tools-distrib
205M	/opt

[root@hspEdu01 opt]# du -hac --max-depth=1 /opt
4.0K	/opt/rh
52M	/opt/VMwareTools-10.3.23-17030940.tar.gz
154M	/opt/vmware-tools-distrib
205M	/opt
205M	总用量

</code></pre> 
<h3>
<a id="_1135"></a>几个小应用</h3> 
<p>统计opt文件夹下文件个数</p> 
<pre><code class="prism language-linux命令">
[root@hspEdu01 opt]# ls -l /opt  ❀列出opt下面的内容
总用量 52584
drwxr-xr-x. 2 root root     4096 10月 31 2018 rh

[root@hspEdu01 opt]# ls -l /opt | grep "^-" ❀用管道过滤出首字母为-的，就是普通文件
-rw-r--r--. 1 root root 53834249 10月 14 2020 VMwareTools-10.3.23-17030940.tar.gz

[root@hspEdu01 opt]# ls -l /opt | grep "^-" | wc -l  ❀用wc统计数字
1

</code></pre> 
<p>统计opt文件夹下目录个数</p> 
<pre><code class="prism language-linux命令">[root@hspEdu01 opt]# ls -l /opt | grep "^d" | wc -l ❀因为目录是以d开头的，然后用wc求和

[root@hspEdu01 opt]# ls -lR /opt | grep "^-" |wc -l  ❀列出opt包括子文件的个数 R递归
</code></pre> 
<p>以树状显示目录结构,首先使用 yum install tree 安装Tree</p> 
<pre><code class="prism language-linux命令">tree /opt
</code></pre> 
<h1>
<a id="NAT_1167"></a>NAT网络配置</h1> 
<p>ping（数据包internet groper)命令用于检查主机与服务器(eg:ping www.baidu.com)、主机(eg:ping 192.168.216.128)之间的网络连接。以ip地址或url为输入。</p> 
<p>ctrl+c停止</p> 
<p>ifconfig在linux中查询ip地址192.168.216.128（会变)，<br> ipconfig在cmd中查 ：vmnet8处IPv4 地址 : 192.168.216.1，<br> cmd中ping 192.168.216.128，很容易ping通，在linux中ping 192.168.216.1得先关闭防火墙（控制面板中）才可以ping通<br> linux虚拟机可以上网原因主机还有无线网卡 IPv4 地址 . . . . . . . . . . . . : 192.168.3.85，虚拟机连接主机时，经由无线网卡的代理找到网关，最后找到互联网。</p> 
<h3>
<a id="_1178"></a>网络环境配置</h3> 
<h5>
<a id="__1180"></a>第一种方法 自动获取</h5> 
<h5>
<a id="_ip_ip_1182"></a>第二种方法 指定ip 直接修改文件来指定ip，并可以连接到外网</h5> 
<pre><code class="prism language-linux命令">vim /etc/sysconfig/network-scripts/ifcfg-ens33
p65
service network restart 、reboot 重启网络服务或者重启系统生效
</code></pre> 
<h3>
<a id="_1190"></a>设置主机名</h3> 
<pre><code>hostname 查看主机名
vim /etc/hostname   修改主机名

</code></pre> 
<h3>
<a id="hosts_Linuxip_1198"></a>设置hosts映射 也就是如何通过主机名找到某个Linux而不是用ip地址</h3> 
<pre><code>在C:windowsSystem32driversetchosts文件指定即可 记事本打开就行 eg：192.168.216.128 hspedu100
linux 在/etc/hosts 编辑写入192.168.216.1 LAPTOP-ERDAN5JF
</code></pre> 
<p>hosts是一个文本文件，用来记录ip和hostname的映射关系</p> 
<h3>
<a id="dns__domain_name_system__ip_1207"></a>dns 就是 domain name system 的缩写 ，域名系统（一组服务器），是互联网上作为域名和ip地址相互映射的一个分布式数据库</h3> 
<h1>
<a id="_1209"></a>进程</h1> 
<p>在Linux里，每一个执行的程序都称为一个进程，每一个进程都分配一个id号（pid，进程号）。每个进程都以两种方式存在：前台，后台。</p> 
<p>linux的每个命令是以进程的方式运行的，每个进程运行时会自动打开三个文件，称为命令的标准文件。stdin，0（标准输入文件），stdout，1，stderr，2</p> 
<h3>
<a id="_1215"></a>显示系统执行的进程</h3> 
<h4>
<a id="ps_1217"></a>ps指令是用来查看目前系统中，有哪些正在执行，执行情况，可不加任何参数</h4> 
<pre><code>[root@hspEdu100 ~]# ps -aux | more       ❀终端
❀进程执行用户 ❀进程号  ❀占用物理内存❀物理内存大小   ❀运行状态    ❀占用cpu时间
USER         PID %CPU %MEM    VSZ   RSS TTY         STAT START   TIME COMMAND
                  ❀占用cpu百分比❀占用虚拟内存大小           ❀开始执行时间  ❀进程名，执行该进程的指令
root          1  0.1  0.3 193816  6924   ?      Ss   08:37   0:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root          2  0.0  0.0      0     0   ?      S    08:37   0:00 [kthreadd]
root          3  0.0  0.0      0     0   ?      S    08:37   0:00 [ksoftirqd/0]
root          5  0.0  0.0      0     0   ?      S&lt;   08:37   0:00 [kworker/0:0H]
root          7  0.0  0.0      0     0   ?      S    08:37   0:00 [migration/0]
root          8  0.0  0.0      0     0   ?      S    08:37   0:00 [rcu_bh]

STAT 其中S- 睡眠 
s-表示该进程是会话的先导进程
N-表示进程拥有比普通优先级更低的优先级
R-正在运行
D-短期等待
Z-僵死进程
T-被跟踪或者被停止

ps -aux | grep xxx 看有没有xxx服务

ps -a 显示当前终端所有进程信息
ps -u 以用户的格式显示进程
ps -x 显示后台进程运行的参数
</code></pre> 
<h4>
<a id="_1246"></a>查看进程父进程</h4> 
<pre><code>ps -ef以全格式显示当前所有进程 -e 显示所有进程，-f全格式
</code></pre> 
<h1>
<a id="rpm_1252"></a>rpm包管理</h1> 
<p>rpm用于互联网下载包的打包以及安装工具,一个 RPM 包包含了已压缩的软件文件集以及该软件的内容信息，通常表现为以 .rpm 扩展名结尾的文件，例如 samba.rpm 。如果需要对RPM包进行操作则需要使用rpm命令。</p> 
<pre><code class="prism language-linux">查询已安装的rpm列表：       rpm -qa |grep xx，     rpm -qa | more    ，rpm -qa 
[root@hspEdu100 ~]# rpm -qa | grep firefox
firefox-60.2.2-1.el7.centos.x86_64      //rpm包名基本格式的例子
名称：firefox
版本号：60.2.2-1
适用的操作系统：el7.centos.x86_64      64位

rpm -q 软件包名：查询软件是否安装
rpm -qi 软件包名：查询软件包信息
rpm -ql 软件包名：查询软件包中的文件
rpm -qf 文件全路径名：查询文件所属软件包
rpm -qf /etc/passwd：查询该文件归属于哪个软件包
[root@hspEdu100 ~]# rpm -qf /etc/passwd
setup-2.8.71-10.el7.noarch         //noarch是32位64位通用的
卸载rpm包 rpm -e rpm包名 //erase 擦除
安装rpm包：rpm -ivh rpm包全路径名称 //i install安装，v verbose 提示，h=hash 进度条

</code></pre> 
<pre><code># 我输入rpm -p at 出现下面的情况      好像是告诉每个选项的全拼
用法: rpm [-aKfgpqVcdLilsiv?] [-a|--all] 
    [-f|--file]
    [-g|--group]
        [-p|--package] [--pkgid] [--hdrid] [--triggeredby] [--whatrequires]
        [--whatprovides] [--nomanifest] 
        [-c|--configfiles] 
        [-d|--docfiles]
        [-L|--licensefiles] [--dump]
        [-l|--list] [--queryformat=QUERYFORMAT]
        [-s|--state] [--nofiledigest] [--nofiles] [--nodeps] [--noscript]
        [--allfiles] [--allmatches] [--badreloc] [-e|--erase &lt;package&gt;+]
        [--excludedocs] [--excludepath=&lt;path&gt;] [--force]
        [-F|--freshen &lt;packagefile&gt;+]
        [-h|--hash] [--ignorearch] [--ignoreos]
        [--ignoresize] [-i|--install] [--justdb] [--nodeps] [--nofiledigest]
        [--nocontexts] [--noorder] [--noscripts] [--notriggers]
        [--nocollections] [--oldpackage] [--percent] [--prefix=&lt;dir&gt;]
        [--relocate=&lt;old&gt;=&lt;new&gt;] [--replacefiles] [--replacepkgs] [--test]
        [-U|--upgrade &lt;packagefile&gt;+] [--reinstall=&lt;packagefile&gt;+]
        [-D|--define “MACRO EXPR”] [--undefine=MACRO] 
        [-E|--eval “EXPR”]
        [--macros=&lt;FILE:…&gt;] [--noplugins] [--nodigest] [--nosignature]
        [--rcfile=&lt;FILE:…&gt;] 
        [-r|--root ROOT] [--dbpath=DIRECTORY]
        [--querytags] [--showrc] [--quiet] 
        [-v|--verbose] [--version]
        [-?|--help] [--usage] [--scripts] [--setperms] [--setugids]
        [--conflicts] [--obsoletes] [--provides] [--requires] [--info]
        [--changelog] [--xml] [--triggers] [--last] [--dupes]
        [--filesbypkg] [--fileclass] [--filecolor] [--fscontext]
        [--fileprovide] [--filerequire] [--filecaps]

</code></pre> 
<h3>
<a id="yum_1314"></a>yum</h3> 
<p>yum是shell前端软件包管理器，基于rpm包管理，能够从指定的服务器自动下载rpm包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包</p> 
<pre><code>查询yum服务器是否有需要安装的软件 yum list | grep xx
安装指定的yum包：yum install xx
</code></pre> 
<h1>
<a id="shell_1323"></a>shell</h1> 
<p>shell是一个命令行解释器，为用户提供了一个向linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动，挂起，停止甚至编写一些程序。</p> 
<h3>
<a id="_binbash__1327"></a>脚本格式要求：脚本以 #!/bin/bash 开头，脚本需要有可执行的权限。</h3> 
<pre><code>[root@hspEdu100 ~]# mkdir /root/shellcode
[root@hspEdu100 ~]# cd /root/shellcode
[root@hspEdu100 shellcode]# ls
[root@hspEdu100 shellcode]# vim hello.sh       
[root@hspEdu100 shellcode]# ll
总用量 4
-rw-r--r--. 1 root root 29 7月  19 20:30 hello.sh         //没有执行权限
[root@hspEdu100 shellcode]# chmod u+x hello.sh
[root@hspEdu100 shellcode]# ll
总用量 4
-rwxr--r--. 1 root root 29 7月  19 20:30 hello.sh
[root@hspEdu100 shellcode]# vim hello.sh

脚本执行方式① 需要有可执行权限
[root@hspEdu100 shellcode]# ./hello.sh                   //相对路径执行脚本
hello,world
[root@hspEdu100 shellcode]# /root/shellcode/hello.sh     //相对路径执行脚本
hello,world
②sh+脚本 没有执行权限也行   sh hello.sh
[root@hspEdu100 shellcode]# chmod u-x hello.sh
[root@hspEdu100 shellcode]# sh hello.sh
hello,world

vim里：
#!/bin/bash                                               //脚本以此开头
echo "hello,world"

</code></pre> 
<h1>
<a id="shell_1359"></a>shell命令</h1> 
<p>linux命令就是shell命令</p> 
<p><strong>内部命令</strong></p> 
<p>是shell本身包含的一些命令</p> 
<p><strong>外部命令</strong></p> 
<p>存放一些二进制可执行文件或shell脚本，外部命令执行时，shell会在文件系统中指定一些目录去搜索相应文件，然后调入内存执行。</p> 
<h3>
<a id="shell_1373"></a>shell变量</h3> 
<p>shell变量分为系统变量，用户自定义变量</p> 
<h4>
<a id="_1377"></a>系统变量</h4> 
<p>$HOME $PWD $SHELL $USER</p> 
<pre><code>[root@hspEdu100 shellcode]# echo $HOME
/root
</code></pre> 
<p>set查看所有系统变量</p> 
<h4>
<a id="_1388"></a>自定义变量</h4> 
<pre><code>定义：变量名=值            变量名一般为大写
撤销变量：  unset 变量
声明静态变量： readonly变量，注意：不能unset

#!/bin/bash
A=1
echo $A 或者echo A=$A 或者 echo "A=$A"
unset A
readonly B=2
echo B=$B                 #静态变量
C=`A` 等价于C=$(A)
</code></pre> 
<h4>
<a id="_1404"></a>环境变量</h4> 
<pre><code>//?在/etc/profile文件中定义TOMCAT_HOME环境变量/全局变量
export 变量名=变量值（将shell变量输出为环境变量/全局变量）
source 配置文件 ，让他刷新一下
[root@hspEdu100 opt]# vim /etc/profile
[root@hspEdu100 opt]# echo $TMOCAT_HOME

[root@hspEdu100 opt]# source /etc/profile
[root@hspEdu100 opt]# echo $TMOCAT_HOME

:&lt;&lt;!      ！多行注释
</code></pre> 
<p>history命令可以查看所有历史命令，记录的多少由用户环境变量中的HISTSIZE决定。n！显示第n条命令</p> 
<h1>
<a id="etcpasswd_1421"></a>/etc/passwd：用户基础信息</h1> 
<p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，他记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。对安全性需求较高的Linux系统都把加密后的口令字分离出来，独立存放在一个文件中，这个文件是/etc/shadow文件。只有终极用户才拥有该文件读权限，这就确保了用户密码的安全性。</p> 
<h1>
<a id="etcshadow_1425"></a>/etc/shadow：用户密码</h1> 
<p>/etc/shadow中的记录行和/etc/passwd中的一一对应，他由pwconv命令根据/etc/passwd中的数据自动产生。他的文件格式和/etc/passwd类似，由若干个字段组成，字段之间用“:”隔开。这些字段是：</p> 
<p>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p> 
<p>（1）“登录名”是和/etc/passwd文件中的登录名相一致的用户账号</p> 
<p>（2）“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不必口令；如果含有不属于集合{ ./0-9A-Za-z }中的字符，则对应的用户不能登录。</p> 
<p>（3）“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不相同。例如在SCO Linux中，这个时间起点是1970年1月1日。</p> 
<p>（4）“最小时间间隔”指的是两次修改口令之间所需的最小天数。</p> 
<p>（5）“最大时间间隔”指的是口令保持有效的最大天数。</p> 
<p>（6）“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</p> 
<p>（7）“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</p> 
<p>（8）“失效时间”字段给出的是个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是个合法的账号，也就不能再用来登录了。</p> 
<h1>
<a id="etcgroup_1447"></a>/etc/group：用户组信息</h1> 
<p>用户组的所有信息都存放在/etc/group文件中</p> 
<p>将用户分组是Linux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中能有多个用户，一个用户也能属于不同的组。当 一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属 于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用户组的所有信息都存放在/etc/group文件中。此文件的格式也 类似于/etc/passwd文件，由冒号隔开若干个字段，这些字段有：</p> 
<p>组名:口令:组标识号:组内用户列表</p> 
<p>（1）“组名”是用户组的名称，由字母或数字构成。和/etc/passwd中的登录名相同，组名不应重复。</p> 
<p>（2）“口令”字段存放的是用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或是*。</p> 
<p>（3）“组标识号”和用户标识号类似，也是个整数，被系统内部用来标识组。</p> 
<p>urce /etc/profile<br> [root@hspEdu100 opt]# echo $TMOCAT_HOME</p> 
<p>:&lt;&lt;! ！多行注释</p> 
<pre><code>
history命令可以查看所有历史命令，记录的多少由用户环境变量中的HISTSIZE决定。n！显示第n条命令

# /etc/passwd：用户基础信息

Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，他记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。对安全性需求较高的Linux系统都把加密后的口令字分离出来，独立存放在一个文件中，这个文件是/etc/shadow文件。只有终极用户才拥有该文件读权限，这就确保了用户密码的安全性。

# /etc/shadow：用户密码

/etc/shadow中的记录行和/etc/passwd中的一一对应，他由pwconv命令根据/etc/passwd中的数据自动产生。他的文件格式和/etc/passwd类似，由若干个字段组成，字段之间用“:”隔开。这些字段是：

登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志

（1）“登录名”是和/etc/passwd文件中的登录名相一致的用户账号

（2）“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不必口令；如果含有不属于集合{ ./0-9A-Za-z }中的字符，则对应的用户不能登录。

（3）“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不相同。例如在SCO Linux中，这个时间起点是1970年1月1日。

（4）“最小时间间隔”指的是两次修改口令之间所需的最小天数。

（5）“最大时间间隔”指的是口令保持有效的最大天数。

（6）“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。

（7）“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。

（8）“失效时间”字段给出的是个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是个合法的账号，也就不能再用来登录了。

# /etc/group：用户组信息

用户组的所有信息都存放在/etc/group文件中

将用户分组是Linux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中能有多个用户，一个用户也能属于不同的组。当 一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属 于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用户组的所有信息都存放在/etc/group文件中。此文件的格式也 类似于/etc/passwd文件，由冒号隔开若干个字段，这些字段有：

组名:口令:组标识号:组内用户列表

（1）“组名”是用户组的名称，由字母或数字构成。和/etc/passwd中的登录名相同，组名不应重复。

（2）“口令”字段存放的是用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或是*。

（3）“组标识号”和用户标识号类似，也是个整数，被系统内部用来标识组。

（4）“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号“,”分隔。这个用户组可能是用户的主组，也可能是附加组。
</code></pre>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>