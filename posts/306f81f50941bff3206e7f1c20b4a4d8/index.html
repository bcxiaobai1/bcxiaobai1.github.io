<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>ChatGPT 编写模式：如何高效地将思维框架赋予 AI ？ - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ChatGPT 编写模式：如何高效地将思维框架赋予 AI ？</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>如何理解 Prompt ？</p> 
 <p style="text-align:center"><img alt="0f3d27c1a62c292105b3ec516d62d9a6.png" src="https://images2.imgbox.com/20/2a/r1MnlubO_o.png"></p> 
</div> 
<figcaption>
 Prompt Enginneering
</figcaption>
<blockquote> 
 <p>prompt 通常指的是一个输入的文本段落或短语，作为生成模型输出的起点或引导。prompt 可以是一个问题、一段文字描述、一段对话或任何形式的文本输入，模型会基于 prompt 所提供的上下文和语义信息，生成相应的输出文本。</p> 
</blockquote> 
<p>举个例子，对于一个语言模型，prompt 可以是 "The cat sat on the"，模型可以通过对接下来的词语进行预测，生成类似于 "mat"、"chair"、"sofa" 等不同的输出：</p> 
<p>‍</p> 
<p style="text-align:center"><img alt="d3695d99a371752b39f822614d6df853.png" src="https://images2.imgbox.com/ae/f5/vWAwtLEO_o.png"></p> 
<p>‍</p> 
<figcaption>
 The Cat
</figcaption>
<p>上图为 Stable Diffusion 生成 (Prompt: The cat sat on the , Steps: 30, Sampler: Euler a, CFG scale: 7, Seed: 234310862, Size: 512x512, Model hash: d8722b4a4d, Model: neverendingDreamNED_bakedVae)</p> 
<p>Prompt 在人工智能语言生成领域中扮演着重要的角色，因为它可以帮助模型更好地理解用户意图，并生成更准确、有意义的文本内容。诸如于如下的 prompt</p> 
<blockquote> 
 <p>women back view without face, flowing dress, edge of the sea, backview, back turned to the camera, upon the glow of the setting sun, sun below the horizon, golden light over the water, hair sways gently, Chinese style clothes, black hair,</p> 
</blockquote> 
<p>可以在 Stable Diffusion 生成图片（配置了 negative prompt）：</p> 
<p style="text-align:center"><img alt="0652b5a00fb3a992c460b0272f9593da.png" src="https://images2.imgbox.com/c8/c9/1lqOu3bU_o.png"></p> 
<p>所以，质量看上去不错，但是可能不是你想要的。在 ChatGPT 则可以生成文本，质量上也是相似的，但是对于 AI 输出的文本来说，质量并没有这么直观。</p> 
<h1>应用好 Prompt 的核心思想：概念与类比</h1> 
<p>开始之前，可以看一下这个问题示例：</p> 
<ol>
<li> <p>设计模式的要素是哪些？</p> </li>
<li> <p>对于 AI 领域的 prompt 编写来说，我们通常使用的模式有哪些？</p> </li>
<li> <p>能将 AI 领域的 prompt 常见的设计模式用 "设计模式要素" 的格式一一表达吗？</p> </li>
</ol>
<p>核心思想，将设计模式要素作为一个概念，让 AI 类比到 prompt 里的模式。详细见：</p> 
<ol>
<li> <p>design-pattern.analogy</p> </li>
<li> <p>design-pattern.analogy2</p> </li>
</ol>
<p>当然了，类比和定义概念不一定都会成功。</p> 
<h1>基础模式</h1> 
<p>四种基础模式：</p> 
<ul>
<li> <p>By example (示例模式)：在这种模式下，我们给模型提供一些示例文本，模型需要生成与示例文本类似的文本。这种模式通常用于生成类似于给定示例的文本，例如自动生成电子邮件、产品描述、新闻报道等。示例文本可以是单个句子或多个段落，具体取决于任务的要求。</p> </li>
<li> <p>By instruction template (指令模板)：在这种模式下，我们给模型提供一些明确的指令，模型需要根据这些指令生成文本。这种模式通常用于生成类似于技术说明书、操作手册等需要明确指令的文本。指令可以是单个句子或多个段落，具体取决于任务的要求。</p> </li>
<li> <p>By specific (特定指令)：在这种模式下，我们给模型提供一些特定信息，例如问题或关键词，模型需要生成与这些信息相关的文本。这种模式通常用于生成答案、解释或推荐等。特定信息可以是单个问题或多个关键词，具体取决于任务的要求。</p> </li>
<li> <p>By proxy（代理模式）：在这种模式下，可以充当了一个代理，代表某个实体（例如人、角色、机器人等）进行操作或交互。代理模式的核心思想是引入一个中介对象来控制对实际对象的访问，从而实现一定程度上的隔离和保护。诸如于在 ChatGPT 中，"act as xxx" 可以让 ChatGPT 充当一个代理，扮演某个角色或实体的身份，以此来处理与该角色或实体相关的任务或请求。</p> </li>
</ul>
<h2>By specific</h2> 
<p style="text-align:center"><img alt="a0bc27a041c7a0623c1c6e0e056c2546.png" src="https://images2.imgbox.com/ca/e4/qUT9YVTM_o.png"></p> 
<figcaption>
 Prompt Enginneering
</figcaption>
<blockquote> 
 <p>在这种模式下，我们给模型提供一些示例文本，模型需要生成与示例文本类似的文本。这种模式通常用于生成类似于给定示例的文本，例如自动生成电子邮件、产品描述、新闻报道等。示例文本可以是单个句子或多个段落，具体取决于任务的要求。</p> 
</blockquote> 
<p>如 <code>翻译</code>、 <code>告诉我</code>，以我们的开头来说：</p> 
<ul><li> <p>定义一下 prompt 工程</p> </li></ul>
<p>类似的场景还可以有：</p> 
<ul>
<li> <p>翻译一下：永和九年，岁在癸丑，暮春之初，会于会稽山阴之兰亭，修禊事也。</p> </li>
<li> <p>转为现代汉语：永和九年，岁在癸丑，暮春之初，会于会稽山阴之兰亭，修禊事也。</p> </li>
</ul>
<p>对应的，还有一系列的子模式</p> 
<h3>子模式</h3> 
<p>如我们通过下面的 prompt 转换了 ChatGPT 输出的子模式：</p> 
<blockquote> 
 <p>转化为 markdown 的 """ <code>markdown {}</code>""" 表格形式，其中的字段为英语模式、中文、简述、示例。</p> 
</blockquote> 
<p>表格示例：</p> 
<p style="text-align:center"><img alt="8ad76eb574e73a0b295cf5ebd1a12942.jpeg" src="https://images2.imgbox.com/7f/75/whfJ2BFr_o.jpg"></p> 
<h3>By Instruction Template</h3> 
<p style="text-align:center"><img alt="d84ef1055ac815a25ea8caf89213eab5.png" src="https://images2.imgbox.com/01/b3/FL4Y1jY1_o.png"></p> 
<figcaption>
 Instruction
</figcaption>
<blockquote> 
 <p>在这种模式下，我们给模型提供一些明确的指令，模型需要根据这些指令生成文本。这种模式通常用于生成类似于技术说明书、操作手册等需要明确指令的文本。指令可以是单个句子或多个段落，具体取决于任务的要求。</p> 
</blockquote> 
<p>如下是一个示例：</p> 
<pre class="has"><code class="language-go">使用 STAR 原则与下面的格式总结一下这段话：
"""
最近几天，因为工作 + 兴趣的原则，我在研究用 text 2 image 来展示如何演进 prompt、用 text 2 article 来展示充足 prompt 的优点、结合 GitHub Copliot 来实现 prompt 完成工作。然后，我在本地部署了一个 Stable Diffusion、使用 ChatGPT 写作展示 text 2 article、在 IDEA 中使用 GitHub Copilot。最后，得到了多篇文章和好多的文章阅读量、几个 Jupyter 代码段、以及一些经验。
"""
情境(Situation):
任务(Task): &lt;comma_separated_list_of_task&gt;
行动(Action): -||-
结果(Result): -||-</code></pre> 
<p>输出文本时要注意中英文之间插入空格，留出间隔，诸如于 """Hello 你好"""，用这种方式输出一下刚才的文本：</p> 
<pre class="has"><code class="language-go">情境(Situation): 最近几天，在工作和兴趣的驱动下，研究如何使用 text 2 image 和 text 2 article 展示 prompt 演进以及结合 GitHub Copliot 来完成工作。
任务(Task):
研究如何使用 text 2 image 展示 prompt 的演进过程
研究如何使用 text 2 article 展示 prompt 的优点
结合 GitHub Copliot 来实现 prompt 完成工作
行动(Action):
本地部署了一个稳定的 Diffusion 模型
使用 ChatGPT 撰写文章来展示 text 2 article 的效果
在 IDEA 中使用 GitHub Copilot
结果(Result):
得到了多篇文章和很多的文章阅读量
获得了几个 Jupyter 代码段以及相关经验</code></pre> 
<h2>By proxy</h2> 
<p style="text-align:center"><img alt="9cdb8392530d480adff7f1a1cdc332fe.png" src="https://images2.imgbox.com/9d/5f/rfk5AMAG_o.png"></p> 
<figcaption>
 Proxy
</figcaption>
<blockquote> 
 <p>Proxy 模式是指用户可以要求 ChatGPT 以特定的身份、角色或者身份扮演某个特定的人、角色或对象来生成回答。这种模式通常用于模拟某个特定人物的语言风格和语境，生成特定情境下的对话、回答或其他形式的文本。</p> 
</blockquote> 
<h3>例子 1：公司客服</h3> 
<p>当使用 ChatGPT 来代替某个人或实体时，可以使用 by proxy 模式。</p> 
<p>例如，可以使用以下 prompt 提问 ChatGPT 代替某个公司的客服：</p> 
<blockquote> 
 <p>我是一家餐饮公司的客服，有顾客反馈说我们的菜品质量有问题，我们该怎么处理呢？</p> 
</blockquote> 
<p>在这种情况下，ChatGPT 会扮演客服的角色，并根据提示来回答，从而帮助公司解决问题。ChatGPT 可以使用类似以下的方式来回答：</p> 
<blockquote> 
 <p>您好，很抱歉听到您的反馈。我们将会仔细审核您的反馈，并尽快采取相应措施来解决这个问题。为此，我们需要更多的信息来进一步了解您的反馈，包括哪些菜品有问题，具体问题是什么等。请问您可以提供更多的信息吗？</p> 
</blockquote> 
<h3>例子 2：终端计算机</h3> 
<p>这种方式可以通过让 ChatGPT 扮演某个实体的角色，例如客服、销售代表等等，来帮助用户解决问题。</p> 
<p>在 Awesome ChatGPT Prompts 中：</p> 
<blockquote> 
 <p>Human: Act as a Linux Terminal</p> 
</blockquote> 
<p>Robot:</p> 
<blockquote> 
 <p>ChatGPT: I want you to act as a linux terminal. I will type commands and you will reply with what the terminal should show. I want you to only reply with the terminal output inside one unique code block, and nothing else. do not write explanations. do not type commands unless I instruct you to do so. When I need to tell you something in English, I will do so by putting text inside curly brackets {like this}. My first command is pwd</p> 
</blockquote> 
<h2>By demonstration</h2> 
<blockquote> 
 <p>在这种模式下，我们给模型提供一些特定信息，例如问题或关键词，模型需要生成与这些信息相关的文本。这种模式通常用于生成答案、解释或推荐等。特定信息可以是单个问题或多个关键词，具体取决于任务的要求。</p> 
</blockquote> 
<p>示例：</p> 
<pre class="has"><code class="language-go">任务表述 颜色代表了温度
例子1 绿色代表寒冷
例子2 蓝色代表寒冷
例子3 红色代表温暖
例子4 黄色代表温暖
执行 橙色代表什么
例子 2：</code></pre> 
<p style="text-align:center"><img alt="478a73e5c77c0c24a0cc43c625095d01.png" src="https://images2.imgbox.com/2f/ce/g4TVaPS8_o.png"></p> 
<p>上图为 Cohere AI 官网的示例图，对应的聊天记录如下：</p> 
<pre class="has"><code class="language-go">English: Writing about language models is fun.
Roish: Writingro aboutro languagero modelsro isro funro.
English: The weather is lovely!
Roish:</code></pre> 
<h1>增强 Prompt</h1> 
<h2>再生成模式</h2> 
<p>当我们无法确定我们的 prompt 是否准确，便可以通过 AI 来帮我们丰富 prompt 。如我在：基于编程、绘画、写作的 AI 探索与总结 的例了一样</p> 
<ul>
<li> <p>phodal: 我想写一段话描述一张照片，帮我美化一下：一年轻女子穿着裙子，背对着镜头，在海边看着日落，太阳已经到地平线下面了，她的头发在风中飘动。</p> </li>
<li> <p>ChatGPT: 这张照片中的场景令人心醉，一位年轻女子穿着一条裙子，站在海边，背对着镜头，凝视着地平线下的夕阳。太阳已经沉入了海面，一片金黄色的光芒在海面上弥漫，照亮了整片海洋，仿佛这个时刻被定格在了时间的某个角落里。女子的头发随着微风轻轻飘动，轮廓被余晖映照得柔和而温暖。她的目光凝视着远方，仿佛在思考着生命的意义和无尽的未来。这张照片中蕴含着一种深刻的内涵，让人感受到时间和自然的力量，也让人思考着自己在这个宏大而美丽的世界中的角色和意义。</p> </li>
</ul>
<p>再去除掉不合适的词，进行润色，就可以再创作：</p> 
<ul><li> <p>phodal：翻译成英语</p> </li></ul>
<p>然后再提炼直至扔至 Stable Diffusion 中：</p> 
<blockquote> 
 <p>women back view without face, flowing dress, edge of the sea, backview, back turned to the camera, upon the glow of the setting sun, sun below the horizon, golden light over the water, hair sways gently, Chinese style clothes, black hair,</p> 
</blockquote> 
<p>而后，根据图片的结果，我们再反复修改。</p> 
<h2>控线模式</h2> 
<p>TODO：这里需要给出更精准的定义，如何让 ChatGPT 做到？</p> 
<p>在没有推出 ControlNet，对于一个 Stable Diffusion 玩家，它需要反复地吟唱咒语，才能获取到满意的图案。</p> 
<p>在有了 ControlNet 之后，我们可以创建一个 Openpose，或者是导入图片从图片生成 pose，相当于是给机器一个示例，而后生成的图片就会有令人满意的姿势：</p> 
<p style="text-align:center"><img alt="ee89ce4b84c6e1943fa5bca84dc45d83.png" src="https://images2.imgbox.com/c3/f8/kjoFCM6k_o.png"></p> 
<p>在 GitHub Copilot，我们可以通过设置输入和输出，结合函数名三个要素，Copilot 就能生成大致准确的代码：</p> 
<figcaption>
 GitHub Copilot 示例
</figcaption>
<p>而在必要的情况下，添加一下注释就能更完整了：</p> 
<pre class="has"><code class="language-go">fun listAllDirInDir(dir: String): List&lt;File&gt; {
// ignore hidden files
}</code></pre> 
<p>生成的代码会更贴近我们的需求。</p> 
<h1>拆解</h1> 
<blockquote> 
 <p>对于复杂问题，ChaGPT 无法一次性输出全部内容，需要进行拆解。</p> 
</blockquote> 
<p>已知问题：ChatGPT 当前版本会丢失上下文。</p> 
<pre class="has"><code class="language-go">我们来定义一下 DDD 游戏的步骤，一共有 6 个步骤，步骤如下：
"""
第一步. 拆解场景。分析特定领域的所有商业活动，并将其拆解出每个场景。
第二步. 场景过程分析。选定一个场景，并使用 "{名词}已{动词}" 的形式描述过程中所有发生的事件，其中的名词是过程中的实体，其中的动词是实体相关的行为。
第三步. 针对场景建模。基于统一语言和拆解出的场景进行建模，以实现 DDD 设计与代码实现的双向绑定。
第四步. 持续建模。回到第一步，选择未完成的场景。你要重复第一到第四步，直到所有的场景完成。
第五步. 围绕模型生成子域。对模型进行分类，以划定不同的子域，需要列出所有的模型包含英语翻译。
第六步. API 生成。对于每一个子域，生成其对应的 RESTful API，并以表格的形式展现这些 API。
"""
需要注意的是，当我说 """ddd 第 {} 步: {}""" 则表示进行第几步的分析，如 """ddd 第一步: 博客系统""" 表示只对博客系统进行 DDD 第一步分析。我发的是 """ddd: {}"""，则表示按 6 个步骤分析：
明白这个游戏怎么玩了吗？</code></pre> 
<p>完整过程见：DDD Sample</p> 
<h1>概念模式集</h1> 
<h2>Language is Language</h2> 
<p>对于 ChatGPT 来说，语言就是语言，他不区分自然语言和编程语言，甚至有可能编程语言对它更友好。所以我们可以直接通过编程语言与之交流：</p> 
<pre>我有下列遗留代码，我想在接口的函数名、参数名不变的情况下（可以新参数，旧的参数不能变）加入新功能：
</pre> 
<pre><code class="language-javascript">module.exports = async function loadYamlFile(filepath, workdir = path.dirname(filepath)) { 
  const content = await fs.readFile(filepath, 'utf8'); // 读取文件内容
  // TODO: 将 content 看做ejs模板的字符串，进行渲染，如果传入了渲染ejs时的context值不为undefined，就进行渲染，否则不进行渲染。

  // TODO：将渲染后的结果传给yaml.load
  const data = yaml.load(content); // 解析YAML为JSON对象
  

  // 遍历JSON对象，查找$ref属性
  const processRef = async (obj) =&gt; {
    if (typeof obj === 'object' &amp;&amp; obj !== null) { // 如果是对象
      if ('$ref' in obj) { // 如果包含$ref属性
        const refPath = path.join(workdir, obj.$ref.split('#')[0]); // 获取引用文件路径
        const pointer = obj.$ref.split('#')[1]; // 获取JSON指针

        // TODO: 递归调用的时候，取出context中以obj.$ref的属性值作为属性名的值作为新的context向下传递
        const refData = await loadYamlFile(refPath, path.dirname(refPath)); // 递归读取引用文件
        const value = getValueByPointer(refData, pointer); // 修复了 # 号问题
        return value;
      } else { // 如果不包含$ref属性，递归处理子属性
        for (const prop in obj) {
          obj[prop] = await processRef(obj[prop]);
        }
      }
    }
    return obj;
  };</code></pre> 
<p>上述描述会比纯自然语言更容易描述我们的需求，适合于更精细的指导。同时，不一定是编程语言，结构化的声明式DSL它也可以很好的解析，如：</p> 
<pre>把我给定的输入输出，按照下面的格式写成一个测试用例的描述：</pre> 
<pre><code class="language-javascript">{
    desc: 'Test with $p_ref returning array',
    input: {
      filepath: './test18.yml',
      workdir: './test/v2',
    },
    expected: {
        "name": "Alice",
        "age": 20
      }
  }</code></pre> 
<p>结果：</p> 
<pre><code class="language-javascript">{
  desc: 'Test with $p_ref returning array',
  input: {
    filepath: './test19.yml',
    workdir: './test/v2',
  },
  expected: [
    {
      "name": "Bob"
    },
    {
      "name": "Alice"
    },
    {
      "name": "Bob"
    },
    {
      "name": "Alice"
    }
  ]
}</code></pre> 
<pre>该测试用例输入了一个 YAML 文件 test19.yml，该文件中包含了一个 $flaten 属性，其值为两个 $p_ref 对象组成的数组，引用了一个返回数组的 YAML 文件 test19_ref.yml。

执行该测试用例后，期望得到的输出是一个数组，其中包含了两个 $p_ref 引用结果的 flatten 后的结果。

需要注意的是，由于该测试用例涉及到文件读取和模板渲染等操作，需要在测试前确保相关文件和依赖库已经正确安装并配置好。</pre> 
<p>通过使用DSL，还可以缩短输入和输出的token数，从而放大 ChatGPT 的能力。</p> 
<h2>概念对齐</h2> 
<p>如在 ChatGPT 中对于自举的理解是不符合我们这里的需求：</p> 
<p style="text-align:center"><img alt="b87ab10ee78813f6439825f0c583341d.png" src="https://images2.imgbox.com/20/96/QKoLbsxL_o.png"></p> 
<figcaption>
 Bootstrap
</figcaption>
<p>第一步，定义</p> 
<blockquote> 
 <p>phodal：自举是指就编译器可以自行编译自己的编译器。实现方法就是这个编译器的作者用这个语言的一些特性来编写编译器并在该编译器中支持这些自己使用到的特性。</p> 
</blockquote> 
<p>第二步，试探</p> 
<blockquote> 
 <p>phodal：将自举应用在游戏领域，应该是怎样的？</p> 
</blockquote> 
<p>第三步，确认理解：</p> 
<blockquote> 
 <p>那么，抽象一下我们新定义的自举？</p> 
</blockquote> 
<p style="text-align:center"><img alt="1ee8b9e164a2ab0f41451bca8f042415.png" src="https://images2.imgbox.com/50/4c/bqrzL2qW_o.png"></p> 
<figcaption>
 总结
</figcaption>
<p>最后一问：</p> 
<p><img alt="84f6b1e4a5b9c7564da3b0aaeeafbbad.png" src="https://images2.imgbox.com/f6/9b/mVwuVPHF_o.png"></p> 
<figcaption>
 自举
</figcaption>
<p>PS：mmp，他一定是故意的。</p> 
<h1>类比模式集（待定）</h1> 
<blockquote> 
 <p>该模式集关注于如何让 AI 再学习理解新的内容，生成内容？</p> 
</blockquote> 
<p style="text-align:center"><img alt="a12ddac223050e64ae4881904e5ea4c8.png" src="https://images2.imgbox.com/7c/23/gS9tqmFT_o.png"></p> 
<h2>模板方法</h2> 
<blockquote> 
 <p>模板方法模式是一种行为型模式，它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现，从而使得子类可以在不改变算法结构的情况下重新定义算法中的某些步骤。</p> 
</blockquote> 
<p>在接下来的例子中，我们会创建一个 muji 游戏中。在游戏的实现可以分为多个步骤，例如初始化游戏、生成随机数、获取用户输入、计算得分等等，而这些步骤可以通过模板方法模式来进行实现。</p> 
<pre class="has"><code class="language-go">我们来玩一个编程游戏名为 wula，包含五个步骤：
第一步. 问题分析：每一轮游戏，你将看到一个以 "wula:" 开头的问题，你需要分析这个问题并简单介绍一下通常解决这个问题的方法。
第二步. 代码编写：你需要用 JavaScript 编写解决这个问题的代码，并输出对应的代码，并介绍一下你的代码（不少于 200 字）。
第三步. 代码执行：你需要作为 JavaScript Console 执行第二步写的代码，如果没有给出测试数据，你需要自己随机生成测试数据，并将这些数据输入到代码中进行计算。
第四步. 错误处理：如果你的代码存在错误或无法正常执行，你需要输出错误，并回到第二步重新开始游戏，直到你的代码能够正常工作。
第五步. 总结：你需要用不少于 100 字左右总结一下这个问题，以及你的解决方案，让其他人可以简单了解这个问题及其解决方法。
示例如下：
"""
wula: 头共10，足共28，鸡兔各几只？
简介：这是一个鸡兔同笼问题，{}，
## 鸡兔同笼
// 计算鸡兔数量的函数
function calcAnimals(heads, legs) {
const rabbitCount = (legs - 2 * heads) / 2;
const chickenCount = heads - rabbitCount;
return {"chicken": chickenCount, "rabbit": rabbitCount};
}
// 计算鸡兔数量
const result = calcAnimals(10, 28);
// 输出结果
console.log(result);
代码的输出结果是：{}
## 总结
{}
"""
明白这个游戏怎么玩了吗？</code></pre> 
<p>在这个游戏里，我们结合了几种不同的模式：</p> 
<ol>
<li> <p>Instruction：让 ChatGPT 创建了一个名为 wula 的游戏，并定义了游戏的步骤。</p> </li>
<li> <p>Specific：让 ChatGPT 用 JavaScript 编写一个程序</p> </li>
<li> <p>Proxy：让 ChatGPT 作为 JavaScript Console 执行程序，并返回结果。</p> </li>
<li> <p>Specific：让 ChatGPT 做总结</p> </li>
<li> <p>Demonstration：提供了一个示例，让 ChatGPT 理解游戏的步骤。</p> </li>
</ol>
<h2>自举模式</h2> 
<blockquote> 
 <p>自举的核心思想是利用一组基础工具和材料来构建和生成一个新的工具或系统，从而逐步替代掉原有的基础工具和材料。在这个过程中，新的工具或系统会逐渐变得更为高效和强大，从而实现对原有基础工具和材料的完全替代。</p> 
</blockquote> 
<pre class="has"><code class="language-go">对于一个设计模式来说，它的大纲一般是如下的格式，你能用自举模式做个示例吗？
"""
├── 背景
│ └── 引发设计问题的设计情形
├── 问题
│ └── 在特定场景下反复出现的一系列作用力
└── 解决方案
└── 平衡这些作用力的配置
├── 结构（包含组件和组件之间的关系
└── 运行阶段行为
"""</code></pre> 
<p>再看</p> 
<pre class="has"><code class="language-go">&gt; wula：创作一个新游戏名为 muji，并解释一下这个游戏："""类似于 wula，可以做简单的图形计算，如体积、面积等。这个游戏还能把解决过程解释清楚，拥有有可运行的 Python 代码，最后的输出结果是一篇文章。"""</code></pre> 
<p style="text-align:center"><img alt="65ddd0f4c7e2d0daf907ed52be1049fc.png" src="https://images2.imgbox.com/9e/5b/tGXeuLHx_o.png"></p> 
<figcaption>
 Muji Sample
</figcaption>
<h1>其它</h1> 
<h2>人类如何思考问题？</h2> 
<p>人类相对于其他动物更擅长于类比、概念抽象、符号化等高级认知活动，这些认知活动可以帮助人类在面对新问题时，从已有的知识和经验中找到相似的部分，快速理解和解决新问题。</p> 
<p>而对于机器来说，机器学习算法通过大量的数据和计算，学习到数据中的规律和模式，并将这些规律和模式应用到新的数据中，从而实现预测和决策等功能。例如，机器学习算法可以通过大量的图像数据学习到图像的特征，并在新的图像中识别出相应的物体；也可以通过大量的自然语言数据学习到语言的规律，从而生成自然语言文本。</p> 
<h3>
<strong>欢迎一起思考更多的模式：</strong><a href="https://github.com/prompt-engineering/prompt-patterns" title="https://github.com/prompt-engineering/prompt-patterns">https://github.com/prompt-engineering/prompt-patterns</a>
</h3>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>