<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Solidity基础六 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Solidity基础六</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p style="text-align:center">生活本来就是平凡琐碎的，哪有那么多惊天动地的大事，快乐的秘诀就是不管对大事小事都要保持热情</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81Solidity%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F(%E5%85%A8%E5%B1%80)-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81Solidity%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F%28%E5%85%A8%E5%B1%80%29">一、Solidity的特殊变量(全局)</a></p> 
<p id="%E4%B8%80%E3%80%81Solidity%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%87%8F-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81Solidity%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%87%8F">二、Solidity的不可变量</a></p> 
<p id="immutable%E7%9A%84%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F%C2%A0-toc" style="margin-left:40px"><a href="#immutable%E7%9A%84%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F%C2%A0">immutable的赋值方式 </a></p> 
<p id="%E4%BA%8C%E3%80%81Solidity%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%97%A5%E5%BF%97-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81Solidity%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%97%A5%E5%BF%97">三、Solidity的事件与日志</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%97%A5%E5%BF%97%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3-toc" style="margin-left:40px"><a href="#%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%97%A5%E5%BF%97%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3">事件和日志加深理解</a></p> 
<p id="%E4%B8%89%E3%80%81Solidity%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81Solidity%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">四、Solidity的异常处理</a></p> 
<p id="1.require()-toc" style="margin-left:40px"><a href="#1.require%28%29">1.require()</a></p> 
<p id="2.assert()-toc" style="margin-left:40px"><a href="#2.assert%28%29">2.assert()</a></p> 
<p id="3.revert()-toc" style="margin-left:40px"><a href="#3.revert%28%29">3.revert()</a></p> 
<p id="4.%E4%B8%89%E8%80%85%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90-toc" style="margin-left:40px"><a href="#4.%E4%B8%89%E8%80%85%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90">4.三者使用例子</a></p> 
<p id="5.require%E3%80%81assert%E3%80%81revert%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px"><a href="#5.require%E3%80%81assert%E3%80%81revert%E5%8C%BA%E5%88%AB">5.require、assert、revert区别</a></p> 
<p id="6%20require%E3%80%81assert%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px"><a href="#6%20require%E3%80%81assert%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">6 require、assert 使用场景</a></p> 
<p id="7.%E6%8A%9B%E5%BC%83%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%85%B6%E4%BB%96%E6%96%B0%E5%A2%9E%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5%C2%A0-toc" style="margin-left:40px"><a href="#7.%E6%8A%9B%E5%BC%83%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%85%B6%E4%BB%96%E6%96%B0%E5%A2%9E%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5%C2%A0">7.抛弃的异常语句和其他新增的异常语句 </a></p> 
<p id="%E5%9B%9B%E3%80%81Solidity%20%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6%C2%A0-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81Solidity%20%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6%C2%A0">五、Solidity 工厂合约 </a></p> 
<hr id="hr-toc"> 
<p><img alt="" height="296" src="https://images2.imgbox.com/5f/93/dOoFj7xP_o.png" width="672"></p> 
<p id="main-toc"></p> 
<p></p> 
<h1 id="%E4%B8%80%E3%80%81Solidity%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F(%E5%85%A8%E5%B1%80)">一、Solidity的特殊变量(全局)</h1> 
<blockquote> 
 <p>特殊变量，是全局可用的变量，提供关于区块链的信息。下面列出了常用的特殊变量 </p> 
</blockquote> 
<table><tbody>
<tr>
<th>名称</th>
<th>返回</th>
</tr>
<tr>
<td>blockhash(uint blockNumber) returns (bytes32)</td>
<td>给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</td>
</tr>
<tr>
<td>block.coinbase (address payable)</td>
<td>当前区块矿工的地址</td>
</tr>
<tr>
<td>block.difficulty (uint)</td>
<td>当前区块的难度</td>
</tr>
<tr>
<td>block.gaslimit (uint)</td>
<td>当前区块的gaslimit</td>
</tr>
<tr>
<td>block.number (uint)</td>
<td>当前区块的number</td>
</tr>
<tr>
<td>block.timestamp (uint)</td>
<td>当前区块的时间戳，为unix纪元以来的秒</td>
</tr>
<tr>
<td>gasleft() returns (uint256)</td>
<td>剩余 gas</td>
</tr>
<tr>
<td>msg.data (bytes calldata)</td>
<td>完成 calldata</td>
</tr>
<tr>
<td>msg.sender (address payable)</td>
<td>消息发送者 (当前 caller)</td>
</tr>
<tr>
<td>msg.sig (bytes4)</td>
<td>calldata的前四个字节 (function identifier)</td>
</tr>
<tr>
<td>msg.value (uint)</td>
<td>当前消息的wei值</td>
</tr>
<tr>
<td>now (uint)</td>
<td>当前块的时间戳</td>
</tr>
<tr>
<td>tx.gasprice (uint)</td>
<td>交易的gas价格</td>
</tr>
<tr>
<td>tx.origin (address payable)</td>
<td>交易的发送方</td>
</tr>
</tbody></table> 
<p></p> 
<h1 id="%E4%B8%80%E3%80%81Solidity%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%87%8F">二、Solidity的不可变量</h1> 
<blockquote> 
 <p>Solidity 的不可变量是另一种常量的表达方式。与常量类似，但是不必强制定义就需要赋值，可以在构造函数时传值，部署后无法改变。它是一种修饰符,被它修饰的变量就称之为不可变量</p> 
 <p></p> 
 <p><strong>关键字：immutable</strong></p> 
 <p></p> 
 <p>immutable 不可变量同样不会占用状态变量存储空间，在部署时，变量的值会被追加的运行时字节码中， 因此它<strong>比使用状态变量便宜的多</strong>，也同样带来了更多的安全性。</p> 
 <p></p> 
 <p>immutable  特性在很多时候非常有用， 最常见的如 ERC20 代币用来指示小数位置的 <code>decimals</code> 变量，它是一个不能修改的变量，很多时候我们需要在创建合约的时候指定它的值，这时 immutable 就大有用武之地， 类似的还有要保创建者地址、关联合约地址等。</p> 
</blockquote> 
<h2 id="immutable%E7%9A%84%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F%C2%A0">immutable的赋值方式 </h2> 
<blockquote> 
 <p><strong>第一种：定义后就赋值</strong></p> 
 <pre>数据类型 修饰符 immutable 不可变量名 = 值;
例如 :address public immutable owner = msg.sender;</pre> 
 <p><strong>第二种：构造函数赋值</strong></p> 
 <p>constructor (参数列表) {<!-- --></p> 
 <p>        不可变量名 = 值</p> 
 <p>}</p> 
 <p>例如：</p> 
 <pre>contract Immutable {
   address public immutable owner;
address public immutable owners; 

   constructor(address _owner) {
      owner = _owner;
        owners=msg.sender;
   }</pre> 
</blockquote> 
<p></p> 
<h1 id="%E4%BA%8C%E3%80%81Solidity%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%97%A5%E5%BF%97">三、Solidity的事件与日志</h1> 
<blockquote> 
 <p>Soliddity 事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。是以太坊提供的基本功能，用于将数据记录成日志保存到区块链上，用户可以自定义需要记录的数据，以及topic和索引 ,</p> 
 <p></p> 
 <p><strong>事件和日志的区别：</strong></p> 
 <p><span style="color:#956fe7">事件强调行为操作、日志强调存储内容，两者是完全不同的概念</span></p> 
 <p></p> 
 <p>事件本质上也相当于一个特殊的函数，称为事件函数</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify">事件在合约中可以被继承</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify">在DAPP的应用中，如果监听了某个事件，当事件发生时，会进行回调执行一系列操作</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>事件的关键字：event </strong></p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>事件的定义格式：</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify">event 事件名( 所要记录的参数列表 ) </p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>事件的触发格式：</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify">emit 事件名( 所要传递给事件的参数列表 )</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>日志：logs</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify">在以太坊的语境里，日志对事件和触发该事件产生的交易信息的存储</p> 
 <p style="margin-left:.0001pt;text-align:justify">日志的组成:</p> 
 <ol>
<li>address: 交易地址</li>
<li>args:事件状态变量存储对象(我们所保存的状态变量值就在这里面)</li>
<li>blockHash: 哈希难度</li>
<li>blockNumber: 区块号</li>
<li>event: 事件名</li>
<li>logIndex:</li>
<li>removed: </li>
<li>transactionHash: 交易哈希</li>
<li>transactionIndex: </li>
</ol> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>日志的作用</strong></p> 
 <ul>
<li style="margin-left:.0001pt;text-align:justify">记录了事件指定的状态变量保存在区块链上的数据(记录了事件不同的状态)</li>
<li style="margin-left:.0001pt;text-align:justify">通过日志来得到某个事件定义的状态变量中以前和现在的值</li>
</ul> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify"><span style="color:#fe2c24"><strong>注意事项：在web3中采用事件监听所返回的值是该事件的日志，可以通过该日志.args.状态变量名    来获取日志中某个状态变量的值，而这个返回的结果是一个数组，它存储了该状态变量变化的值</strong></span></p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify">当触发了事件，那么remix控制台里面的一个信息里面就有logs（日志）信息</p> 
 <p style="margin-left:.0001pt;text-align:justify">里面记录了ages由值0变成值2</p> 
 <p style="margin-left:.0001pt;text-align:justify"><img alt="" height="322" src="https://images2.imgbox.com/66/ce/9Utvas31_o.png" width="558"></p> 
</blockquote> 
<pre><code class="language-java">//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;
contract Test{
    int age;
    string a=unicode'a';
    event  evt(int ages);
    function set(int _age) public returns(string memory){
        age=_age;
        emit evt(_age);
        return a;
    }
}</code></pre> 
<h2 id="%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%97%A5%E5%BF%97%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3">事件和日志加深理解</h2> 
<blockquote> 
 <p>当定义的事件触发时，我们可以将事件存储到EVM的交易日志中，日志其实是区块链中一种特殊的数据结构</p> 
 <p></p> 
 <p style="margin-left:.0001pt;text-align:justify">日志与合约关联，与合约合并存储到区块链中，只要某个区块可以访问，其相关的日志也能访问，<strong>但在合约中，我们不能直接访问日志和事件数据</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify">可以通过日志实现简单支付验证SPV,如果一个外部实体提供了一个带有这种证明的合约，它可以检查日志是否真实存在区块链中</p> 
</blockquote> 
<p></p> 
<h1 id="%E4%B8%89%E3%80%81Solidity%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" style="margin-left:.0001pt;text-align:justify">四、Solidity的异常处理</h1> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>异常和报错</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify">异常是指程序可以解决的一种错</p> 
 <p style="margin-left:.0001pt;text-align:justify">报错是指程序无法解决的一种错</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="text-align:justify"><strong>异常处理</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify">Solidity处理异常和我们常见的语言不一样，solidity是通过<strong>回退状态</strong>的方式来处理错误,同时给调用者返回一个错误标识。</p> 
 <p style="margin-left:.0001pt;text-align:justify">如果不用回退状态的方式来处理，那么异常后，状态发生错误的改变，在区块链上是需要相当大的代价来完成的</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>异常处理过程</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify"><span style="color:#956fe7">发生异常时会撤销当前调用（及其所有子调用）所改变的的状态，同时给调用者返回一个错误标识。也就是回到最初调用前状态</span></p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="text-align:justify">异常处理模式</p> 
 <p style="margin-left:.0001pt;text-align:justify">早期是if....throw这个会消耗所有的gas</p> 
 <p style="margin-left:.0001pt;text-align:justify">Solidity 0.4.10后发布了新的异常处理方法:异常处理函数</p> 
 <p style="margin-left:.0001pt;text-align:justify">0.6.0版本还出现了try...catch</p> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>主要还是以下3种:</strong></p> 
 <ul>
<li style="margin-left:.0001pt;text-align:justify">require()  </li>
<li style="margin-left:.0001pt;text-align:justify">assert()  </li>
<li style="margin-left:.0001pt;text-align:justify">revert()  </li>
</ul> 
 <p style="margin-left:.0001pt;text-align:justify">解决了以前的不好的地方，特别地,  assert() 、 require() 代码会 “确保” 提高合约代码l逻辑条理的清晰，所有我们需要好好学习并区别使用它们</p> 
</blockquote> 
<h2 id="1.require()" style="margin-left:.0001pt;text-align:justify">1.require()</h2> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>格式：</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify">require( 判断表达式 ,  &lt;string&gt;)</p> 
 <p style="margin-left:.0001pt;text-align:justify">&lt;string&gt; 提供了一个自定义错误消息输出的选项</p> 
 <p style="margin-left:.0001pt;text-align:justify">如果不满足条件也就是判断为false，则此函数调用将恢复到原始状态，此函数用于检查输入或外部组件的错误。这个方法一般是用来处理</p> 
 <p></p> 
 <p>require 可以有返回值，例如：require(condition, 'Something bad happened');。</p> 
 <p>返回：'Something bad happened'</p> 
 <p><span style="color:#956fe7">require 的返回值不宜过长，因为返回信息需要消耗 gas。</span></p> 
 <p></p> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>使用 require() 的场景</strong></p> 
 <ol>
<li style="margin-left:.0001pt;text-align:justify">验证一个用户输入是否合法 ： require(input&gt;20)</li>
<li style="margin-left:.0001pt;text-align:justify">验证外部合约的调用结果，例如：require(external.send(amount))</li>
<li style="margin-left:.0001pt;text-align:justify">判断执行一段语句的前置条件；  require(balance[msg.sender]&gt;=amount)</li>
<li style="margin-left:.0001pt;text-align:justify">require应该被经常用到</li>
</ol> 
</blockquote> 
<h2 id="2.assert()">2.assert()</h2> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify">assert(判断表达式)  </p> 
 <p style="margin-left:.0001pt;text-align:justify">如果不满足条件也就是判断为false，则此函数调用将导致一个无效的操作码，对状态所做的任何更改将被还原，这个一般方法是用来处理内部错误的</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p><strong>使用 assert() 的场景</strong></p> 
 <ul>
<li>检查溢出</li>
<li>检查不变量</li>
<li>更改后验证状态</li>
<li>预防永远不会发生的情况</li>
<li> <p style="margin-left:.0001pt;text-align:justify">避免本不应该发生的情况出现，如程序bug</p> </li>
</ul> 
 <p>一般来说，使用assert()的频率较少，通常用于函数的结尾。</p> 
 <p style="margin-left:.0001pt;text-align:justify">assert算是最后防线，因为它会在执行的最后来检查行为的合法性</p> 
</blockquote> 
<h2 id="3.revert()">3.revert()</h2> 
<blockquote> 
 <p>revert()  </p> 
 <p>一执行revert()就将中止执行并将所作的更改还原为执行前的状态 </p> 
 <p></p> 
 <p>它可以搭配if分支来实现和require和assert的效果 </p> 
 <p></p> 
 <p style="margin-left:.0001pt;text-align:justify">一个交易最终只会有两种状态： cmmit &amp; revert</p> 
 <p style="margin-left:.0001pt;text-align:justify">适用revert的时候</p> 
 <p style="margin-left:.0001pt;text-align:justify">因为该操作是已知不应该出现的时候，所以通常同来检查overflow/underflow、检查被修改过的状态变量是否合法，避免不应该出现的条件发生</p> 
</blockquote> 
<h2 id="4.%E4%B8%89%E8%80%85%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90">4.三者使用例子</h2> 
<pre><code class="language-java">uint public num=0;

function testRevert() public {
num++;
if (num&gt;3){
revert(“revert返回的错误”);
}
num++;

}

function testAssert() public {
num++;
assert(num&lt;13);
num++;

}

function testRequire()public {
num++
require(	num&lt;23,”require报错信息”);
num++;

}
总结：不管是哪个回退，都是回退到不满足条件前满足条件的状态</code></pre> 
<h2 id="5.require%E3%80%81assert%E3%80%81revert%E5%8C%BA%E5%88%AB">5.require、assert、revert区别</h2> 
<blockquote> 
 <p><strong>require、assert、revert共同点：</strong></p> 
 <p>assert()与require()语句都需要满足括号中的条件，才能进行后续操作，若不满足则抛出错误。而revert()就抛出错误</p> 
 <p>以下三个语句的功能完全相同：</p> 
 <pre>// revert
if(msg.sender != owner) { 
   revert();
 }
// require
require(msg.sender == owner);

// assert
assert(msg.sender == owner);</pre> 
 <p></p> 
 <p><strong>require、assert 不同点</strong></p> 
 <p>assert(false) 编译为 0xfe，这是一个无效的操作码，所以会消耗掉所有剩余的 gas，并恢复所有的操作。</p> 
 <p>require(false) 编译为 0xfd，这是revert()的操作码，所以会退还所有剩余的 gas，同时可以返回一个自定义的报错信息。 </p> 
 <p></p> 
 <p>同样作为判断一个条件是否满足的函数，require会回退剩下的gas，而assert会烧掉所有的gas</p> 
 <p>所以require 的 gas 消耗要小于 assert，而且可以有返回值，使用更为灵活。</p> 
 <p></p> 
</blockquote> 
<h2 id="6%20require%E3%80%81assert%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">6 require、assert 使用场景</h2> 
<blockquote> 
 <ul>
<li>require() 函数用于检测输入变量或状态变量是否满足条件，以及验证调用外部合约的返回值。</li>
<li>require() 语句的失败报错，应该被看作一个正常的判断语句流程不能通过的事件。</li>
<li>assert()语句的失败报错，意味着发生了代码层面的错误事件，很大可能是合约中有一个bug需要修复</li>
</ul> 
 <p></p> 
 <p><span style="color:#fe2c24"><strong>基本上，require() 应该用于检查条件，而 assert() 只是为了防止发生任何非常糟糕的事情。</strong></span></p> 
</blockquote> 
<h2 id="7.%E6%8A%9B%E5%BC%83%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%85%B6%E4%BB%96%E6%96%B0%E5%A2%9E%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5%C2%A0">7.抛弃的异常语句和其他新增的异常语句 </h2> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify"><strong>throw的介绍</strong>------throw已被废弃</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify">throw在solidity会被编译成invalid opcode，因此执行到这里，EVM会终止tx(交易)且没收所有的gas</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify">Throrw算是一个误用，实际上solidity并没有错误处理的catch机制。因为它在语言上不算好词</p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p style="margin-left:.0001pt;text-align:justify">官方建议修改用revert()代替</p> 
 <p style="margin-left:.0001pt;text-align:justify">  </p> 
 <p style="margin-left:.0001pt;text-align:justify"></p> 
 <p><strong>try...catch介绍</strong></p> 
 <p>我们在当前合约发起对外部合约调用的话，如果外部合约调用执行失败被 revert，外部合约状态会被回滚，当前合约状态也会被回滚。</p> 
 <p>但有时候我们并不想这样，要是能够捕获外部合约调用异常，然后根据情况做自己的处理不是更好吗？所以，这种场景下适应于使用 try...catch 语句。</p> 
 <p></p> 
 <p><strong>和require对比</strong></p> 
 <p>以下代码将会触发 catch Error(string memory reason) ，最终输出 require error。</p> 
 <pre><code class="language-java">pragma solidity ^0.8.0;
contract Manager {
    function count() public pure returns(int){
        require(1==2,"require error");
        return 2;
    }
    
    function test() public view returns(string memory) {
        try this.count()  {
            return "success";
        } catch Error(string memory reason/* 出错原因 */) {
            // 调用 count() 失败时执行，通常是不满足 require 语句条件或触发 revert 语句时所引起的调用失败
            return reason;
        } catch (bytes memory) {
            // 调用 count() 异常时执行，通常是触发 assert 语句或除 0 等比较严重错误时会执行
            return "assert error";
        }
    }
}</code></pre> 
 <p><strong>和assert（）对比</strong></p> 
 <p>以下代码将会触发 catch (bytes memory) ，最终输出 assert error。</p> 
 <pre><code class="language-java">pragma solidity ^0.8.0;
contract Manager {
    function count() public pure returns(int){
        assert(1==2);
        return 2;
    }
    
    function test() public view returns(string memory) {
        try this.count()  {
            return "success";
        } catch Error(string memory reason/* 出错原因 */) {
            // 调用 count() 失败时执行，通常是不满足 require 语句条件或触发 revert 语句时所引起的调用失败
            return reason;
        } catch (bytes memory) {
            // 调用 count() 异常时执行，通常是触发 assert 语句或除 0 等比较严重错误时会执行
            return "assert error";
        }
    }
}</code></pre> 
</blockquote> 
<p></p> 
<h1 id="%E5%9B%9B%E3%80%81Solidity%20%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6%C2%A0">五、Solidity 工厂合约 </h1> 
<blockquote> 
 <p>Solidity 工厂合约是一种批量部署合约的方式。</p> 
 <p>通过一个工厂合约创建部署合约，并记录下所有部署合约的地址。</p> 
</blockquote> 
<pre><code class="language-java">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Account {
    address public bank;
    address public owner;

    constructor(address _owner) payable{
        bank = msg.sender;
        owner = _owner;
    }
}

contract Factory {
    Account[] public accounts;

    function createAccount(address owner) external payable{
       accounts.push(new Account{value:123}(owner));
       accounts.push(new Account{value:456}(owner));
    }
}</code></pre> 
<p><strong> 我们只需要部署 Factory 合约，运行 createAccount 方法，就会自动创建其它合约。</strong></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>