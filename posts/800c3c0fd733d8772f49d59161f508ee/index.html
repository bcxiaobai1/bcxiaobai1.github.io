<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>华为C语言编程规范（2W字总结） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">华为C语言编程规范（2W字总结）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p><strong>1、代码总体原则</strong></p> 
<p><strong>1、清晰第一 </strong></p> 
<p></p> 
<p>清晰性是易于维护、易于重构的程序必需具备的特征。代码首先是给人读的，好的代码应当可以像文章一样发声朗诵出来。</p> 
<p></p> 
<p>目前软件维护期成本占整个生命周期成本的40%~90%。根据业界经验，维护期变更代码的成本，小型系统是开发期的5倍，大型系统（100万行代码以上）可以达到100倍。业界的调查指出，开发组平均大约一半的人力用于弥补过去的错误，而不是添加新的功能来帮助公司提高竞争力。</p> 
<p></p> 
<p>一般情况下，代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化。</p> 
<p></p> 
<p><strong>2、简洁为美</strong></p> 
<p></p> 
<p>简洁就是易于理解并且易于实现。代码越长越难以看懂，也就越容易在修改时引入错误。写的代码越多，意味着出错的地方越多，也就意味着代码的可靠性越低。因此，我们提倡大家通过编写简洁明了的代码来提升代码可靠性。</p> 
<p></p> 
<p>废弃的代码(没有被调用的函数和全局变量)要及时清除，重复代码应该尽可能提炼成函数。</p> 
<p></p> 
<p><strong>3、选择合适的风格，与代码原有风格保持一致</strong></p> 
<p></p> 
<p>产品所有人共同分享同一种风格所带来的好处，远远超出为了统一而付出的代价。在公司已有编码规范的指导下，审慎地编排代码以使代码尽可能清晰，是一项非常重要的技能。如果重构/ / 修改其他风格的代码时，比较明智的做法是根据 现有 代码 的 现有风格继续编写代码，或者使用格式转换工具进行转换成公司内部风格。</p> 
<p></p> 
<p><strong>2、头文件</strong></p> 
<p>对于C语言来说，头文件的设计体现了大部分的系统设计。不合理的头文件布局是编译时间过长的根因，不合理的头文件实际上反映了不合理的设计。</p> 
<p></p> 
<p><strong>1、头文件中适合放置接口的声明，不适合放置实现</strong></p> 
<p></p> 
<p>头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。</p> 
<p></p> 
<p>要求：</p> 
<p></p> 
<p>内部使用的函数（相当于类的私有方法）声明不应放在头文件中。</p> 
<p>内部使用的宏、枚举、结构定义不应放入头文件中。</p> 
<p>变量定义不应放在头文件中，应放在.c文件中。</p> 
<p>变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。即使必须使用全局变量，也只应当在.c中定义全局变量，在.h中仅声明变量为全局的。</p> 
<p><strong>2、头文件应当职责单一，切忌依赖复杂</strong></p> 
<p></p> 
<p>头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.c中使用一个宏，而包含十几个头文件。</p> 
<p></p> 
<p>错误示例：某平台定义WORD类型的头文件：</p> 
<pre><code class="hljs">#include &lt;VXWORKS.H&gt;

#include &lt;KERNELLIB.H&gt;

#include &lt;SEMLIB.H&gt;

#include &lt;INTLIB.H&gt;

#include &lt;TASKLIB.H&gt;

#include &lt;MSGQLIB.H&gt;

#include &lt;STDARG.H&gt;

#include &lt;FIOLIB.H&gt;

#include &lt;STDIO.H&gt;

#include &lt;STDLIB.H&gt;

#include &lt;CTYPE.H&gt;

#include &lt;STRING.H&gt;

#include &lt;ERRNOLIB.H&gt;

#include &lt;TIMERS.H&gt;

#include &lt;MEMLIB.H&gt;

#include &lt;TIME.H&gt;

#include &lt;WDLIB.H&gt;

#include &lt;SYSLIB.H&gt;

#include &lt;TASKHOOKLIB.H&gt;

#include &lt;REBOOTLIB.H&gt;

…

typedef unsigned short WORD;

…</code></pre> 
<p>这个头文件不但定义了基本数据类型WORD，还包含了stdio.h syslib.h等等不常用的头文件。如果工程中有10000个源文件，而其中100个源文件使用了stdio.h的printf，由于上述头文件的职责过于庞大，而WORD又是每一个文件必须包含的，从而导致stdio.h/syslib.h等可能被不必要的展开了9900次，大大增加了工程的编译时间。</p> 
<p>关注公众号：C语言中文社区，免费领取 500G编程资料。</p> 
<p></p> 
<p><strong>3、头文件应向稳定的方向包含 </strong></p> 
<p></p> 
<p>头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。</p> 
<p></p> 
<p>就我们的产品来说，依赖的方向应该是：产品依赖于平台，平台依赖于标准库。某产品线平台的代码中已经包含了产品的头文件，导致平台无法单独编译、发布和测试，是一个非常糟糕的反例。除了不稳定的模块依赖于稳定的模块外，更好的方式是两个模块共同依赖于接口，这样任何一个模块的内部实现更改都不需要重新编译另外一个模块。在这里，我们假设接口本身是最稳定的。</p> 
<p></p> 
<p><strong>4、每一个 .c 文件应有一个同名 .h 文件，用于声明需要对外公开的接口</strong></p> 
<p></p> 
<p>如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。</p> 
<p></p> 
<p>现有某些产品中，习惯一个.c文件对应两个头文件，一个用于存放对外公开的接口，一个用于存放内部需要用到的定义、声明等，以控制.c文件的代码行数。编者不提倡这种风格。这种风格的根源在于源文件过大，应首先考虑拆分.c文件，使之不至于太大。另外，一旦把私有定义、声明放到独立的头文件中，就无法从技术上避免别人include之，难以保证这些定义最后真的只是私有的。</p> 
<p></p> 
<p><strong>5、禁止头文件循环依赖</strong></p> 
<p></p> 
<p>头文件循环依赖，指a.h包含b.h，b.h包含c.h，c.h包含a.h之类导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h的源代码重新编译。</p> 
<p></p> 
<p><strong>6、  .c/.h文件禁止包含用不到的头文件</strong></p> 
<p></p> 
<p>很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一一钻研，直接包含一切想到的头文件，甚至有些产品干脆发布了一个god.h，其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步恶化，并对后来人的维护造成了巨大的麻烦。</p> 
<p></p> 
<p><strong>7、  头文件应当自包含 </strong></p> 
<p></p> 
<p>简单的说，自包含就是任意一个头文件均可独立编译。如果一个文件包含某个头文件，还要包含另外一个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。</p> 
<p></p> 
<p>示例：如果a.h不是自包含的，需要包含b.h才能编译，会带来的危害：每个使用a.h头文件的.c文件，为了让引入的a.h的内容编译通过，都要包含额外的头文件b.h。额外的头文件b.h必须在a.h之前进行包含，这在包含顺序上产生了依赖。</p> 
<p></p> 
<p>注意：该规则需要与“.c/.h文件禁止包含用不到的头文件”规则一起使用，不能为了让a.h自包含，而在a.h中包含不必要的头文件。a.h要刚刚可以自包含，不能在a.h中多包含任何满足自包含之外的其他头文件。</p> 
<p></p> 
<p><strong>8、总是编写内部 #include 保护符（ #define  保护）</strong></p> 
<p></p> 
<p>多次包含一个头文件可以通过认真的设计来避免。如果不能做到这一点，就需要采取阻止头文件内容被包含多于一次的机制。通常的手段是为每个文件配置一个宏，当头文件第一次被包含时就定义这个宏，并在头文件被再次包含时使用它以排除文件内容。所有头文件都应当使用#define 防止头文件被多重包含，命名格式为FILENAME_H，为了保证唯一性，更好的命名是PROJECTNAME_PATH_FILENAME_H。</p> 
<p></p> 
<p>注：没有在宏最前面加上单下划线"_"，是因为一般以单下划线"_"和双下划线"__"开头的标识符为ANSIC等使用，在有些静态检查工具中，若全局可见的标识符以"_"开头会给出告警。</p> 
<p></p> 
<p>定义包含保护符时，应该遵守如下规则：</p> 
<p></p> 
<p>保护符使用唯一名称；</p> 
<p></p> 
<p>不要在受保护部分的前后放置代码或者注释。</p> 
<p></p> 
<p>正确示例：假定VOS工程的timer模块的timer.h，其目录为VOS/include/timer/timer.h,应按如下方式保护：</p> 
<pre><code class="hljs">#ifndef VOS_INCLUDE_TIMER_TIMER_H

#define VOS_INCLUDE_TIMER_TIMER_H

...

#endif</code></pre> 
<p></p> 
<p>也可以使用如下简单方式保护:</p> 
<pre><code class="hljs">#ifndef TIMER_H

#define TIMER_H

...

#endif</code></pre> 
<p>例外情况：头文件的版权声明部分以及头文件的整体注释部分（如阐述此头文件的开发背景、使用注意事项等）可以放在保护符(#ifndef XX_H)前面。</p> 
<p></p> 
<p><strong>9、禁止在头文件中定义变量</strong></p> 
<p></p> 
<p>在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。</p> 
<p></p> 
<p><strong>10、只能通过包含头文件的方式使用其他 .c 提供的接口，禁止在.c 中通过 extern 的方式使用外部函数接口、变量</strong></p> 
<p></p> 
<p>若a.c使用了b.c定义的foo()函数，则应当在b.h中声明extern int foo(int input)；并在a.c中通过#include &lt;b.h&gt;来使用foo。禁止通过在a.c中直接写extern int foo(int input);来使用foo，后面这种写法容易在foo改变时可能导致声明和定义不一致。</p> 
<p></p> 
<p><strong>11、禁止在 extern "C" 中包含头文件</strong></p> 
<p></p> 
<p>在extern "C"中包含头文件，会导致extern "C"嵌套，Visual Studio对extern "C"嵌套层次有限制，嵌套层次太多会编译错误。</p> 
<p>在extern "C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏。</p> 
<p></p> 
<p>错误示例：</p> 
<pre><code class="hljs">extern “C”

{

#include “xxx.h”

...

}</code></pre> 
<p>正确示例：</p> 
<pre><code class="hljs">#include “xxx.h”

extern “C”

{

...

} </code></pre> 
<p><strong>12、一个模块通常包含多个 .c 文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个 .h ，文件名为目录名</strong></p> 
<p></p> 
<p>需要注意的是，这个.h并不是简单的包含所有内部的.h，它是为了模块使用者的方便，对外整体提供的模块接口。以Google test（简称GTest）为例，GTest作为一个整体对外提供C++单元测试框架，其1.5版本的gtest工程下有6个源文件和12个头文件。但是它对外只提供一个gtest.h，只要包含gtest.h即可使用GTest提供的所有对外提供的功能，使用者不必关系GTest内部各个文件的关系，即使以后GTest的内部实现改变了，比如把一个源文件c拆成两个源文件，使用者也不必关心，甚至如果对外功能不变，连重新编译都不需要。对于有些模块，其内部功能相对松散，可能并不一定需要提供这个.h，而是直接提供各个子模块或者.c的头文件。</p> 
<p></p> 
<p>比如产品普遍使用的VOS，作为一个大模块，其内部有很多子模块，他们之间的关系相对比较松散，就不适合提供一个vos.h。而VOS的子模块，如Memory（仅作举例说明，与实际情况可能有所出入），其内部实现高度内聚，虽然其内部实现可能有多个.c和.h，但是对外只需要提供一个Memory.h声明接口。</p> 
<p></p> 
<p><strong>13、如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的 .h，文件名为子模块名</strong></p> 
<p></p> 
<p>降低接口使用者的编写难度</p> 
<p></p> 
<p><strong>14、头文件不要使用非习惯用法的扩展名，如 .inc </strong></p> 
<p></p> 
<p>目前很多产品中使用了.inc作为头文件扩展名，这不符合c语言的习惯用法。在使用.inc作为头文件扩展名的产品，习惯上用于标识此头文件为私有头文件。但是从产品的实际代码来看，这一条并没有被遵守，一个.inc文件被多个.c包含比比皆是。</p> 
<p>关注公众号：C语言中文社区，免费领取 300G编程资料。</p> 
<p></p> 
<p>除此之外，使用.inc还导致source insight、Visual stduio等IDE工具无法识别其为头文件，导致很多功能不可用，如“跳转到变量定义处”。虽然可以通过配置，强迫IDE识别.inc为头文件，但是有些软件无法配置，如Visual Assist只能识别.h而无法通过配置识别.inc。</p> 
<p></p> 
<p><strong>15、同一产品统一包含头文件排列方式</strong></p> 
<p></p> 
<p>常见的包含头文件排列方式：功能块排序、文件名升序、稳定度排序。</p> 
<p></p> 
<p>正确示例1：以升序方式排列头文件可以避免头文件被重复包含：</p> 
<pre><code class="hljs">#include &lt;a.h&gt;

#include &lt;b.h&gt;

#include &lt;c/d.h&gt;

#include &lt;c/e.h&gt;

#include &lt;f.h&gt;</code></pre> 
<p>正确示例2：以稳定度排序，建议将不稳定的头文件放在前面，如把产品的头文件放在平台的头文件前面：</p> 
<pre><code class="hljs">#include &lt;product.h&gt;

#include &lt;platform.h&gt;</code></pre> 
<p>相对来说，product.h修改的较为频繁，如果有错误，不必编译platform.h就可以发现product.h的错误，可以部分减少编译时间。</p> 
<p></p> 
<p><strong>3、函数</strong></p> 
<p>函数设计的精髓：编写整洁函数，同时把代码有效组织起来。</p> 
<p></p> 
<p>整洁函数要求：代码简单直接、不隐藏设计者的意图、用干净利落的抽象和直截了当的控制语句将函数有机组织起来。</p> 
<p></p> 
<p>代码的有效组织包括：逻辑层组织和物理层组织两个方面。逻辑层，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。物理层，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。</p> 
<p></p> 
<p><strong>1、一个函数仅完成一件功能</strong></p> 
<p></p> 
<p>一个函数实现多个功能给开发、使用、维护都带来很大的困难。</p> 
<p></p> 
<p>将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。</p> 
<p></p> 
<p><strong>2、重复代码应该尽可能提炼成函数</strong></p> 
<p></p> 
<p>重复代码提炼成函数可以带来维护成本的降低。</p> 
<p></p> 
<p>重复代码是我司不良代码最典型的特征之一。在“代码能用就不改”的指导原则之下，大量的烟囱式设计及其实现充斥着各产品代码之中。新需求增加带来的代码拷贝和修改，随着时间的迁移，产品中堆砌着许多类似或者重复的代码。</p> 
<p></p> 
<p>项目组应当使用代码重复度检查工具，在持续集成环境中持续检查代码重复度指标变化趋势，并对新增重复代码及时重构。当一段代码重复两次时，即应考虑消除重复，当代码重复超过三次时，应当立刻着手消除重复。</p> 
<p></p> 
<p><strong>3、避免函数过长，新增函数不超过 50 行 （非空非注释行） </strong></p> 
<p></p> 
<p>过长的函数往往意味着函数功能不单一，过于复杂。</p> 
<p></p> 
<p>函数的有效代码行数，即NBNC（非空非注释行）应当在[1，50]区间。</p> 
<p></p> 
<p>例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。</p> 
<p></p> 
<p>延伸阅读材料：业界普遍认为一个函数的代码行不要超过一个屏幕，避免来回翻页影响阅读；一般的代码度量工具建议都对此进行检查，例如Logiscope的函数度量："Number of Statement" （函数中的可执行语句数）建议不超过20行，QA C建议一个函数中的所有行数（包括注释和空白行）不超过50行。</p> 
<p></p> 
<p><strong>4、避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层</strong></p> 
<p></p> 
<p>函数的代码块嵌套深度指的是函数中的代码控制块（例如：if、for、while、switch等）之间互相包含的深度。每级嵌套都会增加阅读代码时的脑力消耗，因为需要在脑子里维护一个“栈”（比如，进入条件语句、进入循环„„）。应该做进一步的功能分解，从而避免使代码的阅读者一次记住太多的上下文。优秀代码参考值：[1, 4]。</p> 
<p></p> 
<p>错误示例：代码嵌套深度为5层：</p> 
<pre><code class="hljs">void serial (void)

{

    if (!Received)

    {

        TmoCount = 0;

         switch (Buff)

        {

            case AISGFLG:

                if ((TiBuff.Count &gt; 3)&amp;&amp; ((TiBuff.Buff[0] == 0xff) || (TiBuf.Buff[0] == CurPa.ADDR)))

                {

                    Flg7E = false;

                    Received = true;

                }

                else

                {

                    TiBuff.Count = 0;

                    Flg7D = false;

                    Flg7E = true;

                }

                break;

            default:

                break;

        }

    }

}</code></pre> 
<p><strong>5、 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护</strong></p> 
<p></p> 
<p>可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。共享变量指的全局变量和static变量。编写C语言的可重入函数时，不应使用static局部变量，否则必须经过特殊处理，才能使函数具有可重入性。</p> 
<p></p> 
<p>示例：函数square_exam返回g_exam平方值。那么如下函数不具有可重入性。</p> 
<pre><code class="hljs">int g_exam;

unsigned int example( int para )

{

    unsigned int temp;

    g_exam = para; // （**）

    temp = square_exam ( );

    return temp;

}</code></pre> 
<p>此函数若被多个线程调用的话，其结果可能是未知的，因为当（**）语句刚执行完后，另外一个使用本函数的线程可能正好被激活，那么当新激活的线程执行到此函数时，将使g_exam赋于另一个不同的para值，所以当控制重新回到“temp =square_exam ( )”后，计算出的temp很可能不是预想中的结果。此函数应如下改进。 </p> 
<pre><code class="hljs">int g_exam;

unsigned int example( int para )

{

    unsigned int temp;

    [申请信号量操作] // 若申请不到“信号量”，说明另外的进程正处于

    g_exam = para; //给g_exam赋值并计算其平方过程中（即正在使用此

    temp = square_exam( ); // 信号），本进程必须等待其释放信号后，才可继

    [释放信号量操作] // 续执行。其它线程必须等待本线程释放信号量后

    // 才能再使用本信号。

    return temp;

}</code></pre> 
<p><strong>6、对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。</strong></p> 
<p></p> 
<p>对于模块间接口函数的参数的合法性检查这一问题，往往有两个极端现象，即：要么是调用者和被调用者对参数均不作合法性检查，结果就遗漏了合法性检查这一必要的处理过程，造成问题隐患；要么就是调用者和被调用者均对参数进行合法性检查，这种情况虽不会造成问题，但产生了冗余代码，降低了效率。</p> 
<p></p> 
<p><strong>7、对函数的错误返回码要全面处理</strong></p> 
<p></p> 
<p>一个函数（标准库中的函数/第三方库函数/用户定义的函数）能够提供一些指示错误发生的方法。这可以通过使用错误标记、特殊的返回数据或者其他手段，不管什么时候函数提供了这样的机制，调用程序应该在函数返回时立刻检查错误指示。</p> 
<p></p> 
<p><strong>8、设计高扇入，合理扇出（小于7）的函数</strong></p> 
<p></p> 
<p>扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。</p> 
<p></p> 
<p>扇出过大，表明函数过分复杂，需要控制和协调过多的下级函数；而扇出过小，例如：总是1，表明函数的调用层次可能过多，这样不利于程序阅读和函数结构的分析，并且程序运行时会对系统资源如堆栈空间等造成压力。通常函数比较合理的扇出（调度函数除外）通常是3~5。 </p> 
<p></p> 
<p>扇出太大，一般是由于缺乏中间层次，可适当增加中间层次的函数。扇出太小，可把下级函数进一步分解多个函数，或合并到上级函数中。当然分解或合并函数时，不能改变要实现的功能，也不能违背函数间的独立性。扇入越大，表明使用此函数的上级函数越多，这样的函数使用效率高，但不能违背函数间的独立性而单纯地追求高扇入。公共模块中的函数及底层函数应该有较高的扇入。</p> 
<p></p> 
<p>较良好的软件结构通常是顶层函数的扇出较高，中层函数的扇出较少，而底层函数则扇入到公共模块中。</p> 
<p></p> 
<p><strong>9、废弃代码（没有被调用的函数和变量) ) 要及时清除</strong></p> 
<p></p> 
<p>程序中的废弃代码不仅占用额外的空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦。</p> 
<p></p> 
<p><strong>10、函数不变参数使用const </strong></p> 
<p></p> 
<p>不变的值更易于理解/跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。</p> 
<p></p> 
<p>正确示例：C99标准 7.21.4.4 中strncmp 的例子，不变参数声明为const。</p> 
<pre><code class="hljs">int strncmp(const char *s1, const char *s2, register size_t n)

{

    register unsigned char u1, u2;

    while (n-- &gt; 0)

    {

        u1 = (unsigned char) *s1++;

        u2 = (unsigned char) *s2++;

        if (u1 != u2)

        {

            return u1 - u2;

        }

        if (u1 == '')

        {

            return 0;

        }

    }

    return 0;

}</code></pre> 
<p><strong>11、函数应避免使用全局变量、静态局部变量和 I/O 操作，不可避免的地方应集中使用</strong></p> 
<p></p> 
<p>带有内部“存储器”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器（如某标记）的状态。这样的函数既不易于理解又不利于测试和维护。在C语言中，函数的static局部变量是函数的内部存储器，有可能使函数的功能不可预测。</p> 
<p>关注公众号：C语言中文社区，免费领取 300G编程资料。</p> 
<p></p> 
<p>错误示例：如下函数，其返回值（即功能）是不可预测的。</p> 
<pre><code class="hljs">unsigned int integer_sum( unsigned int base )

{

    unsigned int index;

    static unsigned int sum = 0;// 注意，是static类型的。

    // 若改为auto类型，则函数即变为可预测。

    for (index = 1; index &lt;= base; index++)

    {

        sum += index;

    }

    return sum;

}</code></pre> 
<p><strong>12、检查函数所有非参数输入的有效性，如数据文件、公共变量等</strong></p> 
<p></p> 
<p>函数的输入主要有两种：一种是参数输入；另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入参数之前，应进行有效性检查。</p> 
<p></p> 
<p><strong>13、 函数的参数个数不超过5个</strong></p> 
<p></p> 
<p>函数的参数过多，会使得该函数易于受外部（其他部分的代码）变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。</p> 
<p></p> 
<p>函数的参数个数不要超过5个，如果超过了建议拆分为不同函数。</p> 
<p></p> 
<p><strong>14、除打印类函数外，不要使用可变长参函数</strong>。</p> 
<p></p> 
<p>可变长参函数的处理过程比较复杂容易引入错误，而且性能也比较低，使用过多的可变长参函数将导致函数的维护难度大大增加。</p> 
<p></p> 
<p><strong>15、在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字</strong></p> 
<p></p> 
<p>如果一个函数只是在同一文件中的其他地方调用，那么就用static声明。使用static确保只是在声明它的文件中是可见的，并且避免了和其他文件或库中的相同标识符发生混淆的可能性。</p> 
<p></p> 
<p>正确示例：建议定义一个STATIC宏，在调试阶段，将STATIC定义为static，版本发布时，改为空，以便于后续的打热补丁等操作。</p> 
<pre><code class="hljs">#ifdef _DEBUG

#define STATIC static

#else

#define STATIC

#endif</code></pre> 
<p><strong>4、标识符命名与定义</strong></p> 
<p>标识符的命名规则历来是一个敏感话题，典型的命名风格如unix风格、windows风格等，从来无法达成共识。实际上，各种风格都有其优势也有其劣势，而且往往和个人的审美观有关。我们对标识符定义主要是为了让团队的代码看起来尽可能统一，有利于代码的后续阅读和修改，产品可以根据自己的实际需要指定命名风格，规范中不再做统一的规定。</p> 
<p></p> 
<p><strong>1、标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解</strong></p> 
<p></p> 
<p>尽可能给出描述性名称，不要节约空间，让别人很快理解你的代码更重要。</p> 
<p></p> 
<p>正确示例：</p> 
<pre><code class="hljs">int error_number;

int number_of_completed_connection;

错误示例：



int n;

int nerr;

int n_comp_conns;</code></pre> 
<p><strong>2、除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音</strong></p> 
<p></p> 
<p>较短的单词可通过去掉“元音”形成缩写，较长的单词可取单词的头几个字母形成缩写，一些单词有大家公认的缩写，常用单词的缩写必须统一。协议中的单词的缩写与协议保持一致。对于某个系统使用的专用缩写应该在注视或者某处做统一说明。</p> 
<p></p> 
<p>正确示例：一些常见可以缩写的例子：</p> 
<p></p> 
<blockquote> 
 <p>argument 可缩写为 arg</p> 
 <p>buffer 可缩写为 buff</p> 
 <p>clock 可缩写为 clk</p> 
 <p>command 可缩写为 cmd</p> 
 <p>compare 可缩写为 cmp</p> 
 <p>configuration 可缩写为 cfg</p> 
 <p>device 可缩写为 dev</p> 
 <p>error 可缩写为 err</p> 
 <p>hexadecimal 可缩写为 hex</p> 
 <p>increment 可缩写为 inc</p> 
 <p>initialize 可缩写为 init</p> 
 <p>maximum 可缩写为 max</p> 
 <p>message 可缩写为 msg</p> 
 <p>minimum 可缩写为 min</p> 
 <p>parameter 可缩写为 para</p> 
 <p>previous 可缩写为 prev</p> 
 <p>register 可缩写为 reg</p> 
 <p>semaphore 可缩写为 sem</p> 
 <p>statistic 可缩写为 stat</p> 
 <p>synchronize 可缩写为 sync</p> 
 <p>temp 可缩写为 tmp</p> 
</blockquote> 
<p><strong>3、产品/项目组内部应保持统一的命名风格</strong></p> 
<p></p> 
<p>Unix like和windows like风格均有其拥趸，产品应根据自己的部署平台，选择其中一种，并在产品内部保持一致。</p> 
<p></p> 
<p><strong>4、用正确的反义词组命名具有互斥意义的变量或相反动作的函数等</strong></p> 
<p></p> 
<p>正确示例：</p> 
<p></p> 
<blockquote> 
 <p>add/remove begin/end create/destroy</p> 
 <p>insert/delete first/last get/release</p> 
 <p>increment/decrement put/get add/delete</p> 
 <p>lock/unlock open/close min/max</p> 
 <p>old/new start/stop  next/previous</p> 
 <p>source/target show/hide  send/receive</p> 
 <p>source/destination copy/paste up/down</p> 
</blockquote> 
<p><strong>5、尽量避免名字中出现数字编号，除非逻辑上的确需要编号</strong></p> 
<p></p> 
<p>错误示例：如下命名，使人产生疑惑。</p> 
<pre><code class="hljs">#define EXAMPLE_0_TEST_

#define EXAMPLE_1_TEST_</code></pre> 
<p>正确示例：应改为有意义的单词命名。</p> 
<pre><code class="hljs">
#define EXAMPLE_UNIT_TEST_

#define EXAMPLE_ASSERT_TEST_</code></pre> 
<p><strong>6、标识符前不应添加模块、项目、产品、部门的名称作为前缀</strong></p> 
<p></p> 
<p>很多已有代码中已经习惯在文件名中增加模块名，这种写法类似匈牙利命名法，导致文件名不可读，并且带来带来如下问题：</p> 
<p></p> 
<p>第一眼看到的是模块名，而不是真正的文件功能，阻碍阅读；</p> 
<p>文件名太长；</p> 
<p>文件名和模块绑定，不利于维护和移植。若foo.c进行重构后，从a模块挪到b模块，若foo.c</p> 
<p>中有模块名，则需要将文件名从a_module_foo.c改为b_module_foo.c。</p> 
<p><strong>7、平台/ / 驱动等适配代码的标识符命名风格保持和平台</strong></p> 
<p></p> 
<p>涉及到外购芯片以及配套的驱动，这部分的代码变动（包括为产品做适配的新增代码），应该保持原有的风格。</p> 
<p></p> 
<p><strong>8、重构/修改部分代码时，应保持和原有代码的命名风格一致</strong></p> 
<p></p> 
<p>根据源代码现有的风格继续编写代码，有利于保持总体一致。</p> 
<p></p> 
<p><strong>9、文件命名统一采用小写字符</strong></p> 
<p></p> 
<p>因为不同系统对文件名大小写处理会不同（如MS的DOS、Windows系统不区分大小写，但是Linux系统则区分），所以代码文件命名建议统一采用全小写字母命名。</p> 
<p></p> 
<p><strong>10、全局变量应增加“g_” 前缀，静态变量应增加“s_”</strong></p> 
<p></p> 
<p>首先，全局变量十分危险，通过前缀使得全局变量更加醒目，促使开发人员对这些变量的使用更加小心。</p> 
<p></p> 
<p>其次，从根本上说，应当尽量不使用全局变量，增加g_和s_前缀，会使得全局变量的名字显得很丑陋，从而促使开发人员尽量少使用全局变量。</p> 
<p></p> 
<p><strong>11、禁止使用单字节命名变量，但 允许 定义i 、j、k作为局部循环变量</strong></p> 
<p></p> 
<p><strong>12、 不建议使用匈牙利命名法</strong></p> 
<p></p> 
<p>匈牙利命名法是一种编程时的命名规范。基本原则是：变量名=属性+类型+对象描述。匈牙利命名法源于微软，然而却被很多人以讹传讹的使用。而现在即使是微软也不再推荐使用匈牙利命名法。历来对匈牙利命名法的一大诟病，就是导致了变量名难以阅读，这和本规范的指导思想也有冲突，所以本规范特意强调，变量命名不应采用匈牙利命名法，而应该想法使变量名为一个有意义的词或词组，方便代码的阅读。</p> 
<p></p> 
<p>变量命名需要说明的是变量的含义，而不是变量的类型。在变量命名前增加类型说明，反而降低了变量的可读性；更麻烦的问题是，如果修改了变量的类型定义，那么所有使用该变量的地方都需要修改。</p> 
<p></p> 
<p><strong>13、使用名词或者形容词＋名词方式命名变量 </strong></p> 
<p></p> 
<p><strong>14、函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构</strong></p> 
<p></p> 
<p>正确示例：找到当前进程的当前目录：</p> 
<p></p> 
<blockquote> 
 <p>DWORD GetCurrentDirectory( DWORD BufferLength, LPTSTR Buffer );</p> 
</blockquote> 
<p><strong>15、函数指针除了前缀，其他按照函数的命名规则命名</strong></p> 
<p></p> 
<p><strong>16、对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线“_”的方式命名（枚举同样建议使用此方式定义）</strong></p> 
<p></p> 
<p>正确示例：</p> 
<p></p> 
<pre><code class="hljs">#define PI_ROUNDED 3.14</code></pre> 
<p><strong>17、除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线“_”开头和结尾</strong></p> 
<p></p> 
<p>一般来说，‟_‟开头、结尾的宏都是一些内部的定义，ISO/IEC 9899（俗称C99）中有如下的描述（6.10.8 Predefined macro names）:</p> 
<p></p> 
<blockquote> 
 <p>None of these macro names (这里上面是一些内部定义的宏的描述)，nor the identifier defined,shall be the subject of a #define or a #undef preprocessing directive.Any other predefined macro names shall begin with a leading underscore fol lowedby an uppercase letter ora second underscore.</p> 
</blockquote> 
<p></p> 
<p><strong>5、变量</strong></p> 
<p><strong>1、一个变量只有一个功能，不能把一个变量用作多种用途</strong></p> 
<p></p> 
<p>一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。</p> 
<p></p> 
<p>错误示例：具有两种功能的反例</p> 
<pre><code class="hljs">WORD DelRelTimeQue( void )

{

    WORD Locate;

    Locate = 3; 

    Locate = DeleteFromQue(Locate); /* Locate具有两种功能：位置和函数DeleteFromQue的返回值 */

    return Locate;

}

正确做法：使用两个变量



WORD DelRelTimeQue( void )

{

    WORD Ret;

    WORD Locate;

    Locate = 3;

    Ret  = DeleteFromQue(Locate);

    return Ret;

}</code></pre> 
<p><strong>2、结构功能单一，不要设计面面俱到的数据结构 </strong></p> 
<p></p> 
<p>相关的一组信息才是构成一个结构体的基础，结构的定义应该可以明确的描述一个对象，而不是一组相关性不强的数据的集合。设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构中。</p> 
<p></p> 
<p>错误示例：如下结构不太清晰、合理。</p> 
<pre><code class="hljs">typedef struct STUDENT_STRU

{

    unsigned char name[32]; /* student's name */

    unsigned char age; /* student's age */

    unsigned char sex; /* student's sex, as follows */

    /* 0 - FEMALE; 1 - MALE */

    unsigned char teacher_name[32]; /* the student teacher's name */

    unsigned char teacher_sex; /* his teacher sex */

} STUDENT;</code></pre> 
<p>正确示例：若改为如下，会更合理些。</p> 
<pre><code class="hljs">typedef struct TEACHER_STRU

{

    unsigned char name[32]; /* teacher name */

    unsigned char sex; /* teacher sex, as follows */

    /* 0 - FEMALE; 1 - MALE */

    unsigned int teacher_ind; /* teacher index */

} TEACHER;



typedef struct STUDENT_STRU

{

    unsigned char name[32]; /* student's name */

    unsigned char age; /* student's age */

    unsigned char sex; /* student's sex, as follows */

    /* 0 - FEMALE; 1 - MALE */

    unsigned int teacher_ind; /* his teacher index */

} STUDENT; </code></pre> 
<p><strong>3、不用或者少用全局变量</strong></p> 
<p></p> 
<p>单个文件内部可以使用static的全局变量，可以将其理解为类的私有成员变量。</p> 
<p></p> 
<p>全局变量应该是模块的私有数据，不能作用对外的接口使用，使用static类型定义，可以有效防止外部文件的非正常访问，建议定义一个STATIC宏，在调试阶段，将STATIC定义为static，版本发布时，改为空，以便于后续的打补丁等操作。</p> 
<p></p> 
<p><strong>4、防止局部变量与全局变量同名</strong></p> 
<p></p> 
<p>尽管局部变量和全局变量的作用域不同而不会发生语法错误，但容易使人误解。</p> 
<p></p> 
<p><strong>5、通讯过程中使用的结构，必须注意字节序</strong></p> 
<p></p> 
<p>通讯报文中，字节序是一个重要的问题，我司设备使用的CPU类型复杂多样，大小端、32位/64位的处理器也都有，如果结构会在报文交互过程中使用，必须考虑字节序问题。由于位域在不同字节序下，表现看起来差别更大，所以更需要注意对于这种跨平台的交互，数据成员发送前，都应该进行主机序到网络序的转换；接收时，也必须进行网络序到主机序的转换。</p> 
<p></p> 
<p><strong>6、严禁使用未经初始化的变量作为右值 </strong></p> 
<p></p> 
<p>在首次使用前初始化变量，初始化的地方离使用的地方越近越好。</p> 
<p></p> 
<p><strong>7、构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象</strong></p> 
<p></p> 
<p>降低全局变量耦合度。</p> 
<p></p> 
<p><strong>8、使用面向接口编程思想，通过 API 访问数据：如果本模块的数据需要对外部模块开放 ，应提供接口函数来设置、获取，同时注意全局数据的访问互斥</strong></p> 
<p></p> 
<p>避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法。定义的接口应该有比较明确的意义，比如一个风扇管理功能模块，有自动和手动工作模式，那么设置、查询工作模块就可以定义接口为SetFanWorkMode，GetFanWorkMode；查询转速就可以定义为GetFanSpeed；风扇支持节能功能开关，可以定义EnabletFanSavePower等。</p> 
<p></p> 
<p><strong>9、明确全局变量的初始化顺序，避免跨模块的初始化依赖 </strong></p> 
<p></p> 
<p>系统启动阶段，使用全局变量前，要考虑到该全局变量在什么时候初始化，使用全局变量和初始化全局变量，两者之间的时序关系，谁先谁后，一定要分析清楚，不然后果往往是低级而又灾难性的。</p> 
<p></p> 
<p><strong>10、尽量减少没有必要的数据类型默认转换与强制转换</strong></p> 
<p></p> 
<p>当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。</p> 
<p></p> 
<p>错误示例：如下赋值，多数编译器不产生告警，但值的含义还是稍有变化。</p> 
<pre><code class="hljs">char ch;

unsigned short int exam;

ch = -1;

exam = ch; // 编译器不产生告警，此时exam为0xFFFF。</code></pre> 
<p><strong>6、宏、常量</strong></p> 
<p><strong>1、用宏定义表达式时，要使用完备的括号 </strong></p> 
<p></p> 
<p>因为宏只是简单的代码替换，不会像函数一样先将参数计算后，再传递。</p> 
<p></p> 
<p>错误示例：如下定义的宏都存在一定的风险</p> 
<pre><code class="hljs">#define RECTANGLE_AREA(a, b) a * b

#define RECTANGLE_AREA(a, b) (a * b)

#define RECTANGLE_AREA(a, b) (a) * (b)</code></pre> 
<p>正确示例：</p> 
<p></p> 
<pre><code class="hljs">#define RECTANGLE_AREA(a, b) ((a) * (b))</code></pre> 
<p>这是因为：如果定义 #define RECTANGLE_AREA(a, b) a * b  或 #define RECTANGLE_AREA(a, b) (a * b)则 c/RECTANGLE_AREA(a, b)  将扩展成 c/a * b , c  与 b 本应该是除法运算，结果变成了乘法运算，造成错误。</p> 
<p></p> 
<p>如果定义 #define RECTANGLE_AREA(a, b) (a * b)则 RECTANGLE_AREA(c + d, e + f) 将扩展成：(c + d * e + f), d 与 e 先运算，造成错误。 </p> 
<p></p> 
<p><strong>2、将宏所定义的多条表达式放在大括号中</strong></p> 
<p></p> 
<p><strong>3、使用宏时，不允许参数发生变化</strong></p> 
<p></p> 
<p>错误示例：</p> 
<pre><code class="hljs">#define SQUARE(a) ((a) * (a))

int a = 5;

int b;

b = SQUARE(a++); // 结果：a = 7，即执行了两次增加操作。</code></pre> 
<p>正确示例：</p> 
<pre><code class="hljs">b = SQUARE(a);

a++; // 结果：a = 6，即只执行了一次增。</code></pre> 
<p>同时也建议即使函数调用，也不要在参数中做变量变化操作，因为可能引用的接口函数，在某个版本升级后，变成了一个兼容老版本所做的一个宏，结果可能不可预知。</p> 
<p></p> 
<p><strong>4、不允许直接使用魔鬼数字 </strong></p> 
<p></p> 
<p>使用魔鬼数字的弊端：代码难以理解；如果一个有含义的数字多处使用，一旦需要修改这个数值，代价惨重。</p> 
<p></p> 
<p>使用明确的物理状态或物理意义的名称能增加信息，并能提供单一的维护点。</p> 
<p></p> 
<p>解决途径：对于局部使用的唯一含义的魔鬼数字，可以在代码周围增加说明注释，也可以定义局部const变量，变量命名自注释。对于广泛使用的数字，必须定义const全局变量/宏；同样变量/宏命名应是自注释的。0作为一个特殊的数字，作为一般默认值使用没有歧义时，不用特别定义。</p> 
<p></p> 
<p><strong>5、除非必要，应尽可能使用函数代替宏</strong></p> 
<p></p> 
<p>宏对比函数，有一些明显的缺点：</p> 
<p></p> 
<p>宏缺乏类型检查，不如函数调用检查严格；</p> 
<p>宏展开可能会产生意想不到的副作用，如#define SQUARE(a) (a) * (a)这样的定义，如果是SQUARE(i++)，就会导致i被加两次；如果是函数调用double square(double a) {return a * a;}则不会有此副作用；</p> 
<p>以宏形式写的代码难以调试难以打断点，不利于定位问题；</p> 
<p>宏如果调用的很多，会造成代码空间的浪费，不如函数空间效率高。</p> 
<p>错误示例：下面的代码无法得到想要的结果：</p> 
<pre><code class="hljs">#define MAX_MACRO(a, b) ((a) &gt; (b) ? (a) : (b))



int MAX_FUNC(int a, int b) {

    return ((a) &gt; (b) ? (a) : (b));

}



int testFunc()

{

    unsigned int a = 1;

    int b = -1;

    printf("MACRO: max of a and b is: %dn", MAX_MACRO(++a, b));

    printf("FUNC : max of a and b is: %dn", MAX_FUNC(a, b));

    return 0;

}</code></pre> 
<p>上面宏代码调用中，由于宏缺乏类型检查，a和b的比较变成无符号数的比较，结果是a &lt; b，所以a只加了一次，所以最终的输出结果是：</p> 
<p></p> 
<blockquote> 
 <p>MACRO: max of a and b is: -1</p> 
 <p>FUNC : max of a and b is: 2</p> 
</blockquote> 
<p><strong>6、常量建议使用 const 定义代替宏</strong></p> 
<p></p> 
<p>“尽量用编译器而不用预处理”，因为#define经常被认为好象不是语言本身的一部分。看下面的语句：</p> 
<p></p> 
<pre><code class="hljs">#define ASPECT_RATIO 1.653</code></pre> 
<p>编译器会永远也看不到ASPECT_RATIO这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是ASPECT_RATIO不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是ASPECT_RATIO。如果ASPECT_RATIO不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。</p> 
<p>解决这个问题的方案很简单：不用预处理宏，定义一个常量：</p> 
<p></p> 
<blockquote> 
 <p>const double ASPECT_RATIO = 1.653;</p> 
</blockquote> 
<p>这种方法很有效，但有两个特殊情况要注意。首先，定义指针常量时会有点不同。因为常量定义一般是放在头文件中（许多源文件会包含它），除了指针所指的类型要定义成const外，重要的是指针也经常要定义成const。例如，要在头文件中定义一个基于char*的字符串常量，你要写两次const：</p> 
<p></p> 
<blockquote> 
 <p>const char * const authorName = "Scott Meyers";</p> 
</blockquote> 
<p>延伸阅读材料：关于const和指针的使用，这里摘录两段ISO/IEC 9899（俗称C99）的描述： </p> 
<p></p> 
<p><strong>7、宏定义中尽量不使用 return 、 goto 、 continue 、 break等改变程序流程的语句</strong></p> 
<p></p> 
<p>如果在宏定义中使用这些改变流程的语句，很容易引起资源泄漏问题，使用者很难自己察觉。</p> 
<p></p> 
<p>错误示例：在某头文件中定义宏CHECK_AND_RETURN：</p> 
<p></p> 
<blockquote> 
 <p>#define CHECK_AND_RETURN(cond, ret) {if (cond == NULL_PTR) {return ret;}}</p> 
 <p>//然后在某函数中使用(只说明问题，代码并不完整):</p> 
 <p>pMem1 = VOS_MemAlloc(...);</p> 
 <p>CHECK_AND_RETURN(pMem1 , ERR_CODE_XXX)</p> 
 <p>pMem2 = VOS_MemAlloc(...);</p> 
 <p>CHECK_AND_RETURN(pMem2 , ERR_CODE_XXX) /*此时如果pMem2==NULL_PTR，则pMem1未释放函数就返回了，造成内存泄漏。*/</p> 
</blockquote> 
<p>所以说，类似于CHECK_AND_RETURN这些宏，虽然能使代码简洁，但是隐患很大，使用须谨慎。 </p> 
<p></p> 
<p><strong>7、表达式</strong></p> 
<p><strong>1、表达式的值在标准所允许的任何运算次序下都应该是相同的</strong></p> 
<p></p> 
<p><strong>2、函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利</strong></p> 
<p></p> 
<p>错误示例：如下代码不合理，仅用于说明当函数作为参数时，由于参数压栈次数不是代码可以控制的，可能造成未知的输出：</p> 
<pre><code class="hljs">int g_var;



int fun1()

{

    g_var += 10;

    return g_var;

}



int fun2()

{

    g_var += 100;

    return g_var;

}



int main(int argc, char *argv[], char *envp[])

{

    g_var = 1;

    printf("func1: %d, func2: %dn", fun1(), fun2());

    g_var = 1;

    printf("func2: %d, func1: %dn", fun2(), fun1());

}</code></pre> 
<p>上面的代码，使用断点调试起来也比较麻烦，阅读起来也不舒服，所以不要为了节约代码行，而写这种代码。</p> 
<p></p> 
<p><strong>3、赋值语句不要写在 if 等语句中，或者作为函数的参数使用</strong></p> 
<p></p> 
<p>因为if语句中，会根据条件依次判断，如果前一个条件已经可以判定整个条件，则后续条件语句不会再运行，所以可能导致期望的部分赋值没有得到运行。</p> 
<p></p> 
<p>错误示例：</p> 
<pre><code class="hljs">int main(int argc, char *argv[], char *envp[])

{

    int a = 0;

    int b;

    if ((a == 0) || ((b = fun1()) &gt; 10))

    {

        printf("a: %dn", a);

    }

    printf("b: %dn", b);

}</code></pre> 
<p>作用函数参数来使用，参数的压栈顺序不同可能导致结果未知。</p> 
<p></p> 
<p><strong>4、用括号明确表达式的操作顺序，避免过分依赖默认优先级</strong></p> 
<p></p> 
<p>使用括号强调所使用的操作符，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。</p> 
<p></p> 
<p><strong>5、赋值操作符不能使用在产生布尔值的表达式上 </strong></p> 
<p></p> 
<p>示例：</p> 
<pre><code class="hljs">x = y;

if (x != 0)

{

    foo ();

}</code></pre> 
<p>不能写成：</p> 
<pre><code class="hljs">if (( x = y ) != 0)

{

    foo ();

}</code></pre> 
<p>或者更坏的：</p> 
<pre><code class="hljs">if (x = y)

{

    foo ();

}</code></pre> 
<p><strong>8、注释</strong></p> 
<p><strong> 1、优秀的代码可 以自我解释，不通过注释即可轻易读懂</strong></p> 
<p></p> 
<p>优秀的代码不写注释也可轻易读懂，注释无法把糟糕的代码变好，需要很多注释来解释的代码往往存在坏味道，需要重构。</p> 
<p></p> 
<p>错误示例：注释不能消除代码的坏味道：</p> 
<pre><code class="hljs">/* 判断m是否为素数*/

/* 返回值：: 是素数，: 不是素数*/

int p(int m)

{

    int k = sqrt(m);

    for (int i = 2; i &lt;= k; i++)

        if (m % i == 0)

            break; /* 发现整除，表示m不为素数，结束遍历*/

    /* 遍历中没有发现整除的情况，返回*/

    if (i &gt; k)

        return 1;

    /* 遍历中没有发现整除的情况，返回*/

    else

        return 0;

}</code></pre> 
<p>重构代码后，不需要注释：</p> 
<pre><code class="hljs">int IsPrimeNumber(int num)

{

    int sqrt_of_num = sqrt (num);

    for (int i = 2; i &lt;= sqrt_of_num; i++)

    {

        if (num % i == 0)

        {

            return FALSE;

        }

    }

    return TRUE;

}</code></pre> 
<p><strong>2、注释的内容要清楚、明了，含义准确，防止注释二义性</strong></p> 
<p></p> 
<p>有歧义的注释反而会导致维护者更难看懂代码，正如带两块表反而不知道准确时间。</p> 
<p></p> 
<p><strong>3、在代码的功能、意图层次上进行注释，即注释解释 代码难以直接表达的意图 ， 而不是重复描述代码</strong></p> 
<p></p> 
<p>注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释。注释不是为了名词解释（what），而是说明用途（why）。</p> 
<p></p> 
<p><strong>4、修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性，不再有用的注释要删除</strong></p> 
<p></p> 
<p>不要将无用的代码留在注释中，随时可以从源代码配置库中找回代码；即使只是想暂时排除代码，也要留个标注，不然可能会忘记处理它。</p> 
<p></p> 
<p><strong>5、文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明</strong></p> 
<p></p> 
<p>正确示例：下面这段头文件的头注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。</p> 
<p></p> 
<p><strong>6、函数声明处注释描述函数功能、性能及用法，包括输入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、 设计约束等</strong></p> 
<p></p> 
<p>重要的、复杂的函数，提供外部使用的接口函数应编写详细的注释。</p> 
<p></p> 
<p><strong>7、全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明</strong></p> 
<p></p> 
<p>正确示例：</p> 
<pre><code class="hljs">/* The ErrorCode when SCCP translate */

/* Global Title failure, as follows */ /* 变量作用、含义*/

/* 0 －SUCCESS 1 －GT Table error */

/* 2 －GT error Others －no use */ /* 变量取值范围*/

/* only function SCCPTranslate() in */

/* this modual can modify it, and other */

/* module can visit it through call */

/* the function GetGTTransErrorCode() */ /* 使用方法*/

BYTE g_GTTranErrorCode;</code></pre> 
<p><strong>8、注释应放在其代码上方相邻位置或右方，不可放在下面，如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同</strong></p> 
<p></p> 
<p>正确示例：</p> 
<pre><code class="hljs">/* active statistic task number */

#define MAX_ACT_TASK_NUMBER 1000

#define MAX_ACT_TASK_NUMBER 1000 /* active statistic task number */

可按如下形式说明枚举/数据/联合结构。

/* sccp interface with sccp user primitive message name */

enum SCCP_USER_PRIMITIVE

{

    N_UNITDATA_IND, /* sccp notify sccp user unit data come */

    N_NOTICE_IND, /* sccp notify user the No.7 network can not transmission this message */

    N_UNITDATA_REQ, /* sccp user's unit data transmission request*/

};</code></pre> 
<p><strong>9、对于 switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释</strong></p> 
<p></p> 
<p>这样比较清楚程序编写者的意图，有效防止无故遗漏break语句。</p> 
<pre><code class="hljs">case CMD_FWD:

    ProcessFwd();

    /* now jump into c ase CMD_A */

case CMD_A:

    ProcessA();

    break;

//对于中间无处理的连续case，已能较清晰说明意图，不强制注释。

switch (cmd_flag)

    {

        case CMD_A:

        case CMD_B:

    {

        ProcessCMD();

        break;

    }

    ……

}</code></pre> 
<p><strong>10、避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写</strong></p> 
<p></p> 
<p><strong>11、同一产品或项目组统一注释风格</strong></p> 
<p></p> 
<p><strong>12、避免在一行代码或表达式的中间插入注释</strong></p> 
<p></p> 
<p>除非必要，不应在代码或表达中间插入注释，否则容易使代码可理解性变差</p> 
<p></p> 
<p><strong>13、注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达，对于有外籍员工的，由产品确定注释语言</strong></p> 
<p></p> 
<p>注释语言不统一，影响程序易读性和外观排版，出于对维护人员的考虑，建议使用中文。</p> 
<p></p> 
<p><strong>14、文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式</strong></p> 
<p></p> 
<p>采用工具可识别的注释格式，例如doxygen格式，方便工具导出注释形成帮助文档。以doxygen格式为例，文件头，函数和全部变量的注释的示例如下：</p> 
<p></p> 
<p><strong>9、排版与格式</strong></p> 
<p><strong>1、程序块采用缩进风格编写， 每级缩进为4个空格</strong></p> 
<p></p> 
<p><strong>2、相对独立的程序块之间、变量说明之后必须加空行 </strong></p> 
<p></p> 
<p>错误示例：如下例子不符合规范。</p> 
<pre><code class="hljs">if (!valid_ni(ni))

{

    // program code

    ...

}

repssn_ind = ssn_data[index].repssn_index;

repssn_ni = ssn_data[index].ni;</code></pre> 
<p>正确示例：</p> 
<pre><code class="hljs">if (!valid_ni(ni))

{

    // program code

    ...

}



repssn_ind = ssn_data[index].repssn_index;

repssn_ni = ssn_data[index].ni;</code></pre> 
<p><strong>3、一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定</strong></p> 
<p></p> 
<p>对于目前大多数的PC来说，132比较合适（80/132是VTY常见的行宽值）；对于新PC宽屏显示器较多的产品来说，可以设置更大的值。换行时有如下建议：</p> 
<p></p> 
<p>换行时要增加一级缩进，使代码可读性更好；</p> 
<p>低优先级操作符处划分新行；换行时操作符应该也放下来，放在新行首；</p> 
<p>换行时建议一个完整的语句放在一行，不要根据字符数断行。</p> 
<p>正确示例：</p> 
<pre><code class="hljs">if ((temp_flag_var == TEST_FLAG)

&amp;&amp;(((temp_counter_var - TEST_COUNT_BEGIN) % TEST_COUNT_MODULE) &gt;= TEST_COUNT_THRESHOLD))

{

    // process code

}</code></pre> 
<p><strong>4、多个短语句（包括赋值语句）不允许写在同一行内 ，即一行只写一条语句</strong></p> 
<p></p> 
<p>错误示例：</p> 
<p></p> 
<pre><code class="hljs">int a = 5; int b= 10; //不好的排版</code></pre> 
<p>正确示例：</p> 
<pre><code class="hljs">int a = 5;

int b= 10;</code></pre> 
<p>5、if 、 for 、 do 、 while 、 case 、 switch 、 default 等语句独占一行</p> 
<p></p> 
<p>执行语句必须用缩进风格写，属于if、for、do、while、case、switch、default等下一个缩进级别；</p> 
<p></p> 
<p>一般写if、for、do、while等语句都会有成对出现的„{}‟，对此有如下建议可以参考：if、for、do、while等语句后的执行语句建议增加成对的“{}”；如果if/else配套语句中有一个分支有“{}”，那么另一个分支即使一行代码也建议增加“{}”；添加“{”的位置可以在if等语句后，也可以独立占下一行；独立占下一行时，可以和if在一个缩进级别，也可以在下一个缩进级别；但是如果if语句很长，或者已经有换行，建议“{”使用独占一行的写法。</p> 
<p></p> 
<p><strong>6、在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格 ；进行非对等操作时，如果是关系密切的立即操作符（如－&gt; &gt; ），后不应加空格</strong></p> 
<p></p> 
<p>采用这种松散方式编写代码的目的是使代码更加清晰。</p> 
<p></p> 
<p>在已经非常清晰的语句中没有必要再留空格，如括号内侧(即左括号后面和右括号前面)不需要加空格，多重括号间不必加空格，因为在C语言中括号已经是最清晰的标志了。在长语句中，如果需要加的空格非常多，那么应该保持整体清晰，而在局部不加空格。给操作符留空格时不要连续留两个以上空格。</p> 
<p></p> 
<p>正确示例：</p> 
<p></p> 
<p><strong>1、逗号、分号只在后面加空格。</strong></p> 
<p></p> 
<pre><code class="hljs">int a, b, c;</code></pre> 
<p><strong>2、比较操作符, 赋值操作符"="、 "+="，算术操作符"+"、"%"，逻辑操作符"&amp;&amp;"、"&amp;"，位域操作符"&lt;&lt;"、"^"等双目操作符的前后加空格。 </strong></p> 
<pre><code class="hljs">if (current_time &gt;= MAX_TIME_VALUE)

a = b + c;

a *= 2;

a = b ^ 2;</code></pre> 
<p><strong>3、"!"、"~"、"++"、"--"、"&amp;"（地址操作符）等单目操作符前后不加空格。</strong></p> 
<pre><code class="hljs">*p = 'a'; // 内容操作"*"与内容之间

flag = !is_empty; // 非操作"!"与内容之间

p = &amp;mem; // 地址操作"&amp;" 与内容之间

i++; </code></pre> 
<p><strong> 4、"-&gt;"、"."前后不加空格。</strong></p> 
<p></p> 
<pre><code class="hljs">p-&gt;id = pid; // "-&gt;"指针前后不加空格</code></pre> 
<p><strong>5、if、for、while、switch等与后面的括号间应加空格，使if等关键字更为突出、明显。</strong></p> 
<p></p> 
<pre><code class="hljs">if (a &gt;= b &amp;&amp; c &gt; d)</code></pre> 
<p><strong>7、注释符（包括/**/、//）与注释内容之间要用一个空格进行分隔</strong></p> 
<p></p> 
<p><strong>8、源程序中关系较为紧密的代码应尽可能相邻</strong></p> 
<p></p> 
<p><strong>10、代码编辑编译 </strong></p> 
<p><strong>1、使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警</strong></p> 
<p></p> 
<p>编译器是你的朋友，如果它发出某个告警，这经常说明你的代码中存在潜在的问题。</p> 
<p></p> 
<p><strong>2、在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略</strong></p> 
<p></p> 
<p>如果必须禁用某个告警，应尽可能单独局部禁用，并且编写一个清晰的注释，说明为什么屏蔽。某些语句经编译/静态检查产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。</p> 
<p></p> 
<p><strong>4、本地构建工具（如 PC-Lint）的配置应该和持续集成的一致</strong></p> 
<p></p> 
<p>两者一致，避免经过本地构建的代码在持续集成上构建失败</p> 
<p></p> 
<p><strong>5、 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会影响构建成功</strong></p> 
<p></p> 
<p>及时签入代码降低集成难度。</p> 
<p></p> 
<p><strong>6、要小心地使用编辑器提供的块拷贝功能编程</strong></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>