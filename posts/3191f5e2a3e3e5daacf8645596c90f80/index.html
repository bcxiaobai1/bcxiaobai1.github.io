<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C&#43;&#43; 提高编程 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 提高编程</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#C__1">C++ 提高编程</a></li>
<li>
<ul>
<li><a href="#__5">一、 模板</a></li>
<li>
<ul>
<li><a href="#1__7">1、 概念</a></li>
<li><a href="#2__16">2、 函数模板</a></li>
<li>
<ul>
<li><a href="#21__21">2.1 函数模板语法</a></li>
<li><a href="#22__88">2.2 注意事项</a></li>
<li><a href="#23__95">2.3 普通函数和函数模板的区别</a></li>
<li><a href="#24__101">2.4 普通函数和函数模板的调用规则</a></li>
<li><a href="#25__157">2.5 模板的局限性</a></li>
</ul>
    </li>
<li><a href="#3__214">3、 类模板</a></li>
<li>
<ul>
<li><a href="#31__216">3.1 类模板语法</a></li>
<li><a href="#32__254">3.2 类模板和函数模板的区别</a></li>
<li><a href="#33__281">3.3 使用时机</a></li>
<li><a href="#34__318">3.4 类模板对象函数做参数</a></li>
<li><a href="#35__399">3.5 类模板与继承</a></li>
<li><a href="#36__424">3.6 类模板成员函数类外实现</a></li>
<li><a href="#37__453">3.7 类模板文件编写</a></li>
<li><a href="#38__523">3.8 类模板和友元</a></li>
<li><a href="#39__570">3.9 数组类封装</a></li>
</ul>
   </li>
</ul>
   </li>
<li><a href="#_STL__735">二、 STL 初识</a></li>
<li>
<ul>
<li><a href="#1__737">1、 基本概念</a></li>
<li><a href="#2_STL__744">2、 STL 六大组件</a></li>
<li>
<ul><li><a href="#21__755">2.1 容器、算法、迭代器</a></li></ul>
    </li>
<li><a href="#3__797">3、 迭代器初始</a></li>
<li>
<ul>
<li><a href="#31_vector__799">3.1 vector 存放内置数据类型</a></li>
<li><a href="#32_vector__846">3.2 vector 存放自定义数据类型</a></li>
<li><a href="#33_vector__895">3.3 vector 中嵌套容器</a></li>
</ul>
   </li>
</ul>
   </li>
<li><a href="#_STL__937">三、 STL 常用容器</a></li>
<li>
<ul>
<li><a href="#1_string__941">1、 string 容器</a></li>
<li>
<ul>
<li><a href="#11_string__943">1.1 string 基本概念</a></li>
<li><a href="#12_string__960">1.2 string 构造函数</a></li>
<li><a href="#13_string__994">1.3 string 赋值操作</a></li>
<li><a href="#14_string__1012">1.4 string 字符串拼接</a></li>
<li><a href="#15_string__1030">1.5 string 查找和替换</a></li>
<li><a href="#16_string__1058">1.6 string 字符串比较</a></li>
<li><a href="#17_string__1080">1.7 string 字符存取</a></li>
<li><a href="#18_string__1092">1.8 string 插入和删除</a></li>
<li><a href="#19_string__1107">1.9 string 中的子串</a></li>
</ul>
    </li>
<li><a href="#2_vector__1119">2、 vector 容器</a></li>
<li>
<ul>
<li><a href="#21_vector__1121">2.1 vector 基本概念</a></li>
<li><a href="#22_vector__1139">2.2 vector 构造函数</a></li>
<li><a href="#23_vector__1156">2.3 vector 赋值操作</a></li>
<li><a href="#24_vector__1170">2.4 vector 大小操作</a></li>
<li><a href="#25_vector__1213">2.5 vector 插入和删除</a></li>
<li><a href="#26_vector__1233">2.6 vector 数据存取</a></li>
<li><a href="#27_vector__1248">2.7 vector 互换容器</a></li>
<li><a href="#28_vector__1282">2.8 vector 预留空间</a></li>
</ul>
    </li>
<li><a href="#3_deque__1317">3、 deque 容器</a></li>
<li>
<ul>
<li><a href="#31_deque__1319">3.1 deque 基本概念</a></li>
<li><a href="#32_deque__1343">3.2 deque 构造函数</a></li>
<li><a href="#33_deque__1358">3.3 deque 赋值操作</a></li>
<li><a href="#34_deque__1372">3.4 deque 大小操作</a></li>
<li><a href="#35_deque__1389">3.5 deque 插入和删除</a></li>
<li><a href="#36_deque__1415">3.6 deque 数据存取</a></li>
<li><a href="#37_deque__1430">3.7 deque 排序</a></li>
</ul>
    </li>
<li><a href="#4__1448">4、 案例-评委打分</a></li>
<li>
<ul>
<li><a href="#41__1450">4.1 案例描述</a></li>
<li><a href="#42__1454">4.2 实现步骤</a></li>
</ul>
    </li>
<li><a href="#5_stack__1539">5、 stack 容器</a></li>
<li>
<ul>
<li><a href="#51_stack__1541">5.1 stack 基本概念</a></li>
<li><a href="#52_stack__1551">5.2 stack 常用接口</a></li>
<li>
<ul>
<li><a href="#521__1557">5.2.1 构造函数</a></li>
<li><a href="#522__1564">5.2.2 赋值操作</a></li>
<li><a href="#523__1570">5.2.3 大小操作</a></li>
<li><a href="#524__1577">5.2.4 数据存取</a></li>
</ul>
    </li>
</ul>
    </li>
<li><a href="#6_queue__1585">6、 queue 容器</a></li>
<li>
<ul>
<li><a href="#61_queue__1587">6.1 queue 基本概念</a></li>
<li><a href="#62_queue__1603">6.2 queue 常用接口</a></li>
<li>
<ul>
<li><a href="#621__1609">6.2.1 构造函数</a></li>
<li><a href="#622__1616">6.2.2 赋值操作</a></li>
<li><a href="#623__1622">6.2.3 大小操作</a></li>
<li><a href="#624__1629">6.2.4 数据存取</a></li>
</ul>
    </li>
</ul>
    </li>
<li><a href="#7_list__1638">7、 list 容器</a></li>
<li>
<ul>
<li><a href="#71_list__1640">7.1 list 基本概念</a></li>
<li><a href="#72_list__1671">7.2 list 构造函数</a></li>
<li><a href="#73_list__1686">7.3 list 赋值和交换</a></li>
<li><a href="#74_list__1701">7.4 list 大小操作</a></li>
<li><a href="#75_list__1716">7.5 list 插入和删除</a></li>
<li><a href="#76_list__1738">7.6 list 数据存取</a></li>
<li><a href="#77_list__1757">7.7 list 反转和排序</a></li>
</ul>
    </li>
<li><a href="#8_set__multiset__1795">8、 set / multiset 容器</a></li>
<li>
<ul>
<li><a href="#81_set__1797">8.1 set 基本概念</a></li>
<li><a href="#82_set__1812">8.2 set 构造和赋值</a></li>
<li><a href="#83_set__1828">8.3 set 大小和交换</a></li>
<li><a href="#84_set__1842">8.4 set 插入合删除</a></li>
<li><a href="#85_set__1858">8.5 set 查找和统计</a></li>
<li><a href="#86_set__multiset__1871">8.6 set 和 multiset 区别</a></li>
<li><a href="#87_pair__1885">8.7 pair 对组创建</a></li>
<li><a href="#88_set__1907">8.8 set 排序</a></li>
</ul>
    </li>
<li><a href="#9_map__multimap__1953">9、 map / multimap 容器</a></li>
<li>
<ul>
<li><a href="#91_map__1955">9.1 map 基本概念</a></li>
<li><a href="#92_map__1976">9.2 map 构造和赋值</a></li>
<li><a href="#93_map__1993">9.3 map 大小和交换</a></li>
<li><a href="#94_map__2007">9.4 map 插入和删除</a></li>
<li><a href="#95_map__2036">9.5 map 查找和统计</a></li>
<li><a href="#96_map__2049">9.6 map 排序</a></li>
</ul>
    </li>
<li><a href="#10__2057">10、 案例-员工分组</a></li>
<li>
<ul>
<li><a href="#101__2059">10.1 案例描述</a></li>
<li><a href="#102__2067">10.2 实现步骤</a></li>
<li><a href="#103__2074">10.3 代码演示</a></li>
</ul>
   </li>
</ul>
   </li>
<li><a href="#_STL__2147">四、 STL 函数对象</a></li>
<li>
<ul>
<li><a href="#1__2149">1、 函数对象</a></li>
<li>
<ul>
<li><a href="#11__2151">1.1 基本概念</a></li>
<li><a href="#12__2162">1.2 使用方法</a></li>
</ul>
    </li>
<li><a href="#2__2197">2、 谓词</a></li>
<li>
<ul>
<li><a href="#21__2199">2.1 谓词概念</a></li>
<li><a href="#22__2207">2.2 一元谓词</a></li>
<li><a href="#23__2240">2.3 二元谓词</a></li>
</ul>
    </li>
<li><a href="#3__2271">3、 内建函数对象</a></li>
<li>
<ul>
<li><a href="#31__2273">3.1 意义</a></li>
<li><a href="#32__2290">3.2 算术仿函数</a></li>
<li><a href="#33__2315">3.3 关系仿函数</a></li>
<li><a href="#34__2332">3.4 逻辑仿函数</a></li>
</ul>
   </li>
</ul>
   </li>
<li><a href="#_STL__2346">五、 STL 常用算法</a></li>
<li>
<ul>
<li><a href="#1__2355">1、 常用遍历算法</a></li>
<li>
<ul>
<li><a href="#11_for_each_2368">1.1 for_each</a></li>
<li><a href="#12_transform_2388">1.2 transform</a></li>
</ul>
    </li>
<li><a href="#2__2409">2、 常用查找算法</a></li>
<li>
<ul>
<li><a href="#21_find_2426">2.1 find</a></li>
<li><a href="#22_find_if_2446">2.2 find_if</a></li>
<li><a href="#23_adjacent_find_2464">2.3 adjacent_find</a></li>
<li><a href="#24_binary_search_2481">2.4 binary_search</a></li>
<li><a href="#25_count_2501">2.5 count</a></li>
<li><a href="#26_count_if_2541">2.6 count_if</a></li>
</ul>
    </li>
<li><a href="#3__2559">3、 常用排序算法</a></li>
<li>
<ul>
<li><a href="#31_sort_2574">3.1 sort</a></li>
<li><a href="#32_random_shuffle_2592">3.2 random_shuffle</a></li>
<li><a href="#33_merge_2615">3.3 merge</a></li>
<li><a href="#34_reverse_2640">3.4 reverse</a></li>
</ul>
    </li>
<li><a href="#4__2657">4、 常用拷贝和替换算法</a></li>
<li>
<ul>
<li><a href="#41_copy_2672">4.1 copy</a></li>
<li><a href="#42_replace_2694">4.2 replace</a></li>
<li><a href="#43_replace_if_2715">4.3 replace_if</a></li>
<li><a href="#44_swap_2736">4.4 swap</a></li>
</ul>
    </li>
<li><a href="#5__2755">5、 常用算术生成算法</a></li>
<li>
<ul>
<li><a href="#51_accumulate_2772">5.1 accumulate</a></li>
<li><a href="#52_fill_2790">5.2 fill</a></li>
</ul>
    </li>
<li><a href="#6__2808">6、 常用集合算法</a></li>
<li>
<ul>
<li><a href="#61_set_insersection_2822">6.1 set_insersection</a></li>
<li><a href="#62_set_union_2848">6.2 set_union</a></li>
<li><a href="#63_set_difference_2874">6.3 set_difference</a></li>
</ul>
   </li>
</ul>
  </li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<h1>
<a id="C__1"></a>C++ 提高编程</h1> 
<p>主要针对C++<mark>泛型编程</mark>和<mark>STL</mark>技术</p> 
<h2>
<a id="__5"></a>一、 模板</h2> 
<h3>
<a id="1__7"></a>1、 概念</h3> 
<p>模板就是建立通用的模具，大大提高代码的复用性</p> 
<p>模板特点</p> 
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>​ 模板的通用并不是万能的</li>
</ul> 
<h3>
<a id="2__16"></a>2、 函数模板</h3> 
<ul>
<li>C++ 另一种编程思想为泛型编程，主要利用的技术就是模板</li>
<li>C++ 提供两种模板机制：函数模板 和 类模板</li>
</ul> 
<h4>
<a id="21__21"></a>2.1 函数模板语法</h4> 
<p>函数模板的作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体确定，用一个虚拟的类型来代表</p> 
<p>语法</p> 
<pre><code class="prism language-c++">template&lt;typename T&gt;
函数声明或定义
</code></pre> 
<p>参数</p> 
<ul>
<li>template：声明创建模板</li>
<li>typename：表明其后面的符号是一种数据类型，可以用class来代替</li>
<li>T：通用的数据类型，名称可以替换，通常为大写字母</li>
</ul> 
<pre><code class="prism language-c++">// 两个整型交换函数
void swap(int&amp; a, int&amp; b)
{
	int temp = a;
	a = b; 
	b = temp;
}
// 交换浮点型的函数
void swap(double&amp; a, double&amp; b)
{
	double temp = a;
	a = b;
	b = temp;
}
// 函数模板
template &lt;typename T&gt;  // 声明模板，告诉编译器后面代码紧跟着T，不要报错，T是一个通用的数据类型
void m_swap(T&amp; a, T&amp; b)
{
	T temp = a;
	a = b;
	b = temp;
}
void test()
{
	int a = 1;
	int b = 3;
	double a1 = 4;
	double b1 = 5;
	/* swap(a, b);
	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;
	swap(a1, b1);
	cout &lt;&lt; a1 &lt;&lt; b1 &lt;&lt; endl; */
	// 使用函数模板
	// 1、 自动推导
	m_swap(a, b);
	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;
	// 2、 显示指定类型
	m_swap&lt;int&gt;(a, b);
	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;
}
</code></pre> 
<blockquote> 
 <p>模板可以将数据类型参数化</p> 
 <p>模板的使用方法</p> 
 <ul>
<li>自动推导</li>
<li>显示指定类型</li>
</ul> 
</blockquote> 
<h4>
<a id="22__88"></a>2.2 注意事项</h4> 
<p>注意事项</p> 
<ul>
<li>自动推导数据类型，必须推导出一致的数据类型 T，才可以使用</li>
<li>模板必须要确定出 T 的数据类型，才可以使用</li>
</ul> 
<h4>
<a id="23__95"></a>2.3 普通函数和函数模板的区别</h4> 
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型装换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型装换</li>
<li>如果利用显示指定类型的方法，可以发生隐式类型转换</li>
</ul> 
<h4>
<a id="24__101"></a>2.4 普通函数和函数模板的调用规则</h4> 
<p>调用规则如下</p> 
<ol>
<li> <p>如果函数模板和普通函数都可以实现，优先调用普通函数</p> </li>
<li> <p>可以通过空模板参数列表强制调用函数模板</p> <pre><code class="prism language-c++">void myPrint(int a, int b)
{
	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "普通函数" &lt;&lt; endl;
}
template&lt;typename T&gt;
void myPrint(T a, T b)
{
	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "模板函数" &lt;&lt; endl;
}

void test()
{
	int a = 10;
	int b = 20;
	myPrint&lt;&gt;(a, b);  // 空模板参数列表调用模板函数
}
</code></pre> </li>
<li> <p>函数模板也可以发生重载</p> </li>
<li> <p>如果函数模板可以产生更好的匹配模式，优先调用函数模板</p> <pre><code class="prism language-c++">void myPrint(int a, int b)
{
	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "普通函数" &lt;&lt; endl;
}
template&lt;typename T&gt;
void myPrint(T a, T b)
{
	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "模板函数" &lt;&lt; endl;
}

void test()
{
	char a = 'a';
	char b = 'b';
	myPrint(a, b);  // 函数模板可以产生更好的匹配 
}
</code></pre> 
  <blockquote> 
   <p>既然提供了函数模板，最好不要提供普通函数，否则容易出现二义性</p> 
  </blockquote> </li>
</ol> 
<h4>
<a id="25__157"></a>2.5 模板的局限性</h4> 
<ul><li>模板的通用性并不是万能的</li></ul> 
<p>如果传入的是一个元组以及自定义数据类型，就无法实现了</p> 
<p>因此，C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化模板</p> 
<pre><code class="prism language-c++">// 模板重载
// 对比两个数据是否相等
class Person
{
public:
	Person(string name, int age)
	{
		m_Age = age;
		m_Name = name;
	}
	string m_Name;
	int m_Age;
};
template&lt;class T&gt;
bool myCompare(T&amp; a, T&amp; b)  // 如果传入的是一个自定义数据类型呢
{
	if (a == b)
	{
		return true;
	}
	else
	{
		return false;
	}
}
// 利用具体化Person的版本实现代码，具体化优先调用
// 也可以使用运算符重载
template&lt;&gt;bool myCompare(Person&amp; p1, Person&amp; p2)
{
	if (p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)
	{
		return true;
	}
	else
	{
		return false;
	}
}
void test()
{
	Person p1("Tom", 10);
	Person p2("Tom", 10);
	cout &lt;&lt; myCompare(p1, p2) &lt;&lt; endl;
}
</code></pre> 
<blockquote> 
 <p>学习模板并不是为了写模板，而是在STL中能够运用系统提供的模板</p> 
</blockquote> 
<h3>
<a id="3__214"></a>3、 类模板</h3> 
<h4>
<a id="31__216"></a>3.1 类模板语法</h4> 
<p>类模板作用</p> 
<ul><li>建立一个通用类，类中成员数据类型可以不具体制定，用一个虚拟的类型代表</li></ul> 
<p>语法</p> 
<pre><code class="prism language-c++">template&lt;typename T&gt;
类
</code></pre> 
<p>参数</p> 
<ul>
<li>template：声明创建模板</li>
<li>typename：表明其后面的符号是一种数据类型，可以用class来代替</li>
<li>T：通用的数据类型，名称可以替换，通常为大写字母</li>
</ul> 
<pre><code class="prism language-c++">template&lt;typename NameT, typename AgeT&gt;
class Person
{
public:
	Person(NameT name, AgeT age)
	{
		m_Age = age;
		m_Name = name;
	}
	NameT m_Name;
	AgeT m_Age;
};
void test()
{
	Person&lt;string, int&gt;("Tom", 30);  // 调用-只有一种调用方式
}
</code></pre> 
<h4>
<a id="32__254"></a>3.2 类模板和函数模板的区别</h4> 
<p>类模板与函数模板区别主要有两点</p> 
<ol>
<li> <p>类模板没有自动类型推导的使用方式</p> </li>
<li> <p>类模板在模板参数列表中可以有默认参数</p> <pre><code class="prism language-c++">template&lt;typename NameT, typename AgeT = int&gt;  // 默认参数
class Person
{
public:
	Person(NameT name, AgeT age)
	{
		m_Age = age;
		m_Name = name;
	}
	NameT m_Name;
	AgeT m_Age;
};
void test()
{
	Person&lt;string&gt;("Tom", 30);
}
</code></pre> </li>
</ol> 
<h4>
<a id="33__281"></a>3.3 使用时机</h4> 
<p>类模板中成员函数和普通类中成员函数创建时机是有区别的</p> 
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul> 
<pre><code class="prism language-c++">class Person1
{
public:
	void show()
	{
		cout &lt;&lt; "Person1" &lt;&lt; endl;
	}

};

template&lt;typename T&gt;
class Person
{
public:
    // 没调用，其不会编译，因为无法确定T的数据类型
	T p1;
	void func1()
	{
		p1.show();
	}
	
};
void test()
{
	Person&lt;Person1&gt; p;
	p.func1();
}
</code></pre> 
<h4>
<a id="34__318"></a>3.4 类模板对象函数做参数</h4> 
<p>类模板实例出的对象，向函数传参</p> 
<p>一共有三种传入方式</p> 
<ul>
<li> <p>指定传入的数据类型：直接显示对象的数据类型</p> 
  <ul><li> <pre><code class="prism language-c++">// 指定传入类型
void printPerson1(Person&lt;string, int&gt; &amp;p); 
</code></pre> </li></ul> </li>
<li> <p>参数模板化：将对象中的参数变为模板进行传递</p> 
  <ul><li> <pre><code class="prism language-c++">// 参数模板化
template&lt;class T1, class T2&gt;
void printPerson2(Person&lt;T1, T2&gt;&amp; p);
</code></pre> </li></ul> </li>
<li> <p>整个类模板化：将这个对象类型模板化进行传递</p> 
  <ul><li> <pre><code class="prism language-c++">// 整个类模板化
template&lt;class T&gt;
void printPerson3(T &amp;p);
</code></pre> </li></ul> </li>
</ul> 
<pre><code class="prism language-c++">// 类模板做函数的参数
template&lt;class T1, class T2&gt;
class Person
{
public:
	Person(T1 name, T2 age)
	{
		m_Name = name;
		m_Age = age;
	}
	T1 m_Name;
	T2 m_Age;
	void showPerson()
	{
		cout &lt;&lt; "name:" &lt;&lt; m_Name &lt;&lt; " age:" &lt;&lt; m_Age &lt;&lt; endl;
	}
};
// 指定传入类型
void printPerson1(Person&lt;string, int&gt; &amp;p)  
{
	p.showPerson();
}
// 参数模板化
template&lt;class T1, class T2&gt;
void printPerson2(Person&lt;T1, T2&gt;&amp; p)
{
	p.showPerson();
	cout &lt;&lt; "T1的类型为：" &lt;&lt; typeid(T1).name() &lt;&lt; endl;
	cout &lt;&lt; "T2的类型为：" &lt;&lt; typeid(T2).name() &lt;&lt; endl;
}
// 整个类模板化
template&lt;class T&gt;
void printPerson3(T &amp;p)
{
	p.showPerson();
}
void test()
{
	Person&lt;string, int&gt; p("Tom", 12);
	printPerson1(p);
	printPerson2(p);
	printPerson3(p);
}
</code></pre> 
<blockquote> 
 <p>查看数据类型的方式</p> 
 <pre><code class="prism language-c++">typeid(T2).name()
</code></pre> 
</blockquote> 
<h4>
<a id="35__399"></a>3.5 类模板与继承</h4> 
<p>当类模板碰到继承是，需要注意以下几点</p> 
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中 T 的数据类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类的 T 的类型，子类也需变为模板</li>
</ul> 
<pre><code class="prism language-c++">// 类模板与继承
template&lt;class T&gt;
class Base
{
public:
	T m_M;
};
// 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中 T 的数据类型
class Son : public Base&lt;string&gt; {};
// 如果想灵活使用父类中的 T 类型，子类也需要变为类模板
template&lt;class T1, class T2&gt;
class Son1 : public Base&lt;T2&gt; {};
</code></pre> 
<h4>
<a id="36__424"></a>3.6 类模板成员函数类外实现</h4> 
<p>能够掌握类模板中的成员函数类外实现</p> 
<pre><code class="prism language-c++">// 类外实现
template&lt;class T1, class T2&gt;
class Person
{
public:
	Person(T1 age, T2 name);
	void shouPerson();
	T1 m_Age;
	T2 m_Name;
};
template &lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 age, T2 name)
{
	this-&gt;m_Name = name;
	m_Age = age;
}
// 要体现其为类模板的类函数，没有参数也要添加
template &lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::shouPerson()
{
	cout &lt;&lt; "name:" &lt;&lt; m_Name &lt;&lt; " age:" &lt;&lt; m_Age &lt;&lt; endl;
}
</code></pre> 
<h4>
<a id="37__453"></a>3.7 类模板文件编写</h4> 
<p>掌握类模板成员函数分文件编写产生的问题以及解决方式</p> 
<p>问题</p> 
<ul><li>类模板中成员函数创建时机是在调用阶段，导致文件编写是链接不到</li></ul> 
<p>解决</p> 
<ol>
<li>直接包含 .cpp 源文件</li>
<li>将声明和实现写到同一个文件中，并更改后缀名为 .hpp，hpp 是约定的名称，并不是强制</li>
</ol> 
<p>person.hpp 中代码</p> 
<pre><code class="prism language-c++">#pragma once
#include &lt;iostream&gt;
using namespace std;


template&lt;class T1, class T2&gt;
class Person
{
public:
	Person(T1 age, T2 name);
	void shouPerson();
	T1 m_Age;
	T2 m_Name;
};
template &lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 age, T2 name)
{
	this-&gt;m_Name = name;
	m_Age = age;
}
template &lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::shouPerson()
{
	cout &lt;&lt; "name:" &lt;&lt; m_Name &lt;&lt; " age:" &lt;&lt; m_Age &lt;&lt; endl;
}
</code></pre> 
<p>程序入口代码</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
using namespace std;
#include &lt;fstream&gt;
// 第一中解决方式，包含 .cpp源文件
// #include"Person.cpp"

// 第二种解决方式，将 .h 和 .cpp 中的内容写到 .hpp 文件中
#include "Person.hpp"

void test()
{
	Person&lt;string, int&gt; p("Tom", 132);
	p.shouPerson();
}
int main() {
	test();

	system("pause");
	return 0;
}
</code></pre> 
<blockquote> 
 <p>主要解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为 .hpp</p> 
</blockquote> 
<h4>
<a id="38__523"></a>3.8 类模板和友元</h4> 
<p>掌握类模板配合友元函数的类内和类外实现</p> 
<ul>
<li>全局函数类内实现：直接在类内声明友元即可</li>
<li>全局函数类外实现：需要提前让编译器知道全局函数的存在</li>
</ul> 
<pre><code class="prism language-c++">// 通过全局函数打印全局信息
 // 提前让编译器知道Person类的存在
template&lt;class T1, class T2&gt;
class Person;

// 如果是类外实现的话需要让编译器提前知道该函数存在
template&lt;class T1, class T2&gt;
void printPerson1(Person&lt;T1, T2&gt;&amp; p);

template&lt;class T1, class T2&gt;
class Person
{
	// 全局函数，类内实现
	friend void printPerson(Person&lt;T1, T2&gt;&amp; p)
	{
		cout &lt;&lt; "姓名：" &lt;&lt; p.m_Name &lt;&lt; " 年龄：" &lt;&lt; p.m_Age &lt;&lt; endl;
 	}
	// 全局函数，类外实现
	friend void printPerson1&lt;&gt;(Person&lt;T1, T2&gt;&amp; p);  // &lt;&gt; 其为函数模板声明
public:
	Person(T1 name, T2 age)
	{
		m_Name = name;
		m_Age = age;
	}
private:
	T1 m_Name;
	T2 m_Age;
};
template&lt;class T1, class T2&gt;
void printPerson1(Person&lt;T1, T2&gt;&amp; p)
{
	cout &lt;&lt; "姓名：" &lt;&lt; p.m_Name &lt;&lt; " 年龄：" &lt;&lt; p.m_Age &lt;&lt; endl;
	cout &lt;&lt; "类外实现" &lt;&lt; endl;
}
</code></pre> 
<blockquote> 
 <p>建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p> 
</blockquote> 
<h4>
<a id="39__570"></a>3.9 数组类封装</h4> 
<p>案例描述：实现一个通用的数组类，要求如下</p> 
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及<code>opertator=</code>防止出现浅拷贝的问题</li>
<li>可以通过下标方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组数量</li>
</ul> 
<p>myArray.hpp 中代码</p> 
<pre><code class="prism language-c++">#pragma once
#include&lt;iostream&gt;
using namespace std;

template&lt;class T1&gt;  // 输出函数
void printArray();
template&lt;class T1&gt;
class MyArray
{
public:
	MyArray(int capacity);  // 有参构造
	MyArray(const MyArray&amp; arr);  // 拷贝构造
	MyArray&amp; operator=(const MyArray&amp; arr);  // 赋值运算符重载，防止浅拷贝问题
	void pushBack(const T1&amp; val);  //  尾插法插入数据
	void delBack();  // 尾删法删除数据
	T1&amp; operator[](int index);  // 重载[]，使得可以使用索引访问数组，同时可以赋值
	int getCapacity();// 返回数组的容量
	int getSize();// 返回数组的大小
	~MyArray();  // 清空堆区数据
private:
	T1* pAddress;  // 指针指向开辟到堆区的真实数组
	int m_Capacity; // 数组容量
	int m_Size;  // 数组大小
};

template&lt;class T1&gt;
MyArray&lt;T1&gt;::MyArray(int capacity)
{
	this-&gt;m_Capacity = capacity;
	this-&gt;m_Size = 0;
	this-&gt;pAddress = new T1[this-&gt;m_Capacity];  // 开辟数组空间
}
template&lt;class T1&gt;
MyArray&lt;T1&gt;::~MyArray()
{
	if (this-&gt;pAddress)
	{
		delete[] pAddress;
		pAddress = NULL;
	}
}
template&lt;class T1&gt;
MyArray&lt;T1&gt;::MyArray(const MyArray&amp; arr)
{
	this-&gt;m_Capacity = arr.m_Capacity;
	this-&gt;m_Size = arr.m_Size;
	// this-&gt;pAddress = arr.pAddress  // 浅拷贝
	this-&gt;pAddress = new T1[arr.m_Capacity];  // 深拷贝
	// arr中的数据都拷贝过去
	for (int i = 0; i &lt; this-&gt;m_Size; i++)
	{
		this-&gt;pAddress[i] = arr.pAddress[i];
	}
}
template&lt;class T1&gt;
MyArray&lt;T1&gt;&amp; MyArray&lt;T1&gt;::operator=(const MyArray&amp; arr)
{
	// 先判断原来堆区是否有数据，如果有先释放
	if (this-&gt;pAddress)
	{
		delete[] pAddress;
		this-&gt;pAddress = NULL;
		this-&gt;m_Size = 0;
		this-&gt;m_Capacity = 0;
	}
	// 深拷贝
	this-&gt;m_Capacity = arr.m_Capacity;
	this-&gt;m_Size = arr.m_Size;
	this-&gt;pAddress = new T1[this-&gt;m_Capacity];
	for (int i = 0; i &lt; this-&gt;m_Size; i++)
	{
		this-&gt;pAddress[i] = arr.pAddress[i];
	}
	return *this;
}
template&lt;class T1&gt;
void MyArray&lt;T1&gt;::pushBack(const T1&amp; val)
{
	// 判断容量是否等于大小
	if (this-&gt;m_Capacity == this-&gt;m_Size)
	{
		cout &lt;&lt; "达到数组容量，无法插入" &lt;&lt; endl;
		return;
	}
	this-&gt;pAddress[this-&gt;m_Size] = val;
	this-&gt;m_Size++;  // 更新数组大小
}
template&lt;class T1&gt;
void MyArray&lt;T1&gt;::delBack()
{
	// 让用户访问不到最后一个元素，即为尾删，逻辑删除
	if (!this-&gt;m_Size)
	{
		cout &lt;&lt; "数组中没有元素" &lt;&lt; endl;
		return;
	}
	this-&gt;m_Size--;  // 访问不到那个元素
}
template&lt;class T1&gt;
T1&amp; MyArray&lt;T1&gt;::operator[](int index)
{
	return this-&gt;pAddress[index];
}
template&lt;class T1&gt;
int MyArray&lt;T1&gt;::getCapacity()
{
	return this-&gt;m_Capacity;
}
template&lt;class T1&gt;
int MyArray&lt;T1&gt;::getSize()
{
	return this-&gt;m_Size;
}
template&lt;class T1&gt;
void printArray(MyArray&lt;T1&gt;&amp; arr)
{
	for (int i = 0; i &lt; arr.getSize(); i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
}
</code></pre> 
<p>主函数调用</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
using namespace std;
#include &lt;fstream&gt;
#include "Person.hpp"

void test()
{
	MyArray&lt;int&gt; arr(5);
	for (int i = 0; i &lt; 5; i++)
	{
		arr.pushBack(i);
	}
	cout &lt;&lt; "开始输出数组" &lt;&lt; endl;
	printArray(arr);
}
int main() {
	test();

	system("pause");
	return 0;
}
</code></pre> 
<p>该数组也可以存储自定义数据类型</p> 
<h2>
<a id="_STL__735"></a>二、 STL 初识</h2> 
<h3>
<a id="1__737"></a>1、 基本概念</h3> 
<ul>
<li>STL 基本模板库</li>
<li>STL 从广义上分为容器、算法和迭代器</li>
<li>容器和算法事件通过迭代器无缝连接</li>
<li>STL 几乎所有的代码都采用了模板类或模板函数</li>
</ul> 
<h3>
<a id="2_STL__744"></a>2、 STL 六大组件</h3> 
<p>STL 大体分为六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p> 
<ul>
<li>容器：各种数据结构：vector、list、deque、set、map等，用来存放数据</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器和算法之间的胶合剂</li>
<li>仿函数：行为类似的函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置和管理</li>
</ul> 
<h4>
<a id="21__755"></a>2.1 容器、算法、迭代器</h4> 
<p>容器：置物之所也</p> 
<p>STL 容器就是将运用最广泛的一些数据结构实现出来</p> 
<p>常用的数据结构：数组、列表、树、栈、队列、集合、映射表等</p> 
<p>这些容器分为序列式容器和关联式容器两种</p> 
<ul>
<li>序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置</li>
<li>关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系</li>
</ul> 
<p>算法：问题之解也</p> 
<p>有限的步骤，解决逻辑或数学上的问题，这叫做算法</p> 
<p>算法分为：质变算法和非质变算法</p> 
<ul>
<li>质变算法：是指运算过程中会更改区间内的元素的内容，例如拷贝、替换、删除等等</li>
<li>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li>
</ul> 
<p>迭代器：容器和算法之间粘合剂</p> 
<p>提供一种方法，使之能够依序寻访某个容器所含有的各个元素，而又无需暴露该容器的内部表示方式</p> 
<p>每个容器都有自己专属的迭代器</p> 
<p>迭代器使用非常类似于指针</p> 
<p>迭代器种类</p> 
<table>
<thead><tr>
<th>种类</th>
<th>权限</th>
<th>支持运算</th>
</tr></thead>
<tbody>
<tr>
<td>Input iterator(输入迭代器)</td>
<td>只读</td>
<td>++、==、!=</td>
</tr>
<tr>
<td>Output iterator(输出迭代器)</td>
<td>只写</td>
<td>++</td>
</tr>
<tr>
<td>Forward iterator(前向迭代器)</td>
<td>读和写，并且推进迭代器</td>
<td>++、==、!=</td>
</tr>
<tr>
<td>Bidirectional iterator(双向迭代器)</td>
<td>读和写，可以向前或向后操作</td>
<td>++、–</td>
</tr>
<tr>
<td>Random access iterator(随机访问迭代器)</td>
<td>读和写。可以跳跃式访问任意数据</td>
<td>++、–、[n]、-n、&lt;、&gt;</td>
</tr>
</tbody>
</table>
<p>常用的容器中迭代器种类为双向迭代器和随机访问迭代器</p> 
<h3>
<a id="3__797"></a>3、 迭代器初始</h3> 
<h4>
<a id="31_vector__799"></a>3.1 vector 存放内置数据类型</h4> 
<p>容器：<code>vector</code></p> 
<p>算法：<code>for_each</code></p> 
<p>迭代器：<code>vector&lt;int&gt;::iterator</code></p> 
<pre><code class="prism language-c++">#include &lt;vector&gt;  // vector 头文件
#include &lt;algorithm&gt;  // 标准算法头文件

void printVector(int value)
{
	cout &lt;&lt; value &lt;&lt; endl;
}
// vector 存放内置数据类型
void test()
{
	// 创建一个 vector 容器——数组
	vector&lt;int&gt; v;

	// 向容器中插入数据
	v.push_back(10);  // 尾插数据
	v.push_back(11);
	v.push_back(12);

	// 通过迭代器访问容器中的数据
	vector&lt;int&gt;::iterator itBegin = v.begin(); // 起始迭代器，指向容器中第一个元素，当做指针使用
	vector&lt;int&gt;::iterator itEnd = v.end();  // 结束迭代器，指向容器最后一个元素的下一个位置

	// 第一种遍历方式
	while (itBegin != itEnd)
	{
		cout &lt;&lt; *itBegin &lt;&lt; endl;
		itBegin++;
	}
	// 第二种遍历方式
	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; endl;
	}
	// 第三种遍历方式
	for_each(v.begin(), v.end(), printVector);  // 回调函数
}
</code></pre> 
<h4>
<a id="32_vector__846"></a>3.2 vector 存放自定义数据类型</h4> 
<p>vector 中存放自定义数据类型，并打印输出</p> 
<pre><code class="prism language-c++">// 存放自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		m_Name = name;
		m_Age = age;
	}
	int m_Age;
	string m_Name;
};

void test()
{
	vector&lt;Person&gt; v;
	Person p1("a", 20);
	Person p2("b", 34);
	Person p3("c", 20);
	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);

	// 遍历数据
	for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		cout &lt;&lt; "name:" &lt;&lt; it-&gt;m_Name  
			&lt;&lt; " age:" &lt;&lt; it-&gt;m_Age &lt;&lt; endl;  // it是一个指针
	}

	// 存放自定义数据类型的指针
	vector&lt;Person*&gt; v1;
	v1.push_back(&amp;p1);
	v1.push_back(&amp;p2);
	v1.push_back(&amp;p3);
	// 遍历数据
	for (vector&lt;Person*&gt;::iterator its = v1.begin(); its != v1.end(); its++)
	{
		cout &lt;&lt; "name:" &lt;&lt; (*its)-&gt;m_Name
			&lt;&lt; " age:" &lt;&lt; (*its)-&gt;m_Age &lt;&lt; endl;  // it是一个指针
	}
}
</code></pre> 
<h4>
<a id="33_vector__895"></a>3.3 vector 中嵌套容器</h4> 
<p>容器中嵌套容器，我们将所有数据遍历输出</p> 
<pre><code class="prism language-c++">// 容器嵌套容器
void test()
{
	vector&lt;vector&lt;int&gt;&gt; V;
	// 创建小容器
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	vector&lt;int&gt; v3;
	vector&lt;int&gt; v4;

	// 向小容器中添加数据
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
		v2.push_back(10 - i);
		v3.push_back(20 - i);
		v4.push_back(i + 10);
	}
	// 将小容器插入到大容器中
	V.push_back(v1);
	V.push_back(v2);
	V.push_back(v3);
	V.push_back(v4);

	// 遍历大容器
	for (vector&lt;vector&lt;int&gt;&gt;::iterator i = V.begin(); i != V.end(); i++)
	{
		// *i 是一个容器
		for (vector&lt;int&gt;::iterator j = (*i).begin(); j != (*i).end(); j++)
		{
			cout &lt;&lt; *j &lt;&lt; "t";
		}
		cout &lt;&lt; endl;
	}
}
</code></pre> 
<h2>
<a id="_STL__937"></a>三、 STL 常用容器</h2> 
<p>每个容器都要添加头文件</p> 
<h3>
<a id="1_string__941"></a>1、 string 容器</h3> 
<h4>
<a id="11_string__943"></a>1.1 string 基本概念</h4> 
<p>本质</p> 
<ul><li>string 是 C++ 风格的字符串，而 string 本质是一个类</li></ul> 
<p>string 和 char* 的区别</p> 
<ul>
<li>char* 是一个指针</li>
<li>string 是一个类，类内部封装了 char* ，管理这个字符串，是一个 char* 容器</li>
</ul> 
<p>特点</p> 
<ol>
<li>string 类内部封装了很多成员方法 
  <ul><li>例如：find, copy, delete, replace, insert</li></ul> </li>
<li>string 管理 char* 所分配的内存，不用担心复制和取值越界等，由类内进行负责</li>
</ol> 
<h4>
<a id="12_string__960"></a>1.2 string 构造函数</h4> 
<p>构造函数原型</p> 
<ul>
<li> <p><code>string();</code> 创建一个空字符串</p> <p><code>string(const char* s);</code> 使用字符串 s 初始化</p> </li>
<li> <p><code>string(const string&amp; str);</code> 使用一个 string 对象初始化另一个 string 对象</p> </li>
<li> <p><code>string(int, char c);</code> 使用 n 个字符 c 初始化</p> </li>
</ul> 
<pre><code class="prism language-c++">/*
- string();							创建一个空字符串
  string(const char* s);			使用字符串 s 初始化
- string(const string&amp; str);		使用一个 string 对象初始化另一个 string 对象
- string(int, char c);              使用 n 个字符 c 初始化
*/
void test()
{
	string s1;  // 默认构造
	const char* str = "hello world";
	string s2(str);  // 有参构造
	cout &lt;&lt; "s2:" &lt;&lt; s2 &lt;&lt; endl;
	string s3(s2);  // 拷贝构造
	cout &lt;&lt; "s3:" &lt;&lt; s3 &lt;&lt; endl;
	string s4(10, 'a');  // 10 个 a 构造
	cout &lt;&lt; "s4:" &lt;&lt; s4 &lt;&lt; endl;
}
</code></pre> 
<blockquote> 
 <p>string 的多种构造方式没有可比性，灵活性较高</p> 
</blockquote> 
<h4>
<a id="13_string__994"></a>1.3 string 赋值操作</h4> 
<p>功能描述</p> 
<ul><li>给 string 字符串进行赋值</li></ul> 
<p>赋值函数原型</p> 
<pre><code class="prism language-c++">string&amp; operator=(const char* s);  // char* 类型字符串赋值给当前的字符串
string&amp; operator=(const string &amp;s);  // 把字符串 s 赋值给当前的字符串
string&amp; operator=(char c);  // 把字符赋值给当前的字符串
string&amp; assign(const char* s);  // 把字符串 s 赋值给当前的字符串
string&amp; assign(const char* s, int n);  // 把字符串 s 的前 n 个字符赋值给当前的字符串
string&amp; assign(const string &amp;s);  // 把字符串 s 赋值给当前的字符串
string&amp; assign(int n, char c);  // 把 n 个字符 c 赋值给当前字符串
</code></pre> 
<h4>
<a id="14_string__1012"></a>1.4 string 字符串拼接</h4> 
<p>功能描述</p> 
<ul><li>实现在字符串末尾拼接字符串</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">string&amp; operator+=(const char* str);  // 重载 += 操作符
string&amp; operator+=(const char c);  // 重载 += 操作符
string&amp; operator+=(const string&amp; str);  // 重载 += 操作符
string&amp; append(const char* s);  // 把字符串 s 连接到当前字符串末尾
string&amp; append(const char* s, int n);  // 把字符串 s 的前 n 个字符连接到字符串结尾
string&amp; append(const string&amp; s);  // 同 operator+=(const string&amp; str);
string&amp; append(const string&amp; s, int pos, int n);  // 字符串 s 从 pos 开始的 n 个字符连接到字符串结尾
</code></pre> 
<h4>
<a id="15_string__1030"></a>1.5 string 查找和替换</h4> 
<p>功能描述</p> 
<ul>
<li>查找：查找指定字符是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">int find(const string&amp; str, int pos = 0) const;  // 查找 str 第一次出现的位置，从 pos 开始查找
int find(const char* s, int pos = 0) const;  // 查找 s 第一次出现的位置，从 pos 开始查找
int find(const char* s, int pos, int n) const;  // 从 pos 位置查找 s 的前 n 个字符第一次出现的位置
int find(const char c, int pos = 0) const;  // 查找字符 c 第一次出现的位置
int rfind(const string&amp; str, int pos = npos) const;  // 查找 str 最后一次位置，从 pos 开始查找
int rfind(const char* s, int pos = npos) const;  // 查找 s 最后一次出现的位置，从 pos 开始查找
int rfind(const char* s, int pos, int n) const;  // 从 pos 查找 s 的前 n 个字符最后一次出现的位置
int rfind(const char c, int pos = 0) const;  // 查找字符 c 最后一次出现的位置
string&amp; replace(int pos, int n, const string&amp; str);  // 替换从 pos 开始 n 个字符为字符串 str
string&amp; replace(int pos, int n, const char* s);  // 替换从 pos 开始的 n 个字符为字符串 s
</code></pre> 
<blockquote> 
 <p>总结</p> 
 <ul>
<li>find查找是从左往右，rfind是从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul> 
</blockquote> 
<h4>
<a id="16_string__1058"></a>1.6 string 字符串比较</h4> 
<p>功能描述</p> 
<ul><li>字符串之间的比较</li></ul> 
<p>比较方式</p> 
<ul>
<li>字符串比较时按字符的ASCII码进行对比</li>
<li>= 返回 0</li>
<li>&lt; 返回 1</li>
<li>&gt; 返回 -1</li>
</ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">int compare(const string&amp; s) const;  // 与字符串 s 进行比较
int compare(const char* s) const;  // 与字符串 s 进行比较
</code></pre> 
<blockquote> 
 <p>主要比较两个字符串是否相等</p> 
</blockquote> 
<h4>
<a id="17_string__1080"></a>1.7 string 字符存取</h4> 
<p>string 中单个字符存取方式有两种</p> 
<pre><code class="prism language-c++">char&amp; operator[](int n);  // 通过 [] 方法获取字符
char&amp; at(int n);  // 通过 at 方法获取字符
str.size();  // 返回字符串的长度 
</code></pre> 
<blockquote> 
 <p>可以修改字符，<code>str[int n] = 'c'</code></p> 
</blockquote> 
<h4>
<a id="18_string__1092"></a>1.8 string 插入和删除</h4> 
<p>功能描述</p> 
<ul><li>对 string 字符串进行插入合删除字符操作</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">string&amp; insert(int pos, const char* s);  // 插入字符串
string&amp; insert(int pos, const string&amp; str);  // 插入字符串
string&amp; insert(int pos, int n, char c);  // 在指定位置插入 n 个字符 c
string&amp; erase(int pos, int n = npos);  // 删除从 pos 开始的 n 个字符
</code></pre> 
<h4>
<a id="19_string__1107"></a>1.9 string 中的子串</h4> 
<p>功能描述</p> 
<ul><li>从字符串中获取想要的子串</li></ul> 
<p>函数原理</p> 
<pre><code class="prism language-C++">string substr(int pos = 0, int n = npos) const;  // 返回由 pos 开始的 n 个字符组成的字符串
</code></pre> 
<h3>
<a id="2_vector__1119"></a>2、 vector 容器</h3> 
<h4>
<a id="21_vector__1121"></a>2.1 vector 基本概念</h4> 
<p>功能</p> 
<ul><li>vector 数据结构和数组非常相似，也称为单端数组</li></ul> 
<p>vector 与普通数组的区别</p> 
<ul><li> <p>不同之处在于数组是静态空间，而 vector 可以动态扩展</p> <p>动态扩展</p> 
  <ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间</li></ul> <p><img src="https://images2.imgbox.com/61/df/FPP6R82B_o.png" alt="https://images.cnblogs.com/cnblogs_com/blogs/722174/galleries/2074790/o_220215124744_Snipaste_2022-02-14_13-36-18.png"></p> 
  <ul><li>vector 容器的迭代是支持随机访问的迭代器</li></ul> </li></ul> 
<h4>
<a id="22_vector__1139"></a>2.2 vector 构造函数</h4> 
<p>功能描述</p> 
<ul><li>创建 vector 容器</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">vector&lt;T&gt; v;  // 采用模板实现类实现，默认构造函数
vector v2(v.begin(), v.end());  // 将 v[begin(), end()] 区间中的元素拷贝到自身，左闭右开
vector v3(n, elem);  // 构造函数将 n 个 elem 拷贝给本身
vector v4(const vector&amp; vec);  // 拷贝构造函数
</code></pre> 
<blockquote> 
 <p>vector 的多种构造方式没有可比性，灵活使用即可</p> 
</blockquote> 
<h4>
<a id="23_vector__1156"></a>2.3 vector 赋值操作</h4> 
<p>功能描述</p> 
<ul><li>给 vector 容器进行赋值</li></ul> 
<p>函数原理</p> 
<pre><code class="prism language-c++">vector&amp; operator=(const vector &amp;vec);  // 重载赋值操作符
assign(v.begin(), v.end());  // 将v[begin, end]区间中的数据拷贝赋值给本身
assign(n, elem);  // 将 n 个 elem 拷贝赋值给本身
</code></pre> 
<h4>
<a id="24_vector__1170"></a>2.4 vector 大小操作</h4> 
<p>功能描述</p> 
<ul><li>对 vector 容器的容量和大小操作</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">empty();  // 判断容器是否为空
capacity();  // 容器的容量
size();  // 返回容器中元素的个数
resize(int num);  // 重新指定容器的长度为 num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除（默认为0）
resize(int num, elem);  // 重新指定容器的长度为 num，若容器边长，则以 elem 值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除
</code></pre> 
<pre><code class="prism language-c++">void printVector(vector&lt;int&gt;&amp; v)
{
	for (vector&lt;int&gt;::iterator i = v.begin(); i != v.end(); i++)
	{
		cout &lt;&lt; *i &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}
void test()
{
	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}
	cout &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; v.size() &lt;&lt; endl;
	v.resize(20);  // 默认使用0填充
	cout &lt;&lt; v.size() &lt;&lt; endl;
	cout &lt;&lt; v.capacity() &lt;&lt; endl;
	printVector(v);
}
</code></pre> 
<blockquote> 
 <p>容量大于等于大小</p> 
</blockquote> 
<h4>
<a id="25_vector__1213"></a>2.5 vector 插入和删除</h4> 
<p>功能描述</p> 
<ul><li>对 vector 容器进行插入、删除操作</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">push_back(elem);  // 尾部插入元素elem
pop_back();  // 删除最后一个元素
insert(const_iterator pos, elem);  // 迭代器指向位置 pos 插入元素 elem
insert(const_iterator pos, int n, elem);  // 迭代器指向位置 pos 插入 n 个元素
erase(const_iterator pos);  // 删除迭代器指向的长度
erase(const_iterator start, const_iterator end);  // 删除迭代器从 start 到 end 之间的元素，左闭右开
clear();  // 删除容器中所有元素
</code></pre> 
<blockquote> 
 <p>​ <code>v1.insert(v1.begin(), 100); // 第一个参数是迭代器</code></p> 
</blockquote> 
<h4>
<a id="26_vector__1233"></a>2.6 vector 数据存取</h4> 
<p>功能描述</p> 
<ul><li>对 vector 中的数据的存取操作</li></ul> 
<p>数据原型</p> 
<pre><code class="prism language-c++">at(int idx);  // 返回索引 idx 所指的对象
operator[](int idx);  // 返回索引 idx 所指的数据
fornt();  // 返回容器中第一个数据元素
back();  // 返回容器中最后一个数据元素
</code></pre> 
<h4>
<a id="27_vector__1248"></a>2.7 vector 互换容器</h4> 
<p>功能描述</p> 
<ul><li>实现两个容器内元素进行互换</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">swap(v);  // 将 vec 与 本身的元素互换
</code></pre> 
<pre><code class="prism language-c++">void test()
{
	vector&lt;int&gt; v;
	vector&lt;int&gt; v1;
	for (int i = 0; i &lt; 10; i++)
	{
		v.insert(v.begin(), i);
		v1.push_back(i + 100);
	}
	cout &lt;&lt; "交换前" &lt;&lt; endl;
	printVector(v);
	printVector(v1);
	v.swap(v1);
	cout &lt;&lt; "交换后" &lt;&lt; endl;
	printVector(v);
	printVector(v1);
}
</code></pre> 
<blockquote> 
 <p>作用：巧用 swap 可以收缩内存空间<code>vector&lt;int&gt; (v).swap(v); // 使用匿名对象</code></p> 
</blockquote> 
<h4>
<a id="28_vector__1282"></a>2.8 vector 预留空间</h4> 
<p>功能描述</p> 
<ul><li>减少 vector 在动态扩展容量时的扩展次数</li></ul> 
<p>函数原理</p> 
<pre><code class="prism language-c++">reserve(int len);  // 容器预留 len 个长度，预留位置不初始化，元素不可访问
</code></pre> 
<pre><code class="prism language-c++">void test()
{
	vector&lt;int&gt; v;

	int num = 0;  // 统计开辟次数
	v.reserve(1000000);  // 当没有添加此代码时，开辟了 35 次内存空间
	int* p = NULL;  
	for (int i = 0; i &lt; 1000000; i++)
	{
		v.push_back(i);
		if (p != &amp;v[0])  // 开辟一次内存，其首地址会发生改变
		{
			p = &amp;v[0];
			num++;
		}
	}
	cout &lt;&lt; num &lt;&lt; endl;
}
</code></pre> 
<blockquote> 
 <p>如果数据量比较大，可以一开始利用 reserve 预留空间</p> 
</blockquote> 
<h3>
<a id="3_deque__1317"></a>3、 deque 容器</h3> 
<h4>
<a id="31_deque__1319"></a>3.1 deque 基本概念</h4> 
<p>功能</p> 
<ul><li>双端数组：可以对头部进行插入删除操作</li></ul> 
<p>deque 和 vector 区别</p> 
<ul>
<li>vector 对于头部的插入和删除的效率较低，数据量大，效率低</li>
<li>deque 相对而言，对头部的插入删除速度会比 vector 快</li>
<li>vector 访问元素时的速度会比 deque 快，这和两者实现有关</li>
</ul> 
<p><img src="https://images2.imgbox.com/e3/ba/OaOyl4og_o.png" alt="https://images.cnblogs.com/cnblogs_com/blogs/722174/galleries/2074790/o_220215135651_Snipaste_2022-02-14_13-36-18.png"></p> 
<p>deque 内部工作原理</p> 
<p>deque 内部有一个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</p> 
<p>中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间</p> 
<p><img src="https://images2.imgbox.com/99/83/lKaBERx3_o.png" alt="https://images.cnblogs.com/cnblogs_com/blogs/722174/galleries/2074790/o_220215135946_OIP-C.jpg"></p> 
<p>deque 容器的迭代器也是支持随机访问的</p> 
<h4>
<a id="32_deque__1343"></a>3.2 deque 构造函数</h4> 
<p>功能描述</p> 
<ul><li>deque 容器构造</li></ul> 
<p>函数原理</p> 
<pre><code class="prism language-c++">deque&lt;T&gt; deq;  // 默认构造形式
deque d2(deq.begin(), deq.end());  // 构造函数将 [beg, end] 区间中的元素拷贝给本身
deque d3(n, elem);  // 构造函数将 n 个 elem 拷贝给本身
deque d4(const deque &amp;deq);  // 拷贝构造函数
</code></pre> 
<h4>
<a id="33_deque__1358"></a>3.3 deque 赋值操作</h4> 
<p>功能描述</p> 
<ul><li>给 deque 容器进行赋值</li></ul> 
<p>函数原理</p> 
<pre><code class="prism language-c++">deque&amp; operator=(const deque&amp; d);  // 重载赋值运算符
assign(beg, end);  // 将 [beg, end] 区间中的数据拷贝赋值给本身
assign(n, elem);  // 将 n 个 elem 拷贝赋值给本身
</code></pre> 
<h4>
<a id="34_deque__1372"></a>3.4 deque 大小操作</h4> 
<p>功能描述</p> 
<ul><li>对 deque 容器的大小进行操作</li></ul> 
<p>函数原理</p> 
<pre><code class="prism language-c++">empty();  // 判断容器是否为空
size();  // 返回容器中元素的个数
resize(int num);  // 重新指定容器的长度为 num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除（默认为0）
resize(int num, elem);  // 重新指定容器的长度为 num，若容器边长，则以 elem 值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除
</code></pre> 
<blockquote> 
 <p>deque 没有容量的概念</p> 
</blockquote> 
<h4>
<a id="35_deque__1389"></a>3.5 deque 插入和删除</h4> 
<p>功能描述</p> 
<ul><li>向 deque 容器中插入和删除数据</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">// 两端操作
push_back(elem);  // 在容器尾部添加一个数据
push_front(elem);  // 在容器头部插入一个数据
pop_back();  // 删除容器最后一个数据
pop_front();  // 删除容器第一个元素

// 指定位置操作
insert(pos, elem);  // 在 pos 位置插入一个 elem 元素的拷贝，返回数据的位置
insert(pos, n, elem);  // 在 pos 位置插入 n 个 elem 数据，无返回值
insert(pos, beg, end);  // 在 pos 位置插入 (d1.begin(), d1.end()) 数据，无返回值
clear();  // 清空容器的所有数据
erase(beg, end);  // 删除 [beg, end] 区间的数据，返回下一个数据的位置
erase(pos);  // 删除 pos 位置的数据，返回下一个数据的位置
</code></pre> 
<blockquote> 
 <p>里面的 pos 是迭代器指针的位置</p> 
</blockquote> 
<h4>
<a id="36_deque__1415"></a>3.6 deque 数据存取</h4> 
<p>功能描述</p> 
<ul><li>对 deque 中的数据的存取操作</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">at(int idx);  // 返回索引 idx 所指的数据
operator[])(int idx);  // 返回索引 idx 所指的值
front();  // 返回容器第一个数据元素
back();  // 返回容器最后一个数据元素
</code></pre> 
<h4>
<a id="37_deque__1430"></a>3.7 deque 排序</h4> 
<p>功能描述</p> 
<ul><li>利用算法对 deque 中的数据进行排序</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">sort(iterator beg, iterator end);  // 对 [beg, end] 区间内元素进行排序
</code></pre> 
<blockquote> 
 <p>注意使用时，要包含头文件<code>#include &lt;algorithm&gt;</code></p> 
 <p>对于支持随机访问的迭代器的容器，都可以利用 sort 算法直接对其进行排序</p> 
 <p>vector 也可以利用 sort 进行排序</p> 
</blockquote> 
<h3>
<a id="4__1448"></a>4、 案例-评委打分</h3> 
<h4>
<a id="41__1450"></a>4.1 案例描述</h4> 
<p>有五名选手：选手 ABCDE ，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分</p> 
<h4>
<a id="42__1454"></a>4.2 实现步骤</h4> 
<ol>
<li>创建五名选手，放到 vector 容器中</li>
<li>遍历 vector 容器，取出每名选手，执行 for 循环，可以把 10 个评分存到 deque 容器中</li>
<li>sort 算法对 deque 容器中分数进行排序，去除最高分和最低分</li>
<li>deque 容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol> 
<pre><code class="prism language-c++">// 选手类
class Person
{
public:
	Person(string name, int score)
	{
		m_Name = name;
		m_Score = score;
	}
	string m_Name;
	int m_Score;  // 平均分
};
void createPerson(vector&lt;Person&gt;&amp; v)
{
	// 创建五名选手
	for (int i = 0; i &lt; 5; i++)
	{
		char nameSeed[] = { 'A', 'B', 'C', 'D', 'E' };
		string name = "选手";
		name += nameSeed[i];
		int score = 0;  // 默认为0分
		Person p(name, score);
		v.push_back(p);
	}
}
void setScore(vector&lt;Person&gt;&amp; v)
{
	// 打分
	for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		// 将评委的分数放入deque容器中
		deque&lt;int&gt; d;
		for (int i = 0; i &lt; 10; i++)
		{
			int score = rand() % 41 + 60;  // 分数在 60 到 100之间，随机分
			d.push_back(score);  // 将分数放入容器中
		}
		// 排序
		sort(d.begin(), d.end());

		// 去除最高分，和最低分
		d.pop_front();
		d.pop_back();
		// 取平均分
		int sum = 0;
		for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)
		{
			sum += *dit;  // 累加分数
		}
		int avr = sum / d.size();
		it-&gt;m_Score = avr;
	}
}
void showScore(vector&lt;Person&gt; v)
{
	for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		cout &lt;&lt; "名字为：" &lt;&lt; it-&gt;m_Name &lt;&lt; "  平均分为：" &lt;&lt; it-&gt;m_Score &lt;&lt; endl;
	}
}
void test()
{
	// 随机数种子
	srand((unsigned int)time(NULL));

	vector&lt;Person&gt; v;  // 存放选手类
	v.reserve(5);

	createPerson(v);

	setScore(v);

	showScore(v);
}
</code></pre> 
<h3>
<a id="5_stack__1539"></a>5、 stack 容器</h3> 
<h4>
<a id="51_stack__1541"></a>5.1 stack 基本概念</h4> 
<p>概念：stack 是一种先进后出的数据结构，它只有一个出口</p> 
<p><img src="https://images2.imgbox.com/87/6b/YOsS365E_o.png" alt="https://images.cnblogs.com/cnblogs_com/blogs/722174/galleries/2074790/o_220216064502_Snipaste_2022-02-14_13-36-18.png"></p> 
<p>栈中进入元素称为入栈：<code>push();</code></p> 
<p>栈中弹出元素称为出栈：<code>pop();</code></p> 
<h4>
<a id="52_stack__1551"></a>5.2 stack 常用接口</h4> 
<p>功能描述：</p> 
<ul><li>栈容器常用的对外接口</li></ul> 
<h5>
<a id="521__1557"></a>5.2.1 构造函数</h5> 
<pre><code class="prism language-c++">stack&lt;T&gt; stk;  // stack 采用模板实现，stack对象的默认构造形式
stack stk1(const stack&amp; stk);  // 拷贝构造函数
</code></pre> 
<h5>
<a id="522__1564"></a>5.2.2 赋值操作</h5> 
<pre><code class="prism language-c++">stack&amp; operator=(const stack&amp; stk);  // 重载赋值运算符
</code></pre> 
<h5>
<a id="523__1570"></a>5.2.3 大小操作</h5> 
<pre><code class="prism language-c++">empty();  // 判断堆栈是否为空
size();  // 返回栈的大小
</code></pre> 
<h5>
<a id="524__1577"></a>5.2.4 数据存取</h5> 
<pre><code class="prism language-c++">push(elem);  // 向栈顶添加元素
pop();  // 从栈顶移除第一个元素
top();  // 返回栈顶元素
</code></pre> 
<h3>
<a id="6_queue__1585"></a>6、 queue 容器</h3> 
<h4>
<a id="61_queue__1587"></a>6.1 queue 基本概念</h4> 
<p>概念：</p> 
<ul><li>queue 是一种先进先出的数据结构，它有两个出口</li></ul> 
<p><img src="https://images2.imgbox.com/13/03/fuifPp7b_o.png" alt="https://images.cnblogs.com/cnblogs_com/blogs/722174/galleries/2074790/o_220216070137_Snipaste_2022-02-14_13-36-18.png"></p> 
<p>队列容器允许从一端新增元素，从另一端移除元素</p> 
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p> 
<p>队列中进数据称为入队：<code>push();</code></p> 
<p>队列中出数据称为出队：<code>pop();</code></p> 
<h4>
<a id="62_queue__1603"></a>6.2 queue 常用接口</h4> 
<p>功能描述</p> 
<ul><li>栈容器常用的对外接口</li></ul> 
<h5>
<a id="621__1609"></a>6.2.1 构造函数</h5> 
<pre><code class="prism language-c++">queue&lt;T&gt; q;  // queue 采用模板类实现，queue 对象的默认构造函数
queue(const queue&amp; que);  // 拷贝构造函数
</code></pre> 
<h5>
<a id="622__1616"></a>6.2.2 赋值操作</h5> 
<pre><code class="prism language-c++">queue&amp; operator=(const queue&amp; q);  // 重载赋值操作符
</code></pre> 
<h5>
<a id="623__1622"></a>6.2.3 大小操作</h5> 
<pre><code class="prism language-c++">empty();  // 判断堆栈是否为空
size();  // 返回栈大小
</code></pre> 
<h5>
<a id="624__1629"></a>6.2.4 数据存取</h5> 
<pre><code class="prism language-c++">push(elem);  // 往队尾添加元素
pop();  // 从队头移除第一个元素
back();  // 返回最后一个元素
front();  // 返回队头第一个元素
</code></pre> 
<h3>
<a id="7_list__1638"></a>7、 list 容器</h3> 
<h4>
<a id="71_list__1640"></a>7.1 list 基本概念</h4> 
<p>功能：将数据进行链式存储</p> 
<p>链表是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p> 
<p>链表的组成：链表是由一系列结点组成</p> 
<p>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p> 
<p>STL 中的链表是一个双向循环链表</p> 
<p><img src="https://images2.imgbox.com/35/cd/S6k95TfF_o.png" alt="https://images.cnblogs.com/cnblogs_com/blogs/722174/galleries/2074790/o_220216072137_OIP-C.jpg"></p> 
<p>由于链表的存储方式并不是连续的内存空间，因此链表 list 中的迭代器只支持前移或后移，属于双向迭代器</p> 
<p>list 优点</p> 
<ul>
<li>采用动态分配内存，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量数据</li>
</ul> 
<p>list 缺点</p> 
<ul><li>链表灵活，但是空间（指针域）和时间（遍历）额外耗费较大</li></ul> 
<p>list 有一个重要的性质，插入操作和删除操作都不会造成原有 list 迭代器的失效，这在 vector 是不成立的</p> 
<p>总结：STL 中 list 和 vector 是最常被使用的容器，各有优缺点</p> 
<h4>
<a id="72_list__1671"></a>7.2 list 构造函数</h4> 
<p>功能描述</p> 
<ul><li>创建 list 容器</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">list&lt;T&gt; l;  // list 采用模板类实现，对象的默认构造形式
list(beg, end);  // 构造函数将 [beg, end]区间中的元素拷贝给本身
list(n, elem);  // 构造函数将 n 个 elem 拷贝给本身
list(const list&amp; l);  // 拷贝构造函数
</code></pre> 
<h4>
<a id="73_list__1686"></a>7.3 list 赋值和交换</h4> 
<p>功能描述</p> 
<ul><li>给 list 容器进行赋值，以及交换 list 容器</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">assign(beg, end);  // 将 [beg, end] 区间中的数据拷贝赋值给本身
assign(n, elem);  // 将 n 个 elem 拷贝赋值给本身
list&amp; operator=(const list&amp; l);  // 重载赋值运算符
swap(l);  // 将 list 与本身的元素互换
</code></pre> 
<h4>
<a id="74_list__1701"></a>7.4 list 大小操作</h4> 
<p>功能描述</p> 
<ul><li>对 list 容器的大小进行操作</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">size();  // 返回容器中元素的个数
empty();  // 判断容器是否为空
resize(int num);  // 重新指定容器的长度为 num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除（默认为0）
resize(int num, elem);  // 重新指定容器的长度为 num，若容器边长，则以 elem 值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除
</code></pre> 
<h4>
<a id="75_list__1716"></a>7.5 list 插入和删除</h4> 
<p>功能描述</p> 
<ul><li>对 list 容器进行数据的插入和删除</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">push_back(elem);  // 在容器尾部添加一个数据
push_front(elem);  // 在容器头部插入一个数据
pop_back();  // 删除容器最后一个数据
pop_front();  // 删除容器第一个元素
insert(pos, elem);  // 在 pos 位置插入一个 elem 元素的拷贝，返回数据的位置
insert(pos, n, elem);  // 在 pos 位置插入 n 个 elem 数据，无返回值
insert(pos, beg, end);  // 在 pos 位置插入 (l.begin(), l.end()) 数据，无返回值
clear();  // 清空容器的所有数据
erase(beg, end);  // 删除 [beg, end] 区间的数据，返回下一个数据的位置
erase(pos);  // 删除 pos 位置的数据，返回下一个数据的位置
remove(elem);  // 删除容器中所有与 elem 值匹配的元素
</code></pre> 
<h4>
<a id="76_list__1738"></a>7.6 list 数据存取</h4> 
<p>功能描述</p> 
<ul><li>对 list 容器中数据进行存取</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">front();  // 返回第一个元素
back();  // 返回最后一个元素
</code></pre> 
<blockquote> 
 <p>注意不能使用 at 和 [] 的方式访问容器中的元素</p> 
 <p>原因是 list 本质是链表，而不是使用连续线性空间存储数据，迭代器也是不支持随机访问的</p> 
 <p>迭代器不支持随机访问，支持双向访问</p> 
</blockquote> 
<h4>
<a id="77_list__1757"></a>7.7 list 反转和排序</h4> 
<p>功能描述</p> 
<ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">reverse();  // 反转链表
sort();  // 链表排序，其为成员函数
</code></pre> 
<blockquote> 
 <p>所有不支持随机访问迭代器容器，不可以使用标准算法</p> 
 <p>不支持随机访问迭代器的容器，内部会提供对应一些算法</p> 
 <p>对于自定义数据类型，sort() 括号可以添加一个排序规则</p> 
 <p>高级排序只是在排序规则上再进行一次逻辑规则的制定，并不复杂</p> 
 <pre><code class="prism language-c++">bool comparePerson(Person&amp; p1, Person&amp; p2)
{
    // 按照年龄升序
    if (p1.m_Age == p2.m_Name)
    {
        // 年龄相同，身高升序
        return p1.Height &gt; p2.Height;
    }
    else
    {
        return p1.m_Age &lt; p2.m_Age;
    }
}
l.sort(comparePerson);  // 排序算法
</code></pre> 
</blockquote> 
<h3>
<a id="8_set__multiset__1795"></a>8、 set / multiset 容器</h3> 
<h4>
<a id="81_set__1797"></a>8.1 set 基本概念</h4> 
<p>简介：</p> 
<ul><li>所有元素都会在插入时自动被排序</li></ul> 
<p>本质</p> 
<ul><li>set 属于关联式容器，底层结构使用二叉树实现</li></ul> 
<p>set 和 multiset 区别</p> 
<ul>
<li>set 不允许容器中有重复元素</li>
<li>multiset 允许容器中有重复元素</li>
</ul> 
<h4>
<a id="82_set__1812"></a>8.2 set 构造和赋值</h4> 
<p>功能描述</p> 
<ul><li>创建 set 容器以及赋值</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">set&lt;T&gt; s;  // 默认构造函数
set(const set&amp; s);  // 拷贝构造函数

set&amp; operator=(const set&amp; s);  // 重载赋值运算符
inset(elem);  // 插入数据
</code></pre> 
<h4>
<a id="83_set__1828"></a>8.3 set 大小和交换</h4> 
<p>功能描述</p> 
<ul><li>统计 set 容器大小及交换 set 容器</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">size();  // 返回容器中元素数目
empty();  // 判断容器是否为空
swap(s);  // 交换两个集合容器 
</code></pre> 
<h4>
<a id="84_set__1842"></a>8.4 set 插入合删除</h4> 
<p>功能描述</p> 
<ul><li>set 容器进行插入和删除操作</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">insert(elem);  // 在容器中插入元素
clear();  // 清空所有元素
erase(pos);  // 删除 pos 迭代器所指的元素，返回下一个元素的迭代器
erase(beg, end);  // 删除区间 [beg, end] 的所有元素，返回下一个元素的迭代器
erase(elem);  // 删除容器中值为 elem 的元素
</code></pre> 
<h4>
<a id="85_set__1858"></a>8.5 set 查找和统计</h4> 
<p>功能描述</p> 
<ul><li>对 set 容器进行查找数据以及进行数据统计</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">find(key);  // 查找 key 是否存在，若存在，返回该键的元素的迭代器；若不存在，返回 set.end();
count(key);  // 统计 key 的元素个数
</code></pre> 
<h4>
<a id="86_set__multiset__1871"></a>8.6 set 和 multiset 区别</h4> 
<p>掌握 set 和 multiset 的区别</p> 
<p>区别</p> 
<ul>
<li> <p>set 不可以插入重复数据，而 multiset 可以</p> </li>
<li> <p>set插入数据的同时会返回插入结果，表示插入是否成功</p> <p><code>ret.second</code>用来查看是否插入成功</p> </li>
<li> <p>multiset 不会检测数据，因此可以重复插入数据</p> </li>
</ul> 
<h4>
<a id="87_pair__1885"></a>8.7 pair 对组创建</h4> 
<p>功能描述</p> 
<ul><li>成功出现的数据，利用对组可以返回两个数据</li></ul> 
<p>两种创建方式</p> 
<pre><code class="prism language-c++">pair&lt;type1, type2&gt; p (value1, value2);  // 两个 type 分别对应 value 的数据类型
pair&lt;type1, type2&gt; p = make_pair(value1, value2);
</code></pre> 
<blockquote> 
 <p>两种创建方式，记住一种就可以了</p> 
</blockquote> 
<p>使用方式</p> 
<pre><code class="prism language-c++">pair&lt;string, int&gt; p ("Tom", 20);
cout &lt;&lt; "name:" &lt;&lt; p.first &lt;&lt; "  age:" &lt;&lt; p.second;
</code></pre> 
<h4>
<a id="88_set__1907"></a>8.8 set 排序</h4> 
<p>set 容器默认排序规则为从小到大，掌握如何改变排序规则</p> 
<ul><li>利用仿函数，可以改变排序规则</li></ul> 
<pre><code class="prism language-c++">#include &lt;set&gt;
class MyCompare
{
public:
	bool operator()(int v1, int v2) const  
	{
		return v1 &gt; v2;  // 降序排序
	}
};

void test()
{
	// 存放内置数据类型，改变排序规则
	set&lt;int, MyCompare&gt; s1;  // 仿函数的本质是一个类
	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);
	for (set&lt;int, MyCompare&gt;::iterator it = s1.begin(); it != s1.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; endl;
	}
}
</code></pre> 
<blockquote> 
 <p>对于自定义的数据类型，要创建排序规则，必须要指定排序规则</p> 
 <pre><code class="prism language-c++">class MyCompare
{
public:	  
    bool operator()(const Person&amp; p1, const Person&amp; p2)
    {
        // 按照年龄降序
        return p1.m_Age &gt; p2.m_Age;
    }
};
</code></pre> 
</blockquote> 
<h3>
<a id="9_map__multimap__1953"></a>9、 map / multimap 容器</h3> 
<h4>
<a id="91_map__1955"></a>9.1 map 基本概念</h4> 
<p>简介：</p> 
<ul>
<li>map 中所有元素都是 pair</li>
<li>pair 中第一个元素为 key（键值），起到索引作用，第二个元素为 value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul> 
<p>本质：</p> 
<ul><li>map/ multimap 属于关联式容器，底层结构通过二叉树实现</li></ul> 
<p>优点：</p> 
<ul><li>可以根据 key 值快速找到 value 值</li></ul> 
<p>map/ multimap 区别</p> 
<ul>
<li>map 不允许容器中有重复 key 值元素</li>
<li>multimap 允许容器中有重复 key 值元素</li>
</ul> 
<h4>
<a id="92_map__1976"></a>9.2 map 构造和赋值</h4> 
<p>功能描述：</p> 
<ul><li>对 map 容器进行构造和赋值操作</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">map&lt;T1, T2&gt; mp;  // map 默认构造函数
map (const map&amp; mp);  // 拷贝构造

map&amp; operator=(const map&amp; mp);  // 重载赋值运算符
</code></pre> 
<blockquote> 
 <p>map 容器中所有元素都是成对出现的，插入数据的时候要使用对组</p> 
</blockquote> 
<h4>
<a id="93_map__1993"></a>9.3 map 大小和交换</h4> 
<p>功能描述：</p> 
<ul><li>对 map 容器大小以及交换 map 值</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">size();  // 返回容器中元素的数目
empty();  // 判断容量是否为空
swap(mp);  // 交换两个集合容器
</code></pre> 
<h4>
<a id="94_map__2007"></a>9.4 map 插入和删除</h4> 
<p>功能描述：</p> 
<ul><li>map 容器进行插入和删除数据</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">insert(elem);  // 在容器中插入元素
clear();  // 清空所有元素
erase(pos);  // 删除 pos 迭代器所指的元素，返回下一个元素的迭代器
erase(beg, end);  // 删除区间 [beg, end] 的所有元素，返回下一个元素的迭代器
erase(key);  // 删除容器键为 key 的元素
</code></pre> 
<blockquote> 
 <p>注意插入的是对组</p> 
 <pre><code class="prism language-c++">// 第一种
m.insert(pair&lt;int, int&gt;(1, 10));
// 第二种
m.insert(make_pair(2, 20));
// 第三种
m.insert(map&lt;int, int&gt;::value_type(3, 30));
// 第四种
m[4] = 40;  // 不建议使用，可以利用 [] 访问值
</code></pre> 
</blockquote> 
<h4>
<a id="95_map__2036"></a>9.5 map 查找和统计</h4> 
<p>功能描述：</p> 
<ul><li>对 map 容器进行查找数据和统计数据</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">find();  // 查找 key 是否存在，返回改键的元素的迭代值；若不存在，返回 m.end();
count();  // 统计 key 的元素个数
</code></pre> 
<h4>
<a id="96_map__2049"></a>9.6 map 排序</h4> 
<p>map 容器默认排序规则为按照键升序排序</p> 
<ul><li>利用仿函数可以改变排序规则</li></ul> 
<p>其和 [set 排序](#8.8 set 排序)类似</p> 
<h3>
<a id="10__2057"></a>10、 案例-员工分组</h3> 
<h4>
<a id="101__2059"></a>10.1 案例描述</h4> 
<ul>
<li>公司每天招聘10个员工，10名员工进入公司后，需要指派员工在哪个部门工作</li>
<li>员工信息：姓名、工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过 multimap 进行信息的插入 key：部门编号、value：员工</li>
<li>分部门显示员工</li>
</ul> 
<h4>
<a id="102__2067"></a>10.2 实现步骤</h4> 
<ol>
<li>创建10名员工，放到 vector 中</li>
<li>遍历 vector 容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中</li>
<li>分部门显示员工信息</li>
</ol> 
<h4>
<a id="103__2074"></a>10.3 代码演示</h4> 
<pre><code class="prism language-c++">class Worker
{
	// 创建员工
public:
	string m_Name;
	int m_Salary;
};
void createWorker(vector&lt;Worker&gt;&amp; v)
{
	// 创建10名员工
	for (int i = 0; i &lt; 10; i++)
	{
		Worker worker;
		string nameSeed = "ABCDEFGHIJ";
		worker.m_Name = "员工";
		worker.m_Name += nameSeed[i];
		worker.m_Salary = rand() % 10000 + 10000;  // 10000~19999
		v.push_back(worker);  // 将员工放入分组中
	}
}
void printWorker(const vector&lt;Worker&gt;&amp; v)
{
	for (vector&lt;Worker&gt;::const_iterator it = v.begin(); it != v.end(); it++)
	{
		cout &lt;&lt; "name: " &lt;&lt; it-&gt;m_Name &lt;&lt; "   salary: " &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;
	}
}
void printWorker(multimap&lt;string, Worker&gt;&amp; mp, string* arr)
{
	string s0(20, '-');
	for (int i = 0; i &lt; 3; i++)
	{
		string s = arr[i];
		s += "部门信息";
		cout &lt;&lt; s &lt;&lt; endl;
		multimap&lt;string, Worker&gt;::iterator pos = mp.find(arr[i]);  // 返回迭代器对象
		int count = mp.count(arr[i]);
		for (int index = 0; pos != mp.end() &amp;&amp; index &lt; count; pos++, index++)
		{
			cout &lt;&lt; "姓名：" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; "   工资：" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
		}
		cout &lt;&lt; s0 &lt;&lt; endl;
	}
}
void setGroup(vector&lt;Worker&gt;&amp; v, multimap&lt;string, Worker&gt;&amp; mp, string* arr)
{
	for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		// 产生随机部门编号
		int depId = rand() % 3;  // 0 1 2 随机数
		// 将员工插入到分组中，key编号，value员工
		mp.insert(pair&lt;string, Worker&gt;(arr[depId], *it));
	}
}
void test()
{
	// 添加随机种子
	srand((unsigned int)time(NULL));
	string dep[] = { "策划", "美术", "研发" };
	vector&lt;Worker&gt; v;
	createWorker(v);
	printWorker(v);

	// 员工分组
	multimap&lt;string, Worker&gt; mp;
	setGroup(v, mp, dep);
	printWorker(mp, dep);
}
</code></pre> 
<h2>
<a id="_STL__2147"></a>四、 STL 函数对象</h2> 
<h3>
<a id="1__2149"></a>1、 函数对象</h3> 
<h4>
<a id="11__2151"></a>1.1 基本概念</h4> 
<p>概念：</p> 
<ul>
<li>重载函数调用操作符的类，其对象常称为函数对象</li>
<li>函数对象使用重载的 () 时，行为类似函数调用，也叫仿函数</li>
</ul> 
<p>本质：</p> 
<ul><li>函数对象（仿函数）是一个类，不是一个函数</li></ul> 
<h4>
<a id="12__2162"></a>1.2 使用方法</h4> 
<p>特点：</p> 
<ul>
<li>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul> 
<pre><code class="prism language-c++">// 函数对象
class MyAdd
{
public:
	MyAdd()
	{
		this-&gt;count = 0;
	}
	int operator()(int v1, int v2)
	{
		this-&gt;count++;
		return v1 + v2;
	}
	int count;  // 函数对象可以有自己的内部状态
};
void test()
{
	MyAdd ma;
	cout &lt;&lt; ma(1, 2) &lt;&lt; endl;
	cout &lt;&lt; ma(1, 2) &lt;&lt; endl;
	cout &lt;&lt; ma(1, 2) &lt;&lt; endl;
	cout &lt;&lt; ma(1, 2) &lt;&lt; endl;
	cout &lt;&lt; "调用次数为：" &lt;&lt; ma.count &lt;&lt; endl;
}
</code></pre> 
<h3>
<a id="2__2197"></a>2、 谓词</h3> 
<h4>
<a id="21__2199"></a>2.1 谓词概念</h4> 
<p>概念</p> 
<ul>
<li>返回 bool 类型的仿函数称为谓词</li>
<li>如果 operator() 接受一个参数，那么叫做一元谓词</li>
<li>如果 operator() 接受两个参数，那么叫做二元谓词</li>
</ul> 
<h4>
<a id="22__2207"></a>2.2 一元谓词</h4> 
<pre><code class="prism language-c++">class CreateFive
{
public:
	bool operator()(int val)
	{
		return val &gt; 5 ? true : false;
	}  // 一元谓词

};

void test()
{
	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}
	// 查找容器中有么有大于5的数字
	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), CreateFive());  // 其为匿名函数对象，find_if 的返回值为一个迭代对象
	if (it == v.end())
	{
		cout &lt;&lt; "没有找到" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "大于五的数字为：" &lt;&lt; *it &lt;&lt; endl;
	}
}
</code></pre> 
<h4>
<a id="23__2240"></a>2.3 二元谓词</h4> 
<pre><code class="prism language-C++">// 二元谓词
class MySort
{
public:
	bool operator()(int a, int b)
	{
		return a &gt; b ? true : false;
	}
};
void test()
{
	vector&lt;int&gt; v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(30);
	v.push_back(40);
	v.push_back(50);
	// sort(v.begin(), v.end());  // 升序排列
	// 使用函数对象，改变算法策略，变为排序规则降序排列
	sort(v.begin(), v.end(), MySort());
	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}
</code></pre> 
<h3>
<a id="3__2271"></a>3、 内建函数对象</h3> 
<h4>
<a id="31__2273"></a>3.1 意义</h4> 
<p>概念：</p> 
<ul><li>STL 内建了一些函数对象</li></ul> 
<p>分类：</p> 
<ul>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul> 
<p>用法：</p> 
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件<code>#include &lt;functional&gt;</code>
</li>
</ul> 
<h4>
<a id="32__2290"></a>3.2 算术仿函数</h4> 
<p>功能描述：</p> 
<ul>
<li>实现四则运算</li>
<li>其中：negate 是一元运算，其他都是二元运算</li>
</ul> 
<p>仿函数原理</p> 
<pre><code class="prism language-c++">template&lt;class T&gt; T plus&lt;T&gt;;  // 加法运算
template&lt;class T&gt; T minus&lt;T&gt;;  // 减法运算
template&lt;class T&gt; T multiplies&lt;T&gt;;  // 乘法运算
template&lt;class T&gt; T divides&lt;T&gt;;  // 除法运算
template&lt;class T&gt; T modulus&lt;T&gt;;  // 取模运算
template&lt;class T&gt; T negate&lt;T&gt;;  // 取反运算，10 取反为 -10
</code></pre> 
<pre><code class="prism language-c++">plus&lt;int&gt; p;
cout &lt;&lt; p(10, 20) &lt;&lt; endl;
negate&lt;int&gt; n;
cout &lt;&lt; n(20) &lt;&lt; endl; 
</code></pre> 
<h4>
<a id="33__2315"></a>3.3 关系仿函数</h4> 
<p>功能描述</p> 
<ul><li>实现关系对比</li></ul> 
<p>仿函数原理</p> 
<pre><code class="prism language-c++">template&lt;class T&gt; bool equal_to&lt;T&gt;;  // =
template&lt;class T&gt; bool not_equal_to&lt;T&gt;;  // !=
template&lt;class T&gt; bool greater&lt;T&gt;;  // &gt;
template&lt;class T&gt; bool greater_equal&lt;T&gt;;  // &gt;=
template&lt;class T&gt; bool less&lt;T&gt;;  // &lt;
template&lt;class T&gt; bool less_equal&lt;T&gt;;  // &lt;=
</code></pre> 
<h4>
<a id="34__2332"></a>3.4 逻辑仿函数</h4> 
<p>功能描述</p> 
<ul><li>实现逻辑运算</li></ul> 
<p>仿函数原理</p> 
<pre><code class="prism language-c++">template&lt;typename T&gt; bool logical_and&lt;T&gt;;  // 与
template&lt;typename T&gt; bool logical_or&lt;T&gt;;  // 或
template&lt;typename T&gt; bool logical_not&lt;T&gt;;  // 非
</code></pre> 
<h2>
<a id="_STL__2346"></a>五、 STL 常用算法</h2> 
<p>描述：</p> 
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;&lt;functional&gt;&lt;numeric&gt;</code>组成</li>
<li>
<code>&lt;algorithm&gt;</code>是所有 STL 头文件中最大的一个，范围涉及到比较、交换、查找、遍历、赋值等等</li>
<li>
<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模块函数</li>
<li>
<code>&lt;functional&gt;</code>定义了一些模快类，用以声明函数对象</li>
</ul> 
<h3>
<a id="1__2355"></a>1、 常用遍历算法</h3> 
<p>学习目标：</p> 
<ul><li>掌握常用遍历算法</li></ul> 
<p>算法简介：</p> 
<pre><code class="prism language-c++">for_each();  // 遍历容器
transform();  // 搬运容器到另一个容器中
</code></pre> 
<h4>
<a id="11_for_each_2368"></a>1.1 for_each</h4> 
<p>功能描述：</p> 
<ul><li>实现遍历容器</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">for_each(iterator beg, iterator end, _func);
</code></pre> 
<blockquote> 
 <p>遍历算法：遍历容器元素</p> 
 <p>参数：</p> 
 <ul>
<li>beg：开始迭代器</li>
<li>end：结束迭代器</li>
<li>_func：函数或者函数对象，一般为输出内容的函数，回调函数</li>
</ul> 
</blockquote> 
<h4>
<a id="12_transform_2388"></a>1.2 transform</h4> 
<p>功能描述：</p> 
<ul><li>搬运容器到另一个容器中</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">transform(iterator beg1, iterator end1, iterator beg2, _func);
</code></pre> 
<blockquote> 
 <p>目标容器要提前开辟空间，否则会报错</p> 
 <p>参数：</p> 
 <ul>
<li>beg1：源容器开始迭代器</li>
<li>end1：源容器结束迭代器</li>
<li>beg2：目标容器开始迭代器</li>
<li>_func：函数或函数对象</li>
</ul> 
</blockquote> 
<h3>
<a id="2__2409"></a>2、 常用查找算法</h3> 
<p>学习目标：</p> 
<ul><li>掌握常用的查找算法</li></ul> 
<p>算法简介：</p> 
<pre><code class="prism language-c++">find();  // 查找元素
find_if();  // 按条件查找元素
adjacent_find();  // 查找相邻重复元素
binary_search();  // 二分查找法
count();  // 统计元素个数
count_if();  // 按条件统计元素个数
</code></pre> 
<h4>
<a id="21_find_2426"></a>2.1 find</h4> 
<p>功能描述：</p> 
<ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">find(iterator beg, iterator end, value);
</code></pre> 
<blockquote> 
 <p>参数：</p> 
 <ul>
<li>beg：开始迭代器</li>
<li>end：结束迭代器</li>
<li>value：查找的元素</li>
</ul> 
 <p>如果是自定义数据类型，查找时要重载等号运算符</p> 
</blockquote> 
<h4>
<a id="22_find_if_2446"></a>2.2 find_if</h4> 
<p>功能描述：</p> 
<ul><li>按条件查找元素</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">find_if(iterator beg, iterator end, _Pred);
</code></pre> 
<blockquote> 
 <p>参数：</p> 
 <ul>
<li>beg：起始迭代器</li>
<li>end：结束迭代器</li>
<li>_Pred：函数或者谓词（返回 bool 类型的仿函数）</li>
</ul> 
</blockquote> 
<h4>
<a id="23_adjacent_find_2464"></a>2.3 adjacent_find</h4> 
<p>功能描述：</p> 
<ul><li>查找相邻重复元素</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">adjacent_find(iterator beg, iterator end);
</code></pre> 
<blockquote> 
 <p>参数：</p> 
 <ul>
<li>beg：开始迭代器</li>
<li>end：结束迭代器</li>
</ul> 
</blockquote> 
<h4>
<a id="24_binary_search_2481"></a>2.4 binary_search</h4> 
<p>功能描述：</p> 
<ul><li>查找指定元素是否存在</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">bool binary_search(iterator beg, iterator end, value);
</code></pre> 
<blockquote> 
 <p>注意：在无序序列中不可用</p> 
 <p>参数：</p> 
 <ul>
<li>beg：开始迭代器</li>
<li>end：结束迭代器</li>
<li>value：查找的元素</li>
</ul> 
</blockquote> 
<h4>
<a id="25_count_2501"></a>2.5 count</h4> 
<p>功能描述：</p> 
<ul><li>统计元素个数</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">count(iterator beg, iterator end, value);
</code></pre> 
<blockquote> 
 <p>beg：开始迭代器</p> 
 <p>end：结束迭代器</p> 
 <p>value：统计的元素</p> 
</blockquote> 
<p>统计自定义数据类型时，要使用仿函数</p> 
<pre><code class="prism language-c++">class Person
{
public:
    Person(string name, int age)  
    {
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    }
    bool operator==(const Person&amp; p)  // 需要重载等号运算符，才可以统计
    {
        return this-&gt;m_Age == p.m_Age &amp;&amp; this-&gt;m_Name = p.m_Name? true : flase;
    }
    int m_Age;
    string m_Name;
};
</code></pre> 
<blockquote> 
 <p>统计自定义数据类型的时候，需要配合重载<code>operator==</code></p> 
</blockquote> 
<h4>
<a id="26_count_if_2541"></a>2.6 count_if</h4> 
<p>功能描述：</p> 
<ul><li>按条件统计元素个数</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">count_if(iterator beg, iterator end, _Pred);
</code></pre> 
<blockquote> 
 <p>参数：</p> 
 <ul>
<li>beg：开始迭代器</li>
<li>end：结束迭代器</li>
<li>_Pred：谓词</li>
</ul> 
</blockquote> 
<h3>
<a id="3__2559"></a>3、 常用排序算法</h3> 
<p>学习目标</p> 
<ul><li>掌握常用的排序算法</li></ul> 
<p>算法简介：</p> 
<pre><code class="prism language-c++">sort();  // 对容器内元素进行排序
random_shuffle();  // 洗牌，指定范围内的元素随机调整次序
merge();  // 容器元素合并，并存储到另一个容器中
reverse();  // 反转指定范围内的元素
</code></pre> 
<h4>
<a id="31_sort_2574"></a>3.1 sort</h4> 
<p>功能描述</p> 
<ul><li>对容器内元素进行排序</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">sort(iterator beg, iterator end, _Pred);
</code></pre> 
<blockquote> 
 <p>参数：</p> 
 <ul>
<li>beg：开始迭代器</li>
<li>end：结束迭代器</li>
<li>_Pred：谓词</li>
</ul> 
</blockquote> 
<h4>
<a id="32_random_shuffle_2592"></a>3.2 random_shuffle</h4> 
<p>功能描述</p> 
<ul><li>洗牌，指定范围内的元素随机调整次序</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">random_shuffle(iterator beg, iterator end);
</code></pre> 
<blockquote> 
 <p>使用时记得添加随机种子</p> 
 <pre><code class="prism language-c++">srand((unsigned int)time(NULL));
</code></pre> 
 <p>参数：</p> 
 <ul>
<li>beg：起始迭代器</li>
<li>end：结束迭代器</li>
</ul> 
</blockquote> 
<h4>
<a id="33_merge_2615"></a>3.3 merge</h4> 
<p>功能描述：</p> 
<ul><li>两个容器元素合并，并存储到另一个容器中</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
</code></pre> 
<blockquote> 
 <p>注意：</p> 
 <ul>
<li>两个容器必须是有序的</li>
<li>要提前给目标容器分配空间</li>
</ul> 
 <p>参数：</p> 
 <ul>
<li>beg1：容器1开始迭代器</li>
<li>end1：容器1结束迭代器</li>
<li>beg2：容器2开始迭代器</li>
<li>end2：容器2结束迭代器</li>
<li>dest：目标容器开始迭代器</li>
</ul> 
</blockquote> 
<h4>
<a id="34_reverse_2640"></a>3.4 reverse</h4> 
<p>功能描述</p> 
<ul><li>将容器内元素进行反转</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">reverse(iterator beg, iterator end);
</code></pre> 
<blockquote> 
 <p>参数：</p> 
 <ul>
<li>beg：开始迭代器</li>
<li>end：结束迭代器</li>
</ul> 
</blockquote> 
<h3>
<a id="4__2657"></a>4、 常用拷贝和替换算法</h3> 
<p>学习目标</p> 
<ul><li>掌握常用的拷贝和替换算法</li></ul> 
<p>算法简介</p> 
<pre><code class="prism language-c++">copy();  // 容器内指定范围内的元素拷贝到另一个容器中
replace();  // 将容器内指定范围的旧元素修改为新元素
replace_if();  // 容器内指定范围满足条件的元素替换为新元素
swap();  // 互换两个容器的元素
</code></pre> 
<h4>
<a id="41_copy_2672"></a>4.1 copy</h4> 
<p>功能描述：</p> 
<ul><li>容器内指定范围的元素拷贝到另一个容器中</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">copy(iterator beg, iterator end, iterator dest);
</code></pre> 
<blockquote> 
 <p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p> 
 <p>需要先预定目标容器的空间</p> 
 <p>参数：</p> 
 <ul>
<li>beg：开始迭代器</li>
<li>end：结束迭代器</li>
<li>dest：目标容器起始迭代器</li>
</ul> 
</blockquote> 
<h4>
<a id="42_replace_2694"></a>4.2 replace</h4> 
<p>功能描述</p> 
<ul><li>将容器内指定范围内的旧元素修改为新元素</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">replace(iterator beg, iterator end, oldvalue, newvalue);
</code></pre> 
<blockquote> 
 <p>它会替换区间内所有满足条件的元素</p> 
 <p>参数：</p> 
 <ul>
<li>beg：起始迭代器</li>
<li>end：结束迭代器</li>
<li>oldvalie：旧元素</li>
<li>newvalue：新元素</li>
</ul> 
</blockquote> 
<h4>
<a id="43_replace_if_2715"></a>4.3 replace_if</h4> 
<p>功能用法</p> 
<ul><li>将区间内满足条件的元素，替换成特定元素</li></ul> 
<p>函数原理</p> 
<pre><code class="prism language-c++">replace_if(iterator beg, iterator end, _Pred, newvalue);
</code></pre> 
<blockquote> 
 <p>它会替换区间内所有满足条件的元素</p> 
 <p>参数：</p> 
 <ul>
<li>beg：起始迭代器</li>
<li>end：结束迭代器</li>
<li>_Pred：谓词</li>
<li>newvalue：替换的新元素</li>
</ul> 
</blockquote> 
<h4>
<a id="44_swap_2736"></a>4.4 swap</h4> 
<p>功能描述：</p> 
<ul><li>互换两个容器的元素</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">swap(container c1, container c2);
</code></pre> 
<blockquote> 
 <p>同种数据类型的容器才能互换</p> 
 <p>参数：</p> 
 <ul>
<li>c1：容器1</li>
<li>c2：容器2</li>
</ul> 
</blockquote> 
<h3>
<a id="5__2755"></a>5、 常用算术生成算法</h3> 
<p>学习目标</p> 
<ul><li>掌握常用的算术生成算法</li></ul> 
<p>注意：</p> 
<ul><li>算术生成算法属于小型算法，使用时需要包含的头文件为<code>#include &lt;numeric&gt;</code>
</li></ul> 
<p>算法简介</p> 
<pre><code class="prism language-c++">accumulate();  // 计算容器元素累计总和
fill();  // 向容器中添加元素
</code></pre> 
<h4>
<a id="51_accumulate_2772"></a>5.1 accumulate</h4> 
<p>功能描述：</p> 
<ul><li>计算区间内元素的总和</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">accumulate(iterator beg, iterator end, firstValue);
</code></pre> 
<blockquote> 
 <p>参数：</p> 
 <ul>
<li>beg：起始迭代器</li>
<li>end：结束迭代器</li>
<li>firstValue：起始累加值</li>
</ul> 
</blockquote> 
<h4>
<a id="52_fill_2790"></a>5.2 fill</h4> 
<p>功能描述：</p> 
<ul><li>向容器中填充指定的元素</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">fill(iterator beg, iterator end, value);
</code></pre> 
<blockquote> 
 <p>参数：</p> 
 <ul>
<li>beg：开始迭代器</li>
<li>end：结束迭代器</li>
<li>value：填充的值</li>
</ul> 
</blockquote> 
<h3>
<a id="6__2808"></a>6、 常用集合算法</h3> 
<p>学习目标：</p> 
<ul><li>掌握常用的集合算法</li></ul> 
<p>算法简介</p> 
<pre><code class="prism language-c++">set_insersection();  // 求两个容器的交集
set_union();  // 求两个容器的并集
set_different();  // 求两个容器的差集
</code></pre> 
<h4>
<a id="61_set_insersection_2822"></a>6.1 set_insersection</h4> 
<p>功能描述：</p> 
<ul><li>求两个容器的交集，重复的元素</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">iterator itEnd = set_insersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  // 交集，返回最后一个值的迭代器
</code></pre> 
<blockquote> 
 <p>需要提前开辟空间，最特殊的情况：大容器包含小容器，开辟空间，取小容器的 size 即可</p> 
 <pre><code class="prism language-c++">dest.resize(c1.size() &gt; c2.size() ? c2.size() : c1.size());
</code></pre> 
 <p>参数：</p> 
 <ul>
<li>beg1：容器1开始迭代器</li>
<li>end1：容器1结束迭代器</li>
<li>beg2：容器2开始迭代器</li>
<li>end2：容器2结束迭代器</li>
<li>dest：目标容器开始迭代器</li>
</ul> 
</blockquote> 
<h4>
<a id="62_set_union_2848"></a>6.2 set_union</h4> 
<p>功能描述：</p> 
<ul><li>求两个容器的并集</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">iterator itEnd = set_insersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  // 并集，返回最后一个值的迭代器
</code></pre> 
<blockquote> 
 <p>目标容器要提前开辟空间，最特殊的情况是两个容器没有交集</p> 
 <pre><code class="prism language-c++">dest.resize(c1.size() + c2.size());
</code></pre> 
 <p>参数：</p> 
 <ul>
<li>beg1：容器1开始迭代器</li>
<li>end1：容器1结束迭代器</li>
<li>beg2：容器2开始迭代器</li>
<li>end2：容器2结束迭代器</li>
<li>dest：目标容器开始迭代器</li>
</ul> 
</blockquote> 
<h4>
<a id="63_set_difference_2874"></a>6.3 set_difference</h4> 
<p>功能描述：</p> 
<ul><li>求两个容器的差集</li></ul> 
<p>函数原型</p> 
<pre><code class="prism language-c++">iterator itEnd = set_insersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  // c1 和 c2 的差集，返回最后一个值的迭代器，c1 - c2
</code></pre> 
<blockquote> 
 <p>目标容器要提前开辟空间，最特殊的情况是两个容器没有交集，取 size 大的作为容器的空间</p> 
 <pre><code class="prism language-c++">dest.resize(c1.size() &gt; c2.size() ? c1.size() : c2.size());  // 也可以使用 max(c1.size(), c2.size());
</code></pre> 
 <p>参数：</p> 
 <ul>
<li>beg1：容器1开始迭代器</li>
<li>end1：容器1结束迭代器</li>
<li>beg2：容器2开始迭代器</li>
<li>end2：容器2结束迭代器</li>
<li>dest：目标容器开始迭代器</li>
</ul> 
</blockquote>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>