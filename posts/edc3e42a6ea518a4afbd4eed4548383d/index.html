<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>c&#43;&#43;指针最全总结(附源码和详细总结) - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;指针最全总结(附源码和详细总结)</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px"></p> 
<p id="%E5%93%88%E5%96%BD%EF%BC%8C%E6%88%91%E5%8F%88%E6%9D%A5%E5%95%A6%F0%9F%98%84-toc" style="margin-left:0px"><a href="#%E5%93%88%E5%96%BD%EF%BC%8C%E6%88%91%E5%8F%88%E6%9D%A5%E5%95%A6%F0%9F%98%84">哈喽，我又来啦?</a></p> 
<p id="%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FWhat%20is%20a%20pointer%EF%BC%9F-toc" style="margin-left:0px"><a href="#%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FWhat%20is%20a%20pointer%EF%BC%9F">指针是什么？What is a pointer？</a></p> 
<p id="%E7%AE%80%E5%8D%95%E7%82%B9%E8%AF%B4-toc" style="margin-left:40px"><a href="#%E7%AE%80%E5%8D%95%E7%82%B9%E8%AF%B4">简单点说</a></p> 
<p id="%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px"><a href="#%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89">一级指针的定义</a></p> 
<p id="%E6%8C%87%E9%92%88%E7%9A%84%E8%B5%8B%E5%80%BC-toc" style="margin-left:0px"><a href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%B5%8B%E5%80%BC">指针的赋值</a></p> 
<p id="%E6%8C%87%E9%92%88%E7%9A%84%E8%BE%93%E5%87%BA-toc" style="margin-left:0px"><a href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%BE%93%E5%87%BA">指针的输出</a></p> 
<p id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89">二级指针的定义</a></p> 
<p id="%E7%AE%80%E5%8D%95%E8%AF%B4-toc" style="margin-left:40px"><a href="#%E7%AE%80%E5%8D%95%E8%AF%B4">简单说</a></p> 
<p id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E8%B5%8B%E5%80%BC-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E8%B5%8B%E5%80%BC">二级指针的赋值</a></p> 
<p id="-toc" style="margin-left:0px"></p> 
<p id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E8%BE%93%E5%87%BA-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E8%BE%93%E5%87%BA">二级指针的输出</a></p> 
<p id="%E6%94%B9%E5%8F%98%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91-toc" style="margin-left:0px"><a href="#%E6%94%B9%E5%8F%98%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91">改变一级指针指向</a></p> 
<p id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E6%AD%A5%E9%95%BF-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E6%AD%A5%E9%95%BF">二级指针的步长</a></p> 
<p id="%E6%94%B9%E5%8F%98n-1%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E5%90%91-toc" style="margin-left:0px"><a href="#%E6%94%B9%E5%8F%98n-1%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E5%90%91">改变n-1级指针的指向</a></p> 
<p id="%E5%BD%93%E6%8C%87%E9%92%88%E9%81%87%E4%B8%8A%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px"><a href="#%E5%BD%93%E6%8C%87%E9%92%88%E9%81%87%E4%B8%8A%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">当指针遇上函数重载</a></p> 
<p id="%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px"><a href="#%E7%A8%8B%E5%BA%8F">程序</a></p> 
<p id="new%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:0px"><a href="#new%E7%9A%84%E7%94%A8%E6%B3%95">new的用法</a></p> 
<p id="%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84-toc" style="margin-left:0px"><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">指针和数组</a></p> 
<p id="%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8-toc" style="margin-left:40px"><a href="#%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8">普通方法遍历列表</a></p> 
<p id="%E7%94%A8%E6%8C%87%E9%92%88%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8-toc" style="margin-left:40px"><a href="#%E7%94%A8%E6%8C%87%E9%92%88%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8">用指针遍历列表</a></p> 
<p id="%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0-toc" style="margin-left:40px"><a href="#%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0">用指针访问数组元素</a></p> 
<p id="%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:0px"><a href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">指针数组</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88-toc" style="margin-left:0px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88">结构体指针</a></p> 
<p id="%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:40px"><a href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93">定义结构体</a></p> 
<p id="%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px"><a href="#%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F">一般结构体变量的访问方式</a></p> 
<p id="%E6%B1%82%E6%8C%87%E9%92%88%E7%9A%84%E5%86%85%E5%AD%98-toc" style="margin-left:0px"><a href="#%E6%B1%82%E6%8C%87%E9%92%88%E7%9A%84%E5%86%85%E5%AD%98">求指针的内存</a></p> 
<p id="%E5%81%9A%E7%82%B9%E7%BB%83%E4%B9%A0%E9%A2%98-toc" style="margin-left:0px"><a href="#%E5%81%9A%E7%82%B9%E7%BB%83%E4%B9%A0%E9%A2%98">做点练习题</a></p> 
<p id="%E9%80%89%E6%8B%A9%E9%A2%98-toc" style="margin-left:40px"><a href="#%E9%80%89%E6%8B%A9%E9%A2%98">选择题</a></p> 
<p id="%E7%BC%96%E7%A8%8B%E9%A2%98-toc" style="margin-left:40px"><a href="#%E7%BC%96%E7%A8%8B%E9%A2%98">编程题</a></p> 
<p id="1.%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9-toc" style="margin-left:80px"><a href="#1.%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9">1.考试成绩</a></p> 
<p id="%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9%EF%BC%882%EF%BC%89-toc" style="margin-left:80px"><a href="#%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9%EF%BC%882%EF%BC%89">考试成绩（2）</a></p> 
<p id="%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E9%97%B4%E6%8E%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px"><a href="#%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E9%97%B4%E6%8E%A5%E6%8E%92%E5%BA%8F">通过指针间接排序</a></p> 
<p id="%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E9%97%B4%E6%8E%A5%E6%8E%92%E5%BA%8F%EF%BC%882%EF%BC%89-toc" style="margin-left:80px"><a href="#%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E9%97%B4%E6%8E%A5%E6%8E%92%E5%BA%8F%EF%BC%882%EF%BC%89">通过指针间接排序（2）</a></p> 
<p id="%E9%A6%85%E9%A5%BC%E5%90%83%E8%B4%A7%E5%8F%AF%E7%9F%A5%E5%90%A6-toc" style="margin-left:80px"><a href="#%E9%A6%85%E9%A5%BC%E5%90%83%E8%B4%A7%E5%8F%AF%E7%9F%A5%E5%90%A6">馅饼吃货可知否</a></p> 
<p id="%E6%9C%80%E5%90%8E-toc" style="margin-left:0px"><a href="#%E6%9C%80%E5%90%8E">最后</a></p> 
<hr id="hr-toc">
<p></p> 
<h1 id="%E5%93%88%E5%96%BD%EF%BC%8C%E6%88%91%E5%8F%88%E6%9D%A5%E5%95%A6%F0%9F%98%84">哈喽，我又来啦?</h1> 
<blockquote> 
 <p>hello?</p> 
 <p>我是「<span style="color:#79c6cd"> YR_T</span> 」</p> 
 <p>众所周知</p> 
 <p>c++相对于其它语言的</p> 
 <p>优势就在与c++有<span style="color:#ffd900"><span style="background-color:#0d0016">「 指针 」</span></span></p> 
 <p>可能你之前有学习过指针</p> 
 <p><span style="color:#6eaad7">可是</span></p> 
 <p>你真的把指针<span style="color:#9c8ec1"><span style="background-color:#fbd4d0">彻底搞懂</span></span>了吗?</p> 
 <p>如果还没有，那再来复习一下?</p> 
 <p><img alt="" height="240" src="https://images2.imgbox.com/4b/8a/ALMVvTmf_o.gif" width="240"><img alt="" height="240" src="https://images2.imgbox.com/c6/ad/QBrQ3ruC_o.jpg" width="240"> </p> 
 <p><span style="color:#fe2c24">这篇文章但凡是和指针沾点边的，都加进来了</span></p> 
</blockquote> 
<h1 id="%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FWhat%20is%20a%20pointer%EF%BC%9F">指针是什么？What is a pointer？</h1> 
<p><strong><span style="color:#fe2c24">指针是变量在内存中的地址</span>(A pointer is the memory address of a variable)</strong></p> 
<p><strong>这个<span style="color:#fe2c24">很重要</span></strong></p> 
<p>首先，来看一下<span style="background-color:#e7fafa">内存空间</span>(图片来源于网络)</p> 
<p><img alt="" src="https://images2.imgbox.com/9d/6c/VFrSqgg5_o.png"></p> 
<h2 id="%E7%AE%80%E5%8D%95%E7%82%B9%E8%AF%B4">简单点说</h2> 
<p>比如你有一个<span style="color:#ed7976">int类型的变量，里面的内容是10</span></p> 
<p>把这个变量的地址保存在指针里，<span style="color:#fe2c24">注意了</span>，<span style="color:#4da8ee">指针里面保存的不是这个变量本身，而是变量在内存中的地址</span></p> 
<p>比如你要买一本书，你去了图书馆，查到了这本书在<span style="color:#ff9900">0x6ffe04</span>位置上</p> 
<p><span style="color:#38d8f0">你拿到了这个位置，并不代表你拿到了这本书，你要通过这个位置来找到这本书</span></p> 
<p>这下懂了吧</p> 
<h1 id="%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89">一级指针的定义</h1> 
<pre><code class="language-cpp">int *p;//语法：类型 * 指针变量名;</code></pre> 
<h1 id="%E6%8C%87%E9%92%88%E7%9A%84%E8%B5%8B%E5%80%BC">指针的赋值</h1> 
<p>由于指针里存的是变量的地址，看这个程序</p> 
<pre><code class="language-cpp">
int *p;//定义一个指针
p=&amp;a;//&amp;是取址符

//或者
int *p=&amp;a;</code></pre> 
<h1 id="%E6%8C%87%E9%92%88%E7%9A%84%E8%BE%93%E5%87%BA">指针的输出</h1> 
<p>我们写这样一个程序</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
	int a=10;
	int *p=&amp;a;
	cout&lt;&lt;"指针p:"&lt;&lt;*p&lt;&lt;endl&lt;&lt;"a的地址:"&lt;&lt;&amp;a&lt;&lt;endl&lt;&lt;"a:"&lt;&lt;a;
	return 0;
}</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-cpp">指针p:10
a的地址:0x6ffe04
a:10
--------------------------------
Process exited after 0.04383 seconds with return value 0
请按任意键继续. . .</code></pre> 
<p><span style="background-color:#cbe0f1">可以看到，我们如果要输出a</span></p> 
<p><span style="background-color:#cbe0f1">不管是通过指针输出还是直接输出变量a结果是<span style="color:#fe2c24">一样</span>的</span></p> 
<h1 id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89">二级指针的定义</h1> 
<p>看这张图</p> 
<p><img alt="" src="https://images2.imgbox.com/0a/ab/seIgciF3_o.png"></p> 
<h2 id="%E7%AE%80%E5%8D%95%E8%AF%B4">简单说</h2> 
<p>简单说，二级指针就是指针的指针，二级指针里存放的是指针的地址</p> 
<h1 id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E8%B5%8B%E5%80%BC">二级指针的赋值</h1> 
<h1></h1> 
<p>二级指针的赋值和一级指针一样</p> 
<pre><code class="language-cpp">int a=10;
int *pi=&amp;a;
int **pi=&amp;pi;</code></pre> 
<h1 id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E8%BE%93%E5%87%BA">二级指针的输出</h1> 
<p>我们写这样一个程序</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
	int a=10;
	int *p=&amp;a;
	int **pp=&amp;p;
	cout&lt;&lt;"*p:"&lt;&lt;*p&lt;&lt;endl&lt;&lt;"&amp;a:"&lt;&lt;&amp;a&lt;&lt;endl&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl&lt;&lt;"**pp:"&lt;&lt;**pp&lt;&lt;endl&lt;&lt;"&amp;pp:"&lt;&lt;&amp;pp&lt;&lt;endl&lt;&lt;"&amp;p:"&lt;&lt;&amp;p;
	return 0;
}</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-cpp">*p:10
&amp;a:0x6ffdfc
a:10
**pp:10
&amp;pp:0x6ffde8
&amp;p:0x6ffdf0
--------------------------------
Process exited after 0.06748 seconds with return value 0
请按任意键继续. . .</code></pre> 
<p>由此可见，二级指针和一级指针的输出是一样的</p> 
<h1 id="%E6%94%B9%E5%8F%98%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91">改变一级指针指向</h1> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
 
using namespace std;
 
int main()
{
	int i = 30;
 
	int *pi = &amp;i;
	std::cout &lt;&lt; "一级指针*pi = " &lt;&lt; *pi &lt;&lt; std::endl;       //一级指针
 
	int **ppi = &amp;pi;
	std::cout &lt;&lt; "二级指针**ppi = " &lt;&lt; **ppi &lt;&lt; std::endl;   //二级指针
 
	*pi = 20;
	std::cout &lt;&lt; "改变一级指针内容： *pi = " &lt;&lt; *pi &lt;&lt; std::endl;  //改变一级指针值
	std::cout &lt;&lt; "一级指针*pi = " &lt;&lt; *pi &lt;&lt; std::endl;       //二级指针
 
	int b = 10;
	*ppi = &amp;b;
	std::cout &lt;&lt; "改变一级指针指向*pi = " &lt;&lt; *pi &lt;&lt; std::endl;   //改变一级指针的指向
	std::cout &lt;&lt; "二级指针**ppi = " &lt;&lt; **ppi &lt;&lt; std::endl;   
 
	system("pause");
	return 0;
}</code></pre> 
<p>运行结果</p> 
<pre><code class="language-cpp">一级指针*pi = 30
二级指针**ppi = 30
改变一级指针内容： *pi = 20
一级指针*pi = 20
改变一级指针指向*pi = 10
二级指针**ppi = 10
请按任意键继续. . .

--------------------------------
Process exited after 3.002 seconds with return value 0
请按任意键继续. . .</code></pre> 
<h1 id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E6%AD%A5%E9%95%BF">二级指针的步长</h1> 
<p>所有类型的二级指针，由于均指向一级指针类型，一级指针类型大小是 4，所以二级指针的步长也是 4，<strong>这个信息很重要</strong>。</p> 
<h1 id="%E6%94%B9%E5%8F%98n-1%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E5%90%91">改变n-1级指针的指向</h1> 
<ul>
<li>可以通过一级指针，修改 0  级指针（变量）的内容。</li>
<li>可以通过二级指针，修改一级指针的指向。</li>
<li>可以通过三级指针，修改二级指针的指向。</li>
<li> ·····</li>
<li>可以通过 n  级指针，修改 n-1 </li>
</ul>
<h1 id="%E5%BD%93%E6%8C%87%E9%92%88%E9%81%87%E4%B8%8A%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">当指针遇上函数重载</h1> 
<p>C++<a href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&amp;spm=1001.2101.3001.7020" title="编译器">编译器</a>会按照函数指针的类型<span style="background-color:#a2e043">自动选择重载函数</span></p> 
<h2 id="%E7%A8%8B%E5%BA%8F">程序</h2> 
<p>看这个程序</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;
 
void print(int a)
{
    cout &lt;&lt; "a is " &lt;&lt; a &lt;&lt; endl;
}
void print()
{
    cout &lt;&lt; "hello world" &lt;&lt; endl;
}
 
typedef void (* Fun)(int);
typedef void (* Fun2)();
 
int main()
{
    Fun pPrint = print; 
    Fun2 pPrint2 = print;
    pPrint(12);
    pPrint2();
    return 0;
}</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-cpp">a is 12
hello world</code></pre> 
<p>重载函数作为参数传递时，特别形参的类型不是确定的函数指针类型时，如void *，例如<span style="color:#f3f3f4"><span style="background-color:#38d8f0">Qt</span></span>中的<span style="color:#4da8ee">QObject::connect()</span>函数，重载的信号或槽传入到<span style="color:#38d8f0">connect</span>时，可以使用<span style="color:#4da8ee">static_cast&lt;&gt;</span>来区别重载函数：</p> 
<pre><code class="language-cpp">connect(subWidget, static_cast&lt;void(SubWidget::*)()&gt;(&amp;SubWidget::switchWin), this, &amp;MainWidget::switchWinSlot);</code></pre> 
<p>connect()函数的第2个和第4个形参都是const char *类型，不是指定好的函数指针类型，所以我们可以通过static&lt;&gt;来区分重载函数的版本。</p> 
<h1 id="new%E7%9A%84%E7%94%A8%E6%B3%95">new的用法</h1> 
<p><span style="color:#79c6cd"><span style="background-color:#fefcd8">new其实就是告诉计算机开辟一段新的空间，但是和一般的声明不同的是，new开辟的空间在堆上，而一般声明的变量存放在栈上。通常来说，当在局部函数中new出一段新的空间，该段空间在局部函数调用结束后仍然能够使用，可以用来向主函数传递参数。另外需要注意的是，new的使用格式，new出来的是一段空间的首地址。所以一般需要用指针来存放这段地址</span></span><span style="color:#dad5e9">。</span></p> 
<p><span style="color:#0d0016"><span style="background-color:#efedf6">练练英语：</span></span></p> 
<p><span style="color:#a2e043">New tells the computer to create a new space, but unlike the normal declaration, the space created by new is on the heap, while the normal declaration variables are stored on the stack. In general, when a new segment of space is created in a local function, that segment of space can be used after the local function call ends and can be used to pass arguments to the main function. Another thing to note is the format of the new, which is the first address of a space. So you usually have to use a pointer to store this address.</span></p> 
<p>具体的代码如下：<br>  </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
int example1()
{
  //可以在new后面直接赋值
  int *p = new int(3);
  //也可以单独赋值
  //*p = 3;
 
  //如果不想使用指针，可以定义一个变量，在new之前用“*”表示new出来的内容
  int q = *new int;
  q = 1;
  cout &lt;&lt; q &lt;&lt; endl;
 
  return *p;
}
 
int* example2()
{
  //当new一个数组时，同样用一个指针接住数组的首地址
  int *q = new int[3];
  for(int i=0; i&lt;3; i++)
    q[i] = i;
 
  return q;
}
 
struct student
{
  string name;
  int score;
};
 
 
student* example3()
{
  //这里是用一个结构体指针接住结构体数组的首地址
  //对于结构体指针，个人认为目前这种赋值方法比较方便
  student *stlist = new student[3]{<!-- -->{"abc", 90}, {"bac", 78}, {"ccd", 93}};
 
  return stlist;
}
 
 
 
int main()
{
  int e1 = example1();
  cout &lt;&lt;"e1: "&lt;&lt; e1 &lt;&lt; endl;
 
  int *e2 = example2();
  for(int i=0; i&lt;3; i++)
    cout &lt;&lt; e2[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
 
 
  student *st1 = example3();
 
  for(int i=0; i&lt;3; i++)
    cout &lt;&lt; st1[i].name &lt;&lt; " " &lt;&lt; st1[i].score &lt;&lt; endl;
 
 
 
  return 0;
}</code></pre> 
<p>运行结果</p> 
<pre><code class="language-cpp">1
e1: 3
0 1 2
abc 90
bac 78
ccd 93

--------------------------------
Process exited after 0.06289 seconds with return value 0
请按任意键继续. . .</code></pre> 
<h1 id="%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">指针和数组</h1> 
<h2 id="%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8">普通方法遍历列表</h2> 
<pre><code class="language-cpp">int i, a[] = {3,4,5,6,7,3,7,4,4,6};
for (i = 0; i &lt;= 9; i++)
{
    std::cout &lt;&lt; a[i] std::endl;
}</code></pre> 
<h2 id="%E7%94%A8%E6%8C%87%E9%92%88%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8">用指针遍历列表</h2> 
<pre><code class="language-cpp">int i, a[] = {3,4,5,6,7,3,7,4,4,6};
for (i = 0; i &lt;= 9; i++)
{
std::cout &lt;&lt; *(a+i) &lt;&lt; std&lt;&lt;endl;;
}</code></pre> 
<p>这两种的效果是<span style="color:#fe2c24">一毛一样</span>的</p> 
<h2 id="%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0">用指针访问数组元素</h2> 
<pre><code class="language-cpp">int i, *pa, a[] = {3,4,5,6,7,3,7,4,4,6};
pa = a; 
for (i = 0; i &lt;= 9; i++)

{
 std::cout &lt;&lt;  pa[i] &lt;&lt; std::endl;
}
</code></pre> 
<h1 id="%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">指针数组</h1> 
<p>指针数组的本质是数组，数组中每一个成员是一个指针。定义形式如下：<br><span style="color:#6eaad7"><span style="background-color:#fbd4d0">char * pArray[10];</span></span><br> 语法解析：pArray 先与“[ ]”结合，构成一个数组的定义,char *修饰的是数组的内容，即数组的每个元素。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
 
using namespace std;
 
int main()
{
	char * pArray[] ={"apple","pear","banana","orange","pineApple"};
	for(int i=0; i&lt;sizeof(pArray)/sizeof(*pArray); i++)
	{
		std::cout &lt;&lt; pArray[i] &lt;&lt; std::endl;
	} 
 
	system("pause");
	return 0;
}</code></pre> 
<p>运行结果</p> 
<pre><code class="language-cpp">apple
pear
banana
orange
pineApple
请按任意键继续. . .

--------------------------------
Process exited after 1.655 seconds with return value 0
请按任意键继续. . .</code></pre> 
<h1 id="%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88">结构体指针</h1> 
<p>c++<a href="https://so.csdn.net/so/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&amp;spm=1001.2101.3001.7020" title="结构体">结构体</a>指针，顾名思义就是指向结构体的一个指针</p> 
<h2 id="%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93">定义结构体</h2> 
<pre><code class="language-cpp">struct My{
    My *left;
    My *right;
    int val;
    My(){}
    My(int val):left(NULL),right(NULL),val(val){}
};</code></pre> 
<h2 id="%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F">一般结构体变量的访问方式</h2> 
<pre><code class="language-cpp">void test1(){
    My m;
    m.val = 1;
    cout&lt;&lt;m.val&lt;&lt;endl;
}</code></pre> 
<p>可见，结构体中的变量，可以直接通过点操作符来访问。</p> 
<p>而对于结构体指针而言：必须通过<span style="background-color:#38d8f0">-&gt;</span>符号来访问指针所指结构体的变量。</p> 
<pre><code class="language-cpp">void test2(){
    My m;
    m.val = 1;
    My *mm;
    mm = &amp;m;
    cout&lt;&lt;mm-&gt;val&lt;&lt;endl;
}</code></pre> 
<p>声明一个结构体指针<span style="color:#fe2c24">记得初始化，记得初始化，记得初始化</span></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/42/a3/JGqxxAul_o.jpg" width="240"></p> 
<p></p> 
<pre><code class="language-cpp">void test3(){
    My *m;
    m = new My(3);
    m-&gt;val = 4;
    cout&lt;&lt;m-&gt;val&lt;&lt;endl;
}</code></pre> 
<p>这就是new的应用，用法上面已将讲过了</p> 
<h1 id="%E6%B1%82%E6%8C%87%E9%92%88%E7%9A%84%E5%86%85%E5%AD%98">求指针的内存</h1> 
<p>cout &lt;&lt; sizeof(pn) &lt;&lt; endl;//4<br> cout &lt;&lt; sizeof(&amp;n[0]) &lt;&lt; endl;//4</p> 
<h1 id="%E5%81%9A%E7%82%B9%E7%BB%83%E4%B9%A0%E9%A2%98">做点练习题</h1> 
<p>学了这么多，不如做点题吧</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/3c/82/AddchQvc_o.gif" width="240"></p> 
<p> 对了，前面的选择题不是只有指针的，编程题是关于指针</p> 
<h2 id="%E9%80%89%E6%8B%A9%E9%A2%98">选择题</h2> 
<p><span style="color:#fe2c24">看答案和解析的方法如下</span></p> 
<pre><code class="language-cpp">if(你是PC端){
    鼠标选中蓝色区域看答案和解析();
}
else if(你是APP端){
    复制蓝色区域里的内容随便粘贴到一个地方看答案和解析();
}
else{
    cout&lt;&lt;"还有其它的吗?!?!?!?";
}</code></pre> 
<p>在<a href="https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&amp;spm=1001.2101.3001.7020" title="面向对象">面向对象</a>方法中，不属于“对象”基本特点的是( <span style="color:#79c6cd"><span style="background-color:#79c6cd">  A      </span></span>)。（3分）</p> 
<p>A) 一致性<br> B) 分类性<br> C) 多态性<br> D) 标识唯一性</p> 
<p>[解析] <span style="color:#79c6cd"><span style="background-color:#79c6cd">本题考查的是对象的基本特点。对象具有标识唯一性、分类性、多态性、封装性和模块独立性好这5个基本特点，所以本题应该选择A。</span></span></p> 
<p>对类的<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" title="构造函数">构造函数</a>和析构函数描述正确的是(<span style="color:#79c6cd"><span style="background-color:#79c6cd">A</span></span>)。（3分）<br>   A. 构造函数可以重载，<a href="https://so.csdn.net/so/search?q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" title="析构函数">析构函数</a>不能重载<br>   B. 构造函数不能重载，析构函数可以重载<br>   C. 构造函数可以重载，析构函数也可以重载<br>   D. 构造函数不能重载，析构函数也不能重裁</p> 
<p>[解析]<span style="color:#79c6cd"><span style="background-color:#79c6cd">一个类中只能定义一个析构函数，否则会造成对同…对象的多次删除；而构造函数可以根据不同的参数个数和类型进行多次重载。</span></span></p> 
<p>C++系统预定义了4个用于标准数据流的对象，下列选项中不属于此类对象的是(<span style="color:#79c6cd"><span style="background-color:#79c6cd">D</span></span>)。（3分）<br>           A. cout<br>           B. cin<br>           C. cerr<br>           D. cset</p> 
<p>[解析]<span style="color:#79c6cd"><span style="background-color:#79c6cd">cin:标准输入 cout:标准输出 cerr:标准错误输出，无缓冲区 clog:同上，标准错误流，有缓冲区</span></span></p> 
<p>下列情况中，不会调用拷贝构造函数的是（<span style="color:#79c6cd"><span style="background-color:#79c6cd">B</span></span>）。（3分）<br>         A. 用一个对象去初始化同一类的另一个新对象时<br>         B. 将类的一个对象赋值给该类的另一个对象时<br>         C. 函数的形参是类的对象，调用函数进行形参和实参结合时<br>         D. 函数的返回值是类的对象，函数执行返回调用时<br> [解析]<span style="color:#79c6cd"><span style="background-color:#79c6cd">一般用重载=运算符</span></span></p> 
<p></p> 
<p>有如下类定义：</p> 
<pre><code class="language-cpp">class Foo
{
public:
          Foo(int v):value(V){  }     //①
          ~Foo(){}                            //②
private:
          Foo(){}                               //③
          int value=0;                      //④
};</code></pre> 
<p>其中存在语法错误的行是（　<span style="color:#79c6cd"><span style="background-color:#79c6cd">　D  </span></span> ）。（3分）<br>           A. ①<br>           B. ②<br>           C. ③ <br>           D. ④<br> [解析]<span style="color:#79c6cd"><span style="background-color:#79c6cd">不能直接在类中初始化</span></span><br>  </p> 
<p>怎么样，题出的还不错吧？</p> 
<h2 id="%E7%BC%96%E7%A8%8B%E9%A2%98">编程题</h2> 
<h3 id="1.%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9">1.考试成绩</h3> 
<p>请编写一个程序，动态分配一个足够大的数组来保存用户定义的考试成绩。一旦输入了所有的分数，数组就应该被传递给一个按照升序排序的函数。应该调用另一个函数来计平均分数。程序应该显示已排序的分数列表和平均分，并加上恰当的标题。请尽可能使用指针表示法而不是数组表示法。<br> 输入验证：考试成绩不接受负数。<br>  </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

void sort(double *s,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        for(int j=0;j&lt;n-i-1;j++)
        {
            if(*(s+j+1)&gt;*(s+j))
            {
                double tmp=*(s+j+1);
                *(s+j+1)=*(s+j);
                *(s+j)=tmp;
            }
        }
    }
}

double adv(double *s,int n)
{
    double sum=0.0;
    for(int i=0;i&lt;n;i++)
        sum+=*(s+i);
    return sum/n;
}

void print(double *s,int n,double advscore)
{
    cout&lt;&lt;'t'&lt;&lt;"考试成绩表"&lt;&lt;endl;
    cout&lt;&lt;"------------------------"&lt;&lt;endl;
    for(int i=0;i&lt;n;i++)
    {
        cout&lt;&lt;i+1&lt;&lt;'t'&lt;&lt;*(s+i)&lt;&lt;endl;
    }
    cout&lt;&lt;"平均成绩为："&lt;&lt;advscore;
}
int main()
{
    double *score=new double[1000];
    cout&lt;&lt;"请输入成绩（输入101结束）："&lt;&lt;endl;
    int i=0;//计数
    while(1)
    {
        cin&gt;&gt;*(score+i);
        if(*(score+i)&lt;0)
        {
            cout&lt;&lt;"输入非法！请重新输入："&lt;&lt;endl;
            cin&gt;&gt;*(score+i);
        }
        else if(*(score+i)==9999)
             break;
        i++;
    }
    sort(score,i); //排序
    double advscore=adv(score,i);//计算平均分
    print(score,i,advscore);//输出
    return 0;
}

</code></pre> 
<h3 id="%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9%EF%BC%882%EF%BC%89">考试成绩（2）</h3> 
<p>修改编程题的程序以允许用户输入名称－分数对。对于每个参加考试的学生，用户先输入代表学生姓名的字符串，然后输入代表学生成绩的整数。修改排序和平均分计算函数，以便它们采用结构数组，每个结构包含单个学生的名称和分数。在遍历数组时，使用指针而不是数组索引。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
struct student
{
    string name;//名字
    int score;//分数
};

void sort(student *s,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        for(int j=0;j&lt;n-i-1;j++)
        {
            if(s[j+1].score&gt;s[j].score)
            {
                student tmp=s[j+1];
                s[j+1]=s[j];
                s[j]=tmp;
            }
        }
    }
}

double adv(student *s,int n)
{
    int sum=0;
    for(int i=0;i&lt;n;i++)
        sum+=s[i].score;
    return sum/n;
}

void print(student *s,int n,double advscore)
{
    cout&lt;&lt;'t'&lt;&lt;"考试成绩表"&lt;&lt;endl;
    cout&lt;&lt;"------------------------"&lt;&lt;endl;
    for(int i=0;i&lt;n;i++)
    {
        cout&lt;&lt;i+1&lt;&lt;'t'&lt;&lt;s[i].name&lt;&lt;'t'&lt;&lt;s[i].score&lt;&lt;endl;
    }
    cout&lt;&lt;"平均成绩为："&lt;&lt;advscore;
}

int main()
{
    student *p=new student[1000];
    cout&lt;&lt;"请输入姓名和成绩（输入#结束）："&lt;&lt;endl;
    int i=0;//计数
    while(1)
    {
        cin&gt;&gt;p[i].name;
        cin&gt;&gt;p[i].score;
        if(p[i].score&lt;0)
        {
            cout&lt;&lt;"输入非法！请重新输入："&lt;&lt;endl;
            cin&gt;&gt;p[i].score;
        }
        else if(p[i].score==9999)
             break;
        i++;
    }
    sort(p,i); //排序
    double advscore=adv(p,i);//计算平均分
    print(p,i,advscore);//输出
    return 0;
}

</code></pre> 
<h3 id="%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E9%97%B4%E6%8E%A5%E6%8E%92%E5%BA%8F">通过指针间接排序</h3> 
<p>某公司有一个包含Person类型结构的Person data[10]数组，需要按姓名对该数组排序</p> 
<pre><code class="language-cpp">struct Person
{
    string name;
    int age;
};
</code></pre> 
<p>在真实的程序中，Person 结构可能拥有许多成员，占用大量内存。在这种情况下，排序和移动Person 对象都可能消耗大量的计算资源。因此，可以考虑定义一个辅助数组 Person＊pData[10],设置pData[k]的每个元都指向data[k]的对应元素。请编写一个程序，对该指针数组进行排序，这样，当按索引k的升序遍历pData数组时，pData[k]元素即指向按字母顺序的升序排序的Person对象。<br>  </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
using namespace std;
struct Person
{
    string name;
    int age;
};

void sort(Person *p,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        for(int j=0;j&lt;n-i-1;j++)
        {
            if(p[j].name&gt;p[j+1].name)
            {
                Person x=p[j];
                p[j]=p[j+1];
                p[j+1]=x;
            }
        }
    }
}
int main()
{
    Person data[10];
    Person *pData[10];

    cout&lt;&lt;"请输入员工的姓名和年龄:"&lt;&lt;endl;
    for(int i=0;i&lt;10;i++)
        cin&gt;&gt;data[i].name&gt;&gt;data[i].age;

    //pData[k]的每个元都指向data[k]的对应元素
    for(int i=0;i&lt;10;i++)
        pData[i]=&amp;data[i];

    sort(*pData,10);

    cout&lt;&lt;'t'&lt;&lt;"姓名排序表"&lt;&lt;endl;
    cout&lt;&lt;"----------------------------"&lt;&lt;endl;
    for(int i=0;i&lt;10;i++)
        cout&lt;&lt;setw(15)&lt;&lt;left&lt;&lt;pData[i]-&gt;name&lt;&lt;pData[i]-&gt;age&lt;&lt;endl;
    return 0;
}
/*
Alice 31
Lucy 20
Linda 25
Cathy 26
Caroline 23
Bob 27
John 29
Peter 24
Justin 23
Jack 30*/

</code></pre> 
<h3 id="%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E9%97%B4%E6%8E%A5%E6%8E%92%E5%BA%8F%EF%BC%882%EF%BC%89">通过指针间接排序（2）</h3> 
<p>请编写一个程序，解决刚才那题提出的问题，但是指针数组现在应该指向按年龄降序排序的数据数组。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
using namespace std;
struct Person
{
    string name;
    int age;
};

void sort(Person *p,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        for(int j=0;j&lt;n-i-1;j++)
        {
            if(p[j].age&lt;p[j+1].age)
            {
                Person x=p[j];
                p[j]=p[j+1];
                p[j+1]=x;
            }
        }
    }
}
int main()
{
    Person data[10];
    Person *pData[10];

    cout&lt;&lt;"请输入员工的姓名和年龄:"&lt;&lt;endl;
    for(int i=0;i&lt;10;i++)
        cin&gt;&gt;data[i].name&gt;&gt;data[i].age;

    //pData[k]的每个元都指向data[k]的对应元素
    for(int i=0;i&lt;10;i++)
        pData[i]=&amp;data[i];

    sort(*pData,10);

    cout&lt;&lt;'t'&lt;&lt;"姓名排序表"&lt;&lt;endl;
    cout&lt;&lt;"----------------------------"&lt;&lt;endl;
    for(int i=0;i&lt;10;i++)
        cout&lt;&lt;setw(15)&lt;&lt;left&lt;&lt;pData[i]-&gt;name&lt;&lt;pData[i]-&gt;age&lt;&lt;endl;
    return 0;
}

</code></pre> 
<h3 id="%E9%A6%85%E9%A5%BC%E5%90%83%E8%B4%A7%E5%8F%AF%E7%9F%A5%E5%90%A6">馅饼吃货可知否</h3> 
<p>在统计作业中，一组值得众数是经常出现得值。请编写一个程序，确定大多数人每年吃多少块馅饼。设置一个可以保存30人得回答的整数数组，输入每个人所说的一年中所吃的馅饼块数。然后编写一个函数来查找这30个值得众数，这将是大多数人吃的馅饼的块数。查找和返回众数得函数应该接受两个实参，其中一个是整数数组，另一个是指示数组中有多少元素。<br>  </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;
int Mode(int *s,int n)
{
    int num=1,x=1;
    //从大到小排序
    for(int i=0;i&lt;n-1;i++)
    {
        for(int j=0;j&lt;n-i-1;j++)
        {
            if(*(s+j)&lt;*(s+j+1))
            {
                int tmp=*(s+j);
                *(s+j)=*(s+j+1);
                *(s+j+1)=tmp;
            }
        }
    }
    int m;//记录众数的值
    int current=0;//当前正在访问的数字的个数
    int most=0;//目前的众数个数
    for(int i=0;i&lt;n;i++)
    {
        current++;
        if(*(s+i)!=*(s+i+1) || i==n-1)
        {
            if(current&gt;most)
            {
                most=current;
                m=*(s+i);
            }
            current=0;
        }
    }
    return m;
}

int main()
{
    int *p=new int[30];
    cout&lt;&lt;"请输入每年吃的馅饼块数："&lt;&lt;endl;
    int i=0;
    while(1)
    {
        cin&gt;&gt;*(p+i);
        if(*(p+i)&lt;0)
        {
            cout&lt;&lt;"输入有误！不能为负数！请重新输入："&lt;&lt;endl;
            cin&gt;&gt;*(p+i);
        }
        else if(*(p+i)==0000)
            break;
        i++;
    }
    cout&lt;&lt;"所吃馅饼的众数为："&lt;&lt;Mode(p,i);
    return 0;
}

</code></pre> 
<p>五道编程题每道17分（我自己编的，凑个整满分100分）</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/8a/78/Zrpaav4p_o.jpg" width="240"></p> 
<p> </p> 
<h1 id="%E6%9C%80%E5%90%8E">最后</h1> 
<blockquote> 
 <p>这次写博客花了几个小时，比对资料，运行出结果...</p> 
 <p>咱也不为了没用的赞和评论</p> 
 <p><span style="color:#79c6cd">只是想把自己学到的知识分享给大家，顺便自己也捋顺一遍</span></p> 
 <p>最后，上面的题你们都拿了多少分呢？可以在下面投票<img alt="" height="48" src="https://images2.imgbox.com/d5/7f/4s3lPspV_o.png" width="48"></p> 
 <p>这次写了一万多字（草稿已保存 17:23:49 共 10309 字），还有不懂的也可以私信我</p> 
 <p>拜拜</p> 
 <p><img alt="" height="240" src="https://images2.imgbox.com/61/0a/2dPfqczY_o.jpg" width="240"><img alt="" height="240" src="https://images2.imgbox.com/5b/9e/NKdns6HB_o.png" width="240"> </p> 
 <p></p> 
</blockquote>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>