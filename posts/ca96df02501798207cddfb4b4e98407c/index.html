<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>什么是架构 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是架构</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h2>
<a id="imagepnghttpsimgblogcsdnimgcnimg_convert00028e9aa745a8663616e25dbf05066fpngclientIdubb75cc02ad034crop0pic_centercrop0crop1crop1frompasteheight559iduddad6e79margin5Bobject20Object5DnameimagepngoriginHeight838originWidth1011originalTypebinaryratio1rotation0showTitletruesize94892statusdonestylenonetaskIdu375c8557af1a4faebc13710cee4ed34titlewidth674__0"></a><img src="https://img-blog.csdnimg.cn/img_convert/00028e9aa745a8663616e25dbf05066f.png#clientId=ubb75cc02-ad03-4&amp;crop=0&amp;#pic_centercrop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=559&amp;id=uddad6e79&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=838&amp;originWidth=1011&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=94892&amp;status=done&amp;style=none&amp;taskId=u375c8557-af1a-4fae-bc13-710cee4ed34&amp;title=%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4%E8%BD%AE%E5%BB%93&amp;width=674" alt="image.png" title="架构思维轮廓">
</h2> 
<h2>
<a id="_1"></a>一、前言</h2> 
<blockquote> 
 <p>架构，又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。架构描述语言（ADL）用于描述软件的体系架构。</p> 
</blockquote> 
<p><strong>软件架构（software architecture）<strong>是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。 软件架构是一个系统的</strong>草图</strong>。软件架构描述的对象是<strong>直接构成系统</strong>的抽象组件。各个组件之间的连接则<strong>明确</strong>和<strong>相对细致</strong>地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体<strong>某个类</strong>或者<strong>对象</strong>。在面向对象领域中，组件之间的连接通常用<strong>接口</strong>(计算机科学)来实现。 软件体系结构是构建计算机软件实践的基础。与建筑师设定建筑项目的<strong>设计原则</strong>和<strong>目标</strong>，作为绘图员画图的基础一样，一个<strong>软件架构师</strong>或者<strong>系统架构师</strong>陈述软件构架以作为满足不同客户需求的实际系统设计方案的基础。<br> </p> 
<h2>
<a id="_6"></a>二、架构设计目标</h2> 
<p>在进行软件系统构架时，软件本身有其要达到的目标，软件架构设计要达到如下的 8 个目标：</p> 
<ol>
<li>
<strong>可靠性（Reliable）</strong>。软件系统对于用户的<strong>商业经营</strong>和<strong>管理</strong>来说极为重要，因此软件系统必须非常可靠。</li>
<li>
<strong>安全性（Secure）</strong>。软件系统所承担的<strong>交易</strong>的商业价值极高，系统的安全性非常重要。</li>
<li>
<strong>可扩展性（Scalable）</strong>。软件必须能够在用户的<strong>使用率</strong>、用户的<strong>数目增加很快</strong>的情况下，保持合理的<strong>性能</strong>。只有这样，才能适应用户的市场扩展得可能性。</li>
<li>
<strong>可定制化（Customizable）</strong>。同样的一套软件，可以根据<strong>客户群的不同</strong>和<strong>市场需求的变化</strong>进行调整。</li>
<li>
<strong>可伸缩 （Extensible）</strong>。在新技术出现的时候，一个软件系统应当允许<strong>导入</strong>新技术，从而对现有系统进行<strong>功能</strong>和<strong>性能</strong>的扩展。</li>
<li>
<strong>可维护性（Maintainable）</strong>。软件系统的维护包括两方面，一是<strong>排除</strong>现有的错误，二是将<strong>新的软件需求</strong>反映到现有系统中去。一个易于维护的系统可以有效地降低技术支持的花费。</li>
<li>
<strong>客户体验（Customer Experience）</strong>。软件系统必须<strong>易于</strong>使用。</li>
<li>
<strong>市场时机（Time to Market）</strong>。软件<strong>用户</strong>要面临同业竞争，软件<strong>提供商</strong>也要面临同业竞争。以最快的速度争夺市场先机非常重要。<br> </li>
</ol> 
<h2>
<a id="_17"></a>三、架构分类</h2> 
<p>通常按不同的关注角度上分，可以将架构类型分为三种：</p> 
<ol><li>
<strong>逻辑架构</strong>：软件中元件之间的关系，比如一个系统的架构在抽象层面，分解为表示层、业务逻辑处理层、数据元件层，如下面图所示，将各元件职责分离且划分简单抽象的单元构建的基本架构。</li></ol> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/180d553ff12d023e97cc59b66e7afac1.png#crop=0&amp;crop=0&amp;#pic_centercrop=1&amp;crop=1&amp;from=url&amp;id=vu2Gw&amp;margin=%5Bobject%20Object%5D&amp;originHeight=323&amp;originWidth=446&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p> 
<ol start="2">
<li> <p><strong>物理架构</strong>：是对软件元件怎么部署到硬件上。比如下图中所描述的物理架构图是一个终端到服务器分布式部署的物理架构，图中所有的元件都是物理设备，该架构包含WEB服务器、代理服务器、应用服务器、存储服务器。<br> <img src="https://images2.imgbox.com/92/47/D1liaUnK_o.png" alt="在这里插入图片描述"></p> </li>
<li> <p><strong>系统架构</strong>：是软件系统的功能性和非功能性特征的体现，而功能性特征的原则是怎么把整个系统做拆分，将各个元件各司其职，完成某一功能为事件。非功能性特征包括可扩展性、可靠性、可用性、健壮性、灵活性、性能等。如下图中描述的是一个系统的构建和设计需要满足的要求。系统架构的设计要求架构师具备软件和硬件的功能和性能的过硬知识，这一工作无疑是架构设计工作中最为困难的工作。<br> <img src="https://images2.imgbox.com/e8/c3/Wkw9fiPV_o.png" alt="在这里插入图片描述"></p> </li>
</ol> 
<h2>
<a id="_30"></a>四、架构边界划分</h2> 
<p>架构通常是<strong>抽象</strong>的，但其边界是可被约束的，在构建实际的系统架构中，我们可以将架构边界划分为<strong>软件元件</strong>和<strong>设计</strong>两个关键要素决定。从每一个角度上看，都可以看到架构中的这两要素，也就是元件的划分和设计。<br>首先，一个软件系统中的元件首先是<strong>逻辑元件</strong>。这些逻辑元件如何放到<strong>硬件</strong>上，以及这些元件如何为整个系统的可扩展性、可靠性、强壮性、灵活性、性能等做出贡献，是非常重要的信息。其次，进行软件设计需要做出的决定中，必然会包括<strong>逻辑结构</strong>、<strong>物理结构</strong>，以及它们如何<strong>影响</strong>到系统的所有<strong>非功能性</strong>特征。这些决定中会有很多是一旦做出，就很难更改的。为了讨论和分析软件架构，必须首先<strong>定义架构</strong>表示方式，即描述架构重要方面的方式。<br>我们决定以多种架构视图来表示软件架构，<strong>架构视图模型</strong>都有哪些将在下面进行说明。每种架构视图针对于开发流程中的涉众（例如最终用户、设计人员、管理人员、系统工程师、维护人员等）所关注的特定方面。架构视图显示了软件架构如何<strong>分解</strong>为构件，以及构件如何由<strong>连接器</strong>连接来产生有用的形式 ，由此记录主要的结构设计决策。这些设计决策必须基于<strong>需求</strong>以及<strong>功能</strong>、补充和其他方面的<strong>约束</strong>。而这些决策又会在<strong>较低层次</strong>上为需求和将来的设计决策施加进一步的约束。<br> </p> 
<h2>
<a id="_33"></a>五、架构视图模型有哪些</h2> 
<p>架构由许多不同的架构视图来表示，这些视图本质上是以图形方式来重点说明“在架构方面具有重要意义”的模型元素。该视图集称为“<strong>4+1 视图模型</strong>”。它包括：</p> 
<ol>
<li>
<strong>用例视图：<strong>包括</strong>用例</strong>和<strong>场景</strong>，这些用例和场景包括在架构方面具有重要意义的行为、类或技术风险。它是<strong>用例模型</strong>的子集。</li>
<li>
<strong>逻辑视图：<strong>包括最重要的设计类、从这些设计</strong>类</strong>到<strong>包</strong>和<strong>子系统</strong>的组织形式，以及从这些包和子系统到层的组织形式。它还包括一些<strong>用例实现</strong>。它是<strong>设计模型</strong>的子集。</li>
<li>
<strong>实施视图：<strong>包括实施模型及其从</strong>模块</strong>到<strong>包</strong>和<strong>层</strong>的组织形式的概览。 同时还描述了将逻辑视图中的包和类向实施视图中的包和模块分配的情况。它是<strong>实施模型</strong>的子集。</li>
<li>
<strong>进程视图：<strong>包括所涉及</strong>任务</strong>（进程和线程）的描述，它们的交互和配置，以及将设计<strong>对象</strong>和<strong>类</strong>向任务的分配情况。只有在系统具有<strong>很高</strong>程度的并行时，才需要该视图。在 Rational Unified Process 中，它是<strong>设计模型</strong>的子集。</li>
<li>
<strong>配置视图：<strong>包括对最典型的平台配置的各种</strong>物理节点</strong>的描述以及将<strong>任务</strong>（来自进程视图）向物理节点分配的情况。只有在<strong>分布式系统</strong>中才需要该视图。它是<strong>部署模型</strong>的一个子集。</li>
</ol> 
<p>针对上面提到的几种视图模型中，我们可以构建其它视图来表达需要特别关注的不同方面，如：用户界面视图、安全视图、数据视图等。对于<strong>简单系统</strong>来说，可以省略 <strong>4+1 视图模型</strong>中的一些视图。<br>虽然以上视图可以表示系统的整体设计，但架构只同以下几个具体方面相关： <strong>模型的结构</strong>，即<strong>组织模式</strong>，例如分层。<br>架构视图在本质上是整体设计的<strong>抽象</strong>或<strong>简化</strong>，它们通过<strong>舍弃</strong>具体<strong>细节</strong>来突出重要的特征。在考虑以下方面时，这些特征非常重要：</p> 
<ul>
<li>系统演进，即进入下一个开发周期。</li>
<li>在产品线环境下复用架构或架构的一部分。</li>
<li>评估补充质量，例如性能、可用性、可移植性和安全性。</li>
<li>向团队或开发商分配开发工作。</li>
<li>决定是否包括商业构件。</li>
<li>插入范围更广的系统。<br> </li>
</ul> 
<h2>
<a id="_51"></a>六、架构设计原则</h2> 
<p>通常我们在对系统或程序做设计过程中并不是一味追求完美和为了架构而去做架构。为了解决软件架构在设计时，可根据传统软件规则约束设计出符合实际业务场景的适用性架构，并且软件架构的设计不是一成不变的，将会随着满足客户需求为意愿或其它内外部因素的影响，我们需要动态和适当的调整架构。<br><strong>基本的软件架构的设计一般需要符合以下 6 个架构设计原则（简称：SOLID）：</strong></p> 
<ol>
<li>
<strong>单一职责（SRP）</strong>：是指在一个类或组件中永远只负责做独有的业务或一件事，保持职责足够单一，各司其职，不受外部因素所干扰，职责清晰，便于维护。</li>
<li>
<strong>开闭原则（OCP）</strong>：是指类或组件的扩展开放，修改关闭原则，实现业务之间耦合性降低和提高了可扩展性。</li>
<li>
<strong>里氏替换原则（LSP）</strong>：是指子类和超类或基类之间的关系，子类的实例可以替换为超类或基类任何实例，并且在此过程中程序不会受到影响，而反过来则不行，会使程序异常。</li>
<li>
<strong>迪米特原则（LKP）</strong>：是指类或组件中所依赖的对象（实体）降到最低，是该类的依赖最少了解，通常也被称为最少知识原则。</li>
<li>
<strong>接口隔离原则（ISP）</strong>：是指不需要把不必要的接口强加给用户使用，尽量保证接口和模块之间的耦合降到最低，也称为接口最少提供原则。</li>
<li>
<strong>依赖倒置原则（DIP）</strong>：是指类与组件之间或层与层之间的关系，顶层不应该依赖于底层，而更应该依赖于抽象层，抽象层不应该依赖于具体的实现，更应该依赖于底层，说明的是内部结构的变动并不会影响到顶层的变化，尽量避免跨层调用和强依赖关系，提高可扩展性。</li>
</ol> 
<p><strong>软件架构设计时您还需要遵守的编程原则（规范）：</strong></p> 
<ol><li><strong>不要重复你自己（Don’t repeat yourself - DRY）</strong></li></ol> 
<p>不要让重复的代码到处都是，要让它们能够复用，所以要尽可能地组件化封装。</p> 
<ol start="2"><li><strong>保持简单与傻瓜（Keep it simple and stupid - KISS）</strong></li></ol> 
<p>不要让系统变得复杂，界面简洁，功能实用，操作方便，要让它足够的简单，足够的傻瓜。</p> 
<ol start="3"><li><strong>高内聚与低耦合（High Cohesion and Low Coupling - HCLC）</strong></li></ol> 
<p>模块内部需要做到内聚度高，模块之间需要做到耦合度低。</p> 
<ol start="4"><li><strong>约定优于配置（Convention over Configuration - COC）</strong></li></ol> 
<p>尽量让约定来减少配置，这样才能提高开发效率，尽量做到“零配置”。很多组件或框架都是这样做的。</p> 
<ol start="5"><li><strong>命令查询分离（Command Query Separation - CQS）</strong></li></ol> 
<p>在定义接口时，要做到哪些是命令，哪些是查询，要将它们分离，而不要揉到一起。</p> 
<ol start="6"><li><strong>关注点分离（Separation of Concerns - SOC）</strong></li></ol> 
<p>将一个复杂的问题分离为多个简单的问题，然后逐个解决这些简单的问题，那么这个复杂的问题就解决了。难就难在如何进行分离。</p> 
<ol start="7"><li><strong>契约式设计（Design by Contract - DBC）</strong></li></ol> 
<p>模块或系统之间的交互，都是基于契约（接口或抽象）的，而不要依赖于具体实现。该原则建议我们要面向契约编程。</p> 
<ol start="8"><li>
<strong>你不需要它（You aren’t gonna need it - YAGNI）</strong><br>不要一开始就把系统设计得非常复杂，不要陷入“过度设计”的深渊。应该让系统足够的简单，而却又不失扩展性，这是其中的难点。<br> </li></ol> 
<h2>
<a id="_93"></a>七、架构的演变过程</h2> 
<p>软件架构的设计，从最初系统的架构到不断的调整和探索的过程中，演变出一系列的架构模型。在此过程中经历了需求和业务的不断挑战和洗礼所产生的衍生架构，为了满足用户需求和实际业务场景去对架构上做出重新调整，实现新的系统架构设计上的本质提升。<br><strong>由于在架构上从不同角度上看会产生不同的粗细模型，但在本质上粗略的分为如下几种架构：</strong></p> 
<ul><li>
<strong>单体架构</strong>：单体架构是传统的软件架构模型，也是最简单、最容易被人所理解的架构，比如：分层。</li></ul> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/78b9eae752de6a2f143575edfdee969c.png#clientId=u18ca0a5d-4290-4&amp;crop=0&amp;#pic_centercrop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=u4c6d3d4b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=322&amp;originWidth=436&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=5955&amp;status=done&amp;style=none&amp;taskId=u01e433d5-7eeb-4274-aca2-1d3e9bff4f8&amp;title=%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84&amp;width=290.6666666666667" alt="image.png" title="简单的三层架构"></p> 
<ul><li>
<strong>分布式架构</strong>：分布式架构是系统和组件元件的聚合，将整个系统分布式部署在服务器上，通过一种技术手段把这些系统连接上，使各系统或模块能够相互协作处理程序操作，比如：分布式集群架构、分布式缓存架构等。</li></ul> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/798193ebe64dfbb46e1a4b49d8aaceb6.png#clientId=u18ca0a5d-4290-4&amp;crop=0&amp;#pic_centercrop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=348&amp;id=u2fea34d3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=522&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=30595&amp;status=done&amp;style=none&amp;taskId=u456ae578-dec3-4aaf-989f-686ee2c9d97&amp;title=%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84&amp;width=426.6666666666667" alt="image.png" title="分布式缓存架构"></p> 
<ul><li>
<strong>微服务架构</strong>：微服务架构的全称是Microservice Architecture，微服务架构是现代化流行的服务化治理架构，是通过业务/组件或功能维度上去划分的架构模型，能够将大的系统分解为各个小的服务，再将这些拆分的服务联系起来，服务之间的相互协作，互不影响，提高了系统的可扩展性、可维护性和容错性。</li></ul> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/7738124398d7306e8c0d7ce3eace110a.png#clientId=u18ca0a5d-4290-4&amp;crop=0&amp;crop=0&amp;#pic_centercrop=1&amp;crop=1&amp;from=paste&amp;height=568&amp;id=udb74e1f3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=852&amp;originWidth=712&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=53815&amp;status=done&amp;style=none&amp;taskId=ue88b93d9-7238-4368-8962-91adf423e94&amp;title=%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84&amp;width=474.6666666666667" alt="image.png" title="微服务架构"></p> 
<ul><li>
<strong>Serverless架构</strong>：Serverless的全称是Serverless computing无服务器运算，又被称为函数即服务（Function-as-a-Service，缩写为 FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。 国内外比较出名的产品有Tencent Serverless、Aliyun Serverless、AWS Lambda、Microsoft Azure Functions 等。</li></ul> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/ffbfb2efabee2f5d8fc57ebcb9203f24.png#clientId=u18ca0a5d-4290-4&amp;crop=0&amp;crop=0&amp;#pic_centercrop=1&amp;crop=1&amp;from=paste&amp;height=381&amp;id=u880cccfc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=572&amp;originWidth=866&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=43780&amp;status=done&amp;style=none&amp;taskId=u06eeb9ea-34ca-4cdf-9200-8c2ebb2907b&amp;title=Serverless%E6%9E%B6%E6%9E%84&amp;width=577.3333333333334" alt="image.png" title="Serverless架构"></p> 
<ul>
<li> <p><strong>Service Mesh架构</strong>：Service Mesh是一个基础设施层，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证请求在这些拓扑中可靠地穿梭。在实际应用当中，服务网格通常是由一系列轻量级的网络代理组成的，它们与应用程序部署在一起，但对应用程序透明。<br> <img src="https://images2.imgbox.com/34/22/fhb1azoL_o.png" alt="在这里插入图片描述"></p> </li>
<li> <p><strong>Istio架构</strong>：Istio扩展了Kubernetes，使用强大的Envoy服务代理建立了一个可编程的、应用程序感知的网络。与Kubernetes和传统工作负载一起工作，Istio为复杂的部署带来了标准的、通用的流量管理、遥测和安全性。</p> </li>
</ul> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/5a3ea3b06ee254e0bd1d1f4bcb1b2901.png#clientId=u18ca0a5d-4290-4&amp;crop=0&amp;crop=0&amp;#pic_centercrop=1&amp;crop=1&amp;from=paste&amp;height=497&amp;id=ue5df5d75&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=745&amp;originWidth=1221&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=176136&amp;status=done&amp;style=none&amp;taskId=ue21c2440-b290-4d89-b292-0757cad9f32&amp;title=Istio%E6%9E%B6%E6%9E%84&amp;width=814" alt="image.png" title="Istio架构"><br> </p> 
<h2>
<a id="_119"></a>八、架构设计思想</h2> 
<p><strong>1、对系统架构理解</strong><br>由于架构是抽象的，关于系统架构目前没有一个明确的定义。有从规划、实现与步骤角度去了解，有从架构分类方面去定义。这次我提的理念是：系统架构的目标是解决利益相关者的关注点。<br><img src="https://img-blog.csdnimg.cn/img_convert/9d60490eec445a9b0cfb671a7f5b62a8.png#clientId=u18ca0a5d-4290-4&amp;crop=0&amp;crop=0#pic_center&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=509&amp;id=u648c1e4c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=763&amp;originWidth=969&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=420128&amp;status=done&amp;style=none&amp;taskId=u209f17b2-6df6-48b6-b970-369f75019b5&amp;title=&amp;width=646" alt="image.png"></p> 
<ul>
<li>每个系统都有一个架构，架构由架构元素以及相互之间的关系构成，系统是为了满足利益相关者的需求构建的；</li>
<li>利益相关者都有自己的关注点；</li>
<li>架构由架构文档描述，并且描述了一系列的架构视角，而这些视角其实就是去解决利益相关者的关注点。</li>
</ul> 
<p><strong>2、对系统关注点理解</strong><br>系统关注点通常是从系统架构中在不同视野上分为功能性关注点和非功能性关注点，而往往我们在对系统做架构设计时忽略了最需要关注的非功能性关注点，下面就着重分析功能性和非功能性关注点所具备的基本原则和规范。<br><strong>处理功能性关注点，需要注意以下 3 个原则，并且通过模型方式来进行实现。</strong><br><strong>1- 架构设计基本原则：S - O - L - I - D</strong><br>SRP：单一职责原则<br>OCP：开闭原则<br>LSP：里氏替换原则<br>LKP：迪米特原则<br>ISP：接口隔离原则<br>DIP：依赖倒置原则<br><strong>2- KISS</strong><br>KEEP IT SIMPLE AND STUPID（保持简单与傻瓜）<br><strong>3- 高内聚、低耦合</strong><br><strong>4- 模型的 3 个层次</strong><br><strong>第一层是代码层面</strong>：就是惯用的代码，策略是指一套API、方法等。<br><strong>第二层是设计模式</strong>：主要GOF提出来的<strong>23种</strong>常用的设计模式。立足于高级抽象层面进行探讨，而非设计标注或 者编程语言，能够大大降低系统复杂度。<br><strong>第三层是架构模式</strong>：它是一个通用的，可复用的解决方案。比如：分层模式、微服务模式等。<br><strong>非功能性关注点，一般应用于对系统的扩展性方面做设计的。</strong><br><strong>1-高可用性</strong><br>首先需要先了解一个分布式理论原则：CAP理论，在分布式系统中，一致性、可用性和分区容错性。三者不可兼得。在设计系统架构时是无法同时满足CAP这三个特性，那么我们怎么样来做权衡选择呢？选择的关键就是取决于您的业务场景。对于现在的互联网应用，特点就是机器数量庞大，部署节点分散，网络故障是常态。可用性是必须保证的，通常一般业务系统会在C和A之间做权衡，但为了保证系统的高可用性，其实本质上就放弃了C，选择AP。<br><strong>保证系统的高可用方式有以下几种：</strong><br><strong>隔离</strong>：发生故障的时候，能限定它传播的范围和影响范围。就应该对其进行隔离，不会出现雪球效应。隔离 包含：进程隔离、线程隔离、集群隔离、机房隔离、读写隔离、动静隔离、爬虫隔离。<br><strong>限流</strong>：限流的目的是通过对并发访问进行限速或者一个时间窗口内的请求进行限速来保护系统常见的限流算 法，有令牌桶和漏桶算法。<br><strong>预案、降级</strong>：目的也是对我们的应用系统的一种保护。在不牺牲核心功能，或者牺牲一定的用户体验的情况 下，保证我们的服务还是可用的。在降级之前我们的准备工作是预案的准备。还要使用配置中心实现 开关配置。<br><strong>2-高性能性</strong><br><strong>缓存</strong>：浏览器或者APP客户端缓存、CDN缓存、接入层缓存(如：Nginx缓存)、应用层缓存(堆内缓存、对外 缓存、磁盘缓存)、分布式缓存。<br><strong>异步并发</strong>：当用户请求达到服务端时，比如商品详情页，它涉及到很多属性，由于目前在微服务这个大环境 下，就会存在大量的HTTP，SOA服务的调用。如果是使用同步调用来获取数据，这个线程都是 出于阻塞状态，降低了系统的吞吐量。这个时候我们就需要使用异步来进行提升吞吐量了。目前 Java这方面的开源框架有： HttpAsyncClient、gRPC、Thrift等。<br><strong>扩容</strong>：业务量级越来越大，单台服务器无法处理这么大的业务流量，这就需要分而治之的思想来对待了。扩 容包括单体应用垂直扩容和水平扩容。垂直扩容：就是对硬件资源进行提升，比如CPU和内存。水平 扩容：就是增加更多的应用镜像，通过负载均衡来分摊压力。<br>最后涉及到高性能的比如数据层索引优化、性能测试等。<br><strong>3-高伸缩性</strong><br>通过很少的改动，甚至只是增加一些硬件设备，就能实现整个系统能力的线性增长，实现高吞吐量和低延迟 性能。<br>对于可伸缩性和纯粹的性能调优，是有区别的：可伸缩性，它主要是对高性能，低成本和可维护性等诸多因素的综合考虑和平衡。普通的性能优化，更多的只是单台机器的性能指标的优化。但是它们有个共同点，就是根据系统的特点在吞吐量和延迟之间进行一个侧重选择。<br><strong>3、康威定律</strong><br>康威定律是马尔文康威1967年提出的：“设计系统的架构受制于产生这些设计的组织的沟通结构。”通俗 的来说：产品必然是其（人员）组织沟通结构的缩影。<br><strong>康威定律可总结为四个定律：</strong><br><strong>第一定律</strong>：组织沟通方式会通过系统设计表达出来。<br><strong>第二定律</strong>：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。<br><strong>第三定律</strong>：线型系统和线型组织架构间有潜在的异质同态特性。<br><strong>第四定律</strong>：大的系统组织总是比小系统更倾向于分解。<br> </p> 
<h2>
<a id="_128"></a>九、架构总结</h2> 
<p>通过阅读了本文相信你们对架构有了初步的认知和了解，但想成为架构师必须具备足够的<strong>技术</strong>和<strong>业务</strong>能力，下面我就以个人对架构的理解和总结说一下个人感触，关于架构总结我从 <strong>3 个</strong>维度去阐明，具体如下图：<br><img src="https://img-blog.csdnimg.cn/img_convert/6bf520b89b149bcd5345619bd804e0d8.png#clientId=ub5ebafda-cf73-4&amp;crop=0&amp;crop=0#pic_center&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=199&amp;id=ub15f2a1a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=461&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19787&amp;status=done&amp;style=none&amp;taskId=ufa244987-4c53-445b-8b1c-9fcfff15116&amp;title=&amp;width=307.3333333333333" alt="image.png"><br><strong>架构认知</strong>：我个人对架构的认知在于<strong>万物皆架构</strong>，在<strong>生活</strong>或<strong>虚拟世界</strong>里都存在着独有的架构，好比在现实生活中的楼房、交通轨道、手机等，都离不开本身着重的架构设计，而在虚拟世界里有应用软件、通信软件和游戏等，但这些基本上都是环绕在我们脑海里对架构的<strong>初步认知</strong>，还尚未成熟，因为<strong>架构是一种思想</strong>，也是<strong>抽象</strong>的，并不被人所理解。<br><strong>架构理解</strong>：通过我对架构上的认知，也触发了我本身对架构上的理解。<strong>架构的设计不在于精，而在于弹性适用性。<strong>假如我们对架构的理解是在于</strong>技术性</strong>的满足，那么就会让你<strong>陷入</strong>技术的海洋，到最后就会迷失方向，一直站在目前的方位。对于产生这样的结果，是因为没有<strong>真正</strong>的去<strong>认知</strong>和<strong>理解</strong>架构的本质。那么架构的本质是什么呢？应该怎么做才能往正确的架构方向靠近呢？无疑这些问题就成为了我们脑海里在探索答案的过程中，对于刚提到的 <strong>2 个</strong>问题我会在下面进行说明。<br><strong>1、架构的本质是什么呢？</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/283c70eb8876cdb2422edd04206bc9a4.png#clientId=ub5ebafda-cf73-4&amp;crop=0&amp;crop=0#pic_center&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=107&amp;id=u599ace30&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=160&amp;originWidth=776&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7867&amp;status=done&amp;style=none&amp;taskId=u53385651-8336-40f7-867a-d43f00d9b6b&amp;title=&amp;width=517.3333333333334" alt="image.png"></p> 
<pre><code>					                    	- 架构师是技术和业务之间的桥梁；
					                        - 架构师不能只顾技术，不懂业务；
					                        - 架构师很容易两头不讨好。
</code></pre> 
<p><strong>2、应该怎么做才能往正确的架构方向靠近呢？</strong><br>首先，需要从<strong>架构思维</strong>上的转变，如下图：<br><img src="https://img-blog.csdnimg.cn/img_convert/ef3b98a92103bed2e1abeff334b8c8cd.png#clientId=uaf3b0e3f-80d5-4&amp;crop=0&amp;crop=0#pic_center&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=109&amp;id=u798c1a81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=164&amp;originWidth=898&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=10690&amp;status=done&amp;style=none&amp;taskId=uc29d16aa-5938-4bb4-ae90-22d8d499da4&amp;title=%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B&amp;width=598.6666666666666" alt="image.png" title="架构思维模型"><br>然后，还要从实际出发点上去看，应该怎么去做，需要哪些方面的经验和方法，如下图：<br><img src="https://img-blog.csdnimg.cn/img_convert/5d3660657ce6c44b04dd30606693ef74.png#clientId=uaf3b0e3f-80d5-4&amp;crop=0&amp;crop=0#pic_center&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=120&amp;id=ub9cc2b8d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=180&amp;originWidth=912&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=15140&amp;status=done&amp;style=none&amp;taskId=ub153f3b5-16c2-46d3-86c0-97dcfe55bfd&amp;title=%E6%9E%B6%E6%9E%84%E8%83%BD%E5%8A%9B%E6%A8%A1%E5%9E%8B&amp;width=608" alt="image.png" title="架构能力模型"><br><strong>架构启发</strong>：从我个人经历架构行业以来，一直对于架构上的认知、理解给予我很多启发。现在我从个人的角度出发去说明架构设计中的思想，其实，架构致力于很多方面、也以各种形式存在。在做架构设计时，我们基本上会从各方面角度去思考，比如用户需求、业务切入点、数据量级等，那么通常所说的架构设计，都是为了满足或解决实际业务问题的。我个人所理解架构总结出一句话就是：架构设计不在于完美，也不在于复杂，而在于架构足够简单并且能够适用于业务，便于能够让人去理解。</p> 
<hr> 
<blockquote> 
 <p>最后，若大家有想往架构这方面去提升的，我会致力于架构方面的经验持续输出，为大家输出高质量文章，麻烦大家动动小手指点个赞，收藏+关注不迷路哦~</p> 
</blockquote>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>