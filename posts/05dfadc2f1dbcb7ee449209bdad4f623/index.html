<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>CSAPP大作业程序人生 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CSAPP大作业程序人生</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"><strong>计算机系统</strong></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"><strong>大作业</strong></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">题     目 <u> </u><u>程序人生</u><u>-Hello’s P2P</u></p> 
<p style="margin-left:0;text-align:justify">专       业 <u> </u><u>计算机科学与技术</u><u>      </u></p> 
<p style="margin-left:0;text-align:justify">学　　   号 <u> 2021113451            </u></p> 
<p style="margin-left:0;text-align:justify">班　　   级 <u> 2103102               </u></p> 
<p style="margin-left:0;text-align:justify">学       生 <u> </u><u>魏嘉浩</u><u>                </u></p> 
<p style="margin-left:0;text-align:justify">指 导 教 师 <u> </u><u>刘宏伟</u><u>                 </u></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"><strong>计算机科学与技术学院</strong></p> 
<p style="margin-left:0;text-align:center"><strong>2022</strong><strong>年5月</strong></p> 
<p style="margin-left:0;text-align:center"><a name="_Toc225579639"></a><a name="_Toc250450163"><strong>摘  要</strong></a></p> 
<p style="margin-left:0;text-align:justify"><strong>   </strong><strong>本文从计算机系统角度上，具体分析了一个程序从被编写到预处理、编译、汇编、链接、执行，最后被内核删除的过程。研究了各过程的概念作用与本质，给出了各处理过程的指令，分析了各过程得到文件的不同之处，研究了运行程序时，系统创建与回收进程的过程，从而更深入理解了计算机系统的运作，对进一步研究如何优化程序性能有指导意义。</strong></p> 
<p style="margin-left:0;text-align:justify"><strong>关键词</strong>：计算机系统，程序处理过程，进程  </p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"><strong>目  录</strong></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238396">第1章 概述................................................................................................................ - 4 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238397">1.1 Hello简介......................................................................................................... - 4 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238398">1.2 环境与工具........................................................................................................ - 4 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238399">1.3 中间结果............................................................................................................ - 4 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238400">1.4 本章小结............................................................................................................ - 4 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238401">第2章 预处理............................................................................................................ - 5 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238402">2.1 预处理的概念与作用........................................................................................ - 5 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238403">2.2在Ubuntu下预处理的命令............................................................................. - 5 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238404">2.3 Hello的预处理结果解析................................................................................. - 5 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238405">2.4 本章小结............................................................................................................ - 5 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238406">第3章 编译................................................................................................................ - 6 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238407">3.1 编译的概念与作用............................................................................................ - 6 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238408">3.2 在Ubuntu下编译的命令................................................................................ - 6 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238409">3.3 Hello的编译结果解析..................................................................................... - 6 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238410">3.4 本章小结............................................................................................................ - 6 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238411">第4章 汇编................................................................................................................ - 7 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238412">4.1 汇编的概念与作用............................................................................................ - 7 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238413">4.2 在Ubuntu下汇编的命令................................................................................ - 7 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238414">4.3 可重定位目标elf格式.................................................................................... - 7 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238415">4.4 Hello.o的结果解析......................................................................................... - 7 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238416">4.5 本章小结............................................................................................................ - 7 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238417">第5章 链接................................................................................................................ - 8 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238418">5.1 链接的概念与作用............................................................................................ - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238419">5.2 在Ubuntu下链接的命令................................................................................ - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238420">5.3 可执行目标文件hello的格式....................................................................... - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238421">5.4 hello的虚拟地址空间..................................................................................... - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238422">5.5 链接的重定位过程分析.................................................................................... - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238423">5.6 hello的执行流程............................................................................................. - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238424">5.7 Hello的动态链接分析..................................................................................... - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238425">5.8 本章小结............................................................................................................ - 9 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238426">第6章 hello进程管理...................................................................................... - 10 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238427">6.1 进程的概念与作用.......................................................................................... - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238428">6.2 简述壳Shell-bash的作用与处理流程........................................................ - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238429">6.3 Hello的fork进程创建过程........................................................................ - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238430">6.4 Hello的execve过程.................................................................................... - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238431">6.5 Hello的进程执行........................................................................................... - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238432">6.6 hello的异常与信号处理............................................................................... - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238433">6.7本章小结.......................................................................................................... - 10 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238434">第7章 hello的存储管理................................................................................... - 11 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238435">7.1 hello的存储器地址空间............................................................................... - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238436">7.2 Intel逻辑地址到线性地址的变换-段式管理............................................... - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238437">7.3 Hello的线性地址到物理地址的变换-页式管理.......................................... - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238438">7.4 TLB与四级页表支持下的VA到PA的变换................................................ - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238439">7.5 三级Cache支持下的物理内存访问............................................................. - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238440">7.6 hello进程fork时的内存映射..................................................................... - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238441">7.7 hello进程execve时的内存映射................................................................. - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238442">7.8 缺页故障与缺页中断处理.............................................................................. - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238443">7.9动态存储分配管理.......................................................................................... - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238444">7.10本章小结........................................................................................................ - 12 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238445">第8章 hello的IO管理.................................................................................... - 13 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238446">8.1 Linux的IO设备管理方法............................................................................. - 13 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238447">8.2 简述Unix IO接口及其函数.......................................................................... - 13 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238448">8.3 printf的实现分析........................................................................................... - 13 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238449">8.4 getchar的实现分析....................................................................................... - 13 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238450">8.5本章小结.......................................................................................................... - 13 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238451">结论............................................................................................................................ - 14 -</a></strong></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238452">附件............................................................................................................................ - 15 -</a></strong></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238453">参考文献.................................................................................................................... - 16 -</a></strong></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc225579641"></a><a name="_Toc250450165"></a><a name="_Toc532238396">第1章 </a>概述</h1> 
<h2 style="margin-left:0;text-align:justify">
<a name="_Toc532238397"></a><a name="_Toc225579642"></a><a name="_Toc250450166">1.1 </a>Hello简介</h2> 
<p style="margin-left:0;text-align:justify">根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。</p> 
<p style="margin-left:0;text-align:justify">P2P(from program to process)是指hello.c文件程序文件变成运行进程的过程，020(from zero to zero)是指初始时内存中没有程序进程，经过程序的完整加载执行过程最后被内核删除。这两个过程的实现步骤如下：</p> 
<ol>
<li style="text-align:justify">通过编辑器文本编写hello源程序，得到hello.c。</li>
<li style="text-align:justify">运行预处理器cpp将源程序预处理成hello.i。</li>
<li style="text-align:justify">运行编译器ccl将其编译生成汇编语言文件hello.s。</li>
<li style="text-align:justify">运行汇编器as将其编译成一个可重定位目标文件（二进制）hello.o。</li>
<li style="text-align:justify">运行链接器ld将hello.o和系统目标文件结合，创建可执行目标文件（二进制）hello。</li>
<li style="text-align:justify">通过shell调用fork函数创建一个新的进程，之后调用execve将hello文件载入内存，并为程序开辟一片运行空间。</li>
<li style="text-align:justify">CPU从内存中取代码和数据运行，有异常时触发异常处理子程序。</li>
<li style="text-align:justify">程序运行结束后，父进程回收hello进程，内核删除程序相关数据。</li>
</ol> 
<p style="margin-left:0;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify">
<a name="_Toc532238398"></a><a name="_Toc225579643"></a><a name="_Toc250450167">1.2 </a>环境与工具</h2> 
<p style="margin-left:0;text-align:justify">列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。.</p> 
<p style="margin-left:0;text-align:justify">硬件：i7-11800H 16GB内存</p> 
<p style="margin-left:0;text-align:justify">软件：Windows10专业版 Vmware16pro Ubuntu20.04 gcc gdb objdump</p> 
<p style="margin-left:0;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238399">1.3 中间结果</a></h2> 
<p style="margin-left:0;text-align:justify">列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。</p> 
<p style="margin-left:0;text-align:justify"><a name="_Hlk119336891">1.hello.i </a>预处理hello.c后得到的c语言文本文件</p> 
<p style="margin-left:0;text-align:justify">2.hello.s 编译hello.i后得到的汇编语言文本文件</p> 
<p style="margin-left:0;text-align:justify">3.hello.o 汇编hello.s后得到的可重定位目标文件（二进制）</p> 
<p style="margin-left:0;text-align:justify">4.hello.elf 用readelf读取hello.o得到ELF格式信息</p> 
<p style="margin-left:0;text-align:justify">5.hello.asm 将hello.o反汇编得到的反汇编文件</p> 
<p style="margin-left:0;text-align:justify">6.hello 将hello.o链接得到的可执行目标文件</p> 
<p style="margin-left:0;text-align:justify">7.hello1.elf 用readelf读取hello可执行文件得到ELF文件</p> 
<p style="margin-left:0;text-align:justify">8.hello1.asm 将hello可执行目标文件反汇编得到的反汇编文件</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238400">1.4 本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">本章对hello程序的一生各阶段的处理过程进行了概括，介绍了P2P，020，具体实现步骤，介绍了实现所用的软件硬件环境，介绍了过程中生成的中间结果文件及其作用。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc225579646"></a><a name="_Toc250450171"></a><a name="_Toc532238401">第2章 </a>预处理</h1> 
<h2 style="margin-left:0;text-align:justify">
<a name="_Toc532238402"></a><a name="_Toc225579647"></a><a name="_Toc250450172">2.1</a> 预处理的概念与作用</h2> 
<p style="margin-left:0;text-align:justify">概念：预处理器cpp根据文件开头字符#开头的指令修改原始c程序。</p> 
<p style="margin-left:0;text-align:justify">作用：根据预处理指令修改源代码，从系统头文件包中将头文件源码插入到源程序文件中，替换文件中常量与宏的数据代码，最终生成.i文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238403">2.2在Ubuntu下预处理的命令</a></h2> 
<p style="margin-left:0;text-align:justify">linux:gcc -E -o hello.i hello.c</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238404">2.3 Hello的预处理结果解析</a></h2> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">打开hello.i文件，可以看到在原先的代码中插入了几千行头文件源码，但仍然是c语言文本文件，原来的main函数部分在文件的最后可以看见，预处理将#后的指令找到系统中的头文件并添加入文件中，删除了不起作用的注释与空行，替换了一些常量值。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238405">2.4 本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">本章介绍了源程序处理成.i文件的概念过程与作用，得到了预处理是将源程序内容进行补充与修改，本质仍然是c语言程序的结论，了解了预处理的内涵。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238406">第3章 </a>编译</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238407">3.1 编译的概念与作用</a></h2> 
<p style="margin-left:0;text-align:justify">概念：在hello.i的基础上，编译器ccl将文件进一步处理成hello.s文本文件，它的本质是一个汇编语言的文本文件，以可以阅读的文本的形式描述机器指令。</p> 
<p style="margin-left:0;text-align:justify">作用：把c语言源程序翻译成汇编语言程序，并且进行语法分析找到语法错误并报错。为后续转化为机器语言二进制程序做准备。</p> 
<p style="margin-left:21pt;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238408">3.2 在Ubuntu下编译的命令</a></h2> 
<p style="margin-left:21pt;text-align:justify">gcc -S hello.i -o hello.s</p> 
<p style="margin-left:21pt;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238409">3.3 Hello的编译结果解析</a></h2> 
<p style="margin-left:0;text-align:justify">此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~ 3.3.x等按照类型和操作进行分析，<strong>只要</strong><strong>hello.s</strong><strong>中出现的属于大作业PPT</strong><strong>中P4</strong><strong>给出的参考C</strong><strong>数据与操作，都应解析</strong>。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3.3.1 hello.s 文件总体结构：</p> 
<p style="margin-left:0;text-align:justify">.file 源文件</p> 
<p style="margin-left:0;text-align:justify">.text 代码段</p> 
<p style="margin-left:0;text-align:justify">.section .rodata 只读变量</p> 
<p style="margin-left:0;text-align:justify">.align 对齐方式</p> 
<p style="margin-left:0;text-align:justify">.string 字符串类型</p> 
<p style="margin-left:0;text-align:justify">.global 全局变量</p> 
<p style="margin-left:0;text-align:justify">.type 函数类型对象类型</p> 
<p style="margin-left:0;text-align:justify">.data 已初始化全局变量静态变量</p> 
<p style="margin-left:0;text-align:justify">.size 文件大小</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3.3.2常量：</p> 
<p style="margin-left:0;text-align:justify">If语句中，判断输入个数是否等于4。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">常数4被保存在代码段.text中，作为指令一部分。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">Printf()打印出的字符串</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">被存储在.rodata中</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3.3.3变量：</p> 
<p style="margin-left:0;text-align:justify">全局变量：已初始化的全局变量存储在.data节中，未初始化的全局变量存储在.bss节中。</p> 
<p style="margin-left:0;text-align:justify">局部变量：局部变量存储在寄存器或栈中，例如 int i变量：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">在汇编代码中，其用%rsp -4栈位置存储。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3.3.4 赋值：</p> 
<p style="margin-left:0;text-align:justify">对局部变量用mov指令赋值，后缀代表数据大小</p> 
<p style="margin-left:0;text-align:justify">b 1字节 w 2字节 l 4字节 q 8字节</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3.3.5 算术操作：</p> 
<p style="margin-left:0;text-align:justify">汇编语言有如下算术指令：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">如for循环中，运算结束后，对i加一操作</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">在汇编语言中，使用addl指令</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3.3.6 数组、指针、结构操作：</p> 
<p style="margin-left:0;text-align:justify">主函数main中的有指针数组 char *argv[]</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">数组中，argv[0]为程序名称，argv[1]开始为字符串</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">可以看到，字符串存储在栈中，需要是读入寄存器中。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3.3.7 控制转移：</p> 
<p style="margin-left:0;text-align:justify">汇编语言中的无条件跳转操作用jmp指令加跳转位置，有条件跳转符号为j加对应的后缀，如if语句中的跳转：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">是用je指令判断是否跳转，上一步比较操作判断相等时跳转。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3.3.8 函数操作：</p> 
<p style="margin-left:0;text-align:justify">汇编语言中函数的通过call指令调用，传入参数使用六个寄存器，按顺序为%rdi，%rsi，%rdx，%rcx，%r8，%r9，更多的寄存器使用栈传入。</p> 
<p style="margin-left:0;text-align:justify">如printf函数，先将要打印的参数放入%rdi，%rsi中，再跳转到printf函数处：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">如sleep函数，先传入参数atoi(argv[3]),再用call指令调用</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3.3.9 关系操作：</p> 
<p style="margin-left:0;text-align:justify">关系操作使用cmp指令，后缀表示字节大小，如比较循环退出条件i&gt;9时使用cmpl指令</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238410">3.4 本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">本章介绍了编译的概念和过程，编译是将c语言程序翻译成汇编语言程序的过程，汇编语言每一条都对应着一条机器指令，以hello.c hello.s的具体代码为例，解释了各个数据类型以及各类操作是如何翻译的以及是如何运作的，验证了大部分数据与操作在汇编语言中的实现，对c语言翻译成汇编语言有了更加深入的了解。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:justify">
<a name="_Toc532238411">第4章 </a>汇编</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238412">4.1 汇编的概念与作用</a></h2> 
<p style="margin-left:0;text-align:justify">概念：汇编是指用汇编器as将编译器翻译得到的汇编语言文本文件.s文件翻译成机器语言二进制目标文件.o文件。</p> 
<p style="margin-left:0;text-align:justify">作用：汇编将汇编语言转化为机器语言，转化为可重定位目标程序，使程序可以直接让机器识别，并且可以结合其他文件生成可执行目标文件。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238413">4.2 在Ubuntu下汇编的命令</a></h2> 
<p style="margin-left:0;text-align:justify">生成.o文件：gcc -c -o hello.o hello.s</p> 
<p style="margin-left:0;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238414">4.3 可重定位目标elf格式</a></h2> 
<p style="margin-left:0;text-align:justify">分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。</p> 
<p style="margin-left:0;text-align:justify">生成.elf文件：readelf -a hello.o &gt; hello.elf</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">ELF结构分析：</p> 
<ol><li style="text-align:justify">ELF头：magic描述了生成该文件系统字大小与字节顺序，剩下部分描述了目标文件的基本信息帮助后续链接器分析，包括ELF头大小、目标文件类型、系统类型、节头部表文件偏移，以及节头部表中条目的大小和数量等信息。</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<ol><li style="text-align:justify">节头：描述了各个节的类型、地址、所占空间大小等信息。</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<ol><li style="text-align:justify">重定位条目：as生成目标文件时，有些数据与代码的最终位置并未确定，为了使链接器知道数据与代码存放在什么位置，需要用重定位条目存放需要重定位的信息。信息主要包括重定位信息在.text和.data节中的偏移位置重定位到的目标类型等。</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<ol><li style="text-align:justify">符号表：.symtab存放程序中定义和引用的函数和全局变量信息。</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<ol><li> 
  <ol><li style="text-align:justify"><a name="_Toc532238415"> Hello.o的结果解析</a></li></ol>
</li></ol> 
<p style="margin-left:0;text-align:justify">命令行输入objdump -d r hello.o &gt; hello.asm 指令输出hello.o的反汇编文件，分析hello.o的反汇编，并与第3章的 hello.s进行对照分析。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       对照分析：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       操作数：汇编语言.s文件中为十进制表示，机器语言反汇编后可以看出是十六进制表示。</p> 
<p style="margin-left:0;text-align:justify">      </p> 
<p style="margin-left:0;text-align:justify">      </p> 
<p style="margin-left:0;text-align:justify">       分支转移：汇编语言.s文件中跳转指令地址记为.L1，.L2这样的段名称，反汇编得到的.asm文件中跳转地址是明确的具体地址，体现为<a name="_Hlk119267467">目标指令地址与当前指令下一条指令地址之差</a>。</p> 
<p style="margin-left:0;text-align:justify">      </p> 
<p style="margin-left:0;text-align:justify">      </p> 
<p style="margin-left:0;text-align:justify">       全局变量访问：汇编语言.s文件中对全局变量的访问使用的是段名称加上（%rip）形式，反汇编得到的.asm文件则使用0x0(%rip)访问，并加上了重定位信息。</p> 
<p style="margin-left:0;text-align:justify">      </p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">函数调用：汇编语言.s文件中call后面直接加函数名称，反汇编生成的.asm文件call后面加目标指令地址与当前指令下一条指令地址之差，以及重定位信息。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"><a name="_Toc532238416">4.5 </a><strong>4.5</strong><strong>本章小结</strong></p> 
<p style="margin-left:0;text-align:justify">本章介绍了汇编的概念与作用，将hello.s 文件汇编成hello.o文件，生成ELF格式文件hello.elf文件为例，研究ELF格式文件的具体结构。通过比较反汇编文件hello.asm与汇编文件hello.s的区别，认识了汇编过程对文件做的改变，认识的这些改变为后续程序的链接做的准备。</p> 
<h1 style="margin-left:0;text-align:justify">
<a name="_Toc532238417">第</a>5章 链接</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238418">5.1 链接的概念与作用</a></h2> 
<p style="margin-left:0;text-align:justify">概念：链接是指链接器ld将可重定位目标文件.o文件合并整理成单一的可执行目标文件的过程。</p> 
<p style="margin-left:0;text-align:justify">作用：将为并入的常用函数文件与程序文件合并，使分离编译成为可能，方便程序员修改单一函数模块。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238419">5.2 在Ubuntu下链接的命令</a></h2> 
<p style="margin-left:0;text-align:justify">ld -o hello -dynamic -linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o</p> 
<p style="margin-left:0;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238420">5.3 可执行目标文件hello的格式</a></h2> 
<p style="margin-left:0;text-align:justify">分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。</p> 
<p style="margin-left:0;text-align:justify">在命令行输入命令 readelf -a hello &gt;hello1.elf 生成可执行目标程序hello的ELF格式文件，保存为hello1.elf。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">对hello.elf进行分析，对比hello.elf，得到结果如下：</p> 
<ol><li style="text-align:justify">ELF头：</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">与hello.elf相比，hello1.elf中的主要信息未改变，类型发生了改变，有了明确的入口点地址，程序头大小与节头部数量增加了。</p> 
<ol><li style="text-align:justify">节头：</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">      与hello.elf 相比，hello1.elf节头数量增加了,并且重新设置了每个符号的地址。</p> 
<ol><li style="text-align:justify">程序头</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello1.elf 比hello.elf多了程序头，它被用来描述系统准备执行程序时需要的段等信息。</p> 
<p style="margin-left:0;text-align:justify">4.符号表：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       Hello1.elf符号表中保存了所有重定位时需要引用符号的说明信息。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238421">5.4 hello的虚拟地址空间</a></h2> 
<p style="margin-left:0;text-align:justify">使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 </p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">通过edb data dump查看加载到虚拟地址的程序代码。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238422">5.5 链接的重定位过程分析</a></h2> 
<p style="margin-left:0;text-align:justify">在命令行输入objdump -d -r hello &gt; hello1.asm生成反汇编文件hello1.asm</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">与hello.asm比较，分析不同之处：</p> 
<ol><li style="text-align:justify">加入了.plt,puts@plt,printf@plt,getchar@plt,等函数代码，因为链接器将共享库中用到的函数加入到可执行文件中。</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<ol><li style="text-align:justify">函数调用指令，跳转指令参数被重定位得到了具体地址。链接器解析重定位条目，计算出调用函数与当前指令下一条之间的相对距离</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"><a name="_Toc532238423">5.6 hello</a>的执行流程</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">Shell调用操作系统代码运行，加载器通过头部表信息将hello可执行文件的片复制到代码段和数据段，随后跳转到程序入口点_start函数的位置，随后加载库函数，最后运行main函数，处理main函数的返回值，并且在需要的时候把控制返回给内核。</p> 
<p style="margin-left:0;text-align:justify">_init                401000</p> 
<p style="margin-left:0;text-align:justify">.plt                 401020</p> 
<p style="margin-left:0;text-align:justify">puts@plt            401090</p> 
<p style="margin-left:0;text-align:justify">printf@plt           4010a0</p> 
<p style="margin-left:0;text-align:justify">getchar@plt         4010b0</p> 
<p style="margin-left:0;text-align:justify">atoi@plt            4010c0</p> 
<p style="margin-left:0;text-align:justify">exit@plt            4010d0</p> 
<p style="margin-left:0;text-align:justify">sleep@plt           4010e0</p> 
<p style="margin-left:0;text-align:justify">_start               4010f0</p> 
<p style="margin-left:0;text-align:justify">_dl_relocate_static_pie 401120</p> 
<p style="margin-left:0;text-align:justify">main               401125</p> 
<p style="margin-left:0;text-align:justify">__libc_csu_init       4011c0</p> 
<p style="margin-left:0;text-align:justify">__libc_csu_fini       401230</p> 
<p style="margin-left:0;text-align:justify">_fini                401238</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238424">5.7 Hello的动态链接分析</a></h2> 
<p style="margin-left:0;text-align:justify">找到.section节中有.got节</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">打开edb查看：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">GOT是一个数组，每个条目八个字节，GOT[0]指向_libc_start_main,GOT[1]指向重定位表，GOT[2]指向动态链接器ld-linux.so运行地址。对于动态共享链接库中PIC函数，编译器没有办法预测函数的运行地址，所以需要添加重定位记录，等待动态链接器的处理，为避免运行时修改调用的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT + 全局变量偏移表GOT实现函数的动态链接，GOT中存放目标函数的地址，PLT使用该地址跳转到目标位置。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238425">5.8 本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">本章介绍了链接的概念和作用，详细分析了hello.o链接成为可执行目标文件的全过程，介绍了可执行文件hello的ELF格式和各个节的意义，分析了hello的虚拟地址空间、重定位过程、执行流程、动态链接过程，从中清楚明白了可执行文件可供执行的要素。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238426">第</a>6章 hello进程管理</h1> 
<h2 style="margin-left:0;text-align:justify">
<a name="_Toc532238427">6.1 进程的概念与作用</a><a name="_Toc532238428"></a>
</h2> 
<p style="margin-left:0;text-align:justify">       概念：进程就是一个正在运行中的程序，每启动一个进程，操作系统就会分配给其一定的运行资源保证其运行。</p> 
<p style="margin-left:0;text-align:justify">       作用：进程使得程序好像可以独占cpu，好像是系统中唯一的程序，这使得计算机同时运行多个独立的程序成为可能。</p> 
<h2 style="margin-left:0;text-align:justify">6.2 简述壳Shell-bash的作用与处理流程</h2> 
<p style="margin-left:0;text-align:justify">shell是一个交互型应用级程序，代表用户运行其他程序。是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。处理过程如下：</p> 
<ol>
<li style="text-align:justify">终端输入命令</li>
<li style="text-align:justify">将输入的字符串切分得到所有命令参数</li>
<li style="text-align:justify">如果是系统内置命令则立即执行</li>
<li style="text-align:justify">如果不是，则调用fork为其分配子进程并执行</li>
<li style="text-align:justify">Shell必须对键盘输入等异常做出反应</li>
</ol> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238429">6.3 Hello的fork进程创建过程</a></h2> 
<p style="margin-left:0;text-align:justify">       Shell通过调用fork函数创建一个新的运行的子进程，子进程与父进程pid不同，但得到了父进程代码、数据段、堆、共享库、用户栈相同的一份副本。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238430">6.4 Hello的execve过程</a></h2> 
<p style="margin-left:0;text-align:justify">       Execve函数的功能是在当前进程的上下文加载运行一个程序。加载并运行可执行目标文件filename，带有参数列表argv环境变量envp。出现错误时，execve返回到调用程序，execve调用一次不返回。需要删除已存在的用户区域，删除之前进程在用户部分已存在的结构，创建新的代码段、数据、堆和栈段。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238431">6.5 Hello的进程执行</a></h2> 
<p style="margin-left:0;text-align:justify">       Hello程序的执行依赖于进程提供给程序一个独立逻辑控制流与一个私有地址空间这两个抽象。</p> 
<p style="margin-left:0;text-align:justify">       一个独立的逻辑控制流，使得进程好像独占使用cpu。</p> 
<p style="margin-left:0;text-align:justify">       上下文切换使得系统在某个进程发生阻塞时切换到其他进程，使当前进程休眠，使一种特殊的异常控制流。</p> 
<p style="margin-left:0;text-align:justify">       时间片是指进程执行它的控制流的及部分的每一个时间段。</p> 
<p style="margin-left:0;text-align:justify">       Hello执行过程：进程调用execve函数，进程为hello程序分配新的虚拟地址空间，hello循环输出hello 2021113451 魏嘉浩，调用sleep函数，运行信号处理程序。运行过程中，cpu不断切换上下文，使运行过程被分成若干时间片，不同进程交替占用cpu，实现进程的调度。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238432">6.6 hello的异常与信号处理</a></h2> 
<p style="margin-left:0;text-align:justify">       异常信号处理种类：</p> 
<p style="margin-left:0;text-align:justify">       中断：来自外部I/O设备 异步返回下一条指令</p> 
<p style="margin-left:0;text-align:justify">       陷阱：有意的执行指令的结果 同步返回下一条指令</p> 
<p style="margin-left:0;text-align:justify">       终止：不可恢复错误 同步不返回</p> 
<p style="margin-left:0;text-align:justify">       故障：潜在可恢复错误 同步 可能返回到当前指令或终止</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       运行：</p> 
<ol><li style="text-align:justify">正常运行：</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       2．按 ctrl-c</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">调用ps命令发现前台没有hello进程</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       3．按 ctrl-z</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">输入ctrl-z挂起进程，进程运行在后台，用ps命令可以看到进程，后台job号为1，调用fg 1将其调出至前台，shell打印命令行命令并继续执行程序，执行结束回收进程。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">输入jobs：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">输入pstree</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">输入kill：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<ol><li style="text-align:justify">按回车</li></ol> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">按回车会导致回车被记入，并程序结束后作为命令输入。</p> 
<p style="margin-left:0;text-align:justify">       乱按键盘：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">同样，如果乱按一个ps，将在程序结束后执行ps命令。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238433">6.7本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">本章介绍了进程的概念和作用，shell程序的作用于处理过程，分析了fork创建新进程过程与execve执行hello程序过程，以及不同情况下hello运行时的异常信号处理。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238434">第</a>7章 hello的存储管理</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238435">7.1 hello的存储器地址空间</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify">结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238436">7.2 Intel逻辑地址到线性地址的变换-段式管理</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238437">7.3 Hello的线性地址到物理地址的变换-页式管理</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238438">7.4 TLB与四级页表支持下的VA到PA的变换</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238439">7.5 三级Cache支持下的物理内存访问</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238440">7.6 hello进程fork时的内存映射</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238441">7.7 hello进程execve时的内存映射</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238442">7.8 缺页故障与缺页中断处理</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238443">7.9动态存储分配管理</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify"><em>Printf</em><em>会调用malloc</em><em>，请简述动态内存管理的基本方法与策略。</em></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238444">7.10本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:center"><strong><span style="color:#ff0000">（第</span></strong><strong><span style="color:#ff0000">7</span></strong><strong><span style="color:#ff0000">章</span></strong><strong><span style="color:#ff0000"> 2</span></strong><strong><span style="color:#ff0000">分）</span></strong></p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238445">第</a>8章 hello的IO管理</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238446">8.1 Linux的IO设备管理方法</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify">设备的模型化：文件</p> 
<p style="margin-left:0;text-align:justify">设备管理：unix io接口</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238447">8.2 简述Unix IO接口及其函数</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238448">8.3 printf的实现分析</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify"><a href="https://www.cnblogs.com/pianist/p/3315801.html" title="[转]printf 函数实现的深入剖析 - Pianistx - 博客园">[转]printf 函数实现的深入剖析 - Pianistx - 博客园</a></p> 
<p style="margin-left:0;text-align:justify">从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用 int 0x80或syscall等.</p> 
<p style="margin-left:0;text-align:justify">字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。</p> 
<p style="margin-left:0;text-align:justify">显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238449">8.4 getchar的实现分析</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify">异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。</p> 
<p style="margin-left:0;text-align:justify">getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238450">8.5本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:center"><strong><span style="color:#ff0000">（第</span></strong><strong><span style="color:#ff0000">8</span></strong><strong><span style="color:#ff0000">章</span></strong><strong><span style="color:#ff0000">1</span></strong><strong><span style="color:#ff0000">分）</span></strong></p> 
<h1 style="margin-left:0;text-align:center"><a name="_Toc532238451">结论</a></h1> 
<p style="margin-left:0;text-align:justify">用计算机系统的语言，逐条总结hello所经历的过程:</p> 
<p style="margin-left:0;text-align:justify">hello.c：文本编写c语言源程序，每个字符都是用ascall编码表示。</p> 
<p style="margin-left:0;text-align:justify">hello.i：hello.c经过预处理阶段，将引用的库展开合并成为预处理文本文件hello.i，仍然是C语言形式。</p> 
<p style="margin-left:0;text-align:justify">hello.s:hello.i经过编译阶段变为汇编语言文本文件hello.s。</p> 
<p style="margin-left:0;text-align:justify">hello.o：hello.s经过汇编阶段变为机器语言二进制文件可重定位目标文件hello.o。</p> 
<p style="margin-left:0;text-align:justify">hello：hello.o可重定位目标文件和动态链接库链接成为机器语言二进制文件可执行文件hello。</p> 
<p style="margin-left:0;text-align:justify">运行：在终端输入./hello 2021113451 魏嘉浩 1。</p> 
<p style="margin-left:0;text-align:justify">创建子进程： shell-bash调用fork函数创建一个子进程。</p> 
<p style="margin-left:0;text-align:justify">加载：shell 调用 execve，execve 调用启动加载器loader，添加映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入 main 函数。</p> 
<p style="margin-left:0;text-align:justify">上下文切换:hello可与多个进程并行运行。hello调用sleep函数之后进程陷入内核模式，处理休眠请求主动释放当前进程，内核进行上下文切换将当前进程的控制权交给其他进程，当sleep函数调用完成时，内核执行上下文切换将控制传递给当前进程。</p> 
<p style="margin-left:0;text-align:justify">信号管理：当程序在运行的时候我们输入Ctrl+c，内核会发送SIGINT信号给进程并终止前台作业。当输入Ctrl+z时，内核会发送SIGTSTP信号给进程，并将前台作业停止挂起，输入其他符号时，系统会保存符号，在程序结束时视为输入这些符号。</p> 
<p style="margin-left:0;text-align:justify">终止：当子进程执行完成时，内核安排父进程回收子进程，将子进程的退出状态传递给父进程。内核删除为这个进程创建的所有数据结构。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法:</p> 
<p style="margin-left:0;text-align:justify">通过本课程的学习与本次大作业的实践，我深刻感受到计算机系统设计的精妙与合理，一个程序运行涉及到一系列复杂操作，使得人编写的高级语言的程序可以让计算机运行，并且考虑到不同程序的并发运行而使用操作系统内核对程序进行上下文切换，为了实现存储器的快速访问设计出多级缓存的存储器结构，使得程序能快速运行。这些设计都是几十年内很多计算机科学家与工程师不断摸索总结出来的合理的计算机系统设计。我们以后要在前人的努力下继续努力，将计算机科学这门学科发展得更完善。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc225579656"></a><a name="_Toc250450180"></a><a name="_Toc532238452">附件</a>
</h1> 
<p style="margin-left:0;text-align:justify"><a name="_Hlk119336962">1.hello.i </a>预处理hello.c后得到的c语言文本文件</p> 
<p style="margin-left:0;text-align:justify">2.hello.s 编译hello.i后得到的汇编语言文本文件</p> 
<p style="margin-left:0;text-align:justify">3.hello.o 汇编hello.s后得到的可重定位目标文件（二进制）</p> 
<p style="margin-left:0;text-align:justify">4.hello.elf 用readelf读取hello.o得到ELF格式信息</p> 
<p style="margin-left:0;text-align:justify">5.hello.asm 将hello.o反汇编得到的反汇编文件</p> 
<p style="margin-left:0;text-align:justify">6.hello 将hello.o链接得到的可执行目标文件</p> 
<p style="margin-left:0;text-align:justify">7.hello1.elf 用readelf读取hello可执行文件得到ELF文件</p> 
<p style="margin-left:0;text-align:justify">8.hello1.asm 将hello可执行目标文件反汇编得到的反汇编文件。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center"><a name="_Toc532238453">参考文献</a></h1> 
<p style="margin-left:0;text-align:justify">[1] https://www.cnblogs.com/diaohaiwei/p/5094959.html</p> 
<p style="margin-left:0;text-align:justify">[2] 深入理解计算机系统原书第3版-文字版.pdf</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>