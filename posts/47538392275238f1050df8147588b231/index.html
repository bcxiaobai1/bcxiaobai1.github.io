<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C语言人工智能 |教你与智能AI对弈三子棋 从此不再孤单寂寞冷 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言人工智能 |教你与智能AI对弈三子棋 从此不再孤单寂寞冷</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p>我们知道 生活中 孤独寂寞的时候很多，既然我们手中已经掌握了编程的技术，<strong>那为何不利用我们的技能创建 一个智能Al来陪我们对弈下棋，让我们不再孤独呢？</strong><br> 于是这款 AI三子棋就因需而生了</p> 
<p><span style="color:#4da8ee"><strong>这篇博客将手把手教会你 自己解决孤独！</strong></span></p> 
<blockquote> 
 <h1 id="1.%E4%B8%BB%E7%95%8C%E9%9D%A2%20%E8%AF%A2%E9%97%AE%E6%98%AF%E5%90%A6%E5%AD%A4%E7%8B%AC">1.主界面 询问是否孤独</h1> 
</blockquote> 
<p><img alt="" height="181" src="https://images2.imgbox.com/ed/30/YtKj4WLD_o.png" width="338"></p> 
<pre><code class="language-cpp">void Main_menu() {
		printf("*************************n");
		printf("******1. 我很孤独********n");
		printf("******0. 我不孤独********n");
		printf("*************************n");
		printf("******2. 我不理解********n");
	}</code></pre> 
<p><span style="color:#4da8ee"> 暖心AI询问是否孤独</span> ，来决定是否 帮助玩家派遣孤独</p> 
<p>这里明显需要 用到<span style="color:#4da8ee">选择结构 </span>我们这里用<span style="color:#956fe7">switch语句</span>来实现</p> 
<p><strong>代码：</strong></p> 
<pre><code class="language-cpp">int main() {
	srand((unsigned int)time(NULL)); 这是待会要用到的 随机数的初始化 暂时先不管
	int input; 用来储存玩家选的的序号
	do {
		Main_menu();
		printf("请选择序号:&gt;");
		scanf("%d", &amp;input); 存放玩家选择的序号
		switch (input) {
		case 1:   /如果你很孤独，AI就会陪伴你
			printf("n既然你很孤独，我们来下棋吧！n");
			printf("n需要看规则吗？nn"); /暖心AI的望闻问切
			printf("1. 需要，我不知道怎么下n");
			printf("2. 不需要，我是高手n");
			int tmp;/用来储存这次选择的序号
			scanf(" %d", &amp;tmp);
			switch (tmp) {
			case 1:
				INFOR();/编写好的 信息模块，里面有游戏规则和其他信息，在文章后面我会有讲解
				break;
			case 2:
				printf("请:&gt;n");
				game();/直接进入游戏模块
				break;
			}
			break;
		case 0: /不孤独的话就不要浪费时间了
			printf("不孤独就退出程序");
			break;
		case 2: /玩家 表示不理解 AI耐心的解释
			printf("n这是一款 能在孤独时陪你下棋的温暖AI!!!nn");
            break;
		default:
			printf("选择序号有误，请重新选择&gt;n");

		}
	} while (input != 0);/当玩家选择0 就会退出


	return 0;
}</code></pre> 
<p><strong><span style="color:#4da8ee">根据 玩家不同的选择</span><span style="color:#0d0016"> 进入到不同的模块</span></strong></p> 
<h2 id="%E5%BD%93%E7%8E%A9%E5%AE%B6%E9%80%89%E6%8B%A9%200%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%BB%96%E5%B9%B6%E4%B8%8D%E5%AD%A4%E7%8B%AC%EF%BC%9A">当玩家选择 0，表示他并不孤独：</h2> 
<p><img alt="" height="182" src="https://images2.imgbox.com/56/3b/AGPk5MPy_o.png" width="326"></p> 
<p><span style="color:#4da8ee">AI表示很无语，显然它不想浪费时间</span> </p> 
<h2 id="%E5%BD%93%E7%8E%A9%E5%AE%B6%E9%80%89%E6%8B%A9%202%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%BB%96%E4%B8%8D%E7%90%86%E8%A7%A3%EF%BC%9A">当玩家选择 2，表示他不理解：</h2> 
<p><img alt="" height="388" src="https://images2.imgbox.com/dc/bf/Dtnia59X_o.png" width="510"></p> 
<p><span style="color:#4da8ee">AI会很耐心的像玩家解释 这是什么。</span></p> 
<h2 id="AI%E8%AF%A2%E9%97%AE%E7%8E%A9%E5%AE%B6%C2%A0%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E8%A7%84%E5%88%99">AI询问玩家 是否需要了解规则</h2> 
<h3 id="%C2%A0%E5%BD%93%E7%8E%A9%E5%AE%B6%E9%80%89%E6%8B%A9%201%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%BB%96%E5%BE%88%E5%AD%A4%E7%8B%AC%EF%BC%9A"><span style="color:#4da8ee"> 当玩家选择 1，表示他很孤独：</span></h3> 
<p><img alt="" height="390" src="https://images2.imgbox.com/d0/53/k04qgJTF_o.png" width="421"></p> 
<p><span style="color:#6eaad7">暖心AI会贴心的提出一起下棋的建议，并贴心的询问玩家是否 熟悉三子棋游戏的规则。</span></p> 
<h3 id="%E5%BD%93%E7%8E%A9%E5%AE%B6%E9%80%89%E6%8B%A9%201%EF%BC%8C%E4%BB%96%E4%B8%8D%E7%9F%A5%E9%81%93%E8%A7%84%E5%88%99%EF%BC%9A">当玩家选择 1，他不知道规则：</h3> 
<p><img alt="" height="257" src="https://images2.imgbox.com/4f/a5/G1iernzN_o.png" width="313"></p> 
<p></p> 
<p>这时就会进入我们编写好的 <span style="color:#956fe7">信息模块</span> 里面有<span style="color:#4da8ee">游戏规则和智能AI的说明信息</span></p> 
<p>首先我们把 游戏规则和AI信息等需要说明的内容都封装到一个<span style="color:#4da8ee">源文件</span>里，在把函数的定义写到一个<span style="color:#4da8ee">头文件</span>里</p> 
<p><span style="color:#4da8ee"><strong>源文件内容：</strong></span></p> 
<pre><code class="language-cpp">#include"menu.h"/引上头文件

void Infor_menu() {
	printf("1.三子棋游戏规则n");
	printf("2.游戏简介n");
	printf("0.都懂了（EXIT）n");
}
void rules() {
	
	printf("1. 下棋走子 需要输入棋盘坐标，输入时用空格隔开n");
	printf("如 想在棋盘第一行第一列走子:应输入 "1 1" ; 三子一线即胜利:&gt;n");
	printf("n");
}
void infor() {
	printf("该游戏的对手是凝聚了作者 目前所有的编程智慧结晶的AI副本n"); 
	printf("原本难度极大，为了派遣你的孤独和保护你的心理健康故意放水n若是不放水，难免日后留下难以消除的心理阴影 :&gt;n");
	printf("n");

}
</code></pre> 
<p><strong><span style="color:#4da8ee">头文件内容：</span></strong></p> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;

/主菜单
void Main_menu();
/信息菜单
void Infor_menu();
/规则菜单
void rules();
/游戏简介
void infor();</code></pre> 
<p>然后再信息模块的函数中 <span style="color:#4da8ee"><strong>根据玩家的选择 调用对应的函数</strong></span>，玩家想得到的信息就会被打印出来</p> 
<p><span style="color:#1c7892">信息模块代码</span></p> 
<pre><code class="language-cpp">void INFOR() {
	int input = 1;

	while (input) {
		Infor_menu();/提示玩家选择对应的序号
		printf("请选择序号:");
		scanf("%d", &amp;input);
		printf("n");
		switch (input) {
		case 1:rules();/查看规则
			break;
		case 2:infor();/AI信息
			break;
		case 0:
			printf("都懂了就来下棋吧！n");/进入游戏
			game();
			break;
		default:
			printf("输入无效，请重新输入n");

		}
	}
}</code></pre> 
<p><span style="color:#4da8ee">因为是循环体 所有玩家可以 依次查看不同的信息 ，</span><span style="color:#0d0016"><strong>最后进入游戏，也就是调用game函数。</strong></span></p> 
<p><img alt="" height="666" src="https://images2.imgbox.com/bd/83/Q0FSc2tm_o.png" width="799"><img alt="" height="320" src="https://images2.imgbox.com/54/c5/GIHpDee8_o.png" width="303"></p> 
<p></p> 
<p></p> 
<blockquote> 
 <h1 id="%E5%BC%80%E5%A7%8B%E4%B8%8B%E6%A3%8B%EF%BC%8C%E5%9F%BA%E6%83%85%E5%AF%B9%E5%BC%88">开始下棋，基情对弈</h1> 
</blockquote> 
<h2 id="1.%E6%B8%B8%E6%88%8F%E4%B8%BB%E4%BD%93">1.游戏主体</h2> 
<p>下棋是怎么实现的呢？</p> 
<p><span style="color:#4da8ee">不多说，先浏览一下代码，<strong>我会再把每一部分拿出来慢慢说明</strong>:</span></p> 
<pre><code class="language-cpp">void game() {
	/储存数据 二维数组
	char Board[ROW][COL];
	/初始化棋盘 - 初始化为空格
	InitBoard(Board,ROW,COL);
	/接受游戏状态信息
    char A ;
	/打印棋盘 — 打印数组内容
	DisplayBoard(Board, ROW, COL);
    进入游戏 你一步 我一步 直到游戏结束
	while(1) {
        /玩家走- 实现赋值的函数
		Player_Move(Board, ROW, COL);
        /走完打印棋盘
        DisplayBoard(Board, ROW, COL);
        /判断游戏状态
		 A = Is_win(Board, ROW, COL);/判断游戏状态的函数
		if (A != 'C')/如果棋盘未满 还没有分出胜负就会返回字符c
			break;/如果不是c就结束游戏
        /AI走
		Computer_Move(Board, ROW, COL);
		/AI思考很快 为了不让玩家自卑故意等一下再走棋
        Sleep(1000);
        /走完打印棋盘
		DisplayBoard(Board, ROW, COL);
        /判断游戏状态
		A = Is_win(Board, ROW, COL);
		if (A != 'C')
			break;
	}

    当游戏结束 查看是平局了还是一方赢了
    /判断游戏状态的函数会根据游戏的状态返回不同的值
	switch (A) {/打印出对应的结果后，返回到主界面 询问是否还是孤独 
	case 'P':
		Sleep(1000);
		printf("平局了,再来一把吧!n");
		break;
	case'X':
		Sleep(1000); 
		printf("你赢了，好厉害!n");
		break;
	case'O':
		Sleep(1000); 
		printf("电脑赢了，笨蛋!n");
		break;
	}
}</code></pre> 
<p>很清楚的是，我们还是通过 <span style="color:#4da8ee">把游戏需要用到的动作封装好</span> 再<span style="color:#4da8ee">依次调用</span>，这样就能很流畅的进行玩家和智能AI的对弈</p> 
<h2 id="2.%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85">2.功能封装</h2> 
<p> 所以我们依旧是把游戏里的函数定义放到一个<span style="color:#4da8ee">源文件</span>，函数声明放到一个<span style="color:#4da8ee">头文件</span>中</p> 
<h3 id="%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%3A"><span style="color:#4da8ee"><strong>头文件代码:</strong></span></h3> 
<pre><code class="language-cpp">#pragma once
/游戏里需要的库函数
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
#include&lt;Windows.h&gt;
#define ROW 3/定义棋盘行数
#define COL 3/定义棋盘列数
/初始化棋盘的函数
void InitBoard(char Board[ROW][COL], int row, int col);
/打印棋盘的函数
void DisplayBoard(char Board[ROW][COL], int row, int col);
/玩家走- 实现赋值的函数
void Player_Move(char Board[ROW][COL], int row ,int col);
/电脑走- 限制随机 赋值的函数
void Computer_Move(char Board[ROW][COL], int row, int col);
/判断是否需要结束游戏
char Is_win(char Board[ROW][COL], int row, int col);
/判断棋盘是否满了的函数
int Is_full(char Board[ROW][COL], int row, int col);</code></pre> 
<h3 id="%E6%BA%90%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%EF%BC%9A"><span style="color:#4da8ee">源文件代码：</span></h3> 
<pre><code class="language-cpp">
#include"game.h" /引上头文件 
完成函数的定义
初始化棋盘 先将数组的元素都设为0
void InitBoard(char Board[ROW][COL], int row, int col) {
	for (int i = 0; i &lt; row; i++) {
		for (int j = 0; j &lt; col; j++)
			Board[i][j] = ' ';
	}
}
打印函数 
void DisplayBoard(char Board[ROW][COL], int row, int col) {
	int r;
	int c;
	for (r = 0; r &lt; row; r++) {
		for (c = 0; c &lt; col; c++) {
			printf(" % c ", Board[r][c]);
			if (c + 1 &lt; col)
				printf("|");
		}
		printf("n");
		printf("---|---|---n");

	}

}
玩家下棋的函数
void Player_Move(char Board[ROW][COL], int row, int col) {
	printf("玩家走:&gt;");
	int ro, co;
	while (1) {
		scanf("%d %d", &amp;ro, &amp;co);
		if (ro &lt;= row &amp;&amp; co &lt;= col &amp;&amp; ro &gt; 0 &amp;&amp; co &gt; 0 &amp;&amp; Board[ro - 1][co - 1] == ' ') {
			Board[ro - 1][co - 1] = 'X';
			break;
		}
		else {
			if (!(ro &lt;= row &amp;&amp; co &lt;= col &amp;&amp; ro &gt; 0 &amp;&amp; co &gt; 0))
			{
				printf("输错了 重新输入:&gt;n");
			}
			else
			{
				printf("这个点(%d,%d)已经有棋子了，不许叠罗汉n",ro,co);
			}
			DisplayBoard(Board, row, col);
		}
	}
}
人工智能AI下棋的函数
void Computer_Move(char Board[ROW][COL], int row, int col) {
	int ro, co;
	printf("AI走:&gt;n");
	while (1) {
		ro = rand() % row;
		co = rand() % col;
		if (Board[ro][co] == ' ') {
			Board[ro][co] = 'O';
			break;
		}
	}

}
判断棋盘是否下满的函数
int Is_full(char Board[ROW][COL], int row, int col) {
	int i = row;
	int j = col;
	int flag = 1;
	for (i = 0; i &lt; row; i++) {
		for (j = 0; j &lt; col; j++) {
			if (Board[i][j] == ' ')
				flag = 0;
		}
	}
	return flag;
}
判断输赢的函数
char Is_win(char Board[ROW][COL], int row, int col) {
	int i;
	int j;
	int flag;
	flag= 0;
	for (i = 0; i &lt; row; i++, flag = 0) {
		
		for (j = 1; j &lt; col; j++) {
			if (' ' == Board[i][j - 1] || ' ' == Board[i][j]) {
				continue;
			}
			if (Board[i][j] == Board[i][j-1]) {
				flag++;
				if (flag == 2)
					return Board[i][j];
			}
			
		}
		
	}

	for (j = flag = 0; j &lt; col; j++, flag = 0) {

		for (i = 1; i &lt; row; i++) {

			if (' ' == Board[i-1][j] || ' ' == Board[i][j]) {
				continue;
			}
			if (Board[i][j] == Board[i-1][j])
				flag++;
			if (2 == flag)
				return Board[i][j];
		}
		
	}
	
	for (i = 1,flag = 0; i &lt; row; i++) {
		
		if ((Board[i][i] == Board[i - 1][i - 1])&amp;&amp;Board[i][i]!=' ') {
			flag++;
		}
		if (2==flag) {
			return Board[i][i];
		}
	}

	for (i = 1, j = 1, flag = 0; i &lt; row&amp;&amp;j&gt;=0; i++,j--) {
		//0,2 //1,1 //2,0 
		if ((Board[i][j] == Board[i - 1][j + 1]) &amp;&amp; Board[i][j] != ' ') {
			flag++;
		}
		if (2 == flag) {
			return Board[i][j];
		}

	}
	
	if(Is_full(Board,row,col)){
		return 'P';
	}
	return 'C';
}
</code></pre> 
<p id="%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E5%B0%B1%E6%9D%A5%E9%80%90%E4%B8%80%E5%88%86%E6%9E%90%20%E8%BF%99%E4%BA%9B%E5%8A%9F%E8%83%BD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span style="color:#0d0016"><strong>接下来我们就来逐一分析 这些功能是怎么实现的</strong></span></p> 
<h3 id="%EF%BC%881%EF%BC%89%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%8B%E7%9B%98%E7%9A%84%E5%87%BD%E6%95%B0">（1） 初始化棋盘的函数</h3> 
<p>我们下棋就是不断地修改 一个<strong>二维数组（棋盘）</strong>的值，所以第一步当然是创建好一个 <strong>二维数组</strong></p> 
<p><strong>将它的值都赋为 空格。</strong></p> 
<pre><code class="language-cpp">初始化棋盘 先将数组的元素都设为0
void InitBoard(char Board[ROW][COL], int row, int col) {
	for (int i = 0; i &lt; row; i++) {
		for (int j = 0; j &lt; col; j++)
			Board[i][j] = ' ';
	}
}</code></pre> 
<h3 id="%EF%BC%882%EF%BC%89%20%E6%89%93%E5%8D%B0%E6%A3%8B%E7%9B%98%E7%9A%84%E5%87%BD%E6%95%B0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0">（2） 打印棋盘的函数       </h3> 
<p>接下来就是打印棋盘了，我们并不是单纯是将 数组的每一个元素打印出来，而是要耍一点花样，</p> 
<p>打印出棋盘该有的样子：</p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/ce/32/WKR2OOZr_o.png" width="178"></p> 
<pre><code class="language-cpp">打印棋盘的函数
void DisplayBoard(char Board[ROW][COL], int row, int col) {
	int r;
	int c;
	for (r = 0; r &lt; row; r++) {
		for (c = 0; c &lt; col; c++) {
			printf(" % c ", Board[r][c]);/ 打印空格 字符 空格
			if (c + 1 &lt; col)
				printf("|");/每个格子用|符号隔开
		}
		printf("n");/换行
		printf("---|---|---n");/每行之间加一行间隔

	}
}</code></pre> 
<h3 id="%C2%A0%EF%BC%883%EF%BC%89%E7%8E%A9%E5%AE%B6%E4%B8%8B%E6%A3%8B%E7%9A%84%E5%87%BD%E6%95%B0"> （3）玩家下棋的函数</h3> 
<p>玩家下棋 的过程由三个过程组成:&gt;</p> 
<p>1. 玩家输入行 和 列 </p> 
<p>2.判断玩家输入的行列是否在棋盘的范围内</p> 
<p>3.判断这个点是否已经下过，若已经下过，便温馨给予提示，重新输入</p> 
<p>4.若该行列合法，<strong>将玩家输入的行列都减一，就得到了该点在二维数组里的下标，</strong>把这个值赋值为字符<strong>X</strong></p> 
<p>5.最后一部，<strong>打印赋值后的棋盘，玩家下棋的这个过程就完毕了</strong></p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/cb/c5/cQOTRKg3_o.png" width="586"></p> 
<p></p> 
<pre><code class="language-cpp">玩家下棋的函数
void Player_Move(char Board[ROW][COL], int row, int col) {
	printf("玩家走:&gt;");
	int ro, co;
	while (1) {
		scanf("%d %d", &amp;ro, &amp;co);
		if (ro &lt;= row &amp;&amp; co &lt;= col &amp;&amp; ro &gt; 0 &amp;&amp; co &gt; 0 &amp;&amp; Board[ro - 1][co - 1] == ' ') {
			Board[ro - 1][co - 1] = 'X';
			break;
		}
		else {
			if (!(ro &lt;= row &amp;&amp; co &lt;= col &amp;&amp; ro &gt; 0 &amp;&amp; co &gt; 0))
			{
				printf("输错了 重新输入:&gt;n");
			}
			else
			{
				printf("这个点(%d,%d)已经有棋子了，不许叠罗汉n",ro,co);
			}
			DisplayBoard(Board, row, col);成功赋值后 打印棋盘
		}
	}
}</code></pre> 
<p id="main-toc"><strong>（4）AI下棋的函数</strong></p> 
<p>我们创建的这个人工智能AI是来陪玩家下棋的，自然不能太聪明，若是把玩家弄自闭了，不但起不到陪伴的作用，玩家怒火中烧，结局可能会很难收场，于是乎我们通过随机数的方式，让我们的暖心AI的<strong>智能恰到好处</strong></p> 
<p>我们这样来实现：</p> 
<p>1.生成两个随机值</p> 
<p>2.分别对棋盘的最大行，列取模，这样就能直接组成一个二维数组范围内的下标</p> 
<p>3.判断这个点是否被下过，若已经被下过，则重新生成</p> 
<p>4.若没有被下过，赋值</p> 
<p>5.打印</p> 
<p></p> 
<p><img alt="" height="469" src="https://images2.imgbox.com/91/7c/Tk3U1eaP_o.png" width="576"></p> 
<pre><code class="language-cpp">AI下棋的函数
void Computer_Move(char Board[ROW][COL], int row, int col) {
	int ro, co;/用来装AI要下的行列
	printf("AI走:&gt;n");
	while (1) {/依旧用循环结构，成功赋值则跳出
		ro = rand() % row;/随机数对棋盘的行取模，得到一个棋盘范围的行号
		co = rand() % col;/同理对棋盘的列取模，得到一个棋盘范围的列号
		if (Board[ro][co] == ' ') {/判断是否没下过，若这个点已经下过，则重新生成
			Board[ro][co] = 'O';/赋值
			break;跳出
		}
	}
}</code></pre> 
<p>有一点要注意的是，为了避免每一次下出现一样的随机数，我们在main函数的第一句，用<strong>时间戳来初始化</strong>我们的随机数生成，<strong>使每一次产生的随机数都不一样：</strong></p> 
<pre><code class="language-cpp">int main() {
	srand((unsigned int)time(NULL)); </code></pre> 
<h3 id="%EF%BC%885%EF%BC%89%E5%88%A4%E6%96%AD%E6%A3%8B%E7%9B%98%E6%98%AF%E5%90%A6%E4%B8%8B%E6%BB%A1%E7%9A%84%E5%87%BD%E6%95%B0"><strong>（5）判断棋盘是否下满的函数</strong></h3> 
<p>我们知道三子棋有三种结果：</p> 
<p><strong>1.玩家赢</strong></p> 
<p><strong>2.AI赢</strong></p> 
<p><strong>3.棋盘下满了，都没赢，也就是平局的结果</strong></p> 
<p>所以我们等会儿判断游戏输赢的函数中会调用这个函数来看是平局还是没下完，要接着对弈。</p> 
<pre><code class="language-cpp">判断棋盘是否下满的函数
int Is_full(char Board[ROW][COL], int row, int col) {
	int i = row;
	int j = col;
	int flag = 1;
	for (i = 0; i &lt; row; i++) {
		for (j = 0; j &lt; col; j++) {
			if (Board[i][j] == ' ')
				flag = 0;
		}
	}
	return flag;
}</code></pre> 
<p>我们把每个点都<span style="color:#956fe7"><strong>遍历</strong></span>一遍，如果有<strong>空格，表明没满，返回0，</strong></p> 
<p><strong>如果没有空格，表明棋盘满了，返回1.</strong></p> 
<h3 id="%EF%BC%886%EF%BC%89%E5%88%A4%E6%96%AD%E6%B8%B8%E6%88%8F%E8%BE%93%E8%B5%A2%E7%9A%84%E5%87%BD%E6%95%B0">（6）判断游戏输赢的函数</h3> 
<p>我们在对弈中，<strong>每落子一次，我们就判断一次输赢（调用一次这个函数）</strong>，只有在双方都没赢且棋盘没有满的情况下，才继续下棋。</p> 
<p>具体这样实现：</p> 
<p>1.判断 每行有没有<strong>出现三个连续相同的字符（</strong>空格除外），若有退出，<strong><span style="color:#956fe7">返回这个字符的值</span></strong>（我们暖心AI和玩家的字符时不一样的），若没有⬇</p> 
<p>2.判断 每列有没有<strong>出现三个连续相同的字符</strong>（空格除外），若有退出，<strong><span style="color:#956fe7">返回这个字符的值</span></strong>（我们暖心AI和玩家的字符时不一样的），若没有⬇</p> 
<p>3.判断 左对角线……</p> 
<p>4.判断 右对角线……</p> 
<p></p> 
<p>经过以上四步，表明没有三个连续相同的棋子，那么<strong>就剩两种情况</strong>了：</p> 
<p>i.棋盘没满，还未分出胜负，接着下棋</p> 
<p>ii.棋盘满了，平局，退出游戏</p> 
<p>这时我们就要用到上面的 判断棋盘是否已满的函数了⬇</p> 
<p></p> 
<p>5.判断棋盘是否下满，下满返回字符<strong><span style="color:#956fe7">P</span></strong>表示<strong>平局</strong>，未下满返回<strong><span style="color:#956fe7">C</span></strong>表示未分出胜负 <strong>接着下</strong>。</p> 
<p></p> 
<p><span style="color:#956fe7"><strong>需要注意的是这个函返回的字符表示调用时游戏的输赢状态</strong></span>，<strong><span style="color:#956fe7">调用它的函数会根据返回的值来进行操作</span></strong></p> 
<p>代码如下：</p> 
<p>我们定义一个flag变量来数相同字符的数量</p> 
<pre><code class="language-cpp">char Is_win(char Board[ROW][COL], int row, int col) {
	int i;
	int j;
	int flag;
	flag= 0;
	for (i = 0; i &lt; row; i++, flag = 0) {
		
		for (j = 1; j &lt; col; j++) {
			if (' ' == Board[i][j - 1] || ' ' == Board[i][j]) {
				continue;
			}
			if (Board[i][j] == Board[i][j-1]) {
				flag++;
				if (flag == 2)
					return Board[i][j];
			}
			
		}
		
	}

	for (j = flag = 0; j &lt; col; j++, flag = 0) {

		for (i = 1; i &lt; row; i++) {

			if (' ' == Board[i-1][j] || ' ' == Board[i][j]) {
				continue;
			}
			if (Board[i][j] == Board[i-1][j])
				flag++;
			if (2 == flag)
				return Board[i][j];
		}
		
	}
	
	for (i = 1,flag = 0; i &lt; row; i++) {
		
		if ((Board[i][i] == Board[i - 1][i - 1])&amp;&amp;Board[i][i]!=' ') {
			flag++;
		}
		if (2==flag) {
			return Board[i][i];
		}
	}

	for (i = 1, j = 1, flag = 0; i &lt; row&amp;&amp;j&gt;=0; i++,j--) {
		//0,2 //1,1 //2,0 
		if ((Board[i][j] == Board[i - 1][j + 1]) &amp;&amp; Board[i][j] != ' ') {
			flag++;
		}
		if (2 == flag) {
			return Board[i][j];
		}

	}
	
	if(Is_full(Board,row,col)){
		return 'P';
	}
	return 'C';
}
</code></pre> 
<p><span style="color:#956fe7"><strong>通过这样的流程，可以实现每一方落完子都能获取到当前游戏的输赢状态。</strong></span></p> 
<p><span style="color:#0d0016"><strong>这时我们再回到游戏主体函数，进入对弈之后的代码</strong></span></p> 
<pre><code class="language-cpp">  进入游戏 你一步 我一步 直到游戏结束
	while(1) {
        /玩家走- 实现赋值的函数
		Player_Move(Board, ROW, COL);
        /走完打印棋盘
        DisplayBoard(Board, ROW, COL);
        /判断游戏状态
		 A = Is_win(Board, ROW, COL);/判断游戏状态的函数
		if (A != 'C')/如果棋盘未满 还没有分出胜负就会返回字符c
			break;/如果不是c就结束游戏
        /AI走
		Computer_Move(Board, ROW, COL);
		/AI思考很快 为了不让玩家自卑故意等一下再走棋
        Sleep(1000);
        /走完打印棋盘
		DisplayBoard(Board, ROW, COL);
        /判断游戏状态
		A = Is_win(Board, ROW, COL);
		if (A != 'C')
			break;
	}

    当游戏结束 查看是平局了还是一方赢了
    /判断游戏状态的函数会根据游戏的状态返回不同的值
	switch (A) {/打印出对应的结果后，返回到主界面 询问是否还是孤独 
	case 'P':
		Sleep(1000);
		printf("平局了,再来一把吧!n");
		break;
	case'X':
		Sleep(1000); 
		printf("你赢了，好厉害!n");
		break;
	case'O':
		Sleep(1000); 
		printf("电脑赢了，笨蛋!n");
		break;
	}
}</code></pre> 
<p><strong>不难发现，这样一来</strong></p> 
<p><strong>只有判断输赢的函数返回<span style="color:#956fe7">C</span>才继续下，不然就跳出，跳出后再进入一个<span style="color:#956fe7">switch</span>语句来看具体是那种结局</strong></p> 
<p></p> 
<h1 id="main-toc">结尾</h1> 
<p>相信通过通过以上的分析，这个暖心AI陪下三子棋的流程就能很清晰的掌握了，希望这篇博客能对大家的代码能力和心理健康起到积极的影响。<span style="color:#956fe7"><strong>希望在你一个人如孤狼般奋进，默默成为大牛的路上，有一这位人工智能陪你下三子棋，抚慰你寂寞的心。</strong></span></p> 
<p id="%E5%BD%93%E7%8E%A9%E5%AE%B6%E9%80%89%E6%8B%A9%200%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%BB%96%E5%B9%B6%E4%B8%8D%E5%AD%A4%E7%8B%AC%EF%BC%9A-toc" style="margin-left:40px"></p> 
<p id="%E5%BD%93%E7%8E%A9%E5%AE%B6%E9%80%89%E6%8B%A9%202%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%BB%96%E4%B8%8D%E7%90%86%E8%A7%A3%EF%BC%9A-toc" style="margin-left:40px"></p> 
<p id="AI%E8%AF%A2%E9%97%AE%E7%8E%A9%E5%AE%B6%C2%A0%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E8%A7%84%E5%88%99-toc" style="margin-left:40px"></p> 
<p id="%C2%A0%E5%BD%93%E7%8E%A9%E5%AE%B6%E9%80%89%E6%8B%A9%201%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%BB%96%E5%BE%88%E5%AD%A4%E7%8B%AC%EF%BC%9A-toc" style="margin-left:80px"></p> 
<p id="%E5%BD%93%E7%8E%A9%E5%AE%B6%E9%80%89%E6%8B%A9%201%EF%BC%8C%E4%BB%96%E4%B8%8D%E7%9F%A5%E9%81%93%E8%A7%84%E5%88%99%EF%BC%9A-toc" style="margin-left:80px"></p> 
<p id="%E5%BC%80%E5%A7%8B%E4%B8%8B%E6%A3%8B%EF%BC%8C%E5%9F%BA%E6%83%85%E5%AF%B9%E5%BC%88-toc" style="margin-left:0px"></p> 
<p id="1.%E6%B8%B8%E6%88%8F%E4%B8%BB%E4%BD%93-toc" style="margin-left:40px"></p> 
<p id="2.%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85-toc" style="margin-left:40px"></p> 
<p id="%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%3A-toc" style="margin-left:80px"></p> 
<p id="%E6%BA%90%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px"></p> 
<p id="%EF%BC%881%EF%BC%89%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%8B%E7%9B%98%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"></p> 
<p id="%EF%BC%882%EF%BC%89%20%E6%89%93%E5%8D%B0%E6%A3%8B%E7%9B%98%E7%9A%84%E5%87%BD%E6%95%B0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0-toc" style="margin-left:80px"></p> 
<p id="%C2%A0%EF%BC%883%EF%BC%89%E7%8E%A9%E5%AE%B6%E4%B8%8B%E6%A3%8B%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"></p> 
<p id="%EF%BC%885%EF%BC%89%E5%88%A4%E6%96%AD%E6%A3%8B%E7%9B%98%E6%98%AF%E5%90%A6%E4%B8%8B%E6%BB%A1%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"></p> 
<p id="%EF%BC%886%EF%BC%89%E5%88%A4%E6%96%AD%E6%B8%B8%E6%88%8F%E8%BE%93%E8%B5%A2%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>