<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【iOS】RunLoop - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【iOS】RunLoop</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="RunLoop_0"></a>前言-什么是RunLoop？</h1> 
<p>什么是<code>RunLoop</code>? 跑圈？字面上理解确实是这样的。</p> 
<p>Apple官方文档这样解释<code>RunLoop</code></p> 
<blockquote> 
 <p>RunLoop是与线程息息相关的基本结构的一部分。RunLoop是一个调度任务和处理任务的事件循环。RunLoop的目的是为了在有工作的时候让线程忙起来，而在没有工作的时候让线程进入休眠状态。</p> 
</blockquote> 
<p>之所以iOS的app能够持续的响应从而让程序保持运行状态，在于其存在一个事件循环（<code>Event Loop</code>）机制： 线程能够随时响应并处理事件的机制，这种机制要求线程不能退出从而高效的完成事件调度和处理。</p> 
<p>在iOS这种事件循环机制就叫做<code>RunLoop</code></p> 
<p><code>RunLoop</code>实际上是一个对象，对象在循环中处理程序运行过程出现的各种事件（比如触摸事件，UI刷新事件，定时器事件，<code>Selector</code>事件）从而保持程序的持续运行并且让程序在没有事件处理的时候进入休眠状态，从而节省CPU资源达到提升程序性能的目的。</p> 
<h2>
<a id="RunLoop_14"></a>默认情况下主线程的RunLoop原理</h2> 
<pre><code class="prism language-objectivec"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>UIKit<span class="token operator">/</span>UIKit<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">"AppDelegate.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    NSString <span class="token operator">*</span> appDelegateClassName<span class="token punctuation">;</span>
    <span class="token operator">@</span>autoreleasepool <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Setup code that might create autoreleased objects goes here.</span>
        appDelegateClassName <span class="token operator">=</span> <span class="token function">NSStringFromClass</span><span class="token punctuation">(</span><span class="token punctuation">[</span>AppDelegate class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">UIApplicationMain</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> nil<span class="token punctuation">,</span> appDelegateClassName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><code>return UIApplicationMain(argc, argv, nil, appDelegateClassName);</code>这是 iOS 应用程序的主运行循环，它负责处理用户事件、界面更新和应用程序的主要逻辑。<code>UIApplicationMain</code> 函数创建应用程序对象和主运行循环，并传递控制权给应用程序的委托类（<code>AppDelegate</code>）来处理应用程序的逻辑。</p> 
<p>其中的<code>UIApplicationMain</code>函数内部帮我们开启了主线程的<code>RunLoop</code>。<br> <code>UIApplicationMain</code>内部拥有一个无限循环的代码。</p> 
<pre><code class="prism language-c">function <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
        var message <span class="token operator">=</span> <span class="token function">get_next_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">process_message</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>message <span class="token operator">!=</span> quit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>程序会一直在<code>do-while</code>循环中执行。</p> 
<p>Apple官方的<code>RunLoop</code>模型图</p> 
<p><img src="https://images2.imgbox.com/cb/62/eCxpELCC_o.png" alt="在这里插入图片描述"></p> 
<p><code>RunLoop</code>就是线程中的一个循环，<code>RunLoop</code>在循环中不断检测，通过<code>Input sources</code>（输入源）和<code>Timer sources</code>（定时源）两种来源等待接受消息，然后对接收到的事件通知线程进行处理，并在没有事件的时候进行休息。</p> 
<h1>
<a id="1_RunLoop_53"></a>1. RunLoop对象</h1> 
<p><code>RunLoop</code>对象是基于<code>CFFoundation框</code>架的<code>CFRunLoopRef</code>类型封装的对象。</p> 
<ul><li>
<code>NSRunLoop</code>是基于<code>CFRunLoopRef</code>的封装，提供了面向对象的API，但是这些API不是线程安全的。</li></ul> 
<pre><code class="prism language-objectivec"><span class="token punctuation">[</span>NSRunLoop currentRunLoop<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//获得当前RunLoop对象</span>
<span class="token punctuation">[</span>NSRunLoop mainRunLoop<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//获得主线程的RunLoop对象</span>
</code></pre> 
<p><code>CoreFoundation</code>框架的 <code>CFRunLoopRef</code>对象</p> 
<ul><li>
<code>CFRunLoopRef</code>是在<code>CoreFoundation</code>框架内的，其提供了纯C语言函数的API，所有这些API都是线程安全的。</li></ul> 
<pre><code class="prism language-c"><span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得当前线程的RunLoop对象</span>
<span class="token function">CFRunLoopGetMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得主线程的RunLoop对象</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/fe/0d/SbLlHRno_o.png" alt="在这里插入图片描述"></p> 
<p>那么对应的两种方式就是:</p> 
<pre><code class="prism language-objectivec"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>getRunLoop <span class="token punctuation">{<!-- --></span>
    NSRunLoop <span class="token operator">*</span>runloop  <span class="token operator">=</span> <span class="token punctuation">[</span> NSRunLoop currentRunLoop<span class="token punctuation">]</span><span class="token punctuation">;</span>
    NSRunLoop <span class="token operator">*</span>manRlp <span class="token operator">=</span> <span class="token punctuation">[</span>NSRunLoop mainRunLoop<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    CFRunLoopRef cfRlp <span class="token operator">=</span> <span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CFRunLoopRef mainCfRlp <span class="token operator">=</span> <span class="token function">CFRunLoopGetMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>看下<code>CFRunLoopGetCurrent</code> 和 <code>CFRunLoopGetMain</code>的具体实现:</p> 
<pre><code class="prism language-c">CFRunLoopRef <span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CFRunLoopRef rl <span class="token operator">=</span> <span class="token punctuation">(</span>CFRunLoopRef<span class="token punctuation">)</span><span class="token function">_CFGetTSD</span><span class="token punctuation">(</span>__CFTSDKeyRunLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rl<span class="token punctuation">)</span> <span class="token keyword">return</span> rl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">_CFRunLoopGet0</span><span class="token punctuation">(</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

CFRunLoopRef <span class="token function">CFRunLoopGetMain</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> CFRunLoopRef __main <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// no retain needed</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>__main<span class="token punctuation">)</span> __main <span class="token operator">=</span> <span class="token function">_CFRunLoopGet0</span><span class="token punctuation">(</span><span class="token function">pthread_main_thread_np</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no CAS needed</span>
    <span class="token keyword">return</span> __main<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>发现在过程都调用了<code>_CFRunLoopGet0</code>这个函数，后面再进行讲解。</p> 
<h1>
<a id="CFRunLoopRef_103"></a>CFRunLoopRef源码部分（引入线程相关）</h1> 
<p>CFRunLoopRef的源码部分</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">__CFRunLoop</span> <span class="token punctuation">{<!-- --></span>
    CFRuntimeBase _base<span class="token punctuation">;</span>
    <span class="token class-name">pthread_mutex_t</span> _lock<span class="token punctuation">;</span>            <span class="token comment">/* locked for accessing mode list */</span>
    __CFPort _wakeUpPort<span class="token punctuation">;</span> <span class="token comment">//【通过该函数CFRunLoopWakeUp内核向该端口发送消息可以唤醒runloop】</span>
    Boolean _unused<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> _per_run_data <span class="token operator">*</span>_perRunData<span class="token punctuation">;</span>              <span class="token comment">// reset for runs of the run loop</span>
    <span class="token class-name">pthread_t</span> _pthread<span class="token punctuation">;</span> <span class="token comment">//【RunLoop对应的线程】</span>
    <span class="token class-name">uint32_t</span> _winthread<span class="token punctuation">;</span>
    CFMutableSetRef _commonModes<span class="token punctuation">;</span> <span class="token comment">// 【存储的是字符串，记录所有标记为common的mode】</span>
    CFMutableSetRef _commonModeItems<span class="token punctuation">;</span><span class="token comment">//【存储所有commonMode的item(source、timer、observer)】</span>
    CFRunLoopModeRef _currentMode<span class="token punctuation">;</span><span class="token comment">//【当前运行的mode】</span>
    CFMutableSetRef _modes<span class="token punctuation">;</span><span class="token comment">//【存储的是CFRunLoopModeRef】</span>
    <span class="token keyword">struct</span> <span class="token class-name">_block_item</span> <span class="token operator">*</span>_blocks_head<span class="token punctuation">;</span><span class="token comment">//【do blocks时用到】</span>
    <span class="token keyword">struct</span> <span class="token class-name">_block_item</span> <span class="token operator">*</span>_blocks_tail<span class="token punctuation">;</span>
    CFTypeRef _counterpart<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>对于一些属性之外，重点需要关注三个成员变量</p> 
<pre><code class="prism language-c"><span class="token class-name">pthread_t</span> _pthread<span class="token punctuation">;</span>【RunLoop对应的线程】
CFRunLoopModeRef _currentMode<span class="token punctuation">;</span>【当前运行的mode】
CFMutableSetRef _modes<span class="token punctuation">;</span>【存储的是CFRunLoopModeRef】
</code></pre> 
<p>看看RunLoop和线程的关系。</p> 
<h1>
<a id="2_RunLoop_130"></a>2. RunLoop和线程</h1> 
<p>先看一下<code>_CFRunLoopGet0</code>这个函数是怎么实现的，和<code>RunLoop</code>和线程有什么关系。</p> 
<pre><code class="prism language-c"><span class="token comment">//全局的Dictionary，key是pthread_t,value是CFRunLoopRef</span>
<span class="token keyword">static</span> CFMutableDictionaryRef __CFRunLoops <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token comment">//访问__CFRunLoops的锁</span>
<span class="token keyword">static</span> CFSpinLock_t loopsLock <span class="token operator">=</span> CFSpinLockInit<span class="token punctuation">;</span>

<span class="token comment">// should only be called by Foundation</span>
<span class="token comment">// t==0 is a synonym for "main thread" that always works</span>
<span class="token comment">//t==0是始终有效的“主线程”的同义词</span>

<span class="token comment">//获取pthread对应的RunLoop</span>
CF_EXPORT CFRunLoopRef <span class="token function">_CFRunLoopGet0</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_equal</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> kNilPthreadT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//pthread为空时，获取主线程</span>
    t <span class="token operator">=</span> <span class="token function">pthread_main_thread_np</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">__CFSpinLock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>__CFRunLoops<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">__CFSpinUnlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//第一次进入时，创建一个临时字典dict</span>
    CFMutableDictionaryRef dict <span class="token operator">=</span> <span class="token function">CFDictionaryCreateMutable</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kCFTypeDictionaryValueCallBacks<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//根据传入的主线程获取主线程对应的RunLoop</span>
    CFRunLoopRef mainLoop <span class="token operator">=</span> <span class="token function">__CFRunLoopCreate</span><span class="token punctuation">(</span><span class="token function">pthread_main_thread_np</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//保存主线程，将主线程-key和RunLoop-Value保存到字典中</span>
    <span class="token function">CFDictionarySetValue</span><span class="token punctuation">(</span>dict<span class="token punctuation">,</span> <span class="token function">pthreadPointer</span><span class="token punctuation">(</span><span class="token function">pthread_main_thread_np</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mainLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//此处NULL和__CFRunLoops指针都指向NULL，匹配，所以将dict写到__CFRunLoops</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">OSAtomicCompareAndSwapPtrBarrier</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> dict<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">volatile</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>__CFRunLoops<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//释放dict</span>
        <span class="token function">CFRelease</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//释放mainRunLoop</span>
    <span class="token function">CFRelease</span><span class="token punctuation">(</span>mainLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__CFSpinLock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//以上说明，第一次进来的时候，不管是getMainRunLoop还是get子线程的runLoop，主线程的runLoop总是会被创建</span>

	<span class="token comment">//从全局字典里获取对应的RunLoop</span>
    CFRunLoopRef loop <span class="token operator">=</span> <span class="token punctuation">(</span>CFRunLoopRef<span class="token punctuation">)</span><span class="token function">CFDictionaryGetValue</span><span class="token punctuation">(</span>__CFRunLoops<span class="token punctuation">,</span> <span class="token function">pthreadPointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__CFSpinUnlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loop<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//如果取不到，就创建一个新的RunLoop</span>
    CFRunLoopRef newLoop <span class="token operator">=</span> <span class="token function">__CFRunLoopCreate</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__CFSpinLock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    loop <span class="token operator">=</span> <span class="token punctuation">(</span>CFRunLoopRef<span class="token punctuation">)</span><span class="token function">CFDictionaryGetValue</span><span class="token punctuation">(</span>__CFRunLoops<span class="token punctuation">,</span> <span class="token function">pthreadPointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//创建好之后，以线程为key，runLoop为value，一对一存储在字典中，下次获取的时候，则直接返回字典内的runLoop</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loop<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//把newLoop存入字典__CFRunLoops，key是线程t</span>
        <span class="token function">CFDictionarySetValue</span><span class="token punctuation">(</span>__CFRunLoops<span class="token punctuation">,</span> <span class="token function">pthreadPointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> newLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
        loop <span class="token operator">=</span> newLoop<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
        <span class="token comment">// don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span>
        <span class="token function">__CFSpinUnlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CFRelease</span><span class="token punctuation">(</span>newLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">//如果传入线程就是当前线程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_equal</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">_CFSetTSD</span><span class="token punctuation">(</span>__CFTSDKeyRunLoop<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>loop<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token function">_CFGetTSD</span><span class="token punctuation">(</span>__CFTSDKeyRunLoopCntr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//注册一个回调，当线程销毁时，销毁对应的RunLoop</span>
            <span class="token function">_CFSetTSD</span><span class="token punctuation">(</span>__CFTSDKeyRunLoopCntr<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>PTHREAD_DESTRUCTOR_ITERATIONS<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>__CFFinalizeRunLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> loop<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这段源码告诉我们：</p> 
<ul>
<li>每条线程都有唯一的与之对应的<code>RunLoop</code>对象。</li>
<li>
<code>RunLoop</code>保存在一个全局的<code>Dictionary</code>里面，线程作为<code>key</code>，<code>RunLoop</code>作为<code>Value</code>
</li>
<li>线程刚创建的并没有<code>RunLoop</code>对象。<code>RunLoop</code>会在第一次获取线程的<code>RunLoop</code>创建，在线程结束的时候销毁。</li>
<li>主线程的<code>RunLoop</code>已经自动获取（创建），子线程默认没有开启<code>RunLoop</code>.</li>
</ul> 
<h1>
<a id="3_RunLoop_206"></a>3. RunLoop相关的类</h1> 
<p>与<code>RunLoop</code>相关的类有5个。</p> 
<ul>
<li>
<code>CFRunLoopRef</code>: 代表了<code>RunLoop</code>对象</li>
<li>
<code>CFRunLoopModeRef</code>: 代表了<code>RunLoop</code>的运行模式</li>
<li>
<code>CFRunLoopSourceRef</code>： <code>RunLoop</code>模型中提到的输入源。</li>
<li>
<code>CFRunLoopTimerRef</code>: 定时源</li>
</ul> 
<p><img src="https://images2.imgbox.com/29/1e/OvDcIxGe_o.png" alt="在这里插入图片描述"></p> 
<ul>
<li>每次调用<code>RunLoop</code>的主函数的时候， 只允许指定其中的一个运行模式（<code>CFRunLoopModeRef</code>），就是被称作<code>CurrentMode</code>;</li>
<li>如果需要切换<code>Mode</code>，只能通过退出<code>Loop</code>，然后需要重新指定一个<code>Mode</code>进入，这样做主要是为了分隔开不同组的输入源（<code>CFRunLoopSourceRef</code>）、定时源（<code>CFRunLoopTimerRef</code>）、观察者（<code>CFRunLoopObserverRef</code>），让其互不影响</li>
<li>如果一个<code>mode</code>中一个<code>Sourcr/Timer/Observer</code>都没有，则<code>RunLoop</code>会直接退出，不进入循环。</li>
</ul> 
<p><code>RunLoop</code>的结构和套娃一样，<code>RunLoop</code>里面装着<code>Mode</code>，<code>Mode</code>里面装着<code>Souce / Observer / Timer</code></p> 
<h2>
<a id="RunLoop_224"></a>RunLoop相关类的实现</h2> 
<p>一个<code>RunLoop</code>包含若干个<code>Mode</code>,每个<code>Mode</code>又包含若干个<code>Source/Timer/Observer</code>。<br> 这句话其实就是5个相关类的关系</p> 
<h2>
<a id="CFRunLoopModeRef_229"></a>CFRunLoopModeRef</h2> 
<p>代表了<code>RunLoop</code>的运行模式，但这里请理清概念，我们的<code>RunLoop</code>里可以装多个<code>Mode</code>，只是我们在指定运行的时候要指定一个<code>Mode</code>。</p> 
<pre><code class="prism language-objectivec"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> __CFRunLoopMode <span class="token operator">*</span>CFRunLoopModeRef<span class="token punctuation">;</span>

<span class="token keyword">struct</span> __CFRunLoopMode <span class="token punctuation">{<!-- --></span>
    CFRuntimeBase _base<span class="token punctuation">;</span>
    pthread_mutex_t _lock<span class="token punctuation">;</span>    <span class="token comment">/* must have the run loop locked before locking this */</span>
    CFStringRef _name<span class="token punctuation">;</span> <span class="token comment">//mode名称，运行模式是通过名称来识别的</span>
    Boolean _stopped<span class="token punctuation">;</span> <span class="token comment">//mode是否被终止</span>
    <span class="token keyword">char</span> _padding<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//整个结构体最核心的部分</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
    CFMutableSetRef _sources0<span class="token punctuation">;</span><span class="token comment">//Sources0</span>
    CFMutableSetRef _sources1<span class="token punctuation">;</span><span class="token comment">//Sources1</span>
    CFMutableArrayRef _observers<span class="token punctuation">;</span><span class="token comment">//观察者</span>
    CFMutableArrayRef _timers<span class="token punctuation">;</span><span class="token comment">//定时器</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
    CFMutableDictionaryRef _portToV1SourceMap<span class="token punctuation">;</span><span class="token comment">//字典    key是mach_port_t，value是CFRunLoopSourceRef</span>
    __CFPortSet _portSet<span class="token punctuation">;</span><span class="token comment">//保存所有需要监听的port，比如_wakeUpPort，_timerPort都保存在这个数组中</span>
    CFIndex _observerMask<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>一个<code>CFRunLoopModeRef</code>对象有<code>name</code>属性，若干<code>source0</code>， <code>source1</code>， <code>timer</code>， <code>observer</code>和<code>port</code>，可以看出来事件都是由<code>mode</code>在管理，而<code>RunLoop</code>负责管理<code>Mode</code>，</li></ul> 
<h3>
<a id="_256"></a>五种运行模式</h3> 
<p>系统默认注册的五个<code>Mode</code>:</p> 
<ul>
<li>
<code>kCFRunLoopDefaultMode</code>：App的默认<code>Mode</code>，通常主线程是在这个<code>Mode</code>下运行。</li>
<li>
<code>UITrackingRunLoopMode</code>：界面跟踪<code>Mode</code>，用于<code>ScrollView</code>追踪触摸滑动，保证界面滑动时不受其他 <code>Mode</code> 影响（与用户交互事件的<code>Mode</code>）。</li>
<li>
<code>UIInitializationRunLoopMode</code>: 在刚启动 App 时第进入的第一个 <code>Mode</code>，启动完成后就不再使用，会切换到<code>kCFRunLoopDefaultMode</code>。</li>
<li>
<code>GSEventReceiveRunLoopMode</code>: 接受系统事件的内部 <code>Mode</code>，通常用不到。</li>
<li>
<code>kCFRunLoopCommonModes</code>: 这是一个占位用的<code>Mode</code>，作为标记<code>kCFRunLoopDefaultMode</code>和<code>UITrackingRunLoopMode</code>用，并不是一种真正的<code>Mode</code> （伪模式，并不是一种真正的模式）。</li>
</ul> 
<p>其中<code>kCFRunLoopDefaultMode</code>、<code>UITrackingRunLoopMode</code>、<code>kCFRunLoopCommonModes</code>是我们开发中需要用到的模式。</p> 
<h3>
<a id="CommonModes_267"></a>CommonModes</h3> 
<p>在<code>RunLoop</code>对象中，前面有一个<code>CommonModes</code>成员变量。</p> 
<pre><code class="prism language-objectivec"><span class="token comment">//简化版本</span>
<span class="token keyword">struct</span> __CFRunLoop <span class="token punctuation">{<!-- --></span>
    pthread_t _pthread<span class="token punctuation">;</span>
    CFMutableSetRef _commonModes<span class="token punctuation">;</span><span class="token comment">//存储的是字符串，记录所有标记为common的mode</span>
    CFMutableSetRef _commonModeItems<span class="token punctuation">;</span><span class="token comment">//存储所有commonMode的item(source、timer、observer)</span>
    CFRunLoopModeRef _currentMode<span class="token punctuation">;</span><span class="token comment">//当前运行的mode</span>
    CFMutableSetRef _modes<span class="token punctuation">;</span><span class="token comment">//存储的是CFRunLoopModeRef对象，不同mode类型，它的mode名字不同</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul>
<li>一个<code>Mode</code>可以将自己标记为<code>Common</code>属性，通过将其<code>ModeName</code>添加到<code>RunLoop</code>的<code>commonModes</code>中。</li>
<li>每当<code>RunLoop</code>的内容发生变化时，<code>RunLoop</code>都会将<code>_commonModeItems</code>里的<code>Source/Observer/Timer</code>同步到具有<code>Common</code>标记的所有<code>Mode</code>里。</li>
</ul> 
<p>其底层原理</p> 
<pre><code class="prism language-objectivec"><span class="token keyword">void</span> <span class="token function">CFRunLoopAddCommonMode</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopIsDeallocating</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>rl<span class="token operator">-&gt;</span>_commonModes<span class="token punctuation">,</span> modeName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//获取所有的_commonModeItems</span>
    CFSetRef set <span class="token operator">=</span> rl<span class="token operator">-&gt;</span>_commonModeItems <span class="token operator">?</span> <span class="token function">CFSetCreateCopy</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> rl<span class="token operator">-&gt;</span>_commonModeItems<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">//获取所有的_commonModes</span>
    <span class="token function">CFSetAddValue</span><span class="token punctuation">(</span>rl<span class="token operator">-&gt;</span>_commonModes<span class="token punctuation">,</span> modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> set<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        CFTypeRef context<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>rl<span class="token punctuation">,</span> modeName<span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">//将所有的_commonModeItems逐一添加到_commonModes里的每一个Mode</span>
        <span class="token function">CFSetApplyFunction</span><span class="token punctuation">(</span>set<span class="token punctuation">,</span> <span class="token punctuation">(</span>__CFRunLoopAddItemsToCommonMode<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">CFRelease</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>总体来说，这个方法的主要作用是将一个指定的 <code>commonModeItems</code> 集合添加到运行循环的共同模式集合中，并将 <code>commonModeItems</code> 添加到共同模式集合中的每个 <code>Mode</code> 中，以确保共同模式的事件源在多个 <code>Mode</code> 下都能得到处理。它涉及到 <code>CoreFoundation</code> 框架中运行循环的底层操作，用于管理运行循环中的事件和模式。</p> 
<h2>
<a id="CFRunLoopSourceRef_307"></a>CFRunLoopSourceRef</h2> 
<p><code>CFRunLoopSourceRef</code>： <code>RunLoop</code>模型中提到的输入源,也就是事件产生的地方。</p> 
<pre><code class="prism language-objectivec"><span class="token keyword">struct</span> __CFRunLoopSource <span class="token punctuation">{<!-- --></span>
    CFRuntimeBase _base<span class="token punctuation">;</span>
    uint32_t _bits<span class="token punctuation">;</span>
    pthread_mutex_t _lock<span class="token punctuation">;</span>
    CFIndex _order<span class="token punctuation">;</span>   <span class="token comment">//执行顺序</span>
    CFMutableBagRef _runLoops<span class="token punctuation">;</span><span class="token comment">//包含多个RunLoop</span>
    <span class="token comment">//版本</span>
    <span class="token keyword">union</span> <span class="token punctuation">{<!-- --></span>
    CFRunLoopSourceContext version0<span class="token punctuation">;</span>    <span class="token comment">/* immutable, except invalidation */</span>
        CFRunLoopSourceContext1 version1<span class="token punctuation">;</span>    <span class="token comment">/* immutable, except invalidation */</span>
    <span class="token punctuation">}</span> _context<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>刚才上面提到<code>souce</code>存在 <code>source0</code> 和 <code>source1</code>两个版本，他们分别做了什么？</p> 
<ul>
<li>
<code>Source0</code>只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用<code>CFRunLoopSourceSignal(source)</code>, 将这个<code>Source</code>标记为待处理，然后手动调用<code>CFRunLoopWakeUp(runloop)</code>来唤醒<code>RunLoop</code>,让其处理这个事件</li>
<li>
<code>Source1</code>包含了一个<code>mach_port</code>和一个回调（函数指针），可以用于内核和其他线程相互发送消息，这种<code>Source</code>能主动唤醒<code>RunLoop</code>线程。</li>
<li>⚠️：对于<code>button</code>的点击事件属于<code>Source0</code>函数的执行内容。点击事件就是<code>Source0</code>进行处理的。<br> <code>Source1</code>则是用来接受和分发事件，分发到<code>Souce0</code>进行处理。</li>
</ul> 
<h2>
<a id="CFRunLoopTimerRef_333"></a>CFRunLoopTimerRef</h2> 
<p><code>CFRunLoopTimerRef</code>: 定时源- 基于时间的触发器。</p> 
<p><code>CFRunLoopTimerRef</code>是基于时间的触发器，它和<code>NSTimer</code>可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到<code>RunLoop</code>时，<code>RunLoop</code>会注册对应的时间点，当时间点到时，<code>RunLoop</code>会被唤醒以执行那个回调。</p> 
<p>当我们调用<code>NSTimer</code>的<code>scheduledTimerWithTimeInterval</code>的时候</p> 
<pre><code class="prism language-objectivec"><span class="token punctuation">[</span>NSTimer scheduledTimerWithTimeInterval<span class="token punctuation">:</span><span class="token number">2.0</span> target<span class="token punctuation">:</span><span class="token keyword">self</span> selector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span> userInfo<span class="token punctuation">:</span>nil repeats<span class="token punctuation">:</span>YES<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>系统会自动加入NSDefaltRunLoopMode.</p> 
<p>等于如下代码</p> 
<pre><code class="prism language-objectivec">NSTimer <span class="token operator">*</span>timer <span class="token operator">=</span> <span class="token punctuation">[</span>NSTimer timerWithTimeInterval<span class="token punctuation">:</span><span class="token number">2.0</span> target<span class="token punctuation">:</span><span class="token keyword">self</span> selector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span> userInfo<span class="token punctuation">:</span>nil repeats<span class="token punctuation">:</span>YES<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span>NSRunLoop currentRunLoop<span class="token punctuation">]</span> addTimer<span class="token punctuation">:</span>timer forMode<span class="token punctuation">:</span>NSDefaultRunLoopMode<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="_353"></a>定时器滑动不准确</h3> 
<p>在知乎日报的时候，滑动<code>tableView</code>造成了上面自动轮播图的定时器失效问题。<br> 常见的问题就是：当我们使用<code>NSTimer</code>每一段时间执行一些事情时滑动<code>UIScrollView</code>，<code>NSTimer</code>就会暂停，当我们停止滑动以后，<code>NSTimer</code>又会重新恢复的情况。</p> 
<p>原因就是：</p> 
<p>当我们不做任何操作的时候，<code>RunLoop</code>处于<code>NSDefaultRunLoopMode</code>下。<br> 当我们进行拖拽时，<code>RunLoop</code>就结束<code>NSDefaultRunLoopMode</code>，切换到了<code>UITrackingRunLoopMode</code>模式下，这个模式下没有添加<code>NSTimer</code>，所以我们的<code>NSTimer</code>就不工作了。<br> 当我们松开鼠标时候，<code>RunLoop</code>就结束<code>UITrackingRunLoopMode</code>模式，又切换回<code>NSDefaultRunLoopMode</code>模式，所以<code>NSTimer</code>就又开始正常工作了。</p> 
<p>解决：</p> 
<pre><code class="prism language-objectivec"><span class="token punctuation">[</span><span class="token punctuation">[</span>NSRunLoop currentRunLoop<span class="token punctuation">]</span> addTimer<span class="token punctuation">:</span>timer forMode<span class="token punctuation">:</span>NSRunLoopCommonModes<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>在 iOS 中，当你滑动 <code>UITableView</code> 或其他滚动视图时，主线程上的 <code>RunLoop</code> 切换到 <code>UITrackingRunLoopMode</code>，这是一个特殊的运行循环模式，用于处理用户交互事件，例如滚动手势。在默认情况下，如果你在主线程上使用定时器，它会在默认的运行循环模式 <code>NSDefaultRunLoopMode</code> 下运行。由于 <code>RunLoop</code> 一次只能处理一个运行循环模式，当你滑动时，<code>NSDefaultRunLoopMode</code> 被切换到 <code>UITrackingRunLoopMode</code>，导致定时器事件暂停，直到滑动结束。</p> 
<p>为了解决这个问题，可以使用 <code>kCFRunLoopCommonModes</code>。代表了一个 “<code>common mode set</code>”，它同时包括了 <code>NSDefaultRunLoopMode</code> 和 <code>UITrackingRunLoopMode</code>。通过在定时器的添加中使用 <code>kCFRunLoopCommonModes</code>，可以使定时器在默认模式和追踪模式下都得到触发，从而避免滑动导致定时器暂停的问题。</p> 
<h2>
<a id="CFRunLoopObserverRef_373"></a>CFRunLoopObserverRef</h2> 
<p><code>CFRunLoopObserverRef</code>是观察者，每个<code>Observer</code>都包含了一个回调（函数指针），当<code>RunLoop</code>的状态发生变化时，观察者就能通过回调接收到这个变化。</p> 
<pre><code class="prism language-objectivec"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> __CFRunLoopObserver <span class="token operator">*</span> CFRunLoopObserverRef<span class="token punctuation">;</span>
<span class="token keyword">struct</span> __CFRunLoopObserver <span class="token punctuation">{<!-- --></span>
    CFRuntimeBase _base<span class="token punctuation">;</span>
    pthread_mutex_t _lock<span class="token punctuation">;</span>
    CFRunLoopRef _runLoop<span class="token punctuation">;</span><span class="token comment">//监听的RunLoop</span>
    CFIndex _rlCount<span class="token punctuation">;</span><span class="token comment">//添加该Observer的RunLoop对象个数</span>
    CFOptionFlags _activities<span class="token punctuation">;</span>		<span class="token comment">/* immutable */</span>
    CFIndex _order<span class="token punctuation">;</span><span class="token comment">//同时间最多只能监听一个</span>
    CFRunLoopObserverCallBack _callout<span class="token punctuation">;</span><span class="token comment">//监听的回调</span>
    CFRunLoopObserverContext _context<span class="token punctuation">;</span><span class="token comment">//上下文用于内存管理</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//观测的时间点有一下几个</span>
<span class="token keyword">typedef</span> <span class="token function">CF_OPTIONS</span><span class="token punctuation">(</span>CFOptionFlags<span class="token punctuation">,</span> CFRunLoopActivity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    kCFRunLoopEntry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">//   即将进入RunLoop</span>
    kCFRunLoopBeforeTimers <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 即将处理Timer</span>
    kCFRunLoopBeforeSources <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 即将处理Source</span>
    kCFRunLoopBeforeWaiting <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">//即将进入休眠</span>
    kCFRunLoopAfterWaiting <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 刚从休眠中唤醒</span>
    kCFRunLoopExit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 即将退出RunLoop</span>
    kCFRunLoopAllActivities <span class="token operator">=</span> <span class="token number">0x0FFFFFFFU</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="Mode_Item_402"></a>什么是Mode Item？</h3> 
<p><code>Mode</code>到底包含哪些类型的元素？<br> 前面提到过 <code>CFMutableSetRef _commonModeItems</code>：存储所有<code>commonMode</code>的<code>item</code> (<code>source</code>、<code>timer</code>、<code>observer</code>)</p> 
<p>上面的 <code>Source</code>/<code>Timer</code>/<code>Observer</code> 被统称为 <code>mode item</code></p> 
<p>所有的<code>mode item</code>都可以被添加到<code>Mode</code>中，<code>Mode</code>中可以包含多个<code>mode item</code>，一个<code>item</code>也可以被加入多个<code>mode</code>。但一个<code>item</code>被重复加入同一个<code>mode</code>时是不会有效果的。如果一个<code>mode</code>中一个<code>item</code>都没有，则<code>RunLoop</code>会退出，不进入循环。</p> 
<p><img src="https://images2.imgbox.com/d1/69/1lI2q1PI_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="RunLoop_414"></a>RunLoop休眠的实现原理</h2> 
<p><strong>从用户态切换到内核态， 在内核态让线程进行休眠，有消息的时候唤起线程，回到用户态处理消息。</strong></p> 
<h2>
<a id="RunLoop_418"></a>RunLoop小结</h2> 
<p><strong>RunLoop内部实际是一个do while循环，当调用CFRunLoopRun()的时候，线程就会一直停留在这个循环里面，当超时或者被手动调用的时候该函数才会返回。</strong></p> 
<ul>
<li>
<code>RunLoop</code>的运行必定要指定一种<code>mode</code>，并且该<code>mode</code>必须注册任务事件。</li>
<li>
<code>RunLoop</code>是在默认<code>mode</code>下运行的，当然也可以指定一种<code>mode</code>运行，但是只能在一种<code>mode</code>下运行。</li>
<li>
<code>RunLoop</code>内部实际上是维护了一个<code>do-while</code>循环，线程就会一直留在这个循环里面，直到超时或者手动被停止。</li>
<li>
<code>RunLoop</code> 的核心就是一个 <code>mach_msg() </code>，<code>RunLoop</code> 调用这个函数去接收消息，如果没有别人发送 <code>port</code> 消息过来，内核会将线程置于等待状态，否则线程处理事件。</li>
</ul> 
<h1>
<a id="4_RunLoop_427"></a>4. RunLoop实际应用</h1> 
<ol>
<li>控制线程生命周期（线程保活）</li>
<li>解决NSTimer在滑动时停止工作的问题</li>
<li>监控应用卡顿</li>
<li>性能优化</li>
</ol> 
<h2>
<a id="RunLoop_434"></a>RunLoop的启动方法</h2> 
<pre><code class="prism language-objectivec"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>run<span class="token punctuation">;</span> <span class="token comment">// 默认模式</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>runUntilDate<span class="token punctuation">:</span><span class="token punctuation">(</span>NSDate <span class="token operator">*</span><span class="token punctuation">)</span>limitDate<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>runMode<span class="token punctuation">:</span><span class="token punctuation">(</span>NSRunLoopMode<span class="token punctuation">)</span>mode beforeDate<span class="token punctuation">:</span><span class="token punctuation">(</span>NSDate <span class="token operator">*</span><span class="token punctuation">)</span>limitDate<span class="token punctuation">;</span>
</code></pre> 
<ol>
<li>run：没有任何条件就可以启动，虽然简单，但是实际的操控结果并不影响，RunLoop是一个do while循环，倘若无条件的运行RunLoop将线程永远的放入循环，这就使我们没有办法控制循环本身，只能靠杀死进程来停止RunLoop</li>
<li>runUnitDate：设置时间限制。</li>
</ol> 
<ul><li>设置了超时的时间，超过这个时间RunLoop就结束了。</li></ul> 
<ol start="3"><li>runMode:beforeDate:在特定模式下启动。</li></ol> 
<ul><li>可以指定runloop以哪种模式运行，但是它是单次调用的，超时时间到达或者一个输入源被处理，则runLoop就会自动退出，上述两种方式都是循环调用的</li></ul> 
<p>第一种会一直运行下去，并且一直在NSDefaultRunLoopMode模式下，重复调用runMode:beforeDate:方法。<br> 第二种会在超时时间之前一直在NSDefaultRunLoopMode模式下调用runMode:beforeDate:方法。<br> 第三种则会在超时时间到达或者第一个inputsource被处理前一直调用runMode:beforeDate:方法。</p> 
<h2>
<a id="RunLoop_452"></a>RunLoop关闭</h2> 
<ol>
<li>将运行的循环配置设置为超时。</li>
<li>手动停止。</li>
</ol> 
<p>这里需要注意，虽然删除runloop的输入源和定时器可能会导致运行循环的退出，但这并不是个可靠的方法，系统可能会添加输入源到runloop中，但在我们的代码中可能并不知道这些输入源，因此无法删除它们，导致无法退出runloop。</p> 
<p>当我们通过 runUnitDate 和 runMode: beforeDate:方法启动RunLoop设置超时时间，但是如果需要对这个线程和它的RunLoop有着最精确的控制，并不是依赖超时机制，我们可以通过 CFRunLoopStop()方法来手动结束一个 RunLoop。但是 CFRunLoopStop()方法只会结束当前正在执行的这次runMode:beforeDate:调用，而不会结束后续runloop的调用。</p> 
<h2>
<a id="imageView_461"></a>imageView延迟显示</h2> 
<p>当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这是当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能出现卡顿的情况。</p> 
<p>我们应该推迟图片的实现，也就是ImageView推迟显示图片。当我们滑动时不要加载图片， 拖动结束再显示：</p> 
<pre><code class="prism language-objectivec"><span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>imageView performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>setImage<span class="token punctuation">:</span><span class="token punctuation">)</span> withObject<span class="token punctuation">:</span><span class="token punctuation">[</span>UIImage imageNamed<span class="token punctuation">:</span><span class="token string">@"imgName.png"</span><span class="token punctuation">]</span> afterDelay<span class="token punctuation">:</span><span class="token number">3.0</span> inModes<span class="token punctuation">:</span><span class="token operator">@</span><span class="token punctuation">[</span>NSDefaultRunLoopMode<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>用户点击屏幕，在主线程中，三秒之后显示图片，但是当用户点击屏幕之后，如果此时用户又开始滚动tableview，那么就算过了三秒，图片也不会显示出来，当用户停止了滚动，才会显示图片。</p> 
<p>这是因为限定了方法setImage只能在NSDefaultRunLoopMode模式下使用。而滚动tableview的时候，程序运行在tracking模式下面，所以方法setImage不会执行。</p> 
<h2>
<a id="_474"></a>常驻线程</h2> 
<p>开发应用程序的过程中，如果后台操作十分频繁，比如后台播放音乐、下载文件等等，我们希望执行后台代码的这条线程永远常驻内存，我们可以添加一条用于常驻内存的强引用子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop：</p> 
<pre><code class="prism language-objectivec"><span class="token keyword">@interface</span> <span class="token function">ViewController</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> strong<span class="token punctuation">)</span> NSThread <span class="token operator">*</span>thread<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

 <span class="token keyword">self</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSThread alloc<span class="token punctuation">]</span> initWithTarget<span class="token punctuation">:</span><span class="token keyword">self</span> selector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>runThread<span class="token punctuation">)</span> object<span class="token punctuation">:</span>nil<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>thread start<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-objectivec"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>runThread <span class="token punctuation">{<!-- --></span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"开启子线程：%@"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 子线程的RunLoop创建出来需要手动添加事件输入源和定时器 因为runloop如果没有CFRunLoopSourceRef事件源输入或者定时器，就会立马消亡。</span>
    <span class="token comment">//下面的方法给runloop添加一个NSport，就是添加一个事件源，也可以添加一个定时器，或者observer，让runloop不会挂掉</span>
    <span class="token punctuation">[</span><span class="token punctuation">[</span>NSRunLoop currentRunLoop<span class="token punctuation">]</span> addPort<span class="token punctuation">:</span><span class="token punctuation">[</span>NSPort port<span class="token punctuation">]</span> forMode<span class="token punctuation">:</span>NSDefaultRunLoopMode<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token punctuation">[</span>NSRunLoop currentRunLoop<span class="token punctuation">]</span> run<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 测试开始RunLoop</span>
    <span class="token comment">// 未进入循环就会执行该代码</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 同时在我们自己新建立的这个线程中写一下touchesBegan这个方法测试点击空白处会不会在子线程相应方法</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>touchesBegan<span class="token punctuation">:</span><span class="token punctuation">(</span>NSSet<span class="token operator">&lt;</span>UITouch <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token punctuation">)</span>touches withEvent<span class="token punctuation">:</span><span class="token punctuation">(</span>UIEvent <span class="token operator">*</span><span class="token punctuation">)</span>event  <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>runTest<span class="token punctuation">)</span> onThread<span class="token punctuation">:</span><span class="token keyword">self</span><span class="token punctuation">.</span>thread withObject<span class="token punctuation">:</span>nil waitUntilDone<span class="token punctuation">:</span>NO<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>runTest <span class="token punctuation">{<!-- --></span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"子线程点击空白：%@"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到RunLoop成功启动进入循环，点击屏幕的时候也是在子线程调用方法，这样子子线程启动完成之后就达到了常驻线程的目的。</p> 
<h2>
<a id="_511"></a>线程保活</h2> 
<p>场景：<br> 平时创建子线程时，线程上的任务执行完这个线程就会销毁掉。<br> 有时我们会需要经常在一个子线程中执行任务，频繁的创建和销毁线程就会造成很多的开销，这时我们可以通过runloop来控制线程的生命周期。</p> 
<p>在下面的代码中，因为runMode:beforeDate:方法是单次调用，我们需要给它加上一个循环，否则调用一次runloop就结束了，和不使用runloop的效果一样。</p> 
<p>这个循环的条件默认设置成YES，当调用stop方法中，执行CFRunLoopStop()方法结束本次runMode:beforeDate:，同时将循环中的条件设置为NO，使循环停止，runloop退出。</p> 
<pre><code class="prism language-objectivec"><span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> strong<span class="token punctuation">)</span> NSThread <span class="token operator">*</span>thread<span class="token punctuation">;</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> assign<span class="token punctuation">)</span> BOOL stopped<span class="token punctuation">;</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>viewDidLoad <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">[</span><span class="token keyword">super</span> viewDidLoad<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">self</span><span class="token punctuation">.</span>view<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token punctuation">[</span>UIColor greenColor<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    UIButton <span class="token operator">*</span>button <span class="token operator">=</span> <span class="token punctuation">[</span>UIButton buttonWithType<span class="token punctuation">:</span>UIButtonTypeRoundedRect<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>view addSubview<span class="token punctuation">:</span>button<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>button addTarget<span class="token punctuation">:</span><span class="token keyword">self</span> action<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>pressPrint<span class="token punctuation">)</span> forControlEvents<span class="token punctuation">:</span>UIControlEventTouchUpInside<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>button setTitle<span class="token punctuation">:</span><span class="token string">@"执行任务"</span> forState<span class="token punctuation">:</span>UIControlStateNormal<span class="token punctuation">]</span><span class="token punctuation">;</span>
    button<span class="token punctuation">.</span>frame <span class="token operator">=</span> <span class="token function">CGRectMake</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    
    UIButton <span class="token operator">*</span>stopButton <span class="token operator">=</span> <span class="token punctuation">[</span>UIButton buttonWithType<span class="token punctuation">:</span>UIButtonTypeRoundedRect<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>view addSubview<span class="token punctuation">:</span>stopButton<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>stopButton addTarget<span class="token punctuation">:</span><span class="token keyword">self</span> action<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>pressStop<span class="token punctuation">)</span> forControlEvents<span class="token punctuation">:</span>UIControlEventTouchUpInside<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>stopButton setTitle<span class="token punctuation">:</span><span class="token string">@"停止RunLoop"</span> forState<span class="token punctuation">:</span>UIControlStateNormal<span class="token punctuation">]</span><span class="token punctuation">;</span>
    stopButton<span class="token punctuation">.</span>frame <span class="token operator">=</span> <span class="token function">CGRectMake</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">self</span><span class="token punctuation">.</span>stopped <span class="token operator">=</span> NO<span class="token punctuation">;</span>
    <span class="token comment">//防止循环引用</span>
    __weak <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> weakSelf <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
    
    <span class="token keyword">self</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSThread alloc<span class="token punctuation">]</span> initWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"Thread---begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//向当前runloop添加Modeitem，添加timer、observer都可以。因为如果mode没有item，runloop就会退出</span>
        <span class="token punctuation">[</span><span class="token punctuation">[</span>NSRunLoop currentRunLoop<span class="token punctuation">]</span> addPort<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">[</span>NSPort alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span> forMode<span class="token punctuation">:</span>NSDefaultRunLoopMode<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>weakSelf<span class="token punctuation">.</span>stopped<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">[</span><span class="token punctuation">[</span>NSRunLoop currentRunLoop<span class="token punctuation">]</span> runMode<span class="token punctuation">:</span>NSDefaultRunLoopMode beforeDate<span class="token punctuation">:</span><span class="token punctuation">[</span>NSDate distantFuture<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"Thread---end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>thread start<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>pressPrint <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//子线程中调用print</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span> onThread<span class="token punctuation">:</span>_thread withObject<span class="token punctuation">:</span>nil waitUntilDone<span class="token punctuation">:</span>NO<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//子线程需要执行的任务</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>print <span class="token punctuation">{<!-- --></span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"%s, %@"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>pressStop <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//子线程中调用stop</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_stopped <span class="token operator">==</span> NO <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">[</span><span class="token keyword">self</span> performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>stop<span class="token punctuation">)</span> onThread<span class="token punctuation">:</span>_thread withObject<span class="token punctuation">:</span>nil waitUntilDone<span class="token punctuation">:</span>YES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

<span class="token comment">//停止子线程的runloop</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>stop <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//设置标记yes</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>stopped <span class="token operator">=</span> YES<span class="token punctuation">;</span>
    
    <span class="token comment">//停止runloop</span>
    <span class="token function">CFRunLoopStop</span><span class="token punctuation">(</span><span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"%s, %@"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//解除引用， 停止runloop这个子线程就会dealloc</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> nil<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>dealloc <span class="token punctuation">{<!-- --></span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"%s"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="NSTimer_596"></a>NSTimer不准</h2> 
<p>timer在实际的开发中一般不在主线程的RunLoop里面存在，因为主线程在执行阻塞任务的时候timer的计时器也会导致不准确。</p> 
<p>如果timer在主线程里面阻塞 如何解决timer不准确的问题。</p> 
<ul>
<li>放入子线程中，但是需要开辟线程和控制线程的生命周期，成本较大。</li>
<li>使用GCD的定时器计时，避免阻塞。</li>
</ul>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>