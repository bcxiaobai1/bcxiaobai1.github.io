<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【云原生】Docker镜像详细讲解 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【云原生】Docker镜像详细讲解</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-dracula">
                    
                        
                    
                    <h2>
<a id="_0"></a>前言</h2> 
<blockquote> 
 <p><font color="#B0C4DE;">大家好，本文是对 <code>Docker</code> 镜像的详细讲解，讲解了如何安装 <code>Docker</code>、配置 <code>Docker</code> 镜像加速以及操作 <code>Docker</code> 镜像。希望对大家有所帮助~</font></p> 
</blockquote> 
<p></p>
<div class="toc">
 <h3>目录</h3>
 <ul><li>
<ul>
<li><a href="#_0">前言</a></li>
<li><a href="#_Docker_6">一、安装 Docker</a></li>
<li>
<ul>
<li><a href="#11CentOS_8">1.1、CentOS</a></li>
<li><a href="#12Ubuntu_68">1.2、Ubuntu</a></li>
</ul>
   </li>
<li><a href="#Docker__117">二、Docker 镜像加速器</a></li>
<li>
<ul>
<li><a href="#21Ubuntu_1404Debian_7_Wheezy_135">2.1、Ubuntu 14.04、Debian 7 Wheezy</a></li>
<li><a href="#22Ubuntu_1604Debian_8CentOS_7_149">2.2、Ubuntu 16.04+、Debian 8+、CentOS 7</a></li>
<li><a href="#23Windows_10_170">2.3、Windows 10</a></li>
<li><a href="#24macOS_174">2.4、macOS</a></li>
<li><a href="#25_178">2.5、检查加速器是否生效</a></li>
</ul>
   </li>
<li><a href="#Docker__189">三、Docker 镜像</a></li>
<li>
<ul>
<li><a href="#31_191">3.1、获取镜像</a></li>
<li>
<ul><li><a href="#311_229">3.1.1、运行</a></li></ul>
    </li>
<li><a href="#32_261">3.2、列出镜像</a></li>
<li>
<ul>
<li><a href="#321_281">3.2.1、镜像体积</a></li>
<li><a href="#322_298">3.2.2、虚悬镜像</a></li>
<li><a href="#323_320">3.2.3、中间层镜像</a></li>
<li><a href="#324_330">3.2.4、列出部分镜像</a></li>
<li><a href="#325_370">3.2.5、以特定格式显示</a></li>
</ul>
    </li>
<li><a href="#33_408">3.3、删除本地镜像</a></li>
<li>
<ul>
<li><a href="#331_ID_416">3.3.1、用 ID、镜像名、摘要删除镜像</a></li>
<li><a href="#332Untagged__Deleted_468">3.3.2、Untagged 和 Deleted</a></li>
<li><a href="#333_docker_image_ls__478">3.3.3、用 docker image ls 命令来配合</a></li>
<li><a href="#334CentOSRHEL__496">3.3.4、CentOS/RHEL 的用户需要注意的事项</a></li>
</ul>
   </li>
</ul>
  </li>
</ul>
 </li></ul>
</div>
<p></p> 
<h2>
<a id="_Docker_6"></a>一、安装 Docker</h2> 
<h3>
<a id="11CentOS_8"></a>1.1、CentOS</h3> 
<p><code>Docker</code> 要求 <code>CentOS</code> 系统的内核版本高于 <code>3.10</code> ，查看本页面的前提条件来验证你的<code>CentOS</code> 版本是否支持 <code>Docker</code></p> 
<p>通过 <strong>uname -r</strong> 命令查看你当前的内核版本</p> 
<pre><code class="prism language-shell"><span class="token function">uname</span> -r
</code></pre> 
<p>使用 <code>root</code> 权限登录 <code>CentOS</code>。确保 <code>yum</code> 包更新到最新</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> yum update
</code></pre> 
<p>卸载旧版本(如果安装过旧版本的话)</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> yum remove <span class="token function">docker</span>  docker-common docker-selinux docker-engine
</code></pre> 
<p>安装需要的软件包， <code>yum-util</code> 提供<code>yum-config-manager</code>功能，另外两个是<code>devicemapper</code>驱动依赖的</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2
</code></pre> 
<p>设置<code>yum</code>源</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</code></pre> 
<p>可以查看所有仓库中所有<code>docker</code>版本，并选择特定版本安装</p> 
<pre><code class="prism language-shell">yum list docker-ce --showduplicates <span class="token operator">|</span> <span class="token function">sort</span> -r
</code></pre> 
<p>安装<code>docker</code></p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce  <span class="token comment">#由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0</span>
<span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token operator">&lt;</span>FQPN<span class="token operator">&gt;</span>  <span class="token comment"># 例如：sudo yum install docker-ce-17.12.0.ce</span>
</code></pre> 
<p>启动并加入开机启动</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> systemctl start <span class="token function">docker</span>
<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>
</code></pre> 
<p>验证安装是否成功(有<code>client</code>和<code>service</code>两部分表示docker安装启动都成功了)</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> version
</code></pre> 
<h3>
<a id="12Ubuntu_68"></a>1.2、Ubuntu</h3> 
<p>系统要求</p> 
<p><code>Docker CE</code> 支持以下版本的 <code>Ubuntu</code> 操作系统：</p> 
<ul>
<li> <p><code>Artful 17.10 (Docker CE 17.11 Edge +)</code></p> </li>
<li> <p><code>Xenial 16.04 (LTS)</code></p> </li>
<li> <p><code>Trusty 14.04 (LTS)</code></p> </li>
</ul> 
<p><code>Docker CE</code> 可以安装在 <code>64</code> 位的 <code>x86</code>平台或 <code>ARM</code> 平台上。<code>Ubuntu</code> 发行版中，<code>LTS（Long-Term-Support）</code>长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 <code>LTS</code> 版本,当前最新的 <code>LTS</code> 版本为 <code>Ubuntu 16.04</code>。</p> 
<p>卸载旧版本</p> 
<p>旧版本的 <code>Docker</code> 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">apt-get</span> remove <span class="token function">docker</span> <span class="token punctuation"></span>
               docker-engine <span class="token punctuation"></span>
               docker.io
</code></pre> 
<p>使用脚本自动安装</p> 
<p>在测试或开发环境中 <code>Docker</code> 官方为了简化安装流程，提供了一套便捷的安装脚本，<code>Ubuntu</code> 系统上可以使用这套安装脚本：</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -fsSL get.docker.com -o get-docker.sh
<span class="token function">sudo</span> <span class="token function">sh</span> get-docker.sh --mirror AzureChinaCloud
</code></pre> 
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 <code>Docker CE</code> 的 <code>Edge</code> 版本安装在系统中</p> 
<p>启动 <code>Docker CE</code></p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>
<span class="token function">sudo</span> systemctl start <span class="token function">docker</span>
</code></pre> 
<p>卸载 <code>Docker</code></p> 
<ul>
<li>先执行命令：<code>apt-get autoremove docker-ce</code>
</li>
<li>删除 <code>/etc/apt/sources.list.d</code> 目录下的 <code>docker.list</code> 文件</li>
</ul> 
<h2>
<a id="Docker__117"></a>二、Docker 镜像加速器</h2> 
<p>国内从 <code>Docker Hub</code> 拉取镜像有时会遇到困难，此时可以配置镜像加速器。<code>Docker</code> 官方和国内很多云服务商都提供了国内加速器服务，例如：</p> 
<ul>
<li>Docker 官方提供的中国 registry mirror</li>
<li>阿里云加速器</li>
<li>DaoCloud 加速器</li>
</ul> 
<p>我们以<code>Docker</code>阿里云加速器为例进行介绍。</p> 
<p>首先登录阿里云（没有账号请先注册），搜索 <strong>容器镜像服务</strong>，找到你的专属加速器地址。</p> 
<p>地址：</p> 
<pre><code class="prism language-http">https://www.aliyun.com/
</code></pre> 
<h3>
<a id="21Ubuntu_1404Debian_7_Wheezy_135"></a>2.1、Ubuntu 14.04、Debian 7 Wheezy</h3> 
<p>对于使用 upstart 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 <code>DOCKER_OPTS</code> 中配置加速器地址：</p> 
<pre><code class="prism language-shell"><span class="token assign-left variable">DOCKER_OPTS</span><span class="token operator">=</span><span class="token string">"--registry-mirror=https://xxxxxxxx.mirror.aliyuncs.com"</span>
</code></pre> 
<p>重新启动服务。</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">docker</span> restart
</code></pre> 
<h3>
<a id="22Ubuntu_1604Debian_8CentOS_7_149"></a>2.2、Ubuntu 16.04+、Debian 8+、CentOS 7</h3> 
<p>对于使用 systemd 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://xxxxxxxx.mirror.aliyuncs.com"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>注意，一定要保证该文件符合 <code>json</code> 规范，否则 <code>Docker</code> 将不能启动。</p> 
</blockquote> 
<p>之后重新启动服务。</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span>
</code></pre> 
<h3>
<a id="23Windows_10_170"></a>2.3、Windows 10</h3> 
<p>对于使用<code> Windows 10</code> 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 <code>Settings</code> ，打开配置窗口后左侧导航菜单选择 <code>Daemon</code> 。在 <code>Registry mirrors</code> 一栏中填写加速器地址 <code>https://registry.docker-cn.com</code> ，之后点击 <code>Apply</code> 保存后 <code>Docker</code> 就会重启并应用配置的镜像地址了。</p> 
<h3>
<a id="24macOS_174"></a>2.4、macOS</h3> 
<p>对于使用 <code>macOS</code> 的用户，在任务栏点击 <code>Docker for mac</code> 应用图标 -&gt;<code> Perferences...</code> -&gt; <code>Daemon</code> -&gt; <code>Registry mirrors</code>。在列表中填写加速器地址 <code>https://registry.docker-cn.com</code> 。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，<code>Docker</code> 就会重启并应用配置的镜像地址了。</p> 
<h3>
<a id="25_178"></a>2.5、检查加速器是否生效</h3> 
<p>配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 <code>docker info</code> ，如果从结果中看到了如下内容，说明配置成功。</p> 
<pre><code class="prism language-shell">Registry Mirrors:
 https://xxxxxxxx.mirror.aliyuncs.com
</code></pre> 
<h2>
<a id="Docker__189"></a>三、Docker 镜像</h2> 
<h3>
<a id="31_191"></a>3.1、获取镜像</h3> 
<p>之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p> 
<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code> 。其命令格式为：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口号<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span>
</code></pre> 
<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p> 
<ul><li>
<code>Docker</code> 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code> 。默认地址是 <code>Docker Hub</code>。</li></ul> 
<p>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code> 。对于 <code>Docker Hub</code> ，如果不给出用户名，则默认为 <code>library</code> ，也就是官方镜像。</p> 
<p>比如：</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> pull ubuntu:16.04
<span class="token number">16.04</span>: Pulling from library/ubuntu
4f53fa4d2cf0: Pull complete 
6af7c939e38e: Pull complete 
903d0ffd64f6: Pull complete 
04feeed388b7: Pull complete 
Digest: sha256:185fec2d6dbe9165f35e4a1136b4cf09363b328d4f850695393ca191aa1475fd
Status: Downloaded newer image <span class="token keyword">for</span> ubuntu:16.04
docker.io/library/ubuntu:16.04
</code></pre> 
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:16.04</code> ，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>16.04</code> 的镜像。</p> 
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p> 
<p>在使用上面命令的时候，你可能会发现，你所看到的<code>层 ID</code> 以及 <code>sha256</code> 的摘要和这里不一样。这是因为官方镜像是一致在维护的，有任何新的 <code>bug</code>，或者版本更新，都会进行修复再以原来的标签发布，这样可有确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p> 
<p><em>如果从<code> Docker Hub</code> 下载镜像非常缓慢，可以参照 <code>镜像加速器</code> 一节配置加速器。</em></p> 
<h4>
<a id="311_229"></a>3.1.1、运行</h4> 
<p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:16.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> run -it --rm <span class="token punctuation"></span>
    ubuntu:16.04 <span class="token punctuation"></span>
    <span class="token function">bash</span>

root@e7009c6ce357:/<span class="token comment"># cat /etc/os-release</span>
<span class="token assign-left variable">NAME</span><span class="token operator">=</span><span class="token string">"Ubuntu"</span>
<span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token string">"16.04.4 LTS, Trusty Tahr"</span>
<span class="token assign-left variable">ID</span><span class="token operator">=</span>ubuntu
<span class="token assign-left variable">ID_LIKE</span><span class="token operator">=</span>debian
<span class="token assign-left variable">PRETTY_NAME</span><span class="token operator">=</span><span class="token string">"Ubuntu 16.04.4 LTS"</span>
<span class="token assign-left variable">VERSION_ID</span><span class="token operator">=</span><span class="token string">"16.04"</span>
<span class="token assign-left variable">HOME_URL</span><span class="token operator">=</span><span class="token string">"http://www.ubuntu.com/"</span>
<span class="token assign-left variable">SUPPORT_URL</span><span class="token operator">=</span><span class="token string">"http://help.ubuntu.com/"</span>
<span class="token assign-left variable">BUG_REPORT_URL</span><span class="token operator">=</span><span class="token string">"http://bugs.launchpad.net/ubuntu/"</span>
</code></pre> 
<p><code>docker run</code> 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。</p> 
<ul>
<li>
<code>it</code> ：这是两个参数，一个是 <code>-i</code> ：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li>
<code>--rm</code> ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code> 。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li>
<code>ubuntu:16.04</code> ：这是指用 <code>ubuntu:16.04</code> 镜像为基础来启动容器。</li>
<li>
<code>bash</code> ：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul> 
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code> ，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 16.04.4 LTS</code> 系统。</p> 
<p>最后们通过 <code>exit</code> 或者 <code>Ctrl + D</code> 退出了这个容器。</p> 
<h3>
<a id="32_261"></a>3.2、列出镜像</h3> 
<p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        <span class="token number">5</span> days ago          <span class="token number">183</span> MB
nginx                latest              05a60462f8ba        <span class="token number">5</span> days ago          <span class="token number">181</span> MB
mongo                <span class="token number">3.2</span>                 fe9198c04d62        <span class="token number">5</span> days ago          <span class="token number">342</span> MB
<span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>               <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>              00285df0df87        <span class="token number">5</span> days ago          <span class="token number">342</span> MB
ubuntu               <span class="token number">16.04</span>               f753707788c5        <span class="token number">4</span> weeks ago         <span class="token number">127</span> MB
ubuntu               latest              f753707788c5        <span class="token number">4</span> weeks ago         <span class="token number">127</span> MB
ubuntu               <span class="token number">14.04</span>               1e0c3dd64ccd        <span class="token number">4</span> weeks ago         <span class="token number">188</span> MB
</code></pre> 
<p>列表包含了 <code>仓库名</code> 、<code>标签</code> 、<code>镜像 ID</code> 、<code>创建时间</code> 、以及 <code>所占用的空间</code>。</p> 
<p>其中仓库名、标签在之前的基础概念已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个<strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:16.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p> 
<h4>
<a id="321_281"></a>3.2.1、镜像体积</h4> 
<p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如， <code>ubuntu:16.04</code> 镜像大小，在这里是 <code>127MB</code> ，但是在 Docker Hub 显示的却是 <code>50MB</code> 。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p> 
<p>另外一个需要注意的问题是， <code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗，由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p> 
<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用空间。</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> system <span class="token function">df</span>
TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              <span class="token number">24</span>                  <span class="token number">0</span>                   <span class="token number">1</span>.992GB             <span class="token number">1</span>.992GB <span class="token punctuation">(</span><span class="token number">100</span>%<span class="token punctuation">)</span>
Containers          <span class="token number">1</span>                   <span class="token number">0</span>                   <span class="token number">62</span>.82MB             <span class="token number">62</span>.82MB <span class="token punctuation">(</span><span class="token number">100</span>%<span class="token punctuation">)</span>
Local Volumes       <span class="token number">9</span>                   <span class="token number">0</span>                   <span class="token number">652</span>.2MB             <span class="token number">652</span>.2MB <span class="token punctuation">(</span><span class="token number">100</span>%<span class="token punctuation">)</span>
Build Cache  
</code></pre> 
<h4>
<a id="322_298"></a>3.2.2、虚悬镜像</h4> 
<p>尚明的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p> 
<pre><code class="prism language-shell"><span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>               <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>              00285df0df87        <span class="token number">5</span> days ago          <span class="token number">342</span> MB
</code></pre> 
<p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时， <code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code> 。除了 <code>docker pull</code> 可能导致这种情况， <code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称之为 <strong>虚悬镜像(dangling image)</strong>，可以用下面的命令专门显示这类镜像：</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span> -f <span class="token assign-left variable">dangling</span><span class="token operator">=</span>true
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
<span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>              <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>              00285df0df87        <span class="token number">5</span> days ago          <span class="token number">342</span> MB
</code></pre> 
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image prune
</code></pre> 
<h4>
<a id="323_320"></a>3.2.3、中间层镜像</h4> 
<p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span> -a
</code></pre> 
<p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其他镜像所依赖的镜像。这些无标签镜像不应该删除，否者会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p> 
<h4>
<a id="324_330"></a>3.2.4、列出部分镜像</h4> 
<p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。 <code>docker iimage ls</code> 有好几个参数可以帮助做到这个事情。</p> 
<p>根据仓库名列出镜像</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span> ubuntu
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              <span class="token number">16.04</span>               f753707788c5        <span class="token number">4</span> weeks ago         <span class="token number">127</span> MB
ubuntu              latest              f753707788c5        <span class="token number">4</span> weeks ago         <span class="token number">127</span> MB
ubuntu              <span class="token number">14.04</span>               1e0c3dd64ccd        <span class="token number">4</span> weeks ago         <span class="token number">188</span> MB
</code></pre> 
<p>列出特定的某个镜像，也就是说指定仓库名和标签</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span> ubuntu:16.04
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              <span class="token number">16.04</span>               f753707788c5        <span class="token number">4</span> weeks ago         <span class="token number">127</span> MB
</code></pre> 
<p>除此之外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，塔还有更多的用法。比如，我们希望在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span> -f <span class="token assign-left variable">since</span><span class="token operator">=</span>mongo:3.2
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
redis               latest              5f515359c7f8        <span class="token number">5</span> days ago          <span class="token number">183</span> MB
nginx               latest              05a60462f8ba        <span class="token number">5</span> days ago          <span class="token number">181</span> MB
</code></pre> 
<p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可、</p> 
<p>此外，如果镜像构建时，定义了 <code>LABEL</code> ，还可以通过 <code>LABEL</code> 来过滤。</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span> -f <span class="token assign-left variable">label</span><span class="token operator">=</span>com.example.version<span class="token operator">=</span><span class="token number">0.1</span>
<span class="token punctuation">..</span>.
</code></pre> 
<h4>
<a id="325_370"></a>3.2.5、以特定格式显示</h4> 
<p>默认情况下， <code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span> -q
5f515359c7f8
05a60462f8ba
fe9198c04d62
00285df0df87
f753707788c5
f753707788c5
1e0c3dd64ccd
</code></pre> 
<p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配已完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p> 
<p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。</p> 
<p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID 和仓库名：</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span> --format <span class="token string">"{<!-- -->{.ID}}: {<!-- -->{.Repository}}"</span>
5f515359c7f8: redis
05a60462f8ba: nginx
fe9198c04d62: mongo
00285df0df87: <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
f753707788c5: ubuntu
f753707788c5: ubuntu
1e0c3dd64ccd: ubuntu
</code></pre> 
<p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> image <span class="token function">ls</span> --format <span class="token string">"table {<!-- -->{.ID}}<span class="token entity" title="t">t</span>{<!-- -->{.Repository}}<span class="token entity" title="t">t</span>{<!-- -->{.Tag}}"</span>
</code></pre> 
<h3>
<a id="33_408"></a>3.3、删除本地镜像</h3> 
<p>如果想要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> image <span class="token function">rm</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>镜像<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>镜像<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<h4>
<a id="331_ID_416"></a>3.3.1、用 ID、镜像名、摘要删除镜像</h4> 
<p>其中， <code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p> 
<p>比如我们有这么一些镜像：</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
centos                      latest              0584b3d2cf6d        <span class="token number">3</span> weeks ago         <span class="token number">196.5</span> MB
redis                       alpine              501ad78535f0        <span class="token number">3</span> weeks ago         <span class="token number">21.03</span> MB
<span class="token function">docker</span>                      latest              cf693ec9b5c7        <span class="token number">3</span> weeks ago         <span class="token number">105.1</span> MB
nginx                       latest              e43d811ce2f4        <span class="token number">5</span> weeks ago         <span class="token number">181.5</span> MB
</code></pre> 
<p>我们可以用镜像的完整 <code>ID</code>，也称为 <code>长 ID</code> ，来删除镜像。使用脚本的时候可能会用<code>长 ID</code>，但是人工输入就太累了，所以更多的时候使用 <code>短 ID</code> 来删除镜像。 <code>docker image ls</code> 默认列出的就已经是<code>短 ID </code>了，一般取前 3 个字符以上，只要足够区分于别的镜像就可以了。</p> 
<p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">rm</span> <span class="token number">501</span>
Untagged: redis:alpine
Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d
Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7
Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b
Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23
Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa
Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3
Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7
</code></pre> 
<p>我们也可以用 <code>镜像名</code> ，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> ，来删除镜像。</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">rm</span> centos
Untagged: centos:latest
Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c
Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a
Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38
</code></pre> 
<p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> image <span class="token function">ls</span> --digests
REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE
<span class="token function">node</span>                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        <span class="token number">3</span> weeks ago         <span class="token number">214</span> MB

$ <span class="token function">docker</span> image <span class="token function">rm</span> node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
</code></pre> 
<h4>
<a id="332Untagged__Deleted_468"></a>3.3.2、Untagged 和 Deleted</h4> 
<p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 <code>ID</code> 和摘要，而一个镜像可以有多个标签。</p> 
<p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p> 
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的源。</p> 
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p> 
<h4>
<a id="333_docker_image_ls__478"></a>3.3.3、用 docker image ls 命令来配合</h4> 
<p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code> ，这样可以成批的删除希望删除的镜像。我们在 “镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p> 
<p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> image <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> image <span class="token function">ls</span> -q redis<span class="token variable">)</span></span>
</code></pre> 
<p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> image <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> image <span class="token function">ls</span> -q -f <span class="token assign-left variable">before</span><span class="token operator">=</span>mongo:3.2<span class="token variable">)</span></span>
</code></pre> 
<p>充分利用你的想象力和 <code>Linux</code> 命令行的强大，你可以完成很多非常赞的功能。</p> 
<h4>
<a id="334CentOSRHEL__496"></a>3.3.4、CentOS/RHEL 的用户需要注意的事项</h4> 
<p>在 <code>Ubuntu/Debian</code> 上有 <code>UnionFS</code> 可以使用，如 <code>aufs</code> 或者 <code>overlay2</code>，而 <code>CentOS</code> 和 <code>RHEL</code> 的内核中没有相关驱动。因此对于这类系统，一般使用 <code>devicemapper</code> 驱动利用<code> LVM</code> 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。<code>Docker</code> 安装在 <code>CentOS/RHEL</code> 上后，会默认选择 <code>devicemapper</code>，但是为了简化配置，其 <code>devicemapper</code> 是跑在一个稀疏文件模拟的块设备上，也被称为 <code>loop-lvm</code>。这样的选择是因为不需要额外配置就可以运行 <code>Docker</code>，这是自动配置唯一能做到的事情。但是 <code>loop-lvm</code> 的做法非常不好，其稳定性、性能更差，无论是日志还是 <code>docker info</code> 中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给 <code>devicemapper</code> 驱动做存储层的做法，这类做法也被称为配置 <code>direct-lvm</code>。</p> 
<p>除了前面说到的问题外，<code>devicemapper</code> + <code>loop-lvm</code> 还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到 <code>/var/lib/docker/devicemapper/devicemapper/data</code> 不断增长，而且无法控制。很多人会希望删除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，随着使用这个稀疏文件一直在不断增长。</p> 
<p>所以对于 <code>CentOS/RHEL</code> 的用户来说，在没有办法使用 <code>UnionFS</code> 的情况下，一定要配置 <code>direct-lvm</code> 给 <code>devicemapper</code>，无论是为了性能、稳定性还是空间利用率。</p> 
<p><em>或许有人注意到了 <code>CentOS 7</code> 中存在被 <code>backports</code> 回来的 <code>overlay</code> 驱动，不过 <code>CentOS</code> 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。</em></p> 
<blockquote> 
 <p><font color="#B0C4DE;">读到这里，想必你知道如何的安装Docker，以及了解了Docker非常重要的镜像。别忘了三连支持博主呀~<br> 我是微枫<code>Micromaple</code>，期待你的关注~???</font></p> 
</blockquote>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>