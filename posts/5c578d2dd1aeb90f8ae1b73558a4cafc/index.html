<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【面经】米哈游数据开发面经 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【面经】米哈游数据开发面经</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <p>声明：面经从网络上搜集，自己补充了答案，不保证准确。</p> 
<blockquote> 
 <p>作者：蓝荆凌<br> 链接：https://www.nowcoder.com/discuss/285388?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=7ECACE7605534464872AA4CD0FF6C741-1658975042162<br> 来源：牛客网</p> 
</blockquote> 
<p>  最近秋招启动的公司越来越多了。现在开始每天刷刷面经。欢迎<a href="https://mp.weixin.qq.com/s/Yi-wDf9uyImOvNYhOph_nw">点击此处</a>关注公众号。</p> 
<h5>
<a id="1_8"></a>1、自我介绍</h5> 
<h5>
<a id="2_10"></a>2、你这些实习好像都很短啊，原因是什么？</h5> 
<h5>
<a id="3_xxx__12"></a>3、讲一下 xxx 公司实习的内容吧。</h5> 
<ul>
<li>oncall：就是查 bug，线上出问题了会找到你。怎么查这个 bug 呢，这就是追溯，可以后面写文章详细讨论。</li>
<li>重构：以前的表换了，比如 dwd 层一张表换成了另一张表，你下游的 dws、app 是不是都得变。这里就会产生数据一致性问题，面试经常问数据一致性，这里后面详细讨论。</li>
<li>开发迭代需求：在已有的需求基础上迭代，修改一些原来已经存在的代码。这里就需要你读懂前人的代码逻辑…</li>
<li>开发新需求：这个工作周期长，难度大，需要和 PM、QA、RD、UI 等等很多人合作。这里后面细说。</li>
<li>回溯：这个工作占比很大，比如你产出了 app 层的表，修改了其中的口径（可以理解为字段的计算逻辑），那么修改完后是不是的重跑历史数据，这并不是点一下运行就能完事的。后面再详细讨论。</li>
<li>同步：怎么把 Hive 的数据推导 Elasticsearch 或者 ClickHouse 让线上能够使用？</li>
<li>看书：《Hive 编程指南》</li>
</ul> 
<h5>
<a id="4Spark__22"></a>4、Spark 的宽窄依赖了解么？</h5> 
<ul>
<li>定义：在 DAG 调度中需要对计算过程划分 stage，而划分依据就是 RDD 之间的依赖关系。针对不同的转换函数， RDD 之间的依赖关系分类窄依赖（narrow dependency）和宽依赖（wide dependency, 也称 shuffle dependency）。 
  <ul>
<li>窄依赖是指父 RDD 的每个分区只被子 RDD 的一个分区所使用，子 RDD 分区通常对应常数个父 RDD 分区(O(1)，与数据规模无关)</li>
<li>宽依赖是指父 RDD 的每个分区都可能被多个子 RDD 分区所使用，子 RDD 分区通常对应所有的父 RDD 分区(O(n)，与数据规模有关)</li>
</ul> </li>
<li>如何划分：有 Shuffle 的是宽依赖。</li>
</ul> 
<h5>
<a id="5Spark__RDDDataFrameDataSet__29"></a>5、Spark 中的 RDD、DataFrame、DataSet 的区别？</h5> 
<table>
<thead><tr>
<th align="left">标准</th>
<th align="left">Spark Datasets</th>
<th align="left">Spark Dataframes</th>
<th align="left">Spark RDDs</th>
</tr></thead>
<tbody>
<tr>
<td align="left">数据表示</td>
<td align="left">Spark Datasets 是 Dataframe 和 RDD 的组合，具有静态类型安全和面向对象接口等特性。</td>
<td align="left">Spark Dataframe 是组织成命名列的分布式数据集合。</td>
<td align="left">Spark RDD 是一个没有模式的分布式数据集合。</td>
</tr>
<tr>
<td align="left">优化</td>
<td align="left">Datasets 使用催化剂优化器进行优化。</td>
<td align="left">Dataframes 使用催化剂优化器进行优化。</td>
<td align="left">没有内置的优化引擎。</td>
</tr>
<tr>
<td align="left">模式投影</td>
<td align="left">Datasets 使用 SQL 引擎自动查找模式。</td>
<td align="left">Dataframes 也会自动找到模式。</td>
<td align="left">Schema 需要在 RDD 中手动定义。</td>
</tr>
<tr>
<td align="left">聚合速度</td>
<td align="left">数据集聚合比 RDD 快，但比 Dataframes 慢。</td>
<td align="left">由于提供了简单而强大的 API，Dataframe 中的聚合速度更快。</td>
<td align="left">在执行数据分组等简单操作时，RDD 比数据帧和数据集都慢。</td>
</tr>
</tbody>
</table>
<h5>
<a id="6Spark__map__flatMap__38"></a>6、Spark 中的 map 和 flatMap 的区别是什么？</h5> 
<ul>
<li>map 的作用是对 rdd 之中的元素进行逐一进行函数操作映射为另外一个 rdd。即对每一条输入进行指定的操作，然后为每一条输入返回一个对象；</li>
<li>flatMap 的操作是将函数应用于 rdd 之中的每一个元素，将返回的<strong>迭代器</strong>的<strong>所有内容</strong>构成新的 rdd。即先映射后扁平化，最后合并成一个对象。</li>
</ul> 
<pre><code class="prism language-shell"><span class="token assign-left variable">rdd</span><span class="token operator">=</span>sc.parallelize<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span><span class="token punctuation">)</span>
rdd.collect<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># [1,2,3]</span>

<span class="token assign-left variable">rdd1</span><span class="token operator">=</span>rdd.map<span class="token punctuation">(</span>lambda:range<span class="token punctuation">(</span>x,3<span class="token punctuation">))</span>
rdd1.collect<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># [[1,2],[2],[]]</span>

<span class="token assign-left variable">rdd2</span><span class="token operator">=</span>rdd.flatMap<span class="token punctuation">(</span>lambda:range<span class="token punctuation">(</span>x,3<span class="token punctuation">))</span>
rdd2.collect<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># [1,2,2]</span>
</code></pre> 
<h5>
<a id="7Spark__groupByKeyreduceByKeyaggregateByKey__57"></a>7、Spark 中的 groupByKey、reduceByKey、aggregateByKey 的区别？</h5> 
<p>groupByKey 和 reduceByKey：</p> 
<ul>
<li>从 shuffle 的角度：reduceByKey 和 groupByKey 都存在 shuffle 的操作，但是 reduceByKey 可以在 shuffle 前对分区内相同 key 的数据进行预聚合（combine）功能，这样会减少落盘的数据量，而 groupByKey 只是进行分组，不存在数据量减少的问题，reduceByKey 性能比较高。</li>
<li>从功能的角度：reduceByKey 其实包含分组和聚合的功能。groupByKey 只能分组，不能聚合，所以在分组聚合的场合下，推荐使用 reduceByKey，如果仅仅是分组而不需要聚合。那么还是只能使用 groupByKey。</li>
</ul> 
<p>reduceByKey 和 aggregateByKey：</p> 
<ul>
<li>reduceByKey 可以认为是 aggregateByKey的简化版；</li>
<li>aggregateByKey 分为三个参数，多提供了一个函数 Seq Function，可以控制如何对每个 partition 中的数据进行先聚合，然后才是对所有partition中的数据进行全局聚合。</li>
</ul> 
<h5>
<a id="8_MapReduce__69"></a>8、一个完整的 MapReduce 整个有哪些过程？这些过程中哪些会用到排序呢？</h5> 
<p>过程：</p> 
<ul>
<li>Map 阶段：提交待处理文本，任务规划，提交到Yarn，算出 MapTask 数量，TextInputFormat 读数据，在 Maptask 中进行逻辑运算，把输入变成 kv 键值对，分区方法将数据标记好分区，outputCollector 把数据输出到环形缓冲区。</li>
<li>shuffle 阶段：环形缓冲区达到 80% 溢写，溢写前对 key 的索引<strong>快排</strong>，溢写文件<strong>归并排序</strong>，也可 combiner，最后按分区存到磁盘。</li>
<li>Reduce 阶段：拉取分区的数据，先存到内存，不够再存磁盘，拉完后<strong>归并排序</strong>。这里拉取数据是按照 key 进行 hash，相同的 key 会进入同一个 reduceTask，大量热点 key 进入同一个 reducetask 可能产生数据倾斜。</li>
</ul> 
<p><img src="https://images2.imgbox.com/63/47/LEuqHZUd_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f9/5e/tMM0my62_o.png" alt="在这里插入图片描述"></p> 
<p>排序：一次快速排序，两次归并排序。</p> 
<h5>
<a id="9Hadoop__SecondaryNameNode__84"></a>9、Hadoop 里面的 SecondaryNameNode 的作用是什么？具体恢复过程了解么？</h5> 
<ul>
<li>作用：SecondaryNameNode 每隔一段时间对 NameNode 元数据备份。</li>
<li>恢复：删除 NameNode 存储的数据。拷贝 SecondaryNameNode 中数据到原 NameNode 存储数据目录。重新启动 NameNode。</li>
</ul> 
<h5>
<a id="10Hive__join_Hive__join__mapjoin__89"></a>10、Hive 里面的 join 分哪些类型呢？Hive 的 join 的优化一般会怎么优化？除了 mapjoin 还知道别的么？</h5> 
<p>分类：</p> 
<p>包括 inner join、left outer join、right outer join、full outer join 类似其他数据库的操作。</p> 
<p>还有下面讲一些使用较少的：</p> 
<p><strong>left semi join</strong>：返回左表的记录，前提是该记录在右表存在。例如：</p> 
<pre><code class="prism language-sql"><span class="token comment"># 例如下面的语法，Hive 中是不支持的</span>
<span class="token keyword">select</span> s<span class="token punctuation">.</span>ymd<span class="token punctuation">,</span>s<span class="token punctuation">.</span>symbol<span class="token punctuation">,</span>s<span class="token punctuation">.</span>price_close <span class="token keyword">from</span> stocks s
<span class="token keyword">where</span> s<span class="token punctuation">.</span>ymd<span class="token punctuation">,</span>s<span class="token punctuation">.</span>symbol <span class="token operator">in</span>
<span class="token punctuation">(</span><span class="token keyword">select</span> d<span class="token punctuation">.</span>ymd<span class="token punctuation">,</span> d<span class="token punctuation">.</span>symbol <span class="token keyword">from</span> dividends d<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># Hive 中实现</span>
<span class="token keyword">select</span> s<span class="token punctuation">.</span>ymd<span class="token punctuation">,</span>s<span class="token punctuation">.</span>symbol<span class="token punctuation">,</span>s<span class="token punctuation">.</span>price_close
<span class="token keyword">from</span> stocks s <span class="token keyword">left</span> semi <span class="token keyword">join</span> dividends
<span class="token keyword">on</span> s<span class="token punctuation">.</span>ymd <span class="token operator">=</span> d<span class="token punctuation">.</span>ymd <span class="token operator">and</span> s<span class="token punctuation">.</span>symbol<span class="token operator">=</span>d<span class="token punctuation">.</span>symbol<span class="token punctuation">;</span>
</code></pre> 
<p><strong>笛卡尔积 join</strong>：错误的连接可能导致笛卡尔积，它会产生大量的数据，无法优化。设置<code>hive.mapred.mod</code>为 strict 会阻止笛卡尔积。</p> 
<p><strong>map-side join</strong>：设置开启 map-side join，并设置使用这个优化时小表的大小：</p> 
<pre><code class="prism language-sql"><span class="token comment"># 开启 map-side join</span>
<span class="token keyword">set</span> hive<span class="token punctuation">.</span>auto<span class="token punctuation">.</span><span class="token keyword">convert</span><span class="token punctuation">.</span><span class="token keyword">join</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment"># 设置小表大小</span>
<span class="token keyword">set</span> hive<span class="token punctuation">.</span>mapjoin<span class="token punctuation">.</span>smalltable<span class="token punctuation">.</span>filesize<span class="token operator">=</span><span class="token number">25000000</span>

<span class="token comment"># 分桶存储的大表也是可以使用的</span>
<span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">optimize</span><span class="token punctuation">.</span>bucketmapJOIN<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果所有的表有相同的分桶数，且数据是按照连接键或桶的键排序的，那么可以使用更快的分类-合并连接（sort-merge JOIN）：</p> 
<pre><code class="prism language-sql"><span class="token keyword">set</span> hive<span class="token punctuation">.</span>input<span class="token punctuation">.</span>format<span class="token operator">=</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hive<span class="token punctuation">.</span>ql<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BucketizedHiveInputFormat<span class="token punctuation">;</span>
<span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">optimize</span><span class="token punctuation">.</span>bucektmapjoin<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">optimize</span><span class="token punctuation">.</span>bucketmapjoin<span class="token punctuation">.</span>sortedmerge<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre> 
<p>优化：</p> 
<ul>
<li>left semi join 代替 in。</li>
<li>mapjoin：将数据量比较小的表，直接缓存在内存，然后在map段完成join，性能提高不少。</li>
</ul> 
<h5>
<a id="11kafka_Spark_StreamingFlink__140"></a>11、kafka接触过吗？实时计算的 Spark Streaming、Flink 了解过吗？</h5> 
<h5>
<a id="12_144"></a>12、数仓分层一般分为哪几层？数仓建模时用到的雪花模型和星型模型的区别？</h5> 
<p>分层：</p> 
<ul>
<li>操作数据层 ODS：把操作系统数据几乎无处理地存放在数据仓库系统中；</li>
<li>公共维度模型层 CDM：存放明细事实数据、维表数据及公共指标汇总数据 ， 其中明细事实数据、维表数据一般根据 ODS 层数据加工生成，CDM 层又细分为<strong>明细数据层 DWD</strong> 和<strong>汇总数据层 DWS</strong> ，采用维度模型方法作为理论基础，更多地采用一些维度退化手法，将维度退化至事实表中，减少事实表和维表的关联，提高明细数据表的易用性：同时在汇总数据层，加强指标的维度退化，采取更多的宽表化手段构建公共指标数据层，提升公共指标的复用性。</li>
<li>应用数据层 APP：存放数据产品个性化的统计指标数据，根据 CDM 层与 ODS 层加工生成 （个性化指标：排名型、比值型等）。</li>
<li>维度 DIM：商品维度表（维度整合）、地区维度表（维度整合）、日期维度表、优惠券维度表、活动维度表（整合）。</li>
</ul> 
<h5>
<a id="13_153"></a>13、主要开发语言是什么？</h5> 
<h5>
<a id="14_JVM__155"></a>14、讲一下 JVM 的内存模型吧。</h5> 
<p><img src="https://images2.imgbox.com/7b/7b/8lRyCKAM_o.png" alt="在这里插入图片描述"></p> 
<p>java 虚拟机主要分为以下几个区:</p> 
<ol><li>
<strong>方法区</strong>：</li></ol> 
<p>a. 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生 GC，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载</p> 
<p>b. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</p> 
<p>c. 该区域是被线程共享的。</p> 
<p>d. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</p> 
<ol start="2"><li>
<strong>虚拟机栈</strong>:</li></ol> 
<p>a. 虚拟机栈也就是我们平常所称的栈内存,它为 java 方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p> 
<p>b. 虚拟机栈是线程私有的，它的生命周期与线程相同。</p> 
<p>c. 局部变量表里存储的是基本数据类型、returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</p> 
<p>d. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p> 
<p>e. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p> 
<ol start="3">
<li> <p><strong>本地方法栈</strong>：<br> 本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。</p> </li>
<li> <p><strong>堆</strong>：</p> </li>
</ol> 
<p>java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p> 
<p><strong>5)</strong> <strong>程序计数器：</strong></p> 
<p>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p> 
<h5>
<a id="15_GC__Eden__195"></a>15、常用的 GC 算法有哪些？怎么判断一个对象是否可以被回收？分代内存回收了解么？年轻代的继续划分？如果我要分配一个对象，这个对象已经超过了 Eden 区的大小，这时会发生什么情况？</h5> 
<p>1.GC 算法：</p> 
<ul>
<li>
<strong>引用计数法</strong> 应用于：微软的COM/ActionScrip3/Python等 
  <ul><li>如果对象没有被引用，就会被回收，缺点：需要维护一个引用计算器</li></ul> </li>
<li>
<strong>复制算法</strong> 年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying) 
  <ul>
<li>效率高，缺点：需要内存容量大，比较耗内存</li>
<li>使用在占空间比较小、刷新次数多的新生区</li>
</ul> </li>
<li>
<strong>标记清除</strong> 老年代一般是由标记清除或者是标记清除与标记整理的混合实现 
  <ul><li>效率比较低，会差生碎片。</li></ul> </li>
<li>
<strong>标记压缩</strong> 老年代一般是由标记清除或者是标记清除与标记整理的混合实现 
  <ul><li>效率低速度慢，需要移动对象，但不会产生碎片。</li></ul> </li>
<li>
<strong>标记清除压缩</strong>标记清除-标记压缩的集合，多次GC后才Compact 
  <ul><li>使用于占空间大刷新次数少的养老区，是3 4的集合体</li></ul> </li>
</ul> 
<p>2.如何判断对象是否可以被回收：</p> 
<ul>
<li>引用计数法</li>
<li>可达性算法(引用链法)</li>
</ul> 
<p>3.内存回收</p> 
<ol>
<li> <p>对象优先在堆的Eden区分配。</p> </li>
<li> <p>大对象直接进入老年代。</p> </li>
<li> <p>长期存活的对象将直接进入老年代。</p> </li>
</ol> 
<p>当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC. Minor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 GC 的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。</p> 
<h5>
<a id="16CMS__G1_226"></a>16、常用的垃圾收集器，CMS 和 G1了解吗？</h5> 
<p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现,在标记清理过程中不会导致用户线程无法定位引用对象。仅作用于老年代收集。</p> 
<ol>
<li>初始标记（CMS initial mark）：独占CPU，stop-the-world, 仅标记GCroots能直接关联的对象,速度比较快；</li>
<li>并发标记（CMS concurrent mark）:可以和用户线程并发执行，通过GCRoots Tracing 标记所有可达对象；</li>
<li>重新标记（CMS remark）：独占CPU，stop-the-world, 对并发标记阶段用户线程运行产生的垃圾对象进行标记修正,以及更新逃逸对象；</li>
<li>并发清理（CMS concurrent sweep）：可以和用户线程并发执行，清理在重复标记中被标记为可回收的对象。</li>
</ol> 
<p>G1 收集器弱化了 CMS 原有的分代模型（分代可以是不连续的空间），将堆内存划分成一个 个Region 1MB~32MB，默认 2048 个分区），这么做的目的是在进行收集时不必在全堆范围内进行。它主要特点在于达到可控的停顿时间，用户可以指定收集操作在多长时间内完成，即 G1提供了接近实时的收集特性。它的步骤如下：</p> 
<ol>
<li>初始标记（Initial Marking）：标记一下GC Roots能直接关联到的对象，伴随着一次普通的Young GC发生，并修改NTAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，此阶段是stop-the-world操作。</li>
<li>根区间扫描，标记所有幸存者区间的对象引用，扫描 Survivor到老年代的引用，该阶段必须在下一次Young GC 发生前结束。</li>
<li>并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行，该阶段可以被Young GC中断。</li>
<li>最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，此阶段是stop-the-world操作，使用snapshot-at-the-beginning (SATB) 算法。</li>
<li>筛选回收（Live Data Counting and Evacuation）：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划,回收没有存活对象的Region并加入可用Region队列。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ol> 
<h5>
<a id="17Java__243"></a>17、Java 的双亲委派模型了解么？</h5> 
<p>JVM 中提供了三层的 ClassLoader：</p> 
<ul>
<li> <p>Bootstrap classLoader：主要负责加载核心的类库(java.lang.*等)，构造 ExtClassLoader 和 APPClassLoader。</p> </li>
<li> <p>ExtClassLoader：主要负责加载 jre/lib/ext 目录下的一些扩展的 jar。</p> </li>
<li> <p>AppClassLoader：主要负责加载应用程序的主函数类。</p> </li>
</ul> 
<p>当一个类收到了类加载请求，它不会尝试自己去加载，而是把这个请求委派给父类完成。每一层都是如此。只有当父类加载器反馈自己无法完成这个请求的时候子类加载器才会尝试自己去加载。</p> 
<p>优点：防止核心库被随意篡改；避免类的重复加载。</p> 
<h5>
<a id="18Java__257"></a>18、Java 里面支持多继承么？接口和抽象类的区别是什么？</h5> 
<p>不支持。</p> 
<p>区别：</p> 
<p>抽象类：</p> 
<ul>
<li>构造方法：有构造方法，用于子类实例化使用。</li>
<li>成员变量：可以是变量，也可以是常量。</li>
<li>成员方法：可以是抽象的，也可以是非抽象的。</li>
<li>继承：只能单继承。</li>
</ul> 
<p>接口：</p> 
<ul>
<li>构造方法：没有构造方法</li>
<li>成员变量：只能是常量。默认修饰符：public static final</li>
<li>成员方法：jdk1.7只能是抽象的。默认修饰符：public abstract (推荐：默认修饰符请自己永远手动给出)<br> jdk1.8可以写以default和static开头的具体方法。</li>
<li>实现：可以实现多个接口。</li>
</ul> 
<h5>
<a id="19HashMap__ConcurrentHashMap_ConcurrentHashMap_HashMap_279"></a>19、HashMap 和 ConcurrentHashMap 的区别是什么？ConcurrentHashMap 具体是怎么实现线程安全的，了解么？HashMap底层的数据结构了解么？二叉搜索树和平衡二叉树有什么区别？如何将一个二叉搜索树变成一个平衡二叉树？</h5> 
<p>HashMap：</p> 
<ul>
<li>数据结构：数组 + 链表 + 红黑树。</li>
<li>安全性：非线程安全，因为底层代码操作数组时未加锁。</li>
</ul> 
<p>ConcurrentHashMap：</p> 
<ul>
<li>数据结构：分段数组 + 链表 + 红黑树</li>
<li>安全性：线程安全，因为底层代码在操作每一个segment时都会对segment加锁，保证线程安全。</li>
</ul> 
<p>二叉搜索树：根节点的值大于其左子树任意节点的值，小于其右子树任意节点的值。这一规则适用于二叉查找树中的每一个节点。且没有键值相等的节点。</p> 
<p>平衡二叉树：每个节点的左右子树的高度差的绝对值最大为1。平衡二叉搜索树，又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p> 
<p>二叉搜索树变成一个平衡二叉树：通过左右旋转来实现。</p> 
<h5>
<a id="20_297"></a>20、常用八大排序算法的时间复杂度？堆排序的时间复杂度是多少？建堆的时间复杂度？堆调整的时间复杂度？哪些排序是稳定的，哪些排序是不稳定的？如果一个数组是基本有序的，那我们要用什么排序会比较好？假设我们要对某个公司所有员工的年龄进行排序，这个时候用什么排序算法比较好？</h5> 
<p><a href="https://mp.weixin.qq.com/s/C5Nyk4MYuUGncQqsgPHEew">【一篇文章搞定排序】</a></p> 
<h5>
<a id="21_301"></a>21、怎么判断两个链表是否相交？怎么优化？</h5> 
<p>力扣<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> headA<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> headB<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> lenA <span class="token operator">=</span> <span class="token function">getLength</span><span class="token punctuation">(</span>headA<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> lenB <span class="token operator">=</span> <span class="token function">getLength</span><span class="token punctuation">(</span>headB<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ListNode</span> a <span class="token operator">=</span> headA<span class="token punctuation">,</span> b <span class="token operator">=</span> headB<span class="token punctuation">;</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> lenA <span class="token operator">-</span> lenB<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span>
            a <span class="token operator">=</span> a<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            b <span class="token operator">=</span> b<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getLength</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            len<span class="token operator">++</span><span class="token punctuation">;</span>
            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">ListNode</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="22TCP__UDP__353"></a>22、TCP 和 UDP 的区别是什么？</h5> 
<p>【网络八股文3】</p> 
<table>
<thead><tr>
<th align="left">TCP/IP</th>
<th align="left">UDP</th>
</tr></thead>
<tbody>
<tr>
<td align="left">面向连接的协议</td>
<td align="left">无连接协议</td>
</tr>
<tr>
<td align="left">更可靠</td>
<td align="left">不太可靠</td>
</tr>
<tr>
<td align="left">传输速度较慢</td>
<td align="left">更快的传输</td>
</tr>
<tr>
<td align="left">数据包顺序可以保留或重新排列</td>
<td align="left">数据包顺序不固定，数据包相互独立</td>
</tr>
<tr>
<td align="left">使用三种方式握手模型进行连接</td>
<td align="left">无需握手即可建立连接</td>
</tr>
<tr>
<td align="left">TCP 数据包是重量级的</td>
<td align="left">UDP数据包是轻量级的</td>
</tr>
<tr>
<td align="left">提供错误检查机制</td>
<td align="left">没有错误检查机制</td>
</tr>
<tr>
<td align="left">HTTP、FTP、Telnet、SMTP、HTTPS 等协议在传输层使用 TCP</td>
<td align="left">DNS、RIP、SNMP、RTP、BOOTP、TFTP、NIP 等协议在传输层使用 UDP</td>
</tr>
</tbody>
</table>
<h5>
<a id="23HTTPHTTPS_368"></a>23、HTTP和HTTPS有什么区别？</h5> 
<p>HTTP 是超文本传输协议，它定义了有关如何在万维网 (WWW) 上传输信息的规则和标准。它有助于网络浏览器和网络服务器进行通信。这是一个“无状态协议”，其中每个命令相对于前一个命令是独立的。HTTP 是建立在 TCP 之上的应用层协议。它默认使用端口 80。</p> 
<p>HTTPS 是超文本传输协议安全或安全 HTTP。它是 HTTP 的高级和安全版本。在 HTTP 之上，SSL/TLS 协议用于提供安全性。它通过加密通信来实现安全交易，还有助于安全地识别网络服务器。它默认使用端口 443。</p> 
<h5>
<a id="24_376"></a>24、子网掩码有什么用？</h5> 
<p>子网是通过称为子网划分的过程实现的网络内部的网络，该过程有助于将网络划分为子网。用于获得更高的路由效率，增强网络的安全性。它减少了从路由表中提取主机地址的时间。</p> 
<p>子网掩码(subnet mask)用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</p> 
<h5>
<a id="25_382"></a>25、进程和线程的区别？进程间通信的方式？</h5> 
<p><strong>进程</strong>：资源分配的基本单位。进程基本上是一个当前正在执行的程序。操作系统的主要功能是管理和处理所有这些进程。当一个程序被加载到内存中并成为一个进程时，它可以分为四个部分——堆栈、堆、文本和数据。</p> 
<p><strong>线程</strong>：独立调度的基本单位。线程是由程序计数器、线程 ID、堆栈和进程内的一组寄存器组成的执行路径。它是 CPU 利用率的基本单位，它使通信更加有效和高效，使多处理器体系结构的利用率能够达到更大的规模和更高的效率，并减少上下文切换所需的时间。它只是提供了一种通过并行性来改进和提高应用程序性能的方法。线程有时被称为<strong>轻量级进程</strong>，因为它们有自己的堆栈但可以访问共享数据。</p> 
<p>在一个进程中运行的多个线程共享进程的地址空间、堆、静态数据、代码段、文件描述符、全局变量、子进程、待定警报、信号和信号处理程序。</p> 
<p>每个线程都有自己的程序计数器、寄存器、堆栈和状态。</p> 
<table>
<thead><tr>
<th align="left">进程</th>
<th align="left">线程</th>
</tr></thead>
<tbody>
<tr>
<td align="left">它是一个正在执行的计算机程序。</td>
<td align="left">它是进程的组件或实体，是最小的执行单元。</td>
</tr>
<tr>
<td align="left">重量级。</td>
<td align="left">轻量级。</td>
</tr>
<tr>
<td align="left">它有自己的内存空间。</td>
<td align="left">它使用它们所属进程的内存。</td>
</tr>
<tr>
<td align="left">与创建线程相比，创建进程更难。</td>
<td align="left">与创建进程相比，创建线程更容易。</td>
</tr>
<tr>
<td align="left">与线程相比，它需要更多资源。</td>
<td align="left">与流程相比，它需要更少的资源。</td>
</tr>
<tr>
<td align="left">与线程相比，创建和终止进程需要更多时间。</td>
<td align="left">与进程相比，创建和终止线程所需的时间更少。</td>
</tr>
<tr>
<td align="left">它通常运行在单独的内存空间中。</td>
<td align="left">它通常运行在共享内存空间中。</td>
</tr>
<tr>
<td align="left">它不共享数据。</td>
<td align="left">它彼此共享数据。</td>
</tr>
<tr>
<td align="left">它可以分为多个线程。</td>
<td align="left">不能再细分了。</td>
</tr>
</tbody>
</table>
<p><strong>IPC（进程间通信）</strong> 是一种需要使用共享资源（如在进程或线程之间共享的内存）的机制。通过 IPC，操作系统允许不同的进程相互通信。它仅用于在一个或多个程序或进程中的多个线程之间交换数据。在这种机制中，不同的进程可以在操作系统的批准下相互通信。</p> 
<p>不同的 IPC 机制：</p> 
<ul>
<li>管道</li>
<li>消息队列</li>
<li>信号量</li>
<li>套接字</li>
<li>共享内存</li>
<li>信号</li>
</ul> 
<h5>
<a id="26_415"></a>26、什么是死锁，死锁产生的必要条件有哪些？</h5> 
<p>死锁通常是一组进程被阻塞的情况，因为每个进程都持有资源并等待获取另一个进程持有的资源。在这种情况下，两个或多个进程只是尝试同时执行并等待每个进程完成它们的执行，因为它们相互依赖。</p> 
<p><strong>死锁的必要条件</strong></p> 
<p>死锁的必要条件基本上有以下四个：</p> 
<ul>
<li>互斥</li>
<li>请求并保持</li>
<li>不可抢占</li>
<li>循环等待或资源等待</li>
</ul> 
<h5>
<a id="27_428"></a>27、数据库的事务？事务的特性？分别指的是什么含义？</h5> 
<p>定义：事务是逻辑上的一组数据库操作，要么都执行，要么都不执行。</p> 
<p>特性：</p> 
<ul>
<li> <p>原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；例如转账的这两个关键操作（将张三的余额减少200元，将李四的余额增加200元）要么全部完成，要么全部失败。</p> </li>
<li> <p>一致性： 确保从一个正确的状态转换到另外一个正确的状态，这就是一致性。例如转账业务中，将张三的余额减少200元，中间发生断电情况，李四的余额没有增加200元，这个就是不正确的状态，违反一致性。又比如表更新事务，一部分数据更新了，但一部分数据没有更新，这也是违反一致性的；</p> </li>
<li> <p>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p> </li>
<li> <p>持久性：一个事务被提交之后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p> </li>
</ul> 
<h5>
<a id="28MySQLBB_442"></a>28、数据库的索引，比如MySQL的索引有了解么？B树和B+树有什么区别？聚簇索引和稀疏索引的区别？</h5> 
<p>B树和B+树：</p> 
<ul>
<li>B Tree(平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。)</li>
<li>B+ Tree (是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能，顺序读取不需要进行磁盘寻道。B+ 树访问磁盘数据有更高的性能，数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。B+树1-3层，双向链表，建议使用自增主键)</li>
</ul> 
<p>聚簇索引和非聚集索引：</p> 
<ul>
<li>聚集索引的顺序就是数据的物理存储顺序。它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引。</li>
<li>非聚集索引： 索引顺序与物理存储顺序不同。非聚集索引的使用场合为： 查询所获数据量较少时； 某字段中的数据的唯一性比较高时。</li>
<li>例：比如字典中，用‘拼音’查汉字，就是聚集索引。因为正文中字都是按照拼音排序的。而用‘偏旁部首’查汉字，就是非聚集索引，因为正文中的字并不是按照偏旁部首排序的，我们通过检字表得到正文中的字在索引中的映射，然后通过映射找到所需要的字。</li>
</ul> 
<p>稠密索引和稀疏索引：</p> 
<ul>
<li>稠密索引：每个索引键值都对应有一个索引项。稠密索引能够比稀疏索引更快的定位一条记录。但是，稀疏索引相比于稠密索引的优点是：它所占空间更小，且插入和删除时的维护开销也小。</li>
<li>稀疏索引：相对于稠密索引，稀疏索引只为某些搜索码值建立索引记录；在搜索时，找到其最大的搜索码值小于或等于所查找记录的搜索码值的索引项，然后从该记录开始向后顺序查询直到找到为止。</li>
</ul> 
<h5>
<a id="29MySQLInnoDBMyISAM_462"></a>29、MySQL的两个引擎InnoDB和MyISAM的区别是什么？</h5> 
<p>MyISAM：</p> 
<ul>
<li>用途：访问的<strong>速度快</strong>，以 SELECT、INSERT 为主的应用</li>
<li>索引：B tree，FullText，R-tree</li>
<li>锁：表锁</li>
<li>事务：不支持事务</li>
<li>其他：不支持外键。每个 MyISAM 在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义。数据文件的扩展名为 .MYD (MYData)。索引文件的扩展名是 .MYI (MYIndex)。</li>
</ul> 
<p>InnoDB：</p> 
<ul>
<li>用途：大部分情况下选择 InnoDB，除非需要用到某些 InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择 InnoDB 引擎。</li>
<li>索引：B+ tree，hash(引擎自适应，无法人为干预)，FullText(5.6开始)</li>
<li>锁：行锁</li>
<li>事务：支持</li>
<li>其他：对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。InnoDB 所有的表都保存在同一个数据文件中，InnoDB 表的大小只受限于操作系统文件的大小限制。MyISAM 只缓存索引，不缓存真实数据；InnoDB 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</li>
</ul> 
<h5>
<a id="30memchache__redis__480"></a>30、memchache 和 redis 有了解过吗？</h5> 
<p>Redis 与 Memchache 都是分布式缓存系统。</p> 
<ul>
<li> <p>数据存储介质： Memchache缓存的数据都是存放在内存中，一旦内存失效，数据就丢失，无法恢复；Redis缓存的数据存放在内存和硬盘中，能够达到持久化存储，Redis能够利用快照和AOF把数据存放到硬盘中，当内存失效，也可以从磁盘中抽取出来，调入内存中，当物理内存使用完毕后，也可以自动的持久化的磁盘中。</p> </li>
<li> <p>数据存储方式：Redis与Memchache都是以键值对的方式存储，而Redis对于值 使用比较丰富，支持Set，Hash，List，Zet（有序集合）等数据结构的存储，Memchache只支持字符串，不过Memchache也可以缓存图片、视频等非结构化数据。</p> </li>
<li> <p>从架构层次：Redis支持Master-Slave（主从）模式的应用，应用在单核上， Memchache支持分布式，应用在多核上</p> </li>
<li> <p>存储数据大小：对于Redis单个Value存储的数据最大为1G，而Memchache存储的最大为1MB，而存储的Value数据值大于100K时，性能会更好</p> </li>
<li> <p>Redis只支持单核，而Memchache支持多核。</p> </li>
</ul> 
<h5>
<a id="31_Hash__495"></a>31、一致性 Hash 有了解过吗？</h5> 
<p>简单 Hash 的缺点：当机器数量发生变动的时候，几乎所有的数据都会移动。</p> 
<p>需求：当增加或者删除节点时，对于大多数记录，保证原来分配到的某个节点，现在仍然应该分配到那个节点，将数据迁移量的降到最低。</p> 
<p>一致性 Hash：</p> 
<ul>
<li>将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数 H 的值空间为 0-2^32-1（即哈希值是一个 32 位无符号整形），整个哈希环如下，从 0 ~ 2^32-1 代表的分别是一个个的节点，这个环也叫哈希环。</li>
<li>将我们的节点进行一次哈希，按照一定的规则，比如按照 ip 地址的哈希值，让节点落在哈希环上。</li>
<li>通过数据 key 的哈希值落在哈希环上的节点，如果命中了机器节点就落在这个机器上，否则落在顺时针直到碰到第一个机器。</li>
<li>当节点宕机时，数据记录会被定位到下一个节点上，当新增节点的时候 ，相关区间内的数据记录就需要重新哈希。</li>
</ul> 
<p>问题：一致性 Hash 算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题。比如只有 2 台机器，这 2 台机器离的很近，那么顺时针第一个机器节点上将存在大量的数据，第二个机器节点上数据会很少。</p> 
<p>虚拟节点解决数据倾斜问题：</p> 
<ul>
<li>为了避免出现数据倾斜问题，一致性 Hash 算法引入了虚拟节点的机制，也就是每个机器节点会进行多次哈希，最终每个机器节点在哈希环上会有多个虚拟节点存在，使用这种方式来大大削弱甚至避免数据倾斜问题。</li>
<li>数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。</li>
</ul> 
<h5>
<a id="32linux_515"></a>32、linux常用的命令，我们要看操作系统中有哪些进程，用什么命令？如果看端口被哪些程序占用了，用什么看？</h5> 
<p>常用命令：</p> 
<table>
<thead><tr>
<th>命令</th>
<th>命令解释</th>
</tr></thead>
<tbody>
<tr>
<td>top</td>
<td>查看内存</td>
</tr>
<tr>
<td>df -h</td>
<td>查看磁盘存储情况</td>
</tr>
<tr>
<td>iotop</td>
<td>查看磁盘IO读写(yum install iotop安装）</td>
</tr>
<tr>
<td>iotop -o</td>
<td>直接查看比较高的磁盘读写程序</td>
</tr>
<tr>
<td>netstat -tunlp | grep 端口号</td>
<td>查看端口占用情况</td>
</tr>
<tr>
<td>uptime</td>
<td>查看报告系统运行时长及平均负载</td>
</tr>
<tr>
<td>ps -ef</td>
<td>查看进程</td>
</tr>
</tbody>
</table>
<h5>
<a id="33_vim__529"></a>33、常用的 vim 命令，如何跳到第一行？怎么跳到最后一行？如何删除一行？</h5> 
<p>在正常模式下输入<code>ngg</code> 或者 <code>nG</code>，<code>n</code>为指定的行数；如输入 <code>100gg</code> 或者 <code>100G</code> 跳转到第100行。</p> 
<p>输入 <code>gg</code> 跳转到当前文件的第一行。</p> 
<p>输入 <code>G</code> 跳转光标到当前文件的最后一行。</p> 
<p>输入 <code>dd</code> 删除光标所在行</p> 
<h5>
<a id="34sed__awk__539"></a>34、sed 和 awk 用过么，用这两个实现把一个文件中的空行进行删除。</h5> 
<h5>
<a id="35_541"></a>35、正则表达式中的贪婪匹配和非贪婪匹配了解吗？这个具体写的时候怎么写了解么？</h5> 
<p>如：</p> 
<pre><code>String str="abcaxc";
Patter p="ab*c";
</code></pre> 
<p><strong>贪婪匹配:</strong> 正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：<strong>abcaxc</strong>(ab*c)。</p> 
<p><strong>非贪婪匹配</strong>：就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：<strong>abc</strong>(ab*c)。</p> 
<p>默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。</p> 
<pre><code class="prism language-java"><span class="token class-name">String</span> rule1<span class="token operator">=</span><span class="token string">"content:".+""</span><span class="token punctuation">;</span>    <span class="token comment">//贪婪模式</span>
<span class="token class-name">String</span> rule2<span class="token operator">=</span><span class="token string">"content:".+?""</span><span class="token punctuation">;</span>    <span class="token comment">//非贪婪模式</span>
</code></pre> 
<h5>
<a id="36git_resetrebase_561"></a>36、常用的版本控制软件，git reset和rebase的区别是什么？</h5>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>