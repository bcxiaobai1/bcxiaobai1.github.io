<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>React面试题最全 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React面试题最全</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h2>1.什么是虚拟DOM？</h2> 
<p>虚拟DOM是真实DOM在内存中的表示，ul的表示形式保存在内存中，并且与实际的DOM同步，这是一个发生在渲染函数被调用和元素在屏幕上显示的步骤，整个过程被称为调和</p> 
<h2>2.类组件和函数组件之间的区别是什么？</h2> 
<p>类组件可以使用其他特性，如状态和生命周期钩子，并且他有this</p> 
<p>函数组件只能接收props渲染到页面，无状态组件，没有this，不能使用生命周期钩子</p> 
<p>函数组件性能要高于类组件，因为类组件使用要实例化，而函数组件直接执行取返回结果即可，为了提高性能，尽量使用函数组件</p> 
<h2>3.react中refs是什么？</h2> 
<p>refs是提供一种访问在render方法中创建DOM节点或者React元素的方法，在典型的数据流中，props是父子组件交互的唯一方式，想要修改子组件，需要使用新的props重新渲染它，某些情况下，在典型的数据流外，强制修改子代，这个时候可以使用refs</p> 
<p>我们可以在组件添加一个ref属性来使用，该属性是一个回调函数，接收作为其第一个参数的底层DOM元素或组件挂载实例</p> 
<p>input元素有一个ref属性，他的值是一个函数，该函数接收输入的实际DOM元素，然后将其放在实例上，这样就可以在 <code>handleSubmit</code> 函数内部访问它</p> 
<p><span style="color:#fe2c24">经常被误解的只有在类组件中才能使用 <code>refs</code>，但是<code>refs</code>也可以通过利用 JS 中的闭包与函数组件一起使用</span></p> 
<h2>4.在react中如何处理事件？</h2> 
<p>为了解决跨浏览器的兼容性问题，<code>SyntheticEvent</code> 实例将被传递给你的事件处理函数，<code>SyntheticEvent</code>是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code>。</p> 
<p>比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。</p> 
<h2>5.state和props区别是什么？</h2> 
<p>相同点：都是普通的js对象，他们包含着影响渲染输出的信息</p> 
<p>不同点：state是组件自己管理数据，控制自己的状态，可变</p> 
<p>props是外部传入的数据参数，不可变</p> 
<p>没有state的叫做无状态组件，有state的叫有状态组件</p> 
<p>多用props，少用state</p> 
<h2>6.如何创建refs？</h2> 
<p>通过React.createRef（）创建的，并通过ref属性附加到react元素，在构造组件中，</p> 
<p>通常将 <code>Refs</code> 分配给实例属性，以便可以在整个组件中引用它们。</p> 
<h2>7.什么是高阶组件？</h2> 
<p><strong>高阶组件(HOC)</strong>是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为<strong>纯组件</strong>，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为</p> 
<p>HOC 可以用于以下许多用例</p> 
<ul>
<li>代码重用、逻辑和引导抽象</li>
<li>渲染劫持</li>
<li>state 抽象和操作</li>
<li>props 处理</li>
</ul> 
<h2>8.在构造函数调用super并将props作为参数传入的作用是啥？</h2> 
<p> 在调用 <code>super()</code> 方法之前，子类构造函数无法使用<code>this</code>引用，ES6 子类也是如此。将 <code>props</code> 参数传递给 <code>super()</code> 调用的主要原因是在子构造函数中能够通过<code>this.props</code>来获取传入的 <code>props</code>。</p> 
<p><code>props</code> 的行为只有在构造函数中是不同的，在构造函数之外也是一样的</p> 
<h2>9.什么是受控组件？</h2> 
<p>在 HTML 中，表单元素如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。</p> 
<p>而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如<code>onChange</code>)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为受控组件。</p> 
<h2>10.<strong>如何 React.createElement ？</strong>
</h2> 
<pre><code>const element = (

  &lt;h1 className="greeting"&gt;

    Hello, world!

  &lt;/h1&gt;

)</code></pre> 
<pre><code>const element = React.createElement(

  'h1',

  {className: 'greeting'},

  'Hello, world!'

);</code></pre> 
<h2>11.什么是jsx？</h2> 
<p>在第一发布react时，还引入了一种新的js方言jsx，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用<code>Babel</code>和<code>webpack</code>等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一起了</p> 
<h2>12.为什么不直接更新state？</h2> 
<p>如果试图直接更新state，就不会重新渲染组件</p> 
<p>需要使用setState（）方法更新state，它对state对象进行更新，当state改变时，组件通过重新渲染来响应</p> 
<h2>13.<strong>React 组件生命周期有哪些不同阶段？</strong>
</h2> 
<ol>
<li>
<strong>Initialization</strong>：在这个阶段，组件准备设置初始化状态和默认属性。</li>
<li>
<strong>Mounting</strong>：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括<code>componentWillMount</code>和<code>componentDidMount</code>生命周期方法。</li>
<li>
<strong>Updating</strong>：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>和<code>componentDidUpdate</code>生命周期方法。</li>
<li>
<strong>Unmounting</strong>：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 <code>componentWillUnmount</code> 生命周期方法。</li>
</ol> 
<p>除以上四个常用生命周期外，还有一个错误处理的阶段：</p> 
<p><strong>Error Handling</strong>：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 <code>componentDidCatch</code> 生命周期方法。</p> 
<h2>14.react生命周期方法有哪些？</h2> 
<ul>
<li>
<code>componentWillMount</code>:在渲染之前执行，用于根组件中的 App 级配置。</li>
<li>
<code>componentDidMount</code>：在第一次渲染之后执行，可以在这里做AJAX请求，DOM 的操作或状态更新以及设置事件监听器。</li>
<li>
<code>componentWillReceiveProps</code>：在初始化<code>render</code>的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染</li>
<li>
<code>shouldComponentUpdate</code>：确定是否更新组件。默认情况下，它返回<code>true</code>。如果确定在 <code>state</code> 或 <code>props</code> 更新后组件不需要在重新渲染，则可以返回<code>false</code>，这是一个提高性能的方法。</li>
<li>
<code>componentWillUpdate</code>：在<code>shouldComponentUpdate</code>返回 <code>true</code> 确定要更新组件之前件之前执行。</li>
<li>
<code>componentDidUpdate</code>：它主要用于更新DOM以响应<code>props</code>或<code>state</code>更改。</li>
<li>
<code>componentWillUnmount</code>：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。</li>
</ul> 
<h2>15.<strong>这三个点(...)在 React 干嘛用的？</strong>
</h2> 
<p> 扩展运算符或者叫展开操作符，对于创建具有现有对象的大多数属性的新对象非常方便，在更新state时经常这么用</p> 
<h2>16.<strong>使用 React Hooks 好处是啥？</strong>
</h2> 
<p><strong>Hooks</strong>是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用<code>state</code>和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易</p> 
<p>hooks解决了什么问题？</p> 
<p>        函数组件中可以使用类组件中的特性问题</p> 
<h2><strong>17：React 中的 <code>useState()</code> 是什么？</strong></h2> 
<p><code>useState</code> 是一个内置的 React Hook。<code>useState(0)</code> 返回一个元组，其中第一个参数<code>count</code>是计数器的当前状态，<code>setCounter</code> 提供更新计数器状态的方法。</p> 
<p>咱们可以在任何地方使用<code>setCounter</code>方法更新计数状态-在这种情况下，咱们在<code>setCount</code>函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件</p> 
<p>定义state的数据，参数是初始化的数据，返回值两个值1. 初始化值，2. 修改的方法</p> 
<p>useState中修改的方法异步</p> 
<ol>
<li> <p>借助于useEffect 进行数据的监听</p> </li>
<li> <p>可以自己定义Hooks的方法, 方法内部可以把逻辑返回</p> </li>
</ol> 
<h2>18.<strong>React 中的StrictMode(严格模式)是什么？</strong>
</h2> 
<p>React 的<code>StrictMode</code>是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用<code>&lt;StrictMode /&gt;</code>包装一组组件，并且可以帮咱们以下检查：</p> 
<ul>
<li>验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。</li>
<li>验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。</li>
<li>通过识别潜在的风险预防一些副作用。</li>
</ul> 
<h2>19.<strong>为什么类方法需要绑定到类实例？</strong>
</h2> 
<p>在js中，this值会根据当前上下文的变化，在React类组件方法中，开发人员通常希望this引用罪案的当前实例，因此有必要将这些方法绑定到实例</p> 
<h2>20.什么是prop drilling，如何避免？</h2> 
<p>在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 <code>prop</code> 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做<strong>prop drilling</strong>。</p> 
<p><code>prop drilling</code>的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。</p> 
<p>为了避免<code>prop drilling</code>，一种常用的方法是使用<strong>React Context</strong>。通过定义提供数据的<code>Provider</code>组件，并允许嵌套的组件通过<code>Consumer</code>组件或<code>useContext</code> Hook 使用上下文数据</p> 
<h2>21.<strong>描述 Flux 与 MVC？</strong>
</h2> 
<p>传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</p> 
<p><strong>数据流不够清晰</strong>:跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</p> 
<p><strong>缺乏数据完整性</strong>:模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。</p> 
<p>使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 <code>store</code> 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性</p> 
<h2>22.<strong>受控组件和非受控组件区别是啥？</strong>
</h2> 
<ul>
<li>
<strong>受控组件</strong>是 React 控制中的组件，并且是表单数据真实的唯一来源。</li>
<li>非受控组件是由 DOM 处理表单数据的地方，而不是在 React 组件中。</li>
</ul> 
<p>尽管非受控组件通常更易于实现，因为只需使用<code>refs</code>即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。</p> 
<p>这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式</p> 
<h2>23. <strong>什么是 React Context?</strong>
</h2> 
<p><code>Context</code> 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 <code>props</code> 属性</p> 
<h2>24.<strong>什么是 React Fiber?</strong>
</h2> 
<p><strong>Fiber</strong> 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。<strong>React Fiber</strong> 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。</p> 
<p>React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。</p> 
<h2>25.<strong>如何在 ReactJS 的 Props上应用验证？</strong>
</h2> 
<p>当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 <code>props</code>，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 <code>props</code> 用 <code>isRequired</code>定义的。</p> 
<p>下面是一组预定义的 prop 类型:</p> 
<ul>
<li>React.PropTypes.string</li>
<li>React.PropTypes.number</li>
<li>React.PropTypes.func</li>
<li>React.PropTypes.node</li>
<li>React.PropTypes.bool</li>
</ul> 
<h2>26.<strong>在 React 中使用构造函数和 getInitialState 有什么区别？</strong>
</h2> 
<p>构造函数和<code>getInitialState</code>之间的区别就是<code>ES6</code>和<code>ES5</code>本身的区别。在使用<code>ES6</code>类时，应该在构造函数中初始化<code>state</code>，并在使用<code>React.createClass</code>时定义<code>getInitialState</code>方法。</p> 
<h2>27.<strong>Hooks会取代 <code>render props</code> 和高阶组件吗？</strong>
</h2> 
<p><code>render props</code>和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。</p> 
<p>这两种模式仍然有一席之地(例如，一个虚拟的 <code>scroller</code> 组件可能有一个 <code>renderItem prop</code>，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套</p> 
<h2>28.<strong>如何避免组件的重新渲染？</strong>
</h2> 
<p>React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：</p> 
<ul>
<li>
<code>React.memo()</code>:这可以防止不必要地重新渲染函数组件</li>
<li>
<code>PureComponent</code>:这可以防止不必要地重新渲染类组件</li>
</ul> 
<p>这两种方法都依赖于对传递给组件的<code>props</code>的浅比较，如果 <code>props</code> 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</p> 
<p>通过使用 <strong>React Profiler</strong>，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。</p> 
<h2>29.<strong>什么是纯函数？</strong>
</h2> 
<p>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</p> 
<h2>30.<strong>当调用<code>setState</code>时，React <code>render</code> 是如何工作的</strong>
</h2> 
<ol>
<li>虚拟 DOM 渲染:当<code>render</code>方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用<code>setState()</code>时，<code>render</code>会被再次调用，因为默认情况下<code>shouldComponentUpdate</code>总是返回<code>true</code>，所以默认情况下 React 是没有优化的。</li>
<li>原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。</li>
</ol> 
<h2>31.<strong>如何避免在React重新绑定实例</strong>？</h2> 
<p>1.将事件处理程序定义为内联箭头函数</p> 
<pre><code>class SubmitButton extends React.Component {

  constructor(props) {

    super(props);

    this.state = {

      isFormSubmitted: false

    };

  }

 

  render() {

    return (

      &lt;button onClick={() =&gt; {

        this.setState({ isFormSubmitted: true });

      }}&gt;Submit&lt;/button&gt;

    )

  }

}</code></pre> 
<p>2.使用箭头函数来定义方法：</p> 
<pre><code>class SubmitButton extends React.Component {

  state = {

    isFormSubmitted: false

  }

 

  handleSubmit = () =&gt; {

    this.setState({

      isFormSubmitted: true

    });

  }

 

  render() {

    return (

      &lt;button onClick={this.handleSubmit}&gt;Submit&lt;/button&gt;

    )

  }

}</code></pre> 
<p>3.使用带有 Hooks 的函数组件</p> 
<pre><code>const SubmitButton = () =&gt; {

  const [isFormSubmitted, setIsFormSubmitted] = useState(false);

 

  return (

    &lt;button onClick={() =&gt; {

        setIsFormSubmitted(true);

    }}&gt;Submit&lt;/button&gt;

  )

};</code></pre> 
<h2>32.<strong>区分Real DOM和Virtual DOM</strong>？</h2> 
<table>
<thead><tr>
<th><strong>Real DOM</strong></th>
<th><strong>Virtual DOM</strong></th>
</tr></thead>
<tbody>
<tr>
<td>1. 更新缓慢。</td>
<td>1. 更新更快。</td>
</tr>
<tr>
<td>2. 可以直接更新 HTML。</td>
<td>2. 无法直接更新 HTML。</td>
</tr>
<tr>
<td>3. 如果元素更新，则创建新DOM。</td>
<td>3. 如果元素更新，则更新 JSX 。</td>
</tr>
<tr>
<td>4. DOM操作代价很高。</td>
<td>4. DOM 操作非常简单。</td>
</tr>
<tr>
<td>5. 消耗的内存较多。</td>
<td>5. 很少的内存消耗。</td>
</tr>
</tbody>
</table> 
<h2> 33.<strong> 什么是React？</strong>
</h2> 
<ul>
<li>React 是 Facebook 在 2011 年开发的前端 JavaScript 库。</li>
<li>它遵循基于组件的方法，有助于构建可重用的UI组件。</li>
<li>它用于开发复杂和交互式的 Web 和移动 UI。</li>
<li>尽管它仅在 2015 年开源，但有一个很大的支持社区</li>
</ul> 
<h2>34.<strong>React有什么特点</strong>
</h2> 
<p>React的主要功能如下：</p> 
<ol>
<li>它使用<strong>虚拟DOM </strong>而不是真正的DOM。</li>
<li>它可以进行<strong>服务器端渲染</strong>。</li>
<li>它遵循<strong>单向数据流</strong>或数据绑定。</li>
</ol> 
<h2>35.<strong> 列出React的一些主要优点</strong>
</h2> 
<ol>
<li>它提高了应用的性能</li>
<li>可以方便地在客户端和服务器端使用</li>
<li>由于 JSX，代码的可读性很好</li>
<li>React 很容易与 Meteor，Angular 等其他框架集成</li>
<li>使用React，编写UI测试用例变得非常容易</li>
</ol> 
<h2>36. <strong>React有哪些限制？</strong>
</h2> 
<ol>
<li>React 只是一个库，而不是一个完整的框架</li>
<li>它的库非常庞大，需要时间来理解</li>
<li>新手程序员可能很难理解</li>
<li>编码变得复杂，因为它使用内联模板和 JSX</li>
</ol> 
<h2>37. <strong>为什么浏览器无法读取JSX？</strong>
</h2> 
<p> 浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器</p> 
<h2>38.<strong>与 ES5 相比，React 的 ES6 语法有何不同？</strong>
</h2> 
<p>1.require 与 import</p> 
<p>2.export 与 exports</p> 
<p>3.component 和 function</p> 
<p>4.props</p> 
<p>5.state</p> 
<h2>39.<strong> React与Angular有何不同？</strong>
</h2> 
<table>
<thead><tr>
<th><strong>主题</strong></th>
<th><strong>React</strong></th>
<th><strong>Angular</strong></th>
</tr></thead>
<tbody>
<tr>
<td><em>1. 体系结构</em></td>
<td>只有 MVC 中的 View</td>
<td>完整的 MVC</td>
</tr>
<tr>
<td><em>2. 渲染</em></td>
<td>可以进行服务器端渲染</td>
<td>客户端渲染</td>
</tr>
<tr>
<td><em>3. DOM</em></td>
<td>使用 virtual DOM</td>
<td>使用 real DOM</td>
</tr>
<tr>
<td><em>4. 数据绑定</em></td>
<td>单向数据绑定</td>
<td>双向数据绑定</td>
</tr>
<tr>
<td><em>5. 调试</em></td>
<td>编译时调试</td>
<td>运行时调试</td>
</tr>
<tr>
<td><em>6. 作者</em></td>
<td>Facebook</td>
<td>Google</td>
</tr>
</tbody>
</table> 
<h2>40. <strong>你怎样理解“在React中，一切都是组件”这句话</strong>
</h2> 
<p>组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。</p> 
<h2>41.<strong>怎样解释 React 中 render() 的目的</strong>
</h2> 
<p>每个React组件强制要求必须有一个 <strong>render()</strong>。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 <code>&lt;form&gt;</code>、<code>&lt;group&gt;</code>、<code>&lt;p&gt;</code> 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果</p> 
<h2>42.<strong>什么是 Props?</strong>
</h2> 
<p>Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据</p> 
<h2>43.<strong> React中的状态是什么？它是如何使用的？</strong>
</h2> 
<p>状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 <code>this.state()</code> 访问它们</p> 
<h2>44.<strong>区分状态和 props</strong>
</h2> 
<table>
<thead><tr>
<th><strong>条件</strong></th>
<th><strong>State</strong></th>
<th><strong>Props</strong></th>
</tr></thead>
<tbody>
<tr>
<td>1. 从父组件中接收初始值</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>2. 父组件可以改变值</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>3. 在组件中设置默认值</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>4. 在组件的内部变化</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>5. 设置子组件的初始值</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>6. 在子组件的内部更改</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table> 
<h2>45. <strong>如何更新组件的状态？</strong>
</h2> 
<p> 可以用 <code>this.setState()</code>更新组件的状态。</p> 
<h2>46.<strong> React 中的箭头函数是什么？怎么用？</strong>
</h2> 
<p> 箭头函数（<strong>=&gt;</strong>）是用于编写函数表达式的简短语法。这些函数允许正确绑定组件的上下文，因为在 ES6 中默认下不能使用自动绑定。使用高阶函数时，箭头函数非常有用</p> 
<h2>47.<strong> 区分有状态和无状态组件</strong>
</h2> 
<table>
<thead><tr>
<th><strong>有状态组件</strong></th>
<th><strong>无状态组件</strong></th>
</tr></thead>
<tbody>
<tr>
<td>1. 在内存中存储有关组件状态变化的信息</td>
<td>1. 计算组件的内部的状态</td>
</tr>
<tr>
<td>2. 有权改变状态</td>
<td>2. 无权改变状态</td>
</tr>
<tr>
<td>3. 包含过去、现在和未来可能的状态变化情况</td>
<td>3. 不包含过去，现在和未来可能发生的状态变化情况</td>
</tr>
<tr>
<td>4. 接受无状态组件状态变化要求的通知，然后将 props 发送给他们。</td>
<td>4.从有状态组件接收 props 并将其视为回调函数。</td>
</tr>
</tbody>
</table> 
<h2> 48.<strong> React中的事件是什么？</strong>
</h2> 
<p>在 React 中，事件是对鼠标悬停、鼠标单击、按键等特定操作的触发反应。处理这些事件类似于处理 DOM 元素中的事件。但是有一些语法差异，如：</p> 
<ol>
<li>用驼峰命名法对事件命名而不是仅使用小写字母。</li>
<li>事件作为函数而不是字符串传递。</li>
</ol> 
<p>事件参数重包含一组特定于事件的属性。每个事件类型都包含自己的属性和行为，只能通过其事件处理程序访问</p> 
<h2>49.<strong>React中的合成事件是什么？</strong>
</h2> 
<p>合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。</p> 
<h2>50.<strong>React 中 key 的重要性是什么？</strong>
</h2> 
<p>key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能</p> 
<h2>51.<strong>什么是Redux</strong>?</h2> 
<p>Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为</p> 
<h2> 52.<strong>Redux遵循的三个原则是什么？</strong>
</h2> 
<ol>
<li>
<strong><em>单一事实来源：</em></strong>整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。</li>
<li>
<strong><em>状态是只读的：</em></strong>改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。</li>
<li>
<strong><em>使用纯函数进行更改：</em></strong>为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。</li>
</ol> 
<h2>53. <strong>你对“单一事实来源”有什么理解？</strong>
</h2> 
<p> Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序</p> 
<h2>54.<strong>列出 Redux 的组件</strong>
</h2> 
<ol>
<li>
<strong>Action</strong> – 这是一个用来描述发生了什么事情的对象。</li>
<li>
<strong>Reducer</strong> – 这是一个确定状态将如何变化的地方。</li>
<li>
<strong>Store</strong> – 整个程序的状态/对象树保存在Store中。</li>
<li>
<strong>View</strong> – 只显示 Store 提供的数据。</li>
</ol> 
<h2>55.<strong> 数据如何通过 Redux 流动？</strong>
</h2> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3d/98/cwd62nBN_o.png"></p> 
<h2>56. <strong>如何在 Redux 中定义 Action</strong>
</h2> 
<p>React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建</p> 
<h2>57.<strong>解释 Reducer 的作用</strong>
</h2> 
<p>Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态</p> 
<h2>58.<strong>Store 在 Redux 中的意义是什么</strong>
</h2> 
<p>Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。</p> 
<h2>59.<strong>Redux 有哪些优点？</strong>
</h2> 
<p>Redux 的优点如下：</p> 
<ul>
<li>
<strong>结果的可预测性 -</strong> 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</li>
<li>
<strong>可维护性 -</strong> 代码变得更容易维护，具有可预测的结果和严格的结构。</li>
<li>
<strong>服务器端渲染 -</strong> 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。</li>
<li>
<strong>开发人员工具 -</strong> 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。</li>
<li>
<strong>社区和生态系统 -</strong> Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用。</li>
<li>
<strong>易于测试 -</strong> Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。</li>
<li>
<strong>组织 -</strong> Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单</li>
</ul> 
<h2>60.<strong>什么是React 路由</strong>
</h2> 
<p> React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API</p> 
<h2>61.<strong> 为什么React Router v4中使用 switch 关键字 </strong>
</h2> 
<p> 虽然 <strong><code>&lt;p&gt;</code> </strong>用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路线时，可以使用 “switch” 关键字。使用时，<strong><code>&lt;switch&gt;</code></strong> 标记会按顺序将已定义的 URL 与已定义的路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线</p> 
<h2>62. <strong> 为什么需要 React 中的路由？</strong>
</h2> 
<p>Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个 Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图</p> 
<h2>63.<strong>列出 React Router 的优点。</strong>
</h2> 
<ol>
<li>就像 React 基于组件一样，在 React Router v4 中，API 是 <em>'All About Components'</em>。可以将 Router 可视化为单个根组件（<strong><code>&lt;BrowserRouter&gt;</code></strong>），其中我们将特定的子路由（<strong><code>&lt;route&gt;</code></strong>）包起来。</li>
<li>无需手动设置历史值：在 React Router v4 中，我们要做的就是将路由包装在 <strong><code>&lt;BrowserRouter&gt;</code></strong> 组件中。</li>
<li>包是分开的：共有三个包，分别用于 Web、Native 和 Core。这使我们应用更加紧凑。基于类似的编码风格很容易进行切换</li>
</ol> 
<h2>64.<strong>React Router与常规路由有何不同？</strong>
</h2> 
<table>
<thead><tr>
<th><strong>主题</strong></th>
<th><strong>常规路由</strong></th>
<th><strong>React 路由</strong></th>
</tr></thead>
<tbody>
<tr>
<td><strong>参与的页面</strong></td>
<td>每个视图对应一个新文件</td>
<td>只涉及单个HTML页面</td>
</tr>
<tr>
<td><strong>URL 更改</strong></td>
<td>HTTP 请求被发送到服务器并且接收相应的 HTML 页面</td>
<td>仅更改历史记录属性</td>
</tr>
<tr>
<td><strong>体验</strong></td>
<td>用户实际在每个视图的不同页面切换</td>
<td>用户认为自己正在不同的页面间切换</td>
</tr>
</tbody>
</table> 
<h2>65.常用的hooks</h2> 
<p> useState：定义state的数据，参数是初始化的数据，返回值两个值1. 初始化值，2. 修改的方法</p> 
<p>useEffect：副作用函数，顾名思义，副作用即只有使用过后才会产生副作用</p> 
<ol>
<li> <p>当作生命周期来使用： 第二个参数如果没写的话，页面一更新触发，compoentDidMount compoentDidUpdate</p> </li>
<li> <p>第二个参数如果空数组的话，只执行一次，compoentDidMount</p> </li>
<li> <p>数组中跟某些变量，当作监听器来使用，监听数据的变化，</p> </li>
<li> <p>useEffect是一个副作用函数，组件更新完成后触发的函数</p> </li>
<li> <p>如果我们在useEffect 返回一个函数的，组件被销毁的时候触发</p> </li>
</ol> 
<p>useMemo：用来计算数据，返回一个结果，监听数据的变化，第二个参数就是监听的数据，具有缓存性</p> 
<p>useMemo和useEffect 相比较来说，useMemo 是组件更新的时候触发生命周期</p> 
<p>useMemo是怎么做性能优化的？</p> 
<p>当父组件向子组件组件通信的时候，父组件中数据发生改变，更新父组件导致子组件的更新渲染，但是如果修改的数据跟子组件无关的话，更新子组件会导致子组件不必要的DOM渲染，是比较消耗性能的，这个时候我们可以使用useMemo或者memo做组件的缓存，减少子组件不必要的DOM渲染</p> 
<p>useCallback：当父组件向子组件传递函数的时候，父组件的改变会导致函数的重新调用产生新的作用域，所以还是会导致子组件的更新渲染，这个时候我们可以使用useCallback来缓存组件</p> 
<p>useRef：相当于createRef的使用，创建组件的属性信息</p> 
<p>useContext：相当在函数组件中获取context状态数的内容信息</p> 
<p>useReducer：useReducer是用来弥补useState的补不足， 可以把数据进行集中式的管理，单独处理数据的逻辑信息</p> 
<h2>66.react中ref的使用方式？</h2> 
<p>1.可以直接写一个字符串，不过它只适用于类组件</p> 
<p>2.createRef和useRef来定义ref变量，ref.current获取数据</p> 
<p>3.可以使用箭头函数的方式，提前定义一个变量，箭头函数的形参就是当前对象 </p> 
<pre><code class="hljs">const App = ()=&gt;{
  let h = useRef();

  let inp = null;//定义一个空变量

  const setVal = ()=&gt;{
    console.log(inp.value);
  }
  return (
    &lt;div&gt;
      &lt;h3 ref={h}&gt;ceshi&lt;/h3&gt;
      &lt;button onClick={()=&gt;console.log(h.current)}&gt;获取&lt;/button&gt;

      &lt;hr /&gt;
      &lt;input placeholder="输入内容" ref={(el)=&gt;{ inp = el; }} onChange={setVal}/&gt;
    &lt;/div&gt;
  )
}</code></pre> 
<p>ref属性不能直接绑定到函数子组件的，函数组件没有this对象，无法获取函数子组件的对象内容，最后函数组件forwardRef高阶组件组件，可以把ref属性通过参数的参数传递到函数子组件的内部，对ref属性进行转发的操作</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>