<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>浅析JAVA之垃圾回收机制 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅析JAVA之垃圾回收机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">对于</span><span style="color:#333333">JAVA</span><span style="color:#333333">编程和很多类似</span><span style="color:#333333">C</span><span style="color:#333333">、</span><span style="color:#333333">C++</span><span style="color:#333333">语言有一个巨大区别就是内存不需要自己去</span><span style="color:#333333">free</span><span style="color:#333333">或者</span><span style="color:#333333">delete</span><span style="color:#333333">，而是由</span><span style="color:#333333">JVM</span><span style="color:#333333">垃圾回收机制去完成的。对于这个过程很多人一直比较茫然或者觉得很智能，使得在写程序的过程不太考虑它的感受，其实知道一些内在的原理，帮助我们编写更加优秀的代码是非常有必要的</span><span style="color:#333333">;</span><span style="color:#333333">本文介绍一些</span><span style="color:#333333">JVM</span><span style="color:#333333">垃圾回收的基本知识，后续的文章中会深入探讨</span><span style="color:#333333">JVM</span><span style="color:#333333">的内在；首先在看文章之前大家需要知道为什么要写</span><span style="color:#333333">JVM</span><span style="color:#333333">垃圾回收，在</span><span style="color:#333333">Java</span><span style="color:#333333">发展以来，由于需要面向对象，而屏蔽掉程序员对于底层的关心，所以在性能上存在很多的缺陷，而通过不断改良，很多缺陷已经逐渐的取消掉了，不过还是依然存在很多的问题，其中最大的一块问题就是</span><span style="color:#333333">JVM</span><span style="color:#333333">的垃圾回收机制，一直以来</span><span style="color:#333333">Java</span><span style="color:#333333">在设计实时系统上都被骂声重重，就是因为垃圾回收存在非常多的问题，世界上目前还没有任何一个垃圾回收机制可以做到无暂停，而只是某些系统可以做到非常少的暂停；本文还不会讨论那么深入的只是，就简单的内部认识做一些概要性的介绍。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">本文从以下几个方面进行阐述：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">1</span></strong><strong><span style="color:#333333">、</span></strong><strong><span style="color:#333333">finalize()</span></strong><strong><span style="color:#333333">方法</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">2</span></strong><strong><span style="color:#333333">、</span></strong><strong><span style="color:#333333">System.gc()</span></strong><strong><span style="color:#333333">方法及一些实用方法</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">3</span></strong><strong><span style="color:#333333">、</span></strong><strong><span style="color:#333333">JAVA</span></strong><strong><span style="color:#333333">如何申请内存，和</span></strong><strong><span style="color:#333333">C</span></strong><strong><span style="color:#333333">、</span></strong><strong><span style="color:#333333">C++</span></strong><strong><span style="color:#333333">有何区别</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">4</span></strong><strong><span style="color:#333333">、</span></strong><strong><em><span style="color:#333333">JVM</span></em></strong><strong><em><span style="color:#333333">如何寻找到需要回收的内存</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">5</span></em></strong><strong><em><span style="color:#333333">、</span></em></strong><strong><em><span style="color:#333333">JVM</span></em></strong><strong><em><span style="color:#333333">如何回收内存的（回收算法分解详述）</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">6</span></em></strong><strong><em><span style="color:#333333">、应用服务器部署及常用参数设置</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">7</span></em></strong><strong><em><span style="color:#333333">、扩展话题</span></em></strong><strong><em><span style="color:#333333">JIT</span></em></strong><strong><em><span style="color:#333333">（即时编译技术）与</span></em></strong><strong><em><span style="color:#333333">lazy evaluation</span></em></strong><strong><em><span style="color:#333333">（惰性评估），如何在应用服务器中控制一些必要的信息（小小代码参考）</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">1</span></strong><strong><span style="color:#333333">、</span></strong><strong><span style="color:#333333">finalize()</span></strong><strong><span style="color:#333333">方法：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF">     <span style="color:#333333">为了说明</span><span style="color:#333333">JVM</span><span style="color:#333333">回收，不得不先说明一个问题就是关于</span><span style="color:#333333">finalize()</span><span style="color:#333333">方法，所有实体对象都会有这个方法，因为这个</span><span style="color:#333333">Object</span><span style="color:#333333">类定义的，这个可能会被认为是垃圾回收的方法或者叫做析构函数，其实并非如此。</span><span style="color:#333333">finalize</span><span style="color:#333333">在</span><span style="color:#333333">JVM</span><span style="color:#333333">内存会收前会被调用（单并非绝对），而即使不调用它，</span><span style="color:#333333">JVM</span><span style="color:#333333">回收机制通过后面所述的一些算法就可以定位哪些是垃圾内存，那么这个拿来干什么用呢？</span><span style="color:#333333">finalize()</span><span style="color:#333333">其实是要做一些特殊的内存回收操作，如果对</span><span style="color:#333333">JAVA</span><span style="color:#333333">研究稍微多一点，大家会发现</span><span style="color:#333333">JAVA</span><span style="color:#333333">中有一种</span><span style="color:#333333">JNI</span><span style="color:#333333">（</span><span style="color:#333333">Java native interface</span><span style="color:#333333">）</span><span style="color:#333333">，这种属于</span><span style="color:#333333">JAVA</span><span style="color:#333333">本地接口调用，即调用本地的其他语言信息，</span><span style="color:#333333">JAVA</span><span style="color:#333333">虚拟机底层掉调用也是这样实现的，这部分调用中可能存在一些对</span><span style="color:#333333">C</span><span style="color:#333333">、</span><span style="color:#333333">C++</span><span style="color:#333333">语言的操作，在</span><span style="color:#333333">C</span><span style="color:#333333">和</span><span style="color:#333333">C++</span><span style="color:#333333">内部通过</span><span style="color:#333333">new</span><span style="color:#333333">、</span><span style="color:#333333">malloc</span><span style="color:#333333">、</span><span style="color:#333333">realloc</span><span style="color:#333333">等关键词创建的对象垃圾回收机制是无能为力的，因为这不是它要管理的范围，而平时这些对象可能被</span><span style="color:#333333">JAVA</span><span style="color:#333333">对应的实体所调用，那么需要在对应</span><span style="color:#333333">JAVA</span><span style="color:#333333">对象放弃时（并不代表回收，只是程序中不使用它了）去调用对应的</span><span style="color:#333333">C</span><span style="color:#333333">、</span><span style="color:#333333">C++</span><span style="color:#333333">提供的本地接口去释放这段内存信息，他们的释放同样需要通过</span><span style="color:#333333">free</span><span style="color:#333333">或</span><span style="color:#333333">delete</span><span style="color:#333333">去释放，所以我们一般情况下不要滥用</span><strong><span style="color:#333333">finalize()</span></strong><strong><span style="color:#333333">，个人建议是最好不要用，所有非同类语言的调用不一定非要通过</span></strong><strong><span style="color:#333333">JNI</span></strong><strong><span style="color:#333333">来完成的，或者调用完就直接释放掉相应的内容，而不要寄希望于</span></strong><strong><span style="color:#333333">finalize</span></strong><strong><span style="color:#333333">这个方法，因为</span></strong><strong><span style="color:#333333">JVM</span></strong><strong><span style="color:#333333">不保证什么时候会调用这个方法</span></strong><span style="color:#333333">。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">2</span></strong><strong><span style="color:#333333">、</span></strong><strong><span style="color:#333333">System.gc()</span></strong><strong><span style="color:#333333">或者</span></strong><strong><span style="color:#333333">Runtime.getRuntime().gc();</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">这个可以被认为是强制垃圾回收的一种机制，但是并非强制回收，只是向</span><span style="color:#333333">JVM</span><span style="color:#333333">建议可以进行垃圾回收，而且垃圾回收的地方和多少是不能像</span><span style="color:#333333">C</span><span style="color:#333333">语言一样控制，这是</span><span style="color:#333333">JVM</span><span style="color:#333333">垃圾回收机去控制的。程序中尽量不要是去使用这些东西，除自己开发一些管理代码除外，一般由</span><span style="color:#333333">JVM</span><span style="color:#333333">自己管理即可。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">这里顺便提及几个查看当前</span><span style="color:#333333">JVM</span><span style="color:#333333">内存的几个简单代码方法（在JVM监控下有很多的工具，而且不同的厂商也有自己不同的工具，不过后续大部分关于java的文章都是只提及到：Hotspot VM的版本，其他的版本可能只是略微说明下）</span><span style="color:#333333">：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#000000">2.1.</span></em></strong><strong><em><span style="color:#000000">设置的最大内存：</span></em></strong><strong><em><span style="color:#000000">-Xmx</span></em></strong><strong><em><span style="color:#000000">等值：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#000000">(Runtime.getRuntime().maxMemory()/ (1024 * 1024)) + "MB"</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#000000">2.2.</span></em></strong><strong><em><span style="color:#000000">当前</span></em></strong><strong><em><span style="color:#000000">JVM</span></em></strong><strong><em><span style="color:#000000">可使用的内存，这个值初始化和</span></em></strong><strong><em><span style="color:#000000">-Xms</span></em></strong><strong><em><span style="color:#000000">等值，若加载东西超过这个值，那么以下值会跟着变大，不过上限为</span></em></strong><strong><em><span style="color:#000000">-Xmx</span></em></strong><strong><em><span style="color:#000000">，由于变动过程中需要将虚拟内存做不断的伸缩过程，所以我们推荐服务器：是</span></em></strong><strong><em><span style="color:#000000">-Xms</span></em></strong><strong><em><span style="color:#000000">等价于</span></em></strong><strong><em><span style="color:#000000">-Xmx</span></em></strong><strong><em><span style="color:#000000">的值：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#000000">(Runtime.getRuntime().totalMemory()/ (1024 * 1024)) + "MB"</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">2.3.</span></em></strong><strong><em><span style="color:#333333">剩余内存，在当前可使用内存基础上，剩余内存等价于其剪掉使用了的内存容量：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">(Runtime.getRuntime().freeMemory()/ (1024 * 1024)) + "MB"</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">同理如果要查看使用了多少内存或者百分比。可以通过上述几个参数进行运算查看到。。。。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">顺便在这里提供几个实用方法和类，这部分可能和</span><span style="color:#333333">JVM</span><span style="color:#333333">回收关系不大，不过只是相关推敲，扩展知识面，而且也较为实用的东西：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">2.4.</span></em></strong><strong><em><span style="color:#333333">获取</span></em></strong><strong><em><span style="color:#333333">JAVA</span></em></strong><strong><em><span style="color:#333333">中的所有系统级属性值（包含虚拟机版本、操作系统、字符集等等信息）：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333"> System.setProperty("AAA", "123445");</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333"> Properties properties = System.getProperties();<br>   Enumeration&lt;Object&gt; e = properties.keys();<br>   while (e.hasMoreElements()) {<!-- --><br>    String key = (String) e.nextElement();<br>    System.out.println(key + " = " + properties.getProperty(key));<br>  }<br>  </span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">2.5.</span></em></strong><strong><em><span style="color:#333333">获取系统中所有的环境变量信息：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">Map&lt;String, String&gt; env = System.getenv();<br>   for (Iterator&lt;String&gt; iterator = env.keySet().iterator(); iterator<br>     .hasNext();) {<!-- --><br>    String key = iterator.next();<br>    System.out.println(key + " = " + env.get(key));<br> }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">System.out.println(System.getenv("CLASSPATH"));</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">2.6.</span></em></strong><strong><em><span style="color:#333333">在</span></em></strong><strong><em><span style="color:#333333">Win</span></em></strong><strong><em><span style="color:#333333">环境下，打开一个记事本和一个</span></em></strong><strong><em><span style="color:#333333">WORD</span></em></strong><strong><em><span style="color:#333333">文档：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">try {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">  Runtime.getRuntime().exec("notepad");</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">  Runtime.getRuntime().exec("cmd /c start Winword");</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">}catch(Exception e) {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">  e.printStackTrace();</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">2.7.</span></em></strong><strong><em><span style="color:#333333">查询当前</span></em></strong><strong><em><span style="color:#333333">SERVER</span></em></strong><strong><em><span style="color:#333333">下所有的线程信息列表情况（这里需要提供两个步骤，首先要根据任意一个线程获取到顶级线程组的句柄（有关线程的说明，后面专门会有一篇文章说明），然后通过顶级线程组得到其存在线程信息，进行一份拷贝，给与遍历）：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">2.7.1.</span></em></strong><strong><em><span style="color:#333333">这里通过当前线程得到顶级线程组信息：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">public static ThreadGroup getHeadThreadGroup() {<!-- --><br>   Thread t = Thread.currentThread();<br>   ThreadGroup group = t.getThreadGroup();<br>   while(group.getParent() != null) {<!-- --><br>    group = group.getParent();<br>   }<br>   return group;<br> }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">2.7.2.</span></em></strong><strong><em><span style="color:#333333">通过得到的顶级线程组，遍历存在的子元素信息（仅仅遍历常用属性）：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">public static void disAllThread(ThreadGroup threadgroup) {<!-- --><br>   Thread list[] = new Thread[threadgroup.activeCount()];<br>   threadgroup.enumerate(list);<br>   for(Thread thread:list) {<!-- --><br>    System.out.println(thread.getId()+"/t"+thread.getName()</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">                              +"/t"+thread.getThreadGroup()+"/t"</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">                              +thread.getState()+"/t"+thread.isAlive());}<br> }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">2.7.3.</span></em></strong><strong><em><span style="color:#333333">测试方法如：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">类名</span><span style="color:#333333">.disAllThread(getHeadThreadGroup());</span><span style="color:#333333">即可完成，第一个方法带有不断向上查询的过程，这个过程可能在一般情况下也不会太慢，不过我们最好将其记录在一个地方，方便我们提供管理类来进行直接管理，而不需要每次去获取，对外调用都是封装的运行过程而已。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">好，回到话题，继续说明</span><span style="color:#333333">JVM</span><span style="color:#333333">垃圾回收机制的信息，下面开始说明</span><span style="color:#333333">JAVA</span><span style="color:#333333">申请内存、回收内存的机制了。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">3</span></strong><strong><span style="color:#333333">、</span></strong><strong><span style="color:#333333">JAVA</span></strong><strong><span style="color:#333333">如何申请内存，和</span></strong><strong><span style="color:#333333">C</span></strong><strong><span style="color:#333333">、</span></strong><strong><span style="color:#333333">C++</span></strong><strong><span style="color:#333333">有何区别。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">在上一次缩写的关于</span><span style="color:#333333">JAVA</span><span style="color:#333333">集合类文章中其实已经有部分说明，可以大致看到</span><span style="color:#333333">JAVA</span><span style="color:#333333">内部是按照句柄指向实体的过程，不过这是从</span><span style="color:#333333">JAVA</span><span style="color:#333333">程序设计的角度去理解，如果我们需要更加细致的问一个问题是：</span><span style="color:#333333">JVM</span><span style="color:#333333">垃圾回收机制是如何知道哪些内存是垃圾内存的？</span><span style="color:#333333">JVM</span><span style="color:#333333">为什么不在平时就去回收内存，而是要等到内存不够用的时候才会去回收内存？不得不让我进一步去探讨</span><span style="color:#333333">JAVA</span><span style="color:#333333">是如何细节的申请内存的。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">从编程思想的角度来说，</span><span style="color:#333333">C</span><span style="color:#333333">、</span><span style="color:#333333">C++new</span><span style="color:#333333">申请的内存也是通过指针指向完成，不过你可以看成是一个地球板块图，在这些板块中，他们去</span><span style="color:#333333">new</span><span style="color:#333333">的过程中，就是好比是找一个版块，因为</span><span style="color:#333333">C</span><span style="color:#333333">、</span><span style="color:#333333">C++</span><span style="color:#333333">在申请内存的过程中，是不断的</span><span style="color:#333333">free</span><span style="color:#333333">和</span><span style="color:#333333">delete</span><span style="color:#333333">操作，所以会产生很多内存的碎片操作，而</span><span style="color:#333333">JAVA</span><span style="color:#333333">不是，</span><span style="color:#333333">JAVA</span><span style="color:#333333">只有内存不够用的时候才会去回收（回收细节讲会在文章后面介绍），也就是说，可以保证内存在一定程度上是连续的。从某种意义上将，只要下一块申请的内存不会到头，就可以继续在上一块申请内存的后面紧跟着去申请内存，那么从某种意义上讲，其申请的开销可能可以和</span><span style="color:#333333">C++</span><span style="color:#333333">媲美。那么</span><span style="color:#333333">JAVA</span><span style="color:#333333">在回收内存后，内存还能是连续的嘛。。。。我们姑且这样去理解，在第五节会说明。。继续深入话题：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">在启动</span><span style="color:#333333">weblogic</span><span style="color:#333333">的时候，如果打开任务管理器，可以马上发现，内存被占用了最少</span><span style="color:#333333">-Xms</span><span style="color:#333333">的大小，一个说明现象就是</span><span style="color:#333333">JVM</span><span style="color:#333333">首先将内存先占用了，然后再分配给其对象的，也就是说我们所谓的</span><span style="color:#333333">new</span><span style="color:#333333">可以理解为在堆上做了一个标记，所以在一定程度上做连续分配内存是可以实现的，只是你会发现若要真正实现连续，必然导致一定程度上的序列化，所以</span><span style="color:#333333">new</span><span style="color:#333333">的开销一般还是蛮大的，即使在后面说的</span><span style="color:#333333">JVM</span><span style="color:#333333">会将内存分成几个大块来完成操作，但是也避免不了序列化的过程。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">在这里一个小推敲就是，一个</span><span style="color:#333333">SERVER</span><span style="color:#333333">的管理内存范围一般不要太大（一般在</span><span style="color:#333333">1~2G</span><span style="color:#333333">一个</span><span style="color:#333333">SERVER</span><span style="color:#333333">），推荐也不要太大，因数去考虑：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">1</span><span style="color:#333333">、</span><span style="color:#333333">JAVA</span><span style="color:#333333">虚拟机回收内存是在不够用的时候再去回收，这个不够用何以说明，很多时候因为计算上的失误导致内存溢出。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">2</span><span style="color:#333333">、如果一个主机只有</span><span style="color:#333333">2G</span><span style="color:#333333">左右内存，很少的</span><span style="color:#333333">CPU</span><span style="color:#333333">，那么一个</span><span style="color:#333333">JVM</span><span style="color:#333333">也好，但是如果主机很好，如</span><span style="color:#333333">32G</span><span style="color:#333333">内存，那么这样做未必有点过，第一发挥不出来，一个</span><span style="color:#333333">JVM</span><span style="color:#333333">管这么大块内存好像有点过，还有内存不够用去回收这么大块内存（回收内存时一般需暂停服务），需要花时间，第二举个很现实的例子，一个学校如果只有</span><span style="color:#333333">20~30</span><span style="color:#333333">人，一个人可以既当校长又当老师，如果一个学校有几百上千人，我想这个人再大的能力忙死也管不过来，而且会出乱子，此时它要请班主任来管了。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">3</span><span style="color:#333333">、对于大内存来说，使用多个</span><span style="color:#333333">SERVER</span><span style="color:#333333">完成负载均衡，一个暂停服务回收内存，另一个还可以运行嘛。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">但是</span></strong><strong><span style="color:#333333">JVM</span></strong><strong><span style="color:#333333">是不是真的就不支持大内存了呢？现在你可以这样理解，因为到目前为止可以这样认为，因为世界上所有的</span></strong><strong><span style="color:#333333">java</span></strong><strong><span style="color:#333333">虚拟机，没有不暂停的，而内存越大，回收的时间是必然越长的，不论有多么优秀的算法还做不到“不暂停”的这一点，所以我们的目标是尽量少的暂停，现在的</span></strong><strong><span style="color:#333333">CMS GC</span></strong><strong><span style="color:#333333">已经让我们看到了希望，不过还存在很多的缺陷，我们期待</span></strong><strong><span style="color:#333333">G1</span></strong><strong><span style="color:#333333">的成熟版本的出现，</span></strong><strong><span style="color:#333333">G1</span></strong><strong><span style="color:#333333">的论文很清晰，不过现在还没有一个成熟的版本，所以很期待。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">4</span></em></strong><strong><em><span style="color:#333333">、</span></em></strong><strong><em><span style="color:#333333">JVM</span></em></strong><strong><em><span style="color:#333333">如何寻找到需要回收的内存：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">要回收垃圾，那么首先要知道哪些内存是垃圾，或者反过来哪些不是垃圾，这个过程我们一般称为：</span></strong><strong><span style="color:#333333">Mark</span></strong><strong><span style="color:#333333">的过程，</span></strong><strong><span style="color:#333333">Mark</span></strong><strong><span style="color:#333333">过程世界上没有任何一门虚拟机不进行对外暂停。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">4.1</span></strong><strong><span style="color:#333333">、</span></strong><strong> </strong><strong><span style="color:#333333">引用计数算法：</span></strong><span style="color:#333333">引用计数这里简单说明下，就是当一个引用被赋值的时候，虚拟机将会被知道（部分虚拟机通过写屏障实现），多一个引用，对象的计数增加</span><span style="color:#333333">1</span><span style="color:#333333">，少一个减少</span><span style="color:#333333">1</span><span style="color:#333333">，回收时，只回收等于</span><span style="color:#333333">0</span><span style="color:#333333">的，好处是算法非常简单，而且</span><span style="color:#333333">这种算法由于回收过程中只是看那些没有被引用，所以在一般情况下无需暂停</span><span style="color:#333333">，不过由于它在计数的过程中需要一个锁的机制，而且遍历内存的过程十分漫长，所以现在已经没有这个东西的存在了；另外一个问题出来了：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">问题出来了：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">循环引用，以及被这些对象引用的对象都讲永远回收不掉，因为循环引用中的对象引用计数永远大于等于1，那么这个资源在循环引用中，其实不是虚拟机算不出来，而且为了这个非常低的代价，虚拟机的算法将会复杂非常多。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">其次这种分配方法在分配回收的过程中因为需要记录哪些内存是垃圾，哪些不是垃圾，所以一般需要维护一个</span></strong><strong><span style="color:#333333">freelist</span></strong><strong><span style="color:#333333">的区域。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">4.2.</span></strong><strong><span style="color:#333333">引用树遍历算法：</span></strong><span style="color:#333333">首先，每个内存都有原始的引用根，这些根部一般来源于当前线程的栈针、静态引用、JNI的句柄等，从这里开始mark，将可达的对象标记为活着的对象，其余的就认为不是活着的对象，至于找到这些对象如何处理也就是回收的算法所决定的。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">5</span></em></strong><strong><em><span style="color:#333333">、</span></em></strong><strong><em><span style="color:#333333">JVM</span></em></strong><strong><em><span style="color:#333333">如何回收内存的（回收算法分解详述）：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">首先了解几个其他的概念：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">5.1</span></strong><strong><span style="color:#333333">．平时所说的JDK，其实是JAVA开发工具的意思，安装JAVA虚拟机会产生两个JRE目录，JRE目录为JAVA运行时环境的意思，两个JRE目录的区别是其中在JDK所在的JRE目录下没有Server和Client文件夹（JDK1.5自动安装包会自动将其复制到JDK下面一份），JRE为运行时环境，提供对JVM操作的API，JVM内部通过动态链接库（就是配置PATH的路径下），通过它作为主动态链接库寻找到其它的动态链接库，动态链接库为何OS绑定的参数，即代码最终要通过这些东西转换为操作系统指令集进行运行，另一个核心工具为JIT（JAVA即时编译工具），用于将代码转换为对应操作系统的运行指令集合的过程，不过其与惰性评估形成对比，后面会专门介绍。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">5.1.JVM</span><span style="color:#333333">首先将大致分为：</span><span style="color:#333333">JVM</span><span style="color:#333333">指令集、</span><span style="color:#333333">JVM</span><span style="color:#333333">存储器、</span><span style="color:#333333">JVM</span><span style="color:#333333">内存（堆栈区域部分）、</span><span style="color:#333333">JVM</span><span style="color:#333333">垃圾回收区域；</span><span style="color:#333333">JVM</span><span style="color:#333333">的堆部分又一般分为：新域、旧域、永久域（很多时候不会认为<strong>永久域</strong>是堆的一部分，因为它是永远不会被回收的，它一般包含</span><span style="color:#333333">class</span><span style="color:#333333">的定义信息、</span><span style="color:#333333">static</span><span style="color:#333333">定义的方法、</span><span style="color:#333333">static</span><span style="color:#333333">匿名块代码段、常量信息（较为典型的就是</span><span style="color:#333333">String</span><span style="color:#333333">常量），不过这块内存也是可以被配置的）；新域内部又可以分为</span><span style="color:#333333">Eden</span><span style="color:#333333">和两个救助区域，这几个对象在</span><span style="color:#333333">JVM</span><span style="color:#333333">内部有一定的默认值，但是也是可以被设置的。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">当新申请的对象的时候，会放入</span><span style="color:#333333">Eden</span><span style="color:#333333">区中（这个区域一般不会太大，默认为新域的3/4， 还有1/4一般会被切成两块，成为救助域），当对象在一定时间内还在使用的时候，它会逐步的进入旧域（此时是一个内存复制的过程，旧区域按照顺序，其引用的句柄也会被修改指向的位置），</span><span style="color:#333333">JVM</span><span style="color:#333333">回收中会先将</span><span style="color:#333333">Eden</span><span style="color:#333333">里面的内存和一个救助区域的内存就会被赋值到另一个救助区域，然后对这两块内存进行回收，同理，旧区域也有一个差不多大小的内存区域进行被复制，这个复制的过程肯定就会在一定程度上将内存连续的排列起来；另外可以想到</span><span style="color:#333333">JAVA</span><span style="color:#333333">提供内存复制最快的就是</span><span style="color:#333333">System.arrayCopy</span><span style="color:#333333">方法，那么这个肯定是按照内存数组进行拷贝（</span><span style="color:#333333">JVM</span><span style="color:#333333">起始就是一个大内存，本身就可以成是几个大数组组成的，而这个拷贝方法，默认拷贝多长呢，其实数组最长可以达到多少，通过数组的</span><span style="color:#333333">length</span><span style="color:#333333">返回的是</span><span style="color:#333333">int</span><span style="color:#333333">类型数据就可以清楚发现，为</span><span style="color:#333333">int</span><span style="color:#333333">类型的上限</span><span style="color:#333333">1&lt;&lt;31 - 1</span><span style="color:#333333">的长度（理想情况，因为有可能因为操作系统的其他进程导致</span><span style="color:#333333">JVM</span><span style="color:#333333">内存本身就不是连续的），即在(</span><span style="color:#333333">2G-1)*</span><span style="color:#333333">单元内存长度，所以也在一定程度上说明我们的一个</span><span style="color:#333333">JVM</span><span style="color:#333333">设置内存不要太大，不然复制内存的过程开销是很大的）。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">其实上述描述的是一种</span><span style="color:#FF0000">停止</span><span style="color:#FF0000">-</span><span style="color:#FF0000">复制</span><span style="color:#333333">回收算法，在这个过程中形成了几个大的内存来回倒，这必然是很恶心的事情，那么继续将其切片为几个大的板块，有些大的对象会出现一两个对象占用一个版块的现象，这些大对象基本不会怎么移动（被回收就是另一回事，因为会清空这个版块），板块之间有一些对应关系，在回收时先将一些版块的小对象，向另一个还未装满的大板块内部转移，复制的粒度变小了，另外管理上可以发挥多线程的优势所在，好比是将一块大的田地，分成很多小田地，每块田地种植不同档次的秧苗，将其划分等级，我们假如秧苗经常会随机的死掉一些（这块是垃圾），在清理一些很普通的秧苗田地的时候，可能会将其中一块或几块田地的（活着的秧苗）种植到另一块田地中，但是他们不可以将高档次的秧苗移植到低档次的田地中，因为高档次的秧苗造价太高（内存太大），移植过程中代价太大，需要使用非普通秧苗的手段要移动他们，所以基本不移动他们，除非丰收他们的时候（他们也成为垃圾内存的时候），才会被拔出，腾出田地来。在转移秧苗的过程中，他们需要整理出顺序便于管理，在很多书籍上把这个过程叫做压缩，因为这样使得保证在只要内存不溢出的情况下，申请的对象都有足够的控件可以存放，不然零碎的空间中间的缝隙未必可以存放下一个较大的对象。将内存分块管理就是另一个停止复制收集器的进一步升级：增量收集思想。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">5.2.</span><span style="color:#333333">一般在</span><span style="color:#333333">hotspot</span><span style="color:#333333">的回收过程有以下一些历史：标记</span><span style="color:#333333">—</span><span style="color:#333333">清除、标记</span><span style="color:#333333">—</span><span style="color:#333333">压缩、停止</span><span style="color:#333333">—</span><span style="color:#333333">复制、增量收集、分代收集、</span><span style="color:#333333">并行收集</span><span style="color:#333333">、并发收集。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">这些收集器各有优缺点，某些收集器可能在早期硬件设备上显示不出优势，不过后来的收集器显示出优势出来，这也是为什么技术没有长短之分，只有时机和场合的问题，不过不论那一种收集器都需要暂停，细节后续来讨论，总的来说hotspot版本的虚拟机经历了串行收集、到早期的并行收集、到新的并行收集算法、再到并发收集（CMS GC）的过程，不过一直以来还是不能满足很多高可用的需求，尤其是面对大内存时，回收会显得非常缓慢，很多时候不得不将其拆分为多个JVM来处理；一直以来我们都期待有一块自己管理的区域出现，或者几乎不受到JVM的干涉，或者有多快这样的区域，也就是目前来说一般JVM的Heap是短命、长命的两个大区域，不过很多时候我们的对象是半长命得，很难让我们控制起来，比如我们的pageCache，既不是很长的命，但是命也不短，但是又不想影响Young区域的正常对象申请，又不想去导致Old区域的大量回收和compaction，所以我们希望有这样的区域出现，不过可惜的事情是现在不是SUN说了算，而是Oracle，这个梦想我想在开源的Hotspot上很难实现了，不过G1倒是让我们看到一些希望，期望G1成熟版本的诞生。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">6</span></em></strong><strong><em><span style="color:#333333">、应用服务器部署及常用参数设置：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">说到JVM的配置，最常用的两个配置就是：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-Xms512m –Xmx1024m</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-Xms</span></strong><strong><span style="color:#333333">设置JVM的初始化内存大小，-Xmx为最大内存大小，当突破这个值，将会报内存溢出，导致的原因有很多，主要是虚拟机的回收问题以及程序设计上的内存泄露问题；由于在超过-Xms时会产生页面申请的开销，所以一般很多应用服务器会推荐-Xms和-Xmx是等值的；最大值一般不保持在主机内存的75%的内存左右(多个SERVER是加起来的内存)，当JVM绝大部分时间处于回收状态，并且内存长时间处于非常长少的状态就会报：java.lang.OutOfMemoryError:Java heap space的错误。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">上面提及到JVM很多的知识面，很显然你想去设置一下其它的参数，其实对于JVM设置的参数有上百个，这里就说一些较为常用配置即可。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">JVM</span></em></strong><strong><em><span style="color:#333333">内存配置分两大类：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">1</span></strong><strong><span style="color:#333333">、-X开头的参数信息：一般每个版本变化不大。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">2</span></strong><strong><span style="color:#333333">、-XX开头的参数信息：版本升级变化较大，如果没有太大必要保持默认即可。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">3</span></strong><strong><span style="color:#333333">、另外还有一个特殊的选项就是-server还是-client，他们在默认配置内存上有一些细微的区别，直接用JDK运行程序默认是-client，应用服务器生产模式一般只会用-server。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">这些命令其实就是在运行java命令或者javaw等相关命令后可以配置的参数，如果不配置，他们有相应的默认值配置。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">1</span></em></strong><strong><em><span style="color:#333333">、-X开头的常用配置信息：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-Xnoclassgc  </span></strong><strong><span style="color:#333333">禁用垃圾回收，一般不适用这个参数</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-Xincgc       </span></strong><strong><span style="color:#333333">启用增量垃圾回收</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-Xmn1024K   Eden</span></strong><strong><span style="color:#333333">区初始化JAVA堆的尺寸，默认值640K</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-Xms512m    JAVA</span></strong><strong><span style="color:#333333">堆初始化尺寸，默认是32M</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-Xmx512m    JAVA</span></strong><strong><span style="color:#333333">堆最大尺寸，默认64M，一般不超过2G，在64位机上，使用64位的JVM，需要操作系统进行unlimited方可设置到2G以上。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">2</span></em></strong><strong><em><span style="color:#333333">、-XX开头常用内存配置信息：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-XX:-DisableExplicitGC  </span></strong><strong><span style="color:#333333">将会忽略手动调用GC的代码，如：System.gc()，将-DisableExplicitGC，   改成+DisableExplicitGC即为启用，默认为启用，什么也不写，默认是加号，但是系统内部默认的并不是什么都启用。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-XX:+UseParallelGC     </span></strong><strong><span style="color:#333333">将会自动启用并行回收，多余多CPU主机有效，默认是不启用。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-XX:+UseParNewGC     </span></strong><strong><span style="color:#333333">启用并行收集（不是回收），也是多CPU有效。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-XX:NewSize=128m     </span></strong><strong><span style="color:#333333">新域的初始化尺寸。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-XX:MaxNewSize=128m </span></strong><strong><span style="color:#333333">新创建的对象都是在Eden中，其属于新域，在-client中默认为640K，而-server中默认是2M，为减少频繁的对新域进行回收，可以适当调大这个值。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-XX:PerSize=64m        </span></strong><strong><span style="color:#333333">设置永久域的初始化大小，在WEBLOGIC中默认的尺寸应该是48M，一般够用，可以根据实际情况作相应条调整。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">-XX:MaxPerSize=64m    </span></strong><strong><span style="color:#333333">设置永久域的最大尺寸。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">另外还可以设置按照区域的比例进行设置操作，以及设置线程、缓存、页面大小等等操作</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">3</span></em></strong><strong><em><span style="color:#333333">、-XX开头的几个监控信息：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#3366ff">-XX:+GITime</span></strong><strong>              </strong><strong><span style="color:#333333">显示有多少时间花在编译代码代码上，这部分为运行时编译为对应机器码时间。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#3366ff">-XX:+PrintGC </span></strong><strong>             </strong><strong><span style="color:#333333">打印垃圾回收的基本信息</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#3366ff">-XX:+PrintGCTimeStamps</span></strong><strong> </strong><strong><span style="color:#333333">打印垃圾回收时间戳信息</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#3366ff">-XX:+PrintGCDetails</span></strong><strong>       </strong><strong><span style="color:#333333">打印垃圾回收的详细信息</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#3366ff">-XX:+TraceClassLoading</span></strong><strong>    </strong><strong><span style="color:#333333">跟踪类的加载</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#3366ff">-XX:+TraceClassResolution</span></strong><strong> </strong><strong><span style="color:#333333">跟踪常量池</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#3366ff">-XX:+TraceClassUnLoading</span></strong><strong> </strong><strong><span style="color:#333333">跟踪类卸载</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">等等。。。。。。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#cc0000">====</span></strong><strong><span style="color:#cc0000">》配置归配置，希望大家不要乱去配置，也不要想当然去配置，一般来说只需要设置最基本的几个参数，其余的就不用关心了，很多时候我们发现设置了的结果还不如不设置，很多时候不设置它也有默认值，默认值在很多情况下就是正确的，并且，当你要设置它的时候，一定要知道它的默认值，不同的厂商甚至于不同的版本每个参数的默认值都会有所不同，所以你在任何地方看到的默认值都是未必靠谱的，甚至于官方公布的一些默认值也未必百分之百的靠谱，因为写官方文档的朋友未必是编写这段代码的朋友，你要真正知道默认值还真得看代码，呵呵。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">例子：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">编写一个简单的JAVA类：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">public class Hello {<!-- --></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">   public static void main(String []args) {<!-- --></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      byte []a1 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第一次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      byte []a2 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第二次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      byte []a3 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第三次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      byte []a4 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第四次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      byte []a5 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第五次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      byte []a6 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第六次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">   }</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">}</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">此时运行程序，这样调试一下:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">C:/&gt;</span></strong><strong><span style="color:#0000FF">java -Xmn4m -Xms16m -Xmx16m Hello</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第一次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第二次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">分析下为什么会这样，Heap总大小为16M，而Young的大小为4M，一般情况下的默认值Eden为Young的80%，所以Eden肯定不到4M，其实初始化直接申请4M空间Enden肯定放不下（抛开对象头部本身的区域也有4M），此时直接放入Old区域，Old区域本身自有剩下12M，第二次也是一样，当尝试第三次放入4M时，JVM检查空间已经不够了，并且以前的空间释放不掉，所以就直接抛出异常了，而不是先将内存放下去，这样引起的是类似于其他语言类似的OS级别的错误，导致的问题就是操作系统直接将进城Crash掉。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">那么我们将程序修改一下再看效果</span></em></strong><strong><span style="color:#333333">：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">public class Hello {<!-- --></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">   public static void main(String []args) {<!-- --></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      byte []a1 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第一次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      a1 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第二次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      a1 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第三次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      a1 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第四次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      a1 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第五次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      a1 = new byte[4*1024*1024];</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">      System.out.println("</span></strong><strong><span style="color:#333333">第六次申请");</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">   }</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">}</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">运行程序如下：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">C:/&gt;javac Hello.java</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">C:/&gt;java -Xmn4m -Xms16m -Xmx16m Hello</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第一次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第二次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第三次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第四次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第五次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第六次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">程序正常下来了，说明中途进行了垃圾回收的动作，我们想看下垃圾回收的整个过程，如何看，把上面的参数搬下来：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">E:/&gt;java -Xmn4m -Xms16m -Xmx16m -XX:+PrintGCDetails Hello</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第一次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第二次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">[GC [DefNew: 189K-&gt;133K(3712K), 0.0014622 secs][Tenured: 8192K-&gt;4229K(12288K), 0.0089967 secs] 8381K-&gt;4229K(16000K), 0.0110011 secs]</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第三次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">[GC [DefNew: 0K-&gt;0K(3712K), 0.0004749 secs][Tenured: 8325K-&gt;4229K(12288K), 0.0083114 secs] 8325K-&gt;4229K(16000K), 0.0092936 secs]</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第四次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">[GC [DefNew: 0K-&gt;0K(3712K), 0.0003168 secs][Tenured: 8325K-&gt;4229K(12288K), 0.0081516 secs] 8325K-&gt;4229K(16000K), 0.0089735 secs]</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第五次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">[GC [DefNew: 0K-&gt;0K(3712K), 0.0003179 secs][Tenured: 8325K-&gt;4229K(12288K), 0.0080368 secs] 8325K-&gt;4229K(16000K), 0.0088335 secs]</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">第六次申请</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">上面可以看到，DefNew一直就没有怎么回收过，其实刚开始看到的189K只是一些引用空间本身内部的一些开销，而Tenured也就是我们说的老年代的每次GC的变法，而括号中的部分代表该区域实际运行中的最大尺寸，后面会给出GC的延迟时间，顺便说明下，这是默认-client情况下是串行回收，当你使用并行回收的时候看到的提示会有所变化，原因是因为他们完全是两套程序控制，所谓DefNew没什么就是它的程序名称叫做这个，Tenured也是这个意思。</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">对于内存回收部分的内容，这里不想说得太深入，只是让大家有一个大致的了解，后续有空专门写几篇文章为大家分享，下面分享一点点雕虫小技。</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">7</span></em></strong><strong><em><span style="color:#333333">、扩展话题</span></em></strong><strong><em><span style="color:#333333">JIT</span></em></strong><strong><em><span style="color:#333333">（即时编译技术）与</span></em></strong><strong><em><span style="color:#333333">lazy evaluation</span></em></strong><strong><em><span style="color:#333333">（惰性评估），如何在应用服务器中控制一些必要的信息：</span></em></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">7.1.JIT</span></em></strong><strong><em><span style="color:#333333">为即时编译技术</span></em></strong><em><span style="color:#333333">，虚拟机有两种方案：一种是在启动时将对应的class信息编译对应的机器指令集合，但是这样会导致的问题是装在时间很长，另一个是机器指令码比字节码要长很多，装在的时间页面操作非常大，此时JAVA提出惰性评估方案，即启动时对于CLASS的字节码并不翻译，当需要调用其代码段了，再去编译（注意代码段若装载后，实例存在其对应代码段是不会注销的，单例程序的代码段也是单例的）。</span></em></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><em><span style="color:#333333">7.2.</span></em></strong><strong><em><span style="color:#333333">如何在应用服务中控制信息</span></em></strong><em><span style="color:#333333">：其实通过上述控制已经发现一些控制原理，当内存在某些特殊的情况下就会内存溢出，尤其在进行一些大批量导出数据的情况下，此时可能会同时导出几万条数据，如果在前端去控制只能到处几百天或者几千条可能客户不答应，因为这太少了；假如我们的控制方式是要在1G内存将各类导出内存数据进行分类：业务类别、平均一百行占用内存多少M。进行计算，然后对于一个SERVER下允许同时在线导出多少个线程进行配置化，按照提交的业务类别，在抽象顶层进行控制，若为导出某类业务将其进行校验，若未通过校验，线程wait()，即释放临界资源，进入等待池，当下载完毕一个时，调用管理器进行对应对象的notify操作，并使得计数器减少。大致原理可以基于以下方式（不过实际应用须稍微修改下）：</span></em></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><em><span style="color:#333333">//</span></em><em><span style="color:#333333">代码段1：设置共享信息，该类</span></em></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">class</span></strong><span style="color:#333333"> WaitObj {//</span><span style="color:#FF0000">该类所在对象须申明为单例，才可以达到效果。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    <strong>private</strong> <strong>volatile</strong> <strong>int</strong> index = 0;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    <strong>private</strong> <strong>int</strong> maxMutile = 20;//</span><span style="color:#000000">假如最多运行</span><span style="color:#333333">20</span><span style="color:#000000">个同时导出</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    <strong>synchronized</strong> <strong>public</strong> <strong>void</strong> checkInfo() {//</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        <strong>while</strong>(index &gt;= maxMutile) {<!-- --></span> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">            <strong>try</strong> {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">                <strong>this</strong>.wait();//</span><span style="color:#000000">超过数量等待激活，激活后还要判定</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">            } <strong>catch</strong> (InterruptedException e) {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">                e.printStackTrace();</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">            }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        index++;//</span><span style="color:#000000">得到申请可以导出时，将在线计数器增加</span><span style="color:#333333">1</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF">    </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    <strong>synchronized</strong> <strong>public</strong> <strong>void</strong> notifyInfo() {//</span><span style="color:#FF0000">做完事情，激活一个</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        index--;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        <strong>this</strong>.notify();</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF">    </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    <strong>public</strong> <strong>void</strong> setMaxMutile(String maxMutilePara) {//</span><span style="color:#FF0000">手工设置最大值</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        maxMutile = (maxMutilePara == <strong>null</strong>)? 20 : Integer.<em>valueOf</em>(maxMutilePara).intValue();</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">}</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">//</span><span style="color:#000000">同文件中代码段</span><span style="color:#333333">2</span><span style="color:#000000">：设置管理器</span><span style="color:#333333">,</span><span style="color:#000000">设置控制简单单例，并提供管理规则</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">public class </span></strong><strong><span style="color:#333333">TestManager</span></strong><strong><span style="color:#7f0055"> {<!-- --></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">   private final static waitObj = new waitObj();//</span></strong><strong><span style="color:#7f0055">只有一个实例</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">    public</span></strong><span style="color:#333333"> <strong>static</strong> <strong>void</strong> checkInfo() {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        <strong>waitObj</strong>.checkInfo();</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    <strong>public</strong> <strong>static</strong> <strong>void</strong> notifyInfo() {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        <strong>waitObj</strong>.notifyInfo();</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">    }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">}</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">//</span></strong><strong><span style="color:#7f0055">外部代码段调用：假如导出部分代码上层有公共调用部分去调用导出代码，那么在公共代码部分这样写：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">TestManager.</span></strong><span style="color:#333333">checkInfo();//</span><span style="color:#FF0000">这里调用了检测部分</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">try {<!-- --></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">  export……</span></strong><strong><span style="color:#000000">调用部分。。。。根据实际情况而定</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">}cache(Exception e) {<!-- --></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong>  </strong><strong><span style="color:#000000">异常处理</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">}finally {<!-- --></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">   TestManager.</span></strong><span style="color:#333333">notifyInfo();//</span><span style="color:#FF0000">执行完毕后，释放一个资源</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">}</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#000000">为了验证程序的正确性，可以从几个角度去测试：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">1</span></strong><strong><span style="color:#333333">、</span></strong><strong> </strong><strong><span style="color:#333333">在本地模拟一个多线程，利用多个线程同时去访问一段代码，这段嗲吗如上，，在执行前通过TestManager.checkInfo()序列化操作，在finally中去TestManager.notifyInfo()操作。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">2</span></strong><strong><span style="color:#333333">、</span></strong><strong> </strong><strong><span style="color:#333333">多线程取一个名字，然后输出名字即可，这里就不提供模拟程序了（因为怕误认为下面的程序为实际的运行程序，下面只是为了模拟情况而已），提供了001~007之间七个线程去访问，而最大同时在线导出人数为5个，以打印信息表示动作已经执行，此时运行结果如下：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">001 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274763253343</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">002 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274763253359</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">004 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274763253359</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">003 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274763253359</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">006 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274763253359</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">007 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274763253359</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">005 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274763253359</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">3</span></strong><strong><span style="color:#333333">、</span></strong><strong> </strong><strong><span style="color:#333333">此时发现，几乎同时执行，为什么，因为程序运行太快，前面执行完后，就直接释放掉信息了，所以看不出什么区别，为了验证先执行完的程序暂时不释放，我们让每个线程执行完（输出信息后）以后，等待两秒再去执行，那么输出结果如下所示：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">001 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274763842140</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">002 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274763842140</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">004 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274763842140</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">003 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274763842140</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">005 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274763842140</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">007 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274763844140</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">006 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274763844140</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#333333">你会发现，后面两个线程几乎同时执行，前面的线程几乎同时执行，是不是后面两个线程同时运行的呢？这样会不会有问题，如现在堵塞了10个线程在这里，那么一旦释放，那么计数器的值是否会错误，此时的确前面5个线程同时几乎同时释放了（虽然都睡了两秒），为了验证后面两个线程对于计数器的操作是否为顺序的或者互斥的，一种首先在自定义线程中，定义一个自定义的time，初始化的时候，设置不同的值，让他们睡不同的时间来激活。另一个模拟就是在每一个线程进行checkInfo()内部，跳出循环的时候，也睡两秒，此时若程序剩下两个线程能够以相差2秒左右的时间下来就是理想结果，如果是同时下来，那么多线程在这里释放的过程中就没有控制到，代码稍微修改下（测试代码）：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        <strong>boolean i = false;</strong></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        <strong>while</strong>(<em>index</em> &gt;= <em>maxMutile</em>) {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">            <strong>try</strong> {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">                i = true;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">                <strong>this</strong>.wait();</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">            } <strong>catch</strong> (InterruptedException e) {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">                e.printStackTrace();</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">            }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        <strong>if(i) {<!-- --></strong></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">            try {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">                Thread.sleep(2000);</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">            } catch (InterruptedException e) {<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">                e.printStackTrace();</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">            }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        }</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">        index ++;</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#000000">此时运行结果如下：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">001 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274764270203</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">003 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274764270203</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">005 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274764270203</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">002 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274764270203</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">007 </span><span style="color:#0000FF">执行了，时间：</span><span style="color:#333333">1274764270203</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">004 </span><span style="color:#FF0000">执行了，时间：</span><span style="color:#333333">1274764274203</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">006 </span><span style="color:#ffcc00">执行了，时间：</span><span style="color:#333333">1274764276203</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#FF0000">注意：可能你会发现，上面的顺序怎么在变化，因为它是多线程，谁先获取到锁这是随即的，虽然也有顺序，不过在很短的时间内，不一定谁先获取到锁。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#FF0000">另外上述为共享锁机制，一般不允许外部代码所直接调用，可以将其作为管理器内部的</span><span style="color:#FF0000">private static class </span><span style="color:#FF0000">的内部类，只有其管理类才可以创建它的实例并直接操作它。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"> </span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">这的确是我们要要的结果，那么在一定程度决定了它的正确性，稳定性由程序完成控制过程，并通过管理器控制外部调用，若可以的话，可以将这部分代码进行</span><span style="color:#333333">AOP</span><span style="color:#333333">切入方式控制到程序中，对于</span><span style="color:#333333">AOP</span><span style="color:#333333">切入方式的原理和核心说明，后面再介绍反射中给予详细例子和说明。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong> </strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><strong><span style="color:#000000">这种应该说在绝大部分概率下问题不大，因为</span></strong><strong><span style="color:#333333">finally</span></strong><strong><span style="color:#000000">是</span></strong><strong><span style="color:#333333">SUN</span></strong><strong><span style="color:#000000">公司承诺无论发生任何事情，是肯定会执行，唯一可能出现漏洞就是</span></strong><strong><span style="color:#333333">TestManager.notifyInfo()</span></strong><strong><span style="color:#000000">出现了异常，不过这个概率非常低。</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#000000">同理如果要完善自己的一些内存数据的管理，进一步分类管理：</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">1</span><span style="color:#000000">、信息类别：页面流、文章、图片等</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">2</span><span style="color:#000000">、业务分类</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">3</span><span style="color:#000000">、初始化内存行数</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">4</span><span style="color:#000000">、最大数据行数</span></span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="background-color:#FFFFFF"><span style="color:#333333">5</span><span style="color:#000000">、置换算法（这个可以配置也可以写死，置换算法比较经典就是</span><span style="color:#333333">LRU</span><span style="color:#000000">最近最久未使用算法，不过写得不好的话，会很慢，还不如直接从数据库里面读，不过细细读每一行意义，总体把握性能，量化评估算法，问题不会太大。）</span></span></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>