<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>HHU云计算期末复习（上）Google、Amazon AWS、Azure - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HHU云计算期末复习（上）Google、Amazon AWS、Azure</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>文章目录</h3> 
 <ul>
<li><a href="#__4">第一章 概论</a></li>
<li><a href="#__Google__16">第二章 Google 云计算</a></li>
<li>
<ul>
<li><a href="#21_GoogleGFS_18">2.1 Google文件系统（GFS）</a></li>
<li><a href="#22_MapReduceHadoop_40">2.2 MapReduce和Hadoop</a></li>
<li><a href="#23_Chubby_75">2.3 分布式锁服务Chubby</a></li>
<li><a href="#24_Bigtable_93">2.4 分布式结构化数据表Bigtable</a></li>
<li>
<ul>
<li><a href="#_101">存储形式</a></li>
<li><a href="#_137">主服务器</a></li>
<li><a href="#_143">子表</a></li>
<li><a href="#Bigtable__176">Bigtable 相关优化技术</a></li>
</ul> 
   </li>
<li><a href="#25_Megastore_190">2.5 分布式存储系统Megastore</a></li>
<li>
<ul>
<li><a href="#Megastore_194">Megastore</a></li>
<li><a href="#ACID_211">ACID语义</a></li>
<li><a href="#_221">基本架构</a></li>
<li><a href="#_235">核心技术-复制</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#_Amazon_AWS_244">第三章 Amazon AWS</a></li>
<li>
<ul>
<li><a href="#31_Dynamo_246">3.1 Dynamo</a></li>
<li>
<ul>
<li><a href="#_261">一致性哈希算法</a></li>
<li><a href="#_272">冗余备份</a></li>
<li><a href="#_280">成员资格和错误检测</a></li>
</ul> 
   </li>
<li><a href="#32_EC2_302">3.2 弹性计算云EC2</a></li>
<li><a href="#33S3_317">3.3简单存储服务S3</a></li>
<li><a href="#34__328">3.4 非关系型数据库</a></li>
<li><a href="#35_RDS_337">3.5 关系数据库服务RDS</a></li>
<li><a href="#36_CloudFront_347">3.6 内容推送服务CloudFront</a></li>
</ul> 
  </li>
<li><a href="#_Azure_363">第四章 微软的云计算服务Azure</a></li>
<li>
<ul>
<li><a href="#41__367">4.1 五个部分</a></li>
<li><a href="#42__387">4.2 三个实例</a></li>
<li><a href="#43__403">4.3 数据结构</a></li>
<li><a href="#44__409">4.4 轮幅备份思想</a></li>
</ul> 
 </li>
</ul> 
</div> 
<p></p> 
<blockquote> 
 <p>河海大学商学院的云计算课程期末复习笔记上半部分<br> 只针对考点所以不太全面，留给未来需要的学弟学妹<br> 本文主要讲了Google云计算、Amazon AWS、微软Azure这三套云计算体系的重要知识点</p> 
</blockquote> 
<h1>
<a id="__4"></a>第一章 概论</h1> 
<p>云计算是一种提供计算服务的模式，包括服务器、存储、数据库、网络、软件、分析等服务，都通过互联网（“云”）提供给全世界的用户。根据服务类型，云计算通常可以分为三类：基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）。</p> 
<p>以下是这三种服务类型的详细介绍和典型例子：</p> 
<ol>
<li>
<strong>基础设施即服务（Infrastructure as a Service，简称IaaS）</strong>：提供计算资源，包括服务器、存储和网络硬件等基础设施服务。用户可以根据需求随时购买或释放资源，以应对业务的变化。这种服务允许用户全面控制基础设施的所有细节，但同时也需要用户自行负责系统的运维和管理。典型的IaaS服务提供商有阿里云（Alibaba Cloud）和腾讯云（Tencent Cloud）。</li>
<li>
<strong>平台即服务（Platform as a Service，简称PaaS）</strong>：提供一套完整的开发和部署环境，让开发者能够专注于编写代码，而无需管理底层的基础设施。PaaS通常包括操作系统、数据库、中间件等服务，用户只需关注应用程序的开发，不需要管理底层的基础设施。华为云（Huawei Cloud）提供了一系列PaaS服务，阿里云和腾讯云也提供了类似的服务。</li>
<li>
<strong>软件即服务（Software as a Service，简称SaaS）</strong>：通过网络提供软件应用。用户无需购买和安装软件，只需要通过网络即可使用。SaaS通常采用订阅制，用户只需要支付使用软件的费用，无需购买和维护软件和硬件。阿里巴巴的钉钉（DingTalk）和腾讯的企业微信（WeChat Work）就是典型的SaaS服务例子。</li>
</ol> 
<p>以上就是云计算的三种主要服务类型。需要注意的是，这三种服务类型并非互斥，很多云服务提供商会同时提供这三种服务。</p> 
<h1>
<a id="__Google__16"></a>第二章 Google 云计算</h1> 
<h2>
<a id="21_GoogleGFS_18"></a>2.1 Google文件系统（GFS）</h2> 
<p><img src="https://images2.imgbox.com/b3/fb/EJFKKFhM_o.gif" alt="CFS的系统架构"></p> 
<p>GFS设计初衷是满足Google大数据存储和处理的需求。系统由一个主服务器（Master Server）和多个分块服务器（Chunk Server）组成，以及一系列客户端库（Client）。</p> 
<ul>
<li>Client是GFS提供给应用程序的访问接口</li>
<li>主服务器Master负责元数据（metadata）的管理，包括命名空间、访问控制信息以及文件分块信息。主服务器并不直接参与文件的读写，从而避免了成为瓶颈。</li>
<li>分块服务器Chunk Server将文件存储为固定大小的块（默认64MB），并在主服务器的指示下进行复制以提供容错能力。</li>
</ul> 
<p>GFS文件写入流程大致为：</p> 
<ul>
<li>客户端询问主服务器该文件哪些分块服务器存有。</li>
<li>主服务器返回分块服务器信息后，客户端向分块服务器发出写入请求。</li>
<li>分块服务器接受写入数据，并在成功后通知主服务器更新元数据。</li>
</ul> 
<p><code>升级原理</code>？</p> 
<h2>
<a id="22_MapReduceHadoop_40"></a>2.2 MapReduce和Hadoop</h2> 
<p>分布数据处理</p> 
<p>MapReduce是Google设计的一种大数据处理编程模型，Apache Hadoop是该模型的一个著名开源实现。</p> 
<p>MapReduce主要包括三个阶段：Map阶段、Shuffle阶段和Reduce阶段。在Map阶段，输入数据被分割成多个块，并在集群的各节点上并行处理，生成一系列的键值对。接下来的Shuffle阶段会把这些键值对按照键进行排序和分组，这样就可以将具有相同键的值集中到一起。然后在Reduce阶段，根据键值对的键来对相应的值进行聚合操作。</p> 
<p>以下是这个过程的一个示例：</p> 
<p>假设我们需要处理一个大型文本文件，目标是计算每个单词出现的次数。我们可以使用MapReduce来完成这个任务。</p> 
<ol>
<li>
<strong>Map阶段</strong>：每个Map任务处理文件的一部分，它会读取文本并将每个单词输出为一个键值对，其中键是单词本身，值是这个单词的计数（初始为1）。例如，如果输入是"apple banana apple"，那么Map阶段的输出就是 [(“apple”, 1), (“banana”, 1), (“apple”, 1)]。</li>
<li>
<strong>Shuffle阶段</strong>：在这个阶段，系统会自动把所有的键值对按照键进行排序和分组，使得所有相同的键都会被集中到一起。在我们的例子中，Shuffle阶段会把所有的(“apple”, 1)和(“banana”, 1)收集到一起。</li>
<li>
<strong>Reduce阶段</strong>：在这个阶段，每个Reduce任务会接收到Shuffle阶段的结果，然后对同一个键的所有值进行聚合。例如，对于"apple"，Reduce阶段的输入是 [(“apple”, 1), (“apple”, 1)]，它会把这些计数加起来，输出的结果就是 [(“apple”, 2)]。</li>
</ol> 
<p>这样，通过MapReduce，我们就可以在一个大规模的集群上，高效地处理大量的数据。</p> 
<blockquote> 
 <ul><li>具体执行过程： 
   <ul><li>MapReduce 的大致执行过程如下图所示：</li></ul> </li></ul> 
 <p><img src="https://images2.imgbox.com/42/8d/36nvWBM6_o.png" alt="img"></p> 
 <p>图中的6个步骤对应如下：</p> 
 <ol>
<li>先将输入文件分成 M个数据片段，每个数据片段的大小一般从 16MB 到 64MB。然后用户程序在集群中创建大量程序副本。</li>
<li>副本程序中除了一个 master，其他都是 worker 程序，并由 master 分配 M个 map 任务和 R个 reduce 任务。master 将一个 map 任务或 reduce 任务分配给一个空闲的 worker。</li>
<li>被分配了 map 任务的 worker 程序读取对应的输入数据片段，解析并处理键值对，生成并输出中间键值对结果，并缓存在内存缓冲区中。</li>
<li>周期性地，缓冲区中的中间结果会被用户指定的切分（partition）函数（例如<code>hash(key) mod R</code>）切分为 R 个部分，并存入到本地磁盘中。任务完成时，缓存在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给 reduce worker。</li>
<li>Reduce worker 程序接收到 master 程序发来的数据存储位置信息后，使用 RPC 从 map worker 所在主机的磁盘上读取这些缓存数据，然后通过对 key 进行排序后使得具有相同 key 值的数据聚合在一起。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</li>
<li>Reduce worker 程序遍历排序后的中间数据，对于每一个唯一的中间 key 值，reduce worker 将这个 key 值和它相关的 value 值的集合传递给用户自定义的 reduce 函数进行处理，处理输出被追加到所属分区的输出文件。由于是按顺序对排序后的中间数据进行处理，所以每个输出文件分片内部是有序的。</li>
</ol> 
</blockquote> 
<h2>
<a id="23_Chubby_75"></a>2.3 分布式锁服务Chubby</h2> 
<p>Chubby是Google的分布式锁服务。它通过提供粗粒度的锁以及存储小量数据的能力，为Google的其他系统提供协同服务。</p> 
<ul><li>Chubby通信协议(阅读课本P30)</li></ul> 
<p><img src="https://images2.imgbox.com/d5/d4/49OYMMcg_o.jpg" alt=""></p> 
<ul>
<li> <p>主服务器出错</p> 
  <ul><li>在Chubby的通信过程中，客户端通过发送RPC请求与Chubby服务器进行交互。当主服务器出错时，会进行故障转移，由备份服务器接替其角色，保证系统的可用性。</li></ul> </li>
<li> <p>租约机制</p> 
  <ul><li>租约（Lease）机制是Chubby保证服务可用性的重要手段。当一个客户端获得一个锁时，它同时也会获得一个租约，有效期通常是几十秒。只要客户端的租约没有过期，它就可以认为自己持有那个锁。如果客户端在租约期限内向Chubby服务器续租，那么租约可以继续有效。如果服务器没有收到续租请求，就会认为客户端已经崩溃，从而释放锁，允许其他客户端获取。</li></ul> </li>
</ul> 
<blockquote> 
 <p>举个例子，假设你正在用Google Docs编写文档，这时你的同事也想同时编辑这份文档。Chubby锁可以在这个过程中防止你们同时修改同一部分文档，造成冲突。当你编辑一个段落时，你的客户端会获取一个Chubby锁，保证在你编辑这个段落时，其他人无法修改。如果你的租约到期没有续租，Chubby就会认为你已经停止编辑，释放锁，允许其他人编辑这个段落。</p> 
</blockquote> 
<h2>
<a id="24_Bigtable_93"></a>2.4 分布式结构化数据表Bigtable</h2> 
<p>视频：https://www.bilibili.com/video/BV1bj41137BY/</p> 
<p>Bigtable是Google的分布式存储系统，主要用于存储结构化数据。<font color="red">Bigtable主要由三个部分组成：客户端程序库（Client Library）、一个主服务器（Master Server）和多个子表服务器（Tablet Server）。</font></p> 
<p>Bigtable中的数据按照行和列进行组织，每一行由行键（row key）进行唯一标识。</p> 
<h3>
<a id="_101"></a>存储形式</h3> 
<ul>
<li> <p>&lt;行关键字，列关键字，时间戳&gt; -&gt; 内容</p> </li>
<li> <p>行标签如何存储</p> 
  <ul><li>行键在Bigtable中存储的方式是**按字典序排序的（应该是字母顺序的意思），这使得读取相邻的行键的操作变得非常高效。**这种特性使得Bigtable非常适合处理那些需要按照某种范围进行读取的操作。</li></ul> </li>
</ul> 
<p><img src="https://images2.imgbox.com/61/5d/v4AONOoy_o.jpg" alt=""></p> 
<ul><li> <p>行标签的倒排的优点</p> 
  <ul>
<li> <p>同一地址域的网页会被存储在表中的连续位置，有利于用户查找和分析</p> </li>
<li> <p>倒排便于数据压缩，可以大幅提高压缩率</p> </li>
<li> <p>解释一下：</p> 
    <ul>
<li> 
      <blockquote> 
       <p>域名：</p> 
       <ul>
<li>“<a href="http://www.example.com/news">www.example.com/news</a>” 中，“example.com” 是主域名，“www” 是这个主域名下的一个子域名，而 “/news” 是这个子域名下的一个路径或者页面。</li>
<li>“news.example.com” 中，“example.com” 仍然是主域名，但是这次 “news” 是这个主域名下的一个子域名。</li>
</ul> 
       <p>子域名是主域名的一个分支，通常用来表示主域名下的不同功能或服务。比如，很多网站会有 “blog.example.com” 来托管他们的博客，或者 “shop.example.com” 来托管他们的在线商店。</p> 
      </blockquote> </li>
<li> 
      <blockquote> 
       <p>Bigtable 的设计者选择使用倒序的 URL 主要是为了更好地优化对“域名”的查询效率，尤其是当 URL 的子域名层级较多时，例如：</p> 
       <ol>
<li>news.example.com</li>
<li>sports.example.com</li>
<li>finance.example2.com</li>
</ol> 
       <p>如果按照正序 URL 排序，上述三个 URL 中，相同主域名（example.com 或example2.com）的页面不一定会被放在一起，而按照倒序排序则可以做到这一点：</p> 
       <ol>
<li>com.example.news</li>
<li>com.example.sports</li>
<li>com.example2.finance</li>
</ol> 
      </blockquote> </li>
</ul> </li>
</ul> </li></ul> 
<h3>
<a id="_137"></a>主服务器</h3> 
<ul><li> <p><font color="red">主服务器的主要作用</font></p> 
  <ul><li><img src="https://images2.imgbox.com/7e/ce/25LNpsyQ_o.jpg"></li></ul> </li></ul> 
<h3>
<a id="_143"></a>子表</h3> 
<ul>
<li> <p>tablet</p> 
  <ul>
<li>Bigtable中的表由许多组成，这些小块在Bigtable中被称为“tablet”。每个tablet代表了行关键字的一部分范围，这样整个表可以分割成许多并行处理的小块，也就是所谓的“子表”。子表（tablet）有助于实现表的分布式存储和并行处理。</li>
<li>从概念上讲子表就是一系列行的集合</li>
</ul> </li>
<li> <p>子表服务器（tablet server）是Bigtable中负责处理一个或多个子表（tablet）的服务器。它处理子表的读取和写入请求，并在必要时将子表分割成更小的单元。</p> </li>
<li> <p>SSTable</p> 
  <ul><li>SSTable 格式的基本示意 
    <ul>
<li>SSTable 是Google为Bigtable设计的内部数据存储格式。所有的SSTable文件都存储在GFS上，用户可以通过键来查询相应的值。</li>
<li>每个SSTable包含了一系列的块（block）和一个块索引（block index），用于高效地查找和读取数据。</li>
<li><img src="https://images2.imgbox.com/da/39/JgUiQmRr_o.jpg" alt="img"></li>
</ul> </li></ul> </li>
<li> <p>子表实际组成</p> 
  <ul>
<li>一个子表由多个SSTable以及日志文件组成</li>
<li>不同子表的SSTable可以共享</li>
<li>每个子表服务器上仅保存一个日志文件</li>
<li>Bigtable规定将日志的内容按照键值进行排序</li>
<li>每个子表服务器上保存的子表数量可以从几十到上千不等，通常情况下是100个左右</li>
<li><img src="https://images2.imgbox.com/f9/5f/5zKT8asX_o.jpg" alt="img"></li>
</ul> </li>
<li> <p>子表地址组成</p> 
  <ul>
<li>一个子表（tablet）的数据存储在一个或多个SSTable中。每个SSTable存储的都是已经排序的键值对，这种排序特性使得范围查询和顺序读取等操作非常高效。</li>
<li>在子表和SSTable之间有一个重要的映射关系：每个子表知道它的数据被存储在哪些SSTable中。当一个子表服务器需要读取或写入一个子表的数据时，它会使用这个映射关系找到相应的SSTable，然后在SSTable中进行操作。</li>
<li><img src="https://images2.imgbox.com/e8/73/gHV1bocZ_o.jpg" alt="img"></li>
</ul> </li>
<li> <p><font color="red">三种形式的数据压缩</font></p> 
  <ul>
<li>次压缩、合并压缩、主压缩</li>
<li><img src="https://images2.imgbox.com/02/c0/BFG6Gtc5_o.jpg" alt="img"></li>
</ul> </li>
</ul> 
<p>子表的数据最终还是写到GFS里的，子表在GFS里的物理形态就是若干个SSTable文件</p> 
<p>集群包括主服务器和子服务器，主服务器负责将片分配给子服务器，而具体的数据服务则全权由子服务器负责。</p> 
<p>但是不要误以为子服务器真的存储了数据（除了内存中memtable的数据），数据的真实位置只有GFS才知道，主服务器将子表分配给子服务器的意思应该是，子服务器获取了子表的所有SSTable文件名，子服务器通过一些索引机制可以知道所需要的数据在哪个SSTable文件，然后从GFS中读取SSTable文件的数据，这个SSTable文件可能分布在好几台chunkserver上。</p> 
<h3>
<a id="Bigtable__176"></a>Bigtable 相关优化技术</h3> 
<p>Bigtable 使用了一些性能优化的技术：BWT（Burrows-Wheeler Transform）和布隆过滤器。</p> 
<ol>
<li> <p>BWT (Burrows-Wheeler Transform)：它是一种用于数据压缩的算法，主要用于对字符串数据进行变换。在 BWT 中，字符串的字符会按照某种顺序进行排列，然后选择一个新的字符串，这个新的字符串中的字符顺序会提高后续压缩算法（如 move-to-front transform, run-length encoding）的效率。换句话说，BWT 通过改变字符串中字符的顺序，将原本随机分布的字符变得更加集中，从而增加了压缩的效率。值得注意的是，这种变换是可逆的，也就是说经过 BWT 变换和压缩的数据，可以被完整地恢复出来。???</p> </li>
<li> <p>布隆过滤器 (Bloom Filter)：布隆过滤器是一种空间效率极高的概率数据结构，用于检测一个元素是不是集合中的成员。它的主要特点是存在一定的误报率，但绝对不会漏报。误报率是指查询一个不存在于集合中的元素，布隆过滤器可能会错误地认为它在集合中；漏报则是指查询一个存在于集合中的元素，布隆过滤器不会错误地认为它不在集合中。在 Bigtable 中，布隆过滤器用于减少不必要的磁盘读取操作：当我们查询一个元素时，先用布隆过滤器判断一下，如果判断结果为“不在”，则可以避免进行磁盘读取；如果判断结果为“在”，则需要进一步从磁盘读取数据来确定。</p> 
  <ul><li> 
    <blockquote> 
     <p>假设我们有一份电话簿，我们需要判断一个电话号码是否在电话簿中。如果我们直接查询电话簿，那么可能需要翻阅整本电话簿，这需要很长的时间。而如果我们使用布隆过滤器，那么我们可以在很短的时间内得到答案。我们首先将电话簿中的所有电话号码添加到布隆过滤器中，这个过程会生成一个位数组。然后，当我们需要查询一个电话号码是否在电话簿中时，我们只需要查询这个位数组即可。如果布隆过滤器判断结果为“不在”，那么我们就可以确定这个电话号码肯定不在电话簿中，从而避免了不必要的查询。如果布隆过滤器判断结果为“在”，那么我们还需要进一步查询电话簿来确定。这样，大多数情况下，我们可以在很短的时间内得到答案，从而大大提高了查询效率。</p> 
    </blockquote> </li></ul> </li>
</ol> 
<p>总的来说，BWT 是用于提高数据压缩效率的算法，而布隆过滤器是用于减少不必要的磁盘读取，从而提高查询效率的数据结构。两者在 Bigtable 中都发挥了重要的作用。</p> 
<h2>
<a id="25_Megastore_190"></a>2.5 分布式存储系统Megastore</h2> 
<p>https://www.jianshu.com/p/7c4d0ab911f6</p> 
<h3>
<a id="Megastore_194"></a>Megastore</h3> 
<p>Megastore是Google的一个分布式存储系统，它是在Bigtable基础之上构建的，为用户提供了包括ACID事务在内的一些关系数据库特性。</p> 
<p>Megastore的基本架构包括以下几个部分：</p> 
<ul>
<li> <p>Entity Group: Megastore将数据组织为实体组（Entity Group），每个实体组内部都是按照Bigtable的方式存储的，<strong>每个实体组都可以提供ACID语义的事务</strong>（就像一个小的数据库）。实体组之间则无法提供ACID事务。</p> </li>
<li> <p>Replicas: 为了提高数据的可用性和容错能力，Megastore会将每个实体组的数据复制到多个物理位置。</p> </li>
<li> <p>Paxos: Megastore使用Paxos算法来保证每个实体组的多个副本之间的一致性。Megastore的每个写操作都需要经过Paxos的多数派同意才能提交。</p> </li>
<li> <p><strong>Catch-up</strong>: 为了保证不同地域之间数据的一致性，Megastore提供了Catch-up机制，即当某个副本落后于其他副本时，它可以通过Catch-up过程来获取丢失的更新。</p> </li>
<li> <p>Product: Megastore被广泛应用在Google的许多产品中，例如Google App Engine的数据存储就是基于Megastore实现的。</p> </li>
</ul> 
<h3>
<a id="ACID_211"></a>ACID语义</h3> 
<p>ACID是指数据库事务正确执行的四个基本特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p> 
<ol>
<li> <p><strong>A(Atomicity）原子性</strong>：这是指整个事务是不可分割的单位，事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务的操作，系统保证所有操作要么全部完成，要么全部不做，不可能停滞在中间环节。事务的原子性是通过Undo和Redo来实现的。</p> </li>
<li> <p><strong>C (Consistency)一致性</strong>：事务必须使数据库从一个一致性状态变换到另一个一致性状态。一致性与业务有关，如A账户给B账户转账，不管转账是否成功，A账户的出账金额与B账户的进账金额必须一致，这就是业务一致性。</p> </li>
<li> <p><strong>I (lsolation)- 隔离性</strong>：当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这使得每个事务都感觉不到系统中有其他事务并行执行。</p> </li>
<li> <p><strong>D (Durability) 持久性</strong>：一旦事务提交，则其所做的修改就会永久保存在数据库中。即使在事务提交后，系统出现崩溃，重新启动后也能保证事务的持久性。</p> </li>
</ol> 
<h3>
<a id="_221"></a>基本架构</h3> 
<p><img src="https://images2.imgbox.com/38/a8/8yBkTBtq_o.png" alt="img"></p> 
<ul>
<li> <p><strong>完整副本</strong>：Bigtable中<strong>存储完整的日志和数据</strong>。</p> </li>
<li> <p><strong>见证者副本</strong>：在Paxos算法执行过程中<strong>无法产生一个决议时参与投票</strong>，因此对于这个副本，Bigtable<strong>只存储其日志而不存储具体数据</strong>。</p> </li>
<li> <p><strong>只读副本</strong>：<strong>无法参与投票</strong>，作用只是读取到最近过去某一个时间点的一致性数据。如果读操作能容忍这些过期数据，只读副本能够在不加剧写延迟的情况下将数据在较大的地理空间上进行传输。</p> </li>
<li> <p>Megastore的部署需要通过一个<strong>客户端函数库和若干个的服务器</strong>。应用程序连接到这个客户端函数库，这个函数库执行Paxos算法，还有一个称为协调者（Fast Reads）的服务，要理解这个服务的作用，首先需要了解快速读和快速写机制<img src="https://images2.imgbox.com/7a/fe/KjkmhWeu_o.png" alt="img"></p> </li>
<li> 
  <blockquote> 
   <p>你可以把 Megastore 想象成一个超大的图书馆，这个图书馆在全球有很多分馆，也就是服务器。在这些分馆中，有些图书馆（完整副本）储存了全部的书籍和详细的借阅记录。还有一些图书馆（见证者副本）并没有储存书籍，但他们记录了所有的借阅行为。另外，还有一些图书馆（只读副本）只允许读者阅读书籍，但并不记录借阅信息。当读者想借书时，就需要连接到客户端函数库（即借阅台），借阅台会执行一套流程（类似Paxos算法）来保证借书的流程正确无误。协调者服务就像一个快速查询服务，能快速告诉你想找的书在哪里，这就是快速读的机制。</p> 
  </blockquote> </li>
</ul> 
<h3>
<a id="_235"></a>核心技术-复制</h3> 
<ul>
<li> <p>数据读取：</p> </li>
<li> <p>在一次Current读之前，**要保证至少有一个副本上的数据是最新的，也就是说所有之前提交到日志中的更新必须到该副本上并确保在该副本上生效。**这个过程称为追赶（Catchup）</p> </li>
<li> <p><img src="https://images2.imgbox.com/31/a1/YXEMpVlb_o.png" alt="img"></p> </li>
</ul> 
<blockquote> 
 <p>把这个过程想象成你去超市购物。你手上有一个购物清单，这个清单在你进超市之前需要保证是最新的，也就是说你在家里做的所有的改动（比如添加或删除某个商品）都已经更新到这个清单上，这个过程就是Catchup。然后你按照清单在超市进行购物，这就是数据读取的过程。如果在购物过程中，你突然发现清单上少了某个商品，那么你就需要回家再次更新清单，这就是保证清单（也就是副本）是最新的。</p> 
</blockquote> 
<h1>
<a id="_Amazon_AWS_244"></a>第三章 Amazon AWS</h1> 
<h2>
<a id="31_Dynamo_246"></a>3.1 Dynamo</h2> 
<p><a href="https://www.jianshu.com/p/f6384d11aa73">云计算 | AWS | Dynamo</a></p> 
<ul>
<li> <p>Dynamo</p> 
  <ul>
<li>底层存储架构，只支持简单的键值对存储</li>
<li>无中心的模式</li>
<li>中心思想：Dynamo是通过在数据中心进行分布式存储来实现高可用性和扩展性。</li>
<li>架构形式：Dynamo采用了一致性哈希算法进行数据分布，使得系统可以在节点动态变化时，平衡负载并最小化数据迁移</li>
</ul> </li>
<li> 
  <blockquote> 
   <p>Windows Azure是一个基于云的应用程序执行环境，提供了计算服务、存储服务以及与应用程序通信的各种服务。在Azure中，存储层使用了多副本复制机制，通过复制数据到不同的物理节点来实现数据的持久性和可靠性。</p> 
   <p>两者的主要区别在于其设计目标和实现方法。Dynamo注重高可用性和扩展性，适合非结构化数据，使用了最终一致性模型；而Azure是一个更通用的平台，提供了计算、存储和通信等服务，适合存储结构化数据，并使用了强一致性模型。</p> 
  </blockquote> </li>
</ul> 
<h3>
<a id="_261"></a>一致性哈希算法</h3> 
<ul><li>一致性哈希算法:<a href="https://www.bilibili.com/video/BV1Hs411j73w/">好刚: 7分钟视频详解一致性hash 算法</a> 
  <ul>
<li>一致性哈希算法中，虚拟节点和物理节点的关系可以简单理解为：每个物理节点对应多个虚拟节点，每个虚拟节点存放一部分物理节点的数据。通过增加虚拟节点，我们可以在物理节点数量变化时，平均分布负载，并且最小化需要迁移的数据量。</li>
<li>使用越多的虚拟节点有以下几个好处： 
    <ul>
<li>1）能够更平均地分布数据，减少数据倾斜问题。这是因为在现实中每一个物理节点的性能不一定相同，引入虚拟节点可以使得不同性能的节点承受不同的负载；</li>
<li>2）当增加或删除物理节点时，只需要迁移少量的数据，减少了数据迁移的开销；</li>
<li>3）提高了系统的可扩展性和稳定性。</li>
</ul> </li>
<li>在一致性哈希算法中，查找特定键（key）的复杂度通常是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            O 
           
          
            ( 
           
          
            l 
           
          
            o 
           
          
            g 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
            ) 
           
          
         
           O(log(n)) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal" style="margin-right: 0.0278em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span>，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            n 
           
          
         
           n 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em"></span><span class="mord mathnormal">n</span></span></span></span></span>是哈希环中节点（服务器）的数量。</li>
<li>一致性哈希算法可以进一步改进，例如通过引入复制和数据分片机制，可以进一步提高系统的可用性和数据安全性。</li>
</ul> </li></ul> 
<h3>
<a id="_272"></a>冗余备份</h3> 
<ul>
<li>参数可调的弱Quorum机制 
  <ul><li>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            R 
           
          
            + 
           
          
            W 
           
          
            &gt; 
           
          
            N 
           
          
         
           R+W&gt;N 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em;vertical-align: -0.0833em"></span><span class="mord mathnormal" style="margin-right: 0.0077em">R</span><span class="mspace" style="margin-right: 0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em"></span></span><span class="base"><span class="strut" style="height: 0.7224em;vertical-align: -0.0391em"></span><span class="mord mathnormal" style="margin-right: 0.1389em">W</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 0.6833em"></span><span class="mord mathnormal" style="margin-right: 0.109em">N</span></span></span></span></span>可以保证当存在故障的节点数量不超过1台时，用户至少可以获得一份最新的数据副本。其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            W 
           
          
         
           W 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em"></span><span class="mord mathnormal" style="margin-right: 0.1389em">W</span></span></span></span></span>表示一次成功的写操作至少需要写入的副本数，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            R 
           
          
         
           R 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em"></span><span class="mord mathnormal" style="margin-right: 0.0077em">R</span></span></span></span></span>表示一次成功读操作须由服务器返回给用户的最小副本数，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            N 
           
          
         
           N 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em"></span><span class="mord mathnormal" style="margin-right: 0.109em">N</span></span></span></span></span>表示每个数据存储的副本数。</li></ul> </li>
<li>为什么冗余备份可以提升数据安全性 
  <ul>
<li>冗余备份是一种常见的保护数据安全和可用性的手段。冗余备份的原理是在多个地方存储数据的副本。如果某个存储地方发生故障，数据丢失或损坏，那么可以从其他地方获取该数据的副本。例如，DynamoDB通过在多个可用区中存储数据副本来提供高可用性和数据持久性。</li>
<li>实际上，冗余备份不仅可以提高数据的安全性，同时也能增加数据的可用性。当某个存储节点故障时，系统可以快速地从其他存储节点中获取数据，避免因为单点故障而导致的系统不可用。</li>
</ul> </li>
</ul> 
<h3>
<a id="_280"></a>成员资格和错误检测</h3> 
<p>P96</p> 
<ul>
<li> <p>Dynamo是无中心的架构，每个成员节点需要保存其他节点的路由信息</p> </li>
<li> <p>在分布式系统中，成员资格和错误检测是非常重要的问题。成员资格是指确定系统中有哪些节点正在参与运行。错误检测是指确定系统中哪些节点可能发生了故障。</p> </li>
<li> <p><strong>成员资格（Membership）</strong> 是指在一个分布式系统中，确定哪些节点是活跃的，也就是当前正在参与运行的节点。由于在一个分布式系统中，节点可能会因为故障或者其他原因离线，所以需要一个机制来跟踪和识别出哪些节点是在线的。</p> 
  <ul><li>假设你正在参与一个多人在线游戏，这个游戏的服务器是分布式的。每个玩家都会连接到一个服务器节点。这个时候，成员资格就是要识别出哪些玩家（节点）当前在线，参与了这个游戏。</li></ul> </li>
<li> <p><strong>错误检测（Failure Detection）</strong>：是指在分布式系统中，识别出哪些节点发生了故障。这是因为在一个大规模的分布式系统中，故障是常态。可能由于硬件故障、网络问题等各种原因导致某些节点无法工作。</p> 
  <ul><li>继续以上面的游戏为例，假设在你的队伍中，有一名玩家突然离线了（可能是因为网络故障、电脑死机等原因）。错误检测的任务，就是尽快发现这个玩家已经离线，以便游戏可以采取相应的措施（例如让AI接管，或者寻找新的玩家加入等）。</li></ul> </li>
</ul> 
<p>成员资格和错误检测通常是通过一种名为"<strong>Gossip（闲聊）</strong>"的协议来实现的。在这个机制中，每个节点周期性地向其他节点发送消息，表示它还“活着”。如果某个节点在一段时间内没有收到另一个节点的消息，那么它就会认为那个节点已经离线或发生了故障。</p> 
<ul><li>假如一个新节点加入节点总数为N的系统，并以最优的方式进行传播（即每次通信的两个节点都是第一次交换节点信息），那么将新节点传遍整个系统需要的时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          l 
         
        
          o 
         
        
          g 
         
        
          n 
         
        
          ) 
         
        
       
         O(logn) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal" style="margin-right: 0.0278em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
</li></ul> 
<p><img src="https://images2.imgbox.com/b7/af/MLA4kQRw_o.jpg" alt=""></p> 
<h2>
<a id="32_EC2_302"></a>3.2 弹性计算云EC2</h2> 
<ul>
<li> <p>地理区域和可用区域</p> </li>
<li> <p>EC2是Amazon的Elastic Compute Cloud的简称，提供了可伸缩的计算能力。用户可以在Amazon的计算环境中虚拟机器上启动应用程序。各种各样的服务，比如提供GPU</p> </li>
<li> <p>AWS全球基础设施是分布在世界各地的云基础设施。这些基础设施包括地理区域和可用区域。</p> 
  <ul>
<li>地理区域是AWS云在全球的物理位置，每个区域都包含至少两个可用区域。</li>
<li>可用区域是指代表在地理上分离的<strong>数据中心</strong>，但在网络延迟低的同一地理区域内。通常根据是否有独立的供电系统和冷却系统等进行划分。</li>
<li>EC2包含多个地理区域，每个地理区域又包含多个可用区域。</li>
</ul> </li>
<li> <p>在应用架构中融入这种思想，就可以提高应用的可用性和容灾能力。例如，通过在多个可用区域部署应用，即使某个可用区域出现问题，应用也可以在其他可用区域正常运行。</p> </li>
</ul> 
<h2>
<a id="33S3_317"></a>3.3简单存储服务S3</h2> 
<p>S3即Simple Storage Service，是Amazon提供的一种对象存储服务，它以对象为单位，提供了在互联网上存储和检索任意数量的数据的能力。</p> 
<ul>
<li>
<strong>桶（Bucket）</strong>：桶在Amazon S3中就像是文件夹或目录，它用来存储对象（数据）。每个桶在S3中都有一个全局唯一的名称，并且所有存储在S3中的对象都必须包含在某个桶中。用户可以设置桶的访问权限，控制哪些用户可以访问桶中的对象。桶也可以配置为在特定的地理区域存储数据。</li>
<li>
<strong>对象（Object）</strong>：对象主要由数据和元数据组成，是桶中的基本元素，类似于文件。每个对象都包含了文件本身的数据和一些元数据（比如文件的类型，创建日期等）。<strong>在S3中，对象被唯一地识别通过其在桶中的键（key）</strong>，这类似于在文件系统中，一个文件被其路径和文件名唯一识别。</li>
</ul> 
<blockquote> 
 <p>我们可以把桶和对象的关系，类比为现实生活中的一个大仓库（Bucket）和仓库里的各种商品（Object）。仓库是用来存放各种商品的地方，而商品则是仓库中的基本单位。每个商品都有自己的标签（例如商品的名称，生产日期等等），这就像是对象的元数据。而在仓库中，每个商品都有其固定的位置，这就像是对象在S3桶中的键。</p> 
 <p>在这个例子中，如果我们想找到特定的商品，我们首先需要知道它在哪个仓库（桶），然后根据商品的标签（元数据）或者位置（键），就可以找到这个商品（对象）。</p> 
</blockquote> 
<h2>
<a id="34__328"></a>3.4 非关系型数据库</h2> 
<p>其与关系型数据库的区别</p> 
<p>课本P108</p> 
<ul>
<li>
<strong>关系型数据库</strong>：如MySQL, PostgreSQL等，是基于关系模型的数据库，其中数据以<strong>表格</strong>的形式存储。关系型数据库强调数据的一致性和事务性，并<strong>遵循ACID原则</strong>（原子性，一致性，隔离性，持久性）。这类数据库适合有复杂查询需求的应用，例如联接、分组和聚合等。</li>
<li>
<strong>非关系型数据库（如SimpleDB, DynamoDB）</strong>：非关系型数据库，也称为NoSQL数据库，它们主要设计用于处理大规模数据，可以提供高吞吐量、低延迟数据访问和存储。这类数据库通常不支持或只提供有限的事务功能，并且可能不遵循ACID原则，而是遵循BASE原则（基本可用性，软状态，最终一致性）。例如，DynamoDB是一个键值存储系统，它以其弹性伸缩性和可预测的性能著名。</li>
</ul> 
<h2>
<a id="35_RDS_337"></a>3.5 关系数据库服务RDS</h2> 
<p>AWS为MySQL提供了一种称为Amazon RDS的托管服务。它处理数据库的许多日常管理任务，如备份、打补丁和故障转移等。用户可以选择在单个可用区内运行RDS实例，或者为了更高的可用性和容错能力，可以在多个可用区之间进行复制。</p> 
<blockquote> 
 <p>RDS（Relational Database Service）是Amazon Web Services (AWS) 提供的一种关系型数据库服务。MySQL则是一种开源的关系型数据库管理系统（RDBMS）。因此，你可以将MySQL看作是一种"产品"，而RDS是一个"服务"。</p> 
 <p>在RDS服务中，你可以选择不同类型的数据库引擎，包括MySQL、PostgreSQL、MariaDB、Oracle、SQL Server等。因此，MySQL是RDS支持的数据库之一。使用AWS的RDS服务，用户可以很方便地部署、扩展和管理数据库。RDS会为用户处理很多数据库运维的工作，如备份、软件补丁更新、故障转移等。</p> 
 <p>简单地说，你可以直接下载并在自己的服务器上安装运行MySQL，这需要你自己处理所有的维护和管理工作。而如果你选择使用AWS的RDS服务并选择MySQL作为数据库引擎，那么AWS会帮你处理许多运维任务，你只需要专注于使用数据库。</p> 
</blockquote> 
<h2>
<a id="36_CloudFront_347"></a>3.6 内容推送服务CloudFront</h2> 
<p>CDN，也就是内容分发网络，是一种在不同地理位置的服务器上复制内容，以便用户能更快地访问到它的服务。通过使用CDN，你可以将你的内容更靠近你的用户，这样他们获取内容的速度就会更快。</p> 
<p>区别：</p> 
<p>Amazon CloudFront和Azure CDN都是这种服务的例子。他们都可以把你的内容（例如网站的静态和动态内容，视频流，API调用等）缓存在全球范围内的边缘位置，以便更快地将内容提供给用户。</p> 
<p>？？？这俩的区别是啥，Azure应该是有缓存的</p> 
<blockquote> 
 <p>举个例子，假设你在美国东部有一个网站，你的用户遍布全球。如果没有使用CDN，来自澳大利亚的用户需要将请求发送到美国东部的服务器，然后再将结果返回。这会增加延迟。但是，如果你使用了CDN，你的网站内容将被复制到全球各地的服务器，包括澳大利亚。因此，来自澳大利亚的用户现在可以从他们附近的服务器获取内容，从而显著减少延迟。</p> 
</blockquote> 
<h1>
<a id="_Azure_363"></a>第四章 微软的云计算服务Azure</h1> 
<h2>
<a id="41__367"></a>4.1 五个部分</h2> 
<ul><li>先来一个类比</li></ul> 
<ol>
<li>
<strong>计算服务</strong>：你可以把 <strong>Azure 中的计算服务看作是租赁的电脑</strong>。就像你在网吧租用一台电脑，你可以在上面做任何你想做的事情，比如浏览网页，编写代码，甚至运行服务器。Azure 提供的计算服务就是让你租用一台云上的电脑，你可以在上面运行你的应用程序</li>
<li>
<strong>存储服务</strong>：Azure 中的<strong>存储服务就像是你租用的仓库</strong>，你可以在里面存储任何你想保存的东西。Azure 提供了 <strong>Blob</strong>（类似于一个大箱子，可以放任何东西），<strong>表</strong>存储（像一个巨大的Excel表格，用来存储结构化数据），<strong>队列</strong>存储（就像是一个排队系统，用来存储待处理的消息），还有磁盘存储（就像你电脑的硬盘，用来存储各种文件和数据）。</li>
<li>
<strong>Fabric 控制器</strong>：<strong>Fabric 控制器</strong>就像是一个智能的建筑管理员或者是楼宇经理。它<strong>负责协调和管理云服务中的资源，如服务器、网络和存储</strong>。就像楼宇经理决定哪个公司租用哪个办公室，电力如何分配，网络连接如何配置一样，Fabric 控制器负责配置和管理 Azure 服务实例的生命周期，分配和管理网络和存储资源。</li>
<li>
<strong>内容分发网络（CDN）</strong>：Azure 的 CDN 就像是全球范围的连锁便利店。假设你在纽约有一个面包店，你的面包非常受欢迎，全世界的人都想吃。但是，让一个在澳大利亚的人来纽约买面包不现实。所以，你决定在全世界各地开设分店，这样每个人都可以在他们附近的店铺买到新鲜的面包。这就是 Azure CDN 做的事情，<strong>它将你的内容（网站、视频、软件等）缓存到全球各地的节点上</strong>，当用户请求这些内容时，可以从最近的节点获取，提高访问速度。</li>
<li>
<strong>Windows Azure Connect</strong>：Azure Connect 就像是一座桥，<strong>它可以把你的本地网络和 Azure 的虚拟网络连接在一起</strong>。假设你有两个岛屿，一个在本地（你的本地网络），另一个在云端（Azure 的虚拟网络）。你需要一个桥梁来把两个岛屿连接起来，这样你就可以方便地在两个岛屿之间通行。Azure Connect 就是这座桥梁，它让你可以在本地网络和云网络之间安全、方便地传输数据。</li>
</ol> 
<ul><li>具体定义</li></ul> 
<ol>
<li>
<strong>计算服务（Compute）</strong>: 提供用于运行应用程序的虚拟机（VM），支持不同的操作系统，和多种编程语言，可以按需扩展。</li>
<li>
<strong>存储服务（Storage）</strong>: 提供大规模、高可用、持久的云存储，包括 Blob（对象）存储，文件存储，队列存储，表存储和磁盘存储。</li>
<li>
<strong>Fabric 控制器</strong>：主要用于部署、管理和监控应用。</li>
<li>
<strong>CDN (Content Delivery Network)</strong>: 提供全球性内容分发网络服务，通过缓存内容到全球范围内的边缘节点，来优化用户获取数据的速度。</li>
<li>
<strong>网络服务（Networking）</strong>: 提供虚拟网络，负载均衡，VPN，流量管理等网络功能，<strong>帮助您在云和本地环境之间建立安全和私有的连接</strong>。</li>
</ol> 
<h2>
<a id="42__387"></a>4.2 三个实例</h2> 
<p>Azure 服务平台为应用程序提供了三种类型的角色（Role）来运行代码：Web Role、Worker Role 和 VM Role。这些角色定义了运行在 Azure 服务平台上的应用程序实例的运行环境。</p> 
<ol>
<li>
<strong>Web Role</strong>: 提供了一个自动管理的、托管的IIS环境。开发者可以发布ASP.NET、WCF服务或其他IIS兼容的应用到Web Role中，用于处理用户的HTTP/HTTPS请求。</li>
<li>
<strong>Worker Role</strong>: 提供了一个通用的Windows环境，开发者可以在其中运行任何类型的程序。Worker Role常常作为后台处理任务的角色，比如处理来自Web Role的数据，运行脚本或者其他长时间运行的任务。</li>
<li>
<strong>VM Role</strong>: 提供了更高自由度的虚拟机环境，用户可以按需自定义VM Role的Windows环境，安装所需的应用程序，以运行特定的任务或服务。</li>
</ol> 
<blockquote> 
 <ol>
<li>
<strong>Web Role</strong>: Web Role就像是一家提供餐饮服务的餐厅。它可以接受和处理客户端（用户）的请求，类似于餐厅为饿了的人提供食物。在Azure中，Web Role是一种运行在微软公共云环境中的服务，专门处理外部HTTP或HTTPS请求，就像在餐厅中处理订单一样。</li>
<li>
<strong>Worker Role</strong>: Worker Role就像是餐厅后厨的厨师，负责烹饪食物。在Azure中，Worker Role则是执行在后台运行的任务，如处理来自Web Role的数据，运行脚本或者其他长时间运行的任务。它们就像厨师，把原材料（数据）加工成美食（有用的信息）。</li>
<li>
<strong>VM Role</strong>: VM Role就像是租用的公寓，你可以按照自己的需求装修，放置家具。在Azure中，VM Role提供的是一种虚拟机环境，用户可以按照自己的需求来配置这个环境，安装所需要的软件。这种角色让用户有更大的自由度来定义他们的云服务环境，就像你可以在租用的公寓中自由布置一样。</li>
</ol> 
</blockquote> 
<h2>
<a id="43__403"></a>4.3 数据结构</h2> 
<ol>
<li>
<strong>Blob</strong>：用于存储大量的非结构化数据，如图片、音频、视频或日志文件等。</li>
<li>
<strong>Table</strong>：提供了可扩展的非关系型结构化数据存储，适用于存储大量的非关系型数据。</li>
<li>
<strong>Queue</strong>：提供了可扩展的消息队列服务，用于在应用程序之间异步传递消息。</li>
</ol> 
<h2>
<a id="44__409"></a>4.4 轮幅备份思想</h2> 
<p>不同的SQL Azure数据库之间的同步是使用“轮幅式（hub-and-spoke）”模型</p> 
<p>在这个模型中，中心节点（Hub）负责接收和分发数据，边缘节点（Spokes）则负责存储数据。</p> 
<blockquote> 
 <p>这里Hub是SQL Azure数据库，其他的Hub可以是SQL Azure数据库、也可以是SQL Server数据库</p> 
</blockquote> 
<p>我们可以将这个模型比喻为航空公司的路线网络。在这个例子中，航空公司的大型中枢机场（例如亚特兰大机场或者阿姆斯特丹机场）就像是中心节点，其他较小的机场就像是边缘节点。所有的航班（数据）都会经过中枢机场（Hub）然后被分发到不同的目的地（Spokes）。</p> 
<p>在Azure的数据中心网络中，也采用了类似的模型。其中的主数据中心（Hub）负责接收所有的用户数据，并将数据同步到各个边缘数据中心（Spokes）。这样，无论用户在哪里访问数据，都可以得到最快的响应时间，因为他们总是从最近的数据中心获取数据。</p> 
<p>而且，如果某个边缘数据中心发生故障，用户的数据仍然可以从主数据中心或者其他边缘数据中心获取，这样确保了数据的可用性和一致性。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>