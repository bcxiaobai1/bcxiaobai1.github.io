<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>2021版 | 60道Java基础面试题，来看看你能记住多少 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2021版 | 60道Java基础面试题，来看看你能记住多少</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    
                        
                    
                    <blockquote> 
 <p>✨<strong>感激相遇 你好 我是阿ken</strong><br><br> <strong>? 公号内置：「Java、Python、前端等学习路线及电子书」，另有「升本习题、教材电子书、各科学霸笔记」</strong><br><br> ? <font color="red"><strong>领取方式：「文末点开扫码」即可「自行免费领取」</strong></font></p> 
</blockquote> 
<p></p>
<div class="toc">
 <h3>「点击下方目录可自动跳转」</h3>
 <ul><li>
<ul>
<li><a href="#Java__9">一、Java 基础</a></li>
<li>
<ul>
<li><a href="#1__10">1. 面向对象和面向过程的区别</a></li>
<li><a href="#2_Java_23">2. Java语言有哪些特点？</a></li>
<li><a href="#3_JavaJava_26">3. 什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？什么是Java程序的主类？应用程序和小程序的主类有何不同？</a></li>
<li><a href="#4_JDK__JRE__42">4. JDK 和 JRE 有什么区别？</a></li>
<li><a href="#5___equals__45">5. == 和 equals 的区别是什么？</a></li>
<li><a href="#6__hashCode_equals_true_48">6. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</a></li>
<li><a href="#7_final__java__51">7. final 在 java 中有什么作用？</a></li>
<li><a href="#8_java__Mathround15__54">8. java 中的 Math.round(-1.5) 等于多少？</a></li>
<li><a href="#9_String__57">9. String 属于基础的数据类型吗？</a></li>
<li><a href="#10_java__60">10. java 中操作字符串都有哪些类？它们之间有什么区别？</a></li>
<li><a href="#11_String_stri_String_strnew_Stringi_63">11. String str="i"与 String str=new String("i")一样吗？</a></li>
<li><a href="#12__66">12. 如何将字符串反转？</a></li>
<li><a href="#13_String__69">13. String 类的常用方法都有那些？</a></li>
<li><a href="#14__72">14. 抽象类必须要有抽象方法吗？</a></li>
<li><a href="#15__final__75">15. 抽象类能使用 final 修饰吗？</a></li>
<li><a href="#16__78">16. 接口和抽象类有什么区别？</a></li>
<li><a href="#17_java__IO__81">17. java 中 IO 流分为几种？</a></li>
<li><a href="#18_BIONIOAIO__84">18. BIO、NIO、AIO 有什么区别？</a></li>
<li><a href="#19_Files_87">19. Files的常用方法都有哪些？</a></li>
</ul>
   </li>
<li><a href="#_90">二、容器</a></li>
<li>
<ul>
<li><a href="#20_java__92">20. java 容器都有哪些？常用容器的图录：</a></li>
<li><a href="#21_Collection__Collections__96">21. Collection 和 Collections 有什么区别？</a></li>
<li><a href="#22_ListSetMap__99">22. List、Set、Map 之间的区别是什么？</a></li>
<li><a href="#23_HashMap__Hashtable__103">23. HashMap 和 Hashtable 有什么区别？</a></li>
<li><a href="#24__HashMap__TreeMap_106">24. 如何决定使用 HashMap 还是 TreeMap？</a></li>
<li><a href="#25__HashMap__109">25. 说一下 HashMap 的实现原理？</a></li>
<li><a href="#26_ArrayList__LinkedList__112">26. ArrayList 和 LinkedList 的区别是什么？</a></li>
<li><a href="#27__List__115">27. 如何实现数组和 List 之间的转换？</a></li>
<li><a href="#28_ArrayList__Vector__118">28. ArrayList 和 Vector 的区别是什么？</a></li>
<li><a href="#29_Array__ArrayList__121">29. Array 和 ArrayList 有何区别？</a></li>
<li><a href="#30__Queue__poll_remove_124">30. 在 Queue 中 poll()和 remove()有什么区别？</a></li>
<li><a href="#31__127">31. 哪些集合类是线程安全的？</a></li>
<li><a href="#32__Iterator__130">32. 迭代器 Iterator 是什么？</a></li>
<li><a href="#33_Iterator__133">33. Iterator 怎么使用？有什么特点？</a></li>
<li><a href="#34_Iterator__ListIterator__136">34. Iterator 和 ListIterator 有什么区别？</a></li>
</ul>
   </li>
<li><a href="#_139">三、多线程</a></li>
<li>
<ul>
<li><a href="#35__141">35. 并行和并发有什么区别？</a></li>
<li><a href="#36__144">36. 线程和进程的区别？</a></li>
<li><a href="#37__147">37. 守护线程是什么？</a></li>
<li><a href="#38__150">38. 创建线程有哪几种方式？</a></li>
<li><a href="#39__runnable__callable__153">39. 说一下 runnable 和 callable 有什么区别？</a></li>
<li><a href="#40__156">40. 线程有哪些状态？</a></li>
<li><a href="#41_sleep__wait__159">41. sleep() 和 wait() 有什么区别？</a></li>
<li><a href="#42_notify_notifyAll_162">42. notify()和 notifyAll()有什么区别？</a></li>
<li><a href="#43__run_start_165">43. 线程的 run()和 start()有什么区别？</a></li>
<li><a href="#44__168">44. 创建线程池有哪几种方式？</a></li>
<li><a href="#45__174">45. 线程池都有哪些状态？</a></li>
<li><a href="#46__submit_execute_179">46. 线程池中 submit()和 execute()方法有什么区别？</a></li>
<li><a href="#47__java__182">47. 在 java 程序中怎么保证多线程的运行安全？</a></li>
<li><a href="#48__185">48. 多线程锁的升级原理是什么？</a></li>
<li><a href="#49__190">49. 什么是死锁？</a></li>
<li><a href="#50__193">50. 怎么防止死锁？</a></li>
<li><a href="#51_ThreadLocal__196">51. ThreadLocal 是什么？</a></li>
<li><a href="#52__synchronized__200">52. 说一下 synchronized 底层实现原理？</a></li>
<li><a href="#53_synchronized__volatile__203">53. synchronized 和 volatile 的区别是什么？</a></li>
<li><a href="#54_synchronized__Lock__206">54. synchronized 和 Lock 有什么区别？</a></li>
<li><a href="#55_synchronized__ReentrantLock__209">55. synchronized 和 ReentrantLock 区别是什么？</a></li>
<li><a href="#56__atomic__212">56. 说一下 atomic 的原理？</a></li>
</ul>
   </li>
<li><a href="#_215">四、反射</a></li>
<li>
<ul>
<li><a href="#57__217">57. 什么是反射？</a></li>
<li><a href="#58__java__220">58. 什么是 java 序列化？</a></li>
<li><a href="#59__223">59. 动态代理是什么？有哪些应用？</a></li>
<li><a href="#60__226">60. 怎么实现动态代理？</a></li>
</ul>
  </li>
</ul>
 </li></ul>
</div>
<p></p> 
<h2>
<a id="Java__9"></a>一、Java 基础</h2> 
<h3>
<a id="1__10"></a>1. 面向对象和面向过程的区别</h3> 
<p>面向过程：</p> 
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p> 
<p>缺点：没有面向对象易维护、易复用、易扩展</p> 
<p>面向对象：</p> 
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p> 
<p>缺点：性能比面向过程低</p> 
<h3>
<a id="2_Java_23"></a>2. Java语言有哪些特点？</h3> 
<p>1，简单易学；2，面向对象（封装，继承，多态）；3，平台无关性（Java虚拟机实现平台无关性）；4，可靠性；5，安全性；6，支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）；7，支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；8，编译与解释并存；</p> 
<h3>
<a id="3_JavaJava_26"></a>3. 什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3> 
<p>先看下java中的编译器和解释器：</p> 
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p> 
<p>Java源代码----&gt;编译器----&gt;jvm可执行的Java字节码(即虚拟指令)----&gt;jvm----&gt;jvm中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。</p> 
<p>采用字节码的好处：</p> 
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p> 
<p>什么是Java虚拟机<br> 　　任何一种可以运行Java字节码的软件均可看成是Java的虚拟机（JVM）<br> 　　<br> 什么是Java程序的主类？应用程序和小程序的主类有何不同？<br> 　　一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p> 
<h3>
<a id="4_JDK__JRE__42"></a>4. JDK 和 JRE 有什么区别？</h3> 
<p>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p> 
<h3>
<a id="5___equals__45"></a>5. == 和 equals 的区别是什么？</h3> 
<p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p> 
<h3>
<a id="6__hashCode_equals_true_48"></a>6. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h3> 
<p>不对，两个对象的 hashCode()相同，equals()不一定 true。代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p> 
<h3>
<a id="7_final__java__51"></a>7. final 在 java 中有什么作用？</h3> 
<p>final 修饰的类叫最终类，该类不能被继承。final 修饰的方法不能被重写。final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p> 
<h3>
<a id="8_java__Mathround15__54"></a>8. java 中的 Math.round(-1.5) 等于多少？</h3> 
<p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p> 
<h3>
<a id="9_String__57"></a>9. String 属于基础的数据类型吗？</h3> 
<p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p> 
<h3>
<a id="10_java__60"></a>10. java 中操作字符串都有哪些类？它们之间有什么区别？</h3> 
<p>操作字符串的类有：String、StringBuffer、StringBuilder。String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p> 
<h3>
<a id="11_String_stri_String_strnew_Stringi_63"></a>11. String str="i"与 String str=new String(“i”)一样吗？</h3> 
<p>不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p> 
<h3>
<a id="12__66"></a>12. 如何将字符串反转？</h3> 
<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p> 
<h3>
<a id="13_String__69"></a>13. String 类的常用方法都有那些？</h3> 
<p>indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 byte 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。</p> 
<h3>
<a id="14__72"></a>14. 抽象类必须要有抽象方法吗？</h3> 
<p>不需要，抽象类不一定非要有抽象方法。普通类不能包含抽象方法，抽象类可以包含抽象方法。抽象类不能直接实例化，普通类可以直接实例化。</p> 
<h3>
<a id="15__final__75"></a>15. 抽象类能使用 final 修饰吗？</h3> 
<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p> 
<h3>
<a id="16__78"></a>16. 接口和抽象类有什么区别？</h3> 
<p>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。构造函数：抽象类可以有构造函数；接口不能有。main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。实现数量：类可以实现很多个接口；但是只能继承一个抽象类。访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p> 
<h3>
<a id="17_java__IO__81"></a>17. java 中 IO 流分为几种？</h3> 
<p>按功能来分：输入流（input）、输出流（output）。按类型来分：字节流和字符流。字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p> 
<h3>
<a id="18_BIONIOAIO__84"></a>18. BIO、NIO、AIO 有什么区别？</h3> 
<p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p> 
<h3>
<a id="19_Files_87"></a>19. Files的常用方法都有哪些？</h3> 
<p>Files.exists()：检测文件路径是否存在。Files.createFile()：创建文件。Files.createDirectory()：创建文件夹。Files.delete()：删除一个文件或目录。Files.copy()：复制文件。Files.move()：移动文件。Files.size()：查看文件个数。Files.read()：读取文件。Files.write()：写入文件。</p> 
<h2>
<a id="_90"></a>二、容器</h2> 
<h3>
<a id="20_java__92"></a>20. java 容器都有哪些？常用容器的图录：</h3> 
<p><img src="https://images2.imgbox.com/6c/11/yb8jzeLg_o.jpg" alt="在这里插入图片描述"></p> 
<h3>
<a id="21_Collection__Collections__96"></a>21. Collection 和 Collections 有什么区别？</h3> 
<p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p> 
<h3>
<a id="22_ListSetMap__99"></a>22. List、Set、Map 之间的区别是什么？</h3> 
<p><img src="https://images2.imgbox.com/d8/62/HkycQoK4_o.jpg" alt="在这里插入图片描述"></p> 
<h3>
<a id="23_HashMap__Hashtable__103"></a>23. HashMap 和 Hashtable 有什么区别？</h3> 
<p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。hashMap允许空键值，而hashTable不允许。</p> 
<h3>
<a id="24__HashMap__TreeMap_106"></a>24. 如何决定使用 HashMap 还是 TreeMap？</h3> 
<p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p> 
<h3>
<a id="25__HashMap__109"></a>25. 说一下 HashMap 的实现原理？</h3> 
<p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashSet底层由HashMap实现HashSet的值存放于HashMap的key上HashMap的value统一为PRESENT</p> 
<h3>
<a id="26_ArrayList__LinkedList__112"></a>26. ArrayList 和 LinkedList 的区别是什么？</h3> 
<p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p> 
<h3>
<a id="27__List__115"></a>27. 如何实现数组和 List 之间的转换？</h3> 
<p>List转换成为数组：调用ArrayList的toArray方法。数组转换成为List：调用Arrays的asList方法。</p> 
<h3>
<a id="28_ArrayList__Vector__118"></a>28. ArrayList 和 Vector 的区别是什么？</h3> 
<p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。ArrayList比Vector快，它因为有同步，不会过载。ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p> 
<h3>
<a id="29_Array__ArrayList__121"></a>29. Array 和 ArrayList 有何区别？</h3> 
<p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。Array是指定大小的，而ArrayList大小是固定的。Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p> 
<h3>
<a id="30__Queue__poll_remove_124"></a>30. 在 Queue 中 poll()和 remove()有什么区别？</h3> 
<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p> 
<h3>
<a id="31__127"></a>31. 哪些集合类是线程安全的？</h3> 
<p>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。statck：堆栈类，先进后出。hashtable：就比hashmap多了个线程安全。enumeration：枚举，相当于迭代器。</p> 
<h3>
<a id="32__Iterator__130"></a>32. 迭代器 Iterator 是什么？</h3> 
<p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p> 
<h3>
<a id="33_Iterator__133"></a>33. Iterator 怎么使用？有什么特点？</h3> 
<p>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。(2) 使用next()获得序列中的下一个元素。(3) 使用hasNext()检查序列中是否还有元素。(4) 使用remove()将迭代器新返回的元素删除。Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p> 
<h3>
<a id="34_Iterator__ListIterator__136"></a>34. Iterator 和 ListIterator 有什么区别？</h3> 
<p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p> 
<h2>
<a id="_139"></a>三、多线程</h2> 
<h3>
<a id="35__141"></a>35. 并行和并发有什么区别？</h3> 
<p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p> 
<h3>
<a id="36__144"></a>36. 线程和进程的区别？</h3> 
<p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p> 
<h3>
<a id="37__147"></a>37. 守护线程是什么？</h3> 
<p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p> 
<h3>
<a id="38__150"></a>38. 创建线程有哪几种方式？</h3> 
<p>①. 继承Thread类创建线程类②. 通过Runnable接口创建线程类③. 通过Callable和Future创建线程</p> 
<h3>
<a id="39__runnable__callable__153"></a>39. 说一下 runnable 和 callable 有什么区别？</h3> 
<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p> 
<h3>
<a id="40__156"></a>40. 线程有哪些状态？</h3> 
<p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p> 
<h3>
<a id="41_sleep__wait__159"></a>41. sleep() 和 wait() 有什么区别？</h3> 
<p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。</p> 
<h3>
<a id="42_notify_notifyAll_162"></a>42. notify()和 notifyAll()有什么区别？</h3> 
<p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p> 
<h3>
<a id="43__run_start_165"></a>43. 线程的 run()和 start()有什么区别？</h3> 
<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p> 
<h3>
<a id="44__168"></a>44. 创建线程池有哪几种方式？</h3> 
<p>①. newFixedThreadPool(int nThreads)创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。<br> ②. newCachedThreadPool()创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。<br> ③. newSingleThreadExecutor()这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。<br> ④. newScheduledThreadPool(int corePoolSize)创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p> 
<h3>
<a id="45__174"></a>45. 线程池都有哪些状态？</h3> 
<p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。线程池各个状态切换框架图：<br> <img src="https://images2.imgbox.com/55/fc/YtwEjvXk_o.jpg" alt="在这里插入图片描述"></p> 
<h3>
<a id="46__submit_execute_179"></a>46. 线程池中 submit()和 execute()方法有什么区别？</h3> 
<p>接收的参数不一样submit有返回值，而execute没有submit方便Exception处理</p> 
<h3>
<a id="47__java__182"></a>47. 在 java 程序中怎么保证多线程的运行安全？</h3> 
<p>线程安全在三个方面体现：原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p> 
<h3>
<a id="48__185"></a>48. 多线程锁的升级原理是什么？</h3> 
<p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。锁升级的图示过程：<br> <img src="https://images2.imgbox.com/fc/10/RmR9oQuA_o.jpg" alt="在这里插入图片描述"></p> 
<h3>
<a id="49__190"></a>49. 什么是死锁？</h3> 
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p> 
<h3>
<a id="50__193"></a>50. 怎么防止死锁？</h3> 
<p>死锁的四个必要条件：互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</p> 
<h3>
<a id="51_ThreadLocal__196"></a>51. ThreadLocal 是什么？</h3> 
<p>有哪些使用场景？线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p> 
<h3>
<a id="52__synchronized__200"></a>52. 说一下 synchronized 底层实现原理？</h3> 
<p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：普通同步方法，锁是当前实例对象静态同步方法，锁是当前类的class对象同步方法块，锁是括号里面的对象</p> 
<h3>
<a id="53_synchronized__volatile__203"></a>53. synchronized 和 volatile 的区别是什么？</h3> 
<p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p> 
<h3>
<a id="54_synchronized__Lock__206"></a>54. synchronized 和 Lock 有什么区别？</h3> 
<p>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p> 
<h3>
<a id="55_synchronized__ReentrantLock__209"></a>55. synchronized 和 ReentrantLock 区别是什么？</h3> 
<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁ReentrantLock可以获取各种锁的信息ReentrantLock可以灵活地实现多路通知另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</p> 
<h3>
<a id="56__atomic__212"></a>56. 说一下 atomic 的原理？</h3> 
<p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p> 
<h2>
<a id="_215"></a>四、反射</h2> 
<h3>
<a id="57__217"></a>57. 什么是反射？</h3> 
<p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力Java反射：在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法Java反射机制主要提供了以下功能：在运行时判断任意一个对象所属的类。在运行时构造任意一个类的对象。在运行时判断任意一个类所具有的成员变量和方法。在运行时调用任意一个对象的方法。</p> 
<h3>
<a id="58__java__220"></a>58. 什么是 java 序列化？</h3> 
<p>什么情况下需要序列化？简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。什么情况下需要序列化：a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；b）当你想用套接字在网络上传送对象的时候；c）当你想通过RMI传输对象的时候；</p> 
<h3>
<a id="59__223"></a>59. 动态代理是什么？有哪些应用？</h3> 
<p>动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。动态代理的应用：Spring的AOP加事务加权限加日志</p> 
<h3>
<a id="60__226"></a>60. 怎么实现动态代理？</h3> 
<p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p> 
<blockquote> 
 <p>作者：二手代码<br> 来源：知乎<br> 因原篇内容有误，进行一番删改，故标明原创，附加链接不过审核，因此没附加原文链接，如有问题请后台私信联系</p> 
</blockquote> 
<blockquote> 
 <p><strong>有问题请随时与我交流，一个人可以走的很快，但一群人才可以走的更远!</strong><br><br></p> 
 <p><b>「关注」：提高学习效率！</b> <br><br> <b>??：原创不易，适当鼓励！</b><br><br></p> 
 <p><b>⭐：收藏文章，温故知新！</b><br><br></p> 
 <p><b>?：评论交流，共同进步！</b><br><br> <strong>期待下次相遇 我是阿ken 再见</strong><br></p> 
</blockquote>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>