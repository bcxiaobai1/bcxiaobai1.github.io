<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>燕山大学机器学习期末复习知识点罗列 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">燕山大学机器学习期末复习知识点罗列</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h2>
<a id="0_0"></a>0、前言</h2> 
<p>本文根据燕山大学软件工程专业机器学习课程期末复习纲要编写，文本内容来源为上课所使用的PPT，由于时间紧迫这个版本是比较全的知识点，只包含关键词的速记突击版本后续会上传。</p> 
<h2>
<a id="1_4"></a>1、机器学习的定义</h2> 
<p>机器学习是人工智能的一个分支。我们使用计算机设计一个系统，使它能够根据提供的训练数据按照一定的方式来学习;随着训练次数的增加，该系统可以在性能上不断学习和改进;通过参数优化的学习模型，能够用于预测相关问题的输出。</p> 
<h2>
<a id="2_8"></a>2、机器学习的发展历程</h2> 
<p>推理期（只要给机器赋予逻辑推理能力，机器就拥有智能）——知识期（要使机器拥有智能就必须设法使机器拥有知识）——学科形成（作为独立学科开始发展）——繁荣期（神经网络被重视，成为深度学习理论的基础）</p> 
<h2>
<a id="3_12"></a>3、监督学习，半监督学习和无监督学习的特点</h2> 
<p>监督学习：模型从有标记的训练数据中推导出预测函数（分类、回归）</p> 
<p>半监督学习：模型在不和外界交互的情况下利用未标记样本提升学习性能</p> 
<p>无监督学习：模型从无标记的数据中推断定论（聚类）</p> 
<p>强化学习：给定数据学习选择一系列行动以最大化长期收益</p> 
<h2>
<a id="4_22"></a>4、机器学习的步骤，每个步骤的主要内容</h2> 
<p>数据预处理：数据清洗、数据集成、数据采样</p> 
<p>特征工程：特征编码、特征选择、特征降维、规范化（标准化、区间缩放、归一化）</p> 
<p>数据建模：回归问题、分类问题、聚类问题、其他问题</p> 
<p>结果评估：拟合度量、查准率、查全率、F1值、PR曲线、AUC、ROC曲线</p> 
<p>**实践流程：**准备数据；配置网络（定义网络，定义损失函数，定义优化算法）；训练网络；模型评估；模型预测</p> 
<h2>
<a id="5_34"></a>5、数据清洗的内容和意义</h2> 
<p>内容：对各种脏数据进行对应方式的处理，得到标准、干净、连续的数据提供给数据统计、挖掘等使用</p> 
<p>意义：保证数据完整性、唯一性、合法性、权威性、一致性</p> 
<h2>
<a id="6_40"></a>6、什么是数据采样</h2> 
<h3>
<a id="_42"></a>数据采集</h3> 
<p>是指对目标领域、场景的特定原始数据进行采集的过程，采集的数据以图像类、文本类、语音类、视频类等非结构化数据为主。</p> 
<h3>
<a id="_46"></a>数据采样</h3> 
<p>就是对随机现象的模拟，根据给定的概率分布从而模拟一个随机事件。另一说法就是用少量的样本点去近似一个总体分布，并刻画总体分布中的不确定性。</p> 
<p>原始数据存在数据不平衡的问题：数据集类别分布不均（二分类，两者数据差距过大）采用过采样、欠采样等方式解决。</p> 
<p>面临不平衡的数据集的时候传统模型评价方法不能精准的衡量模型的性能。</p> 
<h2>
<a id="7_54"></a>7、什么是特征抽取，特征如何选择，如何编码</h2> 
<h3>
<a id="_56"></a>特征抽取：</h3> 
<p>在数据集中找到有用的特征属性，通过组合现有特征创建新特征的子集。（新增特征子集是原来特征的映射）</p> 
<h3>
<a id="_60"></a>特征选择：</h3> 
<p>数据集中经常会出现字符串信息，这类信息不能直接用与算法计算需要转化为数值形式进行编码。</p> 
<p>目标：提高预测的准确性；构造更快、消耗更低的模型；对模型有更好的理解和解释</p> 
<p>方法：运用过滤法、包裹法、嵌入法、one-hot编码、语义编码</p> 
<h2>
<a id="8_68"></a>8、分类算法有哪些？</h2> 
<p>分类问题是有监督学习的核心问题</p> 
<p>贝叶斯、SVM、决策树、逻辑回归</p> 
<h2>
<a id="9_74"></a>9、决策树算法</h2> 
<h3>
<a id="_76"></a><strong>定义：</strong>
</h3> 
<p>决策树是一种描述都样本数据进行分类的树形结构模型，由节点和有向边组成，内部每个节点表示一个属性上的判断，每个分支表示一个判断结果的输出，每个叶节点表示一种分类结果。</p> 
<h3>
<a id="_80"></a>决策过程：</h3> 
<p>从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到达到叶子节点，将叶子节点存放的类别作为决策结果。</p> 
<h3>
<a id="_84"></a><strong>流程：</strong>
</h3> 
<ol>
<li> <p>特征变量的选择：通过信息增益、信息增益比、Gini指数等方法选择</p> </li>
<li> <p>决策树的生成：例如ID3、C4.5、CART等</p> </li>
<li> <p>剪枝：通过剪枝来避免过拟合</p> </li>
</ol> 
<h3>
<a id="_91"></a><strong>特征变量的选择：</strong>
</h3> 
<ol>
<li> <p>信息量不能为负数，信息量之间可以相加，随着概率单调递减（概率越高信息量越小）；</p> </li>
<li> <p>信息熵表示信息不确定性的一种量度，熵越高越混乱</p> </li>
<li> <p>信息增益该变量的信息增益越高则分类效果越好（特征前熵-特征后熵）</p> </li>
<li> <p>信息增益比处理选择取值较多的特征的问题，只有不同变量分裂出不同个数字节点的情况下才会起作用。</p> </li>
<li> <p>Gini指数：Gini指数越小则变量纯度越高</p> </li>
</ol> 
<h3>
<a id="_100"></a><strong>生成的三个终止条件：</strong>
</h3> 
<ol>
<li>当前节点包括样本全部属于同一类别</li>
<li>当前节点已经没有样本</li>
<li>所有特征已经使用完毕</li>
</ol> 
<h3>
<a id="_106"></a><strong>决策树算法：</strong>
</h3> 
<p>ID3算法：以信息增益为准来选择分支</p> 
<p>C4.5算法：以信息增益比为基准来选择分支</p> 
<p>CART算法：使用Gini指数来选择分支的特征变量（二叉树）</p> 
<h3>
<a id="_114"></a><strong>剪枝</strong>：</h3> 
<p>原因：防止过拟合</p> 
<p>策略：预剪枝（降低过拟合风险，显著减少时间开销，存在欠拟合风险）、后剪枝（欠拟合风险小，泛化性能优秀，训练时间开销大）</p> 
<p>判断决策树泛化性能是否提升的方法：留出法（预留一部分数据作为验证集</p> 
<h3>
<a id="_122"></a><strong>理想的决策树</strong>：</h3> 
<ol>
<li>叶子节点数最少</li>
<li>叶子节点深度最小</li>
<li>叶子节点数量最少且叶子节点深度最小</li>
</ol> 
<h2>
<a id="10_128"></a>10、贝叶斯分类算法</h2> 
<p><img src="https://images2.imgbox.com/b0/22/5Plbop7C_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/3a/e0/fVBnTXAo_o.png" alt="请添加图片描述"></p> 
<p>估计先验概率<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        P
       
       
        (
       
       
        c
       
       
        )
       
      
      
       P(c)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal" style="margin-right: 0.1389em">P</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></span>；为每个属性计算条件概率<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        P
       
       
        (
       
       
        
         x
        
        
         i
        
       
       
        ∣
       
       
        c
       
       
        )
       
      
      
       P(x_i|c)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal" style="margin-right: 0.1389em">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></span>；计算后验概率</p> 
<p>在分类问题情况下，所有相关概率都已知的理想情况下，贝叶斯考虑如何基于这些概率和误判损失来选择最优的类别标记。</p> 
<p>贝叶斯判定准则：为最小化总体风险，只需在每个样本上选择那个能使条件风险最小的类别标记。</p> 
<p>然而现实中很难直接获得，机器学习所要实现的是基于有限的训练样本尽可能准确地估计出后验概率，主要用两种策略：判别式模型和生成时模型</p> 
<p>极大似然估计：试图在所有可能的取值中找到一个使数据出现的“可能性”最大的值。</p> 
<p>朴素贝叶斯分类器采取了“属性条件独立性假设”：每个属性独立地对分类结果发生影响。</p> 
<h2>
<a id="11SVM_145"></a>11、SVM</h2> 
<p>支持向量机（SVM），是一种有监督学习方法，寻找具有最大边缘（间隔）的超平面，同时面对<strong>近似线性可分</strong>的情况需要适当放宽这个间隔，引入<strong>软间隔和松弛因子</strong>，面对更复杂的低维线性不可分的情况，通过使用<strong>核函数</strong>将数据点映射到高维，寻找超平面进行划分，使得该平面两侧距离该平面最近的两类样本之间的距离最大化。</p> 
<p>线性可分SVM，应选择“<strong>正中间</strong>”，容忍性好，鲁棒性高，泛化能力最强。</p> 
<p>超平面方程：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        x
       
       
        )
       
       
        =
       
       
        
         ω
        
        
         T
        
       
       
        x
       
       
        +
       
       
        b
       
       
        =
       
       
        0
       
      
      
       f(x)=ω^T x+b=0
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal" style="margin-right: 0.1076em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 0.9247em;vertical-align: -0.0833em"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em">ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8413em"><span class="" style="margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.1389em">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em"></span></span><span class="base"><span class="strut" style="height: 0.6944em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 0.6444em"></span><span class="mord">0</span></span></span></span></span></p> 
<p>最大间隔：寻找参数 <strong>ω</strong> 和 b，使得 γ 最大。</p> 
<p>线性可分：拉格朗日乘子法，SMO算法</p> 
<p>近似线性可分SVM：由于噪声存在或数据本身分布存在偏差，现实中大多数情况下很难实现二类问题的完美划分，需要引入软间隔与松弛变量、Hinge Loss、惩罚因子。</p> 
<p>对于一维线性不可分，映射到二维空间就可以获得一条直线，仍不可分变换坐标空间，二维不可分则映射到三维空间找平面</p> 
<h2>
<a id="12_161"></a>12、线性回归，最小二乘法、梯度下降法</h2> 
<h3>
<a id="_163"></a>线性回归：</h3> 
<p>本质就是一个全连接层</p> 
<p>回归分析用于预测自变量和隐变量之间的关系，只管来说回归问题提等价于函数拟合，根据变量个数可分为一元回归分析和多元回归分析。</p> 
<p>一元线性回归算法流程：</p> 
<ol>
<li>选择拟合函数形式<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         h
        
        
         (
        
        
         x
        
        
         )
        
        
         =
        
        
         
          θ
         
         
          t
         
        
        
         x
        
       
       
        h(x)=θ^tx
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 0.7936em"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7936em"><span class="" style="margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span></span></span></span></span>
</li>
<li>确定损失函数形式</li>
<li>训练算法，找到回归系数</li>
<li>使用算法进行数据预测</li>
</ol> 
<p><strong>损失函数：</strong></p> 
<p>平均绝对误差MAE，又被称为l1范数损失</p> 
<p>平均平方误差MSE，又被称为l2范数损失</p> 
<p>均方根差RMSE，是MSE（平均平方误差）的算术平方根</p> 
<h3>
<a id="_184"></a>最小二乘法：</h3> 
<p>求解：最小二乘法原理，同故宫最小化误差的二平方和，使得拟合对象无限接近目标对象。主要思想就是求解未知参数，是的理论值和观测值之差（残差）的平方和最小。</p> 
<p>缺点：主要针对线性函数有全局最优解且是闭式解，针对更复杂的函数难以起作用。</p> 
<h3>
<a id="_190"></a>梯度下降法：</h3> 
<p><strong>求解：</strong></p> 
<p>可看成是更简单的一种最小二乘法最后一步解方程的方法，梯度下降法是用来计算函数最小值的。</p> 
<p>根据计算一次目标函数梯度的样本数量可分为：批量梯度下降（BGD），随机梯度下降（SGD），小批量梯度下降（mini-batch GD）</p> 
<p><strong>BGD：</strong></p> 
<p>训练过程中每一步迭代都使用训练集中的所有内容，也就是说利用现有参数对训练集中的每一个输入生成一个估计输出，然后跟实际输出进行比较，统计所有误差，求平均来作为更新参数的依据。</p> 
<p>优点：每一步都利用了训练集中的所有数据，因此当损失函数达到最小值以后，能够保证此时的梯度为0，换句话说就是能够收敛，因此，使用BGD时不需要逐渐减小学习速率</p> 
<p>缺点：每一步都需要所有数据，因此随着数据集的增大，运行速度会越来越慢</p> 
<p><strong>SGD：</strong></p> 
<p>优点：每次只计算一个样本，收敛非常快</p> 
<p>缺点：随机抽取样本，误差是不可避免的，每次迭代的梯度受抽样的影响比较大</p> 
<p><strong>mini-batch GD：</strong></p> 
<p>小批量梯度下降结合了批量梯度下降和随机梯度下降的优点，他以一次小批量的训练数据计算目标函数的权重并更新参数。</p> 
<p><strong>挑战：</strong></p> 
<ol>
<li>难以选择合适的学习速率：过小则收敛慢，过大则会在损失最小点周围摇摆</li>
<li>可以在开始时设置一个较大的学习率，然后每个训练周日按比例降低学习率，有效但不能很好地适应数据的内在规律</li>
<li>对特征向量中的所有特征都采用了相同的学习率，如果数据稀疏且不同特征变化频率大这时候对变化频率慢的特征采用大学习率频率快的采用小的学习率效果会更好</li>
<li>梯度下降法难以逃脱”鞍点“，既不是最小值点也不是最大值点，所有方向上梯度都接近于0</li>
</ol> 
<p><strong>梯度下降的改进：</strong></p> 
<p>Momentum：若当前梯度与历史累计梯度方向一致则当前梯度会被加强反之则减弱。</p> 
<p>AdaGrad：每一次迭代，不同参数使用不同的学习率</p> 
<p>Adam：利用梯度的一阶矩和二阶矩估计动态调整每个参数的学习率，优点在于经过偏置校正后，每一次迭代学习率都有一个确定的范围，参数较为平稳。</p> 
<h2>
<a id="13Kmeans_231"></a>13、K-means算法</h2> 
<h3>
<a id="_233"></a><strong>聚类问题概念：</strong>
</h3> 
<p>聚类问题：无监督学习中，训练样本的标记信息是未知的。将数据集中的样本划分为若干个不相交的子集。既可以作为一个单独的过程，也可以作为其他学习任务的前驱过程。</p> 
<p>聚类性能度量，亦称为聚类的”有效性指标“，与监督学习中的性能度量作用类似。一般来讲，同一蔟的样本尽可能彼此相似，不同蔟的样本尽可能不同，”簇内相似度“高”且蔟间相似度“低聚类效果好。外部指标：聚类结果与某个”参考模型【Jaccard、FM、Rand指数在0.1区间内越大越好】"进行比较；内部指标：直接考察聚类结果而不使用任何参考模型。【DB指数 越小越好、Dunn指数 越大越好】</p> 
<h3>
<a id="_239"></a><strong>基本原理：</strong>
</h3> 
<p>随机选取k个点作为初始的聚类中心点，根据每个样本到聚类中心点的距离，把样本归类到相距它最近的聚类中心代表的类中，再计算样本均值，若相邻的两个聚类中心无变化结束迭代，否则改过程重复进行。</p> 
<h3>
<a id="_243"></a><strong>算法流程：</strong>
</h3> 
<p>选取质心；分配数据点；更新聚类中心；判断聚类中心的值是否变化</p> 
<h3>
<a id="_247"></a>主要优点：</h3> 
<ol>
<li>原理比较简单，实现容易，收敛快</li>
<li>聚类效果好</li>
<li>算法可解释度强</li>
<li>主要需调参数只有蔟数k</li>
</ol> 
<h3>
<a id="_254"></a>主要缺点：</h3> 
<ol>
<li>k的值不好把握</li>
<li>不平衡的数据集聚类效果不佳</li>
<li>采用迭代的方法，得到的往往只是局部最优解</li>
<li>对噪音和异常点比较敏感</li>
</ol> 
<h2>
<a id="14_261"></a>14、层次聚类</h2> 
<h3>
<a id="_263"></a>概念：</h3> 
<p>基于层次的聚类方法：层次聚类试图在不同层次对数据集进行划分，从而形成树形的聚类结构，数据集划分既可采用“自底向上”的组合逻辑，也可反向，所以可分为：<strong>聚合层次聚类</strong>和<strong>划分层次聚类</strong>。</p> 
<p><strong>聚合层次聚类：<strong>采用自底向上的策略，开始时每一个样本自己就是一个类，称为</strong>原子聚类</strong>，根据这些样本之间的相似性将这些样本对象进行合并。</p> 
<p>**划分层次聚类：**采用自顶向下的策略，他首先将所有对象置于同一个蔟中，然后逐渐细分直至每个对象自成一簇，豁达到了某个终止条件，该种方法一般较少使用。</p> 
<h3>
<a id="AGNES_271"></a>层次聚类代表方法：AGNES</h3> 
<p>自底向上的聚合策略，首先将数据集中的每一个样本看作一个初始聚类，然后在算法运行时每一步找出距离最近的两个聚类簇进行合并，改过程不断重复，直至到达预设的聚类簇的个数。三种度量方式：最小距离、最大距离、平均距离</p> 
<h3>
<a id="_275"></a><strong>算法流程：</strong>
</h3> 
<p>给定包含n个对象的数据集D，聚类簇距离度量函数d，聚类簇数为k</p> 
<p>计算所有样本间的距离</p> 
<p>更新聚类簇及样本间距离</p> 
<p>重复上述过程，直至聚类簇数位设定的参数k</p> 
<h3>
<a id="_285"></a>聚类效果</h3> 
<p><img src="https://images2.imgbox.com/20/5f/9hkniPwh_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/04/74/KkAO9IPB_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/be/d2/P4SD6LCT_o.png" alt="请添加图片描述"></p> 
<h2>
<a id="15_293"></a>15、密度聚类</h2> 
<h3>
<a id="_295"></a>概念：</h3> 
<p>同一类别的样本，他们之间是紧密相连的，也就是说，在任意样本不远处一定有同类别的样本存在。样本密度出发考虑样本间的可连接性，基于可连接样本不断扩展聚类的蔟实现聚类的目的。</p> 
<h3>
<a id="DBSCAN_299"></a>代表算法为：DBSCAN</h3> 
<p>基于一组“邻域”参数，来刻画样本分布的紧密程度。</p> 
<p>基本概念：</p> 
<ul>
<li> <p>ϵ邻域</p> </li>
<li> <p>核心对象</p> </li>
<li> <p>密度直达</p> </li>
<li> <p>密度可达</p> </li>
<li> <p>密度相连</p> </li>
</ul> 
<h3>
<a id="_315"></a>流程：</h3> 
<ol>
<li>给定包含 n 个对象的数据集 D ，邻域为 ϵ，密度阈值为 MinPts</li>
<li>首先找到所有的核心对象，根据 (ϵ,MinPts) 对 n 个对象进行搜索，寻找所有的核心对象，构成核心对象集合。</li>
<li>根据上述的核心对象寻找 D 中所有密度相连的样本，构成簇，若上述核心对象已被访问，则剔除出去。</li>
<li>重复上述过程，直至核心对象集合为空。</li>
</ol> 
<p>示例：令MinPts=3，且虚线显示出 ϵ 邻域；<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         1
        
       
      
      
       x_1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span>为核心对象，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         2
        
       
      
      
       x_2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span>由<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         1
        
       
      
      
       x_1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span>密度直达，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         3
        
       
      
      
       x_3
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span>由<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         1
        
       
      
      
       x_1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span>密度可达，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         3
        
       
      
      
       x_3
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span>与<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         4
        
       
      
      
       x_4
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em;vertical-align: -0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span>密度相连。</p> 
<p><img src="https://images2.imgbox.com/b3/af/v1K7kBQE_o.png" alt="请添加图片描述"></p> 
<p>DBSCAN对蔟的定义：由密度可达关系导出的最大密度相连样本集合</p> 
<p><img src="https://images2.imgbox.com/aa/97/EQgQ0r6g_o.png" alt="请添加图片描述"></p> 
<h2>
<a id="16AdaBoost_332"></a>16、集成学习AdaBoost</h2> 
<h3>
<a id="_334"></a>概念：</h3> 
<p>集成学习是一个过程：按照某种算法生成多个模型再将这些模型组合起来解决某个问题，通常用来提高模型的性能或者用来降低模型选择不当的可能性。集成个体应好而不同。有一个关键假设：基学习器的误差相互独立，好而不同是集成机器学习研究的核心，大致可分为两类：</p> 
<ol>
<li>个体学习器间存在强依赖关系，必须串行生成的序列化方法，代表是Boosting</li>
<li>个体学习期间不存在强依赖关系，可同时生成的并行化方法，代表是Bagging与随机森林</li>
</ol> 
<p>从偏差-方差权衡的角度看，AdaBoost主要关注降低偏差，因此AdaBoost能基于泛化特性相当弱的分类器构建出很强的集成分类器</p> 
<h3>
<a id="Boosting_343"></a>Boosting</h3> 
<p>先从初始训练集中训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续得到更多关注，然后集训调整后的样本分布来训练下一个基学习器，直到基学习器的数目达到事前指定的T，最后将这T个基学习器进行加权结合。</p> 
<p>AdaBoost采用了boosting的算法框架，通过改变数据分布学习多个基本分类器，这些数据分布由上一个基本分类器分类出来的结果决定，确定下一步输入样本的权值。将每次训练得到的分类器最后融合起来，作为最后的决策分类器。</p> 
<h4>
<a id="_349"></a>算法思想：</h4> 
<p><strong>计算样本权重</strong></p> 
<p>赋予训练集中的每一个样本权重，构成权重向量，将其初始化为相等值，都为1/m</p> 
<p><strong>计算错误率</strong></p> 
<p>在训练集上训练出一个弱分类器，并计算分类器的错误率</p> 
<p><strong>计算弱分类器的权重</strong></p> 
<p>为当前的分类器赋予权重a，计算公式为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        α
       
       
        =
       
       
        
         1
        
        
         2
        
       
       
        l
       
       
        n
       
       
        (
       
       
        
         
          1
         
         
          −
         
         
          ϵ
         
        
        
         ϵ
        
       
       
        )
       
      
      
       α=frac{1}{2}ln(frac{1-ϵ}{ϵ})
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em"></span><span class="mord mathnormal" style="margin-right: 0.0037em">α</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 1.1901em;vertical-align: -0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8451em"><span class=""><span class="pstrut" style="height: 3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class=""><span class="pstrut" style="height: 3em"></span><span class="frac-line" style="border-bottom-width: 0.04em"></span></span><span class=""><span class="pstrut" style="height: 3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right: 0.0197em">l</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8451em"><span class=""><span class="pstrut" style="height: 3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ϵ</span></span></span></span><span class=""><span class="pstrut" style="height: 3em"></span><span class="frac-line" style="border-bottom-width: 0.04em"></span></span><span class=""><span class="pstrut" style="height: 3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">ϵ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p> 
<p><strong>调整样本权重值</strong></p> 
<p>根据上一次的训练结果，调整权重值（上次分类正确权值降低，分类错误权重增加）</p> 
<h3>
<a id="Bagging_367"></a>Bagging</h3> 
<p>给定一个训练数据集，队训练样本进行采样，产生若干个不同的子集，再从每个子集中训练出一个基学习器，如果每个子集都完全不同则甚至不足以进行有效学习，为解决这个问题考虑使用相互有交叠的采样子集。</p> 
<p>基学习器不存在强依赖关系，采用并行化生成的方法，需要用到自助采样法（给定包含t</p> 
<p>个样本的数据集，随机取出一个样本放到采样集中，再放回，经过m次后得到一个m个样本的采样集。</p> 
<p>随机森林：在Bagging框架的基础上，进一步在决策树的训练过程中引入了随机属性选择。</p> 
<p>森林：任意两棵树的相关性：相关性越大则错误率越大；每棵树的分类能力越强，整个森林的错误率越低。</p> 
<p><strong>构建流程</strong>：</p> 
<p>假设有m个样本的训练集，需要的弱分类器为T个。</p> 
<p>对样本使用自助采样法进行随机抽样，共采样T个包含m条样本的采样集；构建决策树时，传统决策树在选择属性时根据当前节点的属性集合中选择一个最优属性，但是在RF中对基决策树中的每个节点，先从节点的属性集合中随机选择一个包含k个属性的子集，再从这个子集中选择一个最优属性用于划分；将构建的T个弱分类器进行结合，得到强分类器。</p> 
<h3>
<a id="_385"></a>结合策略</h3> 
<p><strong>平均法：</strong></p> 
<p>对于树脂类的回归预测问题，通常使用的结合策略是平均法（算术平均法、加权平均法）一般而言，在个体学习器性能相差较大时宜采用加权平均法，在个体学习器性能相近时宜采用简单平均法。</p> 
<p><strong>投票法：</strong></p> 
<p>绝对多数投票法：得票过半数则预测为该标记否则拒绝预测</p> 
<p>相对多数投票法：的票最多的标记，若有多个同时获得最高票数的标记则从中随机选择</p> 
<p>加权投票法：每个基学习器的分类票数和权重相乘，最终将各个类别的票数求和，最大值即为输出</p> 
<p><strong>学习法：</strong></p> 
<p>代表方法是Stacking，主要是利用弱学习器的学习结果作为输入，将初始样本的标记当作样例标记，重新训练新的学习器。</p> 
<p>在这种情况下，将弱学习器称为出基学习器，将用于结合的学习器称为次级学习器。</p> 
<h2>
<a id="17F1PR_405"></a>17、性能指标：准确率，精确率，召回率，F1，PR曲线，宏平均，微平均</h2> 
<p>准确率：分类正确的样本个数占所有样本的个数</p> 
<p>精确率：分类正确的样本个数占分类器所有正样本个数的比例（基数是预测结果的正例）</p> 
<p>召回率：分类正确的正样本个数占正样本个数的比例（基数是真实情况的正例）</p> 
<p>F1：精确率与召回率的调和平均值</p> 
<p>PR曲线：P指精准率，R指精确率，PR曲线用来描述模型的优劣</p> 
<h2>
<a id="18_417"></a>18、什么是人工神经网络，及其基本概念，神经元与权值连接</h2> 
<p>神经网络是由具有适应性的简单单元（神经元模型）组成的广泛并行互联的网络，它的组织能够模拟生物神经系统对真实世界物体所做出的反应</p> 
<p>机器学习中的神经网络通常是指“神经网络学习”，或者机器学习与神经网络两个学科的交叉部分。</p> 
<p>神经元模型即上述定义中的简单单元，是神经网络的基本成分。</p> 
<p>生物神经网络：每个神经元与其他神经元相连，当他兴奋时就会向相连神经元发送物质，改变神经元内的电位，如果电位超过一个阈值，那么它就会被激活，即兴奋起来，向其他神经元发送化学物质。</p> 
<h3>
<a id="_427"></a>感知机</h3> 
<p>MP神经元模型：输入：来自其他n个神经元传递过来的输入信号；处理：输入信号通过带权重的链接进行传递，神经元接收到总输入值将神经元的阈值进行比较；输出：通过激活函数的处理得到输出。能轻易地实现逻辑与、或、非运算。</p> 
<p>激活函数：理想的激活函数时越阶函数，0表示抑制1表示激活，越阶函数具有不连续、不光滑等性质，常用的是Sigmoid函数。</p> 
<p>感知机学习：给定训练数据集，权重与阈值可通过学习得到。</p> 
<p>定义：每层神经元与下一层神经元全互联，神经元之间不存在同层链接也不存在跨层链接。</p> 
<p>前馈：输入层接受外界输入，隐含层与输出层神经元对信号进行加工，最终结果由输出层神经元进行输出。</p> 
<p>学习：根据训练数据来调整神经元之间的“连接权重”以及每个功能神经元的“阈值”。若两类模式线性可分，则感知机学习过程一定会收敛。单层感知机的学习能力非常有限，只能解决线性可分问题，对于非线性可分为题采用多层感知机实现。</p> 
<p>多层网络：包含隐藏层（输入层与输出层之间的神经元称为隐层或隐含层）的网络</p> 
<h2>
<a id="19_443"></a>19、激活函数有哪些？</h2> 
<p>理想的激活函数时越阶函数，0表示抑制神经元1表示激活神经元</p> 
<p>越阶函数具有不连续、不光滑等性质，常用的是Sigmoid函数。</p> 
<h2>
<a id="20_449"></a>20、输入层，隐藏层，输出层，损失函数，反向调参策略，什么是全连接网络，什么是偏置向量</h2> 
<p>输入层：主要用于获取输入的信息，比如黑白照片的像素是黑色还是白色的，大小取决于输入信息的规模</p> 
<p>隐藏层：主要进行特征提取，调整权重让隐藏层的神经单元对某种形式形成反应</p> 
<p>输出层：用于对接隐藏层并输出模型结果，调整权重以对不同的隐藏层神经元刺激形成正确的反应，输出的兴奋度即为结果</p> 
<p>全连接神经网络：每层每个节点均和上一层的所有节点相连</p> 
<p>损失函数：是用来度量模型的预测值<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        x
       
       
        )
       
      
      
       f(x)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal" style="margin-right: 0.1076em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>与真实值Y的差异程度的运算函数，它是一个非负实值函数，通常使用<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        L
       
       
        (
       
       
        Y
       
       
        ,
       
       
        f
       
       
        (
       
       
        x
       
       
        )
       
       
        )
       
      
      
       L(Y, f(x))
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.2222em">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mord mathnormal" style="margin-right: 0.1076em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span></span>来表示，损失函数越小，模型的鲁棒性就越好。</p> 
<p>偏置向量：偏置单元，它其实就是函数的截距，与线性方程<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        y
       
       
        =
       
       
        w
       
       
        x
       
       
        +
       
       
        b
       
      
      
       y=wx+b
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em;vertical-align: -0.1944em"></span><span class="mord mathnormal" style="margin-right: 0.0359em">y</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 0.6667em;vertical-align: -0.0833em"></span><span class="mord mathnormal" style="margin-right: 0.0269em">w</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em"></span></span><span class="base"><span class="strut" style="height: 0.6944em"></span><span class="mord mathnormal">b</span></span></span></span></span>中的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        b
       
      
      
       b
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em"></span><span class="mord mathnormal">b</span></span></span></span></span> 的意义是一致的。在<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        y
       
       
        =
       
       
        w
       
       
        x
       
       
        +
       
       
        b
       
      
      
       y=wx+b
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em;vertical-align: -0.1944em"></span><span class="mord mathnormal" style="margin-right: 0.0359em">y</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 0.6667em;vertical-align: -0.0833em"></span><span class="mord mathnormal" style="margin-right: 0.0269em">w</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em"></span></span><span class="base"><span class="strut" style="height: 0.6944em"></span><span class="mord mathnormal">b</span></span></span></span></span>中，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        b
       
      
      
       b
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em"></span><span class="mord mathnormal">b</span></span></span></span></span>表示函数在y轴上的截距，控制着函数偏离原点的距离，其实在神经网络中的偏置单元也是类似的作用。神经网络的参数也可以表示为：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        W
       
       
        ,
       
       
        b
       
       
        )
       
      
      
       (W, b)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1389em">W</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></span>，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        W
       
      
      
       W
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em"></span><span class="mord mathnormal" style="margin-right: 0.1389em">W</span></span></span></span></span>表示参数矩阵，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        b
       
      
      
       b
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em"></span><span class="mord mathnormal">b</span></span></span></span></span>表示偏置项或截距项。其作用是给网络分类增加平移的能力。</p> 
<h2>
<a id="21BP_463"></a>21、BP神经网络</h2> 
<h3>
<a id="_465"></a>误差逆传播算法</h3> 
<p>BP算法</p> 
<p>最成功的训练多层前馈神经网络的算法，也是使用最多的算法。</p> 
<p>工作流程：将输入示例提供给输入层神经元，逐层将信号前传直到产生输出结果；计算输出层与真实值的误差，将误差使用BP算法传播到整个网络，对连接权重及阈值进行调整；该迭代过程循环进行，直到达成某些条件停止为止。</p> 
<p>标准BP算法：</p> 
<p>每次针对单个训练样例更新权值和阈值</p> 
<p>参数频繁更新，不同样例可能抵消，需要多次迭代</p> 
<p>累计BP算法：</p> 
<p>优化目标是最小化整个训练集上的累计误差</p> 
<p>读取整个训练集一遍才对参数进行更新，参数更新频率较低</p> 
<p>多层前馈网络表示能力：</p> 
<p>只要一个包含足够多神经元的隐层，多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数</p> 
<p>多层前馈网络局限：</p> 
<p>神经网络由于强大的表示能力，经常过拟合，表现为训练误差持续降低但测试误差却上升。</p> 
<p>如何设置隐层神经元个数暂未解决，实际应用中只能试错</p> 
<p>缓解过拟合的策略：</p> 
<p>早停：训练误差降低、验证误差升高则停止训练</p> 
<p>正则化：误差目标函数中增加一项描述网络复杂程度的部分</p> 
<p>可能存在多个局部极小值但只会有一个全局最小值。</p> 
<p>如何跳出局部极小达成全局最小呢？</p> 
<p>模拟退火：每一步都以一定概率接受比当前更差的结果</p> 
<p>梯度随机下降：在计算梯度时加入随机因素</p> 
<h2>
<a id="22_509"></a>22、卷积神经网络，局部连接，权值共享，卷积层，池化层</h2> 
<h3>
<a id="CNN_511"></a>卷积神经网络（CNN）基本结构</h3> 
<ul>
<li>输入层 传递给网络的数据 将输入的数据（图像、文字）转换成网络能计算的数字</li>
<li>卷积层 提取数据的不同特征</li>
<li>激活层 为网络加入非线性因素</li>
<li>池化层 对计算后的特征图进行压缩</li>
<li>全连接层 连接所有的特征，进行分类</li>
</ul> 
<p><strong>卷积层：</strong></p> 
<p>卷积计算=特征抽取</p> 
<p>卷积核深度=上一层数据输入的深度</p> 
<p>多个卷积核：一个卷积核提取一种局部模式</p> 
<p>卷积核个数=提取特征的个数</p> 
<p>多层卷积：一层卷积得到的特征往往是局部的，层数越高学到的特征就越全局化</p> 
<p>每层卷积层由若干卷积单元（卷积核）组成，每个参数都是通过反向传播算法优化得到的。</p> 
<p>卷积运算的目的是提取输入的不同特征，三个关键词：卷积核（用于对输入图像进行共享权值的遍历）；步长（卷积核在图片上移动的大小）；填充（满足输出的图像的维度要求）</p> 
<p>卷积核：往往是行数和列数都为奇数的矩阵，用于图像模糊、平滑处理（均值滤波器和高斯滤波器）大的卷积核不利于模型深度的增加，计算性能也会降低。</p> 
<p>卷积核和图像尺寸不匹配要先进行填充</p> 
<p>Padding解决的问题：每卷积一层下一层输入的维度都会降低、边缘信息利用不够；优点：卷积核大小不再限制深度</p> 
<p><img src="https://images2.imgbox.com/95/05/G6UHMgY3_o.png" alt="请添加图片描述"></p> 
<p><strong>激活层：</strong></p> 
<p>加入非线性元素，在同一个网络中只是用一种激活函数。</p> 
<p><strong>池化层：</strong></p> 
<p>在高和宽的层面上进行采样，不改变深度维度</p> 
<p><strong>全连接层：</strong></p> 
<p>多层映射成一个一维向量；打破卷积层的空间限制，对不同特征进行加权；输出层就是对应每个类别的的得分；</p> 
<h3>
<a id="_556"></a>卷积神经网络训练：</h3> 
<p>本质上是一种输入到输出的映射，只要使用已知的模式对卷积网络加以训练，网络就具有输入输出之间的映射能力，也参照了反向传播算法。</p> 
<p>第一阶段向前传播：从样本集中取得样本，将x输入网络，获得输出结果</p> 
<p>第二阶段向后传播：采用BP算法对误差处理进行更新网络权重</p> 
<h2>
<a id="23LSTM_564"></a>23、LSTM</h2> 
<p>LSTM与RNN结构类似，都是链状结构，但是其中的重复块有不同的结构，依靠门控制机制解决信息遗忘问题。</p> 
<p>用三种门机制进行控制：遗忘门（决定丢弃哪些信息），输入门（决定什么样的新信息被存在细胞状态中，有两层sgimoid决定要存放在细胞状态的信息量的大小，tanh层创建一个新的候选值向量，下一步对这两个信息进行更新）和输出门（计算细胞状态来确定输出的整个细胞单元的状态，首先使用sigmoid确定输出哪个部分然后把细胞状态通过tanh处理并与sigmoid门的输出相乘，最终仅输出确定输出的部分。</p> 
<p>GRU只有两个门（遗忘门和输入门合并成一个更新门）GRU参数跟少因此更容易收敛。</p> 
<h2>
<a id="24_572"></a>24、训练集，验证集和测试集</h2> 
<p>训练集：用于构建学习模型的数据集</p> 
<p>验证集：辅助构建模型，在构建过程中评估模型，提供无偏估计进而调整模型参数</p> 
<p>测试集：用于评估训练好的模型的性能</p> 
<h2>
<a id="25_580"></a>25、超参有哪些</h2> 
<p>理解：机器学习模型中一般有两类参数：一类需要从数据中学习和估计得到，称为模型参数（Parameter）——即模型本身的参数，比如线性回归直线的加权系数（斜率）及其偏差项（截距）。还有一类则是机器学习算法中的调优参数，需要人为设定，称为超参数</p> 
<p>参数和超参数的区别：参数模型是模型内部的配置变量，需要用数据估计模型参数的值；模型超参数时模型外部的配置之，需要手动设置超参数的值。</p> 
<p>超参数有哪些：梯度下降算法中的学习速率α，迭代次数epoch，网络层数，网络节点数，批量大小batch-size，k近邻法（KNN）中的k（最相近的点的个数），决策树模型中树的深度。</p> 
<h2>
<a id="26_588"></a>26、过拟合和欠拟合</h2> 
<h3>
<a id="_590"></a>过拟合</h3> 
<p>模型学习的参数过多导致拟合函数完美预测训练集，但对新数据的测试集预测结果较差，过拟合通常发生在模型过于复杂的情况下，会导致模型预测性能变弱，增加数据的波动性</p> 
<p><strong>改进方法：</strong></p> 
<ol>
<li>从源头获取更多数据（最直观有效）</li>
<li>使用合适的模型（减少网络层数、神经元个数）</li>
<li>使用正则项约束模型的权重，降低模型的非线性</li>
<li>Early stopping使用迭代次数截断防止过拟合，模型对训练数据集迭代收敛之前停止迭代来防止过拟合。</li>
<li>Dropout、交叉验证、决策树剪枝、模型组合（集成学习）</li>
</ol> 
<h3>
<a id="_602"></a>欠拟合</h3> 
<p>模型泛化能力差，训练好的模型在训练集表现差、测试集表现也很差。模型拟合程度不高，数据离拟合曲线较远，模型没有很好地捕捉到数据特征。</p> 
<p><strong>改进方法：</strong></p> 
<ol>
<li>增加新特征，考虑加入特征组合来增大假设空间</li>
<li>添加多项式特征，线性模型添加二次项、三次项是的模型泛化能力强</li>
<li>减少正则化函数</li>
<li>使用非线性模型，例如核SVM、决策树、深度学习等模型</li>
<li>使用集成学习的方法</li>
</ol> 
<h2>
<a id="27RNN_614"></a>27、循环神经网络（RNN）</h2> 
<p>DNN、CNN输入、输出定长，处理输入、输出边长问题效率不高，无法单一解决时序相关序列问题</p> 
<p>RNN不同于是一种双向传递的神经网络，主要用来处理序列数据，当前输出与前面的输出也有关，网络会对前面的信息进行记忆并用于当前神经元的计算。</p> 
<p>模型训练：向前传播算法</p> 
<p>使用形式：</p> 
<ul>
<li>一对一 每个输入有对应输出，例如图像分类</li>
<li>一对多 每个输入有时序序列，常用于翻译模型的解码阶段，图文标注</li>
<li>多对一 整个序列只有一个输出，文本分类、情感分析</li>
<li>多对多 不是一个输入对应一个输出，对应到变化的输出，比如机器翻译</li>
</ul> 
<h2>
<a id="28cnnlstm_629"></a>28、常见算法：波士顿房价预测，鸢尾花分类，cnn文本分类，猫狗分类，手写数字识别，基于lstm的序列标注（翻译，命名实体识别等）</h2>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>