<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>《MySQL高级篇》十四、多版本并发控制 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《MySQL高级篇》十四、多版本并发控制</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>文章目录</h3> 
 <ul><li>
<ul>
<li><a href="#1_MVCC_6">1. 什么是MVCC</a></li>
<li><a href="#2__12">2. 快照读与当前读</a></li>
<li>
<ul>
<li><a href="#21__16">2.1 快照读</a></li>
<li><a href="#22__30">2.2 当前读</a></li>
</ul> 
   </li>
<li><a href="#3__44">3. 复习</a></li>
<li>
<ul>
<li><a href="#31__46">3.1 再谈隔离级别</a></li>
<li><a href="#32_Undo_Log_62">3.2 隐藏字段、Undo Log版本链</a></li>
</ul> 
   </li>
<li><a href="#4_MVCCReadView_119">4. MVCC实现原理之ReadView</a></li>
<li>
<ul>
<li><a href="#41_ReadView_123">4.1 什么是ReadView</a></li>
<li><a href="#42__131">4.2 设计思路</a></li>
<li><a href="#43_ReadView_159">4.3 ReadView的规则</a></li>
<li><a href="#44_MVCC_170">4.4 MVCC整体操作流程</a></li>
</ul> 
   </li>
<li><a href="#5__202">5. 举例说明</a></li>
<li>
<ul>
<li><a href="#51_READ_COMMITTED_220">5.1 READ COMMITTED隔离级别下</a></li>
<li><a href="#52_REPEATABLE_READ_318">5.2 REPEATABLE READ隔离级别下</a></li>
<li><a href="#53__415">5.3 如何解决幻读</a></li>
</ul> 
   </li>
<li><a href="#6__460">6. 总结</a></li>
</ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2>
<a id="1_MVCC_6"></a>1. 什么是MVCC</h2> 
<p><code>MVCC </code>(Multiversion Concurrency Control)，多版本并发控制。顾名思义，MVCC是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p> 
<p>MVCC没有正式的标准，在不同的DBMS中 MVCC的实现方式可能是不同的，也不是普遍使用的(大家可以参考相关的DBMS文档)。这里讲解InnoDB 中 MVCC的实现机制（MySQL其它的存储引擎并不支持它)。</p> 
<h2>
<a id="2__12"></a>2. 快照读与当前读</h2> 
<p>MVCC在MySQL InnoDB中的实现主要是为了<code>提高数据库并发性能</code>，用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到<code>不加锁</code>，<code>非阻塞并发读</code>，而这个读指的就是快照读，而非当前读。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用<code>乐观锁</code>思想的一种方式。</p> 
<h3>
<a id="21__16"></a>2.1 快照读</h3> 
<p><code>快照读</code>又叫一致性读，读取的是<code>快照数据</code>。<mark>不加锁的简单的 SELECT 都属于快照读</mark>，即不加锁的非阻塞读；比如这样：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> player <span class="token keyword">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于<code>MVCC</code>，它在很多情况下，避免了加锁操作，降低了开销。</p> 
<p>既然是基于<code>多版本</code>，那么快照读<mark>可能读到的并不一定是数据的最</mark>新版本，而有可能是之前的历史版本。</p> 
<p>快照读的前提是隔离级别不是串行级别，<mark>串行级别下的快照读会退化成当前读</mark>。</p> 
<h3>
<a id="22__30"></a>2.2 当前读</h3> 
<p>当前读读取的<mark>是记录的最新版</mark>本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。<mark>加锁的 <code>SELECT</code>，或者对数据进行增删改都会进行当前读</mark>。比如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span> <span class="token comment"># 共享锁</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span> <span class="token comment"># 排他锁</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token keyword">values</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment"># 排他锁</span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment"># 排他锁</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment"># 排他锁</span>
</code></pre> 
<blockquote> 
 <p>注意：InnoDB增删改默认加X锁，查默认不加锁</p> 
</blockquote> 
<h2>
<a id="3__44"></a>3. 复习</h2> 
<h3>
<a id="31__46"></a>3.1 再谈隔离级别</h3> 
<p>事务有 4 个隔离级别，可能存在三种并发问题：（准确来说是四种，还有一种：<code>脏写</code>）</p> 
<p><img src="https://images2.imgbox.com/1f/8c/yEUqAnvt_o.png" alt="image-20230130164546130"></p> 
<p>在MySQL中，默认的隔离级别是<code>可重复读</code>，可以解<strong>决脏读和不可重复</strong>读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力</p> 
<p><mark>MVCC可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题</mark>！它可以在大多数情况下替代行级锁，降低系统的开销。</p> 
<p><img src="https://images2.imgbox.com/4a/87/pujZAJDB_o.png" alt="image-20230130164606259"></p> 
<blockquote> 
 <p>在面试的时候要按照第二幅图进行回答哦~</p> 
 <p>如果采用加锁的方式，那么就是间隙锁解决幻读问题。</p> 
</blockquote> 
<h3>
<a id="32_Undo_Log_62"></a>3.2 隐藏字段、Undo Log版本链</h3> 
<p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p> 
<ul>
<li>
<code>trx_id </code>: 每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给<code>trx_id</code>隐藏列</li>
<li>
<code>roll_pointer</code>:每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul> 
<p>**举例：**student表数据如下</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token punctuation">;</span>
<span class="token comment">/*
+----+--------+--------+
| id | name   | class  |
+----+--------+--------+
|  1 | 张三   | 一班    |
+----+--------+--------+
1 row in set (0.07 sec)
*/</span>
</code></pre> 
<p>假设插入该记录的<code>事务id</code>为8，那么此刻该条记录的示意图如下所示:</p> 
<p><img src="https://images2.imgbox.com/4f/88/3PWHkHeJ_o.png" alt="image-20230130164744113"></p> 
<blockquote> 
 <p>insert undo只在事务<code>回滚</code>时起作用，<mark>当事务提交后，该类型的undo日志就没用了</mark>，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放)。</p> 
</blockquote> 
<p>假设之后两个事务id分别为10、20的事务对这条记录进行UPDATE 操作，操作流程如下:</p> 
<table>
<thead><tr>
<th>发生时间顺序</th>
<th>事务10</th>
<th>事务20</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE student SET name=“李四”<br>WHERE id=1;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>UPDATE student SET name=“王五” <br>WHERE id=1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>UPDATE student SET name=“钱七”<br>WHERE id=1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>UPDATE student SET name=“宋八”<br>WHERE id=1;</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>能不能在两个事务中交叉更新同一条记录呢?<br> 不能！这不就是一个事务修改了另一个未提交事务修改过的数据，脏写。</p> 
 <p><mark>InnoDB使用锁来保证不会有脏写情况的发生</mark>，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</p> 
 <p><strong><font color="red">InnoDB增删改默认加x锁，查默认不加锁</font></strong></p> 
</blockquote> 
<p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个<code>roll_pointer</code>属性（<code>INSERT</code>操作对应的undo日志没有该属性，因为该记录并没有更早的版本)，可以将这些<code>undo日志</code>都连起来，串成一个链表:</p> 
<p>update写的时候是默认加了X锁的,20会等待10</p> 
<p><img src="https://images2.imgbox.com/f4/ab/h1bHHzUL_o.png" alt="image-20230130165215416"></p> 
<p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。</p> 
<p>每个版本中还包含生成该版本时对应的<code>事务id</code>。</p> 
<h2>
<a id="4_MVCCReadView_119"></a>4. MVCC实现原理之ReadView</h2> 
<p>MVCC 的实现依赖于：<mark>隐藏字段、Undo Log、Read View</mark></p> 
<h3>
<a id="41_ReadView_123"></a>4.1 什么是ReadView</h3> 
<p>在MVCC机制中，<code>多个事务对同一个行记录进行更新会产生多个历史快照</code>，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到<code>ReadView</code>了，它解决了<mark>行的可见性</mark>问题</p> 
<p>ReadView就是事务A在使用MVCC机制进行快照读操作时产生的<code>读视图</code>。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code>的ID（“活跃"指的就是，<mark>启动了但还没提交</mark>)</p> 
<blockquote> 
 <p>ReadView和事务是一对一的关系~ 也就是当事务中使用MVVC，且是Select时会生成一个ReadView~</p> 
</blockquote> 
<h3>
<a id="42__131"></a>4.2 设计思路</h3> 
<p>使用<code>READ UNCONNMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取的记录就是最新版本了。</p> 
<p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p> 
<p>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 <code>已经提交了的</code> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要<code>判断一下版本链中的哪个版本是当前事务可见的</code>，这是ReadView要解决的主要问题。</p> 
<p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p> 
<ul>
<li> <p><code>creator_trx_id </code>，创建这个 Read View 的事务 ID。</p> 
  <blockquote> 
   <p>说明：只有在对表中的记录做改动时（执行<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>这些语句时）才会为事务分配事务id，否则在一个<code>只读事务</code>中的事务id值都默认为<code>0</code>。</p> 
  </blockquote> </li>
<li> <p><code>trx_ids </code>，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code> 。</p> </li>
<li> <p><code>up_limit_id </code>，活跃的事务中最小的事务 ID。</p> </li>
<li> <p><code>low_limit_id </code>，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系统最大的事务id值，这里要注意是<code>系统中的事务id</code>，需要区别于正在活跃的事务ID。</p> 
  <blockquote> 
   <p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p> 
  </blockquote> </li>
</ul> 
<p><strong>举例：</strong></p> 
<p>trx_ids为trx2、trx3、trx5和trx8的集合，系统的最大事务ID (low_limit_id)为trx8+1(如果之前没有其他的新增事务)，活跃的最小事务ID (up_limit_id)为trx2。</p> 
<p><img src="https://images2.imgbox.com/2f/bb/uk6f0G5q_o.png" alt="image-20230130165359240"></p> 
<h3>
<a id="43_ReadView_159"></a>4.3 ReadView的规则</h3> 
<p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p> 
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id </code>值相同，意味着<mark>当前事务在访问它自己修改过的记录</mark>，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明<mark>生成该版本的事务在当前事务生成ReadView前已经提交</mark>，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明<mark>生成该版本的事务在当前事务生成ReadView后才开启</mark>，所以该版本不可以被当前事务访问。(不然会出现脏读)</li>
<li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id </code>和<code>low_limit_id</code>之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>trx_ids </code>列表中。 
  <ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul> </li>
</ul> 
<h3>
<a id="44_MVCC_170"></a>4.4 MVCC整体操作流程</h3> 
<p>了解了这些概念之后，来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p> 
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID；</li>
<li>获取(生成) ReadView；</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则（当前版本不能被访问），就需要从 <code>Undo Log</code> 中获取历史快照；</li>
<li>最后返回符合规则的数据。</li>
</ol> 
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p> 
<blockquote> 
 <p>InnoDB中，MVCC是通过<code>Undo Log + Read View</code>进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见。</p> 
 <p>Read View和事务是一对一对应的，而且Read View也是一个动态，不断变化的~</p> 
</blockquote> 
<p>在隔离级别为<code>读已提交</code>（Read Committed）时，<mark>一个事务中的每一次 SELECT 查询都会重新获取一次Read View</mark>。</p> 
<table>
<thead><tr>
<th>事务</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select * from student where id &gt;2;</td>
<td>获取一次Read View</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>select * from student where id &gt;2;</td>
<td>获取一次Read View</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>注意，此时同样的查询语句都会重新获取一次Read View，这时如果Read View 不同，就可能产生不可重复读或者幻读的情况。这样符合Read Committed的规则特点~</p> 
</blockquote> 
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为<mark>一个事务只在第一次SELECT的时候会获取一次Read View</mark>，而后面所有的SELECT都会复用这个Read View，如下表所示:</p> 
<p><img src="https://images2.imgbox.com/cf/6f/tONicr67_o.png" alt="image-20230131160657468"></p> 
<h2>
<a id="5__202"></a>5. 举例说明</h2> 
<p>假设现在student表中只有一条由<code>事务id</code>为<code>8</code>的事务插入的一条记录:</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token punctuation">;</span>
<span class="token comment">/*
+----+--------+--------+
| id | name   | class  |
+----+--------+--------+
|  1 | 张三   | 一班    |
+----+--------+--------+
1 row in set (0.07 sec)
*/</span>
</code></pre> 
<p>MVCC只能在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作。接下来看一下READ COMMITTED和REPEATABLE READ所谓的生成ReadView的时机不同到底不同在哪里</p> 
<h3>
<a id="51_READ_COMMITTED_220"></a>5.1 READ COMMITTED隔离级别下</h3> 
<p><strong><font color="red">READ COMMITTED ：每次读取数据前都生成一个ReadView</font></strong></p> 
<p>现在有两个 事务id 分别为 10 、 20 的事务在执行</p> 
<pre><code class="prism language-sql"><span class="token comment"># Transaction 10</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"李四"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"王五"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment"># Transaction 20</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># 更新了一些别的表的记录(为了分配事务id)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<blockquote> 
 <p>说明:事务执行过程中，只有在第一次真正修改记录时(比如使用INSERT、DELETE、UPDATE语句)，才会被分配一个单独的事务id，这个事务id是递增的。所以我们才在事务2中更新一些别的表的记录，目的是让它分配事务id。</p> 
</blockquote> 
<p>此刻，表student 中id为1的记录得到的<code>版本链表</code>如下所示：</p> 
<p><img src="https://images2.imgbox.com/f6/8d/7V1ZQqMJ_o.png" alt="image-20230131170029928"></p> 
<p>假设现在有一个使用 <code>READ COMMITTED</code> 隔离级别的事务开始执行：</p> 
<pre><code class="prism language-sql"><span class="token comment"># 使用READ COMMITTED隔离级别的事务</span>

<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># SELECT1：Transaction 10、20未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'张三'</span>
</code></pre> 
<p><strong>这个 SELECT1 的执行过程如下：</strong></p> 
<p>步骤1∶在执行<code>SELECT</code>语句时会先生成一个<code>ReadView </code>，ReadView的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>,<code>up_limit_id</code>为<code>10</code>, <code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p> 
<p>步骤2：从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的<code>trx_id</code>值为<code>10</code>，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p> 
<p>步骤3：下一个版本的列name的内容是’李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p> 
<p>步骤4：下一个版本的列name的内容是’张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</p> 
<p>之后，把 事务id 为 10 的事务提交一下：</p> 
<pre><code class="prism language-sql"><span class="token comment"># Transaction 10</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>

<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"李四"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"王五"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre> 
<p>然后再到 <code>事务id</code> 为 20 的事务中更新一下表 <code>student </code>中 <code>id </code>为 <code>1 </code>的记录：</p> 
<pre><code class="prism language-sql"><span class="token comment"># Transaction 20</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># 更新了一些别的表的记录</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"钱七"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"宋八"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>此刻，表student中 <code>id </code>为 <code>1 </code>的记录的版本链就长这样：</p> 
<p><img src="https://images2.imgbox.com/fe/d2/DGdVA9ys_o.png" alt="image-20230131170300061"></p> 
<p>然后再到刚才使用 <code>READ COMMITTED</code> 隔离级别的事务中继续查找这个 <code>id</code>为 <code>1</code> 的记录，如下：</p> 
<pre><code class="prism language-sql"><span class="token comment"># 使用READ COMMITTED隔离级别的事务</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>

<span class="token comment"># SELECT1：Transaction 10、20 均未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'张三'</span>

<span class="token comment"># SELECT2：Transaction 10提交，Transaction 20未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'王五'</span>
</code></pre> 
<p>这个<code>SELECT2</code>的执行过程如下:</p> 
<p>步骤1：在执行<code>SELECT</code>语句时会又会<code>单独生成</code>一个<code>ReadView</code>，该ReadView的<code>trx_ids</code>列表的内容就是<code>[20]</code>，<code>up_limit_id</code>为<code>20</code>，<code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p> 
<p>步骤2：从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是<code>’宋八’</code>，该版本的<code>trx_id</code>值为<code>20</code>，在trx_ids列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p> 
<p>步骤3∶下一个版本的列<code>name</code>的内容是‘<code>钱七</code>’，该版本的<code>trx_id</code>值为<code>20</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本</p> 
<p>步骤4∶下一个版本的列<code>name</code>的内容是’<code>王五</code>’，该版本的<code>trx_id</code>值为<code>10</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>20</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’<code>王五</code>’的记录。</p> 
<p>以此类推，如果之后<code>事务id</code>为<code>20</code>的记录也提交了，再次在使用<code>READ COMMITED</code> 隔离级别的事务查询表<code>student</code>中<code>id</code>值为<code>1</code>的记录时，得到的结果就是’<code>宋八</code>’了，具体流程我们就不分析了。</p> 
<blockquote> 
 <p>**强调：**使用<code>READ COMMITTED</code>隔离级别的事务在每次查询开始时都会生成一个独立的ReadView</p> 
</blockquote> 
<h3>
<a id="52_REPEATABLE_READ_318"></a>5.2 REPEATABLE READ隔离级别下</h3> 
<p>使用 <code>REPEATABLE READ</code> 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 <code>ReadView </code>，之后的查询就不会重复生成了。</p> 
<p>比如，系统里有两个 <code>事务id</code> 分别为 <code>10 </code>、 <code>20 </code>的事务在执行：</p> 
<pre><code class="prism language-sql"><span class="token comment"># Transaction 10</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"李四"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"王五"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment"># Transaction 20</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># 更新了一些别的表的记录</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>此刻，表student 中 <code>id </code>为 <code>1 </code>的记录得到的版本链表如下所示：</p> 
<p><img src="https://images2.imgbox.com/05/5d/AsbEZw4Z_o.png" alt="image-20230131170424180"></p> 
<p>假设现在有一个使用 <code>REPEATABLE READ</code> 隔离级别的事务开始执行：</p> 
<pre><code class="prism language-sql"><span class="token comment"># 使用REPEATABLE READ隔离级别的事务</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>

<span class="token comment"># SELECT1：Transaction 10、20未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'张三'</span>
</code></pre> 
<p>这个<code>SELECT1</code>的执行过程如下:</p> 
<p>步骤1：在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id</code>为<code>10</code>, <code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p> 
<p>步骤2：然后从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是’<code>王五</code>’，该版本的<code>trx_id</code>值为<code>10</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p> 
<p>步骤3：下一个版本的列<code>name</code>的内容是’<code>李四</code>’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p> 
<p>步骤4：下一个版本的列name的内容是’<code>张三</code>’，该版本的<code>trx_id</code>值为<code>8</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>10</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为’<code>张三</code> ’的记录</p> 
<p>之后，我们把<code>事务id</code>为<code>10</code>的事务提交一下，就像这样:</p> 
<pre><code class="prism language-sql"><span class="token comment"># Transaction 10</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>

<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"李四"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"王五"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre> 
<p>然后再到 <code>事务id</code> 为 <code>20 </code>的事务中更新一下表 student 中 id 为 1 的记录：</p> 
<pre><code class="prism language-sql"><span class="token comment"># Transaction 20</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>

<span class="token comment"># 更新了一些别的表的记录</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"钱七"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"宋八"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>此刻，表student 中 <code>id </code>为 <code>1 </code>的记录的版本链长这样：</p> 
<p><img src="https://images2.imgbox.com/2f/87/b0hObo16_o.png" alt="image-20230131170550677"></p> 
<p>然后再到刚才使用 <code>REPEATABLE READ</code> 隔离级别的事务中继续查找这个<code>id </code>为 <code>1 </code>的记录，如下：</p> 
<pre><code class="prism language-sql"><span class="token comment"># 使用REPEATABLE READ隔离级别的事务</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>

<span class="token comment"># SELECT1：Transaction 10、20均未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为'张三'</span>

<span class="token comment"># SELECT2：Transaction 10提交，Transaction 20未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值仍为'张三'</span>
</code></pre> 
<p><code>SELECT2</code>的执行过程如下:</p> 
<p>步骤1：因为当前事务的隔离级别为<code>REPEATABLE READ</code>，而之前在执行<code>SELECT1</code>时已经生成过<code>ReadView</code>了，所以此时直接复用之前的ReadView，之前的<code>ReadView</code>的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id</code>为<code>10</code>，<code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p> 
<p>步骤2：然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是’<code>宋八</code>’，该版本的<code>trx_id</code>值为<code>20</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本</p> 
<p>步骤3：下一个版本的列<code>name</code>的内容是’<code>钱七</code>’，该版本的<code>trx_id</code>值为<code>20</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本</p> 
<p>步骤4：下一个版本的列<code>name</code>的内容是’<code>王五</code>’，该版本的<code>trx_id</code>值为<code>10</code>，而trx_ids列表中是包含值为10的事务id的，所以该版本也不符合要求，同理下一个列<code>name</code>的内容是‘<code>李四</code>’的版本也不符合要求。继续跳到下一个版本</p> 
<p>步骤5：下一个版本的列<code>name</code>的内容是’<code>张三</code>’，该版本的<code>trx_id</code>值为<code>8</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为‘<code>张三</code>’的记录。</p> 
<p>两次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是‘<code>张三</code>’，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>20</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>id</code>为<code>1</code>的记得到的结果还是‘<code>张三</code>’，具体执行过程大家可以自己分析一下。</p> 
<h3>
<a id="53__415"></a>5.3 如何解决幻读</h3> 
<p>接下来说明InnoDB 是如何解决幻读的。</p> 
<p>假设现在表 student 中只有一条数据，数据内容中，主键 <code>id=1</code>，隐藏的 <code>trx_id=10</code>，它的 undo log 如下图所示。</p> 
<p><img src="https://images2.imgbox.com/fc/6f/jhRpR52b_o.png" alt="image-20230131170636804"></p> 
<p>假设现在有事务 A 和事务 B 并发执行， <code>事务 A</code> 的事务 id 为 <code>20 </code>， <code>事务 B</code> 的事务 id 为 <code>30 </code>。</p> 
<p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： <code>trx_ids=[20,30]</code> ，<code>up_limit_id=20</code> ，<code> low_limit_id=31</code> ， <code>creator_trx_id=20</code> 。</p> 
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id=10，<code>小于</code>事务 A 的 ReadView 里 <code>up_limit_id</code>，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p> 
<p>结论：事务 A 的第一次查询，能读取到一条数据，id=1。</p> 
<p>步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并<code>提交</code>事务</p> 
<pre><code class="prism language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'王五'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p> 
<p><img src="https://images2.imgbox.com/c9/1d/tMJdPfvc_o.png" alt="image-20230131170730357"></p> 
<p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并<code>不会再重新生成ReadView</code>。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p> 
<p>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。</p> 
<p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到</p> 
<p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见</p> 
<p><img src="https://images2.imgbox.com/4d/7e/wwS8h9bD_o.png" alt="image-20230131170811967"></p> 
<p>结论：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p> 
<h2>
<a id="6__460"></a>6. 总结</h2> 
<p>这里介绍了 <code>MVCC </code>在 <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的 <code>读-写</code> 、 <code>写-读</code> 操作并发执行，从而提升系统性能</p> 
<p>核心点在于 <code>ReadView </code>的原理， <code>READ COMMITTD 、 REPEATABLE READ</code> 这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p> 
<ul>
<li> <p>READ COMMITTD 在每一次进行普通SELECT操作前都会生成一个ReadView</p> </li>
<li> <p>REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了</p> </li>
</ul> 
<blockquote> 
 <p>说明：之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的<code>delete mark</code>操作(标记0-&gt;1)，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。另外后面回滚也可能用到这个delete mark~</p> 
</blockquote> 
<p>通过 MVCC 可以解决:</p> 
<ul>
<li> <p><code>读写之间阻塞的问题</code>。通过MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力</p> </li>
<li> <p><code>降低了死锁的概率</code>。这是因为MVCC采用了<code>乐观锁</code>的方式，读取数据时并不需要加锁，对于写操作，也只锁 定必要的行</p> </li>
<li> <p><code>解决快照读的问题</code>。当查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果</p> </li>
</ul>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>