<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>高并发内存池项目（C&#43;&#43;实战项目） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高并发内存池项目（C&#43;&#43;实战项目）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#_1">?项目介绍</a></li>
<li>
<ul>
<li><a href="#_3">◎项目来源</a></li>
<li>
<ul><li><a href="#_8">▶项目源码</a></li></ul>
   </li>
<li><a href="#_12">◎内存池相关知识</a></li>
<li>
<ul>
<li><a href="#1_14">1、池化技术</a></li>
<li><a href="#2_22">2、内存池</a></li>
<li><a href="#3_26">3、内存池主要解决的问题</a></li>
<li><a href="#4malloc_35">4、malloc</a></li>
</ul>
  </li>
</ul>
  </li>
<li><a href="#_39">?设计思路</a></li>
<li>
<ul>
<li><a href="#_41">◎第一阶段–设计一个定长的内存池</a></li>
<li>
<ul><li><a href="#_46">适应平台的指针方案</a></li></ul>
   </li>
<li><a href="#_205">◎第二阶段–高并发内存池整体框架设计</a></li>
<li>
<ul>
<li><a href="#1thread_cache_217">1.线程缓存（thread cache）</a></li>
<li><a href="#2central_cache_221">2.中心缓存（central cache）</a></li>
<li><a href="#3page_cache_225">3.页缓存（page cache）</a></li>
</ul>
   </li>
<li><a href="#_231">◎第三阶段–三级缓存的具体实现</a></li>
<li>
<ul>
<li><a href="#1Thread_Cache_233">1.Thread Cache框架构建及核心实现</a></li>
<li>
<ul>
<li><a href="#_239">?申请与释放内存的规则及无锁访问</a></li>
<li><a href="#_259">?管理内存对齐和映射等关系</a></li>
<li>
<ul>
<li><a href="#_261">▶计算对齐大小映射的规则</a></li>
<li><a href="#_279">▶计算相应内存映射在哪一个哈希桶中</a></li>
<li><a href="#_335">▶代码实现</a></li>
</ul>
     </li>
<li><a href="#_478">?自由链表的设计</a></li>
<li><a href="#thread_cache_547">?thread cache框架构建</a></li>
<li><a href="#thread_cache_576">?thread cache核心实现</a></li>
</ul>
    </li>
<li><a href="#2central_cache_681">2.central cache框架构建及核心实现</a></li>
<li>
<ul>
<li><a href="#_689">?申请与释放内存规则</a></li>
<li>
<ul><li><a href="#_694">▶慢开始算法</a></li></ul>
     </li>
<li><a href="#SpanSpanList_719">?管理多个大块内存的跨度结构Span及SpanList定义</a></li>
<li><a href="#central_cache_816">?central cache框架构建</a></li>
<li><a href="#central_cache_856">?central cache核心实现</a></li>
</ul>
    </li>
<li><a href="#3page_cache_1030">3.page cache框架构建及核心实现</a></li>
<li>
<ul>
<li><a href="#_1035">?申请与释放内存</a></li>
<li>
<ul>
<li><a href="#_1047">▶直接向堆申请或释放以页为单位的大块内存</a></li>
<li><a href="#Span_1070">▶Span跨度结构以页为单位管理从堆申请的内存</a></li>
</ul>
     </li>
<li><a href="#page_cache_1074">?page cache框架构建</a></li>
<li><a href="#page_cache_1112">?page cache核心实现</a></li>
</ul>
   </li>
</ul>
  </li>
</ul>
  </li>
<li><a href="#_1348">?细节与性能优化</a></li>
<li>
<ul>
<li><a href="#new_1350">◎使用定长内存池配合脱离使用new</a></li>
<li><a href="#256kb_1366">◎解决内存大于256kb的申请释放问题</a></li>
<li><a href="#_1440">◎使用基数树进行性能优化</a></li>
</ul>
  </li>
<li><a href="#_1690">?项目总结</a></li>
<li>
<ul>
<li><a href="#_1692">◎结果演示</a></li>
<li><a href="#malloc_1698">◎项目对比malloc性能高的原因</a></li>
<li><a href="#_1710">◎项目扩展及缺陷</a></li>
<li><a href="#_1724">◎收获与总结</a></li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<h1>
<a id="_1"></a>?项目介绍</h1> 
<h2>
<a id="_3"></a>◎项目来源</h2> 
<p>本项目实现了一个高并发内存池，参考了Google的开源项目tcmalloc实现的简易版；其功能就是实现高效的多线程内存管理。由功能可知，高并发指的是高效的多线程，而内存池则是实现内存管理的。<br> <a href="https://github.com/google/tcmalloc">tcmalloc源码</a></p> 
<h3>
<a id="_8"></a>▶项目源码</h3> 
<p><a href="https://gitee.com/linkylo/concurrent-memorypoll">高并发内存池项目源码</a></p> 
<h2>
<a id="_12"></a>◎内存池相关知识</h2> 
<h3>
<a id="1_14"></a>1、池化技术</h3> 
<p><strong>池化技术就是程序先向系统申请过量的资源，并将这些资源管理起来，避免频繁的申请和释放资源导致的开销</strong>。</p> 
<p>内存池可以使用池化技术来维护可用内存块的链表。当程序需要分配内存时，内存池会从链表中分配一个可用的内存块。如果没有可用的内存块，内存池会从操作系统申请更多的内存，并将新分配的内存块添加到链表中。当程序释放内存时，内存池会将内存块添加回链表中，以便将来使用。</p> 
<p>池化技术可以有效地减少内存碎片，因为它可以将多个小内存块组合成更大的内存块，这样就可以分配更大的连续内存空间，并减少碎片。此外，池化技术还可以提高内存使用效率，因为它可以快速分配和释放内存，而无需每次都调用操作系统的内存分配和释放函数。</p> 
<h3>
<a id="2_22"></a>2、内存池</h3> 
<p><strong>内存池指的是程序预先向操作系统申请足够大的一块内存空间；此后，程序中需要申请内存时，不需要直接向操作系统申请，而是直接从内存池中获取；同理，程序释放内存时，也不是将内存直接还给操作系统，而是将内存归还给内存池</strong>。当程序退出（或者特定时间）时，内存池才将之前申请的内存真正释放。</p> 
<h3>
<a id="3_26"></a>3、内存池主要解决的问题</h3> 
<p>由上可知，内存池首要解决的是效率问题，其次从系统的内存分配器角度出发，还需要解决内存碎片的问题。那么什么是内存碎片问题呢？</p> 
<p>内存碎片分为外碎片和内碎片。</p> 
<ul>
<li>外碎片由下图所示：对于程序员申请的内存，可能因为频繁的申请和释放内存导致内存空间不连续，那么就会出现明明由足够大的内存空间，但程序员却申请不出连续的空间出来，这便是外碎片问题了。</li>
<li>内碎片则是由于一些对齐的需求，导致分配出去的内存空间无法被利用，比如本项目中的<code>Round(Size)</code>对size进行的对齐。</li>
</ul> 
<h3>
<a id="4malloc_35"></a>4、malloc</h3> 
<p>C语言中动态申请内存是通过malloc函数去申请内存的，但是实际上malloc并不是直接向堆申请内存的，而<strong>malloc也可以使用内存池来管理内存分配</strong>，在某些情况下，操作系统或C语言标准库可能会使用内存池来管理堆内存，以提高内存分配效率。当程序将malloc管理的内存池中内存全部申请完时，malloc函数就会继续向操作系统申请空间。</p> 
<h1>
<a id="_39"></a>?设计思路</h1> 
<h2>
<a id="_41"></a>◎第一阶段–设计一个定长的内存池</h2> 
<p>我们知道malloc函数申请内存空间是通用的，即任何场景下都可以使用，但是<strong>各方面都通用就意味着各方面都不顶尖</strong>，那么我们可以设计一个定长内存池来保证特定场景下的内存申请效率要高于malloc函数。<br> <img src="https://images2.imgbox.com/c6/91/r8bo0fx5_o.png" alt="image-20221231222658167"></p> 
<h3>
<a id="_46"></a>适应平台的指针方案</h3> 
<p>在这里，我们想取出一块对象内存中的前4个字节（32位系统）或者8个字节（64位系统）的内存来存储一个指针指向下一块释放回来的自由对象内存，那么在这里为了不作平台系统的判断，可以使用一个小技巧，即将对象内存强转成<code>void**</code> 的类型，那么<strong>再对这个二级指针类型解引用就可以取出当前对象的前4个字节（32位系统）或8个字节（64位系统）</strong>。</p> 
<p>由于这个操作之后会频繁使用，因此定义为内敛函数放在common.h头文件中方便调用：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> <span class="token function">NextObj</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由此，我们就可以设计出<strong>定长内存池</strong>的对象：</p> 
<blockquote> 
 <p>定长内存池池的基本思想是在程序运行时预先分配一大块内存，然后在需要使用某个对象时，从这块内存中分配给它。当对象不再使用时，将它归还给对象池，供其他对象使用。这样做的好处在于减少了内存分配和释放的次数，从而减少了内存碎片的产生，并降低了内存分配的开销。</p> 
 <p>在这段代码中，<code>ObjectPool</code> 类的主要功能包括：</p> 
 <ul>
<li>
<code>New()</code> 函数：用于分配一个新的对象，如果有自由链表中有空闲的对象，则直接从自由链表中取出；否则，如果当前剩余内存块大小不够一个对象的大小，则重新申请一个内存块。申请到内存后，调用对象的构造函数来进行初始化。</li>
<li>
<code>Delete()</code> 函数：用于释放一个对象，调用对象的析构函数进行清理，然后将其加入自由链表中。</li>
</ul> 
 <p>在这段代码中，<code>ObjectPool</code> 类的成员变量包括：</p> 
 <ul>
<li> <p><code>_memory</code>：指向当前申请的内存块的指针。</p> </li>
<li> <p><code>_remainBytes</code>：当前内存块剩余的字节数。</p> </li>
<li> <p><code>_freeList</code>：自由链表的头指针，用于保存当前有哪些对象可以被重复利用。</p> </li>
</ul> 
 <p>在这段代码中，还有一个函数 <code>SystemAlloc()</code>，这是为了避免使用malloc而使用的，它的作用是申请一个新的内存块。如果申请失败，则抛出 <code>std::bad_alloc</code> 异常。</p> 
 <p>总的来说，这段代码实现了一个简单的对象池，可以有效地管理类型为 <code>T</code> 的对象的内存分配和释放，从而减少了内存碎片的产生，并降低了内存分配的开销。</p> 
</blockquote> 
<pre><code class="prism language-c">template<span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span> 
class ObjectPool
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	T<span class="token operator">*</span> <span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		T<span class="token operator">*</span> obj <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
		<span class="token comment">// 如果自由链表非空，以“头删”的方式从自由链表取走内存块，重复利用</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 技巧：(void**)强转方便32位下获取前4字节，64位下获取前8字节</span>
			<span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span> 
			obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">;</span>
			_freeList <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 剩余内存_remainBytes不够一个对象大小时，重新开一块大空间</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_remainBytes <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				_remainBytes <span class="token operator">=</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

				<span class="token comment">// 分配了 _remainBytes 个字节的空间,即(128 *1024字节，128KB）</span>
				<span class="token comment">// memory = (char*)malloc(_remainBytes); </span>
				
				<span class="token comment">// &gt;&gt;13 其实就是一页8KB的大小，可以得到具体多少页</span>
				_memory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">SystemAlloc</span><span class="token punctuation">(</span>_remainBytes <span class="token operator">&gt;&gt;</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_memory <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					throw std<span class="token operator">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span>
			<span class="token comment">// 保证一次分配的空间够存放下当前平台的指针</span>
			<span class="token class-name">size_t</span> objSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 大块内存块往后走，前面objSize大小的内存该分配出去了</span>
			_memory <span class="token operator">+=</span> objSize<span class="token punctuation">;</span> 
			_remainBytes <span class="token operator">-=</span> objSize<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 定位new显式调用T类型构造函数:在内存地址obj处创建一个新的T类型的对象，并调用该对象的构造函数。</span>
		<span class="token comment">// 与普通的new运算符不同的是，它不会使用动态内存分配器来分配内存，而是使用指定的内存地址。</span>
		<span class="token function">new</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>T<span class="token punctuation">;</span>
		<span class="token keyword">return</span> obj<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//将obj这块内存链接到_freeList中</span>
	<span class="token keyword">void</span> <span class="token function">Delete</span><span class="token punctuation">(</span>T<span class="token operator">*</span> obj<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//显式调用obj对象的析构函数,清理空间</span>
		obj<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">//将obj内存块头插</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		_freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
private<span class="token operator">:</span>
	<span class="token keyword">char</span><span class="token operator">*</span> _memory <span class="token operator">=</span> nullptr<span class="token punctuation">;</span> <span class="token comment">// 指向大块内存的指针</span>
	<span class="token class-name">size_t</span> _remainBytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 大块内存在切分过程中的剩余字节数</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> nullptr<span class="token punctuation">;</span> <span class="token comment">// 自由链表的头指针，用于保存当前有哪些对象可以被重复利用。</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>对于我们设计的定长内存池，可以通过下面的测试代码来比较一下malloc与定长内存池的效率：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> _val<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> _left<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> _right<span class="token punctuation">;</span>

	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_val</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_left</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_right</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_left</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_right</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">TestObjectPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 申请释放的轮次</span>
	<span class="token keyword">const</span> <span class="token class-name">size_t</span> Rounds <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token comment">// 每轮申请释放多少次</span>
	<span class="token keyword">const</span> <span class="token class-name">size_t</span> N <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
	v1<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> Rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>new TreeNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			delete v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		v1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">size_t</span> end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ObjectPool<span class="token operator">&lt;</span>TreeNode<span class="token operator">&gt;</span> TNPool<span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>
	v2<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> Rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>TNPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			TNPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		v2<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">size_t</span> end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"new cost time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"object pool cost time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d8/94/3weJ6rbM_o.png" alt="image-20221229202903930"></p> 
<p>可以明显的看出，定长内存池的开销是要低于malloc的，由此可见，在特定场景下，定长内存池的效率高于malloc函数。</p> 
<h2>
<a id="_205"></a>◎第二阶段–高并发内存池整体框架设计</h2> 
<p>现代开发环境大多都是多核多线程，那么在申请内存的场景下，必然存在激烈的锁竞争问题。其实，malloc本身就已经足够优秀了，但本项目的原型tcmalloc将在多线程高并发的场景下更胜一筹。</p> 
<p>而本项目实现的内存池将考虑以下几方面的问题：</p> 
<ul>
<li>1.性能问题</li>
<li>2.多线程场景下的锁竞争问题</li>
<li>3.内存碎片问题</li>
</ul> 
<p>concurrent memory pool（并发内存池），主要有以下3个部分组成：</p> 
<h3>
<a id="1thread_cache_217"></a>1.线程缓存（thread cache）</h3> 
<p>线程缓存是每个线程独有的，用于小于256kb内存的分配。那么对于每一个线程从thread cache申请资源，就<strong>无需考虑加锁问题，每个线程独享一个缓存（cache）</strong>，这也是并发线程池高效的地方。</p> 
<h3>
<a id="2central_cache_221"></a>2.中心缓存（central cache）</h3> 
<p>中心缓存有所有线程所共享，thread cache 按需从central cache处获取对象，而central cache在合适的时机从thread cache处回收对象从而避免一个线程占用太多资源，导致其他线程资源吃紧，进而<strong>实现内存分配在多个线程更加均衡的按需调度</strong>。由于所有thread cache都从一个central cache中取内存对象，故central cache是存在竞争的，也就是说从central cache中取内存对象需要加锁，但我们在central cache这里用的是桶锁，且只有thread cache中没有对象后才会来central cache处取对象，因此锁的竞争不会很激烈。</p> 
<h3>
<a id="3page_cache_225"></a>3.页缓存（page cache）</h3> 
<p>页缓存是中心缓存上一级的缓存，存储并分配以页为单位的内存，central cache中没有内存对象时，会从page cache中分配出一定数量的page，并切割成定长大小的小块内存，给central cache。当page cache中一个span的几个跨度页都回收以后，page cache会回收central cache中满足条件的span对象，并且合并相邻的页，组成更大的页，从而缓解内存碎片（外碎片）的问题。</p> 
<p><img src="https://images2.imgbox.com/8c/00/jjjNOP5T_o.png" alt="image-20221231222738763"></p> 
<h2>
<a id="_231"></a>◎第三阶段–三级缓存的具体实现</h2> 
<h3>
<a id="1Thread_Cache_233"></a>1.Thread Cache框架构建及核心实现</h3> 
<p>thread cache是<strong>哈希桶结构</strong>，每个桶是一个根据桶位置映射的挂接内存块的自由链表，每个线程都会有一个thread cache对象，这样就可以保证线程在申请和释放对象时是无锁访问的。</p> 
<p><img src="https://images2.imgbox.com/3d/7e/olcxBU5T_o.png" alt="image-20221231222810584"></p> 
<h4>
<a id="_239"></a>?申请与释放内存的规则及无锁访问</h4> 
<ul><li>申请内存</li></ul> 
<ol>
<li>当内存申请大小size不超过256KB，则先获取到线程本地存储的thread cache对象，计算size映射的哈希桶自由链表下标i。</li>
<li>如果自由链表_freeLists[i]中有对象，则直接Pop一个内存对象返回。</li>
<li>如果_freeLists[i]中没有对象时，则批量从central cache中获取一定数量的对象，插入到自由链表并返回一个对象。</li>
</ol> 
<p><strong>释放内存</strong><br> 1.当释放内存小于256kb时将内存释放回thread cache，计算size映射自由链表桶位置i，将对象Push到_freeLists[i]。<br> 2.当链表的长度过长，则回收一部分内存对象到central cache。</p> 
<p><strong>tls - thread local storage</strong><br> 线程局部存储（tls），是一种变量的存储方法，这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。而熟知的全局变量，是所有线程都可以访问的，这样就不可避免需要锁来控制，增加了控制成本和代码复杂度。</p> 
<pre><code class="prism language-c"><span class="token comment">//TLS: thread local storage，实现线程的无锁访问</span>
<span class="token keyword">static</span> <span class="token function">_declspec</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span> ThreadCache<span class="token operator">*</span> pTLSThreadCache <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
</code></pre> 
<h4>
<a id="_259"></a>?管理内存对齐和映射等关系</h4> 
<h5>
<a id="_261"></a>▶计算对齐大小映射的规则</h5> 
<p>thread cache中的哈希桶映射比例比非均匀的，如果将内存大小均匀划分的话，则会划分出大量的哈希桶，比如256kb如果按照8byte划分，则会创建32768个哈希桶，这就有较大的内存开销；而如果按照更大的字节划分，那么内存开销虽然减少了，但照顾到的场景也少了，且会产生内碎片问题。</p> 
<p>那么参考tcmalloc项目，为了保证内碎片的浪费整体控制在10%左右进行的区间映射，同时没有那么大的开销。使用<code>RoundUp</code> 函数的将输入的 <code>size</code> 对齐到一个固定的对齐值。对齐值是根据 <code>size</code> 的大小而定的，它分成了五个区间：</p> 
<ul>
<li>如果 <code>size</code> 位于 <code>[1,128]</code> 之间，那么 <code>size</code> 将被对齐到 8 字节。</li>
<li>如果 <code>size</code> 位于 <code>[128+1,1024]</code> 之间，那么 <code>size</code> 将被对齐到 16 字节。</li>
<li>如果 <code>size</code> 位于 <code>[1024+1,8*1024]</code> 之间，那么 <code>size</code> 将被对齐到 128 字节。</li>
<li>如果 <code>size</code> 位于 <code>[8*1024+1,64*1024]</code> 之间，那么 <code>size</code> 将被对齐到 1024 字节。</li>
<li>如果 <code>size</code> 位于 <code>[64*1024+1,256*1024]</code> 之间，那么 <code>size</code> 将被对齐到 8192 字节。</li>
</ul> 
<blockquote> 
 <p>这个函数内部使用了另外一个静态函数 <code>_RoundUp</code> 来实际计算对齐后的值。</p> 
</blockquote> 
<p>也就是说，对于1byte到128byte的内存对象，按照8byte对齐，划分为下标0-15号的哈希桶，而129byte到1kb的内存对象，按照16byte对齐，划分下标16-71号的哈希桶，以此类推，最终划分为0-207号总共208个哈希桶，这样就保证了内存较小的开销，同时各个对齐关系中内碎片浪费控制在10%左右，比如129byte到144byte区间，取144byte的内存对象，浪费率为(144 - 129) / 144 = 10.42%,当然对于最开始的1byte申请8byte内存对象，虽然浪费高达87.5%，但考虑到最终内碎片浪费了7byte，对比后续内碎片一次浪费7kb来说可以忽略不计了。</p> 
<p>这便是申请的内存对象大小对齐的映射关系，这个关系在后续central cache及page cache中仍有应用，因此可以将其定义在头文件common.h中，以后内存大小对齐的管理。</p> 
<h5>
<a id="_279"></a>▶计算相应内存映射在哪一个哈希桶中</h5> 
<p>这里使用<code>Index</code> 函数计算将输入的 <code>size</code> 映射到哪个自由链表桶（freelist）。和 <code>RoundUp</code> 函数一样，这个函数也根据 <code>size</code> 的大小将它分成了五个区间，但是它返回的是一个数组下标。数组的大小和每个区间内的自由链表桶数量是固定的。</p> 
<blockquote> 
 <p>这个函数内部使用了另一个静态函数 <code>_Index</code> 来计算桶的下标。在代码中，<code>size</code> 表示要被对齐的内存块的大小，<code>alignNum</code> 表示对齐的值，<code>align_shift</code> 表示对齐的值的二进制位数。</p> 
</blockquote> 
<p><strong>关于 <code>_RoundUp</code>和<code> _Index</code>:</strong></p> 
<p>对于 <code>_RoundUp</code> 函数，它使用位运算将 <code>size</code> 对齐到最接近它的大于等于它的 <code>alignNum</code> 的倍数。这里有一个简单的例子：假设我们有一个值 <code>size=11</code>，我们想将它对齐到 <code>alignNum=8</code> 的倍数。那么 <code>_RoundUp</code> 函数会返回 16，因为 16 是最接近 11 且大于等于 11 的 <code>alignNum</code> 的倍数。</p> 
<p>对于 <code>_Index</code> 函数，它计算的是将 <code>size</code> 映射到桶链的下标。它的计算方法是将 <code>size</code> 向上对齐到最接近它的大于等于它的 <code>2^align_shift</code> 的倍数，然后再减去 1。这个函数的作用和 <code>_RoundUp</code> 函数类似，但是它<strong>返回的是下标而不是对齐后的值</strong>。</p> 
<pre><code class="prism language-c"><span class="token comment">//计算对齐数</span>
<span class="token class-name">size_t</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">size_t</span> alignNum<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">size_t</span> alignSize<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">%</span> alignNum <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        alignSize <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> alignNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> alignNum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        alignSize <span class="token operator">=</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> alignSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//计算对应链桶的下标</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">size_t</span> <span class="token function">_Index</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> bytes<span class="token punctuation">,</span> <span class="token class-name">size_t</span> alignNum<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">%</span> alignNum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> bytes <span class="token operator">/</span> alignNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> bytes <span class="token operator">/</span> alignNum<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是参考tcmalloc源码，考虑到位移运算更加接近底层，效率更高，而实际应用中映射对应关系的计算是相当频繁的，因此使用位运算来改进算法。</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">size_t</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> bytes<span class="token punctuation">,</span> <span class="token class-name">size_t</span> alignNum<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes <span class="token operator">+</span> alignNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>alignNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">size_t</span> <span class="token function">_Index</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> bytes<span class="token punctuation">,</span> <span class="token class-name">size_t</span> align_shift<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> align_shift<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> align_shift<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="_335"></a>▶代码实现</h5> 
<pre><code class="prism language-c"><span class="token comment">// 计算对象大小的对齐映射规则</span>
class SizeClass
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token comment">// 整体控制在最多10%左右的内碎片浪费</span>
	<span class="token comment">// [1,128]					8byte对齐	    freelist[0,16)</span>
	<span class="token comment">// [128+1,1024]				16byte对齐	    freelist[16,72)</span>
	<span class="token comment">// [1024+1,8*1024]			128byte对齐	    freelist[72,128)</span>
	<span class="token comment">// [8*1024+1,64*1024]		1024byte对齐     freelist[128,184)</span>
	<span class="token comment">// [64*1024+1,256*1024]		8*1024byte对齐   freelist[184,208)</span>

	<span class="token comment">// 使用位运算将 size 对齐到最接近它的大于等于它的 alignNum 的倍数</span>
	<span class="token comment">// 比如size = 11对齐到16</span>
	<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">size_t</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> bytes<span class="token punctuation">,</span> <span class="token class-name">size_t</span> alignNum<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes <span class="token operator">+</span> alignNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>alignNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">size_t</span> <span class="token function">RoundUp</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">128</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">1024</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 将 size 映射到桶链的下标：</span>
	<span class="token comment">// 这个函数的作用和 _RoundUp 函数类似，但是它返回的是下标而不是对齐后的值。</span>
	<span class="token comment">// 比如size = 11映射下标到(2 - 1 = 1) </span>
	<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">size_t</span> <span class="token function">_Index</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> bytes<span class="token punctuation">,</span> <span class="token class-name">size_t</span> align_shift<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> align_shift<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> align_shift<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 计算映射的哪一个自由链表桶</span>
	<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">size_t</span> <span class="token function">Index</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> bytes<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 每个区间有多少个链</span>
		<span class="token keyword">static</span> <span class="token keyword">int</span> group_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">56</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 打表</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">128</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">1024</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> 
        <span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 计算ThreadCache一次从中心缓存CentralCache获取多少个小对象，总的大小就是MAX_BYTES = 256KB</span>
	<span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">NumMoveSize</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// [2, 512]，一次批量移动多少个对象的(慢启动)上限值</span>
		<span class="token comment">// 小对象一次批量上限高</span>
		<span class="token comment">// 小对象一次批量上限低</span>
		<span class="token keyword">int</span> num <span class="token operator">=</span> MAX_BYTES <span class="token operator">/</span> size<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
			num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&gt;</span> <span class="token number">512</span><span class="token punctuation">)</span>
			num <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span>

		<span class="token keyword">return</span> num<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 计算中心缓存CentralCache一次向PageCache获取多少页</span>
	<span class="token comment">// 单个对象 8byte</span>
	<span class="token comment">// ...</span>
	<span class="token comment">// 单个对象 256KB</span>
	<span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">NumMovePage</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 计算一次从中心缓存获取的对象个数num</span>
		<span class="token class-name">size_t</span> num <span class="token operator">=</span> <span class="token function">NumMoveSize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token comment">// 单个对象大小与对象个数相乘,获得一次需要向PageCache申请的内存大小</span>
		<span class="token class-name">size_t</span> npage <span class="token operator">=</span> num <span class="token operator">*</span> size<span class="token punctuation">;</span>

		npage <span class="token operator">&gt;&gt;=</span> PAGE_SHIFT<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>npage <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			npage <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> npage<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>NumMoveSize 函数的作用是计算一次从中心缓存获取多少个对象</strong>。它的计算方法是首先将单个对象大小除以总的缓存大小 MAX_BYTES，得到的结果即为一次从中心缓存获取的对象个数。为了避免数量太少或太多，可以设置一个范围，在 [2, 512] 之间。如果计算出的对象数量不在这个范围内，就取边界值。</p> 
<p><strong>NumMovePage函数的作用是计算中心缓存CentralCache一次向PageCache获取多少页</strong>。一页的大小是由PAGE_SHIFT指定的。本项目中一个页大小是8KB，即2的13次方，所以<code>PAGE_SHIFT = 13</code>。NumMovePage函数先调用NumMoveSize函数计算出一次从CentralCache获取多少个对象，然后乘上对象大小，就获得需要向PageCache申请的内存大小，然后除以单个页的大小（左移PAGE_SHIFT）即可获得向PageCache申请的总页数。</p> 
<p><strong>突击检查：static inline 函数和 inline函数有什么区别呢？</strong></p> 
<p>inline内联函数：为了减少因函数调用而引起的系统开销，内联函数实际上是以空间换效率的一种做法。编译器会尽量将 inline 函数的代码插入到调用函数的代码中，从而减少函数调用的开销。inline 函数的主要优点是可以提高程序的执行效率，因为省去了函数调用的开销。但是，inline 函数的缺点是会降低程序的可读性，代码会变得复杂。</p> 
<p>static inline 函数是一种特殊的函数，它同时具有 inline 函数的优点和 static 函数的优点。<strong>static 函数是指在编译期间就将函数体内的代码插入到调用函数的代码中，并且只在本文件中可见。static 函数的主要优点是可以隐藏函数的实现细节，只提供接口</strong>。所以<strong>在头文件中务必要加上static inline，否则和普通函数一样，当多个CPP文件包含是就会重复定义</strong>。所以加入static提高代码健壮性。</p> 
<p>因此，static inline 函数既可以提高程序的执行效率，又可以隐藏函数的实现细节，是一种很好的函数声明方式。</p> 
<h4>
<a id="_478"></a>?自由链表的设计</h4> 
<p>在有了上面的基础之后，我们来设计自由链表，其实就是实现一个单链表，方便插入删除，同时标识链表长度 _size以方便后续释放流程，以及定义 _maxSize来保住thread cache一次申请对象批次的下限。</p> 
<pre><code class="prism language-c"><span class="token comment">// 返回“obj前4或8字节内存”强转得来的指针，指向的是下一个结点</span>
<span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> <span class="token function">NextObj</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
class FreeList
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 将归还的内存块对象头插进自由链表</span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		_freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>
		<span class="token operator">++</span>_size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
	<span class="token keyword">void</span> <span class="token function">PushRange</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> end<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		_freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>
		_size <span class="token operator">+=</span> size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//将自由链表中的内存块头删出去</span>
		<span class="token keyword">void</span><span class="token operator">*</span> obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		_freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">--</span>_size<span class="token punctuation">;</span>
		<span class="token keyword">return</span> obj<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">PopRange</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> end<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> _size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		start <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		end <span class="token operator">=</span> start<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			end <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		_freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_size <span class="token operator">-=</span> n<span class="token punctuation">;</span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _freeList <span class="token operator">==</span> nullptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">size_t</span><span class="token operator">&amp;</span> <span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 传引用</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _maxSize<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">size_t</span><span class="token operator">&amp;</span> <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
private<span class="token operator">:</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> _maxSize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//慢增长用于保住申请批次下限</span>
	<span class="token class-name">size_t</span> _size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//计算链表长度</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4>
<a id="thread_cache_547"></a>?thread cache框架构建</h4> 
<p>在有了上述基础后，我们来搭建thread cache的框架，其实就是一个哈希桶，每个桶中挂接着自由链表对象。</p> 
<p><code>_declspec(thread)</code>是一个Windows平台专用的关键字，用于声明线程局部存储（TLS）变量。在这里，它声明了一个指向<code>ThreadCache</code>对象的指针变量<code>pTLSThreadCache</code>，该变量的值对于每个线程来说都是独立的，可以使线程在向thread cache申请内存对象的时候实现无锁访问。</p> 
<pre><code class="prism language-c">class ThreadCache
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token comment">// 申请和释放内存对象</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Allocate</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">Deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 从中心缓存获取对象</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">FetchFromCentralCache</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> index<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 释放内存时，如果自由链表过长，回收内存到CentralCache中心缓存</span>
	<span class="token keyword">void</span> <span class="token function">ListTooLong</span><span class="token punctuation">(</span>FreeList<span class="token operator">&amp;</span> list<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
private<span class="token operator">:</span>
	<span class="token comment">// 哈希桶，每个桶中挂接着自由链表对象</span>
	FreeList _freeLists<span class="token punctuation">[</span>NFREELIST<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// pTLSThreadCache是一个指向ThreadCache对象的指针，每个线程都有一个独立的pTLSThreadCache</span>
<span class="token comment">// 可以使线程在向thread cache申请内存对象的时候实现无锁访问</span>
<span class="token keyword">static</span> <span class="token function">_declspec</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span> ThreadCache<span class="token operator">*</span> pTLSThreadCache <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
</code></pre> 
<h4>
<a id="thread_cache_576"></a>?thread cache核心实现</h4> 
<p>1.<code>FetchFromCentralCache(size_t index, size_t size)</code></p> 
<blockquote> 
 <p>从中央缓存（CentralCache）获取内存块。接受两个参数：ThreadCache自由链表对应的桶索引和想获取的内存块大小。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span><span class="token operator">*</span> ThreadCache<span class="token operator">::</span><span class="token function">FetchFromCentralCache</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> index<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 慢开始反馈调节算法</span>
	<span class="token comment">// 1、最开始不会一次向central cache一次批量要太多，因为要太多了可能用不完</span>
	<span class="token comment">// 2、如果你不要这个size大小内存需求，那么batchNum就会不断增长，直到上限</span>
	<span class="token comment">// 3、size越大，一次向central cache要的batchNum就越小</span>
	<span class="token comment">// 4、size越小，一次向central cache要的batchNum就越大</span>
	<span class="token class-name">size_t</span> batchNum <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SizeClass<span class="token operator">::</span><span class="token function">NumMoveSize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> batchNum<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span><span class="token operator">*</span> start <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> end <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> actualNum <span class="token operator">=</span> CentralCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">FetchRangeObj</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> batchNum<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 至少要获得一块</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>actualNum <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>actualNum <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// 只有一个内存块</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> start<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span><span class="token comment">// 除了起始地址外的其他内存块插入当前线程的缓存的自由链表中</span>
	<span class="token punctuation">{<!-- --></span>
		_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushRange</span><span class="token punctuation">(</span><span class="token function">NextObj</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> actualNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> start<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2.<code>Allocate(size_t size)</code></p> 
<blockquote> 
 <p>线程内分配内存</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span><span class="token operator">*</span> ThreadCache<span class="token operator">::</span><span class="token function">Allocate</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 计算出内存块的对齐大小 alignSize 和内存块所在的自由链表的下标 index</span>
	<span class="token class-name">size_t</span> alignSize <span class="token operator">=</span> SizeClass<span class="token operator">::</span><span class="token function">RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> index <span class="token operator">=</span> SizeClass<span class="token operator">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// _freeLists[index] 如果不为空，就从 _freeLists[index] 中弹出一个内存块并返回。</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 如果为空，就调用 FetchFromCentralCache 函数从中央缓存获取内存块；</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">FetchFromCentralCache</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> alignSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3.<code>Deallocate(void* ptr, size_t size)</code></p> 
<blockquote> 
 <p>线程内回收内存，传入内存块的指针: ptr 和内存块的大小: size</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> ThreadCache<span class="token operator">::</span><span class="token function">Deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 计算出映射的自由链表桶index，并将 ptr 插入到 _freeLists[index] 中</span>
	<span class="token class-name">size_t</span> index <span class="token operator">=</span> SizeClass<span class="token operator">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 当链表长度大于一次批量申请的内存时，就开始还一段list给CentralCache</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> _freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">ListTooLong</span><span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>4.<code>ListTooLong(FreeList&amp; list, size_t size)</code></p> 
<blockquote> 
 <p>处理线程内过长自由链表，还一部分给中心缓存的span</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> ThreadCache<span class="token operator">::</span><span class="token function">ListTooLong</span><span class="token punctuation">(</span>FreeList<span class="token operator">&amp;</span> list<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span><span class="token operator">*</span> start <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> end <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
	<span class="token comment">// MaxSize就是归还的list的长度，自由链表结点个数</span>
	list<span class="token punctuation">.</span><span class="token function">PopRange</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

	CentralCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseListToSpans</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="2central_cache_681"></a>2.central cache框架构建及核心实现</h3> 
<p>central cache也是一个哈希表结构，其映射关系与thread cache是一样的，不同的是central cache的哈希桶位置所挂接的是SpanList链表结构，不过每个桶下的span对象被切分成了一块块小内存挂接在span对象的自由链表freeList中。</p> 
<p><img src="https://images2.imgbox.com/52/c9/d9QRiVoe_o.png" alt="image-20221231222905082"></p> 
<blockquote> 
 <p>图稍微有点不对，sapn链是带头双向循环链表，最后不该指向NULL，应该指向头。</p> 
</blockquote> 
<h4>
<a id="_689"></a>?申请与释放内存规则</h4> 
<ul><li>申请内存<br> 1.当thread cache中没有内存后，就会向central cache中申请大块内存。这里的申请过程采用的是类似网络tcp协议拥塞控制的慢开始算法，而central cache中哈希映射的spanlist下挂着的span则向thread cache提供大块内存，而从span中取出对象给thread cache是需要加锁的，这里为了保证效率，提供的是桶锁。</li></ul> 
<h5>
<a id="_694"></a>▶慢开始算法</h5> 
<p>线程缓存从中央缓存获取内存块的数量是按照“慢开始反馈调节算法”递增的：</p> 
<blockquote> 
 <p>1、最开始不会一次向central cache一次批量要太多，因为要太多了可能用不完<br> 2、如果你不要这个size大小内存需求，那么batchNum就会不断增长，直到上限<br> 3、size越大，一次向central cache要的batchNum就越小<br> 4、size越小，一次向central cache要的batchNum就越大</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">// 预计获取的批次数量</span>
<span class="token class-name">size_t</span> batchNum <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SizeClass<span class="token operator">::</span><span class="token function">NumMoveSize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> batchNum<span class="token punctuation">)</span>
    _freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>举个例子，线程申请7块大小相同的内存，第一次申请的批次数量为1块，第二次再来申请时，此时thread cache的自由链表下已经没有空闲的内存了，则又需要继续向central cache申请内存，申请的批次数量为2块，第3次直接从thread cache的自由链表中获取内存块；第4次再申请时，则需要向central cache申请内存，此时申请的批次数量为3块，挂接在thread cache的自由链表下，直到第7次来申请内存时，向central cache申请的内存批次数量为4，这时线程取走一块内存，则挂接在thread cache的自由链表下还有3块空闲的内存。</p> 
<p>2.当central cache中映射的spanlist下所挂接的所有span对象都没有内存后，则需要向page cache申请一块新的span对象，central cache拿到这块span对象后会按照所管理内存的大小将span对象划分成多块，再挂接到central cache的审判list中；然后再从这块新申请的span对象中去内存分配给thread cache。</p> 
<p>3.在这里，为了方便后续的回收，span对象每分配出一块内存，其成员变量<code>_useCount</code>就++；相反thread cache每释放归还一块内存后，<code>_useCount</code>就–。</p> 
<p><strong>释放内存</strong><br> 当thread_cache过长或者线程销毁，则会将内存释放回central cache中的，释放回来时–<code>_useCount</code>。当<code>_useCount</code>变为0后，说明所有分配出去的内存都归还回来了，那么就将这个span对象归还给page cache，page cache会对归还回来的span进行前后页合并。</p> 
<h4>
<a id="SpanSpanList_719"></a>?管理多个大块内存的跨度结构Span及SpanList定义</h4> 
<p>在上面我们知道central cache的哈希桶下挂接着的是跨度结构Span对象，其实Span对象是管理以页为单位的大块内存的结构体。而为了方便后续回收span对象到page cache，需要将任意位置span对象从spanlist中删除，那么将spanlist定义为一个双向链表更好一些。</p> 
<p>由此，<strong>span及spanlist的定义如下</strong>：</p> 
<pre><code class="prism language-c"><span class="token comment">// 管理多个连续页大块内存跨度结构</span>
<span class="token keyword">struct</span>  <span class="token class-name">Span</span>
<span class="token punctuation">{<!-- --></span>
	PAGE_ID _pageId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 大块内存起始页的页号</span>
	<span class="token class-name">size_t</span> _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 页的数量</span>

	Span<span class="token operator">*</span> _next <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>	<span class="token comment">// 指向下一个内存块的指针</span>
	Span<span class="token operator">*</span> _prev <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>  <span class="token comment">// 指向上一个内存块的指针</span>

	<span class="token class-name">size_t</span> _objSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 切好的小对象大小</span>
	<span class="token class-name">size_t</span> _useCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已分配给ThreadCache的小块内存的数量</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>  <span class="token comment">// 已分配给ThreadCache的小块内存的自由链表</span>

	bool _isUse <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// 标记当前span内存跨度是否在被使用</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 带头双向循环链表 </span>
class SpanList
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token comment">// 构造函数，创建带头双向循环链表</span>
	<span class="token function">SpanList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_head <span class="token operator">=</span> new Span<span class="token punctuation">;</span>
		_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
		_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Span<span class="token operator">*</span> <span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Span<span class="token operator">*</span> <span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>_next <span class="token operator">==</span> _head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 头插</span>
	<span class="token keyword">void</span> <span class="token function">PushFront</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">Insert</span><span class="token punctuation">(</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 头删，并返回删除的结点指针</span>
	Span<span class="token operator">*</span> <span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Span<span class="token operator">*</span> front <span class="token operator">=</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token function">Erase</span><span class="token punctuation">(</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> front<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 在链表的指定位置插入新的内存块</span>
	<span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> pos<span class="token punctuation">,</span> Span<span class="token operator">*</span> newSpan<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>newSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

		Span<span class="token operator">*</span> prev <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newSpan<span class="token punctuation">;</span>
		newSpan<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> pos<span class="token punctuation">;</span>
		newSpan<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
		pos<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> newSpan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 从链表中删除指定的内存块</span>
	<span class="token keyword">void</span> <span class="token function">Erase</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> pos<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 不能指向链表的头，这是带头双向循环链表，头结点的意义就如同“刷题”里的哑结点，是虚拟的，只是为了操作方便。</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">!=</span> _head<span class="token punctuation">)</span><span class="token punctuation">;</span>

		Span<span class="token operator">*</span> prev <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		Span<span class="token operator">*</span> next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>

		prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> next<span class="token punctuation">;</span>
		next<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
private<span class="token operator">:</span>
	Span<span class="token operator">*</span> _head<span class="token punctuation">;</span><span class="token comment">// 链表的头指针</span>
public<span class="token operator">:</span>
	std<span class="token operator">::</span>mutex _mtx<span class="token punctuation">;</span><span class="token comment">// 桶锁</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4>
<a id="central_cache_816"></a>?central cache框架构建</h4> 
<p>在明确了span与spanlist的定义描述后，也不能设计出central cache的框架结构，central cache是一个哈希表结构，其映射的是spanlist与哈希桶位置（内存大小）的关系。</p> 
<p>其次，在这里我们将central cache设计为饿汉式单例模式，类的唯一实例在程序启动时就已经被创建出来，并且在整个程序的生命周期内都只有这一个实例。<strong>饿汉式优点是线程安全，因为实例在程序启动时就已经被创建，在整个程序的生命周期内都只有这一个实例，不会存在多线程竞争的情况</strong>。</p> 
<pre><code class="prism language-c">class CentralCache
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token comment">// 单例模式的定义，作用：获取唯一实例的静态方法</span>
	<span class="token keyword">static</span> CentralCache<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// &amp;_sInst 返回 _sInst 对象的地址，因为 _sInst 是一个静态变量</span>
		<span class="token comment">// 所以它的地址是固定的，其他代码也可以通过该地址访问 _sInst 对象</span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_sInst<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 获取一个非空的span</span>
	Span<span class="token operator">*</span> <span class="token function">GetOneSpan</span><span class="token punctuation">(</span>SpanList<span class="token operator">&amp;</span> list<span class="token punctuation">,</span> <span class="token class-name">size_t</span> byte_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 从中心缓存获取一定数量的对象给ThreadCache线程缓存</span>
	<span class="token class-name">size_t</span> <span class="token function">FetchRangeObj</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> end<span class="token punctuation">,</span> <span class="token class-name">size_t</span> batchNum<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 将一定数量的对象释放到中心缓存的span跨度</span>
	<span class="token keyword">void</span> <span class="token function">ReleaseListToSpans</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> <span class="token class-name">size_t</span> byte_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
private<span class="token operator">:</span>
	SpanList _spanLists<span class="token punctuation">[</span>NFREELIST<span class="token punctuation">]</span><span class="token punctuation">;</span>
private<span class="token operator">:</span>
	<span class="token comment">// 构造函数和一个拷贝构造函数私有化</span>
	<span class="token function">CentralCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">CentralCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> CentralCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>

	<span class="token comment">// 定义一个静态的变量 _sInst，该变量保存着 CentralCache 类的唯一实例</span>
	<span class="token keyword">static</span> CentralCache _sInst<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4>
<a id="central_cache_856"></a>?central cache核心实现</h4> 
<p>1.<code>GetOneSpan(SpanList&amp; list, size_t size)</code></p> 
<blockquote> 
 <p>从中心缓存获取一个空闲的Span对象，如果当前中心缓存的对应大小类别的桶中没有空闲的Span对象，则会从页缓存中获取一个新的Span对象并将其添加到中心缓存的桶中。</p> 
</blockquote> 
<pre><code class="prism language-c">Span<span class="token operator">*</span> CentralCache<span class="token operator">::</span><span class="token function">GetOneSpan</span><span class="token punctuation">(</span>SpanList<span class="token operator">&amp;</span> list<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 查看当前的spanlist中是否有还有未分配对象的span</span>
	Span<span class="token operator">*</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token operator">-&gt;</span>_freeList <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> it<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			it <span class="token operator">=</span> it<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 先把central cache的桶锁解掉，这样如果其他线程释放内存对象回来，不会阻塞</span>
	list<span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 走到这里说没有空闲span了，只能找page cache要</span>
	PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Span<span class="token operator">*</span> span <span class="token operator">=</span> PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>SizeClass<span class="token operator">::</span><span class="token function">NumMovePage</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	span<span class="token operator">-&gt;</span>_isUse <span class="token operator">=</span> true<span class="token punctuation">;</span>
	span<span class="token operator">-&gt;</span>_objSize <span class="token operator">=</span> size<span class="token punctuation">;</span>
	PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 对获取span进行切分，不需要加锁，因为这时候这个span是当前进程单例创建的，其他线程访问不到这个span</span>
	
	<span class="token comment">// 计算span的大块内存的起始地址和大块内存的大小(字节数)</span>

	<span class="token keyword">char</span><span class="token operator">*</span> start <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> bytes <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> end <span class="token operator">=</span> start <span class="token operator">+</span> bytes<span class="token punctuation">;</span>

	<span class="token comment">// 把大块内存切成自由链表链接起来</span>
	<span class="token comment">// 先切一块下来去做头，方便尾插</span>
	span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>
	start <span class="token operator">+=</span> size<span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> tail <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">=</span> start<span class="token punctuation">;</span>
		tail <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
		start <span class="token operator">+=</span> size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">=</span> nullptr<span class="token punctuation">;</span> <span class="token comment">// 记得置空</span>

	<span class="token comment">// 切好span以后，需要把span挂到中心缓存对应的哈希桶里面去的时候，再加锁</span>
	list<span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	list<span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> span<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2.<code>FetchRangeObj(void*&amp; start, void*&amp; end, size_t batchNum, size_t size)</code></p> 
<blockquote> 
 <p>从中心缓存获取一定数量的对象给thread cache<br> 值得注意void *&amp; start 和 void *&amp; end 都是传址的形式传入的参数,也就是所谓的输入输出型参数<br> void *&amp; start：输出参数，返回获取到的内存块的起始地址。<br> void *&amp; end：输出参数，返回获取到的内存块的结束地址。<br> size_t batchNum：输入参数，指定从中心缓存获取的内存块的数量。<br> size_t size：输入参数，指定要获取的内存块的大小</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token class-name">size_t</span> CentralCache<span class="token operator">::</span><span class="token function">FetchRangeObj</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> end<span class="token punctuation">,</span> <span class="token class-name">size_t</span> batchNum<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 中央缓存CentralCache哈希桶的映射规则和线程缓存ThreadCache哈希桶映射规则一样</span>
	<span class="token class-name">size_t</span> index <span class="token operator">=</span> SizeClass<span class="token operator">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token function">GetOneSpan</span><span class="token punctuation">(</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 检查获取的span是否为空</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 检查获取的span的自由链表是否为空</span>

	<span class="token comment">// 从span中获取batchNum个对象</span>
	<span class="token comment">// 如果不够batchNum个，有多少拿多少</span>
	start <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">;</span>
	end <span class="token operator">=</span> start<span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> actualNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> batchNum <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		end <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
		actualNum<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// span的[start, end]被取走了</span>
	<span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> nullptr<span class="token punctuation">;</span><span class="token comment">// 置空</span>
	span<span class="token operator">-&gt;</span>_useCount <span class="token operator">+=</span> actualNum<span class="token punctuation">;</span>

	<span class="token comment">// 调试：条件断点</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> cur <span class="token operator">=</span> start<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cur <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>j<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> actualNum<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>


	_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> actualNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3.<code>ReleaseListToSpans(void* start, size_t size)</code></p> 
<blockquote> 
 <p>将一段线程缓存的自由链表还给中心缓存的span。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> CentralCache<span class="token operator">::</span><span class="token function">ReleaseListToSpans</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token class-name">size_t</span> index <span class="token operator">=</span> SizeClass<span class="token operator">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>start<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 把start开头的这一串自由链表内存还给他属于的span,一次循环还一个，一直还</span>
		Span<span class="token operator">*</span> span <span class="token operator">=</span> PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_useCount<span class="token operator">--</span><span class="token punctuation">;</span>

		<span class="token comment">// 说明span的切分出去的所有小块内存都回来了，那就清理一下span，然后把完整的span交给page</span>
		<span class="token comment">// 这个span就可以再回收给page cache，pagecache可以再尝试去做前后页的合并</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_useCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
			span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
			span<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
			span<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>

			<span class="token comment">// 释放span给page cache时，span已经从_spanLists[index]删除了，不需要再加桶锁了</span>
			<span class="token comment">// 这时把桶锁解掉，使用page cache的锁就可以了,方便其他线程申请/释放内存</span>
			_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
			PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		start <span class="token operator">=</span> next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="3page_cache_1030"></a>3.page cache框架构建及核心实现</h3> 
<p>page cache与前两级缓存略有不同，其映射关系不再是哈希桶位置与自由链表或spanlist的映射，而是页号与spanlist的映射，这里我们设计的是128页的page cache。<br> <img src="https://images2.imgbox.com/81/5d/ytCgrKk1_o.png" alt="image-20221231223109247"></p> 
<h4>
<a id="_1035"></a>?申请与释放内存</h4> 
<ul>
<li> <p>申请内存<br> 1.当central cache向page cache申请内存时，page cache先检查对应位置有没有span，如果没有则向更大页寻找一个span，如果找到则分裂成两个。比如：申请的是1页page，1页page后面没有挂span，则向后面寻找更大的span，假设在100页page位置找到一个span，则将100页page的span分裂为一个1页page span和一个99页page span。</p> <p>2.如果找到_spanList[128]都没有合适的span，则向系统使用mmap、brk或者是VirtualAlloc等方式申请128页page span挂在自由链表中，再重复1中的过程。</p> <p>3.需要注意的是central cache和page cache 的核心结构都是spanlist的哈希桶，但是他们是有本质区别的，<strong>central cache中哈希桶，是按跟thread cache一样的大小对齐关系映射的，他的spanlist中挂的span中的内存都被按映射关系切好链接成小块内存的自由链表。而page cache 中的spanlist则是按下标桶号映射的，也就是说第i号桶中挂的span都是i页内存</strong>。</p> </li>
<li> <p>释放内存<br> 如果central cache释放回一个span，则依次寻找span的前后page id的没有在使用的空闲span，看是否可以合并，如果合并继续向前寻找。这样就可以将切小的内存合并收缩成大的span，减少内存碎片。</p> </li>
</ul> 
<h5>
<a id="_1047"></a>▶直接向堆申请或释放以页为单位的大块内存</h5> 
<p>这里我们为了避免使用malloc及free函数接口去向堆申请和释放内存，因此使用系统调用接口直接向堆申请和释放内存。</p> 
<p>这里的系统调用接口在window下为<code>VirtualAlloc</code>与<code>VirtualFree</code>系统调用接口；在Linux系统下为<code>mmap</code>与<code>munmap</code>，<code>brk</code>与<code>sbrk</code>两对系统调用接口。</p> 
<pre><code class="prism language-c"><span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> kPage<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>
	<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">VirtualAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> kPage <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">,</span> MEM_COMMIT <span class="token operator">|</span> MEM_RESERVE<span class="token punctuation">,</span> PAGE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
	<span class="token comment">//Linux下brk mmap等</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// _WIN32</span></span>

	<span class="token comment">//抛异常</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
		throw std<span class="token operator">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="Span_1070"></a>▶Span跨度结构以页为单位管理从堆申请的内存</h5> 
<p>我们向堆申请内存后会返回这块内存的起始地址，那么我们将这个地址看作一个无符号整型，将其除以8*1024作为Span结构的_pageId，再将申请内存时用的页号赋给 _n,这里为了方便后续回收分配出去的Span跨度结构，我们使用STL的<code>unordered_map</code>来构建 _pageId与Span对象的映射关系。</p> 
<h4>
<a id="page_cache_1074"></a>?page cache框架构建</h4> 
<p>与central cache类似的是，page cache也是单例模式；不过page cache加的不是桶锁，而是整级加的一把大锁，即每次central cache向page cache申请内存时，page cache都要加锁防止出现安全问题。</p> 
<pre><code class="prism language-c">class PageCache
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">static</span> PageCache<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_sInst<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 获取从对象到span的映射</span>
	Span<span class="token operator">*</span> <span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 释放空闲span回到Pagecache，并合并相邻的span</span>
	<span class="token keyword">void</span> <span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 获取一个k页的span</span>
	Span<span class="token operator">*</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>

	std<span class="token operator">::</span>mutex _pageMtx<span class="token punctuation">;</span>
private<span class="token operator">:</span>
	SpanList _spanLists<span class="token punctuation">[</span>NPAGES<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// PageCache自己的双链表哈希桶，映射方式是按照页数直接映射</span>
	ObjectPool<span class="token operator">&lt;</span>Span<span class="token operator">&gt;</span> _spanPool<span class="token punctuation">;</span>

	<span class="token comment">// std::unordered_map&lt;PAGE_ID, Span*&gt; _idSpanMap;</span>
	TCMalloc_PageMap1<span class="token operator">&lt;</span><span class="token number">32</span> <span class="token operator">-</span> PAGE_SHIFT<span class="token operator">&gt;</span> _idSpanMap<span class="token punctuation">;</span>

	<span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> PageCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>

	<span class="token keyword">static</span> PageCache _sInst<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4>
<a id="page_cache_1112"></a>?page cache核心实现</h4> 
<p>1.<code>NewSpan(size_t k)</code></p> 
<blockquote> 
 <p>获取一个K页的span<br> 首先会检查第k个桶里面是否有span，如果有就直接返回；如果没有，则检查后面的桶里面是否有更大的span，如果有就可以将它进行切分，切出一个k页的span返回，剩下的页数的span放到对应的桶里；如果后面的桶里也没有span，就去系统堆申请一个大小为128页的span，并把它放到对应的桶里。然后再递归调用自己，直到获取到一个k页的span为止。</p> 
</blockquote> 
<pre><code class="prism language-c">Span<span class="token operator">*</span> PageCache<span class="token operator">::</span><span class="token function">NewSpan</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> k<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 大于128 page的直接向堆申请，这里的128页相当于128*8*1024 = 1M</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//Span* span = new Span;</span>
		Span<span class="token operator">*</span> span <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		span<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span><span class="token comment">// 页号：地址右移PAGE_SHIFT获得</span>
		span<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span> <span class="token comment">// 页数</span>

		<span class="token comment">// _idSpanMap[span-&gt;_pageId] = span;</span>
		_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">return</span> span<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 先检查第k个桶里面有没有span</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 建立id和span的映射，方便central cache回收小块内存时，查找对应的span</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>PAGE_ID i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> kSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// _idSpanMap[kSpan-&gt;_pageId + i] = kSpan;</span>
			_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> i<span class="token punctuation">,</span> kSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">return</span> kSpan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 检查一下后面的桶里面有没有span，如果有可以把他它进行切分</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Span<span class="token operator">*</span> nSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// Span* kSpan = new Span;</span>
			Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// 在nSpan的头部切一个k页下来</span>
			<span class="token comment">// k页span返回</span>
			<span class="token comment">// nSpan再挂到对应映射的位置</span>
			kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> nSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span><span class="token comment">// 标记起始页</span>
			kSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token comment">// 标记页数</span>

			nSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+=</span> k<span class="token punctuation">;</span>
			nSpan<span class="token operator">-&gt;</span>_n <span class="token operator">-=</span> k<span class="token punctuation">;</span>

			_spanLists<span class="token punctuation">[</span>nSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>nSpan<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 被切分掉的另一块放入对应哈希桶</span>

			<span class="token comment">// 存储nSpan的首尾页号跟nSpan映射，方便page cache回收内存时进行的合并查找</span>
			<span class="token comment">// 因为没被中心缓存拿走，所以只标记了首尾就够了</span>
			<span class="token comment">// _idSpanMap[nSpan-&gt;_pageId] = nSpan;</span>
			<span class="token comment">// _idSpanMap[nSpan-&gt;_pageId + nSpan-&gt;_n - 1] = nSpan;</span>
			_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>nSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">,</span> nSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>nSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> nSpan<span class="token operator">-&gt;</span>_n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> nSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// 建立id和span的映射，方便central cache回收小块内存时，查找对应的span</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>PAGE_ID i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> kSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// _idSpanMap[kSpan-&gt;_pageId + i] = kSpan;</span>
				_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> i<span class="token punctuation">,</span> kSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">return</span> kSpan<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 走到这个位置就说明后面没有大页的span了</span>
	<span class="token comment">// 这时就去找堆要一个128页的span</span>
	Span<span class="token operator">*</span> bigSpan <span class="token operator">=</span> new Span<span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 通过将 ptr 地址强制转换为 PAGE_ID 类型，再使用二进制位运算符 &gt;&gt; 将指针的地址右移 PAGE_SHIFT 位</span>
	<span class="token comment">// 最终得到的结果就是这个指针所在的“页的编号”</span>
	bigSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
	bigSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

	_spanLists<span class="token punctuation">[</span>bigSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>bigSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 递归调用自己，这一次一定能成功！</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2.<code>MapObjectToSpan(void* obj)</code></p> 
<blockquote> 
 <p>建立内存地址和span的映射。前期映射方式是哈希或者红黑树，后期性能优化成基数树。</p> 
</blockquote> 
<pre><code class="prism language-c">Span<span class="token operator">*</span> PageCache<span class="token operator">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>

	<span class="token comment">/* std::unique_lock&lt;std::mutex&gt; lock(_pageMtx);// 可以自动解锁
	auto ret = _idSpanMap.find(id);
	if (ret != _idSpanMap.end())
	{
		return ret-&gt;second;
	}
	else
	{
		assert(false);
		return nullptr;
	} */</span>

	<span class="token comment">// 基数树优化后不需要加锁了</span>
	<span class="token keyword">auto</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3.<code>ReleaseSpanToPageCache(Span* span)</code></p> 
<blockquote> 
 <p>缓解外碎片问题，对span前后的页，尝试进行合并，缓解内存碎片问题</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> PageCache<span class="token operator">::</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 大于128 page的直接还给堆，这里的128页相当于128*8*1024 = 1M</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//delete span;</span>
		<span class="token function">SystemFree</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// span结构释放,内存还给堆，类似free</span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 放入定长内存池的自由链表，以便下次申请</span>

		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 向前合并</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		PAGE_ID prevId <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageId <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token comment">/*auto ret = _idSpanMap.find(prevId);
		if (ret == _idSpanMap.end())
		{
			break;
		}*/</span>

		<span class="token keyword">auto</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>prevId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 前面相邻页的span在使用，不合并了</span>
		<span class="token comment">// Span* prevSpan = ret-&gt;second;</span>
		Span<span class="token operator">*</span> prevSpan <span class="token operator">=</span> ret<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_isUse <span class="token operator">==</span> true<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 合并出超过128页的span没办法管理，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		span<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> prevSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>

		_spanLists<span class="token punctuation">[</span>prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将prevSpan从页缓存对应的哈希桶的链表中删掉</span>
		<span class="token comment">// delete prevSpan;// 为什么delete？ </span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 向后合并</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		PAGE_ID nextId <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>
		<span class="token comment">/*auto ret = _idSpanMap.find(nextId);
		if (ret == _idSpanMap.end())
		{
			break;
		}*/</span>

		<span class="token keyword">auto</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nextId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Span* nextSpan = ret-&gt;second;</span>
		Span<span class="token operator">*</span> nextSpan <span class="token operator">=</span> ret<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_isUse <span class="token operator">==</span> true<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> 
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>

		_spanLists<span class="token punctuation">[</span>nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>nextSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// delete nextSpan;</span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>nextSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	_spanLists<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将合并完的span挂到页缓存的对应的哈希桶里面。</span>
	span<span class="token operator">-&gt;</span>_isUse <span class="token operator">=</span> false<span class="token punctuation">;</span>

	<span class="token comment">//_idSpanMap[span-&gt;_pageId] = span;// 首尾存起来，方便被合并</span>
	<span class="token comment">//_idSpanMap[span-&gt;_pageId + span-&gt;_n - 1] = span;</span>

	_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>上述代码delete的作用</strong>：这里的delete操作是用来释放prevSpan和nextSpan这两个Span结构体的内存的。这两个Span结构体可能是之前由PageCache单例创建的，也可能是之前从中心缓存移动过来的。无论是哪一种情况，它们都不再被使用了，因为已经被合并到了当前的span中。所以可以直接释放掉它们的内存。<br> 这里的delete操作并不会影响prevSpan和nextSpan管理的内存。这些内存依然存在，只是没有了管理它们的Span结构体。在进行合并的时候，这些内存就被合并到了当前的span中，当前的span继续管理这些内存。因此，这里的delete操作仅仅是释放了prevSpan和nextSpan这两个Span结构体的内存，这个span管理的内存并不受影响。</p> 
<blockquote> 
 <p>delete释放掉span结构体本身，不会同时释放掉它管理的内存。举个例子，假如你有一个对象A，它管理了一个数组arr，那么你调用delete A时，只会释放掉A对象本身占用的内存，而arr数组的内存依然存在。</p> 
</blockquote> 
<h1>
<a id="_1348"></a>?细节与性能优化</h1> 
<h2>
<a id="new_1350"></a>◎使用定长内存池配合脱离使用new</h2> 
<p>我们定义一个Span结构体时是new一个对象，但new的本质是malloc，而本项目是不依赖malloc的，因此我们可以运用我们自己实现的定长内存池来脱离new的使用。<br> 对于Page Cache，由于要多次定义Span结构，因此我们定义一个特化Span对象的定长内存池：</p> 
<pre><code class="prism language-c"><span class="token comment">//定义定长的span内存池以脱离使用new</span>
ObjectPool<span class="token operator">&lt;</span>Span<span class="token operator">&gt;</span> _spanPool<span class="token punctuation">;</span>
</code></pre> 
<p>而对于Thread Cache，由于要保证对于线程而言，全局只有唯一一个Thread Cache对象，故在头文件内定义为静态变量的定长内存池：</p> 
<pre><code>//静态成员，保证全局只有一个对象
static ObjectPool&lt;ThreadCache&gt; tcPool;
//pTLSThreadCache = new ThreadCache;
pTLSThreadCache = tcPool.New();
</code></pre> 
<h2>
<a id="256kb_1366"></a>◎解决内存大于256kb的申请释放问题</h2> 
<p><img src="https://images2.imgbox.com/2f/1e/xHyQBT3S_o.png" alt="image-20221222205935804"></p> 
<p>1.<code>ConcurrentAlloc() </code>时，对于线程申请大于256kb内存的情况， 直接向页缓存申请即可：</p> 
<pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span> <span class="token comment">// 大于256kb的超大内存</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">size_t</span> alignSize <span class="token operator">=</span> SizeClass<span class="token operator">::</span><span class="token function">RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// size对齐</span>
    <span class="token class-name">size_t</span> kPage <span class="token operator">=</span> alignSize <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span><span class="token comment">// 获取页数</span>

    PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Span<span class="token operator">*</span> span <span class="token operator">=</span> PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>kPage<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 找页缓存要kpage页span</span>
    span<span class="token operator">-&gt;</span>_objSize <span class="token operator">=</span> size<span class="token punctuation">;</span><span class="token comment">// 会有一点内碎片，标记成alignSize也行</span>
    PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取对应地址</span>
    <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2.当然了页缓存的<code>NewSpan()</code>正常分配内存的能力也有上限，大于128 page的选择直接向堆申请，这里的128页相当于128 * 8KB = 1M。</p> 
<pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//Span* span = new Span;</span>
    Span<span class="token operator">*</span> span <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    span<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span><span class="token comment">// 页号：地址右移PAGE_SHIFT获得</span>
    span<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span> <span class="token comment">// 页数</span>

    <span class="token comment">// _idSpanMap[span-&gt;_pageId] = span;</span>
    _idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> span<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3.同样的，<code>ConcurrentFree()</code>时，大于256kb的内存的释放就直接释放给页缓存即可：</p> 
<pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTE<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//找到ptr对应的那块span</span>
    PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">RealeaseSpanToPageCache</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
    PageCache<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>4.<code>ReleaseSpanToPageCache(Span* span)</code>合并页时，若释放的span大于128页，即span的页数大于NPAGES - 1，则直接将内存释放到堆。</p> 
<pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SystemFree</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//delete span;</span>
    _spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="_1440"></a>◎使用基数树进行性能优化</h2> 
<p>如果我们在Page Cache中使用STL的unordered_map容器来构建_pageId与span的映射关系，那么通过测试发现，当前项目的运行效率是要满于malloc的。<br> <img src="https://images2.imgbox.com/ea/77/VWj6rRqR_o.png" alt="image-20221231180451722"></p> 
<p>接下来分析下项目的性能瓶颈：</p> 
<p><img src="https://images2.imgbox.com/e2/e8/bR23ZHda_o.png" alt="image-20221231181802182"></p> 
<p><img src="https://images2.imgbox.com/6f/15/isO8uBnR_o.png" alt="image-20221231182036472"></p> 
<p><img src="https://images2.imgbox.com/27/11/zaEyG0U6_o.png" alt="image-20221231182310079"></p> 
<p><img src="https://images2.imgbox.com/8a/76/kx2Me8MB_o.png" alt="image-20221231182356934"></p> 
<p><img src="https://images2.imgbox.com/68/82/aEPuPSne_o.png" alt="image-20221231182136264"></p> 
<p>分析得到项目在<code>unordered_map&lt;PAGE_ID, Span*&gt; _idSpanMap;</code>中的锁竞争上浪费了大量性能，这主要是unordered_map是线程不安全的，因此多线程下使用时需要加锁，而大量加锁导致资源的消耗。</p> 
<p>因此，这里参考tcmalloc，使用基数树来进行性能的优化。tcmalloc设计了三种基数树，即一层、二层与三层的基数树，其中一层和二层的基数树是适配32位系统下的，而三层基数树则是适配64位系统。</p> 
<p>这里简单介绍以下一层和二层基数树，三层基数树类似于二层：</p> 
<blockquote> 
 <p>32位系统下，一个页大小2<sup>13，进程地址空间大小2</sup>32，所以一共有2<sup>19个页，所以一层基数树需要开辟2</sup>19个元素的数组，每个位置存一个指针，需要的内存是4*2^19 = 2M。</p> 
 <p><img src="https://images2.imgbox.com/b3/36/8sIvHKaz_o.png" alt="image-20221226233521271"></p> 
 <p>32位系统下，两层基数树的结构是第一层一个2<sup>5个元素，第二层每个结点又有2</sup>14个元素，这样也就构成了2^19个的数量。这样的话拿到一个页号，（这个页号二进制下有32位，忽略高13位）这个页号高13位之后的高5位决定了他在第一层的哪个位置，这个页号高13位之后的高6位~高19位决定了他在第二层的哪个位置。</p> 
 <p>多层相较于1层还有个好处，多层不需要一次性开辟所有空间，可以到具体需要时再开辟空间。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e1/19/XYCHvKZK_o.png" alt="image-20221231223239856"></p> 
<p>基数树相较于哈希桶的优势在于如果要写入_pageId和span的映射关系的话，并不会像哈希桶可能有结构上的改变（红黑树翻转、哈希桶扩容等）（一个线程在读的时候，另一个线程在写），而是<strong>一旦基数树构建好映射关系后，就不会改变其结构，之后只会有读的操作，因此多线程环境下无需加锁，从而减少了资源的消耗，优化了性能</strong>。</p> 
<p><img src="https://images2.imgbox.com/fc/f3/kxqozgCP_o.png" alt="image-20221228000530028"></p> 
<p>只有NewSpan和ReleaseSpanToPageCache的时候，会去建立id和 span的映射，进行所谓的“写”操作，但是这俩都加了锁，绝对安全。事实上，即便不加锁也没事，因为我们不可能在同一个位置进行写，不可能同时创建一个span和释放一个span。且基数树写之前已经开好空间了，“写”的过程不会改变基数树的结构。</p> 
<p><strong>采用基数树不需要加锁的原因：</strong></p> 
<ul><li>因为往基数树建立映射的时候span没有在central cache不会给外层使用，并且建立好一次映射关系，后续不需要再建立了，后续都是读了。读写分离了。</li></ul> 
<pre><code class="prism language-c"><span class="token comment">//单层基数树</span>
template <span class="token operator">&lt;</span><span class="token class-name">size_t</span> BITS<span class="token operator">&gt;</span>
class TCMalloc_PageMap1
<span class="token punctuation">{<!-- --></span>
private<span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">;</span><span class="token comment">// 32 - 13 = 19</span>
	<span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> _array<span class="token punctuation">;</span>

public<span class="token operator">:</span>
	<span class="token keyword">typedef</span> <span class="token class-name">uintptr_t</span> Number<span class="token punctuation">;</span><span class="token comment">//存储指针的一个无符号整型类型</span>
	explicit <span class="token function">TCMalloc_PageMap1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//一次将数组所需空间开好</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//计算数组开辟空间所需的大小</span>
		<span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">;</span>
		<span class="token class-name">size_t</span> alignSize <span class="token operator">=</span> SizeClass<span class="token operator">::</span><span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//由于要开辟的空间是2M，已经很大了，故直接想堆申请</span>
		_array <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">SystemAlloc</span><span class="token punctuation">(</span>alignSize <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">memset</span><span class="token punctuation">(</span>_array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Set</span><span class="token punctuation">(</span>Number key<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span><span class="token comment">//key的范围是[0, 2^BITS - 1],_pageId</span>
	<span class="token punctuation">{<!-- --></span>
		_array<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Get</span><span class="token punctuation">(</span>Number key<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//若key超出范围或还未被设置，则返回空</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> _array<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Two-level radix tree</span>
template <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span>
class TCMalloc_PageMap2 <span class="token punctuation">{<!-- --></span>
private<span class="token operator">:</span>
	<span class="token comment">// Put 32 entries in the root and (2^BITS)/32 entries in each leaf.</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ROOT_BITS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ROOT_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> ROOT_BITS<span class="token punctuation">;</span>

	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_BITS <span class="token operator">=</span> BITS <span class="token operator">-</span> ROOT_BITS<span class="token punctuation">;</span><span class="token comment">// 19 - 5 = 14</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span><span class="token comment">// 1左移14位</span>

	<span class="token comment">// Leaf node</span>
	<span class="token keyword">struct</span> <span class="token class-name">Leaf</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> values<span class="token punctuation">[</span>LEAF_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	Leaf<span class="token operator">*</span> root_<span class="token punctuation">[</span>ROOT_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">// Pointers to 32 child nodes</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>allocator_<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// Memory allocator</span>

public<span class="token operator">:</span>
	<span class="token keyword">typedef</span> <span class="token class-name">uintptr_t</span> Number<span class="token punctuation">;</span>

	<span class="token comment">//explicit TCMalloc_PageMap2(void* (*allocator)(size_t)) {<!-- --></span>
	explicit <span class="token function">TCMalloc_PageMap2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//allocator_ = allocator;</span>
		<span class="token function">memset</span><span class="token punctuation">(</span>root_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>root_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取k低14位</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">ASSERT</span><span class="token punctuation">(</span>i1 <span class="token operator">&lt;</span> ROOT_LENGTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token comment">// 确保从start页开始，往后n页的基数树位置都给你开好</span>
	bool <span class="token function">Ensure</span><span class="token punctuation">(</span>Number start<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Number key <span class="token operator">=</span> start<span class="token punctuation">;</span> key <span class="token operator">&lt;=</span> start <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>

			<span class="token comment">// Check for overflow</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&gt;=</span> ROOT_LENGTH<span class="token punctuation">)</span>
				<span class="token keyword">return</span> false<span class="token punctuation">;</span>

			<span class="token comment">// Make 2nd level node if necessary</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//Leaf* leaf = reinterpret_cast&lt;Leaf*&gt;((*allocator_)(sizeof(Leaf)));</span>
				<span class="token comment">//if (leaf == NULL) return false;</span>
				<span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Leaf<span class="token operator">&gt;</span>	leafPool<span class="token punctuation">;</span>
				Leaf<span class="token operator">*</span> leaf <span class="token operator">=</span> <span class="token punctuation">(</span>Leaf<span class="token operator">*</span><span class="token punctuation">)</span>leafPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token function">memset</span><span class="token punctuation">(</span>leaf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">=</span> leaf<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Advance key past whatever is covered by this leaf node</span>
			key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> true<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Allocate enough to keep track of all possible pages</span>
		<span class="token function">Ensure</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Three-level radix tree</span>
template <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span>
class TCMalloc_PageMap3 <span class="token punctuation">{<!-- --></span>
private<span class="token operator">:</span>
	<span class="token comment">// How many bits should we consume at each interior level</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> INTERIOR_BITS <span class="token operator">=</span> <span class="token punctuation">(</span>BITS <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// Round-up</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> INTERIOR_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> INTERIOR_BITS<span class="token punctuation">;</span>

	<span class="token comment">// How many bits should we consume at leaf level</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_BITS <span class="token operator">=</span> BITS <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> INTERIOR_BITS<span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span>

	<span class="token comment">// Interior node</span>
	<span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
		Node<span class="token operator">*</span> ptrs<span class="token punctuation">[</span>INTERIOR_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">// Leaf node</span>
	<span class="token keyword">struct</span> <span class="token class-name">Leaf</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> values<span class="token punctuation">[</span>LEAF_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	Node<span class="token operator">*</span> root_<span class="token punctuation">;</span>                          <span class="token comment">// Root of radix tree</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>allocator_<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// Memory allocator</span>

	Node<span class="token operator">*</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		Node<span class="token operator">*</span> result <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>allocator_<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">memset</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

public<span class="token operator">:</span>
	<span class="token keyword">typedef</span> <span class="token class-name">uintptr_t</span> Number<span class="token punctuation">;</span>

	explicit <span class="token function">TCMalloc_PageMap3</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>allocator<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		allocator_ <span class="token operator">=</span> allocator<span class="token punctuation">;</span>
		root_ <span class="token operator">=</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i3 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span>
			root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> reinterpret_cast<span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i3<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">ASSERT</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i3 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		reinterpret_cast<span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i3<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool <span class="token function">Ensure</span><span class="token punctuation">(</span>Number start<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Number key <span class="token operator">=</span> start<span class="token punctuation">;</span> key <span class="token operator">&lt;=</span> start <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> key <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Check for overflow</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&gt;=</span> INTERIOR_LENGTH <span class="token operator">||</span> i2 <span class="token operator">&gt;=</span> INTERIOR_LENGTH<span class="token punctuation">)</span>
				<span class="token keyword">return</span> false<span class="token punctuation">;</span>

			<span class="token comment">// Make 2nd level node if necessary</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				Node<span class="token operator">*</span> n <span class="token operator">=</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>
				root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Make leaf node if necessary</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				Leaf<span class="token operator">*</span> leaf <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>allocator_<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>leaf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>
				<span class="token function">memset</span><span class="token punctuation">(</span>leaf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>leaf<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Advance key past whatever is covered by this leaf node</span>
			key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> true<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h1>
<a id="_1690"></a>?项目总结</h1> 
<h2>
<a id="_1692"></a>◎结果演示</h2> 
<p>可以看到通过基数树优化后的高并发内存池在性能上是要优于malloc函数的。</p> 
<p><img src="https://images2.imgbox.com/a7/02/mofO6cIQ_o.png" alt="image-20221231210331578"></p> 
<h2>
<a id="malloc_1698"></a>◎项目对比malloc性能高的原因</h2> 
<p><strong>malloc底层是采用边界标记法将内存划分成很多块，从而对内存的分配与回收进行管理</strong>。简单来说，<strong>malloc分配内存时会先获取分配区的锁</strong>，然后根据申请内存的大小一级一级的去获取内存空间，最后返回。</p> 
<p>所以在高并发的场景下，malloc在申请内存时需要加锁，以避免多个线程同时修改内存分配信息，这会导致性能下降。而内存池可以通过维护自由链表来分配内存，避免了加锁的开销。</p> 
<p>总结出本项目效率相对较高的3点原因：</p> 
<ul>
<li>1.第一级thread cache通过tls技术实现了无锁访问。</li>
<li>2.第二级central cache加的是桶锁，可以更好的实现多线程的并行。</li>
<li>3.第三级page cache通过基数树优化，有效减少了锁的竞争。</li>
</ul> 
<h2>
<a id="_1710"></a>◎项目扩展及缺陷</h2> 
<p>1.实际上在释放内存时由thread cache将自由链表对象归还给central cache只使用了链表过长这一个条件，但是实际中这个条件大概率不能恰好达成，那么就会出现thread cache中自由链表挂着许多未被使用的内存块，从而出现了线程结束时可能导致内存泄露的问题。</p> 
<blockquote> 
 <p>解决方法就是使用动态tls或者通过回调函数来回收这部分的内存，并且通过申请批次统计内存占有量，保证线程不会过多占有资源。</p> 
</blockquote> 
<p>2.可以将这个项目打成静态库或动态库替换调用系统调用malloc，不同平台替换方式不同。 基于unix的系统上的glibc，使用了weak alias的方式替换。具体来说是因为这些入口函数都被定义成了weak symbols，再加上gcc支持 alias attribute，所以替换就变成了这种通用形式：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> THROW <span class="token function">attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span> <span class="token punctuation">(</span>tc_malloc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>因此所有malloc的调用都跳转到了tc_malloc的实现。有些平台不支持这样的东西，需要使用hook的钩子技术来做。参考：<a href="https://www.cnblogs.com/feng9exe/p/6015910.html">hook</a></p> 
<h2>
<a id="_1724"></a>◎收获与总结</h2> 
<p>1.锻炼debug能力；</p> 
<p>2.了解了池化技术；</p> 
<p>3.学习了三级缓存自顶向下的设计方案；</p> 
<p>4.单例设计模式在具体项目的应用、慢增长算法以及基数树等。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>