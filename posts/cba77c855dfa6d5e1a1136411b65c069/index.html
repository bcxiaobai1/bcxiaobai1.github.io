<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>对类和对象的详细解析 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">对类和对象的详细解析</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px"></p> 
<p id="1.%E7%B1%BB%E7%9A%84%E6%9E%84%E6%88%90-toc" style="margin-left:0px"><a href="#1.%E7%B1%BB%E7%9A%84%E6%9E%84%E6%88%90">1.类的构成</a></p> 
<p id="2.this%E6%8C%87%E9%92%88-toc" style="margin-left:0px"><a href="#2.this%E6%8C%87%E9%92%88">2.this指针</a></p> 
<p id="%C2%A03.C%2B%2B%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-toc" style="margin-left:0px"><a href="#%C2%A03.C%2B%2B%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"> 3.C++类里面的静态成员</a></p> 
<p id="%C2%A03.1%20%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%C2%A03.1%20%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"> 3.1 类里面的静态成员函数</a></p> 
<p id="3.2%20%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:40px"><a href="#3.2%20%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">3.2 类里面的静态成员变量</a></p> 
<p id="%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:40px"><a href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9">静态成员变量的特点</a></p> 
<p id="%E5%85%B1%E4%BA%AB%E6%80%A7-toc" style="margin-left:80px"><a href="#%E5%85%B1%E4%BA%AB%E6%80%A7">共享性</a></p> 
<p id="%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE-toc" style="margin-left:80px"><a href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE">存储位置</a></p> 
<p id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:80px"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a></p> 
<p id="%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90-toc" style="margin-left:80px"><a href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">访问权限</a></p> 
<p id="%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F-toc" style="margin-left:80px"><a href="#%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F">如何初始化？</a></p> 
<p id="%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"> 构造函数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E7%B1%BB%E7%9A%84%E6%9E%84%E6%88%90">1.类的构成</h2> 
<p><img alt="" height="379" src="https://images2.imgbox.com/47/11/WePS6DSU_o.png" width="544"></p> 
<p> public修饰的成员在类外可以直接被访问</p> 
<p>private和protected修饰的成员不能在类外被访问</p> 
<p>如果变量没有被这三个修饰词来修饰的话,则默认为private</p> 
<h2 id="2.this%E6%8C%87%E9%92%88">2.this指针</h2> 
<p>关于this指针的一个经典回答：</p> 
<blockquote> 
 <p>有一个房子类</p> 
 <p>当你进入这个房子的时候，你可以看见桌子、椅子等，但是房子的全貌你看不见了</p> 
 <p>对于一个类的实例来说，你可以看见他的成员函数、成员变量</p> 
 <p>但是实例本身呢？</p> 
 <p>this这个指针就时时刻刻指向这个实例本身</p> 
 <p>this指针是指向对象的指针，存放对象的首地址</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Student
{
public:
    void Setage(int age)
    {
        this-&gt;age = age;//this-&gt;age表示这个类所指向的age,单独的age是形参
    }
    void Showage()
    {
        cout &lt;&lt; age &lt;&lt; endl;
    }

private:
    int age;
};
int main()
{
    Student s;
    s.Setage(18);
    s.Showage();
    return 0;
}
//输出结果为18</code></pre> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Student
{
public:
    void Setage(int age)
    {
        age = age;//age=age,并不会改变类里面age的值
    }
    void Showage()
    {
        cout &lt;&lt; age &lt;&lt; endl;
    }

private:
    int age;
};
int main()
{
    Student s;
    s.Setage(18);
    s.Showage();
    return 0;
}
//输出结果是0</code></pre> 
 <p><strong>this指针是编译器帮我们加上的，不占用空间</strong></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Student
{
private:
    int age;
};

int main()
{
    cout &lt;&lt; sizeof(Student) &lt;&lt; endl;//结果为4
    return 0;
}</code></pre> 
 <p><strong>既然this指针指向类，那么类的地址和this的地址是一样的</strong></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Student
{
public:
    void test()
    {
        cout &lt;&lt; this &lt;&lt; endl;
    }

private:
    int age;
};

int main()
{
    Student s;
    s.test();
    cout &lt;&lt; &amp;s &lt;&lt; endl;
    return 0;
}</code></pre> 
 <p><img alt="" height="330" src="https://images2.imgbox.com/69/fc/GkGUsSWA_o.png" width="544"></p> 
 <p>输出的地址是一样的</p> 
</blockquote> 
<h2 id="%C2%A03.C%2B%2B%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"> 3.C++类里面的静态成员</h2> 
<p><strong>静态成员是属于整个类的而不是某个对象，静态成员只存储一份供所有对象使用</strong></p> 
<h3 id="%C2%A03.1%20%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"> 3.1 类里面的静态成员函数</h3> 
<p>静态成员函数没有隐藏的this指针</p> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Student
{
public:
    void Set(int age)
    {
        this-&gt;age = age;
    }
    void Showage()
    {
        cout &lt;&lt; age &lt;&lt; endl;
    }
    static void test()
    {
        cout&lt;&lt;this-&gt;age&lt;&lt;endl;//这个地方的age会报错,如果不加this也会报错
        //静态成员函数不能引用非静态成员,但是可以在类的非静态成员函数里面使用静态成员
    }
private:
    int age;
};

int main()
{
    Student s;
    return 0;
}</code></pre> 
 <p><strong>这就说明了静态函数是在这个类创建出来之前就出现了，也就是说静态函数的创建时间比这个类早，所以在这个静态函数里面使用类里面的东西会报错</strong></p> 
 <p></p> 
 <p>那么应该如何使用这个函数呢</p> 
 <p>首先要注意一点：这个静态函数不能使用类里面的东西</p> 
 <pre><code class="language-cpp">class Student
{
    static void test()
    {
        cout&lt;&lt;"i want to sleep"&lt;&lt;endl;
    }
};

int main()
{
    Student s;
    Student::test();//这里记住不能通过类名调用非静态成员函数
    s.test();
    //上面两句说明类的对象可以使用静态和非静态成员函数
    return 0;
}</code></pre> 
 <p>这两种方法都可以调用这个静态函数</p> 
</blockquote> 
<h3 id="3.2%20%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">3.2 类里面的静态成员变量</h3> 
<p>静态成员变量在类的所有实例之间共享，并且可以在不创建类的情况下访问（<strong>在类创建之前就创建好了</strong>）</p> 
<h3 id="%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9">3.3静态成员变量的特点</h3> 
<h4 id="%E5%85%B1%E4%BA%AB%E6%80%A7">共享性</h4> 
<p>静态成员变量在类所有的实例之间共享，这个类的每个对象的静态变量都是相同的</p> 
<h4 id="%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE">存储位置</h4> 
<p>静态成员变量存储在静态存储区，而不是每个对象的堆栈中。这使得他们可以在不创建类的实例的情况下访问</p> 
<h4 id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</h4> 
<p>与程序的生命周期一样。在程序启动的时候就创建了，在程序结束的时候就销毁</p> 
<h4 id="%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">访问权限</h4> 
<p>静态成员变量可以通过类名来访问，也可以通过对象来访问。但是建议前者，这样子能强调他们的共享性</p> 
<h4 id="%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F">如何初始化？</h4> 
<blockquote> 
 <pre><code class="language-cpp">class Student
{
private:
    static int a;
};

int Student::a=0;</code></pre> 
 <p></p> 
</blockquote> 
<h2 id="%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"> 4构造函数</h2> 
<p>构造函数的主要作用不是开辟空间创建对象，而是为了初始化对象</p> 
<h3>特征</h3> 
<p><strong>他不是开空间创建对象，而是初始化对象</strong></p> 
<p>1. 无返回值（也不用写void）</p> 
<p>2. 函数名与类名相同</p> 
<p>3. 构造函数可以重载</p> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Student
{
public:
    Student(int a,int b,int c)//构造函数
    {
        _a=a;
        _b=b;
        _c=c;
    }
    Student(int a,int b)
    {
        _a=a;
        _b=b;
    }
    void Show()
    {
        printf("%d %d %d",_a,_b,_c);
    }
private:
    int _a,_b,_c;
};

int main()
{
    Student s(1,2,3);//创建s对象的同时调用构造函数
    Student p(1,2);//函数重载
    s.Show();
    return 0;
}
//输出结果1 2 3</code></pre> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Student
{
public:
    void Show()
    {
        printf("%d %d %d",_a,_b,_c);
    }
private:
    int _a,_b,_c;
};

int main()
{
    Student s;
    s.Show();
    return 0;
}
/*
输出结果32767 0 0
如果类里面没有构造函数,则C++编译器会自动调用一个无参的默认构造函数
*/</code></pre> 
 <pre><code class="language-cpp">private:
    int _a=1,_b=1,_c=1;

/*
这里对_a,_b,_c不是赋值不是初始化，而是给缺省值
原因：这里的变量都是声明，还没有创建出来
*/</code></pre> 
 <p></p> 
</blockquote> 
<h2>5析构函数</h2> 
<p>作用与构造函数相反。在对象销毁时自动调用，完成对象中资源的清理工作</p> 
<h3>特征</h3> 
<p>析构函数名是在类名的签名加~</p> 
<p>无参数无返回值</p> 
<p>一个类只能有一个析构函数，如果自己没有定义，系统会调用默认的析构函数。析构函数不能重载</p> 
<p>对象生命周期结束时调用</p> 
<p>析构函数的执行在return之前</p> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class S
{
public:
    S()
    {
        cout &lt;&lt; "构造" &lt;&lt; endl;
    }
    ~S()
    {
        cout &lt;&lt; "析构" &lt;&lt; endl;
    }
};
int main()
{
    S s;
    return 0;
}</code></pre> 
 <p><img alt="" height="186" src="https://images2.imgbox.com/be/a2/nVKqu6LO_o.png" width="341"></p> 
 <p>先输出构造，然后再输出析构</p> 
</blockquote> 
<h3> 作用</h3> 
<p>当我们在类中声明了一些指针变量的时候，我们一般在析构函数里面释放这些指针变量所占有的空间，因为系统不会释放指针变量指向的空间，我们需要自己来delete</p> 
<h2>6.构造函数和析构函数的一些应用</h2> 
<h3>6.1 定义为局部变量</h3> 
<p>先补充一个知识点：局部变量存储在栈区，全局变量和静态变量存储在静态区</p> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Date
{
public:
    Date(int a)
    {
        _a = a;
        cout &lt;&lt; "Date()-&gt;" &lt;&lt; _a &lt;&lt; endl;
    }
    ~Date()
    {
        cout &lt;&lt; "~Date()-&gt;" &lt;&lt; _a &lt;&lt; endl;
    }

private:
    int _a;
};

int main()
{
    Date a(1);
    Date b(2);
    return 0;
}</code></pre> 
 <p>输出结果</p> 
 <p><img alt="" height="229" src="https://images2.imgbox.com/ec/9a/5Cqkev1G_o.png" width="311"></p> 
 <p>析构函数的时候为什么先输出~Date()-&gt;2呢？</p> 
 <p>首先我们要知道a和b变量都是局部变量，都存储在栈区，栈区遵循后进先出的原则</p> 
</blockquote> 
<h3> 6.2 局部变量和全局变量同时存在时</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Date
{
public:
    Date(int a)
    {
        _a = a;
        cout &lt;&lt; "Date()-&gt;" &lt;&lt; _a &lt;&lt; endl;
    }
    ~Date()
    {
        cout &lt;&lt; "~Date()-&gt;" &lt;&lt; _a &lt;&lt; endl;
    }

private:
    int _a;
};

Date b(2);

int main()
{
    Date a(1);
    return 0;
}</code></pre> 
 <p>输出结果</p> 
 <p><img alt="" height="136" src="https://images2.imgbox.com/f3/87/eZeqwKwy_o.png" width="286"></p> 
 <p>全局变量先定义，在程序结束之后再销毁（在局部变量销毁之后再销毁）</p> 
</blockquote> 
<h3> 6.3 静态变量、局部变量、全局变量共存</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Date
{
public:
    Date(int a)
    {
        _a = a;
        cout &lt;&lt; "Date()-&gt;" &lt;&lt; _a &lt;&lt; endl;
    }
    ~Date()
    {
        cout &lt;&lt; "~Date()-&gt;" &lt;&lt; _a &lt;&lt; endl;
    }

private:
    int _a;
};

Date b(2);

int main()
{
    Date a(1);
    static Date c(3);
    return 0;
}</code></pre> 
 <p>输出结果</p> 
 <p><img alt="" height="189" src="https://images2.imgbox.com/58/c2/ktdnM46V_o.png" width="325"></p> 
 <p>创建变量按顺序来。首先是局部变量被销毁，静态区的变量（只考虑这个区域时）在销毁时也是类似“后进先出”一样来销毁</p> 
</blockquote> 
<h3> 6.4 静态变量在循环中</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Date
{
public:
    Date(int a)
    {
        _a = a;
        cout &lt;&lt; "Date()-&gt;" &lt;&lt; _a &lt;&lt; endl;
    }
    ~Date()
    {
        cout &lt;&lt; "~Date()-&gt;" &lt;&lt; _a &lt;&lt; endl;
    }

private:
    int _a;
};

int main()
{
    for (int i = 0; i &lt;= 1; i++)
    {
        static Date a(1);
        Date b(2);
    }
    return 0;
}</code></pre> 
 <p>输出结果</p> 
 <p><img alt="" height="179" src="https://images2.imgbox.com/af/e3/mPUIEHbd_o.png" width="190"></p> 
 <p>静态变量只会被创建一次，所以只有一次构造函数和一次析构函数</p> 
</blockquote> 
<h2> 7.拷贝构造函数</h2> 
<h3>浅拷贝</h3> 
<p>拷贝成员变量的值</p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/75/66/fPH29Dgh_o.png" width="819"></p> 
<blockquote> 
 <p></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Student
{
public:
    Student(int a, int b, int c)
    {
        _a = a;
        _b = b;
        _c = c;
    }
    /*
    当有Student b(a)这行代码的时候
    问题1：为什么要写成 Student &amp;s呢？
    写成Student &amp;s表示s是a的别名,不需要调用拷贝构造函数
    如果写成Student s的话,会无限递归
    原因：在调用拷贝构造函数的时候,
Student(Student s)
    {
        this-&gt;_a = s._a;
        this-&gt;_b = s._b;
        this-&gt;_c = s._c;
    }
把a传给s也会调用拷贝够咱函数,也就是说,调用一个拷贝构造函数会使得其内部嵌套另一个拷贝构造函数
那这个嵌套的拷贝构造函数也会继续嵌套一个,依次无限嵌套下去而导致死循环;所以要加一个&amp;
    问题2：那为什么加一个const呢？
    因为我们要a的值不变,将其内部的值赋给b(s),所以我们最好加一个const来修饰来让a的值不变
只要a里面的值变,就会报错
因为有可能出现以下情况
Student(const Student &amp;s)
    {
        a._a = this-&gt;_a;
        a._b = this-&gt;_b;
        a._c = this-&gt;_c;
    }
如果没有const,出现上述情况编译器是不会报错的
    */
    Student(const Student &amp;s)
    {
        this-&gt;_a = s._a;
        this-&gt;_b = s._b;
        this-&gt;_c = s._c;
    }
    void Show()
    {
        printf("%d %d %dn", _a, _b, _c);
    }

private:
    int _a, _b, _c;
};

int main()
{
    Student a(10, 20, 30);
    Student b(a);
    b.Show();
    return 0;
}</code></pre> 
 <p><img alt="" height="426" src="https://images2.imgbox.com/6d/b6/qp5JvBMX_o.png" width="1145"></p> 
 <p>输出结果</p> 
 <p><img alt="" height="161" src="https://images2.imgbox.com/b3/b2/F0NfL3zc_o.png" width="304"></p> 
</blockquote> 
<h2> 8.重载</h2> 
<p>关键字：operator</p> 
<h3>8.1 运算符重载</h3> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Student
{
public:
    Student(int a, int b, int c)
    {
        _a = a;
        _b = b;
        _c = c;
    }
    bool operator==(const Student &amp;b)//重载==运算符
    {
        return _a == b._a &amp;&amp; _b == b._b &amp;&amp; _c == b._c;//a和b相等的条件
    }
private:
    int _a, _b, _c;
};

int main()
{
    Student a(10, 20, 30);
    Student b(10, 20, 30);
    cout &lt;&lt; (a == b) &lt;&lt; endl;//这里判断a和b是否相等只需要判断a和b里面的_a,_b,_c是否分别相等
    return 0;
}</code></pre> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Student
{
public:
    Student(int a, int b, int c)
    {
        _a = a;
        _b = b;
        _c = c;
    }
    int operator-(const Student &amp;b)
    {
        return b._c - _c;
    }

private:
    int _a, _b, _c;
};

int main()
{
    Student a(10, 20, 30);
    Student b(10, 20, 50);
    cout &lt;&lt; (b - a) &lt;&lt; endl;
    return 0;
}
//输出结果是a._c - b._c  结果为-20</code></pre> 
 <p>这里就有一个问题</p> 
 <p>void operator++是怎么区别前置++和后置++的呢？</p> 
 <pre><code class="language-cpp">int operator++();//前置++
    int operator++(int);//后置++
//规定:()里面无参数的为前置++,否则为后置++</code></pre> 
 <p>注意点</p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class A
{
public:
    A(int val){
        _val=val;
    }
    void operator+(const A&amp; d){
        _val+=d._val;
    }
    void operator=(const A&amp; d){
        _val=d._val;
    }
    void Print(){
        cout&lt;&lt;_val&lt;&lt;endl;
    }
private:
    int _val;
};
int main()
{
    A a(3),b(4),c(7);
    c=a=b;
/*
c=a=b会报错,但是a=b,不会报错
因为c=a=b这句话首先执行的是a=b,然后返回值是void
所以
void operator=(const A&amp; d){
        _val=d._val;
    }
应该改成
A operator=(const A&amp; d){
        _val=d._val;
        return *this;//这里返回值是*this的一个拷贝(拷贝的话可能调用其中的拷贝函数或者构造函数什么的)
    }
所以最好写成
A&amp; operator=(const A&amp; d){
        _val=d._val;
        return *this;//这里返回的是*this的别名,不会再去调用拷贝函数
    }
*/
    a.Print();
    return 0;
}</code></pre> 
 <h3>8.2 流重载</h3> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Date
{
public:
    Date(int year, int month, int day)
    {
        _year = year;
        _month = month;
        _day = day;
    }
    void operator&lt;&lt;(ostream &amp;out) // out是cout的别名
    {
        out &lt;&lt; _year &lt;&lt; '/' &lt;&lt; _month &lt;&lt; '/' &lt;&lt; _day &lt;&lt; endl;
    }
    void operator&gt;&gt;(istream &amp;in)
    {
        in&gt;&gt;_year&gt;&gt;_month&gt;&gt;_day;
    }

private:
    int _year, _month, _day;
};

int main()
{
    Date a(2023, 9, 16);
    a&gt;&gt;cin;//a是被操作的对象,cin传给in
    a&lt;&lt;cout;
    return 0;
}</code></pre> 
 <p>const的参与</p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Date
{
public:
    Date(int year, int month, int day)
    {
        _year = year;
        _month = month;
        _day = day;
    }
    void Print()
    {
        printf("%d %d %dn", _year, _month, _day);
    }

private:
    int _year, _month, _day;
};
int main()
{
    Date a(2023, 9, 17);
    const Date b(1,1,1);
    a.Print();
    b.Print();//这里会报错
/*
因为b是一个const Date类型的
b.Print()的原型是b.Print(&amp;b),&amp;b是一个const Date*类型的
void Print()的原型是void Print(Date* const this)
&amp;b从const Date*变成Date*权限放大了
所以我们将void Print()写成void Print() const,这样他的原型变成了:
void Print(const Date* const this)是const Date*类型,后面那个const是修饰this
让this一直指向这个类且不能变
*/
    return 0;
}</code></pre> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Date
{
public:
    Date(int year, int month, int day)
    {
        _year = year;
        _month = month;
        _day = day;
    }
    void Print()const
    {
        printf("%d %d %dn", _year, _month, _day);
    }
    bool operator&lt;(const Date&amp; d)
    {
        return _year&lt;d._year;
    }

private:
    int _year, _month, _day;
};
int main()
{
    Date a(2023, 9, 17);
    const Date b(1,1,1);
    a&lt;b;//不会报错
    b&lt;a;//这里会报错
/*
bool operator&lt;(const Date&amp; d)的原型是
bool operator&lt;Date* const this,const Date&amp; d)
所以写成b&lt;a的时候(b是const Date*类型)
b由const Date*变成Date*,权限变大
可以写成
bool operator&lt;(const Date&amp; d)const
*/
    return 0;
}</code></pre> 
</blockquote> 
<h2> 9.初始化列表</h2> 
<p>初始化列表可以认为是成员变量定义的地方</p> 
<p>（private里面是声明）</p> 
<h3>9.1格式</h3> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Date
{
public:
//格式如下
    Date(int a)
        : _a(a),
          _b(a)
    {
    }
    void Print()
    {
        cout &lt;&lt; _a &lt;&lt; endl;
    }

private:
    int _a;
    int &amp;_b;
};
int main()
{
    Date a(6);
    a.Print();
    return 0;
}</code></pre> 
<h3>9.2例子</h3> 
<p>每个成员变量在初始化列表中只能出现一次</p> 
<p>类中包含以下成员，必须放在初始化列表位置进行初始化</p> 
<p>1.引用成员变量</p> 
<p>2.const成员变量</p> 
<p>3.自定义类型成员</p> 
<blockquote> 
 <pre><code class="language-cpp">class A
{
public:
    A(int a)
        : _a(a)
    {
    }
    void Print()
    {
        cout &lt;&lt; _a &lt;&lt; endl;
    }

private:
    int _a;
};

class B
{
public:
    B(int a, int b)
        : _b(b),
          _a(a),
          _n(10),
          _r(b)
    {
    }
    void Print()
    {
        _a.Print();
        cout &lt;&lt; _b &lt;&lt; endl;
    }

private:
    int _b;
    A _a;
    const int _n;
    int&amp; _r;
};</code></pre> 
 <p></p> 
</blockquote> 
<p> 成员变量在类中声明的次序就是其在初始化列表里面<span style="color:#0d0016">初始化的次序，与其在初始话列表里面的先后顺序无关</span></p> 
<p><span style="color:#0d0016">例子：</span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class A
{
public:
    A(int a)
    :_a(a),
    _b(_a)
    {}
    void Print()
    {
        cout&lt;&lt;_a&lt;&lt;endl;
        cout&lt;&lt;_b&lt;&lt;endl;
    }
private:
    int _b;
    int _a;
};

int main()
{
    A a(3);
    a.Print();
    return 0;
}
/*
输出结果是 3 随机值
因为先是把_a赋值给_b,再把a赋值给_a
*/</code></pre> 
<h3>9.3explicit关键字</h3> 
<p>用explicit修饰的构造函数，会禁止单参构造函数的隐式转换</p> 
<p>首先搞明白什么是隐式转换</p> 
<blockquote> 
 <pre><code class="language-cpp">class A
{
public:
    A(int a)//单参构造函数
        : _a(a)
    {
    }

private:
    int _a;
};

//定义一个类对象
A a(10);
/*
此时_a的值为10,如果进行以下操作,a=20,这样子会把_a的值变为20
编译器会用20(将20赋值给无名对象的_a)构造一个无名对象
最后用无名对象赋值给对象a,这种转换就叫隐式转换
*/</code></pre> 
 <p>隐式转换其实还有很多，比如</p> 
 <p>int a=2;</p> 
 <p>double b=a;</p> 
 <p>编译器会先引入一个中间变量，类型为double，然后再将这个值赋值给b</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class A
{
public:
    A(int a)
/*
如果这里改成explicit A(int a)的话
a=5那行代码会报错
因为explicit会禁止单参构造函数的隐式转换
*/
        : _a(a)
    {
    }
    void Print()
    {
        cout &lt;&lt; _a &lt;&lt; endl;
    }

private:
    int _a;
};

int main()
{
    A a(3);
    a = 5;
    a.Print();
    return 0;
}</code></pre> 
</blockquote> 
<h3> 9.4 匿名对象</h3> 
<p>生命周期只有它所在的那一行</p> 
<blockquote> 
 <pre><code class="language-cpp">class A
{
public:
    A(int a)
    :_a=a
    {}
private:
    int _a;
}; 

A a(10);
    a = A(20);
    a.Print();

如果不使用匿名对象，那就需要：
A a(10);
A b(20);
a=b;
这样子来操作
/*
A(20)表示创建一个匿名对象,他的_a值为20
这个匿名对象创建的时候也会调用构造函数和析构函数
*/</code></pre> 
</blockquote> 
<h2>10.友元类</h2> 
<p>如果类A是类B的友元类，那么B可以调用A里面的private成员和protected成员</p> 
<p>但是这样子做会破坏类的封装性</p> 
<h3>注意点</h3> 
<p>1. 友元关系不能被继承</p> 
<p>2. 友元关系是单向的，A是B的友元，但是B不一定是A的友元</p> 
<p>3. 友元不具有传递性，比如A是B的友元，B是C的友元，但是A不是C的友元</p> 
<blockquote> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class A
{
public:
    friend class B;//代表A是B的友元类,B可以访问A里面的所有成员
    A(int a)
    {
        _a=a;
    }
private:
    int _a;
};

class B
{
public:
    B(int b)
    {
        _b=b;
    }
    void Show_A_a(A a)
    {
        cout&lt;&lt;a._a&lt;&lt;endl;//这里就体现了可以访问A定义的对象a里面的私有成员
    }
private:
    int _b;
};

int main()
{
    A a(666);
    B b(555);
    b.Show_A_a(a);
    return 0;
}</code></pre> 
 <p></p> 
</blockquote> 
<h3 style="background-color:transparent">10. 2内部类</h3> 
<p>定义：如果一个类定义在另一个类的里面，那这个里面的类就叫做内部类</p> 
<p><strong>内部类是外部内的友元类，但是外部类不是内部类的友元类</strong></p> 
<p>比如A是外部类，B是外部类</p> 
<p>那么定义一个类的时候应该A::B b;定义一个对象b，b能调用A和B里面的成员，但是如果A a，那a不能调用B里面的成员</p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>