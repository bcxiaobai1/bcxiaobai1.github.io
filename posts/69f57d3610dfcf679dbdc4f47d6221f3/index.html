<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Java小题精炼训练营(篇三) - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java小题精炼训练营(篇三)</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p>1、关于AOP错误的是？</p> 
<pre>AOP将散落在系统中的“方面”代码集中实现</pre> 
<pre>AOP有助于提高系统可维护性</pre> 
<pre>AOP已经表现出将要替代面向对象的趋势</pre> 
<pre>AOP是一种设计模式，Spring提供了一种实现</pre> 
<blockquote> 
 <p>AOP 和 OOP的区别：</p> 
 <p>1. <strong>面向方面编程</strong> <strong>AOP</strong> 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。</p> 
 <p>2. <strong>面向对象编程</strong> <strong>(oop)</strong> 则是对业务分析中抽取的实体进行方法和属性的封装。</p> 
 <p><strong>也可以说</strong> <strong>AOP</strong> <strong>是面向业务中的动词领域，</strong> <strong>OOP</strong> <strong>面向名词领域。</strong></p> 
 <p>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p> 
 <p>AOP和OOP都是一套方法论，也可以说成设计模式、思维方式、理论规则等等。<br> AOP不能替代OOP，OOP是obejct abstraction，而AOP是concern abstraction，前者主要是对对象的抽象，诸如抽象出某类业务对象的公用接口、报表业务对象的逻辑封装，更注重于某些共同对象共有行为的抽象，如报表模块中专门需要报表业务逻辑的封装，其他模块中需要其他的逻辑抽象 ，而AOP则是对分散在各个模块中的共同行为的抽象，即关注点抽象。一些系统级的问题或者思考起来总与业务无关又多处存在的功能，可使用AOP，如异常信息处理机制统一将自定义的异常信息写入响应流进而到前台展示、行为日志记录用户操作过的方法等，这些东西用OOP来做，就是一个良好的接口、各处调用，但有时候会发现太多模块调用的逻辑大都一致、并且与核心业务无大关系，可以独立开来，让处理核心业务的人专注于核心业务的处理，关注分离了，自然代码更独立、更易调试分析、更具好维护。</p> 
 <p>核心业务还是要OOP来发挥作用，与AOP的侧重点不一样，前者有种纵向抽象的感觉，后者则是横向抽象的感觉， AOP只是OOP的补充，无替代关系。</p> 
 <p>C</p> 
</blockquote> 
<p>2、类A1和类A2在同一包中，类A2有个protected的方法testA2，类A1不是类A2的子类（或子类的子类），类A1可以访问类A2的方法testA2。（  ）</p> 
<p>正确</p> 
<p>错误</p> 
<blockquote> 
 <p></p> 
 <p style="text-align:center"><img alt="图片说明" height="256" src="https://images2.imgbox.com/3d/51/L8wG3JQz_o.png" width="453"></p> 
 <p></p> 
 <p>这个子类指的是 不同包下的子类</p> 
 <p>public：可以被所有其他类所访问</p> 
 <p>private：只能被自己访问和修改</p> 
 <p>protected：自身、子类及同一个包中类可以访问</p> 
 <p>default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。</p> 
 <p>A</p> 
</blockquote> 
<p>3、下列关于异常处理的描述中，错误的是()。</p> 
<pre>程序运行时异常由Java虚拟机自动进行处理</pre> 
<pre>使用try-catch-finally语句捕获异常</pre> 
<pre>可使用throw语句抛出异常</pre> 
<pre>捕获到的异常只能在当前方法中处理，不能在其他方法中处理</pre> 
<blockquote> 
 <p>捕获到的异常不仅可以在当前方法中处理，<strong>还可以将异常抛给调用它的上一级方法来处理。</strong></p> 
 <p><strong>编译时异常必须显示处理，运行时异常交给虚拟机。</strong></p> 
 <p>运行时异常可以不处理。当出现这样的异常时，总是由虚拟机接管。比如我们从来没有人去处理过Null Pointer Exception异常，它就是运行时异常，并且这种异常还是最常见的异常之一。出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被Catch块处理的。只不过往往不对它处理罢了。也就是说，如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。</p> 
 <p>D</p> 
</blockquote> 
<p>4、下列程序的运行结果</p> 
<pre><code class="language-java">public static void main(String args[]) {
    Thread t = new Thread() {
        public void run() {
            pong();
        }
    };
    t.run();
    System.out.print("ping");
}
static void pong() {
    System.out.print("pong");
}
</code></pre> 
<pre>pingpong</pre> 
<pre>pongping</pre> 
<pre>pingpong和pongping都有可能</pre> 
<pre>都不输出</pre> 
<blockquote> 
 <p>这里需要注意Thread的start和run方法</p> 
 <p>用start方法才能真正启动线程，此时线程会处于就绪状态，一旦得到时间片，则会调用线程的run方法进入运行状态。</p> 
 <p>而run方法只是普通方法，如果直接调用run方法，程序只会按照顺序执行主线程这一个线程。</p> 
 <p>在第7行的时候，调用的是t.run();方法，之间调用run方法就是普通的方法调用而已，所以肯定是先执行pong()再执行System.out.print("ping");</p> 
 <p>如果第7行换成t.start()方法，答案就应该选择c，因为t.start()后，线程变为就绪状态，什么时候开始执行时不确定的，可能是主程序先继续执行，也可能是新线程先执行。</p> 
 <p>B</p> 
</blockquote> 
<p>5、在Java中，以下数据类型中,需要内存最多的是()</p> 
<pre>byte</pre> 
<pre>long</pre> 
<pre>Object</pre> 
<pre>int</pre> 
<blockquote> 
 <p>Object 是引用数据类型，只申明而不创建实例，只会在栈内存中开辟空间，默认为空，空占1 bit.</p> 
 <p>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。<br> short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。<br> int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。<br> long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。<br> float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。<br> double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。<br> boolean：只有true和false两个取值。<br> char：16位，存储Unicode码，用单引号赋值。</p> 
 <p>B</p> 
</blockquote> 
<p>6、以下多线程对int型变量x的操作，哪个不需要进行同步（    ）</p> 
<pre>x=y;</pre> 
<pre>x++;</pre> 
<pre>++x;</pre> 
<pre>x=1;</pre> 
<blockquote> 
 <p>A.由于y的值不确定，所以要加锁；</p> 
 <p>B,C 两个在多线程情况下是必须要加锁的，因为他们是先被读入寄存器，然后再进行+1操作，如果没有加锁，那么可能会出现数据异常；</p> 
 <p>D 原子操作，所以不需要加锁</p> 
 <p>    原子性：指该操作不能再继续划分为更小的操作。</p> 
 <p>    Java中的原子操作包括：     </p> 
 <p>        1、除long和double之外的基本类型的赋值操作</p> 
 <p>        2、所有引用reference的赋值操作</p> 
 <p>        3、java.concurrent.Atomic.* 包中所有类的一切操作</p> 
 <p>D</p> 
</blockquote> 
<p>7、如果一个接口Glass有个方法setColor()，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是？  ( )</p> 
<pre>protected void setColor() { …}</pre> 
<pre>void setColor() { …}</pre> 
<pre>public void setColor() { …}</pre> 
<pre>以上语句都可以用在类BlueGlass中</pre> 
<blockquote> 
 <p>接口中只能有常量，是public static final的，方法不写默认是 public abstract的</p> 
 <p>这题就考了两个点：</p> 
 <p>1. 虽然JDK8接口中可以有static或者default修饰的方法，但是这两种方法必须有方法体。同时接口中的方法默认还是public abstract的<br> 2. 类对接口的实现，其实体现了多态性，因为类需要重写接口中所有的抽象方法。而重写需要满足两同两小一大：<br> 1. 方法名和形参列表一致。<br> 2. 重写方法的返回值（引用类型）和抛出的异常，必须是被重写方法的子类或者和被重写方法一样。一旦返回值是基本数据类型，那么重写方法和被重写方法必须一致。<br> 3. 重写方法的访问修饰符大于等于被重写方法的访问修饰符。</p> 
 <p>C</p> 
</blockquote> 
<p>8、下面论述正确的是（）？</p> 
<pre>如果两个对象的hashcode相同，那么它们作为同一个HashMap的key时，必然返回同样的值</pre> 
<pre>如果a,b的hashcode相同，那么a.equals(b)必须返回true</pre> 
<pre>对于一个类，其所有对象的hashcode必须不同</pre> 
<pre>如果a.equals(b)返回true，那么a,b两个对象的hashcode必须相同</pre> 
<blockquote> 
 <p>hashcode和equals的约定关系如下：</p> 
 <p>1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</p> 
 <p>2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p> 
 <p>D</p> 
</blockquote> 
<p>9、protected访问权限要小于包访问权限。（  ）</p> 
<pre>正确</pre> 
<pre>错误</pre> 
<blockquote> 
 <p><strong>Java类成员的访问控制权限：</strong></p> 
 <p>public &gt; protected &gt; 同包（default） &gt; private</p> 
 <p style="text-align:center"><img alt="" height="115" src="https://images2.imgbox.com/97/77/DzgsBxD1_o.png" width="522"></p> 
 <p> B</p> 
</blockquote> 
<p>11、下列说法错误的是</p> 
<pre>虚拟机中没有泛型，只有普通类和普通方法</pre> 
<pre>所有泛型类的类型参数在编译时都会被擦除</pre> 
<pre>创建泛型对象时请指明类型，让编译器尽早的做参数检查</pre> 
<pre>泛型的类型擦除机制意味着不能在运行时动态获取List&lt;T&gt;中T的实际类型</pre> 
<blockquote> 
 <p>1、创建泛型对象的时候，一定要指出类型变量T的具体类型。争取让编译器检查出错误，而不是留给JVM运行的时候抛出类不匹配的异常。 2、JVM如何理解泛型概念 —— 类型擦除。事实上，JVM并不知道泛型，所有的泛型在编译阶段就已经被处理成了普通类和方法。 处理方法很简单，我们叫做类型变量T的擦除(erased) 。 总结：泛型代码与JVM ① 虚拟机中没有泛型，只有普通类和方法。 ② 在编译阶段，所有泛型类的类型参数都会被Object或者它们的限定边界来替换。(类型擦除) ③ 在继承泛型类型的时候，桥方法的合成是为了避免类型变量擦除所带来的多态灾难。 无论我们如何定义一个泛型类型，相应的都会有一个原始类型被自动提供。原始类型的名字就是擦除类型参数的泛型类型的名字。</p> 
 <p>D</p> 
</blockquote> 
<p>12、下面哪些情况会引发异常：</p> 
<pre>数组越界</pre> 
<pre>指定URL不存在</pre> 
<pre>使用throw语句抛出</pre> 
<pre>使用throws语句</pre> 
<blockquote> 
 <p>throws 和 throw：</p> 
 <p>throws出现在方法头，表示可能会出现异常；</p> 
 <p>throw是在方法体，抛出了异常，执行throw则一定抛出了某种异常</p> 
 <p>throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理。</p> 
 <p>ABC</p> 
</blockquote> 
<p>13、下面有关Java的说法正确的是（         ）</p> 
<pre>一个类可以实现多个接口</pre> 
<pre>抽象类必须有抽象方法</pre> 
<pre>protected成员在子类可见性可以修改</pre> 
<pre>通过super可以调用父类构造函数</pre> 
<pre>final的成员方法实现中只能读取类的成员变量</pre> 
<pre>String是不可修改的，且java运行环境中对string对象有一个常量池保存</pre> 
<blockquote> 
 <p>A对：java类单继承，多实现<br> B错：被abstract修饰的类就是抽象类，有没有抽象方法无所谓<br> C错：描述有问题。protected成员在子类的可见性，我最初理解是子类（不继承父类protected成员方法）获取父类被protected修饰的成员属性或方法，可见性是不可能变的，因为修饰符protected就是描述可见性的。<br>         这道题应该是要考察子类继承父类，并重写父类的protected成员方法，该方法的可见性可以修改，这是对的，因为子类继承父类的方法，访问权限可以相同或往大了改   <br> D对。<br> E错：final修饰的方法只是不能重写，static修饰的方法只能访问类的成员变量<br> F对。</p> 
 <p>ACDF</p> 
</blockquote> 
<p>14、有关线程的叙述正确的是()</p> 
<pre>可以获得对任何对象的互斥锁定</pre> 
<pre>通过继承Thread类或实现Runnable接口，可以获得对类中方法的互斥锁定</pre> 
<pre>线程通过使用synchronized关键字可获得对象的互斥锁定</pre> 
<pre>线程调度算法是平台独立的</pre> 
<blockquote> 
 <p>线程的互斥锁机制：synchronized，lock，condition</p> 
 <p>线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p> 
 <p>CD</p> 
</blockquote> 
<p>15、下列代码片段中，存在编译错误的语句是()</p> 
<pre><code class="language-java">byte b1=1,b2=2,b3,b6,b8;
final byte b4=4,b5=6,b7;
b3=(b1+b2);  /*语句1*/
b6=b4+b5;    /*语句2*/
b8=(b1+b4);  /*语句3*/
b7=(b2+b5);  /*语句4*/
System.out.println(b3+b6);</code></pre> 
<pre>语句2</pre> 
<pre>语句1</pre> 
<pre>语句3</pre> 
<pre>语句4</pre> 
<blockquote> 
 <p>Java表达式转型规则<strong>由低到高转换</strong>：</p> 
 <p>1、所有的byte,short,char型的值将被提升为int型；</p> 
 <p>2、如果有一个操作数是long型，计算结果是long型；</p> 
 <p>3、如果有一个操作数是float型，计算结果是float型；</p> 
 <p>4、如果有一个操作数是double型，计算结果是double型；</p> 
 <p>5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。</p> 
 <p>语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；</p> 
 <p>语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；</p> 
 <p>语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);</p> 
 <p>语句4错误：b7=(b2+b5); 同上。同时注意b7是<strong>final修饰，即只可赋值一次，便不可再改变</strong>。</p> 
 <p>BCD</p> 
</blockquote> 
<p>16、Java（）中的静态方法是什么</p> 
<p>它是属于类而不是对象（实例）的方法</p> 
<p>静态方法只能访问静态数据。它无法访问非静态数据（实例变量）</p> 
<p>静态方法只能调用其他静态方法，不能从中调用非静态方法。</p> 
<p>静态方法不能通过类名直接访问，并且不需要任何对象</p> 
<blockquote> 
 <p> 静态方法可以直接用类名访问</p> 
 <p>ABC</p> 
</blockquote> 
<p>17、下述有关c++的虚类和java接口的描述，说法错误的是？</p> 
<pre>c++虚类相当与java里面的抽象类</pre> 
<pre>c++中没有接口的概念，与之对应的是纯虚类，对应的是java的接口</pre> 
<pre>纯虚函数和虚函数的区别在于前者只包含定义，而后者还可以包含函数体。</pre> 
<pre>一个抽象类和接口中的方法必须是抽象方法</pre> 
<blockquote> 
 <pre><strong>1、一个子类只能继承一个抽象类（虚类），但能实现多个接口；
2、一个抽象类可以有构造方法，接口没有构造方法；
3、一个抽象类中的方法不一定是抽象方法，即其中的方法可以有实现（有方法体），接口中的方法都是抽象方法，不能有方法体，只有声明；
4、一个抽象类可以是public、private、protected、default,
   接口只有public;
5、一个抽象类中的方法可以是public、private、protected、default，
   接口中的方法只能是public和default</strong></pre> 
 <p>CD</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>