<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C语言】高效处理文件内容：C语言的文件操作技巧与窍门 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】高效处理文件内容：C语言的文件操作技巧与窍门</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB">一、文件分类</a></p> 
<p id="1%E3%80%81%E6%8C%89%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#1%E3%80%81%E6%8C%89%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB">1、按存储介质分类</a></p> 
<p id="2%E3%80%81%E6%8C%89%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#2%E3%80%81%E6%8C%89%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB">2、按存储方式分类</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6">二、文本文件</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A0%81%E6%96%87%E4%BB%B6%C2%A0-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A0%81%E6%96%87%E4%BB%B6%C2%A0">三、二进制码文件 </a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0">四、二进制和文件文件的区别 </a></p> 
<p id="%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA%C2%A0-toc" style="margin-left:0px"><a href="#%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA%C2%A0">五、文件缓冲区 </a></p> 
<p id="%C2%A01%E3%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px"><a href="#%C2%A01%E3%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F"> 1、文件缓冲区的刷新方式</a></p> 
<p id="2%E3%80%81%E6%A8%A1%E6%8B%9F%E6%97%B6%E9%92%9F-toc" style="margin-left:40px"><a href="#2%E3%80%81%E6%A8%A1%E6%8B%9F%E6%97%B6%E9%92%9F">2、模拟时钟</a></p> 
<p id="3%E3%80%81%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88-toc" style="margin-left:40px"><a href="#3%E3%80%81%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88">3、文件指针</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84API-toc" style="margin-left:0px"><a href="#%E5%85%AD%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84API">六、文件的API</a></p> 
<p id="1%E3%80%81%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6fopen-toc" style="margin-left:40px"><a href="#1%E3%80%81%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6fopen">1、打开文件fopen</a></p> 
<p id="2%E3%80%81%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%20fclose-toc" style="margin-left:40px"><a href="#2%E3%80%81%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%20fclose">2、关闭文件 fclose</a></p> 
<p id="3%E3%80%81%E9%80%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%86%99%20fgetc%20fputc-toc" style="margin-left:40px"><a href="#3%E3%80%81%E9%80%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%86%99%20fgetc%20fputc">3、逐个字符读写 fgetc fputc</a></p> 
<p id="4%E3%80%81%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%20fgets%C2%A0fputs-toc" style="margin-left:40px"><a href="#4%E3%80%81%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%20fgets%C2%A0fputs">4、一次读写一个字符串 fgets fputs</a></p> 
<p id="5%E3%80%81%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99n%E5%9D%97%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%20fread%C2%A0fwrite-toc" style="margin-left:40px"><a href="#5%E3%80%81%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99n%E5%9D%97%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%20fread%C2%A0fwrite">5、一次读写n块文件数据 fread fwrite</a></p> 
<p id="%C2%A06%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%86%99%C2%A0fscanf%C2%A0%20fprintf%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px"><a href="#%C2%A06%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%86%99%C2%A0fscanf%C2%A0%20fprintf%E2%80%8B%E7%BC%96%E8%BE%91"> 6、格式化读写 fscanf  fprintf​编辑</a></p> 
<p id="%C2%A01%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%86%99%C2%A0%20fprintf%20(%20%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%EF%BC%8C%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BE%93%E5%87%BA%E8%A1%A8%E5%88%97%EF%BC%89-toc" style="margin-left:40px"><a href="#%C2%A01%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%86%99%C2%A0%20fprintf%20%28%20%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%EF%BC%8C%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BE%93%E5%87%BA%E8%A1%A8%E5%88%97%EF%BC%89"> 1、格式化写  fprintf ( 文件指针，格式字符串，输出表列）</a></p> 
<p id="2%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%20fscanf%20(%20%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%EF%BC%8C%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BE%93%E5%87%BA%E8%A1%A8%E5%88%97%EF%BC%89-toc" style="margin-left:40px"><a href="#2%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%20fscanf%20%28%20%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%EF%BC%8C%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BE%93%E5%87%BA%E8%A1%A8%E5%88%97%EF%BC%89">2、格式化读 fscanf ( 文件指针，格式字符串，输出表列）</a></p> 
<p id="%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99-toc" style="margin-left:0px"><a href="#%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99">七、文件的随机读写</a></p> 
<p id="1%E3%80%81%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%E5%BC%95%E5%85%A5%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px"><a href="#1%E3%80%81%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%E5%BC%95%E5%85%A5%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E6%A1%88%E4%BE%8B">1、顺序读写引入随机读写案例</a></p> 
<p id="2%E3%80%81%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E7%9A%84API-toc" style="margin-left:40px"><a href="#2%E3%80%81%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E7%9A%84API">2、随机读写的API</a></p> 
<p id="%EF%BC%881%EF%BC%89rewind%E5%A4%8D%E4%BD%8D%E6%96%87%E4%BB%B6%E6%B5%81%E6%8C%87%E9%92%88-toc" style="margin-left:80px"><a href="#%EF%BC%881%EF%BC%89rewind%E5%A4%8D%E4%BD%8D%E6%96%87%E4%BB%B6%E6%B5%81%E6%8C%87%E9%92%88">（1）rewind复位文件流指针</a></p> 
<p id="%C2%A0%EF%BC%882%EF%BC%89ftell%E8%BF%94%E5%9B%9E%E6%96%87%E4%BB%B6%E6%B5%81%E6%8C%87%E9%92%88%20%E8%B7%9D%E7%A6%BB%E6%96%87%E4%BB%B6%E9%A6%96%E9%83%A8%E7%9A%84%20%E5%AD%97%E8%8A%82%E6%95%B0-toc" style="margin-left:80px"><a href="#%C2%A0%EF%BC%882%EF%BC%89ftell%E8%BF%94%E5%9B%9E%E6%96%87%E4%BB%B6%E6%B5%81%E6%8C%87%E9%92%88%20%E8%B7%9D%E7%A6%BB%E6%96%87%E4%BB%B6%E9%A6%96%E9%83%A8%E7%9A%84%20%E5%AD%97%E8%8A%82%E6%95%B0"> （2）ftell返回文件流指针 距离文件首部的 字节数</a></p> 
<p id="%EF%BC%883%EF%BC%89fseek%E6%96%87%E4%BB%B6%E6%B5%81%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D-toc" style="margin-left:80px"><a href="#%EF%BC%883%EF%BC%89fseek%E6%96%87%E4%BB%B6%E6%B5%81%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D">（3）fseek文件流指针定位</a></p> 
<p id="%E5%85%AB%E3%80%81%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E5%99%A8-toc" style="margin-left:0px"><a href="#%E5%85%AB%E3%80%81%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E5%99%A8">八、文件加密器</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h1 id="%E4%B8%80%E3%80%81%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB">一、文件分类</h1> 
<h2 id="1%E3%80%81%E6%8C%89%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB">1、按<span style="color:#fe2c24">存储介质</span>分类</h2> 
<blockquote> 
 <p><span style="background-color:#38d8f0">磁盘</span>文件：文件的数据 存放在磁盘上（音视频、图片文件、文档文件）</p> 
 <p><span style="background-color:#38d8f0">设备</span>文件：通过系统将外部设备抽象文件</p> 
</blockquote> 
<h2 id="2%E3%80%81%E6%8C%89%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB">2、按存储方式分类</h2> 
<blockquote> 
 <p><span style="background-color:#ffd900">物理</span>上：任何磁盘文件 在物理上都是二进制存储。</p> 
 <p><span style="background-color:#ffd900">逻辑</span>上：磁盘文件分为<span style="background-color:#ff9900">二进制文件</span>、<span style="background-color:#ff9900">文本文件</span>。</p> 
</blockquote> 
<h1 id="%E4%BA%8C%E3%80%81%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6">二、<span style="color:#fe2c24"><strong>文本</strong></span>文件</h1> 
<blockquote> 
 <p>        文本文件基于<span style="background-color:#38d8f0">字符</span>编码，常见编码有 <span style="background-color:#38d8f0">ASCII</span>、UNICODE 等。 一般可以使用<span style="background-color:#38d8f0">文本编辑器</span>直接打开</p> 
 <p>        例如：</p> 
 <p>        （1）数 5678 的以 ASCII 存储形式为 ASCII 码：</p> 
 <p><span style="color:#956fe7">                 00110101(==53=='5')  </span> <span style="color:#ffd900">00110110  </span> <span style="color:#a2e043">00110111</span>   <span style="color:#fe2c24">00111000</span>         共4B</p> 
 <p>        （2）歌词文件(lrc):文本文件 </p> 
</blockquote> 
<h1 id="%E4%B8%89%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A0%81%E6%96%87%E4%BB%B6%C2%A0">三、<span style="color:#fe2c24">二进制</span>码文件 </h1> 
<blockquote> 
 <p>        基于<span style="background-color:#ffd900">值</span>编码,把内存中的数据<span style="background-color:#ffd900">原样输出</span>到磁盘上 ，一般需要自己判断或使用特定软件分析<strong>数据格式</strong>。</p> 
 <p>        例如：数 5678 的存储形式为： 二进制码：00010110 00101110</p> 
</blockquote> 
<h1 id="%E5%9B%9B%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0">四、二进制和文件文件的<span style="color:#fe2c24">区别</span> </h1> 
<p><span style="color:#fe2c24"><strong>文本</strong></span>文件：</p> 
<blockquote> 
 <p>优点：一个字节表示一个意思、便于查看</p> 
 <p>缺点：空间大、效率低</p> 
</blockquote> 
<p><span style="color:#fe2c24"><strong>二进制</strong></span>文件：</p> 
<blockquote> 
 <p>优点：效率高、空间小</p> 
 <p>缺点：不定长、不便于查看</p> 
</blockquote> 
<h1 id="%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA%C2%A0">五、文件缓冲区 </h1> 
<p></p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/ec/1f/AqDCIQrQ_o.png" width="717"></p> 
<h2 id="%C2%A01%E3%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F"> 1、文件缓冲区的<span style="color:#fe2c24">刷新方式</span>
</h2> 
<blockquote> 
 <p>1、行刷新：遇到<strong>换行符</strong>刷新。</p> 
 <p>2、满刷新：缓冲区数据<strong>放满</strong> 刷新</p> 
 <p>3、强制刷新使用<strong>fflush函数</strong> 将缓冲刷新</p> 
 <p>4、关闭耍新 ：<strong>程序运行结束</strong>的时候 将缓冲区数据 全部刷新</p> 
</blockquote> 
<h2 id="2%E3%80%81%E6%A8%A1%E6%8B%9F%E6%97%B6%E9%92%9F">2、模拟时钟</h2> 
<pre><code>#include&lt;unistd.h&gt;
void test()
{
    int i=0;
    while(1)
    {
        printf(r%02d:%02d",i/60,i%60);//r回到行首
        fflush(stdout);//强制刷新
        sleep(1);
        i++;
}</code></pre> 
<h2 id="3%E3%80%81%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88">3、文件指针</h2> 
<p>        所有操作文件的<span style="background-color:#ffd900">库函数</span> 都需要<span style="background-color:#ffd900">借助文件指针</span><span style="background-color:#ffd900">操作文件</span>。</p> 
<p>为每一个进程 默认打开的3个文件指针：</p> 
<blockquote> 
 <p>（1）<span style="background-color:#38d8f0">stdin</span>:标准<span style="background-color:#38d8f0">输入</span>默认为当前终端（键盘)<br> 我们使用的scanf、getchar 函数默认从此终端获得数据</p> 
 <p>（2）<span style="background-color:#4da8ee">stdout</span>:标准<span style="background-color:#4da8ee">输出</span>﹑默认为当前终端（屏幕)<br> 我们使用的printf、puts 函数默认输出信息到此终端<br> （3）<span style="background-color:#956fe7">stderr</span>:标准<span style="background-color:#956fe7">错误输出</span>设备文件默认为当前终端（屏幕)</p> 
 <p>当我们程序出错使用:<span style="color:#fe2c24">perror</span>函数时信息打印在此终端</p> 
</blockquote> 
<p>例：fgets(buf,sizeof(buf),stdin);</p> 
<p>        fwrite("hello world",12,1,stdout);//12块1字节输出</p> 
<h1 id="%E5%85%AD%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84API">六、文件的API</h1> 
<p>文件的操作步骤：打开 读写 关闭</p> 
<h2 id="1%E3%80%81%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6fopen">1、打开文件<span style="color:#fe2c24">fopen</span>
</h2> 
<p>        fopen中f描述其为库函数，其底层使用open函数完成系统调用。</p> 
<p>定义：FILE *fopen(const char *path, const char *mode);</p> 
<blockquote> 
 <p>path:文件的路径</p> 
 <p>mode:打开文件方式</p> 
 <p>返回值：</p> 
 <p>        成功：就是打开的文件指针</p> 
 <p>        失败：NULL</p> 
</blockquote> 
<p>文件的打开方式mode：<span style="color:#fe2c24">r、w、a、+、t、b</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24">r</span>:<strong>只读</strong>的方式打开</p> 
 <p><span style="color:#fe2c24">w</span>:<strong>只写</strong>的方式打开</p> 
 <p><span style="color:#fe2c24">a</span>:<strong>追加</strong>的方式打开(清空重写）</p> 
 <p><span style="color:#fe2c24">+</span>:<strong>可读可写</strong>方式打开</p> 
 <p><span style="color:#fe2c24">t</span>:以<strong>文本</strong>文件方式打开 （默认方式，可省略）</p> 
 <p><span style="color:#fe2c24">b</span>:以<strong>二进制</strong>方式打开（必须显示说明）</p> 
</blockquote> 
<p> <strong>组合</strong>方式：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr>
<td>模式</td>
<td>功能</td>
</tr>
<tr>
<td>
<span style="color:#fe2c24">r</span>或rb</td>
<td>以只读方式打开一个文件（不创建文件)</td>
</tr>
<tr>
<td>
<span style="color:#fe2c24">w</span>或wb</td>
<td>以写方式打开文件（使文件长度截断为0字节(<span style="background-color:#ff9900">删除</span>），创建一个文件)</td>
</tr>
<tr>
<td>
<span style="color:#fe2c24">a</span>或ab</td>
<td>以添加方式打开文件，即在末尾添加内容，当文件不存在时，创建文件用于追加<strong><span style="color:#fe2c24">写入</span></strong>
</td>
</tr>
<tr>
<td>
<span style="color:#fe2c24">r+</span>或rb+</td>
<td>以可读、可写的方式打开文件(<span style="background-color:#38d8f0">不创建</span>新文件)</td>
</tr>
<tr>
<td>
<span style="color:#fe2c24">w+</span>或wb+</td>
<td>以可读、可写的方式打开文件<br> (使文件长度为0字节(<span style="background-color:#ff9900">删除</span>)，<span style="background-color:#38d8f0">创建</span>一个文件)</td>
</tr>
<tr>
<td>
<span style="color:#fe2c24">a+</span>或ab+</td>
<td>以添加方式打开文件，打开文件并在末尾更改文件（如果文件不存在，则创建文件)</td>
</tr>
</tbody></table> 
<h2 id="2%E3%80%81%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%20fclose">2、关闭文件 fclose</h2> 
<p>定义：int fclose(FILE *fp);</p> 
<blockquote> 
 <p>返回值：</p> 
 <p>        成功返回     0</p> 
 <p>        失败返回  非0</p> 
</blockquote> 
<pre><code>void test()
{
	FILE* fp = NULL;
	fp = fopen("test.txt", "r");
	if (fp = NULL)//文件不存在
	{
		perror("fopen");
		return;
	}
	fclose(fp);
}</code></pre> 
<h2 id="3%E3%80%81%E9%80%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%86%99%20fgetc%20fputc">3、<span style="color:#fe2c24">逐个</span>字符读写 fgetc fputc</h2> 
<p><span style="color:#fe2c24">一次</span><strong>写</strong>一个字节：fputc</p> 
<blockquote> 
 <p>函数的定义：int fputc(int c, FILE *stream)</p> 
 <p>函数的说明：fputc将c的值写到stream所代表的文件中。</p> 
 <p>返回值:<br>         如果输出<strong>成功</strong>，则返回输出的<strong>字节值</strong>;</p> 
 <p>        如果输出<strong>失败</strong>，则返回一个<strong>EOF</strong>。</p> 
 <p>EOF是在stdio.h文件中定义的宏符号常量，值为-1，EOF只是在<strong><span style="color:#fe2c24"><span style="background-color:#38d8f0">文本</span></span></strong>文件中<span style="background-color:#38d8f0">有效</span>。</p> 
</blockquote> 
<p> 写入hello world字符串：</p> 
<pre><code>void test()
{
	FILE* fp = NULL;
	fp = fopen("test.txt", "w");
	if (fp = NULL)
	{
		perror("fopen");
		return;
	}
	char* file_data = "hello word";
	while (*file_data != '')
	{
		fputc(*file_data, fp);
		file_data++;
	}
	fclose(fp);
}</code></pre> 
<p>一次<strong>读</strong>一个字节：fgetc</p> 
<blockquote> 
 <p>函数定义：int fgetc(FILE *stream);</p> 
 <p>函数说明:fgetc 从stream所标示的文件中读取一个字节，将字节值返回</p> 
 <p>返回值:<br>         以<span style="color:#fe2c24">t</span>的方式:读到文件结尾返回<strong>EOF</strong><br>         以<span style="color:#fe2c24">b</span>的方式:读到文件结尾，使用<span style="color:#fe2c24">feof</span><span style="color:#0d0016">函数</span>(后面会讲)判断结尾</p> 
</blockquote> 
<p> 逐个读字符串：</p> 
<pre><code>void test()
{
	FILE* fp = NULL;
	fp = fopen("test.txt", "r");
	if (fp = NULL)
	{
		perror("fopen");
		return;
	}
	while(1)
	{
		char ch = fgetc(fp);
		if (ch != EOF)
			break;
		printf("%c", ch);
	}
	fclose(fp);
}</code></pre> 
<h2 id="4%E3%80%81%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%20fgets%C2%A0fputs">4、一次读写一个字符串 fgets fputs</h2> 
<p>写一个字符串：int fputs(const char *s, FILE *stream)</p> 
<p>读一个字符串：char *fgets(char *s, int size, FILE *stream)</p> 
<blockquote> 
 <p>读取一个字符串(遇到换行符 结束) ，读取一行文件数据</p> 
 <p><span style="background-color:#38d8f0">成功</span>返回目的<span style="background-color:#38d8f0">数组的首地址</span>，即 s</p> 
 <p><span style="background-color:#4da8ee">失败</span>返回 <span style="background-color:#4da8ee">NULL</span></p> 
</blockquote> 
<p> 有test.txt文件下<strong>读</strong>test.txt<span style="color:#fe2c24">文件中数据</span>往b.txt中<strong>写</strong>的测试程序：</p> 
<pre><code>void test06()
{
    FILE *fp_r = fopen("test.txt", "r");
    if (fp_r == NULL)
    {
         perror("fopen");
         return;
    }
    FILE *fp_w = fopen("b.txt", "w");
    if (fp_w == NULL)
    {
        perror("fopen");
        return;
    }

    while (1)
    {
        char buf[128] = "";//存放读到的数据并写到b.txt中
        //读一行
        char *ret = fgets(buf, sizeof(buf), fp_r);
        if (ret == NULL)
        break;

        //写一行
        fputs(buf, fp_w);
    }

 fclose(fp_r);
 fclose(fp_w);
}</code></pre> 
<h2 id="5%E3%80%81%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99n%E5%9D%97%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%20fread%C2%A0fwrite">5、一次读写n块文件数据 fread fwrite</h2> 
<p>块写：size_t fwrite(void *ptr, size_t size, size_t n, FILE *stream);</p> 
<blockquote> 
 <p>函数说明：fwrite 函数将ptr 指向的内存里的数据，向stream 所标示的文件中写入数据，一块是size个字节，共n块。</p> 
 <p>块<span style="background-color:#38d8f0">写</span>：将<span style="background-color:#38d8f0">内存的数据</span> <strong>原样</strong>的<span style="background-color:#38d8f0">写入</span>到 <span style="background-color:#38d8f0">磁盘文件</span>中</p> 
 <p><strong>返回值</strong>： 实际写入的<strong>块数</strong></p> 
</blockquote> 
<p>快写实例： </p> 
<pre><code>#include &lt;string.h&gt;
typedef struct
{
    int num；
    char name[30];
}STU;
void test()
{
    STU A[3]={<!-- -->{1,"lucy"},{2,"bob"},{3,"张三",{4,"李四"}};
    int n = sizeof(hero) / sizeof(hero[0]);
    FILE *fp = fopen("S.txt", "w");
    if (fp == NULL)
    {
         perror("fopen");
        return;
     }
    fwrite(A, sizeof(A), n, fp);
    fclose(fp);
}</code></pre> 
<p>快读：size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</p> 
<blockquote> 
 <p>快<span style="background-color:#38d8f0">读</span>： <span style="background-color:#38d8f0">磁盘数据</span> <strong>原样</strong><span style="background-color:#38d8f0"> 输入</span>到 <span style="background-color:#38d8f0">内存</span></p> 
 <p>返回值： 实际读到的<strong>整块数</strong>：不足一块 不计数 但数据是读到的。</p> 
</blockquote> 
<p>块读实例 </p> 
<pre><code>#include &lt;string.h&gt;
void test02()
{
    STU A[3];
    memset(A, 0, sizeof(A));
    FILE *fp = fopen("S.txt", "r");
    if (fp == NULL)
    {
        perror("fopen");
        return;
    }
    fread(A, sizeof(STU), 3, fp);
    int i = 0;
    for (i = 0; i &lt; 3; i++)
    {
        printf("%d %sn", A[i].num, A[i].name);
    }
    fclose(fp);
}</code></pre> 
<h2 id="%C2%A06%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%86%99%C2%A0fscanf%C2%A0%20fprintf%E2%80%8B%E7%BC%96%E8%BE%91"> 6、格式化读写 fscanf  fprintf<img alt="" height="201" src="https://images2.imgbox.com/4d/38/KeNHtUNX_o.png" width="938">
</h2> 
<h2 id="%C2%A01%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%86%99%C2%A0%20fprintf%20(%20%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%EF%BC%8C%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BE%93%E5%87%BA%E8%A1%A8%E5%88%97%EF%BC%89"> 1、格式化写  fprintf ( 文件指针，格式字符串，输出表列）</h2> 
<pre><code>#include &lt;string.h&gt;
typedef struct
{
    int num；
    char name[30];
}STU;
void test()
{
    STU A[3]={<!-- -->{1,"lucy"},{2,"bob"},{3,"张三",{4,"李四"}};
    int n = sizeof(hero) / sizeof(hero[0]);
    FILE *fp = fopen("S.txt", "w");
    if (fp == NULL)
    {
         perror("fopen");
        return;
     }
    //格式化写
   int i = 0;
    for (i = 0; i &lt; n; i++)
    {
        fprintf(fp, "%s %d n", A[i].num, A[i].name);
    }

    fclose(fp);
}</code></pre> 
<h2 id="2%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%20fscanf%20(%20%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%EF%BC%8C%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BE%93%E5%87%BA%E8%A1%A8%E5%88%97%EF%BC%89">2、格式化读 fscanf ( 文件指针，格式字符串，输出表列）</h2> 
<pre><code>#include &lt;string.h&gt;
void test02()
{
    STU A[3];
    memset(A, 0, sizeof(A));
    FILE *fp = fopen("S.txt", "r");
    if (fp == NULL)
    {
        perror("fopen");
        return;
    }
    int i = 0;
    for (i = 0; i &lt; 3; i++)
    {
        fscanf(fp, "%d %s",&amp;A[i].num, A[i].name);
    }
    int i = 0;
    for (i = 0; i &lt; 3; i++）
    {
        printf("%d %sn", A[i].num, A[i].name);
    }
    fclose(fp);
}</code></pre> 
<h1 id="%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99">七、文件的随机读写</h1> 
<p>文件默认是流指针<strong>顺序</strong>读写，读写顺序移动流指针 用户<span style="color:#fe2c24"><strong>不能更改</strong></span>。</p> 
<p><strong>                             随机</strong>读写：用户可以<span style="color:#fe2c24"><strong>更改</strong></span>文件流指针的位置</p> 
<h2 id="1%E3%80%81%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%E5%BC%95%E5%85%A5%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E6%A1%88%E4%BE%8B">
<strong>1、顺序</strong>读写引入随机读写案例</h2> 
<pre><code>void test()
{
	FILE* fp = NULL;
	fp = fopen("test.txt", "w+");
	if (fp = NULL)
	{
		perror("fopen");
		return;
	}
	fpus("hello world", fp);//此时流指针指向该字符串末尾
	char buf[100] = "";
    //读时从流指针开始往后顺序读，会读不到字符串hello world
	fgets(buf, sizeof(buf), fp);
	printf("读到的数据：%sn", buf);//无数据显示
	fclose(fp);
}</code></pre> 
<p>顺序读写解决该问题：文件关闭重新打开后流指针会复位。但文件会打开两次关闭两次。</p> 
<pre><code>void test()
{
	FILE* fp = NULL;
	fp = fopen("test.txt", "w+");
	if (fp = NULL)
	{
		perror("fopen");
		return;
	}
	fpus("hello world", fp);//此时流指针指向该字符串末尾
    //流指针复位
    fclose(fp);
    fp=fopen("test.txt","r");
    //读取数据
	char buf[100] = "";
	fgets(buf, sizeof(buf), fp);
	printf("读到的数据：%sn", buf);
	fclose(fp);
}</code></pre> 
<h2 id="2%E3%80%81%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E7%9A%84API">2、随机读写的API</h2> 
<h3 id="%EF%BC%881%EF%BC%89rewind%E5%A4%8D%E4%BD%8D%E6%96%87%E4%BB%B6%E6%B5%81%E6%8C%87%E9%92%88">（1）rewind<span style="color:#fe2c24">复位</span>文件流指针</h3> 
<p>void rewind(FILE *stream);</p> 
<pre><code>void test()
{
	FILE* fp = NULL;
	fp = fopen("test.txt", "w+");
	if (fp = NULL)
	{
		perror("fopen");
		return;
	}
	fpus("hello world", fp);//此时流指针指向该字符串末尾
    //复位文件流指针
    rewind（fp);
    //读取数据
	char buf[100] = "";
	fgets(buf, sizeof(buf), fp);
	printf("读到的数据：%sn", buf);
	fclose(fp);
}</code></pre> 
<h3 id="%C2%A0%EF%BC%882%EF%BC%89ftell%E8%BF%94%E5%9B%9E%E6%96%87%E4%BB%B6%E6%B5%81%E6%8C%87%E9%92%88%20%E8%B7%9D%E7%A6%BB%E6%96%87%E4%BB%B6%E9%A6%96%E9%83%A8%E7%9A%84%20%E5%AD%97%E8%8A%82%E6%95%B0"> （2）ftell返回文件流指针 距离文件首部的 字节数</h3> 
<p>long ftell(FILE *stream);</p> 
<pre><code>void test()
{
	FILE* fp = NULL;
	fp = fopen("test.txt", "w+");
	if (fp = NULL)
	{
		perror("fopen");
		return;
	}
	fpus("hello world", fp);//此时流指针指向该字符串末尾
    //复位文件流指针
    long len=ftell(fp);
	printf("文件的大小：%ldn", len);
	fclose(fp);
}</code></pre> 
<h3 id="%EF%BC%883%EF%BC%89fseek%E6%96%87%E4%BB%B6%E6%B5%81%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D">（3）fseek文件流指针<span style="color:#fe2c24">定位</span>
</h3> 
<p>int fseek(FILE *stream, long offset, int whence);</p> 
<blockquote> 
 <p> whence <strong>定位</strong>流指针的<strong>起始位置</strong></p> 
 <p>                文件开头 SEEK_<span style="background-color:#38d8f0">SET</span> 0</p> 
 <p>                文件当前位置 SEEK_<span style="background-color:#38d8f0">CUR</span> 1</p> 
 <p>                文件末尾 SEEK_<span style="background-color:#38d8f0">END</span> 2</p> 
 <p>offset：流指针的<strong>偏移量</strong>，如果为正数向右偏移（单位为字节数）为负数就是向左偏移</p> 
</blockquote> 
<p>案例：一次性读取文件数据</p> 
<blockquote> 
 <p>主要步骤：</p> 
 <p>（1）将文件流指针定位到尾部</p> 
 <p>（2）ftell返回文件流指针的偏移量 （文件总大小len）</p> 
 <p>（3）根据文件总大小 从堆区申请空间 len+1</p> 
 <p>（4）使用fread一次性将文件数据读取 </p> 
</blockquote> 
<p> 实现代码：</p> 
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
void test06()
{
    FILE *fp = fopen("c.txt", "r");
    if (fp == NULL)
    {
        perror("fopen");
        return;
    }

     fseek(fp, 0, 2);
     long len = ftell(fp);
    //复位文件流指针
    rewind(fp);
    printf("文件总大小:len=%ldn", len);

     unsigned char *text = (unsigned char *)calloc(1, len + 1);
     fread(text, len, 1, fp);

     printf("%sn", text);
     fclose(fp);

     //释放堆区空间（不是必须操作）
     if (text != NULL)
     {
         free(text);
        text = NULL;
     }
 }</code></pre> 
<h1 id="%E5%85%AB%E3%80%81%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E5%99%A8">八、文件加密器</h1> 
<p><img alt="" height="405" src="https://images2.imgbox.com/f1/c7/Ut5YkqBe_o.png" width="789"></p> 
<p>main.c</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "fun.h"

int main(int argc ,char *argv[])
{
	while(1)
	{	
		


		int cmd=0;
		print_help();
		printf("请输入指令：");
		scanf("%d",&amp;cmd);



		if(cmd==1)
		{
			char dest_file[31]="";
			char src_file[31]="";
			unsigned long file_length=0;
			char  *read=NULL;
			unsigned int password=0;
			//从键盘获取源文件和目的文件名字
			get_file_name(dest_file,src_file);
			
			//从文件中读出内容

			read = read_src_file(&amp;file_length,src_file);
			//获取加密password
			printf("请输入密码：");
			scanf("%u",&amp;password);
			//字符数组加密
			read=file_text_encrypt(read,file_length,password);
			
			//保存文件
			save_file(read,file_length,dest_file);
			

		}
		else if (cmd==2)
		{
			char dest_file[31]="";
			char src_file[31]="";
			unsigned long file_length=0;
			char  *read=NULL;
			unsigned int password=0;
			//从键盘获取源文件和目的文件名字
			get_file_name(dest_file,src_file);
			
			//从文件中读出内容

			read = read_src_file(&amp;file_length,src_file);
			//获取加密password
			printf("请输入密码：");
			scanf("%u",&amp;password);
			//字符数组加密
			read=file_text_decrypt(read,file_length,password);
			
			
			//保存文件
			save_file(read,file_length,dest_file);
			
		}
		else if (cmd==3)
		{
			break;
		}
		else
		{
			printf("输入指令出错！！！n");
		}

	
	}
	
	return 0;
}
</code></pre> 
<p> fun.c</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void print_help()
{
	printf("********1:加密文件***********n");
	printf("********2:解密文件***********n");
	printf("********3:退出程序***********n");
}


void get_file_name(char * dest_file_name,char * src_file_name)
{
	printf("请输入源文件的名称：");
	scanf("%s",src_file_name);
	printf("请输入目的文件的名称：");
	scanf("%s",dest_file_name);
	return;
}


char *read_src_file(unsigned long  *file_length,char *src_file_name)
{
	char *data=NULL;
	FILE *fp;

	
	fp=fopen(src_file_name,"r");//只读的方式打开文件
	if(fp==NULL)
	{
		perror("fopen");
		return NULL;
	}
	
	//流指针go尾部
	fseek(fp,0,2);
	//流指针的偏移量
	*file_length = ftell(fp);
	//流指针复位
	rewind(fp);

	//申请空间保存文件
	data=(char *)calloc(1,*file_length);
	if(NULL==data)
	{
		perror("calloc");
		return NULL;
	}

	//一次性读
	fread(data,*file_length,1,fp);

	fclose(fp);
	return data;

}


char *file_text_encrypt(char * src_file_text,unsigned long int length,unsigned int password)
{
	char *data=NULL;
	unsigned int i=0;
	for(i=0;i&lt;length;i++)
	{
		src_file_text[i] += password;
	}
	
	return src_file_text;

	
}


void save_file(char* text,unsigned long int length,char * file_name)
{	
	char *data=NULL;
	FILE *fp;
	fp=fopen(file_name,"w");
	if(NULL==fp)
	{
		perror("fp");
		return;
	}
	
	//写
	fwrite(text,length,1,fp);

	fclose(fp);
	if(text !=NULL)
	{
		free(text);
		text =NULL;

	}
	return;
}


char *file_text_decrypt(char * src_file_text,unsigned long int length,unsigned int password)
{
	char *data=NULL;
	unsigned int i=0;
	for(i=0;i&lt;length;i++)
	{
		src_file_text[i] -= password;
	}
	
	return src_file_text;	
}
</code></pre> 
<p> fun.h</p> 
<pre><code>#ifndef __FUN_H__
#define __FUN_H__

extern void print_help();
extern void get_file_name(char * dest_file_name,char * src_file_name);
extern char *read_src_file(unsigned long  *file_length,char *src_file_name);
extern char *file_text_encrypt(char * src_file_text,unsigned long int length,unsigned int password);
extern void save_file(char* text,unsigned long int length,char * file_name);
extern char *file_text_decrypt(char * src_file_text,unsigned long int length,unsigned int password);

#endif
</code></pre> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>