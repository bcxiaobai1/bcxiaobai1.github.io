<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>c语言实现通讯录管理系统 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言实现通讯录管理系统</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">一、前言</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0">二、通讯录的实现</a></p> 
<p id="1.%E5%85%B3%E4%BA%8E%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87-toc" style="margin-left:40px"><a href="#1.%E5%85%B3%E4%BA%8E%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87">1.关于通讯录的前期准备</a></p> 
<p id="%EF%BC%881%EF%BC%89%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#%EF%BC%881%EF%BC%89%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0">（1）菜单的实现</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%85%B3%E4%BA%8E%E8%81%94%E7%B3%BB%E4%BA%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px"><a href="#%EF%BC%882%EF%BC%89%E5%85%B3%E4%BA%8E%E8%81%94%E7%B3%BB%E4%BA%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%88%9B%E5%BB%BA">（2）关于联系人结构体的创建</a></p> 
<p id="%EF%BC%883%EF%BC%89%E5%AE%9E%E7%8E%B0%E8%8F%9C%E5%8D%95%E9%80%89%E9%A1%B9%E7%9A%84%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px"><a href="#%EF%BC%883%EF%BC%89%E5%AE%9E%E7%8E%B0%E8%8F%9C%E5%8D%95%E9%80%89%E9%A1%B9%E7%9A%84%E5%8A%9F%E8%83%BD">（3）实现菜单选项的功能</a></p> 
<p id="%EF%BC%884%EF%BC%89%E5%85%B3%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px"><a href="#%EF%BC%884%EF%BC%89%E5%85%B3%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89">（4）关于全局变量的定义</a></p> 
<p id="%C2%A02%E3%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px"><a href="#%C2%A02%E3%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"> 2、通讯录的功能实现</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%9A%E8%AE%AF%E5%BD%95-toc" style="margin-left:80px"><a href="#%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%9A%E8%AE%AF%E5%BD%95">（1）初始化通讯录</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%A2%9E%E5%8A%A0%E8%81%94%E7%B3%BB%E4%BA%BA-toc" style="margin-left:80px"><a href="#%EF%BC%882%EF%BC%89%E5%A2%9E%E5%8A%A0%E8%81%94%E7%B3%BB%E4%BA%BA">（2）增加联系人</a></p> 
<p id="%C2%A0%EF%BC%883%EF%BC%89%E6%89%93%E5%8D%B0%E9%80%9A%E8%AE%AF%E5%BD%95-toc" style="margin-left:80px"><a href="#%C2%A0%EF%BC%883%EF%BC%89%E6%89%93%E5%8D%B0%E9%80%9A%E8%AE%AF%E5%BD%95"> （3）打印通讯录</a></p> 
<p id="%EF%BC%884%EF%BC%89%E6%9F%A5%E6%89%BE%E8%81%94%E7%B3%BB%E4%BA%BA-toc" style="margin-left:80px"><a href="#%EF%BC%884%EF%BC%89%E6%9F%A5%E6%89%BE%E8%81%94%E7%B3%BB%E4%BA%BA">（4）查找联系人</a></p> 
<p id="%EF%BC%885%EF%BC%89%E4%BF%AE%E6%94%B9%E8%81%94%E7%B3%BB%E4%BA%BA-toc" style="margin-left:80px"><a href="#%EF%BC%885%EF%BC%89%E4%BF%AE%E6%94%B9%E8%81%94%E7%B3%BB%E4%BA%BA">（5）修改联系人</a></p> 
<p id="%EF%BC%886%EF%BC%89%E5%88%A0%E9%99%A4%E8%81%94%E7%B3%BB%E4%BA%BA%C2%A0-toc" style="margin-left:80px"><a href="#%EF%BC%886%EF%BC%89%E5%88%A0%E9%99%A4%E8%81%94%E7%B3%BB%E4%BA%BA%C2%A0">（6）删除联系人 </a></p> 
<p id="%E4%B8%89%E3%80%81%E5%85%B3%E4%BA%8E%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E4%BC%98%E5%8C%96-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81%E5%85%B3%E4%BA%8E%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E4%BC%98%E5%8C%96">三、关于通讯录的优化</a></p> 
<p id="1%E3%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%94%B9%E8%BF%9B-toc" style="margin-left:40px"><a href="#1%E3%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%94%B9%E8%BF%9B">1、通讯录结构体的改进</a></p> 
<p id="2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:40px"><a href="#2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93">2、初始化结构体</a></p> 
<p id="3.%E5%A2%9E%E5%AE%B9-toc" style="margin-left:40px"><a href="#3.%E5%A2%9E%E5%AE%B9">3.增容</a></p> 
<p id="%C2%A04.%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98-toc" style="margin-left:40px"><a href="#%C2%A04.%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"> 4.释放内存</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93">四、总结</a></p> 
<hr id="hr-toc">
<p></p> 
<h1>一、前言</h1> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px"></p> 
<p>本文将会用c语言实现一个通讯录的系统，并且存储若干人的信息，每个人的信息包括：姓名，性别，年龄，电话号码，住址。此通讯录系统的功能包括： 1.增加联系人 2.删除对应的联系人 3.查找联系人 4.修改联系人的信息 5.排序此通讯录 6.打印出通讯录每个人的信息</p> 
<h1 id="%E4%BA%8C%E3%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0">二、通讯录的实现</h1> 
<h2 id="1.%E5%85%B3%E4%BA%8E%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87">1.关于通讯录的前期准备</h2> 
<h3 id="%EF%BC%881%EF%BC%89%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0">（1）菜单的实现</h3> 
<p>首先关于一个通讯录，建立一个菜单是很重要的，菜单能够实现和用户的交互。</p> 
<p>因此我们需要建立一个菜单，并且菜单立马应该包括通讯录立马该有的功能，以便于用户的操作</p> 
<p>代码如下：</p> 
<pre><code class="language-cs">void menu()
{
	printf("=====================================n");
	printf("============1.增加联系人=============n");
	printf("============2.删除联系人=============n");
	printf("============3.查找联系人=============n");
	printf("============4.修改联系人=============n");
	printf("============5.排序通讯录=============n");
	printf("============6.打印通讯录=============n");
	printf("============0.退出通讯录=============n");
	printf("=====================================n");
}</code></pre> 
<p><img alt="" height="215" src="https://images2.imgbox.com/a1/93/9NPHrYb5_o.png" width="421">效果差不都就是这样子</p> 
<h3 id="%EF%BC%882%EF%BC%89%E5%85%B3%E4%BA%8E%E8%81%94%E7%B3%BB%E4%BA%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%88%9B%E5%BB%BA">（2）关于联系人结构体的创建</h3> 
<p>这里我们需要利用结构体来实现实现前言中的通讯录功能以及联系人信息，我将利用两个结构体来构建我们需要的东西。</p> 
<pre><code class="language-cs">typedef struct PeoInfo
{
	char name[NAME_MAX];
	char sex[SEX_MAX];
	int age;
	char tele[TELE_MAX];
	char addr[ADDR_MAX];
}Peo;
typedef struct Contact
{
	Peo con[PON_MAX];
	int sz;//记录数量
}contact;</code></pre> 
<p>关于第一个结构体Peo是关于个人信息的存储，第二个结构体构建了 我们需要的通讯录，con来作为以第一个结构体为类型的数组，sz来记录这个结构体存储个人信息的数量。</p> 
<h3 id="%EF%BC%883%EF%BC%89%E5%AE%9E%E7%8E%B0%E8%8F%9C%E5%8D%95%E9%80%89%E9%A1%B9%E7%9A%84%E5%8A%9F%E8%83%BD">（3）实现菜单选项的功能</h3> 
<p>我们需要根据菜单里面的选项来选择进行我们需要实现的功能，比如我们想假如一个用户信息，我们就输入1就会进行用户假如的操作，我们想退出程序我们输入0就可以退出。我选择利用枚举变量的形式来实现，讲操作变成数字，利用switch选择语句来实现各自的功能。</p> 
<pre><code class="language-cs">enum Option//利用枚举变量来定义
{
	exit,//0
	add,//1
	del,//2
	search,//3
	modify,//4
	sort,//5
	print//6
};
void test()
{
	contact con;//建立结构体
	InitCon(&amp;con);
	int input = 0;
	do {
		menu();
		scanf("%d", &amp;input);
		switch (input)
		{
		case add:
			AddCon(&amp;con);
			break;
		case del:
			DelCon(&amp;con);
			break;
		case search:
		SearchCon(&amp;con);
			break;
		case modify:
			ModifyCon(&amp;con);
			break;
		case sort:
			SortCon(&amp;con);
			break;
		case print:
			PrintCon(&amp;con);
			break;
		case exit:
			printf("退出程序，欢迎使用！n");
			break;
		default:
			printf("没有找到此数字匹配的操作!!n");
		}
	} while (input);
}</code></pre> 
<h3 id="%EF%BC%884%EF%BC%89%E5%85%B3%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89">（4）关于全局变量的定义</h3> 
<p>为了实现这些变量，并且方便后期的处理数组大小，所以我们可以利用宏来实现这个功能</p> 
<pre><code class="language-cs">#define NAME_MAX 20//姓名的长度
#define SEX_MAX 5//性别的长度
#define TELE_MAX 12//电话号码的长度
#define ADDR_MAX 30//地址长度
#define PON_MAX 1000//通讯录的大小</code></pre> 
<h2 id="%C2%A02%E3%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"> 2、通讯录的功能实现</h2> 
<h3 id="%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%9A%E8%AE%AF%E5%BD%95">（1）初始化通讯录</h3> 
<p>刚刚开始我们创建了通讯录的结构体，但是我们不难发现，因为没有定义的原因，他们里面存的都是随机数，因此我们需要对他们进行初始化防止后面的失误。初始化很简单就是把我们通讯录结构体里面的用户信息的结构体类型的数组进行初始化，这里我们可以浅浅用一个memset函数来实现，当然别忘了引用string的头文件，然后sz的初始化很简单就是初始化为0。</p> 
<pre><code class="language-cs">void InitCon(contact* pc)
{
	assert(pc);
	pc-&gt;sz = 0;
	memset(pc-&gt;con, 0, sizeof(pc-&gt;con));
}//初始化结构体</code></pre> 
<h3 id="%EF%BC%882%EF%BC%89%E5%A2%9E%E5%8A%A0%E8%81%94%E7%B3%BB%E4%BA%BA">（2）增加联系人</h3> 
<p>首先第一步我们完成第一步就可以创建关于加入联系人的函数，这个很简单我们只需要访问通讯录结构体里面的数组中的每个元素然后输入对应值就可以了</p> 
<pre><code class="language-cs">void AddCon(contact* pc)
{
	assert(pc);
	if (pc-&gt;sz == PON_MAX)
	{
		printf("通讯录满了！！n");
	}
	printf("请输入姓名：&gt;n");
	scanf("%s", pc-&gt;con[pc-&gt;sz].name);
	printf("请输入性别：&gt;n");
	scanf("%s", pc-&gt;con[pc-&gt;sz].sex);
	printf("请输入年龄：&gt;n");
	scanf("%d", &amp;(pc-&gt;con[pc-&gt;sz].age));//注意年龄在这里是一个int类型
	printf("请输入电话号码：&gt;n");
	scanf("%s", pc-&gt;con[pc-&gt;sz].tele);
	printf("请输入地址：&gt;n");
	scanf("%s", pc-&gt;con[pc-&gt;sz].addr);
	pc-&gt;sz++;
	printf("此用户添加成功！n");
}</code></pre> 
<p> <img alt="" height="462" src="https://images2.imgbox.com/fb/b6/Sb3XYOpe_o.png" width="480"></p> 
<h3 id="%C2%A0%EF%BC%883%EF%BC%89%E6%89%93%E5%8D%B0%E9%80%9A%E8%AE%AF%E5%BD%95"> （3）打印通讯录</h3> 
<p>打印通讯录也很简单，利用一个for循环根据sz的大小遍历结构体中的数组每个元素并且打印即可</p> 
<pre><code class="language-cs">void PrintCon(const contact* pc)
{
	assert(pc);
	printf("%-15s %-5s %-5s %-12s %-30sn","姓名","性别","年龄","电话","地址");
	for (int i = 0; i &lt; pc-&gt;sz; i++)
	{
		printf("%-15s %-5s %-5d %-12s %-30sn", pc-&gt;con[i].name, pc-&gt;con[i].sex, pc-&gt;con[i].age, pc-&gt;con[i].tele, pc-&gt;con[i].addr);
	}
}</code></pre> 
<p><img alt="" height="246" src="https://images2.imgbox.com/7b/c5/cUMkFYGR_o.png" width="562"></p> 
<h3 id="%EF%BC%884%EF%BC%89%E6%9F%A5%E6%89%BE%E8%81%94%E7%B3%BB%E4%BA%BA">（4）查找联系人</h3> 
<p>查找联系人这边我们需要构建一个函数，这个函数需要去根据我们想要寻找的姓名去在通讯录中寻找这个人所对应的位置，加入找到了就可以返回对应位置的下标，否则返回-1。找到之后就和打印通讯录的操作差不多打印出来就好了。</p> 
<pre><code class="language-cs">int FindByName(const contact* pc, char* name)
{
	assert(pc &amp;&amp; name);
	for (int i = 0; i &lt; pc-&gt;sz; i++)
	{
		if (0 == strcmp(pc-&gt;con[i].name, name))
			return i;
    }
	return -1;
}//寻找或者删除联系人的下标
void SearchCon(const contact* pc)
{
	assert(pc);
	char name[NAME_MAX];
	printf("请输入需要寻找用户的名字:&gt;n");
	scanf("%s", name);
	int pos = FindByName(pc, name);//pos为要寻找的人的下标
	if (pos == -1)
	{
		printf("查无此人n");
	}
	else
	{
		printf("%-15s %-5s %-5s %-12s %-30sn", "姓名", "性别", "年龄", "电话", "地址");
		printf("%-15s %-5s %-5d %-12s %-30sn", pc-&gt;con[pos].name, pc-&gt;con[pos].sex, pc-&gt;con[pos].age, pc-&gt;con[pos].tele, pc-&gt;con[pos].addr);
	}
}</code></pre> 
<p> <img alt="" height="294" src="https://images2.imgbox.com/88/8e/VuehVAet_o.png" width="519"></p> 
<h3 id="%EF%BC%885%EF%BC%89%E4%BF%AE%E6%94%B9%E8%81%94%E7%B3%BB%E4%BA%BA">（5）修改联系人</h3> 
<p>关于修改联系人这个内容，大多数的代码都是直接替换所有的内容，这样也会让一些本来就不用修改的信息又被修改了一遍，很麻烦，所有我的设计是，先让用户查找到需要修改的这个人然后选择是修改什么信息，然后重新输入嘞一部分的信息，这个其实就和菜单选项实现很相似，我们需要利用枚举变量，并且利用do...while语句来让他一直循环直到输入0为止，利用switch来根据用户的选项来跳到需要的操作。 </p> 
<pre><code class="language-cs">enum Con
{
	ERRO,
    NAME,
	SEX,
	AGE,
	TELE,
	ADDR
};
void ModifyCon(contact* pc)
{
	assert(pc);
	char name[NAME_MAX];
	printf("请输入需要修改信息用户的名字:&gt;n");
	scanf("%s", name);
	int pos = FindByName(pc, name);//pos为要寻找的人的下标
	if (pos == -1)
	{
		printf("查无此人n");
	}
	else
	{
		int num = 0;
		do {
			printf("请输入你想修改此用户的信息n");
			printf(" 0.退出 1.姓名 2.性别 3.年龄 4.电话 5.地址:&gt;n");			
			scanf("%d", &amp;num);
			switch (num)
			{
			case NAME:
				printf("请输入你想修改的姓名:&gt;n");
				scanf("%s", pc-&gt;con[pos].name);
				break;
			case SEX:
				printf("请输入你想修改的性别:&gt;n");
				scanf("%s", pc-&gt;con[pos].sex);
				break;
			case AGE:
				printf("请输入你想修改的年龄:&gt;n");
				scanf("%d", &amp;(pc-&gt;con[pos].age));
				break;
			case TELE:
				printf("请输入你想修改的电话:&gt;n");
				scanf("%s", pc-&gt;con[pos].tele);
				break;
			case ADDR:
				printf("请输入你想修改的地址:&gt;n");
				scanf("%s", pc-&gt;con[pos].addr);
				break;
			case 0:
				printf("不修改退回界面n");
				break;
			default:printf("无效操作数！n");
			}
		} while (num);
	}
}</code></pre> 
<p> <img alt="" height="768" src="https://images2.imgbox.com/2d/74/1w0IPX2L_o.png" width="577"></p> 
<h3 id="%EF%BC%886%EF%BC%89%E5%88%A0%E9%99%A4%E8%81%94%E7%B3%BB%E4%BA%BA%C2%A0">（6）删除联系人 </h3> 
<p>这个操作也不算复杂，我的思路是，首先我们先利用刚刚查找的嘞个查找下标的函数，查找到我们需要寻找删除联系人的坐标，然后对他进行删除，删除之后呢我们需要把后面的元素往前移动，这就要利用for循环，但是对于for循环的次数要多加注意，因为稍不小心就会导致数组越界。</p> 
<pre><code class="language-cs">void DelCon(contact* pc)
{
	assert(pc);
	char name[NAME_MAX];
	printf("请输入需要删除用户的名字:&gt;n");
	scanf("%s", name);
	int pos = FindByName(pc, name);//pos为要寻找的人的下标
	if (pos == -1)
	{
		printf("查无此人n");
	}
	else
	{
		for (int i = pos; i &lt; pc-&gt;sz - 1; i++)
		{
			pc-&gt;con[i] = pc-&gt;con[i + 1];
		}
		pc-&gt;sz--;
		printf("删除成功！n");
	}
}</code></pre> 
<p><img alt="" height="593" src="https://images2.imgbox.com/fd/b9/zB23jY63_o.png" width="547"></p> 
<p>（7)排序通讯录</p> 
<p>这一步我们需要按照人名首字母的大小对于通讯录进行排序，就比如summer和banni，banni会在summer，这个排序其实和冒泡排序差不多，我们需要注意的是我们在交换两个数的时候我们需要定义的的嘞个中间数为联系人结构体类型，以免出错</p> 
<pre><code class="language-cs">void SortCon(contact* pc)
{
	if (pc-&gt;sz == 0)
	{
		printf("通讯录中没有联系人n");
	}
	else
	{
		for (int i = 0; i &lt; pc-&gt;sz - 1; i++)
		{
			for (int j = 0; j &lt; pc-&gt;sz - 1 - i; j++)
			{
				if ((strcmp(pc-&gt;con[j].name, pc-&gt;con[j + 1].name)) &gt; 0)
				{
					Peo temp = pc-&gt;con[j];
					pc-&gt;con[j] = pc-&gt;con[j + 1];
					pc-&gt;con[j + 1] = temp;
				}
			}
		}
		printf("排序成功！n");
	}
}</code></pre> 
<p> <img alt="" height="580" src="https://images2.imgbox.com/f6/a9/Qzyx5INS_o.png" width="621"></p> 
<p>这样我们需要的一个通讯录就这样实现了！</p> 
<h1 id="%E4%B8%89%E3%80%81%E5%85%B3%E4%BA%8E%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E4%BC%98%E5%8C%96">三、关于通讯录的优化</h1> 
<p>这个通讯录我们不难发现他有一个致命的缺点，就是我们初始化的通讯录大小为1000，但是当我们存满还想存元素的时候，编译器就会给我们报错，我们就需要继续手动增加空间，所以为了避免这样我们可以利用动态内存分配来定义我们的通讯录结构体。</p> 
<h2 id="1%E3%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%94%B9%E8%BF%9B">1、通讯录结构体的改进</h2> 
<p>这边我们可以把之前的结构体里面的数组变成一个指针数组，并且为了考虑这个通讯录来回删除增加的缘故，一个sz来记录数组元素个数是不行的，我们需要在设定一个值为数组最大的空间，当sz和他相等的时候我们就需要扩充这个数组。</p> 
<pre><code class="language-cs">typedef struct Contact
{
	Peo* con;
	int sz;//记录数量
	int max;//记录通讯录当前的最大容量
}contact;</code></pre> 
<h2 id="2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93">2、初始化结构体</h2> 
<p>这个初始化结构体，我们需要sz初始化为0，并且为con这个指针开辟一块空间，并且赋予max一个初始值，这个初始值我们可以用宏来定义我们初始化通讯录的大小</p> 
<pre><code class="language-cs">#define CON_MAX 3//通讯录初始化大小
void InitCon(contact* pc)
{
	assert(pc);
	pc-&gt;sz = 0;
	pc-&gt;max = CON_MAX;
    pc-&gt;con = (Peo*)malloc(sizeof(Peo) * pc-&gt;max);
	if (pc-&gt;con == NULL)
	{
		perror("InitContact::malloc");
		return;
	}
	memset(pc-&gt;con, 0, pc-&gt;max * sizeof(Peo));
}</code></pre> 
<h2 id="3.%E5%A2%9E%E5%AE%B9">3.增容</h2> 
<p>当我们增加联系人是sz == max的时候，我们可以利用realloc函数来实现扩容，每一次扩容两个空间</p> 
<pre><code class="language-cs">void CheckCapacity(contact* pc)
{
	//增容的代码
	if (pc-&gt;sz == pc-&gt;max)
	{
		Peo* tmp = (Peo*)realloc(pc-&gt;sz, (pc-&gt;max + 2) * sizeof(Peo));
		if (tmp != NULL)
		{
			pc-&gt;sz = tmp;
		}
		else
		{
			perror("CheckCapacity::realloc");
			return;
		}
		pc-&gt;max += 2;
		printf("增容成功n");
	}
}</code></pre> 
<h2 id="%C2%A04.%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"> 4.释放内存</h2> 
<p>这边我们可以构建一个函数在这个程序结束之后释放内存</p> 
<pre><code class="language-cs">void DestroyContact(contact* pc)
{
	free(pc-&gt;con);
	pc-&gt;con = NULL;
	pc-&gt;max = 0;
	pc-&gt;sz = 0;
	printf("销毁成功n");
}</code></pre> 
<h1 id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93">四、总结</h1> 
<p>这个通讯录主要考察的是对于结构体的访问，还有对于结构体的创建，在编码的时候得务必细心，最后放上完整的源代码供大家参考</p> 
<pre><code class="language-cs">#pragma once
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;

//类型的声明

#define MAX 1000

#define NAME_MAX 20
#define SEX_MAX 5
#define TELE_MAX 12
#define ADDR_MAX 30

//通讯录初始状态的容量大小
#define DEFAULT_SZ 3

enum Option
{
	EXIT,//0
	ADD,
	DEL,
	SEARCH,
	MODIFY,
	SORT,
	PRINT
};
enum Con
{
	ERRO,
	NAME,
	SEX,
	AGE,
	TELE,
	ADDR
};

typedef struct PeoInfo
{
	char name[NAME_MAX];
	char sex[SEX_MAX];
	int age;
	char tele[TELE_MAX];
	char addr[ADDR_MAX];
} PeoInfo;
typedef struct Contact
{
	PeoInfo* data;//可以存放1000个人的信息
	int sz;//记录通讯中已经保存的信息个数
	int capacity;//记录通讯录当前的最大容量
}Contact;
//函数的声明
//初始化通讯录
void InitContact(Contact* pc);
//销毁通讯录
void DestroyContact(Contact* pc);
//增加联系人的信息
void AddContact(Contact* pc);
//打印通讯录中的信息
void PrintContact(const Contact* pc);
//删除指定联系人
void DelContact(Contact* pc);
//查找指定联系人
void SearchContact(const Contact* pc);
//保存通讯录的信息到文件
void SaveContact(const Contact* pc);
//通讯录排序
void SortCon(Contact* pc);
void ModifyCon(Contact* pc);
#define _CRT_SECURE_NO_WARNINGS 1

//动态的版本
//void InitContact(Contact* pc)
//{
//	assert(pc);
//	pc-&gt;sz = 0;
//	pc-&gt;capacity = DEFAULT_SZ;
//	pc-&gt;data = (PeoInfo*)malloc(pc-&gt;capacity * sizeof(PeoInfo));
//
//	if (pc-&gt;data == NULL)
//	{
//		perror("InitContact::malloc");
//		return;
//	}
//	memset(pc-&gt;data, 0, pc-&gt;capacity * sizeof(PeoInfo));
//}
void CheckCapacity(Contact* pc)
{
	//增容的代码
	if (pc-&gt;sz == pc-&gt;capacity)
	{
		PeoInfo* tmp = (PeoInfo*)realloc(pc-&gt;data, (pc-&gt;capacity + 2) * sizeof(PeoInfo));
		if (tmp != NULL)
		{
			pc-&gt;data = tmp;
		}
		else
		{
			perror("CheckCapacity::realloc");
			return;
		}
		pc-&gt;capacity += 2;
		printf("增容成功n");
	}
}
void LoadContact(Contact* pc)
{
	//打开文件
	FILE* pf = fopen("contact.dat", "rb");
	if (pf == NULL)
	{
		perror("LoadContact::fopen");
		return;
	}
	//读文件
	PeoInfo tmp = { 0 };
	while (fread(&amp;tmp, sizeof(PeoInfo), 1, pf))
	{
		CheckCapacity(pc);
		pc-&gt;data[pc-&gt;sz] = tmp;
		pc-&gt;sz++;
	}

	//关闭文件
	fclose(pf);
	pf = NULL;
}
//初始化通讯录 - 文件版本
void InitContact(Contact* pc)
{
	assert(pc);
	pc-&gt;sz = 0;
	pc-&gt;capacity = DEFAULT_SZ;
	pc-&gt;data = (PeoInfo*)malloc(pc-&gt;capacity * sizeof(PeoInfo));

	if (pc-&gt;data == NULL)
	{
		perror("InitContact::malloc");
		return;
	}
	memset(pc-&gt;data, 0, pc-&gt;capacity * sizeof(PeoInfo));

	//加载文件信息到通讯录中
	LoadContact(pc);
}
void DestroyContact(Contact* pc)
{
	free(pc-&gt;data);
	pc-&gt;data = NULL;
	pc-&gt;capacity = 0;
	pc-&gt;sz = 0;
	printf("销毁成功n");
}
void AddContact(Contact* pc)
{
	assert(pc);

	//静态版本
	//if (pc-&gt;sz == MAX)
	//{
	//	printf("通讯录已满，无法添加n");
	//	return;
	//}

	//动态的版本
	CheckCapacity(pc);

	//录入信息
	printf("请输入名字:&gt;");
	scanf("%s", pc-&gt;data[pc-&gt;sz].name);
	printf("请输入年龄:&gt;");
	scanf("%d", &amp;(pc-&gt;data[pc-&gt;sz].age));
	printf("请输入性别:&gt;");
	scanf("%s", pc-&gt;data[pc-&gt;sz].sex);
	printf("请输入电话:&gt;");
	scanf("%s", pc-&gt;data[pc-&gt;sz].tele);
	printf("请输入地址:&gt;");
	scanf("%s", pc-&gt;data[pc-&gt;sz].addr);

	pc-&gt;sz++;
	printf("添加成功n");
}
void PrintContact(const Contact* pc)
{
	assert(pc);

	int i = 0;
	printf("%-20s %-5s %-5s %-12s %-30sn", "姓名", "年龄", "性别", "电话", "地址");

	for (i = 0; i &lt; pc-&gt;sz; i++)
	{
		printf("%-20s %-5d %-5s %-12s %-30sn", pc-&gt;data[i].name, pc-&gt;data[i].age, pc-&gt;data[i].sex, pc-&gt;data[i].tele, pc-&gt;data[i].addr);
	}
}

//找到了返回下标
//找不到返回-1
int FindByName(const Contact* pc, char name[])
{
	assert(pc);
	int i = 0;
	for (i = 0; i &lt; pc-&gt;sz; i++)
	{
		if (0 == strcmp(pc-&gt;data[i].name, name))
		{
			return i;
		}
	}

	return -1;
}

void DelContact(Contact* pc)
{
	assert(pc);

	if (pc-&gt;sz == 0)
	{
		printf("通讯录已空，无法删除n");
		return;
	}
	//删除
	//1. 找到
	char name[NAME_MAX] = { 0 };
	printf("请输入要删除人的名字:&gt;");
	scanf("%s", name);
	int pos = FindByName(pc, name);
	if (pos == -1)
	{
		printf("要删除的人不存在n");
		return;
	}
	//2. 删除
	int j = 0;
	for (j = pos; j &lt; pc-&gt;sz - 1; j++)
	{
		pc-&gt;data[j] = pc-&gt;data[j + 1];
	}

	pc-&gt;sz--;
	printf("删除成功n");
}

void SearchContact(const Contact* pc)
{
	char name[NAME_MAX] = { 0 };
	printf("请输入要查找人的名字:&gt;");
	scanf("%s", name);
	int pos = FindByName(pc, name);
	if (pos == -1)
	{
		printf("要查找的人不存在n");
		return;
	}
	printf("%-20s %-5s %-5s %-12s %-30sn", "姓名", "年龄", "性别", "电话", "地址");
	printf("%-20s %-5d %-5s %-12s %-30sn", pc-&gt;data[pos].name, pc-&gt;data[pos].age, pc-&gt;data[pos].sex,
		pc-&gt;data[pos].tele, pc-&gt;data[pos].addr);
}


void SaveContact(const Contact* pc)
{
	FILE* pf = fopen("contact.dat", "wb");
	//回来本地建立一个contact.dat的记事本
	if (pf == NULL)
	{
		perror("SaveContact::fopen");
		return;
	}
	//写文件
	int i = 0;
	for (i = 0; i &lt; pc-&gt;sz; i++)
	{
		fwrite(pc-&gt;data + i, sizeof(PeoInfo), 1, pf);
	}

	//关闭文件
	fclose(pf);
	pf = NULL;
}
void SortCon(Contact* pc)
{
	if (pc-&gt;sz == 0)
	{
		printf("通讯录中没有联系人n");
	}
	else
	{
		for (int i = 0; i &lt; pc-&gt;sz - 1; i++)
		{
			for (int j = 0; j &lt; pc-&gt;sz - 1 - i; j++)
			{
				if ((strcmp(pc-&gt;data[j].name, pc-&gt;data[j + 1].name)) &gt; 0)
				{
					PeoInfo temp = pc-&gt;data[j];
					pc-&gt;data[j] = pc-&gt;data[j + 1];
					pc-&gt;data[j + 1] = temp;
				}
			}
		}
		printf("排序成功！n");
	}
}

void ModifyCon(Contact* pc)
{
	assert(pc);
	char name[NAME_MAX];
	printf("请输入需要修改信息用户的名字:&gt;n");
	scanf("%s", name);
	int pos = FindByName(pc, name);//pos为要寻找的人的下标
	if (pos == -1)
	{
		printf("查无此人n");
	}
	else
	{
		int num = 0;
		do {
			printf("请输入你想修改此用户的信息n");
			printf(" 0.退出 1.姓名 2.性别 3.年龄 4.电话 5.地址:&gt;n");
			scanf("%d", &amp;num);
			switch (num)
			{
			case NAME:
				printf("请输入你想修改的姓名:&gt;n");
				scanf("%s", pc-&gt;data[pos].name);
				break;
			case SEX:
				printf("请输入你想修改的性别:&gt;n");
				scanf("%s", pc-&gt;data[pos].sex);
				break;
			case AGE:
				printf("请输入你想修改的年龄:&gt;n");
				scanf("%d", &amp;(pc-&gt;data[pos].age));
				break;
			case TELE:
				printf("请输入你想修改的电话:&gt;n");
				scanf("%s", pc-&gt;data[pos].tele);
				break;
			case ADDR:
				printf("请输入你想修改的地址:&gt;n");
				scanf("%s", pc-&gt;data[pos].addr);
				break;
			case 0:
				printf("不修改退回界面n");
				break;
			default:printf("无效操作数！n");
			}
		} while (num);
	}
}

void menu()
{
	printf("*****************************************n");
	printf("**** 1.增加联系人    2.删除联系人    ****n");
	printf("**** 3.查找联系人    4.修改联系人    ****n");
	printf("**** 5.通讯录排序    6.打印通讯录    ****n");
	printf("****            0.退出               ****n");
	printf("******************************************n");
}

void test()
{
	int input = 0;
	Contact con;
	InitContact(&amp;con);

	do
	{
		menu();
		printf("请输入你的选择:&gt;");
		scanf("%d", &amp;input);
		switch (input)
		{
		case ADD:
			AddContact(&amp;con);
			break;
		case DEL:
			DelContact(&amp;con);
			break;
		case SEARCH:
			SearchContact(&amp;con);
			break;
		case MODIFY:
			ModifyCon(&amp;con);
			break;
		case SORT:
			SortCon(&amp;con);
			break;
		case PRINT:
			PrintContact(&amp;con);
			break;
		case EXIT:
			SaveContact(&amp;con);
			DestroyContact(&amp;con);
			printf("感谢使用n");
			break;
		default:
			printf("非法输入n");
			break;
		}
	} while (input);
}

int main()
{
	test();
	return 0;
}


</code></pre> 
<p>感谢阅读！！！！</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>