<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Java集合专题（超级详细） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java集合专题（超级详细）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="Java_0"></a>Java集合专题（超级详细）</h1> 
<p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#Java_0">Java集合专题（超级详细）</a></li>
<li><a href="#_8">前言</a></li>
<li><a href="#_10">一、集合是什么？</a></li>
<li>
<ul>
<li><a href="#1_12">1.集合和数组的区别</a></li>
<li><a href="#2Collection_19">2.Collection体系的继承树</a></li>
<li>
<ul>
<li><a href="#21_Collection_22">2.1 Collection接口常用方法</a></li>
<li><a href="#22_Collection_32">2.2 Collection常用遍历方式</a></li>
<li>
<ul>
<li><a href="#221_Iterator_33">2.2.1 迭代器Iterator使用</a></li>
<li><a href="#222_for_44">2.2.2 增强for循环遍历</a></li>
</ul>
    </li>
<li><a href="#23__List3_56">2.3 List常用遍历方式(3种)</a></li>
<li><a href="#24__Set2_62">2.4 Set常用遍历方式(2种)</a></li>
</ul>
   </li>
<li><a href="#3Map_67">3.Map体系的继承树</a></li>
<li>
<ul>
<li><a href="#31_Map_82">3.1 Map接口常用方法</a></li>
<li><a href="#32_Map6_90">3.2 Map常用遍历方式（6种）</a></li>
</ul>
   </li>
<li><a href="#4ListSetMap_163">4.List，Set，Map三者的区别</a></li>
<li><a href="#5_171">5.开发中如何选择集合</a></li>
</ul>
  </li>
<li><a href="#List_188">二、List源码分析</a></li>
<li>
<ul>
<li><a href="#1ArrayList_190">1.ArrayList源码分析</a></li>
<li><a href="#2Vector_221">2.Vector源码分析</a></li>
<li><a href="#3ArrayListVector_306">3.ArrayList与Vector的区别</a></li>
<li><a href="#4LinkedList_311">4.LinkedList源码分析</a></li>
<li>
<ul><li><a href="#41_LinkedList_333">4.1 LinkedList添加操作底层分析</a></li></ul>
   </li>
<li><a href="#5ArrayListLinkedList_383">5.ArrayList与LinkedList的区别</a></li>
<li>
<ul><li><a href="#51_ArrayListLinkedList_388">5.1 如何选择ArrayList和LinkedList</a></li></ul>
  </li>
</ul>
  </li>
<li><a href="#Set_394">三、Set源码分析</a></li>
<li>
<ul>
<li><a href="#1HashSet_396">1.HashSet源码分析</a></li>
<li>
<ul>
<li><a href="#11_HashSet_397">1.1 HashSet添加操作底层分析</a></li>
<li><a href="#12_HashSet_493">1.2 HashSet的扩容和转红黑树机制</a></li>
</ul>
   </li>
<li><a href="#2LinkedHashSet_499">2.LinkedHashSet源码分析</a></li>
<li>
<ul><li><a href="#21_LinkedHashSet_502">2.1 LinkedHashSet添加操作底层分析</a></li></ul>
  </li>
</ul>
  </li>
<li><a href="#Map_521">四、Map源码分析</a></li>
<li>
<ul>
<li><a href="#1HashMap_523">1.HashMap源码分析</a></li>
<li><a href="#2HashTable_551">2.HashTable源码分析</a></li>
<li><a href="#3TreeMap_600">3.TreeMap源码分析</a></li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<hr size='1"'> 
<h1>
<a id="_8"></a>前言</h1> 
<h1>
<a id="_10"></a>一、集合是什么？</h1> 
<p><mark><strong>集合是一个用来存放对象的容器，它只能存放对象</strong></mark>（<em><strong>实际上是对象名，即指向地址的指针</strong></em>），在没有集合前，我们是用数组来储存对象的。下面介绍一下集合和数组之间都有哪些不同。</p> 
<h2>
<a id="1_12"></a>1.集合和数组的区别</h2> 
<table>
<thead><tr>
<th>区别</th>
<th>数组</th>
<th>集合</th>
</tr></thead>
<tbody>
<tr>
<td>长度</td>
<td>固定</td>
<td>可变</td>
</tr>
<tr>
<td>存放类型</td>
<td>基本类型/引用类型</td>
<td>引用类型</td>
</tr>
<tr>
<td>存储元素</td>
<td>同一种类型</td>
<td>不同类型</td>
</tr>
<tr>
<td>操作上</td>
<td>添加/删除元素比较麻烦</td>
<td>提供add/remove/set/get 比较方便</td>
</tr>
</tbody>
</table>
<h2>
<a id="2Collection_19"></a>2.Collection体系的继承树</h2> 
<p><img src="https://images2.imgbox.com/b7/f9/lFWse3QZ_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="21_Collection_22"></a>2.1 Collection接口常用方法</h3> 
<ol>
<li>add:添加单个元素</li>
<li>remove：删除指定元素</li>
<li>contains：查找元素是否为空</li>
<li>size：获取元素个数</li>
<li>isEmpty：判断元素是否为空</li>
<li>clear：清空</li>
<li>addAll：添加多个元素</li>
<li>containsAll：查找多个元素是否都存在</li>
<li>removeAll：删除多个元素</li>
</ol> 
<h3>
<a id="22_Collection_32"></a>2.2 Collection常用遍历方式</h3> 
<h4>
<a id="221_Iterator_33"></a>2.2.1 迭代器Iterator使用</h4> 
<p>Collection接口遍历元素使用Iterator(称为迭代器)，<mark>所有实现Collection接口的集合类都有一个Iterator（）方法</mark>，只能用于遍历集合。</p> 
<pre><code class="prism language-java">        List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Iterator iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取迭代器</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//判断是否还有下一个，如果不用hasNext()会报NoSuchElementException</span>
            Object next <span class="token operator">=</span>  iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<h4>
<a id="222_for_44"></a>2.2.2 增强for循环遍历</h4> 
<p>底层也是采用了 Iterator 的方式实现，可以理解为简化版本的Iterator</p> 
<pre><code class="prism language-java">        List lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//增强for循环同样可以用在数组上面</span>
        <span class="token comment">//使用foreach增强for循环</span>
       
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Object list<span class="token operator">:</span>lists<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="23__List3_56"></a>2.3 List常用遍历方式(3种)</h3> 
<p><strong>1. 使用迭代器（Iterator）<br> 2. 使用增强for循环<br> 3. 使用普通for循环</strong></p> 
<h3>
<a id="24__Set2_62"></a>2.4 Set常用遍历方式(2种)</h3> 
<p><strong>1. 使用迭代器（Iterator）<br> 2. 使用增强for循环</strong><br> 3. 不能使用普通for循环（因为没有提供get方法）</p> 
<h2>
<a id="3Map_67"></a>3.Map体系的继承树</h2> 
<p><img src="https://images2.imgbox.com/0e/0f/vjIHMKQ5_o.png" alt="在这里插入图片描述"><br> Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素）<br> <strong>Key-Value为了方便遍历，还会创建EntrySet集合，该集合存放元素的类型Entry，而一个Entry对象就有Key，Value。</strong><br> 当HashMap $ Node对象存放到EntrySet就会方便我们遍历，因为Map.Entry&lt;K, V&gt;提供了重要的方法，如下：</p> 
<pre><code class="prism language-java"> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span> V<span class="token punctuation">&gt;</span></span><span class="token operator">&gt;</span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
 <span class="token keyword">interface</span> <span class="token class-name">Entry</span><span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="31_Map_82"></a>3.1 Map接口常用方法</h3> 
<ol>
<li>put:添加</li>
<li>remove：根据键删除映射关系</li>
<li>get：根据键获取值</li>
<li>size：获取元素个数</li>
<li>isEmpty：判断元素是否为空</li>
<li>clear：清空</li>
<li>containsKey：查找键是否存在</li>
</ol> 
<h3>
<a id="32_Map6_90"></a>3.2 Map常用遍历方式（6种）</h3> 
<p><strong><mark>第一组：先取出所有的key，在通过Key获取对应的Values</mark></strong></p> 
<ol><li><strong>增强for循环</strong></li></ol> 
<pre><code class="prism language-java">			<span class="token comment">//先取出所有的key，在通过Key获取对应的Values</span>
        Set keyset <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Object key<span class="token operator">:</span>keyset<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"__"</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li><strong>迭代器</strong></li></ol> 
<pre><code class="prism language-java">		<span class="token comment">//先取出所有的key，在通过Key获取对应的Values</span>
        Set keyset <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Iterator iterator <span class="token operator">=</span> keyset<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            Object key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><strong><mark>第二组：取出所有的Values</mark></strong><br> 3. <strong>增强for循环</strong></p> 
<pre><code class="prism language-java">	<span class="token comment">//把所有的Values值取出</span>
	Collection values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>Object value<span class="token operator">:</span>values<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	
</code></pre> 
<ol start="4"><li><strong>迭代器</strong></li></ol> 
<pre><code class="prism language-java">		<span class="token comment">//把所有的Values值取出</span>
        Collection values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Iterator iterator <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            Object value <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><strong><mark>第三组：通过EntrySet来获取key-value</mark></strong><br> 5. <strong>增强for循环</strong></p> 
<pre><code class="prism language-java">	<span class="token comment">//通过EntrySet来获取key-value</span>
	Set entrySet <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Object entry<span class="token operator">:</span>entrySet<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          Map<span class="token punctuation">.</span>Entry entrys <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span> entry<span class="token punctuation">;</span>
          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entrys<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>entrys<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
</code></pre> 
<ol start="6"><li><strong>迭代器</strong></li></ol> 
<pre><code class="prism language-java">		<span class="token comment">通过EntrySet来获取key-value</span>
        Set entrySet <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Iterator iterator <span class="token operator">=</span> entrySet<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            Object value <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Map<span class="token punctuation">.</span>Entry entrys <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span> value<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entrys<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>entrys<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="4ListSetMap_163"></a>4.List，Set，Map三者的区别</h2> 
<p>Collection集合主要有List和Set两大接口</p> 
<table>
<thead><tr>
<th>接口</th>
<th>有序性</th>
<th>重复性</th>
<th>索引</th>
</tr></thead>
<tbody>
<tr>
<td>List</td>
<td>有序</td>
<td>可重复</td>
<td>有</td>
</tr>
<tr>
<td>Set</td>
<td>无序</td>
<td>不可重复</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。</p> 
<h2>
<a id="5_171"></a>5.开发中如何选择集合</h2> 
<p>其实开发中如何选择集合，主要是<strong>取决于业务操作特点</strong>，然后根据集合实现类特性进行选择，分析如下：<br> <strong>1.先判断存储类型</strong>（是单列还是双列）<br> <strong>单列：Collection接口</strong></p> 
<ul>
<li>
<strong>允许重复：List</strong> 
  <ul>
<li>
<mark><strong>增删多：LinkedList</strong></mark>（底层维护了双向链表）</li>
<li>
<mark><strong>改查多：ArrayList</strong></mark>（底层维护了Object类型的可变数组）</li>
</ul> </li>
<li>
<strong>不允许重复：Set</strong> 
  <ul>
<li>
<mark><strong>无序：HashSet</strong></mark>（底层维护了HashMap）</li>
<li><mark><strong>排序：TreeSet</strong></mark></li>
<li>
<mark><strong>插入取出顺序一致：LinkedHashSet</strong></mark>（底层维护了数组+双向链表）</li>
</ul> </li>
</ul> 
<p><strong>双列：Map接口</strong></p> 
<ul>
<li><strong>键无序：HashMap</strong></li>
<li><strong>键有序：TreeMap</strong></li>
<li><strong>读取文件：Properties</strong></li>
<li><strong>插入取出顺序一致：LikendHashMap</strong></li>
</ul> 
<h1>
<a id="List_188"></a>二、List源码分析</h1> 
<h2>
<a id="1ArrayList_190"></a>1.ArrayList源码分析</h2> 
<p><font color="#999AAA">ArrayList是线程不安全的，从源码中可以看出，没有添加synchronized</font></p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>
        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><mark>ArrayList (线程不安全）</mark>，在多线程的情况下不建议使用ArrayList，可以考虑<mark>Vector(线程安全)</mark>。<mark>ArrayList 和Vector基本一样</mark>，除了在线程上面不同。<br> <strong>ArrayList底层操作机制源码分析：</strong></p> 
<ol>
<li> <p><strong>ArrayList中维护了一个Object类型的数组（transient Object[] elementData）</strong><mark>transient 表示该属性不会被序列化</mark>。 <strong>为什么要使用transient呢</strong>？<strong>因为lementData是一个缓存数组</strong>，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，<strong>可以保证只序列化实际存储的那些元素，而不是整个数组</strong>，从而节省空间和时间。</p> </li>
<li> <p>当创建ArrayList对象时，如果<strong>使用的是无参构造器</strong>，则初始化elementData容量为0 ，<strong>如果第一次添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍</strong></p> </li>
<li> <p>如果<strong>使用指定大小的容量capacity构造器</strong>，则初始化elementData容量为指定大小的capacity，如果<strong>需要扩容，则直接扩容elementData为1.5倍</strong></p> </li>
<li> <p>当添加元素时，先判断是否需要扩容，如果需要则调用grow()方法，否则直接添加元素到合适的位置</p> </li>
</ol> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// overflow-conscious code</span>
        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//位移1位 相当于原来的oldCapacity 除于2</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//第一次扩容因为oldCapacity为0，所以默认elementData为10</span>
            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//Arrays.copyOf保证原先的数组不变的情况下，进行扩容</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="2Vector_221"></a>2.Vector源码分析</h2> 
<p><font color="#999AAA">Vector底层也是一个对象数组，protected Object[] elementData，它是线程安全的，操作方法基本都带有synchronized，在开发中需要线程同步安全时，可以考虑Vector</font></p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">ensureCapacityHelper</span><span class="token punctuation">(</span>elementCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        elementData<span class="token punctuation">[</span>elementCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">synchronized</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> elementCount<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">synchronized</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> elementCount<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ol><li>如果是无参构造，默认Capacity为10，当Capacity超出10后就按2倍进行扩容</li></ol> 
<pre><code class="prism language-java">	<span class="token comment">//无参构造，默认Capacity为10</span>
    <span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">int</span> capacityIncrement<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>
                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacityIncrement <span class="token operator">=</span> capacityIncrement<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java">	<span class="token comment">//确定是否需要扩容</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityHelper</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">//capacityIncrement在创建Vector时默认就是0</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>capacityIncrement <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                                         capacityIncrement <span class="token operator">:</span> oldCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre> 
<ol start="2">
<li>如果是有参构造，指定大小，则每次直接按2倍扩容</li>
<li>如果指定大小Capacity和capacityIncrement（自定义扩容大小），则按照自定义扩容大小进行扩容</li>
</ol> 
<pre><code class="prism language-java">	<span class="token comment">//也可以进行指定capacityIncrement，不用默认的0</span>
    <span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">int</span> capacityIncrement<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>
                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacityIncrement <span class="token operator">=</span> capacityIncrement<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
	<span class="token comment">//扩容核心代码</span>
 	<span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>capacityIncrement <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                                         capacityIncrement <span class="token operator">:</span> oldCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2>
<a id="3ArrayListVector_306"></a>3.ArrayList与Vector的区别</h2> 
<table>
<thead><tr>
<th>集合</th>
<th>底层结构</th>
<th>效率</th>
<th>扩容机制</th>
<th>版本</th>
</tr></thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>线程不安全，效率高</td>
<td>有参构造 1.5倍，无参第一次10，第二次按1.5倍扩容</td>
<td>jdk1.2</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组</td>
<td>线程安全效率低</td>
<td>无参默认10，按2倍扩容，指定大小，每次也按2倍，通过有参构造修改capacityIncrement ，可以按照capacityIncrement 的值扩容</td>
<td>jdk1.0</td>
</tr>
</tbody>
</table>
<h2>
<a id="4LinkedList_311"></a>4.LinkedList源码分析</h2> 
<ol><li>
<mark>LinkedList底层实现了双向链表</mark>，维护了<mark>两个属性first（首节点）和last（尾结点）</mark>，<strong>每个节点中维护了prev,item,next</strong>三个属性。通过prev自行前一个节点和next指向后一个节点，最终实现双向链表。</li></ol> 
<pre><code class="prism language-java">    <span class="token keyword">transient</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>
    <span class="token keyword">transient</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>

	<span class="token comment">//node节点（有三个属性）</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        E item<span class="token punctuation">;</span>
        Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
        Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>

        <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="41_LinkedList_333"></a>4.1 LinkedList添加操作底层分析</h3> 
<p>1.执行添加操作，<mark><strong>在添加第一个元素时</strong></mark>，从源码中可以看出 first、last和都指向同一个节点，并且两头为空。</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span><span class="token comment">// 第一次添加 last为null</span>
        <span class="token keyword">final</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// l==null</span>
        <span class="token comment">//将新的节点，加入到双向链表的最后</span>
        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token comment">//last 指向newNode</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment">//执行这条语句</span>
            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment">//first 指向newNode</span>
        <span class="token keyword">else</span>
            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//链表元素个数</span>
        modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//修改次数</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>参考下图更容易理解：<br> <img src="https://images2.imgbox.com/cc/81/9C7SembT_o.png" alt="在这里插入图片描述"></p> 
<p>2.执行添加操作，<mark><strong>在添加第二个元素时</strong></mark>，从源码中可以看出 first、last和都指向同一个节点，并且两头为空。</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span><span class="token comment">// 第二次添加 l指向last</span>
        <span class="token keyword">final</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>E<span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// l==last,这里相当于把新节点 的pre指向last(前一个节点)</span>
        <span class="token comment">//将新的节点，加入到双向链表的最后</span>
        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token comment">//last 指向新的节点newNode（原来的旧节点就断开了）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>
            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token comment">//l这个时候不为null 执行这条语句</span>
            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token comment">//l.next 指向newNode</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//链表元素个数</span>
        modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//修改次数</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>参考下图更容易理解：<br> <img src="https://images2.imgbox.com/a0/37/W6AA70hZ_o.png" alt="在这里插入图片描述"></p> 
<ol>
<li>可以添加任意元素（元素可以重复），包括null，添加和删除是通过修改节点指向，不是由数组完成的，所以效率较高。</li>
<li>线程不安全，没有实现同步</li>
</ol> 
<h2>
<a id="5ArrayListLinkedList_383"></a>5.ArrayList与LinkedList的区别</h2> 
<table>
<thead><tr>
<th>集合</th>
<th>底层结构</th>
<th>效率</th>
</tr></thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>
<strong><mark>增删</mark>效率较<mark>低</mark></strong>（数组扩容）/<strong><mark>改查</mark>效率较<mark>高</mark></strong>
</td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>
<strong><mark>增删</mark>效率较<mark>高</mark></strong>（链表）/<strong><mark>改查</mark>效率较<mark>低</mark></strong>
</td>
</tr>
</tbody>
</table>
<h3>
<a id="51_ArrayListLinkedList_388"></a>5.1 如何选择ArrayList和LinkedList</h3> 
<p><strong>1.修改和查找操作多时，我们选择ArrayList</strong>，<br> <strong>2.增加和删除操作多时，我们选择LinkedList</strong></p> 
<blockquote> 
 <p>注意：这两个集合都是线程不安全的，所以适合在单线程的情况下使用</p> 
</blockquote> 
<h1>
<a id="Set_394"></a>三、Set源码分析</h1> 
<h2>
<a id="1HashSet_396"></a>1.HashSet源码分析</h2> 
<h3>
<a id="11_HashSet_397"></a>1.1 HashSet添加操作底层分析</h3> 
<p><strong>1.HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）</strong></p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>2.添加一个元素时，先得到hash值（hash值是通过(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)算法计算得出），在转成索引值</p> 
<pre><code class="prism language-java">   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//PRESENT 占位用 没有实际意义</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//这里主要用到key;  value=PRESENT 是static共享的</span>
	<span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//得到hash值，这里的hash是通过算法计算得到的 </span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

 <span class="token comment">//核心方法（难点）</span>
 <span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Node<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
        <span class="token comment">//table就是HashMap的一个数组，类型是Node[]</span>
        <span class="token comment">//table是null或0,就是第一次扩容到16个空间</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token comment">//resize()执行返回Node&lt;K,V&gt;[]有16个大小的</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">//根据key得到的hash，去计算key应该放在table表的哪个索引位置，并把这个位置赋值给p</span>
        <span class="token comment">//如果p为null:表示还未存放元素，就创建一个Node，然后放进去tab[i] = newNode(hash, key, value, null);</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//如果p不为null:</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            Node<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span><span class="token comment">//定义了辅助变量,在需要的时候在创建</span>
            <span class="token comment">//如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样</span>
            <span class="token comment">//并且满足下面两个条件之一：</span>
            <span class="token comment">//1、准备加入的key和p指向Node结点的key是同一个对象（地址相同）</span>
            <span class="token comment">//2、准备加入的key和p指向Node结点的key是同一个值（值相同）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> 
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">//这里可以重写equals方法 比如new Person("小明");new Person("小明");</span>
                <span class="token comment">//通过重写equals方法可以让他们按照equals去比较是否相等</span>
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token comment">//判断p是不是红黑树,如果是调用putTreeVal方法</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//如果table对应索引位置，已经是一个链表，就可以使用for循环比较</span>
                <span class="token comment">//依次和该链表的每一个元素比较后，都不相同，则加入到该链表的最后，添加后立即判断该链表是否已经达到8个节点，如果达到就调用treeifyBin（tab, hash）方法（树化）转成红黑树。</span>
                <span class="token comment">//在转成红黑树时,要进行判断，如果该table数组size小于64（TREEIFY_CAPACITY），不会马上树化，会先扩容table。</span>
                <span class="token comment">//如果发现相同的情况，就直接break</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
			
			<span class="token comment">//这里指的是当用HashMap时，key一致，value不可重复（替换原来的value）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// existing mapping for key</span>
                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>3.找到存储数据表table，看这个索引位置是否已经存放有元素<br> 4.如果没有，直接加入<br> 5.如果有，就调用equals比较，如果相同，就放弃添加，如果不同，则添加到最后<br> 6.在java8中，如果一条链表的元素个数达到TREEIFY_THRESHOLD（默认是8）,并且table的大小&gt;=TREEIFY_CAPACITY（默认64），就会进行树化（红黑树）</p> 
<h3>
<a id="12_HashSet_493"></a>1.2 HashSet的扩容和转红黑树机制</h3> 
<ol>
<li>HashSet底层是HashMap，<strong>第一次添加时，table数组扩容到16</strong>，<strong>临界值（threshold）是</strong>16*加载因子（loadFactor）0.75=<strong>12</strong>
</li>
<li>
<strong>如果table数组使用到了临界值12，就会扩容到16<em>2=32，新的临界值就是32</em>0.75=24</strong>，以此类推</li>
<li>在Java8中，如果一条链表的<strong>元素个数达到</strong>TREEIFY_THRESHOLD（默认是<strong>8</strong>）,并且<strong>table的大小&gt;=</strong> TREEIFY_CAPACITY（默认<strong>64</strong>），<strong>就会进行树化（红黑树）</strong>，<mark><strong>否则仍然采用数组扩容机制</strong></mark>
</li>
</ol> 
<h2>
<a id="2LinkedHashSet_499"></a>2.LinkedHashSet源码分析</h2> 
<p><strong><mark>LinkedHashSet底层是一个LinkedHashMap</mark></strong>,底层维护了一个数组+双向链表。添加数据和取出元素的顺序一致</p> 
<h3>
<a id="21_LinkedHashSet_502"></a>2.1 LinkedHashSet添加操作底层分析</h3> 
<p>1.第一次添加时，直接将数值table扩容到16，<strong>存放节点(数据)的类型是LinkedHashMap $ Entry，数组类型是HashMap $ Node[]</strong></p> 
<p><strong><mark>作为HashSet的子类，只是比它多了一条链表</mark></strong>，这条链表用来记录元素顺序，因此LinkedHashSet其中的元素有序。</p> 
<pre><code class="prism language-java">    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>
        <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>添加方法和前面描述的HashSet添加操作底层分析一样的，这里就不再重复介绍。</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h1>
<a id="Map_521"></a>四、Map源码分析</h1> 
<h2>
<a id="1HashMap_523"></a>1.HashMap源码分析</h2> 
<p>在上面的HashSet中已经讲过了，这里就简单讲解一下</p> 
<p><strong>HashMap是最经典的Map实现，下面以它的视角介绍put的过程：</strong></p> 
<p><strong>1.首次扩容：</strong></p> 
<ul><li>先判断数组是否为空，若数组为空则进行第一次扩容（resize）；</li></ul> 
<p><strong>2.计算索引：</strong></p> 
<ul><li>通过hash算法，计算键值对在数组中的索引；</li></ul> 
<p><strong>3.插入数据：</strong></p> 
<ul>
<li> <p>如果当前位置元素为空，则直接插入数据；</p> </li>
<li> <p>如果当前位置元素非空，且key已存在，则直接覆盖其value；</p> </li>
<li> <p>如果当前位置元素非空，且key不存在，则将数据链到链表末端；</p> </li>
<li> <p>若链表长度达到8，则将链表转换成红黑树，并将数据插入树中；</p> </li>
</ul> 
<p><strong>4.再次扩容</strong></p> 
<p>如果数组中元素个数（size）超过threshold，则再次进行扩容操作。<br> <img src="https://images2.imgbox.com/80/5d/5XLHzvqm_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="2HashTable_551"></a>2.HashTable源码分析</h2> 
<p><strong>HashTable</strong>（<strong><mark>线程安全</mark></strong>）使用方法基本和HashMap（线程不安全）一致，<strong><mark>HashTable的键和值都不能为空</mark></strong><br> <strong><mark>底层用Hashtable $ Entry[] 初始化大小为11</mark></strong>。临界值threshold为8 = 11 * loadFactor（0.75）</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">transient</span> Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
  
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Make sure the value is not null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
         Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">&gt;</span> tab<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">%</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
        Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> entry <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> entry <span class="token operator">!=</span> null <span class="token punctuation">;</span> entry <span class="token operator">=</span> entry<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> entry<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                V old <span class="token operator">=</span> entry<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                entry<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token keyword">return</span> old<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
		
		<span class="token comment">//添加方法</span>
        <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    
	 <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
	
	        Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">&gt;</span> tab<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> table<span class="token punctuation">;</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;=</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	            <span class="token comment">// 扩容方法</span>
	            <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	            tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
	            hash <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">%</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
	        <span class="token punctuation">}</span>
	
	        <span class="token comment">// Creates the new entry.</span>
	        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
	        Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
	        tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	        count<span class="token operator">++</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="3TreeMap_600"></a>3.TreeMap源码分析</h2> 
<p><strong>TreeMap基于红黑树（Red-Black tree）实现</strong>。<strong>映射根据其键的自然顺序进行排序，<mark>或者根据创建映射时提供的 Comparator 进行排序</mark></strong>，具体取决于使用的构造方法。TreeMap的基本操作containsKey、get、put、remove方法，它的<strong>时间复杂度是log(N)</strong>。</p> 
<p>TreeMap包含几个重要的成员变量：root、size、comparator。其中root是红黑树的根节点。<strong>它是Entry类型</strong>，Entry是红黑树的节点，它包含了红黑树的6个基本组成：key、value、left、right、parent和color。<strong>Entry节点根据根据Key排序，包含的内容是value</strong>。<strong>Entry中key比较大小是根据比较器comparator来进行判断的</strong>。size是红黑树的节点个数。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>