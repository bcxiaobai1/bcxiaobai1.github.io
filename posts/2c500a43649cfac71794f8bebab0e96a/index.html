<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>solidity基础以及版本变化 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">solidity基础以及版本变化</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>文章目录</h3> 
 <ul><li>
<ul>
<li><a href="#_2">参考网址</a></li>
<li><a href="#_6">修饰符</a></li>
<li>
<ul>
<li><a href="#_constantsimmutable_7">初始变量修饰符 constants-immutable</a></li>
<li><a href="#_storagememorycalldata_13">数据位置 storage-memory-calldata</a></li>
<li><a href="#_viewpure_18">方法修饰符 view-pure</a></li>
<li><a href="#_requirerevertassert_22">错误 require-revert-assert</a></li>
<li><a href="#_publicprivateinternalexternal_39">方法修饰符 public-private-internal-external</a></li>
</ul> 
   </li>
<li><a href="#mapping_46">mapping</a></li>
<li><a href="#_58">数组</a></li>
<li><a href="#struct__132">struct 结构体</a></li>
<li><a href="#modifier_189">modifier</a></li>
<li><a href="#Events___indexed_219">Events 事件 indexed</a></li>
<li><a href="#Constructor__256">Constructor 构造方法</a></li>
<li><a href="#__Inheritance_309">继承 Inheritance</a></li>
<li><a href="#_386">调用父类合约</a></li>
<li><a href="#payable_468">payable</a></li>
<li><a href="#_Sending_Ether_transfer_send_call_491">发送以太坊 Sending Ether (transfer, send, call)</a></li>
<li>
<ul>
<li><a href="#ether_492">有三种方式给地址转ether</a></li>
<li><a href="#_497">合约接收以太坊</a></li>
<li><a href="#_507">应该使用哪个方法</a></li>
</ul> 
   </li>
<li><a href="#fallback_receivefunction_583">fallback 回调函数，receive，function()</a></li>
<li>
<ul>
<li><a href="#060_591">低版本的实现(0.6.0前)</a></li>
<li><a href="#060_598">0.6.0后的版本</a></li>
</ul> 
   </li>
<li><a href="#call_624">call</a></li>
<li><a href="#delegatecall_662">delegatecall</a></li>
<li><a href="#functionselector_668">function-selector</a></li>
<li><a href="#_Calling_Other_Contract_692">调用其他合约 Calling Other Contract</a></li>
<li><a href="#_757">合约中创建合约</a></li>
<li>
<ul><li><a href="#_827">合约内提前计算地址</a></li></ul> 
   </li>
<li><a href="#try_catch_881">try catch</a></li>
<li><a href="#Keccak256_949">Keccak256</a></li>
<li>
<ul><li><a href="#encodePackedencode_996">encodePacked,encode后的区别</a></li></ul> 
   </li>
<li><a href="#_Verifying_Signature_1037">验证签名 Verifying Signature</a></li>
<li><a href="#solidity_1204">solidity版本变化</a></li>
<li>
<ul>
<li><a href="#050_1207">0.5.0</a></li>
<li><a href="#060_1211">0.6.0</a></li>
<li><a href="#070_1220">0.7.0</a></li>
<li><a href="#080_1229">0.8.0</a></li>
</ul> 
  </li>
</ul> 
 </li></ul> 
</div> 
<p></p> 
<h2>
<a id="_2"></a>参考网址</h2> 
<p>此处主要是针对链接中，增加中文理解说明，有需要可查看原文</p> 
<p>（文中参考代码主要摘自该链接）<a href="https://solidity-by-example.org/">https://solidity-by-example.org/</a></p> 
<h2>
<a id="_6"></a>修饰符</h2> 
<h3>
<a id="_constantsimmutable_7"></a>初始变量修饰符 constants-immutable</h3> 
<ul>
<li>constants 常量，硬编码，不可修改</li>
<li>immutable 不可变， 可在构造函数中赋值，之后不能修改</li>
<li>public 外部可访问，public变量会默认有个getter</li>
<li>private/default 私有，外部访问不了，子类可访问</li>
</ul> 
<h3>
<a id="_storagememorycalldata_13"></a>数据位置 storage-memory-calldata</h3> 
<ul>
<li>storage 全局变量都属于storage,存储在区块中，方法中使用该声明，会对区块信息修改</li>
<li>memory 存储在内存中，仅调用函数体内有效，可修改值</li>
<li>calldata 主要针对external类方法的参数，和memory的区别是不可以修改该变量</li>
</ul> 
<h3>
<a id="_viewpure_18"></a>方法修饰符 view-pure</h3> 
<ul>
<li>view 不会更改任何状态(会读取区块内变量)</li>
<li>pure 不会更改任何状态且不读取区块内变量</li>
</ul> 
<h3>
<a id="_requirerevertassert_22"></a>错误 require-revert-assert</h3> 
<ul>
<li>require 执行的前置条件，如果这个不满足，无法往下执行， 且有提示语的话，会出现在浏览器和estimateGas提示</li>
<li>revert 在某个if判断，可调用revrt,功能和require类似</li>
<li>assert 断言某个条件是否为真</li>
</ul> 
<p>常用是require/revert, 可以将错误信息返出去，便于知道错误在哪<br> assert存在意义在哪不确定，可以使用require替代</p> 
<p>另外针对assert的区别。 0.8.x测试没发现和require有什么区别，但是在低版本区别很大<br> 例：0.4.x eth-usdt，可以去查看他的源码<br> 如果一个交易gasLimit设置的100w,实际消耗大概是5w，代码最后面增加(require,revert)/ assert 导致出错</p> 
<p>如果使用<mark>require/revert, 实际gasUsed = gasPrice * 5w</mark>，然后回退了<br> 如果使用<mark>assert， 实际gasUsed = gasPrice * 100w</mark>， 会把gas消耗完…!</p> 
<h3>
<a id="_publicprivateinternalexternal_39"></a>方法修饰符 public-private-internal-external</h3> 
<ul>
<li>public 公开的，本合约也可以调用，外部也可以调用</li>
<li>private 私有的， 仅本合约可以调用</li>
<li>internal 内部的， 当前合约和子合约可以调用</li>
<li>external 公开的，当前合约自身不可调用</li>
</ul> 
<h2>
<a id="mapping_46"></a>mapping</h2> 
<p>key=&gt;value 格式</p> 
<pre><code> mapping(address =&gt; uint) public myMap;
 mapping(address =&gt; mapping(uint =&gt; bool)) public nested;
 myMap[_addr] = _i;
 myMap[_addr];
 delete myMap[_addr];
 
</code></pre> 
<h2>
<a id="_58"></a>数组</h2> 
<pre><code>pragma solidity ^0.8.7;
contract Array {
    // 初始化数组的几种方式
    uint[] public arr;//可变长度数组，初始长度0
    uint[] public arr2 = [1, 2, 3];//可变长度数组，初始长度3，有对应值
    // 固定长度数组，所有元素是默认值，当前例子为 0，  这个数组不可以push/pop改变长度
    uint[10] public myFixedSizeArr;
    //通过下标获取数组元素
    function get(uint i) public view returns (uint) {
        return arr[i];
    }

    //可返回整个数组，这种方法需要避免长度很长可增长的数组
    //查询方法也受gasLimit限制，查询过多内容时会超限制
    function getArr() public view returns (uint[] memory) {
        return arr;
    }
    
     //数量很长的分页/区间查询
    function getArr1(uint256 pageNo, uint256 pageSize)public view returns(uint256[]memory list) {
        uint len = arr.length;
        uint start = pageNo * pageSize;
        if(len == 0  || start &gt;= len){
            return new uint[](0);
        }
        uint end = start + pageSize;
        if(end &gt; len){
            end = len;
        }
        uint arrLen = end - start;
        list = new uint[](arrLen);
        uint index;
        for(;start &lt; end ; start ++){
            list[index++] = start;
        }
    }
    
    

    function push(uint i) public {
        //追加到数组，数组长度加1
        arr.push(i);
    }

    function pop() public {
        //移除数组的最后一个元素
        arr.pop();
    }
    //返回数组长度
    function getLength() public view returns (uint) {
        return arr.length;
    }

    function remove(uint index) public {
       //delete 操作不对修改数组长度，只是把索引位置的值重置为默认值，当前例子为0
        delete arr[index];
    }
    //如果想移除一个值，且改变数组长度,
    //可以先替换值， 在pop
    //注： 该方式会导致数组值不是原来的插入顺序
    function remove2(uint index)public{
        arr[index] = arr[arr.length-1];
        arr.pop();
    }

    function examples() external {
        // 在内存中创建数组，只能创建固定大小
        uint[] memory a = new uint[](5);
    }
}
</code></pre> 
<h2>
<a id="struct__132"></a>struct 结构体</h2> 
<p>通过struct将相关数据放一起</p> 
<pre><code>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract Todos {
    struct Todo {
        string text;
        bool completed;
    }

    // An array of 'Todo' structs
    Todo[] public todos;//public声明， 外部可以通过  todos[index],输入index会返回整个结构体

    function create(string memory _text) public {
        // 3种初始化结构的方式
        // 像方法一样顺序传参
        todos.push(Todo(_text, false));

        // key value mapping
        todos.push(Todo({text: _text, completed: false}));

        // 初始化一个空的结构体，并针对每个字段赋值， 如果结构体中存在数组/其他结构体时，这种方式合适
        Todo memory todo;
        todo.text = _text;
        //未显视赋值的变量为类型初始值
        // todo.completed initialized to false

        todos.push(todo);
    }

    // Solidity automatically created a getter for 'todos' so
    // you don't actually need this function.
    function get(uint _index) public view returns (string memory text, bool completed) {
        Todo storage todo = todos[_index];
        return (todo.text, todo.completed);
    }
    //如果是低版本的，会要求在文件头部声明 pragma experimental ABIEncoderV2;
    function getObject(uint _index)public view returns(Todo memory){
        return todos[_index];
    }

    // update text
    function update(uint _index, string memory _text) public {
        Todo storage todo = todos[_index];
        todo.text = _text;
    }

    // update completed
    function toggleCompleted(uint _index) public {
        Todo storage todo = todos[_index];
        todo.completed = !todo.completed;
    }
}
</code></pre> 
<h2>
<a id="modifier_189"></a>modifier</h2> 
<p>可在函数调用前做一定处理，以及执行之后，再做一定处理</p> 
<p>主要功能</p> 
<ul>
<li>限制访问</li>
<li>验证输入</li>
<li>防止重入</li>
</ul> 
<pre><code>    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
       //下划线是一个特殊字符，仅在modifier中， 标志执行方法的其他代码
        _;
    }
    //判断输入的地址不是0地址
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Not valid address");
        _;
    }
    //防止重入，调用函数前先把状态改了， 函数执行完后， 再把状态改回来
    modifier noReentrancy() {
        require(!locked, "No reentrancy");

        locked = true;
        _;
        locked = false;
    }
</code></pre> 
<h2>
<a id="Events___indexed_219"></a>Events 事件 indexed</h2> 
<p>简单理解就是日志，便于知道区块内部执行了什么</p> 
<pre><code>event Transfer(address indexed from, address indexed to, uint value);
</code></pre> 
<p>日志定义里面有个indexed修饰符， 最多允许3个参数使用该修饰符<br> event的数据，在transaction中logs中存在两个不同位置，<br> indexed 修饰的 在topic中 而其他的在data中</p> 
<pre><code>"logs": [
            {
                "address": "0x55d398326f99059ff775485246999027b3197955",
                "topics": [
                    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
                    "0x000000000000000000000000eb2d2f1b8c558a40207669291fda468e50c12345",
                    "0x000000000000000000000000bcdc55ce32a3d875d440c6fec0354919ab812345"
                ],
                "data": "0x00000000000000000000000000000000000000000000001b1ae4d6e2ef500000"
            }
        ]
</code></pre> 
<p>logs中说明<br> <strong>address</strong> 表示该事件是哪个合约地址的(注意是实际发出的地址， 比如A合约调用B代币， address是B代币的地址，而不是A合约的地址)</p> 
<p><strong>topics</strong> 是个数组,topics[0] 表示事件名，后面的就是顺序取事件中的indexed修饰的参数<br> 以下针对Transfer事件的说明</p> 
<pre><code>topics[0]对应的内容是 keccak256(bytes('Transfer(address,address,uint256)'))
topics[1]对应的内容是事件中的 from
topics[2]对应的内容是事件中的 to
</code></pre> 
<p><strong>data</strong> 是非indexed修饰的参数，顺序取</p> 
<p>去掉前面的0x后， 每64位表示一个参数，解析的时候对应参数类型解析即可</p> 
<h2>
<a id="Constructor__256"></a>Constructor 构造方法</h2> 
<p>继承多父类是从左到右的顺序</p> 
<p>参考下面代码中注释， 链接中描述顺序是Y-X-child 是错的</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

// Base contract X
contract X {
    string public name;

    constructor(string memory _name) {
        name = _name;
    }
}

// Base contract Y
contract Y {
    string public text;

    constructor(string memory _text) {
        text = _text;
    }
}

// 有两种方式用参数初始化父合约。

//方法一、 在合约继承的时候填参数
contract B is X("Input to X"), Y("Input to Y") {

}
//方法二、在构造方法中传参
contract C is X, Y {
    
    constructor(string memory _name, string memory _text) X(_name) Y(_text) {}
}

// 父构造函数总是按照继承的顺序调用，而不管子合约的构造函数中列出的父合约的顺序。
// 继承是从左到右的
//下面两个的顺序都是 X,Y,child

contract D is X, Y {
    constructor() X("X was called") Y("Y was called") {}
}

contract E is X, Y {
    constructor() Y("Y was called") X("X was called") {}
}

</code></pre> 
<h2>
<a id="__Inheritance_309"></a>继承 Inheritance</h2> 
<p>以下是例子<br> 继承的顺序是从左到右；</p> 
<p>例：E is C,B (和链接中有<code>override(B, C)</code>有改动)</p> 
<p>先继承C，再继承B； C/B有同名方法，后继承B，所以B会覆盖掉C的方法实现</p> 
<p>虽然方法中有 <code>override(B, C)</code> 但是无效，以合约中is的继承顺序， B在后面返回的结果是B</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

/* Graph of inheritance
    A
   / 
  B   C
 /  /
F  D,E

*/

contract A {
    function foo() public pure virtual returns (string memory) {
        return "A";
    }
}

// Contracts inherit other contracts by using the keyword 'is'.
contract B is A {
    // Override A.foo()
    function foo() public pure virtual override returns (string memory) {
        return "B";
    }
}

contract C is A {
    // Override A.foo()
    function foo() public pure virtual override returns (string memory) {
        return "C";
    }
}

// Contracts can inherit from multiple parent contracts.
// When a function is called that is defined multiple times in
// different contracts, parent contracts are searched from
// right to left, and in depth-first manner.

contract D is B, C {
    // D.foo() returns "C"
    // since C is the right most parent contract with function foo()
    function foo() public pure override(B, C) returns (string memory) {
        return super.foo();
    }
}

contract E is C, B {
    // E.foo() returns "B"
    // since B is the right most parent contract with function foo()
    function foo() public pure override(B, C) returns (string memory) {
        return super.foo();
    }
}

// Inheritance must be ordered from “most base-like” to “most derived”.
// Swapping the order of A and B will throw a compilation error.
contract F is A, B {
    function foo() public pure override(A, B) returns (string memory) {
        return super.foo();
    }
}

</code></pre> 
<h2>
<a id="_386"></a>调用父类合约</h2> 
<p>根据下面的描述以及测试结果<br> B,C中foo/bar的区别是 <strong>bar都是使用super.bar(),而foo都是使用A.bar()</strong></p> 
<p>调用D.foo, 调用了C，再调用了A<br> 调用D.bar,调用了C，然后调用B，最后调用了A，(A只调用了一次)</p> 
<p>两个的区别可以看出，同名方法是后继承覆盖先继承。<br> C中bar调用的super,最终到了B， B再调用superA</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

/* Inheritance tree
   A
 /  
B   C
  /
  D
*/

contract A {
    // This is called an event. You can emit events from your function
    // and they are logged into the transaction log.
    // In our case, this will be useful for tracing function calls.
    event Log(string message);

    function foo() public virtual {
        emit Log("A.foo called");
    }

    function bar() public virtual {
        emit Log("A.bar called");
    }
}

contract B is A {
    function foo() public virtual override {
        emit Log("B.foo called");
        A.foo();
    }

    function bar() public virtual override {
        emit Log("B.bar called");
        super.bar();
    }
}

contract C is A {
    function foo() public virtual override {
        emit Log("C.foo called");
        A.foo();
    }

    function bar() public virtual override {
        emit Log("C.bar called");
        super.bar();
    }
}

contract D is B, C {
    // Try:
    // - Call D.foo and check the transaction logs.
    //   Although D inherits A, B and C, it only called C and then A.
    // - Call D.bar and check the transaction logs
    //   D called C, then B, and finally A.
    //   Although super was called twice (by B and C) it only called A once.

    function foo() public override(B, C) {
        super.foo();
    }

    function bar() public override(B, C) {
        super.bar();
    }
}

</code></pre> 
<h2>
<a id="payable_468"></a>payable</h2> 
<p>声明的函数和地址加了payable才可以接收ether<br> 如果对一个普通地址转ether,需要先用payable(address)转换成 address payable，再进行转ether</p> 
<pre><code>pragma solidity ^0.8.7;

contract Payable {
    // Payable address can receive Ether
    address payable public owner;

    // Payable constructor can receive Ether
    constructor() payable {
        owner = payable(msg.sender);
    }

    // Function to deposit Ether into this contract.
    // Call this function along with some Ether.
    // The balance of this contract will be automatically updated.
    function deposit() public payable {}
}
    
</code></pre> 
<h2>
<a id="_Sending_Ether_transfer_send_call_491"></a>发送以太坊 Sending Ether (transfer, send, call)</h2> 
<h3>
<a id="ether_492"></a>有三种方式给地址转ether</h3> 
<ul>
<li>transfer (2300 gas, 超出会抛异常回退)</li>
<li>send (2300 gas, 返回bool,超出会调用失败)</li>
<li>call (使用所有gas,或者设置gas,返回bool)</li>
</ul> 
<h3>
<a id="_497"></a>合约接收以太坊</h3> 
<p>接收 Ether 的合约必须至少具有以下功能之一</p> 
<ul>
<li>receive() external payable</li>
<li>fallback() external payable</li>
</ul> 
<p>如果msg.data为空，会调用 receive()<br> 否则<br> 会调用fallback()</p> 
<h3>
<a id="_507"></a>应该使用哪个方法</h3> 
<p>如果接收地址是普通的地址，可以使用transfer最简单<br> 如果接收地址是合约，且合约里面有功能的话，需要使用call,否则可能gas不足导致失败</p> 
<p>文中介绍2019.12月后建议使用call和re-entrancy结合使用<br> <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol">OpenZeppelin-ReentrancyGuard</a></p> 
<p>call 除了防止重入，也可以手动设置gas使用量，限制接收地址消耗太多gas</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

contract ReceiveEther {
    /*
    Which function is called, fallback() or receive()?

           send Ether
               |
         msg.data is empty?
              / 
            yes  no
            /     
receive() exists?  fallback()
         /   
        yes   no
        /      
    receive()   fallback()
    */

    event RecInfo(address indexed _from, uint256 _type, uint256 _value, bytes _data);

    // Function to receive Ether. msg.data must be empty
    receive() external payable {
        
        emit RecInfo(msg.sender, 1, msg.value, bytes(""));
    }

    // Fallback function is called when msg.data is not empty
    fallback() external payable {
        emit RecInfo(msg.sender, 2, msg.value,msg.data);
    }

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}

contract SendEther {
    function sendViaTransfer(address payable _to) public payable {
        // This function is no longer recommended for sending Ether.
        _to.transfer(msg.value);
    }

    function sendViaSend(address payable _to) public payable {
        // Send returns a boolean value indicating success or failure.
        // This function is not recommended for sending Ether.
        bool sent = _to.send(msg.value);
        require(sent, "Failed to send Ether");
    }

    function sendViaCall(address payable _to) public payable {
        // Call returns a boolean value indicating success or failure.
        // This is the current recommended method to use.
        // (bool sent, bytes memory data) = _to.call{value: msg.value,gas:66666}("");
        (bool sent, bytes memory data) = _to.call{value: msg.value, gas: 2300}("");
        
        //0.5.x
        //(bool sent, bytes memory data) = _to.call.value(msg.value).gas(2300)("");
        require(sent, "Failed to send Ether");
    }
}

</code></pre> 
<h2>
<a id="fallback_receivefunction_583"></a>fallback 回调函数，receive，function()</h2> 
<p>这是一个不带任何参数且不返回任何内容的函数<br> 主要功能：</p> 
<ul>
<li>需要声明回调函数，合约才可以直接接收ether</li>
<li>调用的data匹配不到合约内方法时触发(参考delegatecall)</li>
</ul> 
<p>需要注意的是，如果使用transfer/send给该合约发送ether,受gas(2300)限制</p> 
<h3>
<a id="060_591"></a>低版本的实现(0.6.0前)</h3> 
<p>实现该方法即可接收</p> 
<pre><code>function() external payable {
}
</code></pre> 
<h3>
<a id="060_598"></a>0.6.0后的版本</h3> 
<p>分了两个动作；</p> 
<ul>
<li>receive() 仅msg.data为空才会执行</li>
<li>fallback() msg.data不为空，或者没有实现receive()方法时执行</li>
</ul> 
<p>如果只实现fallback()方法，就和之前的function()功能一样了</p> 
<pre><code>    /*
    Which function is called, fallback() or receive()?

           send Ether
               |
         msg.data is empty?
              / 
            yes  no
            /     
receive() exists?  fallback()
         /   
        yes   no
        /      
    receive()   fallback()
    */
</code></pre> 
<h2>
<a id="call_624"></a>call</h2> 
<p>call是与其他合约交互的低级功能<br> call会返回bool<br> call合约的时候，如果data没有匹配到合约方法，会调用fillback函数</p> 
<p>以下举例几种使用call调用其他合约的方式<br> (比如有些合约没有开源，但是区块浏览器可以看到交互记录/data,这个时候可以直接使用call data的方式调用合约)</p> 
<pre><code>contract Caller {
    event Response(bool success, bytes data);

    // Let's imagine that contract B does not have the source code for
    // contract A, but we do know the address of A and the function to call.
    function testCallFoo(address payable _addr) public payable {
        // You can send ether and specify a custom gas amount
        (bool success, bytes memory data) = _addr.call{value: msg.value, gas: 5000}(
            abi.encodeWithSignature("foo(string,uint256)", "call foo", 123)
        );

        emit Response(success, data);
    }

    // Calling a function that does not exist triggers the fallback function.
    function testCallDoesNotExist(address _addr) public {
        (bool success, bytes memory data) = _addr.call(
            abi.encodeWithSignature("doesNotExist()")
        );

        emit Response(success, data);
    }

    function getCalldata(uint256 params1)public pure returns (bytes memory){
        bytes4 method = 0xbe221111;
        return abi.encodeWithSelector(method, params1);
    }
}
</code></pre> 
<h2>
<a id="delegatecall_662"></a>delegatecall</h2> 
<p>delegatecall是一个类似于call的低级函数。</p> 
<p>当合约A执行delegatecall到合约时B，B代码被执行<br> 执行后修改的信息是合约A里面的，且调用其他合约时，msg.sender是A，msg.value也是从A扣</p> 
<h2>
<a id="functionselector_668"></a>function-selector</h2> 
<p>调用合约时的data，前4个字节(8位)是指定调用哪个方法名</p> 
<p>transfer(address,uint256) 方法hash的结果是<br> 0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b</p> 
<p>取前面8位就是 a9059cbb， 后面跟随的就是参数</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

contract FunctionSelector {
    /*
    "transfer(address,uint256)"
    0xa9059cbb
    "transferFrom(address,address,uint256)"
    0x23b872dd
    */
    function getSelector(string calldata _func) external pure returns (bytes4) {
        return bytes4(keccak256(bytes(_func)));
    }
}
</code></pre> 
<h2>
<a id="_Calling_Other_Contract_692"></a>调用其他合约 Calling Other Contract</h2> 
<p>调用合约有两种方式</p> 
<ul>
<li>知道接口名，通过 Callee(contractAddress).method("")；调用合约</li>
<li>不知道接口名，知道方法id, 通过区块浏览器记录分析方法名和方法参数，构建交易，使用call调用</li>
</ul> 
<p>另外下面附上参数是结构体的形式调用方式， key/value的方式对应</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

contract Callee {
    uint public x;
    uint public value;

    function setX(uint _x) public returns (uint) {
        x = _x;
        return x;
    }

    function setXandSendEther(uint _x) public payable returns (uint, uint) {
        x = _x;
        value = msg.value;

        return (x, value);
    }
}

contract Caller {
    function setX(Callee _callee, uint _x) public {
        uint x = _callee.setX(_x);
    }

    function setXFromAddress(address _addr, uint _x) public {
        Callee callee = Callee(_addr);
        callee.setX(_x);
    }

    function setXandSendEther(Callee _callee, uint _x) public payable {
        (uint x, uint value) = _callee.setXandSendEther{value: msg.value}(_x);
    }
}




         //结构体调用例子
        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: DAI,
                tokenOut: WBNB,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });

        // The call to `exactInputSingle` executes the swap.
        amountOut = swapRouter.exactInputSingle(params);
    


</code></pre> 
<h2>
<a id="_757"></a>合约中创建合约</h2> 
<p>其他合约可以使用new，或者create2的方式创建<br> 0.8.0开始，create2 也支持使用new关键字加上指定salt来创建</p> 
<p>后面附上new和create2提前计算合约地址的方式</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

contract Car {
    address public owner;
    string public model;
    address public carAddr;

    constructor(address _owner, string memory _model) payable {
        owner = _owner;
        model = _model;
        carAddr = address(this);
    }
}

contract CarFactory {
    Car[] public cars;

    function create(address _owner, string memory _model) public {
        Car car = new Car(_owner, _model);
        cars.push(car);
    }

    function createAndSendEther(address _owner, string memory _model) public payable {
        Car car = (new Car){value: msg.value}(_owner, _model);
        cars.push(car);
    }

    function create2(
        address _owner,
        string memory _model,
        bytes32 _salt
    ) public {
        Car car = (new Car){salt: _salt}(_owner, _model);
        cars.push(car);
    }

    function create2AndSendEther(
        address _owner,
        string memory _model,
        bytes32 _salt
    ) public payable {
        Car car = (new Car){value: msg.value, salt: _salt}(_owner, _model);
        cars.push(car);
    }

    function getCar(uint _index)
        public
        view
        returns (
            address owner,
            string memory model,
            address carAddr,
            uint balance
        )
    {
        Car car = cars[_index];

        return (car.owner(), car.model(), car.carAddr(), address(car).balance);
    }
}

</code></pre> 
<h3>
<a id="_827"></a>合约内提前计算地址</h3> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.5.17;
 contract Car {
    address public owner;
    string public model;
    address public carAddr;

    constructor() public payable {

    }
}
contract CarFactory {
    bytes32 public initCodeHash;
    //使用create2的方式提前计算地址
     function pairFor(uint256 _n) public view returns (address pair) {
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                address(this),
                keccak256(abi.encodePacked(_n)),
                initCodeHash
            ))));
    }
    uint256 public curNum = 0;
    //该方式不知道如何传参数
    function createPair() public  returns (address pair)  {
        bytes memory bytecode = type(Car).creationCode;
        bytes32 salt = keccak256(abi.encodePacked(curNum++));
        assembly {
            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
        }
       
    }
    //使用create的方式提前计算地址
    function addressFrom(address _origin, uint _nonce) public pure returns (address _address) {
        bytes memory data;
        if (_nonce == 0x00) data = abi.encodePacked(byte(0xd6), byte(0x94), _origin, byte(0x80));
        else if (_nonce &lt;= 0x7f) data = abi.encodePacked(byte(0xd6), byte(0x94), _origin, uint8(_nonce));
        else if (_nonce &lt;= 0xff) data = abi.encodePacked(byte(0xd7), byte(0x94), _origin, byte(0x81), uint8(_nonce));
        else if (_nonce &lt;= 0xffff) data = abi.encodePacked(byte(0xd8), byte(0x94), _origin, byte(0x82), uint16(_nonce));
        else if (_nonce &lt;= 0xffffff) data = abi.encodePacked(byte(0xd9), byte(0x94), _origin, byte(0x83), uint24(_nonce));
        else data = abi.encodePacked(byte(0xda), byte(0x94), _origin, byte(0x84), uint32(_nonce));
        bytes32 hash = keccak256(data);
        assembly {
            mstore(0, hash)
            _address := mload(0)
        }
    }
}

</code></pre> 
<h2>
<a id="try_catch_881"></a>try catch</h2> 
<p>try/catch 只允许外部调用以及合约创建时才可以捕获</p> 
<p>下面例子还可以catch revert/require, 和assert的区别<br> 或者统一处理</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

// External contract used for try / catch examples
contract Foo {
    address public owner;

    constructor(address _owner) {
        require(_owner != address(0), "invalid address");
        assert(_owner != 0x0000000000000000000000000000000000000001);
        owner = _owner;
    }

    function myFunc(uint x) public pure returns (string memory) {
        require(x != 0, "require failed");
        return "my func was called";
    }
}

contract Bar {
    event Log(string message);
    event LogBytes(bytes data);

    Foo public foo;

    constructor() {
        // This Foo contract is used for example of try catch with external call
        foo = new Foo(msg.sender);
    }

    // Example of try / catch with external call
    // tryCatchExternalCall(0) =&gt; Log("external call failed")
    // tryCatchExternalCall(1) =&gt; Log("my func was called")
    function tryCatchExternalCall(uint _i) public {
        try foo.myFunc(_i) returns (string memory result) {
            emit Log(result);
        } catch {
            emit Log("external call failed");
        }
    }

    // Example of try / catch with contract creation
    // tryCatchNewContract(0x0000000000000000000000000000000000000000) =&gt; Log("invalid address")
    // tryCatchNewContract(0x0000000000000000000000000000000000000001) =&gt; LogBytes("")
    // tryCatchNewContract(0x0000000000000000000000000000000000000002) =&gt; Log("Foo created")
    function tryCatchNewContract(address _owner) public {
        try new Foo(_owner) returns (Foo foo) {
            // you can use variable foo here
            emit Log("Foo created");//创建成功
        } catch Error(string memory reason) {
            // catch failing revert() and require()
            emit Log(reason);//revert/require中的提示错误
        } catch (bytes memory reason) {
            // catch failing assert()
            emit LogBytes(reason);//assert的错误
        }
    }
}

</code></pre> 
<h2>
<a id="Keccak256_949"></a>Keccak256</h2> 
<p>keccak256 计算输入内容的Keccak-256哈希值<br> 主要场景</p> 
<ul><li>hash后确认唯一性</li></ul> 
<p>下面例子中有说明一个hash冲突的问题</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

contract HashFunction {
    function hash(
        string memory _text,
        uint _num,
        address _addr
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_text, _num, _addr));
    }

    // Example of hash collision
    // Hash collision can occur when you pass more than one dynamic data type
    // to abi.encodePacked. In such case, you should use abi.encode instead.
    function collision(string memory _text, string memory _anotherText)
        public
        pure
        returns (bytes32)
    {
        // encodePacked(AAA, BBB) -&gt; AAABBB
        // encodePacked(AA, ABBB) -&gt; AAABBB
        return keccak256(abi.encodePacked(_text, _anotherText));
    }
}

contract GuessTheMagicWord {
    bytes32 public answer =
        0x60298f78cc0b47170ba79c10aa3851d7648bd96f2f8e46a19dbc777c36fb0c00;

    // Magic word is "Solidity"
    function guess(string memory _word) public view returns (bool) {
        return keccak256(abi.encodePacked(_word)) == answer;
    }
}

</code></pre> 
<h3>
<a id="encodePackedencode_996"></a>encodePacked,encode后的区别</h3> 
<p>(AAA, BBB) 和 (AA, ABBB) 为例<br> encodePacked 的结果都是</p> 
<pre><code>0x414141424242
</code></pre> 
<p>所以keccak256的结果都是一样的</p> 
<p>encode<br> AAA BBB</p> 
<pre><code>0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003414141000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034242420000000000000000000000000000000000000000000000000000000000

展开
0x
0000000000000000000000000000000000000000000000000000000000000040
0000000000000000000000000000000000000000000000000000000000000080
0000000000000000000000000000000000000000000000000000000000000003
4141410000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000003
4242420000000000000000000000000000000000000000000000000000000000


</code></pre> 
<p>AA ABBB</p> 
<pre><code>0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002414100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044142424200000000000000000000000000000000000000000000000000000000

展开
0x
0000000000000000000000000000000000000000000000000000000000000040
0000000000000000000000000000000000000000000000000000000000000080
0000000000000000000000000000000000000000000000000000000000000002
4141000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000004
4142424200000000000000000000000000000000000000000000000000000000
</code></pre> 
<h2>
<a id="_Verifying_Signature_1037"></a>验证签名 Verifying Signature</h2> 
<p>可以在链下签名，链上延签，再执行一定的操作</p> 
<p>签名步骤</p> 
<pre><code>1、所有参数进行hash
msgHash = hash(allparams...)
2、加上前缀再hash
ethPrefix = "x19Ethereum Signed Message:n32";
ethHash = hash(ethPrefix,msgHash);
3、使用私钥签名得到签名结果
signResult = sign(ethHash,prikey)
通过signResult得到r,s,v  传入到合约中
</code></pre> 
<p>注意使用的时候，一般都会在合约里面维护一个nonces,参考UniswapV2ERC20中的permit</p> 
<p>使用场景：</p> 
<ul>
<li>UniswapV2ERC20中的permit，验证签名通过后，进行授权，避免发送两次交易</li>
<li>小狐狸签名后，把交易信息给到中心化后端，后端用于确认用户生成token鉴权</li>
<li>项目方地址签名，合约内验签，验证通过后给调用者发送收益(参考链游提收益)</li>
</ul> 
<p>上面所说的链游提收益，是针对游戏中心化产生的积分，需要实际提到链上时，可参考meli提PCE， 代码没开源，应该也是这种方式</p> 
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

/* Signature Verification

How to Sign and Verify
# Signing
1. Create message to sign
2. Hash the message
3. Sign the hash (off chain, keep your private key secret)

# Verify
1. Recreate hash from the original message
2. Recover signer from signature and hash
3. Compare recovered signer to claimed signer
*/

contract VerifySignature {
    /* 1. Unlock MetaMask account
    ethereum.enable()
    */

    /* 2. Get message hash to sign
    getMessageHash(
        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,
        123,
        "coffee and donuts",
        1
    )

    hash = "0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd"
    */
    function getMessageHash(
        address _to,
        uint _amount,
        string memory _message,
        uint _nonce
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));
    }

    /* 3. Sign message hash
    # using browser
    account = "copy paste account of signer here"
    ethereum.request({ method: "personal_sign", params: [account, hash]}).then(console.log)

    # using web3
    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)

    Signature will be different for different accounts
    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b
    */
    function getEthSignedMessageHash(bytes32 _messageHash)
        public
        pure
        returns (bytes32)
    {
        /*
        Signature is produced by signing a keccak256 hash with the following format:
        "x19Ethereum Signed Messagen" + len(msg) + msg
        */
        return
            keccak256(
                abi.encodePacked("x19Ethereum Signed Message:n32", _messageHash)
            );
    }

    /* 4. Verify signature
    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd
    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C
    amount = 123
    message = "coffee and donuts"
    nonce = 1
    signature =
        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b
    */
    function verify(
        address _signer,
        address _to,
        uint _amount,
        string memory _message,
        uint _nonce,
        bytes memory signature
    ) public pure returns (bool) {
        bytes32 messageHash = getMessageHash(_to, _amount, _message, _nonce);
        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);

        return recoverSigner(ethSignedMessageHash, signature) == _signer;
    }

    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)
        public
        pure
        returns (address)
    {
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);

        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    function splitSignature(bytes memory sig)
        public
        pure
        returns (
            bytes32 r,
            bytes32 s,
            uint8 v
        )
    {
        require(sig.length == 65, "invalid signature length");

        assembly {
            /*
            First 32 bytes stores the length of the signature

            add(sig, 32) = pointer of sig + 32
            effectively, skips first 32 bytes of signature

            mload(p) loads next 32 bytes starting at the memory address p into memory
            */

            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }

        // implicitly return (r, s, v)
    }
}

</code></pre> 
<h2>
<a id="solidity_1204"></a>solidity版本变化</h2> 
<p>参考链接<br> <a href="https://learnblockchain.cn/docs/solidity/060-breaking-changes.html">https://learnblockchain.cn/docs/solidity/060-breaking-changes.html</a></p> 
<h3>
<a id="050_1207"></a>0.5.0</h3> 
<ul>
<li>sha3改用keccak256， keccak256只允许接收一个参数，使用abi.encodePacked等组合params</li>
<li>构造函数由同名空参方法变成constructor</li>
</ul> 
<h3>
<a id="060_1211"></a>0.6.0</h3> 
<ul>
<li>仅标记virtual的接口才可以被覆盖，覆盖时需要使用新关键字override，如果多个基类同方法名时，需要像这样列出 override(Base1, Base2)</li>
<li>不能通过修改length来修改数组长度，需要通过push(),push(value),pop的方式，或者赋值一个完整的数组</li>
<li>使用abstract标识抽象合约，抽象合约不能使用new创建</li>
<li>回调函数由function()拆分为fallback()和receive()</li>
<li>新增try/catch，可对调用失败做一定处理</li>
<li>数组切片，例如: abi.decode(msg.data[4:], (uint, uint)) 是一个对函数调用payload进行解码底层方法</li>
<li>payable(x) 把 address 转换为 address payable</li>
</ul> 
<h3>
<a id="070_1220"></a>0.7.0</h3> 
<ul>
<li>call方式调用方法由x.f.gas(1000).value(1 ether)(arg1,arg2)改成 x.f{gas:1000,value:1 ether}(arg1,arg2)</li>
<li>now 不推荐使用，改用block.timestamp</li>
<li>gwei增加为关键字</li>
<li>字符串支持ASCII字符，Unicode字符串</li>
<li>构造函数不在需要 public修饰符，如需防止创建，可定义成abstract</li>
<li>不允许在同一继承层次结构中具有同名同参数类型的多个事件</li>
<li>using A for B,只在当前合约有效， 以前是会继承的，现在需要使用的地方，都得声明一次</li>
</ul> 
<h3>
<a id="080_1229"></a>0.8.0</h3> 
<ul>
<li>弃用safeMath,默认加了溢出检查，如需不要检查使用 <code>unchecked { ... }</code> , 可以节省丢丢手续费</li>
<li>默认支持ABIEncoderV2，不再需要声明</li>
<li>求幂是右结合的，即表达式<code>a**b**c</code>被解析为<code>a**(b**c)</code>。在 0.8.0 之前，它被解析为<code>(a**b)**c</code>
</li>
<li>assert 不在消耗完 完整的gas,功能和require基本一致，但是try/catch错误里面体现不一样，还有一定作用…</li>
<li>不再允许使用uint(-1),改用type(uint).max</li>
</ul>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>