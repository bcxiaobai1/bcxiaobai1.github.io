<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>山东大学大数据管理与分析知识点总结 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">山东大学大数据管理与分析知识点总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="_0"></a>大数据概述</h1> 
<ul>
<li>大数据(big data)，或称巨量资料，指的是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产</li>
<li>大数据指不用随机分析法（抽样调查）这样的捷径，而采用所有数据进行分析处理</li>
</ul> 
<h4>
<a id="_5"></a>大数据四个本质特征</h4> 
<ul>
<li> <p><strong>大量化（volume），快速化（velocity），多样化（variety），价值化（value）</strong>；四个V</p> </li>
<li> <p><strong>Volume—数量大</strong>：数据每两年就增长一倍（大数据摩尔定律）</p> </li>
<li> <p><strong>Velocity—速度快</strong>：</p> 
  <ul>
<li>从数据的生成到消耗，时间窗口非常小，可用于<strong>生成决策的时间非常少</strong>
</li>
<li>1秒定律（在<strong>秒级</strong>时间范围内给出分析结果）：这一点和传统的数据挖掘技术有本质的不同</li>
</ul> </li>
<li> <p><strong>Variety—多样化</strong>：大数据是由结构化和非结构化数据组成的</p> 
  <ul>
<li> <p>–10%的结构化数据，存储在数据库中</p> <p>–90%的非结构化数据，与人类信息密切相关</p> </li>
<li> <p><strong>非结构化数据类型多样</strong>（邮件、视频、微博、位置信息、链接信息、网页点击）</p> </li>
</ul> </li>
<li> <p><strong>Value—价值</strong>：价值密度低，商业价值高</p> </li>
</ul> 
<h4>
<a id="_24"></a>大数据分析的三个特征</h4> 
<ul>
<li> <p><strong>全样</strong>而非抽样</p> </li>
<li> <p><strong>效率</strong>而非精确</p> </li>
<li> <p><strong>相关</strong>而非因果</p> </li>
</ul> 
<h4>
<a id="vs_31"></a>池塘捕鱼（数据库）vs.大海捕鱼（大数据）</h4> 
<ul>
<li> <p>数据规模（MB vs GB，TB，PB），</p> </li>
<li> <p>数据类型（结构化 vs 非结构化，半结构化，结构化），</p> </li>
<li> <p>模式与数据关系（数据库是先有模式，大数据是先有数据，后有模式，模式随着数据量增长改变），</p> </li>
<li> <p>处理对象（数据本身 vs 数据作为一种资源来辅助解决其他诸多领域的问题），</p> </li>
<li> <p>处理工具，</p> </li>
</ul> 
<h4>
<a id="_45"></a>大数据与云计算</h4> 
<ul>
<li>密切相关、相辅相成的，二者的关键技术是共享的，<strong>海量数据存储技术、海量数据管理技术、MapReduce编程模型</strong> 
  <ul>
<li>利用云计算强大的计算能力，可以更快处理大数据信息</li>
<li>通过大数据的业务需求，推进云计算的实际运用</li>
</ul> </li>
<li>区别：最大区别是应用目标不同，云计算更侧重“计算模式”，大数据更侧重“数据资源”[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-B2u6csa0-1656911923907)(C:Users27562AppDataRoamingTyporatypora-user-imagesimage-20220625174450484.png)]</li>
</ul> 
<h4>
<a id="_52"></a>大数据面临的挑战</h4> 
<ul>
<li> <p>大数据集成：</p> 
  <ul>
<li>散布于不同的数据管理系统；</li>
<li>数据类型转向结构，半结构和非结构融合；</li>
<li>数据质量不一，垃圾信息泛滥；</li>
</ul> </li>
<li> <p>大数据分析：</p> 
  <ul>
<li>数据处理实时性</li>
<li>动态变化环境中索引设计</li>
<li>先验知识缺乏</li>
</ul> </li>
<li> <p>大数据隐私问题：数据更多以数字化的形式存储在电脑中，互联网的发展则使数据更加容易产生和传播。</p> 
  <ul>
<li> <p>隐性的数据暴露，–面临技术和人力（众包）的双重考验</p> </li>
<li> <p>数据公开与隐私保护的矛盾，–隐私保护数据挖掘</p> </li>
<li> <p>数据动态性，–现有隐私保护技术基于静态数据</p> </li>
</ul> </li>
<li> <p>大数据能耗问题：能源价格上涨、数据中心存储规模不断扩大</p> 
  <ul><li>解决方面：采用新型低功耗硬件，引入可再生的新能源</li></ul> </li>
<li> <p>大数据处理与硬件协同：硬件的快速升级换代照成大量不同架构硬件共存的局面</p> 
  <ul>
<li>硬件异构性带来的大数据处理难题</li>
<li>新硬件给大数据处理带来的变革</li>
</ul> </li>
<li> <p>大数据管理易用性问题：</p> 
  <ul>
<li> <p>易用性的挑战突出体现在两个方面：</p> 
    <ul>
<li>分析复杂，结果形式更加的多样化</li>
<li>很多行业都有大数据分析需求</li>
</ul> </li>
<li> <p>达到易用性，关注三个准则：可视化原则，匹配原则，反馈原则</p> </li>
</ul> </li>
<li> <p>性能测试基准：目前尚未有针对大数据管理的测试基准</p> 
  <ul><li> <p>构建大数据测试基准面临的主要挑战：</p> 
    <ul><li> <p>系统复杂度高</p> <p>用户案例的多样性</p> <p>数据规模庞大</p> <p>系统的快速演变</p> <p>重新构建还是复用现有的测试基准</p> </li></ul> </li></ul> </li>
</ul> 
<h4>
<a id="_101"></a>大数据处理基本流程</h4> 
<ul>
<li>数据抽取与集成，数据分析，数据解释</li>
<li>数据抽取与集成： 
  <ul>
<li>数据来源广泛，数据类型繁杂，所以需要从中提取出关系和实体，经过关联和聚合之后采用统一定义的结构来存储这些数据；</li>
<li>集成提取的时候需要进行数据清洗，保证数据质量和可信性。</li>
<li>数据抽取和集成的方式分为四个类型：数据整合，数据联邦，数据传播，混合方法</li>
</ul> </li>
<li>数据分析： 
  <ul>
<li>数据量大，同时意味着数据噪声大，大数据时代算法需要调整</li>
<li>数据分析是大数据处理的核心，但是用户最关注结果的展示</li>
</ul> </li>
<li>数据解释： 
  <ul>
<li>引入可视化技术</li>
<li>让用户在一定程度上了解参与具体的分析过程</li>
</ul> </li>
</ul> 
<h4>
<a id="_115"></a>大数据的快</h4> 
<ul>
<li> <p>大数据为什么强调快？</p> 
  <ul>
<li> <p>数据的价值像商品一样会折旧</p> </li>
<li> <p>数据跟新闻和金融行情一样，具有时效性</p> </li>
<li> <p>时间在分母上，越小，单位价值越大</p> </li>
</ul> </li>
<li> <p>大数据的快体现在两个方面：动态数据来的快，正使用数据处理的快</p> </li>
<li> <p>如何实现快的数据处理：</p> 
  <ul>
<li>考虑目前的架构是不是有潜力改进</li>
<li>采用通用技术思路： 
    <ul>
<li>前端采用流处理，即时处理过滤非重要数据</li>
<li>数据预处理成适合快速分析的格式</li>
<li>增量计算：先新后旧</li>
<li>原始数据和中间数据存储到内存而不是硬盘</li>
<li>降低对于精确度要求</li>
</ul> </li>
</ul> </li>
</ul> 
<h4>
<a id="_136"></a>批处理与流处理</h4> 
<ul>
<li> <p>大数据三种状态：静止数据，正使用数据，动态数据</p> </li>
<li> <p>批处理：数据不动，处理逻辑进来，算完后出去</p> </li>
<li> <p>流处理：处理逻辑不动，动态数据进来，计算完后价值留下，原始数据加入静止数据，或者丢弃</p> 
  <ul><li>源源不断的数据当成流；新数据到来时立刻处理并返回结果。</li></ul> </li>
<li> <p>流处理与批处理的组合：</p> 
  <ul>
<li>流处理作为批处理的前端：</li>
<li>流处理与批处理肩并肩：动态智能+历史智能=全时智能</li>
</ul> </li>
</ul> 
<h4>
<a id="_149"></a>大数据关键技术和工具</h4> 
<ul>
<li> <p>Hadoop</p> </li>
<li> <p>Spark</p> </li>
<li> <p>文件系统：HDFS，GFS，TFS</p> </li>
<li> <p>数据库系统</p> </li>
<li> <p>NoSQL技术：</p> 
  <ul><li>NoSQL数据库应该具有的特点：模式自由，支持简单备份，程序接口简单，最终一致性（支持BASE特性），支持海量数据</li></ul> </li>
<li> <p>索引和 查询技术</p> </li>
<li> <p>数据分析技术：MapReduce计算模型，实时数据处理</p> </li>
</ul> 
<h1>
<a id="Hadoop_164"></a>Hadoop</h1> 
<h4>
<a id="Hadoop_166"></a>Hadoop的作用和功能</h4> 
<ul>
<li><strong>采用分布式存储方式，提高读写速度，扩大存储容量</strong></li>
<li>采用<strong>MapReduce</strong>整合分布式文件系统的数据，<strong>保证分析和处理数据的高效</strong>
</li>
<li>采用<strong>存储冗余数据方式保证数据安全性</strong>
</li>
<li>HDFS的高容错特性，基于Java语言，使得Hadoop<strong>可以部署在低廉的计算机集群</strong>
</li>
<li>开源特性，还有HDFS的数据管理能力，MapReduce的高效率处理任务</li>
</ul> 
<h4>
<a id="Hadoop_174"></a>Hadoop优点</h4> 
<ul>
<li>Hadoop 是<strong>可靠</strong>的：因为它假设计算元素和存储会失败，因此它维护多个工作数据副本，确保能够针对失败的节点重新分布</li>
<li>Hadoop 是<strong>高效</strong>的：因为它以并行的方式工作，通过并行处理加快处理速度。</li>
<li>Hadoop 还是<strong>可伸缩</strong>的，能够处理PB 级数据</li>
<li>Hadoop<strong>成本低</strong>：依赖于廉价服务器：因此它的成本比较低，任何人都可以使用</li>
<li>
<strong>运行在Linux平台</strong>上：Hadoop带有用Java 语言编写的框架，因此运行在Linux 生产平台上是非常理想的</li>
<li>
<strong>支持多种编程语言</strong>：Hadoop 上的应用程序也可以使用其他语言编写，比如C++</li>
</ul> 
<h4>
<a id="RDBMSMapReduce_183"></a>RDBMS与MapReduce比较</h4> 
<ul>
<li>RDBMS适合查询与更新，MR适合批处理</li>
<li>RDBMS适合持续更新数据集，MR适合一次性写入多次读取的应用</li>
<li>RDBMS只能处理结构化数据，MR对于非结构化和半结构化的数据也非常有效</li>
<li>二者融合时一种趋势</li>
</ul> 
<h4>
<a id="Hadoop_190"></a>Hadoop体系结构</h4> 
<ul>
<li>核心元素：HDFS，MapReduce计算框架</li>
<li>HDFS时最底层的，它存储在Hadoop集群中存储节点上的文件，在集群上实现了分布式文件系统</li>
<li>HDFS上一层是MapReduce引擎，在集群上实现了分布式计算和任务处理</li>
<li>HDFS在MapReduce任务处理过程中提供了<strong>文件操作和存储</strong>等支持，MapReduce在HDFS的基础上实现了<strong>任务的分发、跟踪、执行</strong>等工作，并<strong>收集结果</strong>。二者相互作用，完成了Hadoop分布式集群的主要任务</li>
</ul> 
<h4>
<a id="HDFS_197"></a>HDFS体系结构</h4> 
<ul>
<li>hdfs集群由一个NameNode和若干DataNode组成</li>
<li>HDFS可以用文件名去存储和访问文件，实际上文件是被分成不同的数据块，这些数据块就是存储在数据节点上面</li>
<li>
<strong>NameNode</strong>：主服务器，管理文件系统命名空间和客户端对文件的访问操作。目录节点负责Hadoop文件系统里面所有元数据的管理，这样的设计使数据不会脱离目录节点的控制。 
  <ul><li>NameNode内存储的是<strong>命名空间，数据块与文件名的映射表，每个数据块副本的位置信息</strong>
</li></ul> </li>
<li>
<strong>DataNode</strong>：集群中管理存储的数据，文件分成若干数据块，这些数据块存放在一组DataNode上</li>
</ul> 
<h4>
<a id="MR_207"></a>MR体系结构</h4> 
<ul>
<li>MapReduce是一种并行编程模式</li>
<li>MapReduce是一个简单易用的软件框架，实现Hadoop的并行任务处理功能</li>
<li>MapReduce框架是由一个单独运行在主节点上的JobTracker 和运行在每个集群从节点上的TaskTracker共同组成的</li>
<li>主节点负责调度构成一个作业的所有任务，这些任务分布在不同的从节点上；主节点监控它们的执行情况，并且重新执行之前失败的任务。从节点仅负责由主节点指派的任务</li>
<li>当一个Job 被提交时，JobTracker接收到提交作业和配置信息之后，就会将配置信息等分发给从节点，同时调度任务并监控TaskTracker的执行</li>
</ul> 
<h4>
<a id="Hadoop_215"></a>Hadoop与分布式开发</h4> 
<ul><li>将大数据集分解为成百上千个小数据集，每个（或若干个）数据集分别由集群中的一个节点进行处理并生成中间结果，然后这些中间结果又由大量的节点合并，形成最终结果</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eKJUXYAQ-1656911923910)(C:Users27562AppDataRoamingTyporatypora-user-imagesimage-20220625233212479.png)]</p> 
<ul>
<li>MapReduce 编程模型的原理是：利用一个输入的key/value 对集合,来产生一个输出的key/value 对集合。这个过程基于Map 和Reduce这两个用户自定义函数实现。</li>
<li>用户自定义的<strong>map函数接收一个输入的key/value 对，然后产生一个中间key/value 对的集</strong>
</li>
<li><strong>MapReduce（shuffle）把所有具有相同key值的value集合在一起，然后传递给reduce 函数</strong></li>
<li>用户自定义的**reduce 函数接收key和相关的value集合，合并这些value 值，形成一个较小的value 集合。**一般来说，每次reduce 函数调用只产生0 或1 个输出的value值</li>
<li>通常<strong>通过一个迭代器把中间的value 值提供给reduce 函数</strong>，这样就可以处理无法全部放入内存中的大量的value 值集合</li>
</ul> 
<h1>
<a id="HDFS_227"></a>HDFS分布式文件系统</h1> 
<h4>
<a id="HDFS_229"></a>HDFS是基于流数据模式访问和处理超大文件的需求而开发的，它可以运行于廉价商用服务器上</h4> 
<h4>
<a id="HDFS_231"></a>HDFS在设计时的假设和目标</h4> 
<ul><li>透明性<br> 并发控制<br> 文件复制功能<br> 硬件和操作系统的异构性<br> 容错能力<br> 安全性问题</li></ul> 
<h4>
<a id="HDFS_240"></a>HDFS的基本特征</h4> 
<ul>
<li>大规模数据存储能力</li>
<li>高并发访问能力</li>
<li>强大容错能力</li>
<li>顺序式文件访问</li>
<li>简单一致性模型</li>
<li>数据库存储模式</li>
</ul> 
<h4>
<a id="HDFS_249"></a>HDFS的局限性</h4> 
<ul>
<li>不适合低延迟数据访问，HDFS 是为高数据吞吐量应用而优化的，这可能会以高时间延迟为代价。</li>
<li>无法高效存储大量小文件，所能存储的文件总量受限于 NameNode 的内存总容量。过多的小文件存储会大量消耗 NameNode 的存储量。</li>
<li>不支持多用户写入及任意修改文件，写操作总是将数据添加在文件的末尾</li>
</ul> 
<h4>
<a id="_255"></a>块</h4> 
<ul>
<li>HDFS分布式文件系统中的文件也被分成块进行存储，“块”是文件存储处理的逻辑单元</li>
<li>使用抽象的块可以带来很多好处： 
  <ul>
<li>可以存储任意大的文件，而又不会受到网络中任一单个节点磁盘大小的限制</li>
<li>使用抽象块作为操作的单元，可以简化存储系统</li>
<li>块更有利于分布式文件系统中复制容错的实现</li>
</ul> </li>
<li>一个文件被划分成一连串的数据块，除了文件的最后一块以外其它所有的数据块都是固定大小的，为了数据容错性，每一个数据块都会被冗余存储起来</li>
</ul> 
<h4>
<a id="_264"></a>目录节点</h4> 
<ul>
<li>集群里面的主节点，负责管理整个HDFS系统的命名空间和元数据，也是客户端访问HDFS系统的入口</li>
<li>数据节点会定期发送一个<strong>心跳信号</strong>（Heartbeat）和数据块列表给目录节点，心跳信号<strong>使目录节点知道该数据节点还是有效的</strong>，而数据块列表包括了该数据节点上面的所有数据块编号</li>
<li>命名空间，即整个系统的目录结构；命名空间的维护操作包括文件和目录的创建、删除、重命名等，所有对命名空间的改动，不包括文件打开读取写入数据），都会被HDFS记录下来</li>
<li>客户端需要访问目录节点才能知道一个文件的所有数据块都保存在哪些数据节点上</li>
<li>每个数据块默认有3个副本，副本位置信息也保存在目录节点里面</li>
</ul> 
<h4>
<a id="_272"></a>数据节点</h4> 
<ul>
<li>一般就是集群里面的一台机器，负责数据的存储和读取</li>
<li>在写入时，由目录节点分配数据块的保存，然后客户端直接写到对应的数据节点</li>
<li>在读取时，当客户端从目录节点获得数据块的映射关系后，就会直接到对应的数据节点读取数据</li>
<li>数据节点也要根据目录节点的命令创建、删除数据块和进行副本复制</li>
</ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HbXU7yXI-1656911923911)(C:Users27562AppDataRoamingTyporatypora-user-imagesimage-20220626001853944.png)]</p> 
<h4>
<a id="HDFS_281"></a>HDFS可靠性设计</h4> 
<ul>
<li> <p>HDFS的主要目标之一就是在硬件出错的时候保证数据的完整性，它把磁盘错误作为肯定会出现的情况来对待，而不是异常。</p> </li>
<li> <p>常见的数据存储中出现的错误：</p> <p>–目录节点错误</p> <p>–数据节点错误</p> <p>–网络传输异常</p> </li>
</ul> 
<h1>
<a id="HBase_293"></a>HBase</h1> 
<h4>
<a id="HBase_295"></a>HBase的设计目标、</h4> 
<ul>
<li>解决HDFS缺少结构化半结构化数据存储访问能力的缺陷</li>
<li>提供基于列存储的大数据表管理能力</li>
<li>试图提供随时和实时的数据访问能力</li>
<li>具备高可扩展性，高可用性，容错处理能力，负载平衡能力，实时数据查询能力</li>
</ul> 
<h4>
<a id="HBase_302"></a>HBase数据模型</h4> 
<ul><li>表中的数据式通过一个行关键字(row key)，一个列关键字(column family + column name)，一个时间戳(time stamp)进行索引和查询定位的</li></ul> 
<h4>
<a id="Hbase_306"></a>Hbase存储管理结构</h4> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-62byNtiH-1656911923911)(C:Users27562AppDataRoamingTyporatypora-user-imagesimage-20220626233632720.png)]</p> 
<ul><li>table-&gt;region-&gt;-store-&gt;{memstor,storeFile}</li></ul> 
<h4>
<a id="Hbase_312"></a>Hbase数据访问与更新</h4> 
<ul>
<li> <p>需要查询数据时，子表先查memStore。如果没有，则再查磁盘上的StoreFile。</p> </li>
<li> <p>开始数据更新时，先查子表服务器,然后向子表提交数据更新请求。提交的数据并不直接存储到磁盘上的数据文件中，而是添加到一个基于内存的子表数据对象memStore中，当memStore中的数据达到一定大小时，系统将自动将数据写入到文件数据块StoreFile中</p> </li>
<li> <p>元数据子表采用三级索引结构：</p> <p>根子表－&gt;用户表的元数据表－&gt;用户表</p> </li>
</ul> 
<h1>
<a id="Hive_322"></a>Hive数据仓库</h1> 
<h4>
<a id="_324"></a>数据仓库是一个面向主题，集成的，时变的，非易失性的数据集合，用来支持管理决策过程</h4> 
<h4>
<a id="HiveSQL_326"></a>Hive提供一个统一的查询分析层，支撑连接、分组、聚集等类SQL语句，可以看作是用户编程接口</h4> 
<h4>
<a id="Hive_329"></a>Hive的应用案例</h4> 
<ul>
<li>日志分析</li>
<li>数据挖掘</li>
<li>文档索引</li>
<li>商业智能信息处理</li>
<li>即时查询以及数据验证</li>
</ul> 
<h1>
<a id="spark_337"></a>spark</h1> 
<h4>
<a id="MapReduce_339"></a>MapReduce的缺陷</h4> 
<ul>
<li>适合高吞吐量批处理数据，不擅长低延时</li>
<li>迭代计算，数据共享率太低</li>
<li>系统设计没有充分利用内存，难以实现高性能</li>
<li>不表达复杂计算问题，例如图形计算，迭代计算</li>
</ul> 
<h4>
<a id="spark_346"></a>spark集群</h4> 
<ul>
<li>Master node，是整个集群的控制器，负责整个集群的运行，管理work node</li>
<li>Worker node，计算节点，接受主节点命令，进行状态汇报</li>
<li>Executors：每个Worker都有一个Executor，负责Task程序的执行，每个worknode可能有多个worker</li>
</ul> 
<h4>
<a id="spark_352"></a>spark系统</h4> 
<ul>
<li> <p>driver是任务的起点，负责任务调度</p> </li>
<li> <p>Worker管理计算节点worknode，创建并处理并行任务</p> </li>
<li> <p>cache存储中间结果</p> </li>
</ul> 
<h4>
<a id="spark_361"></a>spark程序执行</h4> 
<ul>
<li> <p>Job：包含多个Task的并行计算，由Spark action催生</p> <p>Stage：Job拆分成多组Task，每组任务被称为Stage，也可称为TaskSet</p> <p>Task：基本程序执行单元，在一个executor上执行</p> </li>
<li> <p>每个线程可以执行一个task。同一个Executor进程内，多个task之间可以共享内存资源。</p> </li>
<li> <p>Driver向Cluster Manager申请资源，并构建Application的运行环境，即启动SparkContext</p> </li>
<li> <p>sparkcontext：spark运行的核心模块，对是spark程序进行必要的初始化</p> </li>
<li> <p>Cluster manager：集群当中的资源调度服务选取。Standalone模式下，ClusterManager即为Master。在YARN下，ClusterManager为资源管理器</p> </li>
<li> <p>application-&gt;job-&gt;stage-&gt;task</p> </li>
</ul> 
<h4>
<a id="_380"></a>基于内存计算思想提高计算性能</h4> 
<ul>
<li>弹性分布式数据集RDD，spark通过对于RDD的一系列操作完成计算任务</li>
<li>Spark系统通过世系关系(lineage)来记录一个RDD是如何通过其他一个或者多个父类RDD转变过来的，当这个RDD的数据丢失时，Spark可以通过它父类的RDD重新计算</li>
<li>Spark是一种基于内存的迭代式分布式计算框架，适合于完成多种计算模式的大数据处理任务</li>
</ul> 
<h4>
<a id="RDD_386"></a>RDD的创建</h4> 
<ul>
<li>通过从存储器中读取 
  <ul><li>val rdd=sc.textFile("……“）</li></ul> </li>
<li>其他RDD的数据上的确定性操作来创建（即Transformation） 
  <ul><li>val fiilterRdd=rdd.filter(……)</li></ul> </li>
</ul> 
<h4>
<a id="RDD_393"></a>RDD的操作</h4> 
<ul>
<li> <p>转换transformation：这是一种惰性计算，只是定义了一个新的RDD，并不马上计算新的RDD的值</p> </li>
<li> <p>动作action：立即计算RDD的值，并返回结果给程序，或者把结果写入外存</p> </li>
<li> <p>val filterRDD=file.filter(line=&gt;line.contains(“ERROR”))</p> <p>这个操作对于Spark来说仅仅记录从file这个RDD通过filter操作变换到filterRDD这个RDD的变换，现在并不实际计算filterRDD的结果</p> <p>val result = filterRDD.count()</p> <p>计算最终的result是多少，操作包括前边transformation时的变换</p> </li>
</ul> 
<h4>
<a id="wordcountspark_407"></a>wordcount的spark编程</h4> 
<ul><li> <p>val file = spark.textFile(“hdfs://…”)</p> <p>val counts = file.flatMap(line =&gt; line.split(“ ”)) //分词</p> <p>​ .map(word =&gt; (word, 1)) //对应mapper的工作</p> <p>​ .reduceByKey(_ + _) //相同key的不同value之间进行”+”运算<br> counts.saveAsTextFile(“hdfs://…”)</p> </li></ul> 
<h4>
<a id="KmeansMapReduce_418"></a>K-means的MapReduce实现</h4> 
<ul>
<li>Map阶段：对于接受的每个数据点p，计算p与聚类中心的距离，归类，输出《cluster，（p，1）》</li>
<li>combiner阶段：接受的《cluster，（p，1）》，求出这些点的均值</li>
<li>Reduce阶段：经过Map和Combine后从Map节点输出的所有ClusterID相同的中间结果&lt;ClusterID, [(pm1, n1), (pm2, n3)…]&gt;,计算新的均值pm，输出&lt;ClusterID, pm&gt; 
  <ul><li>输出的（cluster，（pm，n））得到新的聚类中心</li></ul> </li>
</ul> 
<h4>
<a id="KmeansMapReduce_425"></a>K-means的MapReduce不足</h4> 
<ul>
<li>每次迭代操作需要作为独立作业，需要重复初始化和磁盘读写</li>
<li>迭代过程存在大量不变数据，但是每次重新载入处理</li>
<li>上一次迭代终止，才能开始下一次迭代</li>
</ul> 
<h4>
<a id="KmeansSpark_431"></a>K-means的Spark实现</h4> 
<ul>
<li> <p>从HDFS上读取数据转化为RDD，将RDD中的每个数据对象转化为向量形成新的RDD存入缓存，随机抽样K个向量作为全局初始聚类中心</p> </li>
<li> <p>计算RDD中的每个向量p到聚类中心cluster centers的距离，将向量划分给最近的聚类中心，生成以&lt;ClusterID, (p, 1)&gt;为元素的新的RDD</p> </li>
<li> <p>聚合新生成的RDD中Key相同的&lt;ClusterID, (p, 1)&gt;键值对，将相同ClusterID下的所有向量相加并求取向量个数n，生成新的RDD</p> </li>
<li> <p>对生成的RDD中每一个元素&lt;ClusterID, (pm, n)&gt;, 计算ClusterID聚类的新的聚类中心，生成以&lt;ClusterID, pm/n&gt;为元素的新的RDD</p> </li>
<li> <p>判断是否达到最大迭代次数或者迭代是否收敛，不满足条件则重复步骤2到步骤5，满足则结束，输出最后的聚类中心</p> </li>
<li> <p><strong>读取数据和初始化聚类中心</strong></p> <p>val lines = sc.textFile(“data/mllib/kmeans_data.txt” )</p> <p>val data = lines.map(s =&gt;</p> <p>​ s.split(" ").map(_.toDouble)).cache()</p> <p>val kPoints = data.takeSample(false, K, 42)</p> <p>​ .map(s =&gt; spark.util.Vector(s))</p> <p>//takeSample(Boolean, Int, Long)采样函数，false表示不使用替换方法采样，K表示样本数，42表示随机种子</p> <p><strong>划分数据给聚类中心</strong></p> <p>val closest = data.map // 产生&lt;ClusterID, (p, 1)&gt;键值对</p> <p>(p =&gt;</p> <p>( closestPoint(spark.util.Vector§, kPoints), // closestPoint计算最近的聚类中心，</p> <p>// 产生&lt;ClusterID, (spark.util.Vector§, 1)&gt;</p> <p>) )</p> <p><strong>聚合生成新的聚类中心</strong></p> <p>//同一个聚类下所有向量相加并统计向量个数</p> <p>val pointStats = closest.reduceByKey {<!-- --></p> <p>​ case ((x1, y1), (x2, y2)) =&gt; (x1 + x2, y1 + y2) //产生(pm, n)</p> <p>} //将同一clusterID的所有(p, 1)的两个分量分别相加，得到&lt;ClusterID, (pm, n)&gt;</p> <p>//计算生成新的聚类中心</p> <p>val newPoints = pointStats.map {<!-- --></p> <p>​ pair =&gt; (pair._1, pair._2._1 / pair._2._2)}.collectAsMap()</p> <p>//由&lt;ClusterID, (pm, n)&gt;产生(ClusterID, pm/n)。其中，pair._1表示聚类的ClusterID，pair._2._1表示聚类中所有向量之和pm ，pair._2._2表示聚类中所有向量的个数n</p> </li>
</ul> 
<h3>
<a id="PageRank_489"></a>PageRank</h3> 
<h4>
<a id="PR_491"></a>PR思想</h4> 
<ul>
<li> <p>Rank leak ： 没有连接的网页产生排名泄漏</p> <p>解决办法：<br> 1.将无出度的节点递归地从图中去掉，待其他节点计算完毕后再加上<br> 2.对无出度的节点添加一条边，指向那些指向它的顶点</p> </li>
<li> <p>Rank Sink ：整个网页图中若有网页没有入度链接，如节点A所示，其所产生的贡献会被由节点B、C、D构成的强联通分量“吞噬”掉，就会产生排名下沉，节点A的PR值在迭代后会趋向于0</p> </li>
<li>
</li>
</ul> 
<h1>
<a id="_503"></a>数据挖掘</h1> 
<ul><li>数据挖掘的特征之一：海量数据</li></ul> 
<h4>
<a id="kmeans_507"></a>kmeans算法描述</h4> 
<ul><li>选出K个点作为初始的cluster center<br> Loop:<br> 对输入中的每一个点p：<br> ｛<br> 计算p到各个cluster的距离；<br> 将p归入最近的cluster;<br> ｝<br> 重新计算各个cluster的中心<br> 如果不满足停止条件，goto Loop; 否则，停止</li></ul> 
<h4>
<a id="kmeans_519"></a>kmeans的局限性</h4> 
<ul>
<li>初始簇中心的选择影响最终的聚类结果</li>
<li>计算量大</li>
</ul> 
<h4>
<a id="knnmapreduce_524"></a>knn的mapreduce思路</h4> 
<ul>
<li> <p>计算测试样本到各训练样本的距离，取其中距离最小的K个，并根据这K个训练样本的标记进行投票得到测试样本的标记</p> </li>
<li> <p>//Mapper伪代码<br> class Mapper<br> setup(…)<br> {<!-- --><br> 读取全局训练样本数据文件，转入本地内存的数据表TR中<br> }<br> map(key, ts) // ts为一个测试样本<br> { Φ -&gt;MaxS (k)<br> ts -&gt; tsid, A’, y’<br> for i=0 to TR.lenghth()<br> { TR[i] -&gt; trid, A, y<br> S = Sim(A, A’);//计算相似度<br> 若S属于k个最大者， (S, y) -&gt; MaxS;<br> }<br> 根据MaxS和带加权投票表决模型计算出y’ =∑Si*yi/∑Si<br> emit(tsid, y’)<br> }</p> </li>
</ul> 
<h4>
<a id="_546"></a>朴素贝叶斯</h4> 
<ul>
<li>训练数据集Yi频度统计Mapper伪代码<br> class Mapper<br> map(key, tr) // tr为一个训练样本<br> {<!-- --><br> tr -&gt; tr_id, A, y<br> emit(y, 1)<br> for i=0 to A.lenghth()<br> { A[i] -&gt; 属性名xni和属性值xvi<br> emit(&lt;y, xni, xvi&gt;, 1)<br> }<br> }</li>
<li>训练数据集频度统计Reducer伪代码<br> class Reducer<br> reduce(key, value_list) // key 或为分类标记y，或为&lt;y, xni, xvi&gt;<br> {<!-- --><br> sum =0<br> while(value_list.hasNext())<br> sum += value_list.next().get();<br> emit(key, sum)<br> }</li>
<li>测试样本分类预测Mapper伪代码<br> class Mapper<br> setup(…)<br> { 读取从训练数据集得到的频度数据<br> 分类频度表 FY = { (Yi, 每个Yi的频度FYi) }<br> 属性频度表 FxY = { (&lt;Yi, xnj, xvj&gt;, 出现频度FxYij ) }<br> }<br> map(key, ts) // ts为一个测试样本<br> { ts -&gt; ts_id, A<br> MaxF = MIN_VALUE; idx = -1;<br> for (i=0 to FY.length)<br> { FXYi = 1.0；Yi = FY[i].Yi; FYi = FY[i].FYi<br> for (j=0 to A.length)<br> { xnj = A[j].xnj; xvj = A[j].xvj<br> 根据&lt;Yi, xnj, xvj&gt;扫描FxY表, 取得FxYij<br> FXYi = FXYi * FxYij;<br> }<br> if(FXYi* FYi &gt;MaxF) { MaxF = FXYi*FYi; idx = i; }<br> }<br> emit(ts_id, FY[idx].Yi)<br> }</li>
</ul> 
<h1>
<a id="_590"></a>流计算</h1> 
<h4>
<a id="_592"></a>流计算的概念</h4> 
<ul><li> <p>流计算是针对流式数据的实时计算</p> 
  <ul>
<li> <p>流式数据：是指将数据看作数据流的形式来处理。数据流是在时间分布和数量上无限的一系列动态数据集合体；数据记录是数据流的最小组成单元</p> </li>
<li> <p>流数据具有实时持续不断到达，到达次序独立，数据来源众多，格式复杂，数据规模大且不关注存储，注重数据的整体价值而不是个别数据点的特点</p> </li>
<li> <p>流计算应用：</p> <p>处理金融服务如股票交易、银行交易等产生的大量实时数据</p> <p>各种实时Web服务中，广告推荐，个性化推荐</p> </li>
</ul> </li></ul> 
<h4>
<a id="_606"></a>流计算系统需求</h4> 
<ul><li>高性能，海量式，实时性，分布性，易用性，可靠性</li></ul> 
<h4>
<a id="_610"></a>流计算的处理流程</h4> 
<ul>
<li>数据实时采集</li>
<li>数据实时计算</li>
<li>实时查询服务</li>
</ul> 
<h4>
<a id="StormHadoop_616"></a>Storm对于实时计算的意义类似于Hadoop对于批处理的意义</h4> 
<ul>
<li> <p>storm特点：简单编程模型，支持各种语言，容错性，水平扩展，可靠的消息处理，快速，容易部署</p> </li>
<li> <p>Storm对于流Stream的抽象：流是一个不间断的无界的连续Tuple（元组，是元素有序列表）</p> 
  <ul>
<li>stream的源头抽象为spouts</li>
<li>stream的中间状态抽象为Bolts，Bolts可以处理Tuples，同时可以发送新的流给其他Bolts</li>
</ul> </li>
<li> <p>使用storm的公司：淘宝，亚马逊</p> </li>
<li> <p>流计算是针对流式数据的实时计算</p> 
  <ul>
<li> <p>流式数据：是指将数据看作数据流的形式来处理。数据流是在时间分布和数量上无限的一系列动态数据集合体；数据记录是数据流的最小组成单元</p> </li>
<li> <p>流数据具有实时持续不断到达，到达次序独立，数据来源众多，格式复杂，数据规模大且不关注存储，注重数据的整体价值而不是个别数据点的特点</p> </li>
<li> <p>流计算应用：</p> <p>处理金融服务如股票交易、银行交易等产生的大量实时数据</p> <p>各种实时Web服务中，广告推荐，个性化推荐</p> </li>
</ul> </li>
</ul> 
<h4>
<a id="_640"></a>流计算系统需求</h4> 
<ul><li>高性能，海量式，实时性，分布性，易用性，可靠性</li></ul> 
<h4>
<a id="_644"></a>流计算的处理流程</h4> 
<ul>
<li>数据实时采集</li>
<li>数据实时计算</li>
<li>实时查询服务</li>
</ul>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>