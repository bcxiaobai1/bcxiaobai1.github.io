<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>docker容器——介绍、安装、使用、流程解读、制作镜像与图形化工具 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker容器——介绍、安装、使用、流程解读、制作镜像与图形化工具</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>目录</h3>
 <ul>
<li><a href="#_1">准备工作</a></li>
<li><a href="#docker_3">docker简介</a></li>
<li>
<ul><li>
<ul>
<li><a href="#_4">简介</a></li>
<li>
<ul>
<li><a href="#_6">——百度百科</a></li>
<li><a href="#docker_8">——docker中文社区</a></li>
<li><a href="#wikipedia_17">——wikipedia</a></li>
</ul>
    </li>
<li><a href="#_20">与虚拟机的区别</a></li>
</ul>
  </li></ul>
  </li>
<li><a href="#docker_24">docker安装</a></li>
<li><a href="#dockerhello_world_56">docker测试实例hello world</a></li>
<li><a href="#docker_70">docker流程解读</a></li>
<li>
<ul><li>
<ul>
<li><a href="#docker_71">docker引擎</a></li>
<li><a href="#_79">执行流程</a></li>
<li><a href="#image_92">image镜像</a></li>
<li><a href="#container_109">container容器</a></li>
</ul>
  </li></ul>
  </li>
<li><a href="#docker_136">制作自己的docker容器</a></li>
<li>
<ul>
<li><a href="#_137">配置文件介绍</a></li>
<li>
<ul><li>
<ul>
<li><a href="#Dockerfile_138">Dockerfile文件</a></li>
<li><a href="#dockerignore_170">.dockerignore文件</a></li>
<li><a href="#requirementstxt_173">requirements.txt文件</a></li>
</ul>
   </li></ul>
   </li>
<li><a href="#_185">制作过程</a></li>
<li><a href="#image_240">发布image文件</a></li>
</ul>
  </li>
<li><a href="#docker_255">docker图形化工具</a></li>
<li>
<ul><li>
<ul>
<li><a href="#_256">简介</a></li>
<li><a href="#Portainer_260">Portainer安装</a></li>
</ul>
  </li></ul>
  </li>
<li><a href="#_285">补充</a></li>
<li><a href="#_287">参考资料</a></li>
</ul>
</div>
<p></p> 
<h1>
<a id="_1"></a>准备工作</h1> 
<p>首先，需要准备Ubuntu16.04.7环境，笔者是在vmware虚拟机中安装的该环境，附教程：<a href="https://blog.csdn.net/bruuuuuuuuno/article/details/121131478">https://blog.csdn.net/bruuuuuuuuno/article/details/121131478</a></p> 
<h1>
<a id="docker_3"></a>docker简介</h1> 
<h3>
<a id="_4"></a>简介</h3> 
<p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p> 
<h4>
<a id="_6"></a>——百度百科</h4> 
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p> 
<h4>
<a id="docker_8"></a>——docker中文社区</h4> 
<p>链接：<a href="https://www.docker.org.cn/">https://www.docker.org.cn/</a><br> Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、 bare metal、OpenStack 集群和其他的基础应用平台。</p> 
<p>Docker通常用于如下场景：<br> 1、web应用的自动化打包和发布；<br> 2、自动化测试和持续集成、发布；<br> 3、在服务型环境中部署和调整数据库或其他的后台应用；<br> 4、从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</p> 
<h4>
<a id="wikipedia_17"></a>——wikipedia</h4> 
<p>链接：<a href="https://zh.wikipedia.org/wiki/Docker">https://zh.wikipedia.org/wiki/Docker</a><br> Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。另外，Docker也为容器提供更强的业界的隔离兼容。</p> 
<h3>
<a id="_20"></a>与虚拟机的区别</h3> 
<p>Docker容器在Linux本地运行，并与其他容器共享主机的内核。它运行一个离散进程，不占用任何其他可执行文件更多的内存，从而使其更轻巧。（容器不是模拟一个完整的操作系统，而是对进程进行隔离。）</p> 
<p>相比之下，虚拟机（VM）是完整的操作系统，一些系统级别的操作步骤往往无法跳过。通常，VM会产生大量开销，超出了应用程序逻辑所消耗的开销。</p> 
<h1>
<a id="docker_24"></a>docker安装</h1> 
<p>进入ubuntu命令行，输入以下代码，使用官方安装脚本自动安装：</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -fsSL https://get.docker.com <span class="token operator">|</span> <span class="token function">bash</span> -s docker --mirror Aliyun
</code></pre> 
<p>如果报错，可能是不能翻到外网的原因，可以按照以下方法将命令进行修改：</p> 
<pre><code>把https改成git
</code></pre> 
<p>如果还是报错，可以查看官方安装教程进行安装:<a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a></p> 
<p>安装完成后，运行以下命令查看docker相关信息，来验证是否安装成功：</p> 
<pre><code class="prism language-shell">$ docker version
<span class="token comment"># 或者</span>
$ docker info
</code></pre> 
<p>为了避免每次命令都输入sudo，可以设置用户权限(将当前用户添加到docker组里面)，注意执行后须注销重新登录：</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">usermod</span> -a -G docker <span class="token environment constant">$USER</span>
</code></pre> 
<p>安装完成Docker后，默认已经启动了docker服务，如需手动控制docker服务的启停，可执行如下命令：</p> 
<pre><code class="prism language-shell"><span class="token comment"># 启动docker</span>
<span class="token function">sudo</span> <span class="token function">service</span> docker start

<span class="token comment"># 停止docker</span>
<span class="token function">sudo</span> <span class="token function">service</span> docker stop

<span class="token comment"># 重启docker</span>
<span class="token function">sudo</span> <span class="token function">service</span> docker restart
</code></pre> 
<h1>
<a id="dockerhello_world_56"></a>docker测试实例hello world</h1> 
<p>docker安装好后，让我们使用docker来运行第一个简单的实例。<br> 首先，在确保启动docker服务后，在命令行输入以下代码，来获取helloworld实例的镜像：</p> 
<pre><code class="prism language-shell">docker image pull hello-world
</code></pre> 
<p>接着，我们输入以下代码，来使用我们的镜像生成一个运行的容器：</p> 
<pre><code class="prism language-shell">docker container run hello-world
</code></pre> 
<p>（docker container run命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的docker image pull命令并不是必需的步骤。）</p> 
<p>如果运行成功，将会得到如下的输出结果，输出完后，该容器将自动终止：<br> <img src="https://images2.imgbox.com/39/3b/eMvXNuvj_o.png" alt="在这里插入图片描述"></p> 
<h1>
<a id="docker_70"></a>docker流程解读</h1> 
<h3>
<a id="docker_71"></a>docker引擎</h3> 
<p>docker引擎是具有以下主要组件的客户端-服务器应用程序：</p> 
<ul>
<li>docker服务器是一种长期运行的程序，也称为守护进程（ docker daemon）。</li>
<li>REST API通讯层，它可以用来与守护程序进行通信并提供操作接口。</li>
<li>命令行界面（CLI）客户端（执行docker命令）。</li>
</ul> 
<p>docker客户端使用 REST API接口或直接使用CLI命令来控制Docker守护程序或与Docker守护程序进行交互。其他Docker应用程序都使用基础API和CLI。REST API是基于web容器提供服务，因此客户端和服务器的通信是基于HTTP协议的，兼容和扩展性好。守护程序用于创建和管理Docker 对象，例如镜像获取，容器创建等。<br> <img src="https://images2.imgbox.com/2a/ab/FYSsTtgH_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="_79"></a>执行流程</h3> 
<p>Docker使用客户端-服务器架构。Docker 客户端与Docker 守护进程进行对话，该守护进程完成了构建，运行和分发Docker容器的繁重工作。Docker客户端和守护程序可以 在同一系统上运行，也可以将Docker客户端连接到远程Docker守护程序。Docker客户端和守护程序在网络接口上使用REST API进行通信。<br> <img src="https://images2.imgbox.com/b5/de/jzEoFyXJ_o.png" alt="在这里插入图片描述"><br> <strong>Docker守护程序（Docker daemon）</strong><br> Docker守护程序侦听Docker API请求并管理Docker对象，例如图像，容器，网络和卷。守护程序还可以与其他守护程序通信以管理Docker服务。</p> 
<p><strong>Docker客户端（Client）</strong><br> Docker客户端是Docker用户与Docker交互的主要方式。当您使用诸如docker run之类的命令时，客户端会将这些命令发送到Docker daemon，以执行这些命令。Docker客户端可以与多个守护程序通信。</p> 
<p><strong>Docker注册中心（Registry）</strong><br> Docker 注册中心存储Docker镜像。Docker Hub是任何人都可以使用的公共注册中心（远程/中央仓库），并且Docker默认配置为在Docker Hub上查找映像。</p> 
<blockquote> 
 <p>当客户端执行docker pull命令时，客户端通过通讯层将命令发送给守护程序，守护程序首先检测本地的images中是否存在该镜像，如果不存在，就会从配置的远程仓库中拉取镜像到本地。<br> 此时客户端执行docker run命令，守护程序就会创建容器，启动应用。</p> 
</blockquote> 
<h3>
<a id="image_92"></a>image镜像</h3> 
<p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。</p> 
<blockquote> 
 <p>可以把镜像看成生产车间的模具，只有通过这个模具，才能生产出产品；<br> 同时，一个模具可以生产出很多产品；<br> 一个模具生产出来的产品都是一样的。</p> 
</blockquote> 
<p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。Docker 的官方仓库 <a href="https://hub.docker.com/">https://hub.docker.com/</a> 是最重要、最常用的 image 仓库。</p> 
<p>对于电脑中的image文件，可以采用如下命令进行查看和删除：</p> 
<pre><code class="prism language-shell"><span class="token comment"># 列出本机的所有 image 文件。</span>
docker image <span class="token function">ls</span>

<span class="token comment"># 删除 image 文件</span>
docker image <span class="token function">rm</span> <span class="token punctuation">[</span>imageName<span class="token punctuation">]</span>
</code></pre> 
<h3>
<a id="container_109"></a>container容器</h3> 
<p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。关闭容器并不会删除容器文件，只是容器停止运行而已。</p> 
<blockquote> 
 <p>如果镜像是生产车间的模具的话，容器则是生产出来的产品，是我们最终使用的；<br> 一个模具生产出来的产品是一样的；<br> 产品使用后不会被丢弃，还可以再次使用，如果要丢弃需要主动扔掉。</p> 
</blockquote> 
<p>对于电脑中的container文件，可以采用如下命令进行查看、运行和删除：</p> 
<pre><code class="prism language-shell"><span class="token comment"># 列出本机正在运行的容器</span>
docker container <span class="token function">ls</span>

<span class="token comment"># 列出本机所有容器，包括终止运行的容器</span>
docker container <span class="token function">ls</span> --all

<span class="token comment"># 启动已存在的容器</span>
docker start <span class="token punctuation">[</span>containerID<span class="token punctuation">]</span>

<span class="token comment"># 停止指定的容器运行</span>
docker container <span class="token function">kill</span> <span class="token punctuation">[</span>containerID<span class="token punctuation">]</span>

<span class="token comment"># 删除指定的容器文件</span>
docker container <span class="token function">rm</span> <span class="token punctuation">[</span>containerID<span class="token punctuation">]</span>

<span class="token comment"># 也可以使用docker container run命令的--rm参数，在容器终止运行后自动删除容器文件，如：</span>
docker container run --rm -p <span class="token number">8000</span>:3000 -it demo
</code></pre> 
<h1>
<a id="docker_136"></a>制作自己的docker容器</h1> 
<h2>
<a id="_137"></a>配置文件介绍</h2> 
<h4>
<a id="Dockerfile_138"></a>Dockerfile文件</h4> 
<p>Dockerfile是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。Dockerfile的每一行是一个命令——Docker镜像是使用 Docker build 命令构建的。在构建镜像时，Docker创建了所谓的“层(layers)”。每一层都记录了Dockerfile中的命令所导致的更改，以及运行命令后镜像的状态。</p> 
<blockquote> 
 <p>Dockerfile 一般分为四部分：</p> 
 <ul>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时执行指令</li>
</ul> 
 <p>（’#’ 为 Dockerfile 中的注释）</p> 
</blockquote> 
<p>下面是一些常用的Dockerfile指令：</p> 
<table>
<thead><tr>
<th>指令</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>FROM</td>
<td>构造的新镜像是基于哪个镜像，例如：FROM centos:v1</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>维护者信息，例如：MAINTAINER yanglin</td>
</tr>
<tr>
<td>RUN</td>
<td>构建镜像时运行的shell命令，例如：RUN [“yum”, “install”, “http”]、RUN yum install httpd</td>
</tr>
<tr>
<td>CMD</td>
<td>运行容器时执行的shell命令，例如：CMD ["-c","/startup.sh"]、CMD ["/usr/sbin/sshd","-D"]、CMD /usr/sbin/sshd -D</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>指定于外界交互的端口，即容器在运行时监听的端口，EXPOSE 8081 8082</td>
</tr>
<tr>
<td>ENV</td>
<td>设置容器内环境变量，例如：ENV MYSQL_ROOT_PASSWORD 123456</td>
</tr>
<tr>
<td>ADD</td>
<td>拷贝文件或者目录到镜像，如果是URL或者压缩包会自动下载或者自动解压，例如：ADD hom* /mydir/、ADD test relativeDir/</td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝文件或者目录到镜像，用法同ADD，例如：COPY ./startup.sh /startup.sh</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>运行容器时执行的shell命令，例如：ENTRYPOINT ["/bin/bash","-c","/startup.sh"]、ENTRYPOINT /bin/bash -c ‘/startup.sh’</td>
</tr>
<tr>
<td>VOLUME</td>
<td>指定容器挂载点到宿主机自动生成的目录或者其他容器，例如：VOLUME ["/path/to/dir"]</td>
</tr>
<tr>
<td>USER</td>
<td>为RUN,CMD,ENTRYPOINT执行命令指定运行用户，例如：USER www，镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>为RUN,CMD,ENTRYPOINT,COPY和ADD设置工作目录，例如：WORKDIR /data</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>健康检查，HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/</td>
</tr>
<tr>
<td>ARG</td>
<td>在构建镜像时指定一些参数，例如：FROM centos:6、ARG age=100</td>
</tr>
</tbody>
</table>
<p>在网上看到一张图，十分形象地展示了这些指令的作用：<br> <img src="https://images2.imgbox.com/4a/e4/yxY2WpO3_o.png" alt="在这里插入图片描述"></p> 
<h4>
<a id="dockerignore_170"></a>.dockerignore文件</h4> 
<p>.dockerignore文件表示写入该文件的路径要排除，不要打包进入image镜像文件。如果没有路径要排除，这个文件可以不新建。<br> 比如，像node_modules这种很大的文件在构建镜像时便可以排除，因为被继承的镜像中可能已经含有node_modules，所以无需再添加。</p> 
<h4>
<a id="requirementstxt_173"></a>requirements.txt文件</h4> 
<p>用于记录所有python依赖包及其精确的版本号，以便新环境部署。</p> 
<p>而为什么这些内容不直接在Dockerfile文件中构建呢，这就涉及到<strong>Docker镜像构建原理</strong>：</p> 
<blockquote> 
 <p>Docker镜像是使用 Docker build 命令构建的。在构建镜像时，Docker创建了所谓的“层(layers)”。每一层都记录了Dockerfile中的命令所导致的更改，以及运行命令后镜像的状态。</p> 
 <p>Docker在内部缓存这些层，这样在重新构建镜像时只需要重新创建已更改的层。例如，使用了flask的基础镜像，相同容器的所有后续构建都可以重用它，因为它不会改变。但是，因为项目修改，在下次重新构建过程中 app 目录的内容可能会有所不同，因此只会重新构建这一层。</p> 
 <p>需要注意的是，每当重新构建某一层时，Dockerfile 中紧随其后的所有层也都需要重新构建。例如，我们首先复制 requirements.txt 文件，然后再复制应用程序的其余部分。这样之前安装的依赖项只要没有新的依赖关系，即使应用程序中的其他文件发生了更改，也不需要重新构建这一层。这一点在创建 Dockerfiles 时一定要注意。</p> 
 <p>因此，通过将 pip 安装与应用程序其余部分的部署分离，可以优化容器的构建过程。</p> 
</blockquote> 
<h2>
<a id="_185"></a>制作过程</h2> 
<p>本次案例将选取一个基于flask框架的python应用进行制作，较为简单。首先，新建一个文件夹，存放项目代码：<br> <img src="https://images2.imgbox.com/a8/66/sR6EDEv4_o.png" alt="在这里插入图片描述"><br> 然后，在该文件夹下新建一个app.py文件，并输入如下代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  
  <span class="token keyword">return</span> <span class="token triple-quoted-string string">"""
  &lt;h1&gt;Python Flask in Docker!&lt;/h1&gt;
  &lt;p&gt;A sample web-app for running Flask inside Docker.&lt;/p&gt;
  """</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>  
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span>debug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>host<span class="token operator">=</span><span class="token string">"0.0.0.0"</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">8000</span><span class="token punctuation">)</span>
<span class="token comment">##host一定不要用默认的"127.0.0.1"，不然容器启动，即使映射了端口，在浏览器中也仍然是无法访问服务</span>
</code></pre> 
<p>然后新建requirements.txt文件，输入：</p> 
<pre><code>Flask==1.0.2
</code></pre> 
<p>然后新建Dockerfile文件，输入：</p> 
<pre><code>FROM python:3.6
MAINTAINER yjh
COPY ./requirements.txt /requirements.txt
WORKDIR /
RUN pip install -r requirements.txt
COPY . /
EXPOSE 8000
ENTRYPOINT [ "python3" ]
CMD [ "app.py" ]
</code></pre> 
<p>打开命令行，创建Image镜像：</p> 
<pre><code class="prism language-shell">docker build -t flask_demo:0.1 <span class="token builtin class-name">.</span>
<span class="token comment">#-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</span>
</code></pre> 
<p>如果成功的话，输入docker image ls可以查看到：<br> <img src="https://images2.imgbox.com/bf/2e/T37bcw1r_o.png" alt="在这里插入图片描述"></p> 
<p>然后输入以下代码生成容器：</p> 
<pre><code class="prism language-shell">docker container run -p <span class="token number">8000</span>:8000 -it flask_demo:0.1
<span class="token comment">#-p参数：容器的 8000 端口映射到本机的 8000 端口。</span>
<span class="token comment">#-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e6/32/DOdnqVKI_o.png" alt="在这里插入图片描述"><br> 在浏览器中打开下方网址，即可看到成功生成的flask网站：<br> <img src="https://images2.imgbox.com/63/bd/nHvgWCEi_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="image_240"></a>发布image文件</h2> 
<p>Docker官方维护了一个DockerHub的公共仓库，里边包含有很多平时用的较多的镜像。除了从上边下载镜像之外，我们也可以将自己自定义的镜像发布（push）到DockerHub上。<br> 先注册：<a href="https://hub.docker.com/">https://hub.docker.com/</a><br> 然后登陆：</p> 
<pre><code>docker login
</code></pre> 
<p>接着，为本地的 image 标注用户名和版本：</p> 
<pre><code>docker image tag [imageName] [username]/[repository]:[tag]
</code></pre> 
<p>发布 image 文件：</p> 
<pre><code>docker image push [username]/[repository]:[tag]
</code></pre> 
<h1>
<a id="docker_255"></a>docker图形化工具</h1> 
<h3>
<a id="_256"></a>简介</h3> 
<p>docker 图形页面管理工具常用的有三种，DockerUI ，Portainer ，Shipyard 。DockerUI 是 Portainer 的前身，这三个工具通过docker api来获取管理的资源信息。其实，docker 图形页面管理工具也是作为一个容器在电脑中运行，可以理解成别人做了一个镜像，这个镜像的功能是将docker的相关信息可视化，而你只需要根据他做的镜像在你的电脑里生成一个容器来运行，登录到容器指定的页面进行访问即可。平时我们常常对着shell对着这些命令行客户端，审美会很疲劳，如果有漂亮的图形化界面可以直观查看docker资源信息，是非常方便的。</p> 
<p>这三种图形化管理工具中，以Portainer最为受欢迎。同时它们的安装方法也大同小异，故笔者将只叙述Portainer的安装过程。</p> 
<h3>
<a id="Portainer_260"></a>Portainer安装</h3> 
<p>首先，打开命令行，输入以下代码查看Portainer镜像源。</p> 
<pre><code class="prism language-shell">docker search portainer
</code></pre> 
<p><img src="https://images2.imgbox.com/8f/e1/iMrg4Cmc_o.png" alt="在这里插入图片描述"><br> 可以选择自己喜欢的一个镜像进行下载（推荐选择STARS最多的，也可以选择汉化版镜像），输入如下代码：</p> 
<pre><code class="prism language-shell">docker search portainer
</code></pre> 
<p><img src="https://images2.imgbox.com/34/99/hM6tpagq_o.png" alt="在这里插入图片描述"><br> 等待镜像下载完毕后，像之前生成容器一样生成一个该镜像的容器运行（注意，代码末尾根据自己的选择进行修改）：</p> 
<pre><code class="prism language-shell">docker run -d --name portainerUI -p <span class="token number">9000</span>:9000 -v /var/run/docker.sock:/var/run/docker.sock <span class="token number">6053537</span>/portainer-ce
</code></pre> 
<p>它如果输出一串字符串，说明运行成功了：<br> <img src="https://images2.imgbox.com/66/72/4fK1TSpf_o.png" alt="在这里插入图片描述"><br> 这时候，可以打开浏览器，输入 http://172.17.0.2:9000 即可访问图形化页面。<br> <img src="https://images2.imgbox.com/21/ba/qPdlaDae_o.png" alt="在这里插入图片描述"><br> 创建用户后，自动登录进入，点击“开始”：<br> <img src="https://images2.imgbox.com/aa/70/pmH7ZIyw_o.png" alt="在这里插入图片描述"><br> 点击“local”跳到仪表盘：<br> <img src="https://images2.imgbox.com/47/cd/eMvgYhcC_o.png" alt="在这里插入图片描述"><br> 这样，图形化工具便创建完成：<br> <img src="https://images2.imgbox.com/7b/1d/PBr29j3e_o.png" alt="在这里插入图片描述"></p> 
<h1>
<a id="_285"></a>补充</h1> 
<p>（暂无）</p> 
<h1>
<a id="_287"></a>参考资料</h1> 
<p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a><br> <a href="https://blog.csdn.net/rui754220732/article/details/112145374">https://blog.csdn.net/rui754220732/article/details/112145374</a><br> <a href="https://developer.aliyun.com/article/110806">https://developer.aliyun.com/article/110806</a><br> <a href="https://blog.csdn.net/qq_38415505/article/details/83687207">https://blog.csdn.net/qq_38415505/article/details/83687207</a><br> <a href="https://zhuanlan.zhihu.com/p/71251233">https://zhuanlan.zhihu.com/p/71251233</a><br> <a href="https://www.cnblogs.com/frankdeng/p/9686735.html">https://www.cnblogs.com/frankdeng/p/9686735.html</a><br> <a href="https://blog.csdn.net/m0_37617778/article/details/107930536">https://blog.csdn.net/m0_37617778/article/details/107930536</a></p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>