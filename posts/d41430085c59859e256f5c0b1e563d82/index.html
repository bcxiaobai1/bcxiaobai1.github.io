<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Java-多线程解析1 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java-多线程解析1</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h3>一、线程的描述：</h3> 
<blockquote> 
 <p>        1、线程是一个应用程序进程中不同的执行路径比例如：<span style="color:#fe2c24"><strong>一个WEB服务器，能够为多个用户同时提供请求服务</strong></span>；而 -&gt; 进程是操作系统中正在执行的不同的应用程序,比如：我们可以同时打开系统的word和游戏</p> 
 <p>        2、<span style="color:#fe2c24"><strong>多线程随处不在</strong></span>，例如：平常用电脑办公的时候，一边听着歌一边做事，此时电脑的状态就是多线程；向平常玩手机看直播的时候，一边看着直播，一边聊着WX，此时手机的状态就是多线程；提高了用户的体验度以及画面的效应速率，生活中随处可见；</p> 
 <p>        3、三大特性：</p> 
 <p>                3.1、<strong><span style="color:#fe2c24">原子性</span></strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作（Atomic、CAS算法、synchronized、Lock）</p> 
 <p>                3.2、<span style="color:#fe2c24"><strong>可见性</strong></span>：一个主内存的线程如果进行了修改，可以及时被其他线程观察到（synchronized、volatile）</p> 
 <p>                3.3、<span style="color:#fe2c24"><strong>有序性</strong></span>：如果两个线程不能从 happens-before原则 观察出来，那么就不能观察他们的有序性，虚拟机可以随意的对他们进行重排序，导致其观察观察结果杂乱无序（happens-before原则）</p> 
</blockquote> 
<p></p> 
<hr> 
<h3>二、线程的作用：</h3> 
<blockquote> 
 <p> <span style="color:#fe2c24">    <strong>   1、举例说：把一个人花费30天完成的事情 变成10个人化3天就能完成，目的时为了提高程序的效率</strong></span></p> 
 <p><span style="color:#fe2c24">   <strong>     2、为了解决CPU利用率问题，提高CPU利用</strong></span></p> 
 <p>        3、平时开发的时候，点击某一个操作时，通过<span style="color:#fe2c24"><strong>同一个条件</strong></span>访问2个接口，将结果数据展示到页面；</p> 
 <p>                3.1、<span style="color:#fe2c24"><strong>传统的做法</strong></span>：按照顺序<span style="background-color:#ffd900">依次</span>访问2个接口，那么数据最后展示的时间就是2个接口返回结果总和；</p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/96/08/TeFMjmaD_o.png"></p> 
 <p>                3.2、<span style="color:#fe2c24"><strong>异多线程做法</strong></span>：将方法放入异步线程中，线程启动后就去抢CPU执行权，谁先拿到谁先执行，线程<span style="background-color:#ffd900">同时发起请求</span>，数据的执行时间= 其中某个线程返回结果的最长的时间；</p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/91/af/rxI8sjfG_o.png"></p> 
 <p>                3.3、<span style="color:#fe2c24"><strong>同步多线程：</strong></span></p> 
 <p>                        synchronized 是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p> 
</blockquote> 
<hr> 
<p></p> 
<h3>三、线程的生命周期：</h3> 
<p><img alt="" src="https://images2.imgbox.com/4d/9e/fIiKIMYZ_o.png"></p> 
<hr> 
<h3>四、线程的实现方式：</h3> 
<blockquote> 
 <h3>        有三种：<strong><span style="background-color:#ffd900">继承Thread类</span>、<span style="background-color:#ff9900">实现Runnable接口</span></strong><strong>、<span style="background-color:#4da8ee">实现Callable接口（不常用）</span></strong>
</h3> 
</blockquote> 
<hr> 
<h3>1、<span style="background-color:#ffd900">继承Thread方式</span>：</h3> 
<blockquote> 
 <p>        1-1：继承Thread类，重写run方法；</p> 
 <p>        1-2：线程启动后，谁先抢到CPU执行权，谁就先执行</p> 
 <pre><code class="language-java">public class JavaStudyThread extends Thread {

    public JavaStudyThread(String name) {
        super(name);
    }

    //自定义线程对象，继承Thread，重写run()方法
    @Override
    public void run() {
        // 线程执行体
        for (int i = 1; i &lt; 3; i++) {
            System.out.println("公平竞争-&gt;"+Thread.currentThread().getName() + "--" + "主动出击" + i + "次,得到了我");
        }
    }

    public static void main(String[] args) {
        //创建线程实现类对象,调用start()方法启动线程
        new JavaStudyThread("小老婆1").start();
        new JavaStudyThread("小老婆2").start();
        for (int i = 1; i &lt; 6; i++) {
            System.out.println("公平竞争-&gt;"+"大老婆--" + "主动出击" + i + "次,得到了我");
        }
    }
}</code></pre> 
 <p><strong><span style="color:#fe2c24">输出结果：说明谁抢到主动权，谁就可以先拥有我</span></strong></p> 
 <pre><code class="language-cs">公平竞争-&gt;大老婆--主动出击1次,得到了我
公平竞争-&gt;小老婆2--主动出击1次,得到了我
公平竞争-&gt;小老婆1--主动出击1次,得到了我
公平竞争-&gt;大老婆--主动出击2次,得到了我
公平竞争-&gt;小老婆2--主动出击2次,得到了我
公平竞争-&gt;小老婆1--主动出击2次,得到了我
公平竞争-&gt;大老婆--主动出击3次,得到了我
公平竞争-&gt;大老婆--主动出击4次,得到了我
公平竞争-&gt;大老婆--主动出击5次,得到了我</code></pre> 
 <p></p> 
</blockquote> 
<hr> 
<h3>        2、<strong><span style="background-color:#ff9900">实现Runnable接口：</span></strong>
</h3> 
<blockquote> 
 <p>        2-1：实现Runnable接口，重写run方法</p> 
 <p>        2-2：谁先抢到CPU执行权，谁就先执行</p> 
 <pre><code class="language-java">public class JavaStudyThread implements Runnable {

    // 自定义线程对象，实现Runnable接口，重写run()方法
    @Override
    public void run() {
        for (int i = 1; i &lt; 3; i++) {
            System.out.println("公平竞争-&gt;"+Thread.currentThread().getName() + "--" + "主动出击" + i + "次,得到了我");
        }
    }

    public static void main(String[] args) {
        // 创建实现类对象
        JavaStudyThread javaStudyThread = new JavaStudyThread();
        // 创建代理类对象
        Thread thread = new Thread(javaStudyThread,"小老婆1");
        Thread thread2 = new Thread(javaStudyThread,"小老婆2");
        // 调用start()方法启动线程
        thread.start();
        thread2.start();
        for (int i = 1; i &lt; 6; i++) {
            System.out.println("公平竞争-&gt;"+"大老婆--" + "主动出击" + i + "次,得到了我");
        }
    }
}</code></pre> 
 <p><strong><span style="color:#fe2c24">输出结果：说明谁抢到主动权，谁就可以先拥有我</span></strong></p> 
 <pre><code class="language-cs">公平竞争-&gt;大老婆--主动出击1次,得到了我
公平竞争-&gt;小老婆1--主动出击1次,得到了我
公平竞争-&gt;大老婆--主动出击2次,得到了我
公平竞争-&gt;小老婆1--主动出击2次,得到了我
公平竞争-&gt;小老婆2--主动出击1次,得到了我
公平竞争-&gt;小老婆2--主动出击2次,得到了我
公平竞争-&gt;大老婆--主动出击3次,得到了我
公平竞争-&gt;大老婆--主动出击4次,得到了我
公平竞争-&gt;大老婆--主动出击5次,得到了我</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<hr> 
<p>        3、<strong><span style="background-color:#4da8ee">实现Callable接口（不常用）</span></strong></p> 
<blockquote> 
 <p>        3-1：实现Callable接口，定义返回值类型</p> 
 <p>        3-2：重写call()方法，并抛出异常</p> 
 <p>        3-3：谁先抢到CPU执行权，谁就先执行</p> 
</blockquote> 
<pre><code class="language-java">public class JavaStudyThread implements Callable&lt;Boolean&gt; {

    @Override
    public Boolean call() throws Exception {
        for (int i = 0; i &lt; 4; i++) {
            System.out.println("自定义" + Thread.currentThread().getName() + "-&gt;" + i);
        }
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 创建实现类对象
        JavaStudyThread thread = new JavaStudyThread();
        JavaStudyThread thread2 = new JavaStudyThread();

        // 创建执行服务，参数是线程池线程数量
        ExecutorService ser = Executors.newFixedThreadPool(2);
        // 提交执行
        Future&lt;Boolean&gt; res = ser.submit(thread);
        Future&lt;Boolean&gt; res2 = ser.submit(thread2);

        // 获取结果
        boolean r1 = res.get();
        boolean r2 = res2.get();
        // 关闭服务
        ser.shutdownNow();
    }
    /*输出结果：
        自定义pool-1-thread-2-&gt;0
        自定义pool-1-thread-2-&gt;1
        自定义pool-1-thread-2-&gt;2
        自定义pool-1-thread-1-&gt;0
        自定义pool-1-thread-1-&gt;1
        自定义pool-1-thread-2-&gt;3
        自定义pool-1-thread-1-&gt;2
        自定义pool-1-thread-1-&gt;3
    */
}</code></pre> 
<hr> 
<p></p> 
<h3>五、多线程常用的一些控制方法：</h3> 
<blockquote> 
 <p>         <img alt="在这里插入图片描述" src="https://images2.imgbox.com/a1/5a/SrJYJChU_o.png"></p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <h2>
<span style="color:#fe2c24"><strong>sleep方法：</strong></span><strong><span style="color:#fe2c24">同步（</span>synchronized <span style="color:#fe2c24">）</span></strong>
</h2> 
 <p></p> 
 <pre>        设定线程阻塞的时间，先让从“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" title="运行状态">运行状态</a>”进入到“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" title="休眠(阻塞)状态">休眠(阻塞)状态</a>”，等待设定的时间过去，从“<span style="color:#0d0016"><span style="background-color:#4da8ee">(阻塞)状态</span></span>”变成“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" title="就绪状态">就绪状态</a>” 每一个对象都有一个锁，<span style="color:#fe2c24"><strong>sleep不会释放锁</strong></span>。</pre> 
 <pre><code class="language-java">public class JavaStudyThread implements Runnable{
    private int count = 20;
    public void run() {
        while (true) {
            if (count &lt;= 0) {
                System.out.println("已卖完");
                return;
            }
            getCount();
        }
    }
    public synchronized void getCount() {
        if(count==0){
            System.out.println("已卖完");
            return;
        }
        System.out.println(Thread.currentThread().getName() + "--&gt;售出第：" + (21 - count) + "票");
        count--;
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args){
        JavaStudyThread t1 = new JavaStudyThread();
        Thread thread= new Thread(t1);
        Thread thread1= new Thread(t1);
        thread.start();
        thread1.start();
    }
}</code></pre> 
 <hr> 
 <h2><span style="color:#fe2c24"><strong>wait方法：</strong></span></h2> 
 <pre>        设定线程阻塞的时间，先让从“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" title="运行状态">运行状态</a>”进入到“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" title="休眠(阻塞)状态">休眠(阻塞)状态</a>”，<strong><span style="color:#fe2c24">释放同步锁</span></strong>，等待设定的时间过去，从“<strong><span style="color:#0d0016"><span style="background-color:#4da8ee">(阻塞)状态</span></span></strong>”变成“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" title="就绪状态">就绪状态</a>” 每一个对象都有一个锁;
</pre> 
 <pre><code class="language-java">public class JavaStudyThread {
    private static String str = "test";

    public void run() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (str) {
                    while (true) {
                        try {
                            System.out.println(str);
                            str.wait();
                            System.out.println(str);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }).start();
    }

    public static void main(String[] args) {
        new JavaStudyThread().run();
        System.out.println("111111");
    }
}</code></pre> 
 <hr> 
 <h2><span style="color:#fe2c24"><strong>yield方法：</strong></span></h2> 
 <pre>        - 提出申请释放CPU资源，至于能否成功释放取决于JVM决定。
        - 调用yield()方法后，线程仍然处于RUNNABLE状态，线程不会进入阻塞状态。
        - 调用yield()方法后，线程处于RUNNABLE状态，就保留了随时被调用的权利。
        - 第一种：a/b线程释放CPU，a/b线程抢到CPU执行释放，a/b线程抢到了CPU执行权；
        - 第二种：a/b的所有线程执行完才释放CPU，此时a/b线程抢到CPU继续执行；</pre> 
 <pre><code class="language-java">public class JavaStudyThread implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "--得到了我");
        Thread.yield();
        System.out.println(Thread.currentThread().getName() + "--连续--得到了我");
    }

    public static void main(String[] args) {
        //创建实现类对象
        JavaStudyThread javaStudyThread = new JavaStudyThread();
        //创建线程
        Thread thread = new Thread(javaStudyThread, "大老婆");
        Thread thread1 = new Thread(javaStudyThread, "小老婆");
        //启动线程
        thread.start();
        thread1.start();
    }
}</code></pre> 
 <h3><span style="color:#fe2c24">输出结果：</span></h3> 
 <pre>        1.从结果1看，小老婆释放CPU成功后，大老婆就抢到了CPU执行权，接着大老婆也释放CPU成功，小老婆抢到了CPU执行权；
        2.从结果2看，小老婆并没有成功释放CPU,而是连续得到了我;</pre> 
 <pre><code class="language-cs">结果1:
	小老婆--得到了我
	大老婆--得到了我
	小老婆--连续--得到了我
	大老婆--连续--得到了我
	
结果2:
	小老婆--得到了我
	小老婆--连续--得到了我
	大老婆--得到了我
	大老婆--连续--得到了我</code></pre> 
 <hr> 
 <h2><span style="color:#fe2c24"><strong>join方法：</strong></span></h2> 
 <pre>        - 将当前的线程挂起，当前线程阻塞，待其他的线程执行完毕，当前线程才能执行。
        - 可以把join()方法理解为插队，谁插到前面，谁先执行。
        - 如果主线程阻塞，等待 join线程 一口气执行完，主线程才能继续执行。</pre> 
 <pre><code class="language-java">public class JavaStudyThread implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            System.out.println(Thread.currentThread().getName() + "join()线程执行：" + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        //创建实现类对象
        JavaStudyThread javaStudyThread = new JavaStudyThread();
        //创建线程
        Thread thread = new Thread(javaStudyThread, "a");
        //启动线程
        thread.start();

        for (int i = 0; i &lt; 10; i++) {
            System.out.println("主线程执行：" + i);
            if (i == 2) {
                thread.join();//主线程阻塞，等待thread一口气执行完，主线程才能继续执行
            }
        }
    }
}</code></pre> 
 <hr> 
 <h2><span style="color:#fe2c24"><strong>setPriority方法：</strong></span></h2> 
 <pre>        - 改变、获取线程的优先级。
        - Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。
        - 线程的优先级用数据表示，范围1~10。
        - 线程的优先级高只是表示他的权重大，获取CPU执行权的几率大。
        - 先设置线程的优先级，在执行start()方法。
        - 优先级高的线程不一定先执行。</pre> 
 <pre><code class="language-java">public class JavaStudyThread implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "线程优先级：" + Thread.currentThread().getPriority());
    }

    public static void main(String[] args) {
        //创建实现类对象
        JavaStudyThread javaStudyThread = new JavaStudyThread();
        //创建线程
        Thread thread = new Thread(javaStudyThread, "a");
        Thread thread1 = new Thread(javaStudyThread, "b");
        Thread thread2 = new Thread(javaStudyThread, "c");
        Thread thread3 = new Thread(javaStudyThread, "d");

        //先设置线程的优先级
        thread.setPriority(Thread.MIN_PRIORITY);//1
        thread1.setPriority(Thread.NORM_PRIORITY);//5
        thread2.setPriority(Thread.MAX_PRIORITY);//10
        thread3.setPriority(7);
        //启动线程
        thread.start();
        thread1.start();
        thread2.start();
        thread3.start();
    }
    //    执行结果：优先级高的线程不一定先执行
    //        c线程优先级：10
    //        b线程优先级：5
    //        a线程优先级：1
    //        d线程优先级：8

}</code></pre> 
 <hr> 
 <h2><span style="color:#fe2c24"><strong>setDaemon()方法:</strong></span></h2> 
 <pre>        -线程分为用户线程和守护线程。
        -虚拟机必须确保用户线程执行完毕。
        -虚拟机不用等待守护线程执行完毕。（如：后天记录操作日志、监控内存、垃圾回收等线程）。
        -Thread.setDeamon(booean on)方法，true：守护线程；fasle：用户进程。默认是false。
        -用户进行执行完毕，守护进程也就停止执行。</pre> 
 <pre><code class="language-java">public class JavaStudyThread {
    public static void main(String[] args) {
        //创建实现类对象
        DeamonThread deamon = new DeamonThread();
        UserThread user = new UserThread();

        Thread thread2 =new Thread(user);
        thread2.start();

        //创建线程
        Thread thread1 = new Thread(deamon);
        thread1.setDaemon(true);
        thread1.start();

    }
}
//守护进程
class DeamonThread implements Runnable {

    @Override
    public void run() {
        // 验证虚拟机不用等待守护线程执行完毕，只要用户线程执行完毕，程序就结束。
        while (true){
            System.out.println("守护线程");
        }
    }
}
//用户进程
class UserThread implements Runnable{

    @Override
    public void run() {
        for (int i =0 ;i&lt;2;i++) {
            System.out.println("用户线程：" + i);
        }
    }
}</code></pre> 
 <hr> 
 <h2><span style="color:#fe2c24"><strong>isAlive方法：</strong></span></h2> 
 <pre>        -用于检查线程是否处于活动状态。活着是指已开始但尚未终止的线程。调用run方法时，线程将运行特定的时间段，然后停止执行。</pre> 
 <pre><code class="language-java">public class JavaStudyThread implements Runnable {
    @Override
    public void run(){
        System.out.println("sample ");
        try{
            Thread.sleep(25);
        }
        catch (InterruptedException ie){
        }
        System.out.println("only ");
    }
    public static void main(String[] args){
        JavaStudyThread javaStudyThread =new JavaStudyThread();
        Thread my_obj_1 = new Thread(javaStudyThread);
        Thread my_obj_2 = new Thread(javaStudyThread);
        my_obj_1.start();
        System.out.println("第一个对象已创建并启动");
        my_obj_2.start();
        System.out.println("第二个对象已创建并启动");
        System.out.println(my_obj_1.isAlive());
        System.out.println("第一个对象上的isAlive函数已被调用");
        System.out.println(my_obj_2.isAlive());
        System.out.println("第二个对象上的isAlive函数已被调用");
    }
    /*输出结果：
        第一个对象已创建并启动
        sample
        第二个对象已创建并启动
        true
        第一个对象上的isAlive函数已被调用
        true
        第二个对象上的isAlive函数已被调用
        sample
        only
        only
    */
}</code></pre> 
</blockquote> 
<h3>
<span style="color:#0d0016"><strong>六、多线程 并发 和 同步：</strong></span><span style="color:#fe2c24">synchronized 同步锁的使用</span>
</h3> 
<h2><span style="color:#fe2c24"><strong>        1、并发：</strong></span></h2> 
<blockquote> 
 <p><span style="color:#0d0016"><strong>       </strong></span><span style="color:#fe2c24"><strong> 1-1、并发原因</strong></span><span style="color:#0d0016"><strong>：</strong></span>在多线程场景下，如果同一个资源 被多个线程修改，其他线程又读取这个资源，那么就可能存在数据结果不对的问题，也就会导致线程不安全；例如：两人卖20张票；</p> 
 <pre><code class="language-java">public class JavaStudyThread implements Runnable{
    private int count = 20;
    public void run() {
        while (true) {
            if (count &lt;= 0) {
                System.out.println("已卖完");
                return;
            }
            getCount();
        }
    }
    public void getCount() {
        if(count==0){
            System.out.println("已卖完");
            return;
        }
        System.out.println(Thread.currentThread().getName() + "--&gt;售出第：" + (21 - count) + "票");
        count--;
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args){
        JavaStudyThread t1 = new JavaStudyThread();
        Thread thread= new Thread(t1);
        Thread thread1= new Thread(t1);
        thread.start();
        thread1.start();
    }
}
</code></pre> 
 <pre><code class="language-java">Thread-0--&gt;售出第：1票
Thread-1--&gt;售出第：1票
Thread-1--&gt;售出第：3票
Thread-0--&gt;售出第：3票
Thread-0--&gt;售出第：5票
Thread-1--&gt;售出第：5票
Thread-1--&gt;售出第：7票
Thread-0--&gt;售出第：7票
Thread-1--&gt;售出第：9票
Thread-0--&gt;售出第：9票
Thread-0--&gt;售出第：11票
Thread-1--&gt;售出第：11票
Thread-0--&gt;售出第：13票
Thread-1--&gt;售出第：13票
Thread-0--&gt;售出第：15票
Thread-1--&gt;售出第：15票
Thread-1--&gt;售出第：17票
Thread-0--&gt;售出第：17票
Thread-1--&gt;售出第：19票
Thread-0--&gt;售出第：20票
已卖完
已卖完</code></pre> 
 <p><strong><span style="color:#fe2c24">从结果可以看出，</span><span style="color:#0d0016">两个人卖的票存在重复了。票号是唯一，所以这是并发异步带来的问题；</span></strong></p> 
</blockquote> 
<blockquote> 
 <p>        <strong><span style="color:#fe2c24">1-2、<strong>处理方法</strong></span></strong><span style="color:#0d0016"><strong>：增加同步关键字 </strong></span><span style="color:#fe2c24"><strong>synchronized ，让线程排队，</strong></span>操作<strong>共享资源</strong>要有<strong>先后顺序</strong>，一个线程操作完之后，另一个线程才能操作或者读取。</p> 
 <p>            <span style="background-color:#fe2c24">   </span><span style="color:#f3f3f4"><strong><span style="background-color:#fe2c24"> 1-2-1、同步方法：public synchronized void method(int args){执行体…}</span></strong></span></p> 
 <p></p> 
 <ul>
<li>防止线程同步访问<em><strong>共享资源</strong></em>造成冲突。</li>
<li>
<em><strong>变量</strong></em>需要同步，<em><strong>常量</strong></em>不需要同步（常量存放于方法区）。</li>
<li>多个线程访问共享资源的代码（即线程执行体）有可能是同一份代码，也有可能是不同的代码；无论是否执行同一份代码，只要这些线程的代码访问同一份可变的共享资源，这些线程之间就需要同步。</li>
</ul> 
 <pre><code class="language-java">public class JavaStudyThread implements Runnable{
    private int count = 20;
    public void run() {
        while (true) {
            if (count &lt;= 0) {
                System.out.println("已卖完");
                return;
            }
            getCount();
        }
    }
    public synchronized void getCount() {
        if(count==0){
            System.out.println("已卖完");
            return;
        }
        System.out.println(Thread.currentThread().getName() + "--&gt;售出第：" + (21 - count) + "票");
        count--;
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args){
        JavaStudyThread t1 = new JavaStudyThread();
        Thread thread= new Thread(t1);
        Thread thread1= new Thread(t1);
        thread.start();
        thread1.start();
    }
}
</code></pre> 
 <pre><code class="language-cs">Thread-0--&gt;售出第：1票
Thread-0--&gt;售出第：2票
Thread-1--&gt;售出第：3票
Thread-1--&gt;售出第：4票
Thread-1--&gt;售出第：5票
Thread-0--&gt;售出第：6票
Thread-0--&gt;售出第：7票
Thread-0--&gt;售出第：8票
Thread-1--&gt;售出第：9票
Thread-1--&gt;售出第：10票
Thread-1--&gt;售出第：11票
Thread-1--&gt;售出第：12票
Thread-1--&gt;售出第：13票
Thread-1--&gt;售出第：14票
Thread-0--&gt;售出第：15票
Thread-0--&gt;售出第：16票
Thread-0--&gt;售出第：17票
Thread-1--&gt;售出第：18票
Thread-1--&gt;售出第：19票
Thread-1--&gt;售出第：20票
已卖完
已卖完
已卖完

进程已结束,退出代码0
</code></pre> 
 <p><strong><span style="color:#fe2c24">从结果可以看出：</span><span style="color:#0d0016">两个人分别各自卖完了手上的票；</span></strong></p> 
 <hr> 
 <p><span style="color:#f3f3f4"><strong><span style="background-color:#fe2c24">                1-2-1、同步代码块：synchronized (Obj){执行体…}</span></strong></span></p> 
 <p></p> 
 <ul>
<li>Obj称之为<strong>同步监视器</strong>，可以是任何对象，但是推荐使用<strong>共享资源</strong>作为同步监视器。</li>
<li>不同方法中无需指定同步监视器，因为同步方法中的同步监视器就是this，就是这个对象本身，或者是class。</li>
</ul> 
 <pre><code class="language-java">public class JavaStudyThread {
    private static String str = "test";

    public void run() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (str) {
                    while (true) {
                        try {
                            System.out.println(str);
                            str.wait();
                            System.out.println(str);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }).start();
    }

    public static void main(String[] args) {
        new JavaStudyThread().run();
        System.out.println("111111");
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<h3>七、死锁问题： </h3> 
<blockquote> 
 <p>       <span style="color:#fe2c24"><strong> 1、死锁的原因：</strong></span></p> 
 <p>                1-1、多个线程各自占有一个资源的时候，同时等待其他线程占有的资源才能运行。导致这些线程都在等待对方释放资源，都停止了执行。</p> 
 <p>                1-2、某一个同步代码块同时拥有“<strong>两个以上对象的锁</strong>”时,就可能发生“死锁”的问题。</p> 
 <pre><code class="language-java">class Goddess{}//女神
class GirlFriend{}//女朋友
class Person extends Thread {
    public static Goddess  goddess = new Goddess();
    public static GirlFriend girlFriend = new GirlFriend();
    int choose;
    String personName;

    public Person(int choose, String personName) {
        this.choose = choose;
        this.personName = personName;
    }

    @Override
    public void run() {
        try {
            this.kiss();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //同步代码块中 嵌套了 同步代码块，会导致 线程一致阻塞，大家都在等待对方释放锁，也就停止了执行；
    private void kiss() throws InterruptedException {
        if (choose == 0) {
            synchronized (goddess) {//女神
                System.out.println(personName + "--亲到--女神--被女朋友发现了,女朋友分手了,死锁了");
                Thread.sleep(1000);
                synchronized (girlFriend) {//女朋友
                    System.out.println(personName + "--亲到--女朋友--被女神发现了,女神分手了,死锁了");
                }
            }
        } else {
            synchronized (girlFriend) {
                System.out.println(personName + "--亲到--女朋友--被女神发现了,女朋友分手了,死锁了");
                Thread.sleep(1000);
                synchronized (goddess) {
                    System.out.println(personName + "--亲到--女神--被女朋友发现了,女神分手了,死锁了");
                }
            }
        }
    }
}

public class JavaStudyThread {
    public static void main(String[] args) {
        System.out.println("人生赢家第一条,两女共处渡良宵!");
        System.out.println("两女拿不下,不如回家种地瓜");
        Person person = new Person(0, "穷男A");
        Person person1 = new Person(1, "穷男B");
        person.start();
        person1.start();
    }
}</code></pre> 
 <p><span style="color:#fe2c24"><strong>   输出结果： </strong></span><span style="color:#4da8ee"><strong>说明男主来到后发现女神和女朋友是闺蜜，现场被捉，思索了</strong></span></p> 
 <pre><code class="language-java">人生赢家第一条,两女共处渡良宵!
两女拿不下,不如回家种地瓜
穷男B--亲到--女朋友--被女神发现了,女朋友分手了,死锁了
穷男A--亲到--女神--被女朋友发现了,女朋友分手了,死锁了</code></pre> 
 <p></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24"><strong>    2、解决死锁--synchronized同步锁：</strong></span></p> 
 <p>                杜绝<span style="color:#fe2c24"><strong>synchronized</strong></span>相互嵌套，把方法作为同级使用，如下：</p> 
 <pre><code class="language-java">class Goddess{}//女神
class GirlFriend{}//女朋友
class Person extends Thread {
    public static Goddess  goddess = new Goddess();
    public static GirlFriend girlFriend = new GirlFriend();
    int choose;
    String personName;

    public Person(int choose, String personName) {
        this.choose = choose;
        this.personName = personName;
    }

    @Override
    public void run() {
        try {
            this.trueKiss();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //同步代码 移到同级，杜绝相互嵌套，正确的输出结果
    private void trueKiss() throws InterruptedException {
        if (choose == 0) {
            synchronized (girlFriend) {
                System.out.println(personName + "--亲到了--女朋友,--被女神发现了,女神就加入了");
                Thread.sleep(1000);
            }
            synchronized (goddess) {
                System.out.println(personName + "--亲到了--女神,--被女朋友发现了,女朋友就加入了");
            }
        } else {
            synchronized (goddess) {
                System.out.println(personName + "--亲到了--女神,--被女朋友发现了,女朋友就加入了");
                Thread.sleep(1000);
            }
            synchronized (girlFriend) {
                System.out.println(personName + "--亲到了--女朋友,--被女神发现了,女神就加入了");
            }
        }
    }
}

public class JavaStudyThread {
    public static void main(String[] args) {
        System.out.println("人生赢家第一条,两女共处渡良宵!");
        System.out.println("两女拿不下,不如回家种地瓜");
        Person person = new Person(0, "穷男A");
        Person person1 = new Person(1, "穷男B");
        person.start();
        person1.start();
    }
}</code></pre> 
 <p><span style="color:#fe2c24"><strong>    输出结果： </strong></span><span style="color:#4da8ee"><strong>说明男主来到后发现女神和女朋友是闺蜜，分不开各个击破</strong></span></p> 
 <pre><code class="language-java">人生赢家第一条,两女共处渡良宵!
两女拿不下,不如回家种地瓜
穷男A--亲到了--女朋友,--被女神发现了,女神就加入了
穷男B--亲到了--女神,--被女朋友发现了,女朋友就加入了
穷男B--亲到了--女朋友,--被女神发现了,女神就加入了
穷男A--亲到了--女神,--被女朋友发现了,女朋友就加入了</code></pre> 
</blockquote> 
<h3></h3> 
<h3>八、Lock(锁)：同步锁                </h3> 
<blockquote> 
 <p>                同步代码块 / 同步⽅法具有的功能 Lock 都有；<br>                 创建对象 Lock lock = new ReentrantLock() ，<br>                 public void lock() ：加同步锁<br>                 public void unlock() ：释放同步锁</p> 
</blockquote> 
<pre><code class="language-java">public class JavaStudyThread implements Runnable {

    private static int count =10;

    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

    private final Lock lock =new ReentrantLock();

    @Override
    public void run() {
        while (true){
            lock.lock();//加锁
            try {
                if(count&gt;0){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    list.add(count);
                    count--;
                    var aa = list.stream().count();
                    System.out.println(aa);
                }else {
                    break;
                }
            }finally {
                lock.unlock();//解锁
            }
        }
    }

    public static void main(String[] args) {
        JavaStudyThread javaStudyThread=new JavaStudyThread();
        Thread thread=new Thread(javaStudyThread);
        Thread thread2=new Thread(javaStudyThread);
        thread.start();
        thread2.start();
    }

}</code></pre> 
<p> 输出结果：按照顺序依次输出结果</p> 
<pre><code class="language-java">1
2
3
4
5
6
7
8
9
10</code></pre> 
<h3>九、多线程的异步方法：如果存在返回值，则代表有阻塞，那就是同步请求了。无返回值，则代表异步请求，bin</h3> 
<p>        <span style="color:#fe2c24"><strong>1、runAsync() 异步无参返回：</strong></span></p> 
<p><span style="color:#fe2c24"><strong>        2、supplyAsync() 异步有参返回</strong></span></p> 
<p><strong>   <span style="color:#fe2c24">     3、allOf() 多个异步处理(针对有参返回)</span></strong></p> 
<pre><code class="language-java">ublic class JavaStudyThread {

    //runAsync 无参返回   不会阻塞，代表异步
    public void asyncThread() throws Exception {
        CompletableFuture async1 = CompletableFuture.runAsync(() -&gt; {
            try {
                Thread.sleep(100);
                System.out.println(Thread.currentThread().getName());
                System.out.println("none return Async");
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
        // 调用get()将等待异步逻辑处理完成
        async1.get();
    }

    //supplyAsync 有参返回   会阻塞，代表异步
    public void asyncThread2()throws Exception {
        CompletableFuture&lt;String&gt; async2 = CompletableFuture.supplyAsync(() -&gt; {
            return "hello";
        });
        String result = async2.get();
        System.out.println(result);
    }

    //allOf() 多个异步处理(针对有参返回)  会阻塞，代表异步
    public void asyncThread3() throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; async3 = CompletableFuture.supplyAsync(()-&gt;{
            try {
                Thread.sleep(6000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "a";
        });
        CompletableFuture&lt;String&gt; async4 = CompletableFuture.supplyAsync(()-&gt;{
            try {
                Thread.sleep(6000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "b";
        });
        CompletableFuture&lt;String&gt; async5 = CompletableFuture.supplyAsync(()-&gt;{
            try {
                Thread.sleep(6000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "c";
        });

//        CompletableFuture result = CompletableFuture.allOf(async3,async4,async5);
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String timeValue = sdf.format(date);
        System.out.println(timeValue);
        var a = async3.get();
        var b = async4.get();
        var c = async5.get();
        Date date2 = new Date();
        String timeValue2 = sdf.format(date2);
        System.out.println(a+b+c+";"+timeValue2);

//        var aaa = result.get();
//        String bbb = Stream.of(async3,async4,async5).map(CompletableFuture::join).collect(Collectors.joining(" "));
//        System.out.println(bbb);
    }

    public static void main(String[] args) throws Exception {
        JavaStudyThread javaStudyThread = new JavaStudyThread();
        javaStudyThread.asyncThread3();
    }
}</code></pre> 
<p><span style="color:#fe2c24"><strong> 4、complete：</strong></span></p> 
<pre><code class="language-java">CompletableFuture&lt;String&gt; future1 = new CompletableFuture&lt;&gt;();
future.complete("hello world");     //异步线程执行
future.whenComplete((res, throwable) -&gt; {
  System.out.println(res);
});
System.out.println(future1.join());
CompletableFuture&lt;String&gt; future2 = new CompletableFuture&lt;&gt;();
future.completeExceptionally(new Throwable("failed")); //异步线程执行
System.out.println(future2.join());</code></pre> 
<p><span style="color:#fe2c24"><strong>5、thenApply：</strong></span></p> 
<pre><code class="language-java">String original = "Message";
CompletableFuture&lt;String&gt; cf = 
 CompletableFuture.completedFuture(original).thenApply(String::toUpperCase);
System.out.println(cf.join());</code></pre> 
<p><span style="color:#fe2c24"><strong>6、thenCombine：</strong></span></p> 
<pre><code class="language-java">CompletableFuture&lt;String&gt; cf = 
 CompletableFuture.completedFuture("Message").thenApply(String::toUpperCase);
CompletableFuture&lt;String&gt; cf1 = 
 CompletableFuture.completedFuture("Message").thenApply(String::toLowerCase);
CompletableFuture&lt;String&gt; allCf = cf.thenCombine(cf1, (s1, s2) -&gt; s1 + s2);
System.out.println(allCf.join());</code></pre> 
<p><span style="color:#fe2c24"><strong> 7、allOf</strong></span></p> 
<pre><code class="language-java">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; "Message1");
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; "Message2");
CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; "Message3");
CompletableFuture&lt;String&gt; future = 
 CompletableFuture.allOf(future1, future2, future3).thenApply(v -&gt; {
  String join1 = future1.join();
  String join2 = future2.join();
  String join3 = future3.join();
  return join1 + join2 + join3;});
System.out.println(future.join());</code></pre>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>