<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Vue高频面试问题（含答案），面试官直呼好家伙~ - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue高频面试问题（含答案），面试官直呼好家伙~</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>高质量文章都会首发于：CSDN大前端交流社区<a href="https://bbs.csdn.net/forums/WebLSR" title=" https://bbs.csdn.net/forums/WebLSR"> https://bbs.csdn.net/forums/WebLSR</a></p> 
 <p>诚心邀请各位小伙伴加入，快来跟前端人一起交流学习吧，致力营造成资源共享型社区。</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A01%E3%80%81vue%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4-toc" style="margin-left:0px"><a href="#%C2%A01%E3%80%81vue%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4" title=" 1、vue常见指令"> 1、vue常见指令</a></p> 
<p id="2%E3%80%81v-if%20%E5%92%8C%20v-show%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:0px"><a href="#2%E3%80%81v-if%20%E5%92%8C%20v-show%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" title="2、v-if 和 v-show 有什么区别？">2、v-if 和 v-show 有什么区别？</a></p> 
<p id="3.%E7%BB%84%E4%BB%B6%E4%B8%AD%20data%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F-toc" style="margin-left:0px"><a href="#3.%E7%BB%84%E4%BB%B6%E4%B8%AD%20data%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F" title="3.组件中 data 为什么是一个函数？">3.组件中 data 为什么是一个函数？</a></p> 
<p id="4.Vue%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F-toc" style="margin-left:0px"><a href="#4.Vue%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F" title="4.Vue 组件间通信有哪几种方式？">4.Vue 组件间通信有哪几种方式？</a></p> 
<p id="5%E3%80%81computed%20%E5%92%8C%20watch%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F-toc" style="margin-left:0px"><a href="#5%E3%80%81computed%20%E5%92%8C%20watch%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F" title="5、computed 和 watch 的区别和运用的场景？">5、computed 和 watch 的区别和运用的场景？</a></p> 
<p id="6%E3%80%81vue-router%20%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F-toc" style="margin-left:0px"><a href="#6%E3%80%81vue-router%20%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F" title="6、vue-router 路由模式有几种？">6、vue-router 路由模式有几种？</a></p> 
<p id="7%E3%80%81delete%E5%92%8CVue.delete%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px"><a href="#7%E3%80%81delete%E5%92%8CVue.delete%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB" title="7、delete和Vue.delete删除数组的区别">7、delete和Vue.delete删除数组的区别</a></p> 
<p id="8%E3%80%81key%E4%B8%BB%E8%A6%81%E6%98%AF%E8%A7%A3%E5%86%B3%E5%93%AA%E4%B8%80%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E7%B4%A2%E5%BC%95index%EF%BC%88%E9%87%8D%E7%BB%98%EF%BC%89-toc" style="margin-left:0px"><a href="#8%E3%80%81key%E4%B8%BB%E8%A6%81%E6%98%AF%E8%A7%A3%E5%86%B3%E5%93%AA%E4%B8%80%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E7%B4%A2%E5%BC%95index%EF%BC%88%E9%87%8D%E7%BB%98%EF%BC%89" title="8、key主要是解决哪一类的问题，为什么不建议用索引index（重绘）">8、key主要是解决哪一类的问题，为什么不建议用索引index（重绘）</a></p> 
<p id="9%E3%80%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%EF%BC%9F-toc" style="margin-left:0px"><a href="#9%E3%80%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%EF%BC%9F" title="9、如何获取传过来的动态参数？">9、如何获取传过来的动态参数？</a></p> 
<p id="10%E3%80%81vue-%20router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%EF%BC%9F-toc" style="margin-left:0px"><a href="#10%E3%80%81vue-%20router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%EF%BC%9F" title="10、vue- router有哪几种导航钩子？">10、vue- router有哪几种导航钩子？</a></p> 
<p id="11%E3%80%81%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E4%BD%A0%E5%AF%B9Vue.js%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:0px"><a href="#11%E3%80%81%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E4%BD%A0%E5%AF%B9Vue.js%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3" title="11、请详细说明你对Vue.js生命周期的理解">11、请详细说明你对Vue.js生命周期的理解</a></p> 
<p id="12%E3%80%81%E5%9C%A8Vue.cli%E4%B8%AD%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%EF%BC%9F%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F-toc" style="margin-left:0px"><a href="#12%E3%80%81%E5%9C%A8Vue.cli%E4%B8%AD%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%EF%BC%9F%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F" title="12、在Vue.cli中怎样使用自定义组件？在使用过程中你遇到过哪些问题？">12、在Vue.cli中怎样使用自定义组件？在使用过程中你遇到过哪些问题？</a></p> 
<p id="13%E3%80%81%E5%9C%A8vue.js%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%9F-toc" style="margin-left:0px"><a href="#13%E3%80%81%E5%9C%A8vue.js%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%9F" title="13、在vue.js中如何绑定事件？">13、在vue.js中如何绑定事件？</a></p> 
<p id="14%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8v-for%20%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%AE%9E%E7%8E%B0v-model%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%9F-toc" style="margin-left:0px"><a href="#14%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8v-for%20%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%AE%9E%E7%8E%B0v-model%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%9F" title="14、如何在v-for 循环中实现v-model 数据的双向绑定？">14、如何在v-for 循环中实现v-model 数据的双向绑定？</a></p> 
<p id="%E6%9C%80%E5%90%8E%C2%A0-toc" style="margin-left:80px"><a href="#%E6%9C%80%E5%90%8E%C2%A0" title="最后 ">最后 </a></p> 
<hr id="hr-toc">
<h1> <strong><strong><strong>1</strong></strong><strong><strong>、vue常见指令</strong></strong></strong>
</h1> 
<h3 id="v-text" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-text</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-text主要用来更新textContent，可以等同于JS的text属性。</span></span></p> 
<div> 
 <pre><code class="language-html">   &lt;span v-text="msg"&gt;&lt;/span&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">这两者等价：</span></span></p> 
<div> 
 <pre><code class="language-html">&lt;span&gt;插值表达式{<!-- -->{msg}}&lt;/span&gt;</code></pre> 
</div> 
<h3 id="v-html" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-html</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">双大括号的方式会将数据解释为纯文本，而非HTML。为了输出真正的HTML，可以用v-html指令。它等同于JS的innerHtml属性</span></span></p> 
<div> 
 <pre><code class="language-html">    &lt;div v-html="rawHtml"&gt;&lt;/div&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify">   <span style="background-color:#ffffff"><span style="color:#4d4d4d">这个div的内容将会替换成属性值rawHtml，直接作为HTML进行渲染。</span></span></p> 
<h3 id="v-pre" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-pre</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-pre主要用来跳过这个元素和它的子元素编译过程。可以用来显示原始的Mustache标签。跳过大量没有指令的节点加快编译。  </span></span></p> 
<div> 
 <pre><code class="language-html">  &lt;div id="app"&gt;

       &lt;span v-pre&gt;{<!-- -->{message}}&lt;/span&gt;  //这条语句不进行编译

       &lt;span&gt;{<!-- -->{message}}&lt;/span&gt;

&lt;/div&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">最终仅显示第二个span的内容</span></span></p> 
<h3 id="v-cloak" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-cloak</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">这个指令是用来保持在元素上直到关联实例结束时进行编译</span></span></p> 
<div> 
 <pre><code class="language-html">  &lt;div id="app" v-cloak&gt;

    &lt;div&gt;

        {<!-- -->{message}}

    &lt;/div&gt;

&lt;/div&gt;

&lt;script type="text/javascript"&gt;

    new Vue({

      el:'#app',

      data:{

        message:'hello world'

      }

    })

&lt;/script&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">在页面加载时会闪烁（插值闪烁问题），先显示:</span></span></p> 
<div> 
 <pre><code class="language-html">&lt;div&gt;

    {<!-- -->{message}}

&lt;/div&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">然后才会编译为：</span></span></p> 
<div> 
 <pre><code class="language-html">&lt;div&gt;

    hello world!

&lt;/div&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>可以用v-cloak指令解决插值表达式闪烁问题，v-cloak在css中用属性选择器设置为display: none;</strong></span></span></strong></p> 
<h3 id="v-once" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-once</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-once关联的实例，只会渲染一次。之后的重新渲染，实例极其所有的子节点将被视为静态内容跳过，这可以用于优化更新性能。</span></span></p> 
<div> 
 <pre><code class="language-html">&lt;span v-once&gt;This will never change:{<!-- -->{msg}}&lt;/span&gt;  //单个元素

&lt;div v-once&gt;//有子元素

    &lt;h1&gt;comment&lt;/h1&gt;

    &lt;p&gt;{<!-- -->{msg}}&lt;/p&gt;

&lt;/div&gt;

&lt;my-component v-once:comment="msg"&gt;&lt;/my-component&gt;  //组件

&lt;ul&gt;

    &lt;li v-for="i in list"&gt;{<!-- -->{i}}&lt;/li&gt;

&lt;/ul&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">上面的例子中，msg,list即使产生改变，也不会重新渲染。</span></span></p> 
<h3 id="v-if" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-if</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-if可以实现条件渲染，Vue会根据表达式的值的真假条件来渲染元素。</span></span></p> 
<div> 
 <pre><code class="language-html">&lt;a v-if="ok"&gt;yes&lt;/a&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">如果属性值ok为true，则显示。否则，不会渲染这个元素。</span></span></p> 
<h3 id="v-else" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-else</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-else是搭配v-if使用的，它必须紧跟在v-if或者v-else-if后面，否则不起作用。</span></span></p> 
<div> 
 <pre><code class="language-html">&lt;a v-if="ok"&gt;yes&lt;/a&gt;

&lt;a v-else&gt;No&lt;/a&gt;</code></pre> 
</div> 
<h3 id="v-else-if" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-else-if</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-else-if充当v-if的else-if块，可以链式的使用多次。可以更加方便的实现switch语句。</span></span></p> 
<div> 
 <pre><code class="language-html">&lt;div v-if="type==='A'"&gt;

    A

&lt;/div&gt;

&lt;div v-else-if="type==='B'"&gt;

    B

&lt;/div&gt;

&lt;div v-else-if="type==='C'"&gt;

    C

&lt;/div&gt;

&lt;div v-else&gt;

    Not A,B,C

&lt;/div&gt;</code></pre> 
</div> 
<h3 id="v-show" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-show</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<div> 
 <pre><code class="language-html">&lt;h1 v-show="ok"&gt;hello world&lt;/h1&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">也是用于根据条件展示元素。和v-if不同的是，如果v-if的值是false，则这个元素被销毁，不在dom中。但是v-show的元素会始终被渲染并保存在dom中，它只是简单的切换css的dispaly属性。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#ff0000">注意：v-if有更高的切换开销</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#ff0000">v-show有更高的初始渲染开销。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#ff0000">因此，如果要非常频繁的切换，则使用v-show较好；如果在运行时条件不太可能改变，则v-if较好</span></span></p> 
<h3 id="v-for" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-for</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">用v-for指令根据遍历数组来进行渲染</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#ff0000">注意：当v-for和v-if同处于一个节点时，v-for的优先级比v-if更高。这意味着v-if将运行在每个v-for循环中</span></span></p> 
<h3 id="v-bind" style="margin-left:0px;text-align:left"><span style="background-color:#ffffff"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-bind</strong></span></span></strong></span></h3> 
<p style="margin-left:0;text-align:left"><br><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-bind用来</span></span><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>动态的绑定一个或者多个特性</strong></span></span></strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">。没有参数时，可以绑定到一个包含键值对的对象。常用于动态绑定class和style。以及href等。</span></span><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">简写为一个冒号【 </span></span><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>：</strong></span></span></strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">】</span></span></span></p> 
<h3 id="v-model" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-model</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">这个指令用于在表单上创建</span></span><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>双向数据绑定</strong></span></span></strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">。</span></span><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-model会忽略所有表单元素的value、checked、selected特性的初始值。因为它选择Vue实例数据做为具体的值</span></span></p> 
<div> 
 <pre><code class="language-html">&lt;div id="app"&gt;    &lt;input v-model="somebody"&gt;

    &lt;p&gt;hello {<!-- -->{somebody}}&lt;/p&gt;

&lt;/div&gt;

&lt;script&gt;

    var app = new Vue({

        el: '#app',

        data: {

            somebody:'小明'

        }

    })

&lt;/script&gt;</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">这个例子中直接在浏览器input中输入别的名字，下面的p的内容会直接跟着变。这就是双向数据绑定。</span></span></p> 
<h3 id="v-on" style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>v-on</strong></span></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify"><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-on主要用来监听dom事件，以便执行一些代码块。表达式可以是一个方法名。</span></span></p> 
<h1 id="2%E3%80%81v-if%20%E5%92%8C%20v-show%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" style="text-align:left"><strong><strong><strong>2</strong></strong><strong><strong>、v-if 和 v-show 有什么区别？</strong></strong></strong></h1> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">共同点：v-if 和 v-show 都能实现元素的显示隐藏</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">区别：</span></span></strong></p> 
<ol>
<li style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d"> v-show 只是简单的控制元素的 display 属性，而 v-if 才是条件渲染（条件为真，元素将会被渲染，条件为假，元素会被销毁）；</span></span></li>
<li style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-show 有更高的首次渲染开销，而 v-if 的首次渲染开销要小的多；</span></span></li>
<li style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-if 有更高的切换开销，v-show 切换开销小；</span></span></li>
<li style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-if 有配套的 v-else-if 和 v-else，而 v-show 没有</span></span></li>
<li style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">v-if 可以搭配 template 使用，而 v-show 不行</span></span></li>
</ol>
<h1 id="3.%E7%BB%84%E4%BB%B6%E4%B8%AD%20data%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F" style="margin-left:.0001pt;text-align:justify"><strong><strong><strong>3.组件中 data 为什么是一个函数？</strong></strong></strong></h1> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</span></span></p> 
<div> 
 <pre><code class="language-javascript">// data

data() {

  return {

message: "子组件",

childName:this.name

  }

}



// new Vue

new Vue({

  el: '#app',

  router,

  template: '&lt;App/&gt;',

  components: {App}

})</code></pre> 
</div> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#ff0000">因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</span></span></p> 
<h1 id="4.Vue%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F" style="margin-left:.0001pt;text-align:justify">4.<strong><strong><strong>Vue 组件间通信有哪几种方式？</strong></strong></strong>
</h1> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>（1）props / $emit 适用 父子组件通信</strong></span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">（2）ref 与 $parent / $children 适用 父子组件通信</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">$parent / $children：访问父 / 子实例</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">（3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">（4）$attrs/$listeners 适用于 隔代组件通信</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">（5）provide / inject 适用于 隔代组件通信</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">（6）Vuex 适用于 父子、隔代、兄弟组件通信</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</span></span></p> 
<h1 id="5%E3%80%81computed%20%E5%92%8C%20watch%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F" style="text-align:left"><strong><strong><strong>5</strong></strong><strong><strong>、computed 和 watch 的区别和运用的场景？</strong></strong></strong></h1> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>computed： </strong>是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d">运用场景：</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</span></span></p> 
<h1 id="6%E3%80%81vue-router%20%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F" style="margin-left:.0001pt;text-align:justify">
<span style="background-color:#ffffff"><span style="color:#4d4d4d">6</span></span><span style="background-color:#ffffff"><span style="color:#4d4d4d">、vue-router 路由模式有几种？</span></span>
</h1> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">Hash:  使用URL的hash值来作为路由。支持所有浏览器。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">History:  以来HTML5 History API 和服务器配置。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#4d4d4d">Abstract：支持所有javascript运行模式。如果发现没有浏览器的API，</span></span><span style="background-color:#ffffff"><span style="color:#4d4d4d">路由</span></span><span style="background-color:#ffffff"><span style="color:#4d4d4d">会自动强制进入这个模式。</span></span></p> 
<h1 id="7%E3%80%81delete%E5%92%8CVue.delete%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB" style="text-align:left"><strong><strong><strong>7</strong></strong><strong><strong>、delete和Vue.delete删除数组的区别</strong></strong></strong></h1> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。</span></span><br><span style="background-color:#ffffff"><span style="color:#4d4d4d">Vue.delete直接删除了数组 改变了数组的键值。</span></span></span></p> 
<h1 id="8%E3%80%81key%E4%B8%BB%E8%A6%81%E6%98%AF%E8%A7%A3%E5%86%B3%E5%93%AA%E4%B8%80%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E7%B4%A2%E5%BC%95index%EF%BC%88%E9%87%8D%E7%BB%98%EF%BC%89" style="margin-left:0px;text-align:left"><strong><strong><strong>8、key主要是解决哪一类的问题，为什么不建议用索引index（重绘）</strong></strong></strong></h1> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#000000">（1）key的作用主要是为了高效的更新虚拟DOM</span></p> 
<p style="margin-left:.0001pt;text-align:left"><span style="color:#000000">（2）当以index为key值时，如果数组长度发生变化，会导致key的变化，比如删除其中某一项，那么index会相应变化。</span><br><span style="color:#000000">所以用index作为key和不加index没有什么区别，都不能提升性能。一般用每项数据的唯一值来作为key，就算数组长度变化，也不会影响到这个key</span></p> 
<h1 id="9%E3%80%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%EF%BC%9F" style="text-align:left"><strong><strong><strong>9</strong></strong><strong><strong>、如何获取传过来的动态参数？</strong></strong></strong></h1> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">在组件中，使用$router对象的 params.id，即 $route.params.id 。</span></span></span></p> 
<h1 id="10%E3%80%81vue-%20router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%EF%BC%9F" style="text-align:left"><span style="background-color:#ffffff"><strong><span style="background-color:#ffffff"><strong>10、vue- router有哪几种导航钩子？</strong></span></strong></span></h1> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">有3种。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">第一种是全局导航钩子：router.beforeEach(to,from,next)。作用是跳转前进行判断拦截。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">第二种是组件内的钩子。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">第三种是单独路由独享组件。</span></span></span></p> 
<h1 id="11%E3%80%81%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E4%BD%A0%E5%AF%B9Vue.js%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3" style="margin-left:0px;text-align:left"><span style="background-color:#ffffff"><strong><span style="background-color:#ffffff"><span style="color:#000000"><strong>11</strong></span></span></strong><strong><span style="background-color:#ffffff"><span style="color:#000000"><strong>、</strong></span></span></strong><strong><span style="background-color:#ffffff"><span style="color:#000000"><strong>请详细说明你对Vue.js生命周期的理解</strong></span></span></strong></span></h1> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">总共分为8个阶段，分别为 beforeCreate、created、beforeMount、 mounted、beforeUpdate、 updated、 beforeDestroyed、 destroyed。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>beforeCreate：</strong>在实例初始化之后，数据观测者（ data observer）和 event/ watcher事件配置之前调用。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>created：</strong>在实例创建完成后立即调用。在这一步，实例已完成以下的配置：数据观测者，属性和方法的运算， watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>beforeMount：</strong>在挂载开始之前调用，相关的 render函数首次调用。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>mounted: </strong> el被新创建的vm.$el替换，并且在挂载到实例上之后再调用该钩子如果root实例挂载了一个文档内元素，当调用 mounted时vm.sel也在文档内。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>beforeUpdate：</strong>在数据更新时调用，发生在虛拟DOM重新渲染和打补丁之前。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>updated：</strong>由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>beforeDestroy：</strong>在实例销毁之前调用。在这一步，实例仍然完全可用。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>destroyed：</strong>在 Vue. js实例销毀后调用。调用后，Vue. js实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><strong><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">当使用组件的kep- alive功能时，增加以下两个周期。</span></span></span></strong></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">activated在keep- alive组件激活时调用；</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">deactivated在keep-live组件停用时调用。</span></span></span></p> 
<h1 id="12%E3%80%81%E5%9C%A8Vue.cli%E4%B8%AD%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%EF%BC%9F%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F" style="text-align:left"><strong><strong><strong>12、</strong></strong><strong><strong>在Vue.cli中怎样使用自定义组件？在使用过程中你遇到过哪些问题？</strong></strong></strong></h1> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">具体步骤如下。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">（1）在 components目录中新建组件文件，脚本一定要导出暴露的接口。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">（2）导入需要用到的页面（组件）。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">（3）将导入的组件注入uejs的子组件的 components属性中。</span></span></span></p> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">（4）在 template的视图中使用自定义组件。</span></span></span></p> 
<h1 id="13%E3%80%81%E5%9C%A8vue.js%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%9F" style="margin-left:0px;text-align:left"><span style="background-color:#ffffff"><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>13、</strong></span></span></strong><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>在vue.js中如何绑定事件？</strong></span></span></strong></span></h1> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">通过在v-on后跟事件名称=“事件回调函数( )”的语法绑定事件。事件回调函数的参数集合( )可有可无。如果存在参数集合( )，事件回调函数的参数需要主动传递，使用事件对象要传递 $event。当然，此时也可以传递一些其他自定义数据。如果没有参数集合，此时事件回调函数有一个默认参数，就是事件对象。事件回调函数要定义在组件的 methods属性中，作用域是 Vue. js实例化对象，因此在方法中，可以通过this使用 Vue. js中的数据以及方法，也可以通过@语法糖快速绑定事件，如@事件名称=“事件回调函数( )”。</span></span></span></p> 
<h1 id="14%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8v-for%20%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%AE%9E%E7%8E%B0v-model%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%9F" style="text-align:left"><strong><strong><strong>14</strong></strong><strong><span style="background-color:#ffffff"><span style="color:#4d4d4d"><strong>、</strong></span></span></strong><strong><strong>如何在v-for 循环中实现v-model 数据的双向绑定？</strong></strong></strong></h1> 
<p style="margin-left:0;text-align:left"><span style="background-color:#ffffff"><span style="background-color:#ffffff"><span style="color:#4d4d4d">有时候需要循环创建input，并用v- model实现数据的双向绑定。此时可以为v- model绑定数组的一个成员 selected [$ index]，这样就可以给不同的 input绑定不同的v- model，从而分别操作它们。</span></span></span></p> 
<div> 
 <pre><code class="language-html">&lt;div v-for= " ( item, index ) in arr"&gt;

&lt;input type= "text "  v-model="arr [index ] "&gt;

&lt;h1&gt; { { arr [index ] } } &lt;/h1&gt;

&lt;/div&gt;</code></pre> 
</div> 
<h3 id="%E6%9C%80%E5%90%8E%C2%A0">最后 </h3> 
<p>如果对您有帮助，希望能给个?评论/收藏/三连！</p> 
<p>博主为人老实，无偿解答问题哦❤</p> 
<p style="margin-left:.0001pt;text-align:justify"></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>