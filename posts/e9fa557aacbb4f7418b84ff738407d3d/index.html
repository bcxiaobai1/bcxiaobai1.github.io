<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>STL标准模板库 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STL标准模板库</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <h3>软件界一直一种需要可重复利用的东西，C++的泛型编程和面向对象都是为了提高重复率。因此为了建立一种数据结构和算法的统一标准，于是就有了STL。本节接近一万五千字的文章将带你系统走入STL。</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr><td> <h2>目录</h2> </td></tr>
<tr><td>STL的基本概念</td></tr>
<tr><td>STL的基本组件</td></tr>
<tr><td>vector容器</td></tr>
<tr><td>string容器</td></tr>
<tr><td>list容器</td></tr>
<tr><td>stack容器</td></tr>
<tr><td>deque容器</td></tr>
<tr><td>set/multiset容器</td></tr>
<tr><td>queue容器</td></tr>
<tr><td>map/multimap容器</td></tr>
<tr><td>仿函数</td></tr>
<tr><td>谓词</td></tr>
<tr><td>算术仿函数</td></tr>
<tr><td>关系仿函数</td></tr>
<tr><td>逻辑仿函数</td></tr>
<tr><td>遍历算法</td></tr>
<tr><td>查找算法</td></tr>
<tr><td>算术生成算法</td></tr>
<tr><td>排序算法</td></tr>
<tr><td>拷贝和替换算法</td></tr>
</tbody></table>
<p> </p> 
<h1>(一）STL的基本概念</h1> 
<p>1.STL从广义上可以分为<span style="color:#fe2c24">容器，算法，迭代器</span></p> 
<p>2.容器和算法之间通过<span style="color:#ff9900">迭代器进行无缝连接</span></p> 
<p>3.STL几乎所有的<strong>代码都采用了模板类型或者模板函数</strong></p> 
<h1>
<strong>（二）STL六大组件</strong>：</h1> 
<p>1.STL的六大组件包括容器 <strong>算法 迭代器 仿函数</strong>（重载的小括号也就是行为类似函数）<strong> 配置器</strong>（修饰容器或者仿函数或者迭代器接口的东西）<strong> 空间配置器</strong>（负责空间的配置和管理）</p> 
<p>2<span style="color:#fe2c24">.容器</span>：放数据。运用最广泛的数据结构实现。</p> 
<p>容器分为序列式容器和关联式容器。</p> 
<p>序列式容器强调的是值的排序，序列式容器：强调的是值的排序，序列式容器中的每个元素都有固定的位置。</p> 
<p>关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系。</p> 
<p>3.<span style="color:#fe2c24">算法</span>：问题之解法也</p> 
<p>质变算法：运算过程中更改区间中元素的内容，例如拷贝，替换，删除等等</p> 
<p>非质变算法：运算过程中不会更改区间中元素的内容，例如查找，遍历，计数，寻找极值</p> 
<p>4.<span style="color:#fe2c24">迭代器</span>：容器和算法之间的粘合剂</p> 
<p>提供一种方法，使之能够依序寻找某个容器所含的各个元素，而又无需暴露容器的内部联系方式。每个容器都有自己的迭代器。</p> 
<p>迭代器使用非常类似于指针。</p> 
<p>常用的迭代器类型为双向迭代器（读写操作，并且能够向前向后操作）和随机访问迭代器（读写操作，并且可以以任意的方式去访问任意数据，功能最强）</p> 
<h1><strong>（三）vector容器</strong></h1> 
<p>1）vector容器可以理解为<strong>数组，单端数组</strong>。</p> 
<p>但是不同之处在于<strong>数组是静态空间，但是vector是可以动态扩展</strong>。动态扩展并不是在原有的空间之后续空间，而是把<strong>原有的数据拷贝到新空间里面，释放原有的空间</strong>。</p> 
<p>vector容器的<strong>迭代器是支持随机访问的迭代器</strong></p> 
<pre><code class="language-cpp">容器：vector
算法：for_each
迭代器：vector&lt;int&gt;::iterater</code></pre> 
<pre><code class="language-cpp">void myprint(int val)
{
  cout&lt;&lt;val&lt;&lt;endl;
}</code></pre> 
<pre><code class="language-cpp">#include&lt;vector&gt;
#include&lt;algorithm&gt;//标准算法的头文件

void test01()
{
  //创建了一个vector容器，认为它是一个数组
   vector&lt;int&gt;v;

  //向容器中插入数据
  v.push_back(10);
  
  //通过迭代器访问容器中的数据
   vector&lt;int&gt;::iterator itBegin=v.bagin();//起始迭代器 指向容器中的第一个元素
   vector&lt;int&gt;::iterator itEND=v.end();//结束迭代器 指向容器中的最后一个元素的下一个位置

  //第一种遍历方式：
   while(itBegin!=itEnd)
   {
     cout&lt;&lt;*itBegin&lt;&lt;endl;
     itBegin++;
   }
 //第二种遍历：
  for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end;it++)
{
   cout&lt;&lt;*it&lt;&lt;endl;//&lt;&gt;里面是什么数据类型，*it解出来的也是相同的数据类型
}
//第三种遍历
 for_each(v.begin(),v.end(),myPrint);
}
 </code></pre> 
<pre><code class="language-cpp">自定义数据类型通过容器访问内部成员
(*it).m_name;
it-&gt;m_name;</code></pre> 
<p> 2）vector容器中嵌套一个容器（二维数组）</p> 
<pre><code class="language-cpp">void test01()
{
  vector&lt;vector&lt;int&gt;&gt;v;

  //创建小容器
  vector&lt;int&gt;v1;
  vector&lt;int&gt;v2;
  vector&lt;int&gt;v3;
  vector&lt;int&gt;v4;
  
 //向小容器添加数据
for(int i=0;i&lt;4;i++)
  {
    v1.push_back(i=1);
    v2.push_back(i=2);
    v3.push_back(i=3);
    v4.push_back(i=4);
 }

 //将小容器插到大容器中去
  v.push_back(v1);
    v.push_back(v2);
        v.push_back(v3);
   v.push_back(v4);
 //通过大容器把所有数据遍历一遍
   for(vector&lt;vector&lt;int&gt;&gt;::iterator it=v.begin();it!=v.end();it++)
   {
     //(*it)--容器vector&lt;int&gt;
     for(vector&lt;int&gt;::iterator vit=(*it).begin();vit!=(*it).end;vit++)
      {
         cout&lt;&lt;*vit&lt;&lt;endl;
      }
   }
}</code></pre> 
<p> 3）vector函数的默认构造</p> 
<pre><code class="language-cpp">vector&lt;T&gt; v;//利用模板实现类实现，默认构造函数
vector&lt;v.bagin(),v.end()&gt;//利用v[bagin(),end()]区间的元素拷贝到自身
vector&lt;n,elem&gt;;//构造函数把n个elem拷贝给自身
vector&lt;const vector &amp;vec);//拷贝构造函数</code></pre> 
<p>4）vector的赋值操作</p> 
<pre><code class="language-cpp">vector &lt;int&gt;v2;
v2=v1;//

vector &lt;int&gt;v3;
v3.assign(v1.begin(),v1.end());//

vector &lt;int&gt;v4;
v4.assign(10,100);//n个elem方式赋值
</code></pre> 
<p>5）vector的插入和删除</p> 
<pre><code class="language-cpp">v1.push_back(1);//在尾部插入一个1

v1.pop_back();//尾删

v1.insert(v1.begin(),100);//在头部插入100 第一个参数是迭代器

v1.insert(v1.begin(),2,1000);//在头部插入2个1000

v1.erase(v1.begin());//头删的参数也是迭代器

v1.erase(v1.begin,v2.end);//清空 只剩换行

v1.clear;//同清空
</code></pre> 
<p>6）vector的数据存取</p> 
<pre><code class="language-cpp">v[i];//利用[]来访问

v.at(i);//利用at来访问

v1.front;//获取第一个位置上的元素

v1.end;//获取最后一个位置的元素</code></pre> 
<p>7）vector容器的互换器</p> 
<pre><code class="language-cpp">v1.swap(v2);
//用swap可以收缩空间大小
vector&lt;int&gt;(v).swap(v);//匿名对象.容器交换</code></pre> 
<p>8）vector预留空间</p> 
<p><strong>减少vector在动态扩展容量时的扩展次数</strong></p> 
<p>reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问</p> 
<p>9）vector容器的容量和大小</p> 
<pre><code class="language-cpp">empty();//判断容器是否为空
capacity();//容器的容量
size();//返回容器的元素个数
resize(int num);//重新指定容器的长度为num,如果容器变长，则以默认值填充新位置
                //如果容器变短，则末尾超出容器长度的元素被删除
resize(int num,elem);//同上只不过靠elem填充新位置
</code></pre> 
<h1><strong>（四）string容器：本质上是一个类</strong></h1> 
<p>1.string和char*的区别：char*是一个指针.string是一个类，类内封装了char* ，管理这个字符串，是一个char*类型的容器。</p> 
<p>2.特点：封装了很多成员方法：find copy replace insert</p> 
<p>3.string的构造方式：</p> 
<pre><code class="language-cpp">string s1;//默认构造
const char*str="hello world";
string s2(str);//使用字符串初始化
string(const string&amp; str);//使用一个string对象初始另一个string对象
  string s3(s2);
string(int n,char c);//使用n个字符初始化</code></pre> 
<p>4.string的赋值操作：</p> 
<pre><code class="language-cpp">void test()
{
  string str1;
  str1="hello";
  
  string str2;
  str2=str1;

  string str3;
  str3='a';

  string str4;
  str5.assign("hello");

  string str5;
  str5.assign("hello",3);//把字符串的前3个字符赋值给str5

 string str6;
 str6.assign(str5);

  string str7;
  str7.assign(10,'*');//用10个*
}</code></pre> 
<p>5.字符串的拼接：</p> 
<pre><code class="language-cpp">//void test01()
{
  string str1="我";
  str1+="爱你";//追加
 
  str1+=':';

  str2="t";
  str1+=str2;

  string str3="I";
  str3.append("love");

  str3.append("game abbcd",4);//把前四个拼接进去

  str3.append(arr2);
}
</code></pre> 
<pre><code class="language-cpp">void test()
{
 string str1="我“;
 string str2="yyds sdbz";

 str1.append(str2,0,4);//从str的第零个位置截取4个字符
 str1.append(str2,4,4);//从str的第四个位置开始截取四个字符
}</code></pre> 
<p>6）string的查找（指定的字符串是否存在）和替换（在指定的位置替换字符串）</p> 
<pre><code class="language-cpp">void test01()
{
  string str1="abcdef";
  int pos=str1.find("de");//输出3 地址从0开始数 地址不存在的时候会返回-1
  
  int pos2=str1.rfind;//也输出3
  
  //rfind从右往左查找，find从左往右查找
}
 </code></pre> 
<pre><code class="language-cpp">void test02()
{
 //从第n个位置起的几个字符替换成什么样的字符串
 string str1="abcdefg";
 str1.replace(1,3,"1111");//从第一个位置开始数三个字符替换成1111的字符串a1111efg
}</code></pre> 
<p>7)string字符串的比较：比得是字符的ASCII码值逐个对比</p> 
<p>相等返回0 第一个大的话返回1 第一个小的话返回-1</p> 
<pre><code class="language-cpp">if(str1.compare(str2)==0)
{
  cout&lt;&lt;"str1==str2"&lt;&lt;endl;
}</code></pre> 
<p>8)string的字符存取</p> 
<p>string的单个字符的存取方式有俩种</p> 
<pre><code>//通过[]来访问单个字符

for(int i=0;i&lt;str.size();i++)
{
   cout&lt;&lt;str[i]&lt;&lt;endl;
}

//通过at的方式来访问单个字符

for(int i=0;i&lt;str.size();i++)
{
   cout&lt;&lt;str.at(i)&lt;&lt;endl;
}</code></pre> 
<pre><code class="language-cpp">//修改单个字符
str[0]='a';
str.at(1)='a';</code></pre> 
<p>9)string中的插入和删除</p> 
<pre><code>//插入
 str.insert(1,'111');//在第一个位置插入三个1
//删除
 str .erase(1,3)//从第一个位置删三个</code></pre> 
<p>10）string子串——常用接口（从字符串中截取想要的子串）</p> 
<pre><code class="language-cpp">string str1='abcdef';
string str2=str.substr(1,3);//从第一个的位置截取三个bcd

//实用操作 从邮件地址中获取用户名信息
void test02()
{
  string email="zhangsan@sina.com";
  int pos=email.find("@");
  string userName=email.substr(0,pos);
}</code></pre> 
<h1> (四）deque容器</h1> 
<p>deque容器：<strong>双端数组</strong>，可以对头端进行插入和删除操作。</p> 
<p>和vector的区别：vector对于头部的插入删除效率低，数据量越大，效率越低</p> 
<p>deque相对而言，对头部的插入删除速度比vector快</p> 
<p>vector访问元素的速度比deque快，这和俩者的内部实现有关。</p> 
<pre><code class="language-cpp">//vector的赋值操作
1)等号赋值
 v2=v1;
2)assign赋值
 v3.assign(d1.begin(),d1.end());
3)
 v4=assign(10,100);</code></pre> 
<pre><code class="language-cpp">//deque的大小操作
 d1.empty();//空为1非空为0
 d1.size();//容器中的元素个数
 deque容器没有容量的概念
 d1.resize(15,1);//重新指定大小
</code></pre> 
<pre><code class="language-cpp">//deque的删除和插入
 //尾插
   d1.push_back(10);
 //头插
   d1.push_front(10);
 //尾删
   d1.pop_back()；
 //尾删
   d1.pop_front();
 //d1.insert(d1.begin(),1000);
   d1.insert(d1.begin(),2,10000);//在头部插入俩个一万
 //按照区间来进行插入
   d1.insert(d1.begin(),d2.begin(),d2.end());//在d1的头部插入d2
 //删除
   d1.erase();
 //按照区间来删除
   d1.erase(d1.begin(),d1.end());
 //清空
   d1.clear;</code></pre> 
<pre><code class="language-cpp">//deque的数据存储
  []访问
     d[i]
  at访问
     d.at(i);
  d.front
  d.end</code></pre> 
<pre><code class="language-cpp">//deque的排序
算法：sort(d.begin().d.end());//默认从小到大升序排列</code></pre> 
<p> 对于支持随机访问的迭代器容器，都可以利用sort算法直接对其进行排序。vector也可以用这个方式进行排序。</p> 
<h1><strong>（五）stack栈容器</strong></h1> 
<p>一种先进后出的数据结构，通常只有一个出口。栈不允许有遍历行为，会有元素的改动。栈可以判断容器是否为空，栈可以返回它的元素个数（入栈的时候记录个数）</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stack&gt;
using namespace std;

void test01()
{
  stack&lt;int&gt;s;//默认构造
 //入栈
  s.push(10);
  s.push(20);
 //只要栈不为空，查看栈顶，最后执行出栈
 while(!s.empty())
  {
    cout&lt;&lt;"栈顶元素"&lt;&lt;s.top&lt;&lt;endl;
   //出栈
    s.pop();
 }
 cout&lt;&lt;"栈的大小"&lt;&lt;s.size&lt;&lt;endl;
}
</code></pre> 
<p>queue队列容器：符合先进先出的数据结构，它有俩个出口。队尾只能进数据，对头只能出数据。</p> 
<p>进叫做入队（push)，出叫做出队(pop)。</p> 
<p>1)队列容器允许从一段新增元素，从另一端移除元素</p> 
<p>2）队列中只有头和尾才能被外部访问，因此队列中不允许有遍历行为</p> 
<p>3）队列不允许遍历</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#include&lt;queue&gt;

class person
{
public:
 person(string name,int age)
  {
    this-&gt;m_name=name;
    this-&gt;m_age=age;
   }
   int m_age;
   int m_name;
}

void test()
{
  queue&lt;person&gt; q;
 
  person p1("tt",19);
  q.push(p1);

 //只要队列不为空，查看队头和队尾，出队
 while(!q.empty())
  {
   cout&lt;&lt;q.front().m_Name&lt;&lt;q.front().m_Age&lt;&lt;endl;//查看队头
   q.pop();//出队
  }
}</code></pre> 
<h1>（六）list容器：</h1> 
<p>将数据进行链式存储</p> 
<p>链表是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针实现的。链表是由结点组成的。每个结点是由指针域和数据域组成的。</p> 
<p>优点：可以对任意的位置进行快速插入或者删除元素</p> 
<p>缺点：对容器中元素的遍历速度较慢，占用的空间大于数组</p> 
<p>STL中的链表是一种双重循环链表：每一个结点都记录着前面和后面的指针域，最后一个结点指向第一个结点，第一个指向最后一个。</p> 
<p>链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器。</p> 
<pre><code class="language-cpp">//list构造函数
list&lt;T&gt;int;
list(begin,end);
list(n,elem);


list&lt;int&gt;l2(l1.begin(),l1.end());//区间构造

list(const list &amp;lst);//拷贝构造
list&lt;int&gt;l3(l2);</code></pre> 
<pre><code class="language-cpp">//list的赋值和交换
#include&lt;iostream&gt;
#include&lt;list&gt;

void test01()
{
 list&lt;int&gt;L1;
   //插入
 L1.push(10);
 L1.push(20);

 list&lt;int&gt;L2；
   L2=L1;//赋值
   L2.assign(L2.begin(),L2.end());
   L2.assign(10,100);

 //交换
  L1.swap(L2);
};</code></pre> 
<pre><code>//list容器中的大小操作
size()
emptu()
resize(n,elem);
resize(n);
</code></pre> 
<pre><code class="language-cpp">//List的插入和删除
  //在pos位置插入elem元素
   insert(pos.elem);
  //在pos位置插入n个elem
   insert(pos,n,elem);
  //移除容器中的所有数据
   clear();
  //删掉（begin,end)区间的数据
  erase(begin,end);
  //删除pos位置的数据，返回下一个数据
  erase(pos);
  //删除容器中和elem匹配的元素
  remove（elem);</code></pre> 
<pre><code>list数据的存储
front();//返回第一个元素
back();//返回最后一个元素</code></pre> 
<pre><code class="language-cpp">//验证迭代器是不支持随机访问的 支持双向的
list&lt;int&gt;::iterator it=li.begin();
it--;
it++;//但是it=it+1 +2……会报错</code></pre> 
<pre><code class="language-cpp">//list的反转和排序
//把容器中的元素反转，以及对容器中的数据进行排序
  reverse();
  sort();

void print(const list&lt;int&gt;&amp;L)
{
  for(list&lt;int&gt;::const_iterator it=L.begin;it!=L.end;it++)
   {
      cout&lt;&lt;"*it"&lt;&lt;endl;
   }
}

void test()
{
  list&lt;int&gt;l1;
  l1.push_back(10);
  l1.push_back(20);
  l1.reverse();
  sort(l1.begin(),l2.end);//err 所有不支持随机访问迭代器的容器，不支持标准算法
  //不支持随机访问迭代器的容器内部会提供一些对应的算法
  l1.sort();//默认从小到大
}</code></pre> 
<pre><code class="language-cpp">//从大到小排序
bool myCompare(int v1,int v2)
{
  //降序让第一个数大于第二个数
   return v1&gt;v2;
}

l1.sort(mycompare);//sort是成员函数</code></pre> 
<h1>（七）set/multiset容器：</h1> 
<p>所有元素都会在插入的时候自动被排序</p> 
<p>本质：set/multiset属于关联式的容器，就是结构是用二叉树实现的。</p> 
<p>set不允许数据中有重复存在，multiset允许数据的重复存在。</p> 
<pre><code class="language-cpp">//构造：
set&lt;T&gt;s;
set s1(const set&amp; s2);
//插入
s1.insert(10);
//大小
size();
empty();
//交换
swap(st);
//插入
insert(elem);
//删除
clear();
//删除pop所指的元素，返回下一个元素的迭代器
erase(pop);
//删除begin,end的元素，返回下一个元素的迭代器
erase(begin,end);
//删除容器中为elem的元素
erase(elem);
//查找key是否存在，存在就返回该键元素的迭代器，不存在就返回set.end()
find(ket);
//统计key元素的个数
count(key);</code></pre> 
<p></p> 
<p>队组：成对出现的数据，利用队组可以返回俩个数据</p> 
<pre><code class="language-cpp">pair&lt;type,type&gt;p(value1,value2);
pair&lt;type.type&gt;p=make_pair(value1,value2);</code></pre> 
<pre><code class="language-cpp">//pair对组的创建
void test01()
{
  //第一种方式
  pair&lt;string,int&gt;p("Tom",20);
  cout&lt;&lt;p.first&lt;&lt;p.second&lt;&lt;endl;
  //第二种方式
  pair&lt;string,int&gt;p2=make_pair("jerry",18);
}</code></pre> 
<h1> （八）map/multimap容器：</h1> 
<p>map中的所有元素都是pair</p> 
<p>pair中的第一个元素是key(键值），起到索引的作用。第二个元素是实值value</p> 
<p>所有元素都会根据键值自动排序。</p> 
<p>map本质上也是关联式的容器，底层结构是用二叉树实现的。</p> 
<p>优点：可以根据key快速找到value</p> 
<p>缺点：（1）map不允许有重复的key</p> 
<p>(2)multimap允许出现重复的key</p> 
<pre><code class="language-cpp">//构造
map&lt;T1,T2&gt;mp;
map(const map&amp; mp);
//赋值
map&amp; operator=(const map &amp;mp);
//大小
size()
empty()
swap(st);
//插入
insert(item);
//清除
clear();
//删除pos迭代器所指的元素，返回下一个元素的迭代器
erase(pos);
//删除区间
erase(begin,end);
//删除容器中值为key的元素
erase(key);
//查找
find(key);
//统计
count(key);

</code></pre> 
<p>map容器中的排序</p> 
<pre><code class="language-cpp">#include&lt;iostrean&gt;
using namespace std;
#include&lt;map&gt;


class compare
{
public:
  bool operator()(int v1,int v2)
  { 
      return v1&gt;v2;
  }
}

void test01()
{
  map&lt;int,int,compare&gt;m;
  m.insert(make_pair(1,10));
  m.insert(make_pair(2,20));

 for(map&lt;int,int&gt;::iterator it=m.begin;it!=m.end;it++)
  {
    cout&lt;&lt;it-&gt;first&lt;&lt;it-&gt;second&lt;&lt;endl;
  }</code></pre> 
<h1>（九）函数对象（仿函数）是一个类，而不是一个函数。</h1> 
<p>概念：</p> 
<p>重载函数调用操作符的类，其对象称为函数对象</p> 
<p>函数对象使用重载的（）时候，行为类似函数调用，也叫做仿函数。</p> 
<p>函数对象在使用的时候，可以像普通函数那样调用，可以有参数和返回值</p> 
<pre><code>int operator()(int v1,int v2)
{
  return v1+v2;
}</code></pre> 
<pre><code>myprintf()
{
  this-&gt;count=0;
  this-&gt;count++;
}
int operator()(int v1,int v2)
{
  return v1+v2;
}

int count;//查看调用次数</code></pre> 
<p>函数对象可以作为参数传递</p> 
<pre><code>void doprint(myprint &amp;mp,string test)
{
   mp(test);
}

void test03()
{
   myprint my;
   doprint(my,"hello");
}</code></pre> 
<h1>（十）谓词：返回bool类型的仿函数</h1> 
<p>如果operator（）接受一个参数，那么叫做一元谓词</p> 
<p>如果operator()接受俩个参数，那么叫做二元谓词</p> 
<pre><code class="language-cpp">class over
{
  public:
     bool operator()(int val)
     {
         return val&gt;5;
     }
};


void test01()
{
  vector&lt;int&gt;v1;
  int i=0;
  for(;i&lt;10;i++)
   {
     v.push_back(i);
   }
  //查找容器中是否有大于5的数字 over()匿名函数对象
  vector&lt;int&gt;::iterator it=find_if(v1.begin,vi.end,over());
  if(it==v.end())
   {
     cout&lt;&lt;"未找到”&lt;&lt;endl;
   }
  else
   {
     cout&lt;&lt;*it&lt;&lt;endl;
   }
}</code></pre> 
<p>二元谓词</p> 
<pre><code class="language-cpp">bool operator()(int val1,int val2)
{
  return val1&gt;val2;
}</code></pre> 
<h1>（十一）算术仿函数</h1> 
<p>功能：实现四则运算</p> 
<pre><code class="language-cpp">plus minus multiplies divides modulus negate//取反
#include&lt;functional&gt;

void test()
{
  negate&lt;int&gt;(n);
  n(50);
}

void test()
{
  plus&lt;int&gt;p
  p(10,20);
}</code></pre> 
<h1>（十二）关系仿函数</h1> 
<p>功能：实现关系对比</p> 
<pre><code class="language-cpp">equal not_equal greater greater_equal less less_equal//
sort(v.begin,v.end,greater&lt;int&gt;());//greater&lt;int&gt;&lt;&gt;内建函数对象</code></pre> 
<h1>（十三） 逻辑仿函数</h1> 
<p>功能：实现逻辑运算</p> 
<pre><code>logical_and与 logical_or或 logic_not非
//把v1容器中的数据搬到v2，并且执行取反操作

vector&lt;bool&gt;v1
vector&lt;bool&gt;v2;
v2.resize(v.size());

transform(v.begin(),v.end(),v2.begin(),logical_not&lt;bool&gt;())
</code></pre> 
<p></p> 
<h1>（十四）遍历算法</h1> 
<pre><code>//for_each遍历

#include&lt;vector&gt;
#include&lt;algorithm&gt;

class print{
 public:
   void operator()(int val)
    {
      cout&lt;&lt;val&lt;&lt;endl;
     }
}


void test01()
{
  vector&lt;int&gt;v;
  for(int i=0;i&lt;10;i++)
   {
      v.push_back(i);
   }
  for_each(v.begin(),v.end(),print());
}
</code></pre> 
<pre><code class="language-cpp">//transform的遍历
class transform()
{
  public:
    int operator()(int val)
     {
       return val+10000;
     }
};

void test01()
{
  vector&lt;int&gt;v;
  for(int i=0;i&lt;10;i++)
   {
      v.push_back(i);
   }
  vector&lt;int&gt;v1;
  v1.resize(v.size());
 transform(v.begin(),v.end(),v1.begin(),transform());
}</code></pre> 
<h1><strong>（十五）常用查找算法：</strong></h1> 
<pre><code class="language-cpp">find：查找指定元素，查到的话返回指定元素的迭代器，找不到的话返回最后元素的迭代器end()
 vector&lt;int&gt;::iterator it=find(v.begin(),v.end(),5);
 if(it==v.end)
  cout&lt;&lt;"没有找到"&lt;&lt;endl;
 else{
   cout&lt;&lt;*it&lt;&lt;endl;
  }

//遇到自定义类型的时候需要重载==
class person{
 public:
   person(string name,int age)
   { 
      this-&gt;m_name=name;
      this-&gt;m_age=age;
    }
   string m_name;
   int m_age;
//重载==
   bool operator==(const person&amp; p)
   {
       if(this-&gt;m_name==p.m_name&amp;&amp;this-&gt;m_name==p.m_name)
           return true;
       else return false;
   }
}
 </code></pre> 
<p>find_if（起始，最后，仿函数）：按条件查找元素</p> 
<p>按照值去查找元素，找到的话就返回指定位置迭代器，找不到的话返回结束迭代器。</p> 
<pre><code class="language-cpp">vector&lt;int&gt;::iterator it=find_if(v.begin(),v.end(),overfive());</code></pre> 
<p>adjacent_find(起始，最后）：查找相邻元素</p> 
<p>如果查到相邻元素了，就返回相邻元素的第一个的迭代器</p> 
<pre><code>vector&lt;int&gt;::iterator pos=adjacent_find(v.begin(),v.end());</code></pre> 
<p>binary_search：查找指定的元素是否存在(必须是一个有序序列）</p> 
<pre><code class="language-cpp">bool ret=binary_search(v.begin(),v.end(),9);</code></pre> 
<p>count:统计元素的个数</p> 
<pre><code class="language-cpp">int num=count(v.begin(),v.end(),40);</code></pre> 
<p>count_if：按照条件来统计元素个数</p> 
<pre><code>class over5()
{
  public:
   bool operator()(int val)
    {
       return val&gt;20;
    }
};

int num=count_if(v.begin(),v.end(),over5());</code></pre> 
<h1>（十六）常用排序算法： </h1> 
<p>sort  对容器元素进行排序</p> 
<pre><code>sort(v.begin(),v.end(),greater&lt;int&gt;());</code></pre> 
<p>random_shuffle  洗牌 在指定范围内的元素随机调整次序</p> 
<pre><code class="language-cpp">void test()
{
  srand((unsigned int)time(NULL));
}

random_shuffle(v.begin()&lt;v.end());</code></pre> 
<p>merge：容器元素合并 并且存储到另一个容器中 俩个容器必须是有序的</p> 
<pre><code class="language-cpp">//提前给目标容器分配空间
vtarget.resize(v1.size()+v2.size());
merge(v1.begin(),v1.end(),v2.begin(),v2.end(),vtarget.begin());</code></pre> 
<p>reverse：反转指定范围内的元素</p> 
<pre><code>reverse(v.begin(),v.end());</code></pre> 
<h1>（十七）常用的拷贝和替换算法：</h1> 
<p>.copy:容器中指定范围的元素拷贝到另一个容器中</p> 
<pre><code class="language-cpp">v2.resize(v1.size());
copy(v1.begin(),v1.end,v2.begin());</code></pre> 
<p>replace：将容器中指定范围内的旧元素修改为新元素</p> 
<pre><code>replace(v1.begin(),v1.end(),20,2000);//把20替换成2000</code></pre> 
<p>.replace_if:容器内指定范围满足条件的元素替换为新元素</p> 
<pre><code>class greater30
{
  public:
    bool operator()(int val)
     {
         return val&gt;=30;
     }
};
replace_if(v.begin(),v.end(),greater30,3000);//把大于等于30的替换成3000</code></pre> 
<p>swap:互换俩个容器中的元素</p> 
<pre><code>swap(v1,v2);</code></pre> 
<h1>（十八）常用的算术生成算法#include&lt;numeric&gt;</h1> 
<p>accumulate:计算容器元素累计总和</p> 
<pre><code>int total=accumulate(v1.begin(),v1.end(),val);//val是初始值</code></pre> 
<p>fill：向容器中添加元素</p> 
<pre><code>fill(v.begin(),v.end(),100);</code></pre> 
<p>常用集合算法</p> 
<p>求俩个容器的交集</p> 
<pre><code>//目标容器需要提前开辟空间，俩个容器取小的
vtarget.resize(min(v1.size(),v2.size());
vector&lt;int&gt;::iterator it
=set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),vtarget.begin());</code></pre> 
<p>求俩个容器的并集：俩个集合必须是有序的序列</p> 
<pre><code>vtarget.resize(v1.size()+v2.size());
vector&lt;int&gt;::iterator it
=set_union(v1.begin(),v1.end(),v2.begin(),v2.end(),vtarget.begin());</code></pre> 
<p>求俩个容器的差集：从某个容器中看和另一个容器中不同的部分</p> 
<pre><code>vtarget.resize(max(v1.size(),v2.size());
vector&lt;int&gt;::iterator it=set_difference(v1.begin(),v1.end(),v2.begin(),v2.end(),vtarget());
</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>