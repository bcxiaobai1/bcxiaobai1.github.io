<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>数据库计算机三级等级考试--数据库技术相关知识点和笔记 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库计算机三级等级考试--数据库技术相关知识点和笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    
                        
                    
                    <h2>
<a id="_0"></a>数据库计算机三级等级考试–数据库技术</h2> 
<p>计算机三级等级考试笔记,是博主通过计算机三级数据库技术考试的相关笔记，此篇博客，不仅适合需要考计算机三级考试的各位考生，也适合在职场处理关于数据库的部分操作，个人认为算是一篇使用性比较强的文档，我个人认为，我目前所在开发岗位，在回顾去看这篇文档，我都会再次有收获，对了，如果你需要计算机三级的刷题软件，可以一键三连，留下评论，然后私聊博主。总结不易，如果有收获可以在下方评论。对了，计算机三级考试主要采用的是sql server数据库。</p> 
<h3>
<a id="1__2"></a>第1章 数据库应用系统开发方法</h3> 
<p>一、系统规划与定义：</p> 
<blockquote> 
 <p>1、任务陈述。<br> 2、确定任务目标。<br> 3、确定系统范围和边界。<br> 4、确定用户视图</p> 
</blockquote> 
<p>二、可行性分区：</p> 
<blockquote> 
 <p>1、经济可行性。<br> 2、技术可行性。<br> 3、操作可行性。（各种人员资源，常考选择题）<br> 4、开发方案选择。</p> 
</blockquote> 
<p>三、数据字典：</p> 
<blockquote> 
 <p>1、数据项。<br> 2、数据结构。<br> 3、数据流。<br> 4、数据存储。<br> 5、处理过程。</p> 
</blockquote> 
<p>四、数据处理需求（事务规范）：</p> 
<blockquote> 
 <p>1、事务名称。<br> 2、事务描述。<br> 3、事务所访问的数据项。<br> 4、事务用户。 注意：事务隔离级别不属于事务规范。（选择题）</p> 
</blockquote> 
<p>五、性能指标：</p> 
<blockquote> 
 <p>1、数据操作响应时间。<br> 2、系统吞吐量。<br> 3、允许并发访问的最大用户数。<br> 4、每TPS代价值。用于衡量系统性价比 的指标。</p> 
</blockquote> 
<p>六、系统设计：</p> 
<blockquote> 
 <p>1、概念设计。（ER图）<br> 2、逻辑设计。（ER图转关系模式） 包括：数据库逻辑结构设计、应用程序概要设计、数据库事务概要设计。<br> 3、物理设计。（具体实现）</p> 
</blockquote> 
<p>七、实现与部署：</p> 
<blockquote> 
 <p>1、建立数据库结构。<br> 2、数据加载。<br> 3、事务和应用程序的编码及测试。<br> 4、系统集成、测试与试运行。<br> 5、系统部署。</p> 
</blockquote> 
<h3>
<a id="2__54"></a>第2章 需求分析</h3> 
<p>一、获取需求的方法：</p> 
<blockquote> 
 <p>1、面谈。<br> 2、实地观察。<br> 3、问卷调查。<br> 4、查阅资料。</p> 
</blockquote> 
<p>二、软件需求说明书：</p> 
<blockquote> 
 <p>1、需求概述。<br> 2、功能需求。（常考区分功能需求与非功能需求）<br> 3、信息需求。<br> 4、性能需求。<br> 5、环境需求。（运行环境）<br> 6、其他需求。</p> 
</blockquote> 
<p>三、三种需求分析方法：DFD、IDEF0、UML。</p> 
<blockquote> 
 <p>DFD建模方法： 过程建模和功能建模方法都是结构化分析思路。</p> 
</blockquote> 
<p>DFD（自顶向下逐步细化）</p> 
<p>IDEF0</p> 
<p>UNM</p> 
<p>数据流（核心）、处理 、数据存储、外部项。 箭头（强调数据约束）、矩形框（活动） 系统、角色、</p> 
<h3>
<a id="3_83"></a>第3章、数据库结构设计</h3> 
<p>一、数据库概念设计：<br> 两种数据建模方法： <code>ER建模方法、IDEF1X建模方法</code></p> 
<p>1、ER建模方法：第一大题</p> 
<p>2、IDEF1X 建模方法：</p> 
<blockquote> 
 <p>a. 实体集：独立实体集（矩形框）、从属实体集（加圆角矩形框）。 <br> b、联系：<br> ①、标定型联系：两个实例确定第三个实例。（实线连接）<br> ②、非标定型联系：唯一实例确定。（虚线连接） ③、分类联系：如学生可以是大学生、高中生、初中生。 ④、分确定联系：多对多关系</p> 
</blockquote> 
<p>二、数据库逻辑设计（ER图转关系模式）<br> 这个还好，就是将E-R图转换为数据库的名称描述<br> 规范:<br> 某个表（主键，列名。。。） 主键一般有下划线，外键可以是波浪线，一般可以来个描述，某个列是主键，某个列是外键。<br> 三、数据库物理设计：<br> 1、索引：<br> 两大类：==有序索引、散列索引 ==<br> a、有序索引又可以分为： ①、聚集索引与非聚集索引：排列顺序相一致或不一致。 ②、稠密索引与稀疏索引：每个查找码都对应一个索引记录 或 只是一部分对应。 ③、主索引与辅索引：建立在主键上 或 非主键上。 ④、唯一索引：确保索引列不包含重复的值。 ⑤、单层索引与多层索引：没刷到过题。</p> 
<p>2、物理设计内容：</p> 
<blockquote> 
 <p>a、数据库逻辑模式描述。（关系模式转换成基本表）<br> b、文件组织与存取设计。<br> c、数据分布设计。<br> d、确定系统配置。<br> e、物理模式评估。</p> 
</blockquote> 
<p>基本表选择合适的文件结构原则：</p> 
<blockquote> 
 <p>①堆文件：数据量少，更新频繁。 ②顺序文件：查询条件在查找码上。 ③散列文件：访问顺序随机，<br> 并且没有以下情况：<br> a、基于散列域值的非精确查询（模糊查询、范围查询）。<br> b、基于非散列域进行的查询。<br> ④B-树和B+树文件：大数据量的基本表、等值查询、范围查询、模糊查询、部分查询。<br> ⑤聚集文件：频繁执行且进行多表连接操作的查询。</p> 
</blockquote> 
<p>适合建立索引原则：</p> 
<blockquote> 
 <p>①、表的主键。<br> ②、在where查询子句中引用率较高的属性。<br> ③、参与连接的属性。<br> ④、group by 与 order by子句中的属性。<br> ⑤、对于经常需要进行查询、连接、统计操作，且数据量大的基本表。</p> 
</blockquote> 
<h3>
<a id="4__130"></a>第4章 数据库应用系统设计与实施</h3> 
<p>一、DBAS体系结构设计</p> 
<blockquote> 
 <p>1、客户 / 服务器体系结构（两层 C / S）<br> 2、浏览器 / 服务器结构 （三层 B / S）</p> 
</blockquote> 
<p><mark>表示层：位于客户端。<br> 功能层：位于Web应用服务器。<br> 数据层：位于数据库服务器。</mark></p> 
<p>二、DBAS功能概要设计<br> 从功能角度划分</p> 
<blockquote> 
 <p>1、表示层：进行人机界面设计。<br> 2、数据逻辑层：梳理DBAS的各项业务活动，减去表示为各种系统架构。传输数据的作用。<br> 3、数据访问层：设计操作数据库的事务。负责与DBMS系统进行交互。<br> 4、数据持久层：进行应用系统的存储结构设计。保存和管理应用系统数据。</p> 
</blockquote> 
<p>高内聚，松耦合原则：</p> 
<blockquote> 
 <p>a、单一责任原则。<br> b、各个构件均应具有独立的功能。<br> c、构件之间的接口应尽量简单明确。<br> d、构件间关系比较复杂，进一步模块划分。<br> e、构件间关系过于复杂，细分。</p> 
</blockquote> 
<p>事务设计：</p> 
<blockquote> 
 <p>1、事务规范（数据处理需求）：事务名称、事务描述、事务所访问的数据项、事务用户等。<br> 2、两个元操作：read、write<br> 3、事务隔离性级别越高，安全性越高，性能越低，同时事务的隔离级别和数据库并发性是对立的。<br> 4数据库的一致性：事务执行成功则全部提交，如果一个事务提交失败，则做过的所有更新则全部撤销。</p> 
</blockquote> 
<p>三、安全架构设计<br> 安全可靠性是应用系统的重要衡量指标。</p> 
<p>1、数据安全设计<br> 数据库的安全性保护：</p> 
<blockquote> 
 <p>a、用户身份鉴别。 b、权限控制。 c、视图机制。</p> 
</blockquote> 
<p>数据库的完整性保护： <mark>完整性：是指数据库中数据的正确性、一致性、相容性。 方法：设置完整性检查。 检查数据表时（select等）不会检查数据的完整性约束。</mark></p> 
<p>两段锁协议： 指所有事务必须分两个阶段对数据项加锁和解锁。</p> 
<p>1、在对任何数据进行读、写操作之前，要申请并获得对该数据的封锁。</p> 
<p>2、在释放一个封锁之后，事务不再申请和获得其他任何封锁。 可以证明，若并发执行的素有事务均遵守两段锁协议。则对这些事务的任何并发调度策略都是可串行化的。 也可能发生死锁。 加锁协议事务可以申请获得任何数据项的任何类型的锁，但不允许释放任何锁。 一次封锁法： 要求每个事务必须一次将所有要使用的数据全部加锁。一次封锁法遵守两段锁协议，但两段锁协议并不要求一次全加锁。</p> 
<p>三级加锁协议：保证数据的一致性。 检测死锁：检测事务等待图 是否出现回路。</p> 
<p>数据库并发控制： <mark>封锁技术：排它锁（x锁）、共享锁（s锁）</mark></p> 
<p>避免死锁的方法：</p> 
<blockquote> 
 <p>a、按同一顺序访问资源。<br> b、避免事务中的用户交互。<br> c、采用小事务模式，尽量缩短事务的长度，减少占有锁的时间。<br> d、尽量使用记录级别的锁（行锁），少用表级别的锁。<br> e、使用绑定连接，使同一应用程序锁打开的两个或多个连接可以相互合作。</p> 
</blockquote> 
<p>数据库的备份与恢复：</p> 
<blockquote> 
 <p>a、双机热备。 b、数据转储。 c、数据加密存储。</p> 
</blockquote> 
<p>数据加密传输：</p> 
<blockquote> 
 <p>a、数字安全证书。 b、对称密钥加密。 c、数字签名。 d、数字信封。</p> 
</blockquote> 
<p>2、环境安全设计</p> 
<ol>
<li>漏洞与补丁</li>
<li>计算机病毒保护： a、安装杀毒软件，定期查杀病毒。 b、计算机实时监控。</li>
<li>网络环境安全： a、防火墙。 b、入侵检测系统。 c、网络隔离。</li>
<li>物理环境安全</li>
</ol> 
<p>四、DBAS实施<br> 1、创建数据库： a、初始空间大小。 b、数据库增量大小。 c、访问性能。</p> 
<p>2、数据装载： a、筛选数据。 b、转换数据格式。 c、输入数据。 d、校验数据。 3、编写与调试应用程序 4、数据库系统试运行： a、功能测试。 b、性能测试。</p> 
<h3>
<a id="5_UML_211"></a>第5章 UML与数据库应用系统</h3> 
<p>UML四层建模概念框架 1、元元模型层。 2、元模型层。 3、模型层。 4、用户模型层。</p> 
<p>13种图 结构图（静态）6种：<mark>类图、对象图、复合结构图、包图、组件图、部署图</mark>。 简记：类对复包组部</p> 
<p>行为图（动态）7种：<mark>用例图、顺序图、通信图、交互概述图、时间图、状态图、活动图</mark>。 简记：用顺通交时状活</p> 
<p>一、类图：<br> 类图关系：<br> 泛化：——▷ 父类<br> 实现：------▷ 接口（被实现类）<br> 关联：——&gt; 被拥有者<br> 聚合：——◇ 整体<br> 组合：——◆ 整体<br> 依赖：------&gt; 被使用者</p> 
<p>二、对象图：<br> 系统某个时间的所有对象的快照。</p> 
<p>三、复合结构图：<br> 最主要元素：部件。</p> 
<p>四、包图：<br> 用于表达系统中不同的包、命名空间或不同的项目间彼此关系的图。 包与包之间不能共享一个相同的模型元素。</p> 
<p>五、组件图：<br> 表示系统的静态实现视图，展现一组组件之间的组织和依赖。</p> 
<p>六、部署图：<br> 描述系统运行时的结构，展现硬件的配置及其软件如何部署。只有一个部署图，帮助理解分布式系统。</p> 
<p>七、用例图：<br> 主要组成： 用例、角色、系统。用例之间的关系：扩展、使用、组合</p> 
<p>八、顺序图：<br> 强调时间。 用于描述系统内部的动态结构，主要用于描述系统内对象之前的消息发送与接收序列。</p> 
<p>九、通信图（协作图）：<br> 强调空间。表达对象之前的联系以及对象间发送和接收消息的图。</p> 
<p>十、交互概述图：<br> 活动图为基础。</p> 
<p>十一、时间图：<br> 作为状态图的辅助说明工具。</p> 
<p>十二、状态图：<br> 描述一个对象在其生存期内的动态行为。状态间的转移。状态之间的转移是由事件 驱动的。</p> 
<p>十三、活动图：<br> 描述系统、用例、程序模块中逻辑流程的先后执行次序。</p> 
<h3>
<a id="6__263"></a>第6章 高级数据查询</h3> 
<p>一、一般数据查询功能扩展<br> 1、使用TOP 限制结果集</p> 
<pre><code>【distinct】 TOP n 【percent】【with ties】
</code></pre> 
<ol>
<li>distinct ：不重复的</li>
<li>percent：使用%显示</li>
<li>whit ties：取并列结果 通常TOP与order by 排序一起使用</li>
</ol> 
<p>2、case 函数<br> 简单case函数：</p> 
<blockquote> 
 <p>case 测试表达式 when 简单表达式1 then 结果表达式 … [ else 结果表达式 ] end</p> 
</blockquote> 
<p><mark>搜索case函数 与简单case函数形式的区别是 case 后面不跟有测试表达式</mark></p> 
<p>3、将查询结果保存到新表中（into语句）<br> <mark>select 列名 into 新表名 from …</mark></p> 
<p>新表可以是永久表，也可以是临时表。 临时表区别： 局部临时表（#table）、全局临时表（##table）</p> 
<p>二、查询结果的并、交、差运算</p> 
<p>并运算（UNION）：将两表进行垂直连接。<br> 交运算 （INTERSECT）：取两表相交部分。<br> 差运算 （EXCEPT）：表1 - 表2</p> 
<p>并交差运算与 join 连接不同的是<mark>join是水平合并数据，而并交差则是垂直合并数据</mark>。 常考：选择填空题。</p> 
<p>三、子查询<br> 运算符 IN 与NOT IN ：将表达式与子查询返回的结果集进行比较。 比较运算符：子查询返回的必须是单值。 以上两者都是<mark>不相关子查询，即先执行内层查询，在执行外层查询，子查询的查询条件不依赖外层循环</mark>。 使用子查询进行存在性测试</p> 
<p>关键字：EXISTS 与 NOT EXISTS 子查询返回的结果为 真值或假值。 区别 ： <mark>带EXISTS谓词的查询是先执行外层查询，然后在执行内层查询</mark>。相关子查询。</p> 
<p>四、聚合函数与开窗函数<br> 聚合函数 ：SUM、COUNT、AVG、MIN、MAX count（*）返回表中的行数，不会过滤null和重复的行，但count（列名）会过滤 null</p> 
<p>开窗函数 ：OVER（【partition by】，【order by】）<br> 1、聚合开窗函数 聚合函数与开窗函数的结合 如： SUM OVER (PARTITON BY 列名) …<br> 2、排序开窗函数<br> <mark>RANK() ：有重复，但不连续的排名</mark>。<br> <mark>DENSE_RANK()：有重复，但连续的排名</mark>。<br> <mark>NTILE()：用于将分组数据按照顺序切分成n片，返回当前切片值。将一个有序的数据集划分为多个桶(bucket)，并为每行分配一个适当的桶数（切片值，第几个切片，第几个分区等概念）。它可用于将数据划分为相等的小切片，为每一行分配该小切片的数字序号</mark>。<br> <mark>ROW_NUMBER()： row_number() OVER (PARTITION BY COL1 ORDER BY COL2)<br> 表示根据COL1分组，在分组内部根据COL2排序，而此函数计算的值就表示每组内部排序后的顺序编号（组内连续的唯一的）</mark>。</p> 
<p>聚合函数与开窗函数都是位于select <mark>【】</mark> from</p> 
<p>五、派生表与公用表<br> 1、派生表（内联视图） 如:（select * form table） AS 别名</p> 
<p>2、公用表 如 WITH 公用表名（列名） AS (select * from table)</p> 
<p>需要死记得关键字： <mark>distinct（不重复的）、percent（百分比）、with ties （取相同）、UNION(并)、INTERSECT(交)、EXCEPT(差)、EXISTS(存在)。</mark></p> 
<h3>
<a id="7__321"></a>第7章 数据库及数据库对象</h3> 
<p>一、创建及维护数据库<br> 1、两大类：<br> 系统数据库 （自动创建和维护的）：</p> 
<blockquote> 
 <p>master：最重要的数据库，记录所有系统级信息，主要的信息都是存放在这。</p> 
 <p>msdb：保存报警、作业、操作员等信息。（考的不多，选择判断题）</p> 
 <p>model：所有创建数据库的模板。</p> 
 <p>tempdb：临时数据库，每次启动SQL都会重新创建，因此不需要备份。 用户创建的局部和全局临时表均被自动放置在改数据库中。</p> 
 <p>Resource：只读数据库。（没见过考）</p> 
</blockquote> 
<p>用户数据库（用户创建和维护）</p> 
<p>经常考选择题：系统数据库如何备份？（未完成）</p> 
<p>2、数据库文件分类<br> 数据文件：<br> 主要数据文件：每个数据库中只有一个，第一个数据文件，推荐扩展名：mdf。<br> 次要数据文件：可以有0~n个，推荐扩展名：ndf.</p> 
<blockquote> 
 <p>总结：主要数据文件有且只有一个，而次要数据文件可以有0或多个，可以建立在多个磁盘上。两者对用户来说没有区别，在多个不同的磁盘中建立多个数据文件，有利于利用存储空间，以及提高数据的存取效率。</p> 
</blockquote> 
<p>日志文件 每个数据库至少有一个日志文件（创建数据库时，如果没有创建日志文件，系统自动创建日志文件），推荐扩展名：ldf。</p> 
<p>3、数据库存储空间的分配<br> 数据库的存储分配单位是数据页，其中一数据页的大小是 8k ,一行数据不能存储在不同的数据页中（行不能跨页存储）。</p> 
<blockquote> 
 <p>经常考填空题：一个数据表中 n 行数据，每行 m 字节，则需要多少MB的存储空间，以及空间利用率为多少？ 解法：n 行数据需要 a<br> 页数据页，则需要 8a MB的存储空间。空间利用率等于：每页数据页实际使用的空间 除以 一页数据页总共的空间。</p> 
</blockquote> 
<p>4、文件组<br> 主文件组：一个数据库只有一个默认文件组，一般默认为Paimary，存放主要数据文件和未明确分配文件组的次要数据文件。</p> 
<p>特别： 1、日志文件不存放在文件组中，日志空间与数据空间是分开管理的。 2、一个文件不可是多个文件组的成员。</p> 
<p>经常考点：主要数据文件、次要数据文件、日志文件可以有多少个？可以存放的位置等问题。</p> 
<p>5、创建数据库</p> 
<pre><code class="prism language-bash">create database db_name on <span class="token punctuation">[</span>指定的文件组<span class="token punctuation">]</span>
</code></pre> 
<p>（ name = db_data, //逻辑名 filename = ‘F:Datadb_data.mdf’, //物理名 size = 2mb, //初始大小 maxsize = 10mb, //最大大小 filegrowth = 2 //自动增长 ） log on ( … )</p> 
<p>6、修改数据库<br> 扩大数据库两种方法：<br> 一：add 添加数据文件 <code>alter database db add file</code>（ …与创建数据库时相同 ）<br> 添加日志文件 <code>alter database db add log file</code>( … )<br> 添加文件组 <code>alter database db add filegroup group_name</code></p> 
<p>二：<code>modify alter database db modify file( name = 逻辑名， …修改内容 size = filegrowth = )</code></p> 
<p>收缩数据库空间的两种方法 文件收缩都是从末尾开始的<br> 一：收缩整个数据库大小 <code>DBCC shrinkdatabase (database_name, 大小 )</code><br> 二：收缩数据库中某个文件的大小 <code>DBCC shrinkfile （file_name,大小）</code></p> 
<p>删除数据库文件</p> 
<pre><code class="prism language-bash">alter database db remove <span class="token function">file</span> file_name
</code></pre> 
<p>7、分离和附加数据库<br> 分离：从SQL server 实例中删除，但不删除数据库中的数据文件和日志文件。 <code>EXEC sp_detach_db ‘db_name’,‘true’</code></p> 
<p>附加：创建一个新的数据库。。。</p> 
<p>经常考点选择题：分离数据库是否需要停止数据库。<br> 1、在分离数据库之前，必须先断开所有用户与该数据库的连接。<br> 2、分离数据库会分离数据文件和日志文件。<br> 3、分离和附加的位置可以不同。<br> 4、进行分离数据库操作不能停止SQL server 服务。</p> 
<p>二、架构<br> 架构：逻辑命名空间，他是一个数据库对象的容器。架构相当于文件夹（不能同名，可以有多个），对象相当于文件（不同文件夹下的文件可以同名）。<br> 关键字：<br> <code>CASCADE</code>：所有架构对象一起全部删除。<br> <code>RESTRICT</code>：包含架构对象则拒绝。</p> 
<p>创建架构： <code>create schema 【架构名】authorizetion 用户名</code></p> 
<p>删除架构： <code>DROP schema 架构名</code></p> 
<p>考点：选择题</p> 
<p>三、分区表<br> a、分区表是水平划分的子集。<br> b、优点：可以快速且有效地管理和访问数据子集。<br> c、是否创建分区表？（选择题） 主要取决于表当前的数据量大小以及将来的数据量大小，同时还取决于对表中数据进行的操作。<br> d、物理上将一张大表分成几张小表，逻辑上还是大表。</p> 
<p>1、分区表两大步骤<br> 创建分区函数：告诉数据库管理系统以什么方式对表进行分区。</p> 
<pre><code class="prism language-bash">create partition <span class="token keyword">function</span> PF_name<span class="token punctuation">(</span>数据类型<span class="token punctuation">)</span> as range <span class="token punctuation">[</span> left <span class="token punctuation">]</span> <span class="token keyword">for</span> values<span class="token punctuation">(</span>分段1，分段2，分段3<span class="token punctuation">)</span>
</code></pre> 
<p>创建分区方案：将分区函数生成的分区映射到文件组中。</p> 
<pre><code class="prism language-bash">create partition scheme PS_name as partiton PF_name to<span class="token punctuation">(</span>文件组1，文件组2，文件组3，文件组4<span class="token punctuation">)</span>
</code></pre> 
<p>PS：指定的文件组数一定要大于或等于分区函数所划分的分区数</p> 
<p>四、索引<br> 索引的创建： 关键字：<br> <code>UNIQUE</code>：唯一索引。 <code>CLUSTERED</code>：聚集索引。 <code>NONCLUSTERED</code>：默认选项，非聚集索引。</p> 
<p>通常创建唯一聚集索引为：(填空题，加粗字体必背)<br> <strong>CREATE UNIQUE CLUSTERED INDEX DROP</strong></p> 
<pre><code class="prism language-bash">CREATE UNIQUE CLUSTERED INDEX index_name ON Table_name<span class="token punctuation">(</span>cname<span class="token punctuation">)</span>
</code></pre> 
<p>对索引键值进行升降排序： ps:系统默认查询结果按升序ASC排序。</p> 
<pre><code class="prism language-bash">CREATE INDEX index_name ON Table_name<span class="token punctuation">(</span>cname1 ASC, cname2 DESC<span class="token punctuation">)</span>
</code></pre> 
<p>删除索引：</p> 
<pre><code class="prism language-bash">DROP INDEX index_name
</code></pre> 
<p>五、索引视图<br> 标准视图（虚拟表）结果集并不存储在数据库中，如果频繁使用这类视图会导致开销很多。 因此可以对视图创建唯一聚集索引的方式来提高查询性能。 对视图创建唯一聚集索引后，视图的结果集将存储在数据库中，就像带有聚集索引的表一样。成为索引视图（物化视图）。</p> 
<p>做题： 索引视图可以提高查询类型的性能： 1、处理大量行的连接和聚合。 2、查询经常执行连接和聚合。 3、决策支持工作负荷。 总结：连接和聚合使用索引视图。</p> 
<p>4、视图可以在视图上再定义视图。</p> 
<p>考点：填空题，加粗字体。</p> 
<p>需要死记得关键字：</p> 
<blockquote> 
 <p><strong>primary（主要的）、create（创建）、filegrowth（增长）、modify（修改）、alter（改变）、DBCC、shrinkdatabase（收缩数据库）、shrinkfile（收缩文件)、remove（移除）、EXEC(执行)、</strong><br> <strong>sp_detach_db(分离数据库)、DROP、schema（架构）、scheme（方案）、partition（划分）</strong></p> 
</blockquote> 
<h3>
<a id="8__469"></a>第8章 数据库后台编程技术</h3> 
<p>一、存储过程<br> 存储过程用于存储和执行T-SQL代码。 好处： 1、允许模块化程序设计。 2、改善性能。 3、减少网络流量。 4、增强应用程序的安全性。</p> 
<p>创建存储过程</p> 
<pre><code class="prism language-bash">create procedure proc_name @parameter data_type , … @parameter2 <span class="token builtin class-name">type</span> output AS T-SQL代码
</code></pre> 
<p>执行存储过程</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">declare</span> @x int , @y int EXEC proc_name ‘输入’ ， @x output,@y output
</code></pre> 
<p>删除存储过程</p> 
<pre><code class="prism language-bash">DROP PROC name
</code></pre> 
<p>二、用户定义函数 (大题常考)<br> 标量函数<br> 返回值</p> 
<p>创建标量函数</p> 
<pre><code class="prism language-bash">create <span class="token keyword">function</span> function_name<span class="token punctuation">(</span>@parameter<span class="token punctuation">)</span> returns <span class="token builtin class-name">type</span> AS begin <span class="token builtin class-name">declare</span> @x int T-SQL语句 <span class="token builtin class-name">return</span> @x end
</code></pre> 
<p>调用标量函数 <mark>函数拥有者名.函数名</mark></p> 
<p>内联函数<br> 返回表</p> 
<p>创建内联表值函数</p> 
<pre><code class="prism language-bash">create <span class="token keyword">function</span> name<span class="token punctuation">(</span>@parameter<span class="token punctuation">)</span> returns table AS <span class="token builtin class-name">return</span> <span class="token punctuation">(</span>T-SQL<span class="token punctuation">)</span>
</code></pre> 
<p>多语句表值函数<br> 创建多语句表值函数</p> 
<pre><code class="prism language-bash">create <span class="token keyword">function</span> name<span class="token punctuation">(</span>@parameter<span class="token punctuation">)</span> returns @table_name table<span class="token punctuation">(</span> 列名 type, … <span class="token punctuation">)</span> AS begin insert into @table_name T-SQL <span class="token builtin class-name">return</span> end
</code></pre> 
<p>删除用户自定义函数</p> 
<pre><code class="prism language-bash">DROP FUNCTION name
</code></pre> 
<p>总结：存储过程与用户自定义函数的区别</p> 
<blockquote> 
 <p>1、存储过程相当于对复杂T-SQL进行预编译封装。<br> 2、用户自定义函数相当于其他编程语言中的函数方法。<br> 区别：<br> 1、声明时，存储过程参数不需要使用括号，并且在输出参数后使用 output 。<br> 2、用户自定义函数必须要有retrun返回值。<br> 3、用户自定义函数一般使用BEGIN和END 将T-SQL语句包围起来。</p> 
</blockquote> 
<p>总结：用户自定义函数中的区别</p> 
<blockquote> 
 <p>不同：<br> 1、标量函数返回的是一个值。<br> 2、内联表值函数返回的是select 查询 的一个表，类似于视图。并且一般不使用BEGIN和END。<br> 3、多语句表值函数返回的是新定义的表。</p> 
 <p>相同：<br> 1、他们的创建语句基本相同，不同的是返回类型。<br> 2、调用方法相同。</p> 
</blockquote> 
<p>三、触发器<br> 一种特殊的存储过程，不需要由用户来直接调用，自动触发执行。 SQL Server 2008中有五种约束类型：<mark>主键约束、外键约束、唯一约束、缺省约束、检查约束</mark>。</p> 
<p>触发器通常用在下列场合： 1、完成比CHECK约束更复杂的数据约束。（check约束只能实现同一个表中列之间的取值约束） 2、为了保证数据库性能而维护的非规范化数据。 3、可实现复杂的商业规则。 4、触发器也可以评估数据修改前后的表状态，并根据其差异采取对策。</p> 
<pre><code class="prism language-bash">三种触发器： <span class="token number">1</span>、DML触发器（只讲）。2、DDL触发器。3、登录触发器。
</code></pre> 
<p>创建触发器</p> 
<pre><code class="prism language-bash">create trigger trigger_name on table <span class="token keyword">for</span> <span class="token punctuation">[</span> after <span class="token punctuation">]</span><span class="token punctuation">[</span> instead of <span class="token punctuation">]</span> 操作类型（insert ，updata，delete） AS T-SQL
</code></pre> 
<p>触发器的区别： 1、后触发型触发器： 使用FOR 或 AFTER 定义的触发器。（即等引发触发器执行的操作都已成功执行才执行触发器操作） 使用ROLLBACK撤销不正确的操作。（实际是回滚到引发触发器执行的操作之前的状态） 后触发型触发器同一个操作可以有多个触发器。 几个用途： a、维护数据操作完整性的触发器。 b、维护不同列之间的取值完整性的触发器。 c、维护数据的一致性的触发器。</p> 
<p>2、前触发型触发器： 使用 INSTEAD OF 选项定义的触发器。（即不执行引发触发器的操作） 前触发型触发器同一个操作只能有一个触发器。</p> 
<p>两个特殊的临时工作表：<br> INSERTED表与 DELETED表。<br> 对于三种操作，insert 、updata、delete 的数据存放。<br> insert 、delete更新删除的数据存放到对应的表中，而updata操作前的数据存放到DELETED表中，操作后的数据存放到INSERTED表中，updata操作相当于对表数据先进行删除，然后在对表数据进行插入。</p> 
<p>四、游标<br> 声明游标 --&gt; 打开游标 --&gt; 提取数据 --&gt; 关闭游标 --&gt;释放资源</p> 
<p>提取数据： <mark>FETCH</mark></p> 
<p>需要死记的关键字： <mark>procedure(程序)、declare(声明)、execute(执行)、trigger（触发）、ROLLBACK(回滚)、for after （后触发型）、instead of （前触发型）</mark></p> 
<h3>
<a id="9__577"></a>第9章 安全管理</h3> 
<p>一、登录账户<br> 创建登录账户：</p> 
<pre><code class="prism language-bash">create login log_name <span class="token punctuation">[</span> whit <span class="token operator">|</span> from <span class="token punctuation">]</span> windows 用户名 <span class="token operator">|</span> password <span class="token operator">=</span> ‘ ’
</code></pre> 
<p>修改登录账户：</p> 
<pre><code class="prism language-bash">alter login log_name <span class="token builtin class-name">enable</span> <span class="token operator">|</span> disable
</code></pre> 
<p>删除登录账户：</p> 
<pre><code class="prism language-bash">drop login log_name
</code></pre> 
<p>二、数据库用户<br> 建立数据库用户：</p> 
<pre><code class="prism language-bash">create user user_name
</code></pre> 
<p>删除数据库用户：</p> 
<pre><code class="prism language-bash">drop user user_name
</code></pre> 
<p>三、Guest 用户<br> 一个特殊的数据库用户。 启用：具有连接权限</p> 
<pre><code class="prism language-bash">grant connect to guest<span class="token punctuation">;</span>
</code></pre> 
<p>禁用：收回连接权限</p> 
<pre><code class="prism language-bash">revoke connect to guest
</code></pre> 
<p>四、权限管理<br> 授权语句：</p> 
<pre><code class="prism language-bash">grant 操作（select、insert、update、delete）on 被授权的对象（表、存储过程等） to 用户
</code></pre> 
<p>拒绝权限：</p> 
<pre><code class="prism language-bash">deny 操作 on 被被授权对象 to 用户
</code></pre> 
<p>授权语句：</p> 
<pre><code class="prism language-bash">revoke 操作 on 被授权对象 to 用户
</code></pre> 
<p>语句级别的权限：</p> 
<pre><code class="prism language-bash">create database create procedure create table create view create <span class="token keyword">function</span> backup database backup log
</code></pre> 
<p>五、角色<br> 1、固定服务器角色<br> 九大服务器级角色：</p> 
<blockquote> 
 <p>bulkadmin：不常见。<br> dbcreator：具有创建、修改、删除和还原数据库的权限。常考<br> diskadmin：具有管理磁盘的权限。<br> processadmin：不常见。<br> securityadmin：不常见。<br> serveradmin：具有设置服务器级别的配置选项和关闭服务器的权限。<br> setupadmin：不常见。<br> sysadmin：具有在服务器及数据库上执行任何操作的权限。常见</p> 
</blockquote> 
<p>授权与删除：<br> 授权：<code>sp_addsrvrolemember</code><br> 删除：<code>sp_dropsrvrolemenber</code></p> 
<p>ps：用户和角色语句位置的顺序： 先用户后角色</p> 
<p>2、固定数据库角色</p> 
<blockquote> 
 <p>数据库级角色：<br> db_accessadmin：具有添加或删除数据库用户的权限。不常见<br> db_backupoperator：具有备份数据库、备份日志的权限。不常见<br> db_datareader：具有查询数据库中所有用户数据的权限。<br> db_datawriter：具有插入、删除、更改数据库中所有用户数据的权限。<br> db_ddladmin：具有执行数据定义语言（DDL）的权限。<br> db_denydatareader：不允许，与db_datareader权限相反。<br> db_denydatawriter：不允许，与db_datawriter权限相反。<br> db_owner：具有全部操作的权限。<br> db_securityadmin：具有管理权限。</p> 
</blockquote> 
<p>授权与删除：<br> 授权：==sp_addrolemember ==<br> 删除：<mark>sp_denyrolemember</mark></p> 
<p>ps：用户和角色语句位置的顺序：先角色后用户</p> 
<p>共同点： 固定数据库角色与固定服务器角色都具有一个相同的角色：<mark>public</mark></p> 
<p>3、用户定义的角色</p> 
<pre><code class="prism language-bash">create role name【authorization】用户或角色
</code></pre> 
<p>需要死记的关键字：<strong>enable（启用）、disable（禁用）、grant（允许）、revoke（撤回）</strong></p> 
<h3>
<a id="10__697"></a>第10章 数据库运行维护与优化</h3> 
<p>一、维护工作主要包括：<br> 1、数据库的转储与恢复。<br> 数据库管理员需要定期对转储的数据进行恢复测试工作。</p> 
<p>2、数据库的安全性、完整性控制。<br> 通过行政手段制定规范。</p> 
<p>3、检测并改善数据库的性能。</p> 
<p>4、数据库的重组与重构。<br> 重组：不修改数据库原有设计的逻辑结构和物理结构。 重构：部分修改数据库的模式和内模式。</p> 
<p>二、运行状态监控与分析：<br> 1、自动监控机制。 2、手动监控机制。 分为对数据库构架体系的监控和对数据库性能的监控。</p> 
<p>三、数据库性能优化。<br> 1、外部调整：<br> 当CPU在业务空闲时使用率超过90%，说明服务器缺乏CPU资源。</p> 
<p>2、模式调整与优化：<br> a、增加派生性冗余列。（总价=单价*数量） b、增加冗余列。 c、重新组表。 d、分割表。 e、新增汇总表。</p> 
<p>3、存储优化：<br> a、物化视图。 b、聚集。</p> 
<p>4、查询优化：<br> a、合理使用索引。 b、避免或简化排序。 c、消除对大型表数据的顺序存取。 d、避免复杂的正则表达式。 e、使用临时表加速查询。 f、用排序来取代非顺序磁盘存取。 g、不充分的连接条件。 h、存储过程。 i、不要随意使用游标。 j、事务处理。</p> 
<h3>
<a id="11__726"></a>第11章 故障管理</h3> 
<p>一、四类故障：<br> 1、事务内部故障：大部分是非预期的，由系统自动完成。 2、系统故障（软故障）：所有正在运行的事务以非正常方式终止，需要系统重启。 3、介质故障（硬故障）：破坏性最大。 4、计算机病毒故障：破坏方式以破坏数据库文件为主（不多见）。</p> 
<p>二、数据转储（数据备份）：<br> 1、静态转储：转储操作和事务是互斥的，保证转储前后的一致性。 2、动态转储：允许转储操作和用户事务并发执行，但不能保证转储数据的一致性。</p> 
<p>三、数据转储机制：<br> 1、完全转储。 2、增量转储：只复制上次转储后发生变化的文件或数据块（复制部分）。 3、差量转储：对最近一次完全转储以来发生变化的数据进行转储。</p> 
<p>4、完全转储加增量转储：其中任何一次转储出现问题都会导致恢复的失败，同时恢复时间较长。 5、完全转储加差量转储：操作简单，恢复时间短。但是需要移动和存储更多数据。</p> 
<p>四、日志文件：<br> 1、以记录为单位的日志文件： 日志文件中有BEGIN TRANSACTION 记录，而没有COMMIT 或 ROLLBACK 执行 UNDO操作。 日志文件中既有BEGIN TRANSACTION 记录，也有 COMMIT 或 ROLLBACK 执行REDO操作。</p> 
<p>2、以数据块为单位的日志文件。</p> 
<p>什么时候使用日志文件：</p> 
<p>1、事务故障恢复和系统故障恢复必须使用日志文件。 2、在动态转储方式中必须建立日志文件。 3、在静态转储方式中，也可以使用日志文件。 检查点技术大幅度减少了数据库恢复时执行的日志恢复操作量。</p> 
<p>五、磁盘保护技术：<br> 1、RAID0：优点采用数据分块、并行传送方式，能够提高读写速度。缺点出现介质故障时无法恢复。 2、RAID1：提高了读速度，加强了系统的可靠性。缺点：硬盘的利用率低，冗余度为50%，同时写速度并未提高。 3、RAID5：磁盘空间利用率比RAID1高，存储成本相对较低。</p> 
<p>六、数据库镜像分类：<br> 1、双机互备援模式。 2、双机热备份模式。 3、三种实现方式：高可用性、高保护、高性能。</p> 
<h3>
<a id="12_753"></a>第12章、备份与恢复数据库</h3> 
<p>一、造成数据丢失的原因：<br> 1、存储介质故障。 2、用户的操作错误。 3、服务器故障。 4、由于病毒的侵害而造成的数据丢失或损坏。 5、由于自然灾害而造成的数据丢失或损坏。</p> 
<p>二、恢复模式：<br> 1、简单恢复模式： 只用于测试和开发数据库或只读数据库，不备份事务日志、 2、完整恢复模式： 完整记录所有的事务，备份日志文件。 3、大容量日志恢复模式： 完整恢复模式的附加模式。</p> 
<p>三、数据库备份：<br> 1、完整数据库备份（完全转储）： 备份所有。 2、差异数据库备份（差异转储）：备份最近一次完整数据库备份之后的数据。</p> 
<p>两种备份都备份在备份过程中用户对数据库进行的操作。</p> 
<p>四、文件备份：<br> 1、文件备份。 2、差异文件备份。</p> 
<p>五、事务日志备份：<br> 只备份日志记录。</p> 
<p>1、纯日志备份： 不包含大容量备份模式下执行的任何大容量更改的备份。 2、大容量操作日志备份： 不允许对大容量操作日志备份进行时点恢复。 3、结尾日志备份： 在出现故障时进行，用于防止丢失数据。</p> 
<p>ps：结尾日志备份可以防止数据丢失并确保日志链的完整性。 日志文件中包含恢复点或者希望移动或替换（覆盖）数据库，不一定需要结尾日志备份。</p> 
<p>六、常用备份策略：<br> 1、完整数据库备份 2、完整数据库备份加日志备份 3、完整数据库备份加差异数据库备份加日志备份</p> 
<p>七、实现备份：<br> 备份数据库与文件组：</p> 
<pre><code class="prism language-bash">backup database data_name to 备份设备 【with differential】 （进行差异备份，默认完全备份） 【disk <span class="token operator">|</span> tape 】指定磁盘文件或磁带设备
</code></pre> 
<p>备份日志：</p> 
<pre><code class="prism language-bash">backup log data_name to 备份设备 norecovrey
</code></pre> 
<p>实现还原：</p> 
<pre><code class="prism language-bash">restore database data_name
</code></pre> 
<h3>
<a id="13_797"></a>第13章、大规模数据库架构</h3> 
<p>一、分布式数据库：<br> 分布式数据库系统与分布式数据库的区别： 分布式数据库系统：物理上分散、逻辑上集中的数据库系统。 分布式数据库：是分布式数据库系统中各场地上数据库的逻辑集合。</p> 
<p>分布式数据库的12个目标：</p> 
<blockquote> 
 <p>1、本地治理。 2、非集中式管理。 3、高可用性。 4、位置独立性。 5、数据分片独立性。 6、数据复制独立性。 7、分布式查询处理。<br> 8、分布式事务管理。 9、硬件独立性。 10、操作系统独立性。 11、网络独立性。 12、数据库管理系统独立性。</p> 
</blockquote> 
<p>数据分布策略： <mark>先数据分片、后数据分配。</mark></p> 
<p>数据分片： <mark>水平分片、垂直分片、导出分片、混合分片</mark>。<br> 数据分配： <mark>集中式、分割式、全复制式、混合式</mark>。</p> 
<p>分布透明性：</p> 
<blockquote> 
 <p>1、分片透明性：最高级别、完全透明。<br> 2、位置透明性：指数据分片的分配位置对用户是透明的。<br> 3、局部数据模型透明性：不需要了解数据模型。</p> 
</blockquote> 
<p>分布式数据库查询代价： 由CPU代价和 I/0代价来衡量，要考虑站点间传输数据的通信代价。 导致数据传输量大的主要原因：数据间的连接操作和并操作。</p> 
<p>分布式事务管理： 恢复控制和并发控制。 恢复控制：基于二阶段的提交协议。 并发控制：基于封锁协议。</p> 
<p>2、并行数据库：<br> 体系结构： 1、共享内存结构：共享一个主存储器，实现简单、容易造成访问内存冲突。 2、共享磁盘结构：共享磁盘，会产生通信代价。 3、无共享结构：不共享任何资源。最好并行结构。缺点：通信代价和非本地磁盘访问的代价高。 4、层次结构：顶层无共享结构、底层共享内存或共享磁盘结构。</p> 
<p>数据划分： 1、轮转法：顺序扫描、评价分配、适合于扫描整个关系。缺点：不适于点查询 和 范围查询。 2、散列划分：适合点查询 。缺点：散列函数的选用。 3、范围划分：适合点查询和范围查询。但是会造成数据分布不均匀。</p> 
<p>3、云计算：</p> 
<blockquote> 
 <p>软件即服务（SaaS）：软件分配模式。<br> 平台即服务（PaaS）：通过网络提供操作系统和相关服务，无需下载或安装。<br> 基础设施即服务（IaaS）：将用于支持运作的设备对外提供服务。</p> 
</blockquote> 
<p>公共云： <mark>即用即付的方式提供给公众</mark>。<br> 私有云： <mark>不对公众开放的企业或组织内部数据中心的资源</mark>。</p> 
<p>目前主要的云计算平台： Amazon 的 AWS 、Goodle 的GAE 、开放的云计算平台Hadoop。</p> 
<p>云计算的缺点： <mark>1、数据安全问题。 2、对云的管理问题。 3、对因特网的依赖</mark>。</p> 
<p>Google开发的模型简化的大规模分布式数据库BigTable： 索引： 行关键字、列关键字、时间戳。共同定位。</p> 
<p>特点： 1、行关键字可以是任意的字符串。 2、列族是由列关键字组成的集合，是访问控制的基本单位。 3、时间戳记录BigTable中不同版本数据的时间标识。</p> 
<h3>
<a id="14__843"></a>第14章 数据仓库与数据挖掘</h3> 
<p>一、数据仓库：<br> 是一个面向主题的 、集成的 、非易失的 、且随时间变化的数据集合，用来支持管理人员的决策。</p> 
<p>体系结构： 操作型数据、操作型数据存储、数据仓库、数据集市、个体层数据（临时数据）。</p> 
<p>四个级别： 1、早期细节级：老化以后的细节数据。 2、当前细节级：经过集成后，进入当前细节级。 3、轻度综合级：对当前细节级进行轻度综合。 4、高度综合级：对当前细节级进行高度综合。</p> 
<p>粒度： 综合级别称为粒度。 粒度越小，细节程度越高，数据量越大。</p> 
<p>元数据： 描述数据的结构、内容、链、索引等内容。 技术型元数据： 描述关于数据仓库技术细节的数据。 业务型元数据： 从业务角度描述了数据仓库中的数据。</p> 
<p>ODS： 面向主题的、集成的、可变的、数据是当前或接近当前的。</p> 
<p>ODS I： 第一类秒级。 ODS II：第二类小时级。 ODS III：第三类天级。 ODS IV：第四类根据数据来源方法和类型划分。</p> 
<p>数据仓库的设计过程： 概念模型设计、技术评估、环境准备工作、 逻辑模型设计、物理模型设计、数据生成与应用实现、数据仓库运行与维护。</p> 
<p>数据仓库的更新维护： 维护策略： 实时维护：触发条件：数据源进行数据的更新操作。（软硬件性能要求很高，难以实现） 延时维护：触发条件：数据发生变化后首次进行查询操作。（视图查询时间相对比较长） 快照维护：触发条件：时间。（通常无法提供最新的数据，广泛使用）</p> 
<p>二、OLAP<br> 多维分析的基本操作： 1、钻取与卷起。 2、切片与切块。 3、旋转。</p> 
<p>OLAP的实现方式： 1、基于多维数据库的OLAP（MOLAP）。 2、基于关系数据库的OLAP（ROLAP）。 3、混合型的OLAP（HOLAP）。</p> 
<p>三、数据挖掘：<br> 三阶段： 数据准备、数据挖掘、结果解释评估。</p> 
<p>关联规则挖掘： 1、支持度： 两者都买，占总数据仓库的百分比。 2、置信度： 两者都买，占其中买X的百分比。（买了X中有多少人买了Y的百分比）</p> 
<p>分类挖掘： 构造方法：统计方法、机器学习方法、神经网络方法。</p> 
<p>聚类挖掘： 使得每一组内的数据尽可能的相似而不同组间的数据尽可能的不同。 包括：统计方法、机器学习方法、神经网络方法、面向数据库的方法。</p> 
<p>常见的创建语句：</p> 
<blockquote> 
 <p>CREATE DATABASE -----&gt; 创建数据库<br> CREATE PARTITION FUNCTION -----&gt; 创建分区表<br> CREATE UNQUE CLUSTERED | NONCLUSTERED -----&gt; 创建索引<br> CREATE PROC -----&gt;创建存储过程<br> CREATE FUNCTION -----&gt; 创建标量|内联表值|多语句表值函数<br> CREATE TRIGGER -----&gt; 创建触发器</p> 
</blockquote> 
<p>事务的几种性质：<br> 1、一致性： 2、完整性： 3、可串行性：两段锁协议保证</p> 
<p>遗忘：<br> 1、触发器通常用于保证业务规则和数据完整性。 2、与触发器相关的两张表使用大写（傻逼软件不区分大小写）</p> 
<p>数据库设计各阶段所包含的内容：<br> 逻辑设计阶段： 数据库逻辑结构设计、数据库事务概要设计、应用程序概要设计 概念设计阶段： 系统总体框架设计 物理设计阶段： 数据库逻辑模式调整、文件组织与存取设计、数据分布设计、安全模式设计、确定系统配置、物理模式评估 数据库运行和维护阶段： 日常维护、监控与分析、性能优化与调整、系统进化。 数据库实现和部署阶段： 创建数据库、数据装载、应用程序的编码和调试、数据库的试运行</p> 
<p>数据库应用系统设计的四个层次：<br> 1、表示层： 2、业务逻辑层： 3、数据访问层： 4、数据持久层： 设计工作属于数据组织与存储等方面的物理设计内容（包括索引设计），属于物理设计阶段</p> 
<p>最后大题：</p> 
<blockquote> 
 <p>一、针对数据库系统本身及网络传输过程中可能的一些调优方案：<br> 1、把数据、日志、索引放到不同的I/O设备上，增加读取速度，数据量越大，提高I/O越重要。 2、纵向、横向分割表，减少表的尺寸。<br> 3、升级硬件，扩大服务器的内存，增加服务器CPU个数。<br> 4、重建索引，收缩数据和日志，设置自动收缩日志，对于大的数据库不要设置数据库自动增长，它会降低服务器的性能。 5、优化锁结构。</p> 
</blockquote> 
<p>二、SQL查询语句优化方案：</p> 
<blockquote> 
 <p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where 及 order by 涉及的列上建立索引。<br> 2、应尽量避免在where子句中使用 != 或 &lt; &gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。<br> 3、任何地方都不要使用select * from进行全表扫描，用具体的字段列表代替 “ * ” ，不要返回冗余字段。<br> 4、避免频繁创建和删除临时表，以减少系统表只有的消耗。<br> 5、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。<br> 6、尽量避免大事务操作，提高系统并发能力。</p> 
</blockquote> 
<p>三、对使用UNION 对大量数据进行查询的优化方法：</p> 
<blockquote> 
 <p>使用 union all 替代 union 进行合并查询，原因是union会自动压缩多个结果集中重复的数据（删除合并后重复的数据），而union all 则将所有的结果显示出来，减少了操作量。</p> 
</blockquote> 
<p>四、磁盘阵列 RAID 的特点和选择：<br> 三种RAID的特点与区别：</p> 
<ul>
<li>RAID 0 :采用数据分块，并行传输方式，能够提高读写速度。但是由于没有冗余备份，所有数据可靠性低（其中一个硬盘介质出现问题时，则无法恢复）。</li>
<li>RAID 1： 增加了镜像（冗余数据），所以数据 读速度提高（可以同时从原数据和冗余数据中读取），可靠性增加。硬盘利用率低（毕竟冗余数据占用50%）。</li>
<li>RAID 5： 只比RAID 0 增加了一个奇偶校验信息。</li>
</ul> 
<p>总的来说：RAID 0 <mark>单纯提高了性能</mark>，但是缺少数据可靠性。 RAID 1 <mark>提高了数据可靠性和读速度，但是CPU占用率高，磁盘利用率低</mark>。 RAID 5<mark>则是一种存储性能、数据安全和存储成本兼顾的方法</mark>。</p> 
<p>PS:附上博主考试通过的证书照片<br> <img src="https://images2.imgbox.com/68/2f/tPn4g721_o.png" alt="在这里插入图片描述"></p> 
<p>至此，数据库三级的相关知识点就汇聚完毕了，这个文档里边会不少于50分，后边大题这里边要背的SQL语句关键字也有，把这个文档搞清楚，基本上数据库三级考试也差不多。祝各位考生顺利通过计算机三级考试！！！</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>