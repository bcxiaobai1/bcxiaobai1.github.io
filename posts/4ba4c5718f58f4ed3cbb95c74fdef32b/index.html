<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>GCP 上的人工智能实用指南：第三、四部分 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GCP 上的人工智能实用指南：第三、四部分</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-tomorrow-night">
                    
                        
                    
                    <blockquote> 
 <p>原文：<a href="https://b-ok.global/book/5558575/8c32a0">Hands-On Artificial Intelligence on Google Cloud Platform</a></p> 
 <p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p> 
 <p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p> 
 <p>本文来自<a href="https://github.com/apachecn/apachecn-dl-zh">【ApacheCN 深度学习 译文集】</a>，采用<a href="https://cn.bing.com/search?q=%E8%AF%91%E5%90%8E%E7%BC%96%E8%BE%91">译后编辑（MTPE）</a>流程来尽可能提升效率。</p> 
 <p>不要担心自己的形象，只关心如何实现目标。——《原则》，生活原则 2.3.c</p> 
</blockquote> 
<h1>
<a id="_3_Google_Cloud_Platform__TensorFlow_12"></a>第 3 节：Google Cloud Platform 上的 TensorFlow</h1> 
<p><strong>张量处理单元</strong>（<strong>TPU</strong>）是 <strong>Google Cloud Platform</strong>（<strong>GCP</strong>）上高性能 AI 应用的基本构建块。 在本节中，我们将重点介绍 GCP 上的 TensorFlow。 本节包含三章。 我们将深入介绍 Cloud TPU，以及如何利用它们来构建重要的 AI 应用。 我们还将通过利用 Cloud TPU 构建预测应用，使用 Cloud ML Engine 实现 TensorFlow 模型。</p> 
<p>本节包括以下章节：</p> 
<ul>
<li>“第 7 章”，“了解云 TPU”</li>
<li>“第 8 章”，“使用 Cloud ML Engine 实现 TensorFlow 模型”</li>
<li>“第 9 章”，“构建预测应用”</li>
</ul> 
<h1>
<a id="_TPU_22"></a>七、了解云 TPU</h1> 
<p>任何平台都只能发挥其优势。 利用 <strong>Google Cloud Platform</strong>（<strong>GCP</strong>）之类的平台，最重要的方面是将其投入运营，来处理业务的日常工作量。 在本章中，我们将看到在 GCP 上运行<strong>人工智能</strong>（<strong>AI</strong>）的一些最佳实践和实用技巧。 我们将了解<strong>张量处理单元</strong>（<strong>TPU</strong>）以及 TPU 如何在内部运行以促进大规模并行计算需求，以便构建利用<strong>机器学习</strong>（<strong>ML</strong>）模型的各种服务。</p> 
<p>本章将涵盖以下主题：</p> 
<ul>
<li>云 TPU 及其组织简介</li>
<li>软硬件架构图</li>
<li>将 TPU 用于模型开发的最佳实践</li>
<li>使用<code>TPUEstimator</code>训练模型</li>
<li>设置 TensorBoard 以分析 TPU 性能</li>
<li>表现指南</li>
<li>了解抢占式 TPU</li>
</ul> 
<h1>
<a id="_TPU__36"></a>云 TPU 及其组织的简介</h1> 
<p>TPU 是在 GCP 上构建各种服务和 ML 模型的基本构建块。 为了充分利用该平台，我们需要了解 TPU 的核心概念。 这些核心概念将帮助我们优化性能，并使我们能够最大程度地利用为该帐户分配的计算资源。</p> 
<p>Google 已经开发了 TPU，以加速 ML 工作流程。 借助 Cloud TPU，用户可以使用 TensorFlow 在 Google 的 Cloud TPU 硬件上运行其 ML 工作流。 用户可以使用 TPU（特别是线性代数算法）获得最大的性能提升。 TensorFlow 计算集群可以利用<strong>中央处理器</strong>（<strong>CPU</strong>），<strong>图形处理器</strong>（<strong>GPU</strong>）和 TPU 来构建。 在本章的后面，我们将详细讨论可以使用 TPU 并可以带来巨大好处的领域。</p> 
<p>现在，让我们快速检查一下 Cloud TPU 可用的区域。 这将帮助您确定最近的模型部署区域：</p> 
<ul><li>
<strong>在美国地区的可用性</strong>：在撰写本章时，TPU 在美国和欧洲地区普遍可用。 以下屏幕快照所示的表格中列出了美国地区的一般可用性：</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VnW8XIra-1681704646231)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/0a0c53f2-0ef6-4895-af9f-fd053255c82e.png)]</p> 
<p><strong>TFRC</strong> 是 <strong>TensorFlow 研究云</strong>的缩写。</p> 
<ul><li>
<strong>在欧洲地区的可用性</strong>：在以下屏幕快照中显示的表格中列出了欧洲区域的一般可用性：</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c53kRYD0-1681704646232)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/0219c1ae-d96b-41fb-8efc-3cc64583d3bd.png)]</p> 
<ul><li>
<strong>在亚洲地区的可用性</strong>：此外，GCP 在亚洲地区也正在扩展，在撰写本章时，其可用性有限，如以下屏幕快照所示。 预计随着 GCP 在整个地理区域中采用率的提高，亚洲地区的可用性也会有所提高：</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-obS9SDJj-1681704646232)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/14f37ddf-23ad-4e31-a1d6-6536231227bc.png)]</p> 
<p>应用可以通过<strong>虚拟私有云</strong>（<strong>VPC</strong>）网络从实例，容器和 AI 服务访问 TPU 节点。 下表概述了访问 GCP 上的 TPU 节点的方法：</p> 
<ul>
<li> <p>Compute Engine 上的 Cloud TPU 非常适合需要它来管理自己的 Cloud TPU 服务的用户； 通常，建议使用 Google Cloud 的用户，因为它具有 CTPU 工具，可以为用户完成基本的后台工作，例如设置虚拟机，云存储服务和 TPU。</p> </li>
<li> <p>当您需要在应用中进行自动扩展，灵活地更改硬件（CPU，GPU 和 TPU 之间），虚拟机的自动管理以及<strong>无类别域间路由</strong>（<strong>CIDR</strong>）时，可以使用 Kubernetes Engine 上的 Cloud TPU 块范围，更重要的是，是一个容错应用。</p> </li>
<li> <p>经验丰富的 ML 程序员应使用 AI 服务上的 Cloud TPU，他们可以利用 GCP 提供的托管 AI 服务。 AI 服务为用户管理 AI 工作流中的许多活动，例如在用户数据上训练 ML 模型，部署模型，预测监控和模型管理。</p> </li>
</ul> 
<p>现在，我们对 TPU 有了基本的了解，让我们看一下 TPU 的使用领域和优势。</p> 
<p>以下屏幕快照描述了硬件使用的区域，即 CPU，GPU 和 TPU：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HYbM3Mik-1681704646233)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/cd327b5d-e58e-4a3a-ba59-d2c0715d71e7.png)]</p> 
<p>从前面的屏幕快照可以明显看出，我们需要在用例和当前问题的背景下进行思考，然后才能在 CPU，GPU 和 TPU 之间做出选择。 具有由矩阵计算控制的大量训练和评估数据的超大型模型最适合在 TPU 上进行训练。</p> 
<h1>
<a id="_TPU__73"></a>使用 TPU 的优势</h1> 
<p>在 ML 算法中，通常使用线性代数计算。 TPU 使这种计算的性能最大化； 可以在很短的时间内在 TPU 上训练在 GPU 上花费大量时间的模型。 此外，对于<strong>卷积神经网络</strong>（<strong>CNN</strong>）模型，Cloud TPU 大大缩短了达到准确率的时间。 如果您拥有适用于 Cloud TPU 的应用，则可以在很短的时间内以非常低的成本获得最大的输出。</p> 
<p>以下屏幕快照显示了用于训练 ResNet 50 模型的 GPU 和 TPU 的快速比较。 ResNet 50 是一个 CNN 模型，已经对 ImageNet 数据库中的一百万幅图像进行了训练。 已经观察到，如果用户使用八个 v100 GPU 和一个完整的 Cloud TPU v2 pod，则训练时间和成本都会大大降低。 虽然训练速度提高了 27 倍，但成本也降低了 38%。</p> 
<p>以下屏幕截图比较了在 GPU 和 TPU 上进行训练的成本：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q38eIkTB-1681704646233)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/4f7f085c-5a06-4299-ba83-56d89e43c77c.png)]</p> 
<p>图 7.1 训练费用比较</p> 
<p>从前面的屏幕快照可以明显看出，TPU 可以为复杂的模型训练工作节省大量成本。 在一段时间内进行多次部署后，节省的成本变得更加重要，尤其是在生产部署场景中，该场景中需要经常训练模型。</p> 
<h1>
<a id="_87"></a>软硬件架构图</h1> 
<p>为了进一步加速数学计算，创建了专用硬件作为<strong>专用集成电路</strong>（<strong>ASIC</strong>）。 这样，尤其是在<code>n</code>-多维数学中，计算能力得到了倍增。 在本节中，我们将详细介绍 TPU 及其相关组件的软件和硬件架构。</p> 
<h1>
<a id="_TPU__91"></a>可用的 TPU 版本</h1> 
<p>每个 TPU 版本都包含一些主要组件，这些组件构成了 TPU 的功能。 在讨论 TPU 版本时，我们将看一下 TPU 内核的架构和 TPU 内核的<strong>高带宽存储器</strong>（<strong>HBM</strong>）。 我们将了解每个 TPU 设备上的内核如何互连以及如何将网络接口用于设备间通信。</p> 
<p>下表显示了 TPU v2 的特征：</p> 
<ul>
<li>每个 TPU 内核 TPU v2 的 HBM 为 8 GB。</li>
<li>每个内核具有一个<code>128 * 128</code>的<strong>矩阵单元</strong>（<strong>MXU</strong>）。</li>
<li>一个 TPU 盒最多可具有 512 个内核和 4 TB 的总内存。</li>
</ul> 
<p>下图显示了 TPU v2 的组织：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AS4jgSfs-1681704646233)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/7c253d7c-52ae-4193-ab67-f78a5e27fbab.png)]</p> 
<p>图 7.2 TPU V2 特性</p> 
<p>下表显示了 TPU v3 的特征：</p> 
<ul>
<li>每个 TPU 内核 TPU v3 的 HBM 为 16 GB。</li>
<li>每个内核具有两个<code>128 * 128</code>的 MXU。</li>
<li>一个 TPU 盒最多可具有 2,048 个内核和 32 TB 的总内存。</li>
</ul> 
<p>下图显示了 TPU v3 的组织：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1EAH3BiW-1681704646234)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/0aa7c8da-97d5-4b5e-a650-82f12926b9d5.png)]</p> 
<p>图 7.3 TPU 的组织</p> 
<p>每个 TPU 内核均由标量单元，向量单元和 MXU 组成。 TPU 芯片以 MXU 计算能力为后盾。 在一个周期内，MXU 可以执行 16,000 个<strong>乘积</strong>（<strong>MAC</strong>）操作。 MXU 输入和输出是 32 位浮点值，但是它以<code>bfloat16</code>精度执行乘法以提高精度。 每个内核可以独立执行用户操作，并且通过高带宽互连可以与其他芯片进行通信。 对于大型 ML 工作负载，可以将多个 TPU 设备与高速网络接口互连，以获得大量的 TPU 内核和内存。</p> 
<h1>
<a id="_TPU_v2_TPU_v3__121"></a>与 TPU v2 相比，TPU v3 的性能优势</h1> 
<p>正如我们在本书前面所看到的，与 TPU v2 相比，TPU v3 具有更多的 <strong>TeraFlops</strong>（<strong>TFLOPS</strong>）和内存。 因此，肯定有一些地方 TPU v3 可以获得比 TPU v2 更好的结果。 要确定要使用的 TPU 版本，可以在可用版本上运行模型，并使用 TensorBoard 检查性能。</p> 
<p>以下是 TPU v3 可以改善的一些方面：</p> 
<ul>
<li>受计算限制的模型在 TPU v3 上具有显着的优势。</li>
<li>数据不适合 TPU v2 内存但适合 TPU v3 内存的情况会有所帮助。</li>
<li>批量大小不适合 TPU v2 的新模型可以再次获得性能优势。</li>
<li>在某些区域中，模型是输入绑定的，或者模型是内存绑定的； 在那里，您可能看不到这种性能提升。 因此，在确定 TPU 版本之前，请在预期用例的背景下进行性能基准测试和成本值分析。</li>
</ul> 
<h1>
<a id="_TPU__132"></a>可用的 TPU 配置</h1> 
<p>让我们讨论 Google 提供的不同类型的 TPU 配置。</p> 
<p>Google 提供了两种不同类型的配置，用户可以在两个 TPU 版本中利用它们。 它们如下：</p> 
<ul>
<li>
<strong>单设备 TPU</strong>：这些是执行所有操作的单独设备。 这些设备未通过网络与其他 TPU 设备互连。 实际上，一个以上的单个 TPU 设备无法通过网络连接到另一设备。</li>
<li>
<strong>TPU 盒</strong>：TPU 盒不过是群集，其中有多个 TPU 设备通过高速网络与另一台设备互连。</li>
</ul> 
<p>下图描述了单个 TPU 设备，因为它不连接到另一个 TPU 设备，因此不需要高速网络带宽。 TPU 节点仅连接到一个 TPU 设备。 TPU 中的芯片已经互连，不需要主机 CPU 或主机网络资源：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FV6BG50x-1681704646234)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/b91e08d1-63df-49cb-bf6d-1db860781c52.png)]</p> 
<p>图 7.4 单设备 TPU</p> 
<p>上图中的设备正在使用 Cloud TPU v3，但是在设置节点时，您可以指定任何 TPU 版本。 我们将在“软件架构”部分中讨论流程。 以下屏幕快照描绘了一个 TPU 盒，其中多个 TPU 设备通过高速网络连接进行连接：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4kZLQwb5-1681704646234)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/c0154d1a-5abb-4379-a5a2-37e6f85b5ab1.png)]</p> 
<p>图 7.5 TPU 盒</p> 
<p>在上图中，请注意以下几点：</p> 
<ul>
<li>主机正在不同的 TPU 设备上分配 ML 工作流。</li>
<li>TPU 中的芯片已经互连，不需要主机 CPU 或主机网络资源。</li>
<li>由于 TPU 设备通过高速带宽网络连接，因此它们也不需要主机 CPU 或主机网络资源。</li>
</ul> 
<p>上图中的设备正在使用 Cloud TPU v2，但是在设置节点时，可以指定任何 TPU 版本。 在创建 TPU 节点时，我们还可以指定是占用全部 TPU 还是部分 TPU 吊舱。 可以使用 Cloud TPU API 自动化 TPU 节点的 TPU 管理，这极大地有助于扩展集群和管理工作负载。</p> 
<h1>
<a id="_161"></a>软件架构</h1> 
<p>在本节中，我们将看到运行应用时在软件方面发生的情况。</p> 
<p><strong>TPU 软件架构的流程</strong>：TensorFlow 生成计算图，并通过 <strong>gRPC 远程过程调用</strong>（<strong>gRPC</strong>）。 根据您选择的 TPU 的类型和可用于工作负载的设备数量，TPU 节点会及时编译计算图，并将二进制文件发送到一个或多个可用的 TPU 设备。</p> 
<p>下图描述了 TPU 软件架构的软件组件块。 它由 ML 模型，<code>TPUEstimator</code>， <strong>TensorFlow 客户端</strong>， <strong>TensorFlow 服务器</strong> 和 <strong>XLA 即时（JIT）编译</strong>组成：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-m4R5dMDD-1681704646234)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/b3c22eb1-bc71-4c74-b8e4-fa6fbb9eb189.png)]</p> 
<p>图 7.6 TPU 的软件组件块</p> 
<p>让我们详细讨论每个组件，如下所示：</p> 
<ul>
<li>
<strong><code>TPUEstimator</code></strong>：<code>TPUEstimator</code>简化了 Cloud TPU 的模型构建，以提取最大的 TPU 性能。 <code>TPUEstimator</code>是基于估计器的高级 API。 <code>TPUEstimator</code>将 ML 程序转换为 TensorFlow 操作。 对于使用 Cloud TPU 的 ML 模型，绝对应该使用<code>TPUEstimator</code>。</li>
<li>
<strong>TensorFlow 客户端</strong>：TensorFlow 客户端将 TensorFlow 操作转换为计算图，然后通过 gRPC 发送到 TensorFlow 服务器。</li>
<li>
<strong>TensorFlow 服务器</strong>：TensorFlow 服务器在 Cloud TPU 服务器上运行。 当 TensorFlow 服务器从 TensorFlow 客户端接收到计算图时，它将从所需的存储中加载输入。 它将图划分为多个块，应在 TPU 和 CPU 上运行。 它生成<strong>加速线性代数</strong>（<strong>XLA</strong>）操作，以便在 Cloud TPU 上运行子图，并调用 XLA 编译器。</li>
<li>
<strong>XLA 编译器</strong>：XLA 是<strong>即时</strong>（<strong>JIT</strong>）编译器。 TensorFlow 服务器产生 XLA 编译器视为输入的操作。 XLA 生成在 Cloud TPU 上运行的二进制代码，包括从片上存储器到硬件执行单元的数据编排以及芯片间通信。 Cloud TPU 使用 Cloud TPU 服务器和 Cloud TPU 之间的<strong>外围组件互连快速</strong>（<strong>PCIe</strong>）连接来加载二进制代码，然后启动执行。</li>
</ul> 
<h1>
<a id="_TPU__180"></a>使用 TPU 的模型开发的最佳实践</h1> 
<p>在本节中，我们将讨论如何在 Cloud TPU 上开发模型以最大化模型表现并优化利用硬件。</p> 
<p>让我们快速看一下 TPU 芯片配置。 单个 TPU 芯片包含两个内核，每个内核具有多个 MXU。 正如我们所讨论的，MXU 非常适合执行密集矩阵乘法和卷积的程序。 因此，对于此类程序，我们绝对应该考虑使用 TPU 并利用其硬件。 未执行矩阵乘法并且执行诸如<code>add</code>之类的操作的程序将不会有效地使用 MXU。 在以下小节中，我们将介绍一些准则，这些准则将帮助您决定是否应使用 TPU，并告知您如何开发模型以从中获得最佳性能。</p> 
<h1>
<a id="_TPU__186"></a>在 TPU 上进行模型开发的指导原则</h1> 
<p>为了充分利用硬件程序，您应该利用所有可用的内核，因为这会增加模型训练的时间（每个 TPU 设备包含四个芯片和八个内核）。 这可以使用<code>TPUEstimator</code>来实现。 它提供了一个图运算符，可帮助构建和运行副本。 每个副本都是在每个核心上运行的训练图，并且实质上是批量大小的八分之一。</p> 
<p>布局和形状是获得性能提升的非常重要的方面。 当 XLA 编译器转换代码时，它包括将矩阵平铺为多个小块。 这样可以提高 MXU 的使用效率。 由于 MXU 为<code>128 * 128</code>，因此它希望平铺应为 8 的倍数。有些适用于平铺的矩阵，而有些则需要重塑。 这些是内存绑定操作。 形状恒定的模型适合 TPU，而形状变化的模型不适合 Cloud TPU，因为重新编译形状会减慢处理速度。</p> 
<p>对于高性能的 Cloud TPU 程序，应将密集的计算轻松地分为<code>128 * 128</code>的倍数。XLA 编译器使用填充选项。XLA 编译器未完全利用 MXU 时，将张量填充零。 您可以通过<code>op_profile</code>看到 XLA 编译器应用的填充。 通常，填充有助于提高性能，但也有两个缺点。 应用填充意味着未充分利用 MXU，并且由于它增加了张量所需的片上存储空间，因此有时可能会导致内存不足错误。 因此，选择正确的尺寸对于最小化/避免填充非常重要。</p> 
<p>张量尺寸应该非常谨慎地选择，因为它在从 MXU 中提取最大性能方面起着重要作用。 XLA 编译器使用批量大小或尺寸来获得 MXU 的最佳性能。 因此，任何一个都应该是 128 的倍数。如果都不是 128 的倍数，则编译器应该填充 1 到 128。可以从 MXU 中获得最大的性能，因为它的批量大小和 TPU 是 8 的倍数。</p> 
<h1>
<a id="TPUEstimator_196"></a>使用<code>TPUEstimator</code>训练模型</h1> 
<p>在本节中，我们将讨论训练模型时<code>TPUEstimator</code>的用法和优点。</p> 
<p><code>TPUEstimator</code>吸收了许多底层的，特定于硬件的细节，并简化了在 Cloud TPU 上运行的模型。 <code>TPUEstimator</code>在内部执行许多优化以增强模型的性能。 使用<code>TPUEstimator</code>编写的模型可以跨不同的硬件运行，例如 CPU，GPU，TPU 吊舱和单个 TPU 设备，大多数情况下无需更改代码。</p> 
<h1>
<a id="_TensorFlow__API_202"></a>标准 TensorFlow 估计器 API</h1> 
<p>TensorFlow Estimator 提供了一个用于训练，评估，运行和导出服务模型的 API，如下表所示。 对于估计器，您应该编写与 TensorFlow 图的模型和输入部分相对应的<code>model_fn</code>和<code>input_fn</code>函数。 让我们看一下以下屏幕截图：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-myLSCY2k-1681704646235)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/dca5bd5a-3b58-4829-8a81-dea7e6accb9f.png)]</p> 
<p>图 7.7 TensorFlow API</p> 
<p>除了上述功能之外，TensorFlow Estimator 还包括其他一些常见功能，例如工作训练，检查点功能等。</p> 
<h1>
<a id="TPUEstimator_212"></a><code>TPUEstimator</code>编程模型</h1> 
<p>GCP 为<code>TPUEstimator</code>编程提供了一致的模型。 以下是有关模型的详细信息：</p> 
<ul>
<li> <p><code>TPUEstimator</code>使用<code>model_fn</code>，它包装计算并将其分配到所有 Cloud TPU 内核。 为了获得最佳性能，应根据批量大小调整学习率。</p> </li>
<li> <p>跨 TPU 进行计算的复制和分发由<code>model_fn</code>完成。 您必须确保计算仅包含 Cloud TPU 支持的操作。</p> </li>
<li> <p>通过<code>input_fn</code>函数对在远程主机 CPU 上运行的输入管道进行建模。</p> </li>
<li> <p>输入操作应使用<code>tf.data</code>进行编程。</p> </li>
<li> <p>每次调用都会将全局批量的输入处理到一个设备上。 碎片批量大小是从[<code>'batch_size'</code>]参数中获取的。 确保返回数据集而不是张量以获得最佳性能。</p> </li>
<li> <p>应用代码始终在客户端上运行，而工作程序执行 TPU 计算。</p> </li>
<li> <p>为了获得良好的性能输入管道，操作始终放在远程工作器上，只有<code>tf.data</code>支持它。</p> </li>
<li> <p>为了摊销 TPU 的启动成本，模型训练步骤包含在<code>tf.while_loop</code>中，到目前为止，<code>tf.while_loop</code>仅可以包装<code>tf.data</code>。 因此，正是出于这两个原因，必须使用<code>tf.data</code>。</p> </li>
</ul> 
<h1>
<a id="TPUEstimator_226"></a><code>TPUEstimator</code>概念</h1> 
<p>基本上，TensorFlow 程序可以使用图内复制和图间复制。 为了运行 TensorFlow 程序，<code>TPUEstimator</code>使用图内复制。 稍后，我们将介绍图内复制和图间复制之间的区别。</p> 
<p>TensorFlow 会话主服务器不在<code>TPUEstimator</code>中本地运行。 我们的程序创建了一个图，该图被复制到 Cloud TPU 中的所有可用核心，并且 TensorFlow 会话主服务器设置为第一个工作服务器。 输入管道位于远程主机上，因此训练示例可以快速提供给 Cloud TPU。 Cloud TPU 工作器之间发生同步操作； 也就是说，每个工作器都在同一时间执行相同的步骤。</p> 
<h1>
<a id="_TensorFlow_TPUEstimator_232"></a>从 TensorFlow 估计器转换为<code>TPUEstimator</code>
</h1> 
<p>当您转换为任何其他工具时，请确保从一个小例子开始，然后再处理一个复杂的例子。 这有助于熟悉任何工具的基本概念。</p> 
<p>要将<code>tf.estimator.Estimator</code>类转换为使用<code>tf.contrib.tpu.TPUEstimator</code>，您将需要执行以下步骤：</p> 
<ol>
<li> <p>将<code>tf.estimator.RunConfig</code>更改为<code>tf.contrib.tpu.RunConfig</code>。</p> </li>
<li> <p>设置<code>TPUConfig</code>以指定<code>iterations_per_loop</code>。 训练循环的指定迭代次数由 Cloud TPU 执行，然后返回主机。 在运行所有 Cloud TPU 迭代之前，不会保存检查点或摘要。</p> </li>
<li> <p>在<code>model_fn</code>中，使用<code>tf.contrib.tpu.CrossShardOptimizer</code>包装优化器，如以下代码所示。 您必须将<code>tf.estimator.Estimator</code>更改为<code>tf.contrib.tpu.TPUEstimator</code>才能转换为<code>TPUEstimator</code>：</p> </li>
</ol> 
<pre><code class="prism language-py">optimizer <span class="token operator">=</span> tf<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>tpu<span class="token punctuation">.</span>CrossShardOptimizer<span class="token punctuation">(</span>
 tf<span class="token punctuation">.</span>train<span class="token punctuation">.</span>GradientDescentOptimizer<span class="token punctuation">(</span>learning_rate<span class="token operator">=</span>learning_rate<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>默认值<code>RunConfig</code>在每 100 个步骤后为 TensorBoard 保存摘要，并每 10 分钟写入一个检查点。</p> 
<h1>
<a id="_TensorBoard__TPU__250"></a>设置 TensorBoard 来分析 TPU 性能</h1> 
<p>分析任何应用的性能都是至关重要的，TensorBoard 可帮助可视化和分析 Cloud TPU 的性能。 使用 TensorBoard，您不仅可以监视您的应用，还可以通过应用 TensorBoard 提供的建议来提高其性能。</p> 
<p>设置 Cloud TPU 之后，您应该安装最新版本的 Cloud TPU 分析器以创建<code>capture-tpu-profile</code>脚本。 以下是运行 TensorBoard 的步骤：</p> 
<ol>
<li>打开一个新的 Cloud Shell 以启动 TensorBoard。</li>
<li>运行以下命令来设置所需的环境变量，并为您的云存储桶和模型目录创建环境变量。 模型目录变量（<code>MODEL_DIR</code>）包含 GCP 目录的名称，该目录在模型训练期间存储检查点，摘要和 TensorBoard 输出。 以下代码显示了带有可用于设置 TensorBoard 的参数的命令：</li>
</ol> 
<pre><code class="prism language-py">$ ctpu up ctpu up <span class="token operator">-</span><span class="token operator">-</span>name<span class="token operator">=</span><span class="token punctuation">[</span>Your TPU Name<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span>zone<span class="token operator">=</span><span class="token punctuation">[</span>Your TPU Zone<span class="token punctuation">]</span>

$ export STORAGE_BUCKET<span class="token operator">=</span>gs<span class="token punctuation">:</span><span class="token operator">//</span>YOUR STORAGE BUCKET NAME
$ export MODEL_DIR<span class="token operator">=</span>$<span class="token punctuation">{<!-- --></span>STORAGE_BUCKET<span class="token punctuation">}</span><span class="token operator">/</span>MODEL DIRECTORY
</code></pre> 
<p>TensorBoard 跟踪可以通过两种方式查看：</p> 
<ul>
<li>静态跟踪查看器</li>
<li>流式跟踪查看器</li>
</ul> 
<p>如果每个 TPU 需要超过一百万个事件，则必须使用流式跟踪查看器。</p> 
<p>让我们检查一下如何启用静态跟踪查看器。</p> 
<ol start="3"><li>在用于设置环境变量（在上一步中设置）的同一 Cloud Shell 中运行以下命令：</li></ol> 
<pre><code class="prism language-py">$tensorboard <span class="token operator">-</span><span class="token operator">-</span>logdir<span class="token operator">=</span>$<span class="token punctuation">{<!-- --></span>MODEL_DIR<span class="token punctuation">}</span> <span class="token operator">&amp;</span>

</code></pre> 
<ol start="4"><li>在同一 Cloud Shell 的顶部，单击<code>Web Preview</code>并打开端口<code>8080</code>以查看 TensorBoard 输出。 要从命令行捕获输出，请运行以下命令：</li></ol> 
<pre><code class="prism language-py">$ capture_tpu_profile <span class="token operator">-</span><span class="token operator">-</span>tpu<span class="token operator">=</span><span class="token punctuation">[</span>YOUR TPU NAME<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span>logdir<span class="token operator">=</span>$<span class="token punctuation">{<!-- --></span>MODEL_DIR<span class="token punctuation">}</span>

</code></pre> 
<p>TensorBoard 提供以下功能：</p> 
<ul>
<li>TensorBoard 提供了各种选项来可视化和分析性能。</li>
<li>您可以可视化图并利用 Profiler 来提高应用的性能。</li>
<li>XLA 结构图和 TPU 兼容性图对于分析非常有用。</li>
<li>还有一些分析器选项，例如概述页面，输入管道分析器，XLA Op 配置文件，跟踪查看器（仅适用于 Chrome 浏览器），内存查看器，吊舱查看器和流式跟踪查看器（仅适用于 Chrome 浏览器）。 这些对于分析性能和调整应用非常有用。</li>
</ul> 
<h1>
<a id="_296"></a>性能指南</h1> 
<p>在开发模型时，非常重要的是要对其进行调整以使其获得良好的性能。 在本节中，我们将介绍一些技巧，这些技巧将帮助您提高模型在 Cloud TPU 上的性能。 这样，Cloud TPU 可以提供良好的性能，但是我们可以通过为应用设置正确的配置来增强它。</p> 
<p>在以下小节中，我们将讨论提高性能的重点领域。</p> 
<h1>
<a id="XLA__302"></a>XLA 编译器性能</h1> 
<p>XLA 编译器是标准 TensorFlow 代码库的一部分。 它是 ML 编译器，可以为 CPU，GPU，TPU 和其他一些平台生成二进制文件。 将 Cloud TPU 的 TensorFlow 模型转换为 XLA 图，然后 XLA 编译器将其转换为 TPU 可执行文件。 在这里，我们将注意到的一件事是 TPU 硬件不同于 CPU 和 GPU 硬件。</p> 
<p>CPU 具有少量高性能线程，而 GPU 具有大量高性能线程。 Cloud TPU 具有<code>128 * 128</code>个 MXU，它们可以作为单个非常高性能的线程执行，并且每个周期可以执行 16,000 次操作，或者以管道方式连接的<code>128 * 128</code>个微小线程。</p> 
<h1>
<a id="_308"></a>平铺的后果</h1> 
<p>Cloud TPU 中的数组是平铺的。 这要求将其中一个维度的填充填充为 8 的倍数，将另一个维度填充为 128 的倍数。XLA 执行数据布局转换，以将数据安排在内存中以进行有效使用。 这些转变是由试探法驱动的。 这对于大多数模型而言效果很好，但有时可能会出错。 为了获得最佳性能，应尝试不同的配置。</p> 
<p>以下是一些可以最大程度提高性能的非常重要的事情：</p> 
<ul>
<li>填充成本应降至最低。</li>
<li>批和特征尺寸的值应非常有效地选择。</li>
</ul> 
<h1>
<a id="_317"></a>融合</h1> 
<p>如果要组合执行多个操作，则 XLA 编译器将使用融合技术来优化程序。 融合操作是可以组合执行的多个操作的组合。</p> 
<p>例如，考虑以下一系列操作：</p> 
<pre><code class="prism language-py">tf_add <span class="token operator">=</span> tf<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
result <span class="token operator">=</span> tf<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>tf_add<span class="token punctuation">,</span> z<span class="token punctuation">)</span>
</code></pre> 
<p>在步骤中，此代码将像这样执行：</p> 
<ol><li>首先，循环将顺序访问元素并执行加法运算，结果将保存在<code>tf_add</code>中，并将其存储在临时存储器中，如以下代码块所示：</li></ol> 
<pre><code class="prism language-py"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 tf_add<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>现在，将再次访问加法结果并将其相乘，如下所示：</li></ol> 
<pre><code class="prism language-py"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 result <span class="token operator">=</span> tf_add<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用融合，数组访问会同时发生，如以下代码块所示：</p> 
<pre><code class="prism language-py"><span class="token comment">#In Fusion both addition and multiplication operations are performed together.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 result <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在此示例中，内存往返次数减少了，并且 XLA 不需要为<code>tf_add</code>分配任何空间。</p> 
<p>融合为 Cloud TPU 带来了许多好处，例如：减少了内存传输，优化了硬件利用率，等等。</p> 
<p>当两个形状相同的张量组合在一起时，广播将隐式发生，但是请注意，强制实现广播可能会导致性能下降。</p> 
<h1>
<a id="_TPU_361"></a>了解抢占式 TPU</h1> 
<p>可抢占的 TPU 是低成本 TPU，但其性能与按需 TPU 相同。 但是这里要注意的是，当 Google 需要资源用于其他目的时，总可以终止它。 让我们检查一下如何从控制台创建可抢占的 TPU。</p> 
<h1>
<a id="_TPU__365"></a>从控制台创建抢占式 TPU 的步骤</h1> 
<p>GCP 为创建可抢占的 TPU 提供了简单的界面。 涉及的步骤如下：</p> 
<ol><li>在 GCP 控制台上的 Compute Engine 下，选择<code>TPU</code>。 如果未启用 API，请单击<code>ENABLE</code>启用它，如以下屏幕截图所示：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qJ6diass-1681704646235)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/51279d69-8357-493f-b533-91eed4d727f8.png)]</p> 
<p>图 7.8 启用 Cloud TPU API</p> 
<ol start="2"><li>单击<strong>创建 TPU 节点</strong>，如以下屏幕截图所示：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vd0gP95g-1681704646235)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/06590ced-29a7-4f61-9c0a-530e73ae1a69.png)]</p> 
<p>图 7.9 创建 TPU 节点</p> 
<ol start="3"><li>填写所需的详细信息，选择<strong>可抢占性</strong>选项，然后单击<strong>网络，描述，标签</strong>链接，如以下屏幕截图所示：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RYGJMKVj-1681704646235)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/87e1324f-831d-4e34-952e-5253aacca1c9.png)]</p> 
<p>图 7.10 创建云 TPU</p> 
<ol start="4"><li>填写其他详细信息，然后单击屏幕底部的<strong>创建</strong>，如以下屏幕截图所示，您的 TPU 准备就绪：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-r9OQS0pL-1681704646236)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/9efa3b50-2775-44a1-bc4b-300ca93f8eeb.png)]</p> 
<p>图 7.11 创建 Cloud TPU 的其他详细信息</p> 
<h1>
<a id="_TPU__393"></a>抢占式 TPU 的定价</h1> 
<p>与按需 TPU 相比，可抢占 TPU 的价格约为价格的 30% 左右。 这里要注意的一点是，抢占式 TPU 的配额高于普通 TPU 的配额，而抢占式 TPU 具有单独的配额。 以下屏幕快照显示了 us-central1 区域中 v2-8 和 v3-8 的定价比较示例：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SDVGHuC1-1681704646236)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/fa8c6974-80bd-4f23-b3b9-58005ce4b913.png)]</p> 
<p>图 7.12 价格比较 v2-8 和 v3-5</p> 
<h1>
<a id="_TPU__401"></a>抢占式 TPU 的检测</h1> 
<p>如果已经创建了 TPU，并且我们必须检查它是否可抢占，则有相应的规定。 以下命令用于检测 TPU 是否可抢占：</p> 
<ul><li>
<code>ctpu</code>命令：运行以下命令检查已创建的 TPU 的详细信息。 在“TPU 可抢占”上打印的值指示 TPU 是否被抢占，<code>READY</code>值表示未抢占 TPU，而<code>PREEMPTED</code>值表示 TPU 已被抢占：</li></ul> 
<pre><code class="prism language-py">$ ctpu status
</code></pre> 
<ul><li>
<code>gcloud</code>命令：如果尚未指定区域，它将使用当前配置中的 compute 属性的值。 运行以下命令以检索项目中可用于 Cloud TPU 的计算区域列表：</li></ul> 
<pre><code class="prism language-py">$gcloud compute tpus <span class="token builtin">list</span>
</code></pre> 
<p>在决定使用 TPU 选项之前，请检查您的用例是否可以继续使用可抢占的 TPU，因为这样可以节省大量成本。</p> 
<h1>
<a id="_419"></a>总结</h1> 
<p>在本章中，我们获得了创建 TPU 并在其上编写模型的所有必需知识。 我们已经了解了 Cloud TPU 及其组织以及 Cloud TPU 软件和硬件架构的基础。 我们已经在 Google Cloud 上创建了 TPU 和可抢占的 TPU。 我们已经编写了模型并使用<code>TPUEstimator</code>对其进行了训练。 我们已经使用 TensorBoard 描述了 Cloud TPU。 除了学习所有这些，我们还通过了足够的技巧来编写优化的模型。</p> 
<p>在下一章中，我们将基于在实际项目上的经验，介绍在 GCP 上实现 TensorFlow 模型的最佳和行之有效的实践。</p> 
<h1>
<a id="_Cloud_ML_Engine__TensorFlow__425"></a>八、使用 Cloud ML Engine 实现 TensorFlow 模型</h1> 
<p><strong>Google Cloud Platform</strong>（<strong>GCP</strong>）上的 Cloud ML Engine 是一种无服务器方式，可用于构建机器学习管道。 该引擎利用基础平台组件，消除了对基础架构的配置和维护的需求。 数据科学家可以专注于数据，模型和预测。 这是在生产环境中启动并运行模型的理想且快速的方法。 该平台固有地提供了存储和计算弹性，并且几乎无限制地扩展了模型的训练和使用已部署的模型进行实时预测的能力。</p> 
<p>在本章中，我们将深入研究 Cloud ML Engine，并了解各种构建模块，并使用 TensorFlow 模型对机器学习管道进行实验。</p> 
<p>本章将涵盖以下主要主题：</p> 
<ul>
<li>了解 Cloud ML Engine 的组件</li>
<li>训练和利用 TensorFlow 模型涉及的步骤</li>
<li>在 Cloud ML Engine 中打包和部署您的训练应用</li>
<li>为您的训练工作选择正确的计算选项</li>
<li>监控您的 TensorFlow 训练模型作业</li>
</ul> 
<h1>
<a id="_Cloud_ML_Engine__439"></a>了解 Cloud ML Engine 的组件</h1> 
<p>首先，让我们了解 Cloud ML Engine 满足哪些机器学习工作流程单元。 Cloud ML Engine 可用于以下目的：</p> 
<ul>
<li>训练机器学习模型</li>
<li>部署训练有素的模型</li>
<li>将部署的模型用于预测</li>
<li>通过各种参数和 KPI 监视模型使用情况</li>
<li>模型管理以及版本控制</li>
</ul> 
<p>Cloud ML Engine 具有各种组件，它们执行独特的操作并在机器学习管道中发挥作用。 这些组件是服务组件，它们利用基础平台组件并利用所需的存储和计算量，具体取决于模型的复杂性和数据量。 这是 Cloud ML Engine 的组件。</p> 
<h1>
<a id="_451"></a>训练服务</h1> 
<p>训练服务模型提供了一些预定义的算法，这些算法可轻松用于训练而无需编写任何代码。 该算法可与训练数据一起使用，前提是该数据限于平台上可用算法内的预期方案。</p> 
<h1>
<a id="_455"></a>使用内置算法</h1> 
<p>在撰写本章时，Cloud ML Engine 支持以下算法：</p> 
<ul>
<li> <p><strong>线性学习器</strong>：此学习器算法使用 TensorFlow 估计器，<code>LinearClassifier</code>和<code>LinearRegressor</code>，可用于分类和回归问题。 该算法支持<strong>图形处理器</strong>（<strong>GPU</strong>）加速，以及默认的<strong>中央处理器</strong>（<strong>CPU</strong>）加速器。</p> </li>
<li> <p><strong>宽和深</strong>：这是一种旨在具有最佳级别的算法，用于存储训练数据并同时概括输入。 该算法对于分类，回归和排名问题很有用。 该算法支持 GPU 加速以及默认的 CPU 加速器。</p> </li>
<li> <p><strong>XGBoost</strong>：我们已经在“第 3 章”，“使用 XGBoost 的机器学习应用”中详细了解了此算法，Cloud ML Engine 提供了对该算法的内置包装器，并以并行的方式简化了两个阶段，即预处理和训练。 在预处理阶段，Cloud ML Engine 将分类数据和数字数据转换为统一的数据集，该数据集完全以数字格式表示。 该算法可轻松用于诸如点击率预测之类的用例。 GPU 加速器不支持该算法，并且只能与 CPU 一起使用。</p> </li>
</ul> 
<p>一旦确定了合适的算法，就需要对输入（训练，评估和生产）数据进行格式化，以匹配内置算法的预期模式。 数据需要以不带标题的<strong>逗号分隔值</strong>（<strong>CSV</strong>）格式提交，并且第一列应代表目标变量。 我们需要在 GCP 上为内置算法指定存储分区，以存储训练输出。 Cloud ML Engine 为训练工作提供了有限的自定义，例如使用特定的机器类型进行训练。</p> 
<p>原始的一组机器类型只能用于内置算法。 我们还可以定义需要运行作业的区域。 默认情况下，平台会自动选择合适的区域来运行训练作业。 还可以通过使用所需的学习率和批量大小来完成特定于作业的自定义。 我们可以设置超参数调整的目标阈值，以实现最大的准确率并最小化损失函数的值。 内置算法可在 GCP 共享空间上的容器内使用，可以与特定的<strong>统一资源标识符</strong>（<strong>URI</strong>）配合使用，如下表所示：</p> 
<table>
<thead><tr>
<th><strong>算法</strong></th>
<th><strong>容器 URI</strong></th>
</tr></thead>
<tbody>
<tr>
<td>线性学习器</td>
<td><code>gcr.io/cloud-ml-algos/linear_learner_cpu:latest``gcr.io/cloud-ml-algos/linear_learner_gpu:latest</code></td>
</tr>
<tr>
<td>宽深</td>
<td><code>gcr.io/cloud-ml-algos/wide_deep_learner_cpu:latest``gcr.io/cloud-ml-algos/wide_deep_learner_gpu:latest</code></td>
</tr>
<tr>
<td>XGBoost</td>
<td><code>gcr.io/cloud-ml-algos/boosted_trees:latest</code></td>
</tr>
</tbody>
</table>
<p>让我们使用内置的线性学习器算法解决一个简单的回归问题。 例如，学生的<strong>学业能力测验</strong>（<strong>SAT</strong>）分数与<strong>平均绩点</strong>（<strong>GPA</strong>）分数之间存在已知的相关关系 。 我们将有一个包含两列的示例 CSV 文件。</p> 
<p>第一列包含 GPA 分数（输出变量），第二列包含 SAT 分数。 首先让我们将 CSV 文件上传到存储桶。 以下是使用 Cloud ML Engine 训练模型的简单步骤，该模型根据 SAT 分数预测 GPA 分数：</p> 
<ol>
<li>从导航菜单中输入 GCP 控制台和 AI 平台，然后转到<code>Jobs</code>侧菜单。 您将以表格格式查看所有作业（正在运行和已完成）。 单击标题菜单中的“新训练工作”按钮。</li>
<li>创建训练工作有两种选择：使用内置算法训练或自定义代码训练。 在这种情况下，请选择“内置算法训练”选项。</li>
<li>选择线性学习器算法。</li>
<li>单击“下一步”按钮。</li>
</ol> 
<p>在以下屏幕快照中直观地表示了所有前面的步骤。 我们来看一下：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mKZLcUa1-1681704646236)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/cbdf8bd0-6b6a-4eba-a742-d1baf01e4e36.png)]</p> 
<p>图 8.1-Cloud ML Engine 的模型训练所涉及的步骤（1）</p> 
<ol start="5">
<li>提供 Google Storage 上 CSV 文件的标准路径。 该 CSV 文件包含没有标题行的训练数据，并且目标属性出现在第一列中。</li>
<li>提供用于验证的训练数据百分比的数值。 默认情况下，此值为 20，并且可以根据用例上下文将此数字更改为任何合理的值。</li>
<li>提供用于测试的训练数据百分比的数字值（可选）。 推荐值为 20，可以根据用例要求和机器学习问题的特征进行设置。</li>
<li>提供到要存储模型文件的输出目录的标准路径。 这必须是 Google Cloud Storage 上的有效位置。</li>
<li>单击<code>NEXT</code>按钮，为算法提供运行时参数。</li>
</ol> 
<p>在以下屏幕快照中直观地表示了所有前面的步骤。 我们来看一下：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YQslWcMn-1681704646236)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/e3f34061-cc55-4427-a4e7-2f0206a0fe5f.png)]</p> 
<p>图 8.2-Cloud Engine ML 模型训练所涉及的步骤（2）</p> 
<ol start="10">
<li>选择需要训练的模型类型。 当预期输出是连续变量时，将使用回归模型；而当预期输出是离散类时，将使用分类模型。</li>
<li>仔细选择最大步数，以确保完整的训练数据在生成的输出模型中得到充分体现。 同时，为此参数设置很高的值会增加训练模型的计算成本。</li>
<li>学习率是使用梯度下降算法使用模型时使用的数值。 原则上，此属性指示学习算法的两次迭代之间的步长。</li>
</ol> 
<p>这是需要设置的基本参数。 在以下屏幕快照中直观地表示了所有前面的步骤。 我们来看一下：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uj8cIX9w-1681704646237)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/ad56d876-ddf7-4bd8-995c-319f15671a88.png)]</p> 
<p>图 8.3-将参数传递给模型训练</p> 
<p>除了这些基本参数外，还可以对模型进行超调，以进一步优化和提高准确率。 选中“最大步数”旁边的<code>HyperTune</code>复选框时，需要设置最小和最大步数； 并且选中“学习率”旁边的<code>HyperTune</code>复选框时，需要设置最小和最大学习率。</p> 
<p>除了基本参数之外，还有一些高级设置可用作可配置参数，用于进一步调整模型训练，如以下屏幕快照所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1fUQbaFY-1681704646237)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/020647c0-3fc4-49d0-8835-c23ba89f69ba.png)]</p> 
<p>图 8.4-高级模型训练配置</p> 
<p>可用于调整的其他参数如下：</p> 
<ul>
<li> <p><strong>评估步骤</strong>：这是一个可选字段，指示需要对其进行评估的批量数量。 如果未指定参数，则对整个数据集运行评估。</p> </li>
<li> <p><strong>批量大小</strong>：这是在一个评估步骤中处理的数据行数。</p> </li>
<li> <p><strong>优化器类型</strong>：我们可以选择三种可能的优化器，这些优化器根据梯度下降算法的实现细节而有所不同：</p> 
  <ul>
<li><code>AdamOptimizer</code></li>
<li>
<code>FTRLOptimizer</code>（默认）</li>
<li>
<strong>随机梯度下降</strong>（<strong>SGD</strong>）优化器</li>
</ul> </li>
<li> <p><strong>L1 正则化强度</strong>：这是一个数值，表示正则化的一种类型，该类型与权重的绝对值之和成比例地对权重进行惩罚。</p> </li>
<li> <p><strong>L2 正则化强度</strong>：这是一个数值，表示正则化的一种类型，该类型与权重的平方和成比例地对权重进行惩罚。</p> </li>
<li> <p><strong>L2 收缩调整强度</strong>：此参数适用于<code>FtrlOptimizer</code>，表示幅度损失。 大于等于 0。</p> </li>
</ul> 
<p>设置算法参数后，最后一步是在下一个工作流程步骤中提供作业 ID，区域和资源大小，如下所示：</p> 
<ol start="13">
<li> <p><strong>作业 ID</strong>：这是一个字母数字字段，在项目中必须是唯一的，并且一旦设置就无法更改。 建议在作业 ID 创建中使用项目特定的上下文，因为这样可以更轻松地在生产环境中进行监视和故障排除。</p> </li>
<li> <p><strong>区域</strong>：这是用于训练模型的服务器所在的地理区域。 建议使用相同的区域来存储训练数据和模型训练。</p> </li>
<li> <p><strong>扩展层</strong>：这定义了需要分配给 AI 平台用于训练工作的资源。 各个层具有预先配置的资源级别，并且可以进行自定义，如下所示：</p> </li>
</ol> 
<pre><code>*   `BASIC`：此层设置单个工作程序实例。 顾名思义，这是基本配置级别，不能考虑用于生产负载。
*   `STANDARD_1`：此层配置许多工作程序和一组有限的参数服务器。
*   `PREMIUM_1`：此层预配置了大量工作程序和参数服务器。
*   `BASIC_GPU`：此层为 GPU 提供单个工作程序实例。 再一次，这将加快训练速度，仅对实验有益。
*   `BASIC_TPU`：此层使用 Cloud TPU 设置单个工作程序实例。
*   `CUSTOM`：使用此配置时，可以完全配置用于训练的群集的规模。 需要为自定义配置设置以下参数：
    *   **主节点类型**：需要用于主节点的虚拟机的类型。 这是必填字段。
    *   **工作器数**：这定义了用于训练的工作器数。 如果工作器数设置为 1 或更多，则还需要设置工作器类型。
    *   **参数服务器数**：这定义了用于训练的参数服务器的计数。 如果参数服务器的数量为 1 个或更多，则需要设置参数服务器类型。
</code></pre> 
<p>在以下屏幕快照中直观地表示了所有前面的步骤。 我们来看一下：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eVnhct4J-1681704646237)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/b9f82a01-5871-454f-95a3-0d352d04a9c6.png)]</p> 
<p>图 8.5-模型训练的作业设置</p> 
<ol start="16"><li>作业设置完成后，模型开始训练，并且可以在控制台中跟踪作业。 以下屏幕截图显示了控制台中正在进行，成功和失败的作业：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-opbAADbj-1681704646237)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/4cfa9c05-8f63-4c1e-bfa3-1ba3aa3c9342.png)]</p> 
<p>图 8.6-模型训练作业控制台</p> 
<ol start="17"><li>一旦模型训练完成，就可以从控制台进行部署。 该模型可通过<strong>表述性状态转移</strong>（<strong>REST</strong>）API 与新数据集一起调用。 需要提供唯一的模型名称以及需要在其中部署模型的区域，以及关于模型的可选描述，如以下屏幕快照所示：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GNSc1Sb2-1681704646237)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/0ac97151-e012-4eb2-8b6f-0fc1b3fdf2cf.png)]</p> 
<p>图 8.7-模型部署</p> 
<p>在这一点上，模型被训练和部署以供使用。 在接下来的部分中，我们将研究利用模型和构建预测服务。</p> 
<h1>
<a id="_570"></a>使用自定义训练应用</h1> 
<p>内置算法是一些最常用的算法。 但是，您将需要针对大多数实际用例训练定制模型。 AI 平台提供了用于训练自定义模型的标准一致框架。 以下屏幕快照描述了通用过程：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0E8bzT3N-1681704646238)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/aee892d0-14d9-4f86-8aa8-81779a05d53c.png)]</p> 
<p>图 8.8-在 AI 平台上训练自定义模型的步骤</p> 
<p>AI 平台与典型的机器学习开发生命周期同步工作并对其进行补充。 模型训练代码从本地文件夹或共享位置访问训练数据。 我们需要从 Cloud Storage 位置访问训练数据。 提取数据后，需要分批量每个单独的数据实例。 可以根据用例上下文和数据量来决定这些批量。 评估数据用于测试模型的准确率。 经过训练的模型将作为二进制文件导出，并存储在本地驱动器或 Cloud Storage 位置中。</p> 
<p>另外，可以以分布式方式训练模型。 AI 平台使其成为一个无缝的过程，并要求将有关多台机器的详细信息作为训练群集的参数进行传递。 训练服务根据机器类型和所选容量执行资源分配。 在单个节点上运行的每个训练作业都称为<strong>复制副本</strong>。 每个副本都扮演一个角色，并对一组特定的训练数据进行操作。 工作负载分配的详细信息由平台管理，不需要特定的用户配置或参与。 有三种类型的实体有助于分布式模型训练，如下所示：</p> 
<ul>
<li>
<strong>主节点</strong>：AI 平台将一个副本指定为主节点。 分布式训练计划在其他可用节点上进行，并且主节点会跟踪进度。 训练作业的总体状态与主节点的状态相同。</li>
<li>
<strong>工作器</strong>：集群中可用的节点扮演工作器的角色。 单个工作器执行其任务，并将状态报告回主节点。</li>
<li>
<strong>参数服务器</strong>：副本节点之一被指定为参数服务器，并执行节点之间模型的共享状态的协调任务。</li>
</ul> 
<p>分布式训练的基本且简单的策略涉及将数据分块为各个段，从而在节点上使用每个单独的数据段来训练模型。 在这种情况下，参数服务器会跟踪各个梯度值，并执行合并到最终模型状态的任务。</p> 
<p>使用可用框架之一构建应用后，需要将其打包以便在平台上进行部署。 可以使用<code>gcloud</code> <strong>命令行界面</strong>（<strong>CLI</strong>）完成打包。 建议使用<code>gcloud</code>工具打包应用。 可以使用标准打包和构建工具手动构建该包，如以下代码块所示：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform jobs submit training $JOB_NAME <span class="token operator">-</span><span class="token operator">-</span>staging<span class="token operator">-</span>bucket $PACKAGE_STAGING_PATH <span class="token operator">-</span><span class="token operator">-</span>job<span class="token operator">-</span><span class="token builtin">dir</span> $JOB_DIR <span class="token operator">-</span><span class="token operator">-</span>package<span class="token operator">-</span>path $TRAINER_PACKAGE_PATH <span class="token operator">-</span><span class="token operator">-</span>module<span class="token operator">-</span>name $MAIN_TRAINER_MODULE <span class="token operator">-</span><span class="token operator">-</span>region $REGION 
</code></pre> 
<p>这是我们需要传递给脚本的参数的简要说明：</p> 
<ul>
<li>
<code>--staging-bucket</code>：这是一个存储训练和依赖项的云存储位置。 GCP 项目需要有权访问此存储桶，建议该存储桶位于打算运行训练作业的同一区域中。</li>
<li>
<code>--job-dir</code>：这是一个云存储位置，用于存储训练作业的输出文件。 该位置必须与训练作业要在同一区域进行。</li>
<li>
<code>--package-path</code>：这是父目录的本地路径，其中存在应用工件。 AI 平台将该路径中的内容打包到<code>tar.gz</code>文件中，并将其上传到云存储中。 通过解压缩档案的内容来执行训练作业。</li>
<li>
<code>--module-name</code>：这是应用的名称。</li>
<li>
<code>--region</code>：这是执行训练工作的地理区域。</li>
</ul> 
<h1>
<a id="_602"></a>预测服务</h1> 
<p>上一节中训练的机器学习模型可以基于新的数据集托管在云上进行消费和预测。 预测服务主要负责管理预测所需的存储和计算资源。 作为一般过程，需要导出训练工件。 对于在 AI 平台上训练的模型以及在外部训练的模型，导出过程相同。 可以导出的最大模型大小为 250 MB。 如果需要导出更大的定制模型，则需要提交配额增加表。 AI 平台限制了计算基础架构的使用，因此该平台可以在合理的水平上使用，足以满足大多数通用用例的需要。</p> 
<p>但是，计算密集型和大型模型可能需要增加配额。 机器学习模型预测是一个迭代过程，需要对模型的多个版本进行训练。 AI 平台将模型引用为特定机器学习管道的各种版本的容器。 模型可以包含管道的各种版本，并且特定版本可以由 API 调用。 一旦提供了模型版本，就应格式化需要发送到预测服务的数据，并将其提供给 API 调用进行预测。</p> 
<p>可以通过两种方式请求预测，如下所示：</p> 
<ul>
<li>
<strong>在线预测</strong>：服务使用用于 API 调用的数据调用模型版本，并在响应中返回预测。 在后台，模型版本会在运行时部署在请求中指定的区域上。 平台可以缓存模型版本，该模型版本更常用于快速响应时间。</li>
<li>
<strong>批量预测</strong>：批量预测是一个异步服务调用，当用例需求是这样的需求：需要大量进行预测时，可以使用该异步服务，并且可以在服务提供预测时独立进行处理。 当请求批量预测时，预测服务会在 AI 平台上分配资源以运行作业。 这可能涉及一个或多个预测节点。 在每个分配的节点上还原模型图。 一旦分配了节点，输入数据就由主服务器分发以进行分布式预测。 每个单独的节点在请求预测服务时将预测数据存储在提到的云存储位置中。</li>
</ul> 
<p>在在线预测和批量预测的前提，可能的用例以及因此的存储和计算需求方面，存在根本的区别。 在线预测的目标是最小化预测服务的等待时间（响应时间），并将预测返回到响应的消息正文中。 另一方面，批量预测的目标是处理具有大型数据集和复杂模型的大量实例。 预测输出存储在 Cloud Storage 存储桶中，而不是在消息响应正文中发送。</p> 
<p>在线预测通常可以用在处理实时数据的用例中，并且需要及时进行预测以使系统采取行动。 当预测需要对大量历史数据进行操作时，可以使用批量预测。 如果我们尝试使用批量预测模式运行较小的预测负载（数据量较小且算法简单），则与在线预测模型相比，它需要更长的时间。 这是由于以下事实：发送请求时完成了计算和存储资源的提供，并且优先级低于在线预测作业。 为特定用例选择正确的预测模式非常重要。</p> 
<p>在创建用于在线预测的模型时，用户需要决定使用哪个区域来运行预测，并且必须决定是否启用在线预测日志记录。 启用日志记录对于故障排除或测试很有用。 但是，启用日志记录时会产生额外的费用。 在提出在线模型预测请求之前，需要先考虑这些成本。</p> 
<p>应用开发人员还需要确定要使用的运行时版本，以及 Python 的版本和用于在线预测的机器类型。 可以根据数据量和模型的复杂性来确定机器类型。</p> 
<p>可以为预测服务启用三个级别的日志记录，如下所示：</p> 
<ul>
<li>
<strong>访问日志记录</strong>：此日志记录有助于分析对预测服务的请求数，并跟踪请求开始和呈现时间的时间戳。 可以基于等待时间值以及预测服务的使用模式进行分析。</li>
<li>
<strong>流日志记录</strong>：标准错误和标准输出被写入 Stackdriver Logging。 仅出于调试目的，需要仔细启用此设置，否则可能会遇到高昂的成本。 仅在创建模型资源时才能启用此日志记录。</li>
<li>
<strong>请求-响应日志记录</strong>：此级别将在线预测请求和响应记录到 BigQuery 表中。</li>
</ul> 
<p>可以使用<code>gcloud</code>命令行以及 REST API 启用这些日志记录级别。 为了使用<code>gcloud</code>启用访问日志记录，需要传递<code>--enable logging</code>参数，如下所示：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform models create model_name <span class="token operator">-</span><span class="token operator">-</span>regions us<span class="token operator">-</span>central1 <span class="token operator">-</span><span class="token operator">-</span>enable<span class="token operator">-</span>logging 
</code></pre> 
<p>如以下代码块所示，需要传递<code>--enable-console-logging</code>参数以启用流日志记录：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform models create model_name <span class="token operator">-</span><span class="token operator">-</span>regions us<span class="token operator">-</span>central1 <span class="token operator">-</span><span class="token operator">-</span>enable<span class="token operator">-</span>console<span class="token operator">-</span>logging
</code></pre> 
<p>无法使用<code>gcloud</code>启用请求响应日志记录。 需要使用 REST API 启用它。 可以在创建模型和版本时设置日志记录级别。 <code>projects.models.create</code> 方法用于创建模型，并通过以下 HTTP URI 进行调用：</p> 
<pre><code class="prism language-py">POST https<span class="token punctuation">:</span><span class="token operator">//</span>ml<span class="token punctuation">.</span>googleapis<span class="token punctuation">.</span>com<span class="token operator">/</span>v1<span class="token operator">/</span><span class="token punctuation">{<!-- --></span>parent<span class="token operator">=</span>projects<span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">}</span><span class="token operator">/</span>models
</code></pre> 
<p>父项是代表项目名称的必需的字符串 URL 参数。 为了成功验证请求，我们需要对项目具有<code>ml.models.create</code> Google <strong>身份和访问管理</strong>（<strong>IAM</strong>）权限。 请求主体是模型对象的表示。 这是模型对象的示意图：</p> 
<pre><code class="prism language-py"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"name"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  <span class="token string">"description"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  <span class="token string">"defaultVersion"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token builtin">object</span> <span class="token punctuation">(</span>Version<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">"regions"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
    string
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">"onlinePredictionLogging"</span><span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>
  <span class="token string">"onlinePredictionConsoleLogging"</span><span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>
  <span class="token string">"labels"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    string<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">"etag"</span><span class="token punctuation">:</span> string
<span class="token punctuation">}</span>
</code></pre> 
<p>让我们看一下下表中的模型参数列表及其描述：</p> 
<table>
<thead><tr>
<th><strong>参数名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>必填</strong></th>
<th><strong>说明</strong></th>
</tr></thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>字符串</td>
<td>是</td>
<td>这是模型的名称。 模型名称在项目中必须唯一。</td>
</tr>
<tr>
<td><code>description</code></td>
<td>字符串</td>
<td>否</td>
<td>这是创建模型时的描述。</td>
</tr>
<tr>
<td><code>defaultVersion</code></td>
<td>目的</td>
<td>是</td>
<td>当未在请求内发送版本信息时，将使用该模型版本。 随着模型的发展，默认版本会不断变化并变得越来越有用。 可以使用<code>projects.methods</code>更改为模型版本。</td>
</tr>
<tr>
<td><code>regions[]</code></td>
<td>字符串数组</td>
<td>否</td>
<td>这是模型在其上部署的所有区域的列表。 这是为 AI 平台的将来版本提供的。 在撰写本章时，平台仅支持一个区域。 默认值为<code>us-central1</code>。</td>
</tr>
<tr>
<td><code>onlinePredictionLogging</code></td>
<td>布尔型</td>
<td>否</td>
<td>如果设置为<code>true</code>，则在线预测日志将发送到 StackDriver Logging。 这些日志类似于服务器访问日志，其中记录了所有请求的请求时间戳和响应时间。 默认情况下，此参数的值为<code>false</code>，需要将其显式设置为<code>true</code>。</td>
</tr>
<tr>
<td><code>onlinePredictionConsoleLogging</code></td>
<td>布尔型</td>
<td>否</td>
<td>如果设置为<code>true</code>，则在线预测日志将以更详细的方式发送到 StackDriver Logging，并包含标准输出以及标准错误日志消息的完整记录。 该日志对于调试很有帮助，但需要谨慎使用以节省成本。</td>
</tr>
<tr>
<td><code>labels</code></td>
<td>键值对映射</td>
<td>否</td>
<td>标签有助于组织 AI 平台上的各种资源。 这些标签是可以具有任意值的键值字符串。 带标签的资源易于监视和分组。 我们最多可以提供 64 个标签。 键和值最多可以包含 63 个字符。 键必须以字母开头，并且可以包含字母数字字符，下划线和破折号。</td>
</tr>
<tr>
<td><code>etag</code></td>
<td>字符串</td>
<td>是</td>
<td>该标志用于防止两个独立模型更新之间的竞争状况。 需要在各种请求和响应之间以链接的方式使用<code>etag</code>参数，以确保对模型进行顺序更新。 建议有效使用<code>etag</code>，以避免模型版本不一致。</td>
</tr>
</tbody>
</table>
<p>除了创建模型之外，相同的请求主体对象还可用于以下函数：</p> 
<ul>
<li>
<code>delete</code>：删除模型</li>
<li>
<code>get</code>：获取有关模型的所有信息，包括版本</li>
<li>
<code>getIamPolicy</code>：获取资源的访问控制策略</li>
<li>
<code>list</code>：提供项目中存在的所有模型的列表</li>
<li>
<code>patch</code>：更新模型资源</li>
<li>
<code>setIamPolicy</code>：设置 AI 平台内特定资源的访问控制</li>
<li>
<code>testIamPermissions</code>：列出调用用户帐户对特定资源拥有的所有权限</li>
</ul> 
<p>为了执行在线预测，需要以值列表形式或 JSON 对象的形式对输入数据进行结构化和格式化。 以下是可以在 AI 平台上传递给张量模型的输入张量的示例：</p> 
<pre><code class="prism language-py"><span class="token punctuation">{<!-- --></span><span class="token string">"values"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"one"</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">,</span><span class="token string">"three"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">:</span><span class="token number">123</span><span class="token punctuation">}</span>
</code></pre> 
<p>需要将该对象格式化为以下格式，才能发送到 REST API 端点：</p> 
<pre><code class="prism language-py"><span class="token punctuation">{<!-- --></span><span class="token string">"instances"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
                       <span class="token punctuation">{<!-- --></span><span class="token string">"values"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"one"</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">,</span><span class="token string">"three"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                       <span class="token punctuation">{<!-- --></span><span class="token string">"values"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"five"</span><span class="token punctuation">,</span><span class="token string">"six"</span><span class="token punctuation">,</span><span class="token string">"seven"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">}</span>

<span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>project<span class="token punctuation">,</span> model<span class="token punctuation">,</span> instances<span class="token punctuation">,</span> version<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    GOOGLE_APPLICATION_CREDENTIALS<span class="token operator">=</span><span class="token operator">&lt;</span>path_to_service_account_file<span class="token operator">&gt;</span>
    service <span class="token operator">=</span> googleapiclient<span class="token punctuation">.</span>discovery<span class="token punctuation">.</span>build<span class="token punctuation">(</span><span class="token string">'ml'</span><span class="token punctuation">,</span> <span class="token string">'v1'</span><span class="token punctuation">)</span>
    name <span class="token operator">=</span> <span class="token string">'projects/{}/models/{}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>project<span class="token punctuation">,</span> model<span class="token punctuation">)</span>

    <span class="token keyword">if</span> version <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        name <span class="token operator">+=</span> <span class="token string">'/versions/{}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span>

    response <span class="token operator">=</span> service<span class="token punctuation">.</span>projects<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>predict<span class="token punctuation">(</span>
        name<span class="token operator">=</span>name<span class="token punctuation">,</span>
        body<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'instances'</span><span class="token punctuation">:</span> instances<span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token string">'error'</span> <span class="token keyword">in</span> response<span class="token punctuation">:</span>
        <span class="token keyword">raise</span> RuntimeError<span class="token punctuation">(</span>response<span class="token punctuation">[</span><span class="token string">'error'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> response<span class="token punctuation">[</span><span class="token string">'predictions'</span><span class="token punctuation">]</span>
</code></pre> 
<p>如我们所见，可以通过使用对项目的引用来对 JSON 格式的输入结构化数据进行建模来获得在线预测。 我们使用<code>googleapiclient</code>创建机器学习服务的实例，并在服务实例上调用<code>predict</code>方法。</p> 
<h1>
<a id="_726"></a>笔记本</h1> 
<p>The AI Platform provides an intuitive way of working with it in terms of notebooks. These are pre-packaged online interfaces that can be used for effective collaboration among team members and can be quickly configured to have the latest versions of Python libraries in the backend. The notebooks enable the developers to create and manage virtual machines on the GCP that can utilize TensorFlow and PyTorch frameworks, along with R and Python deep learning packages.</p> 
<p>可以配置工作流和管道，以真正无服务器的方式利用 CPU 和 GPU。 笔记本电脑可以使用的图像经过测试和优化，以实现最佳表现和易用性。 GCP 的认证层用于访问笔记本，并且可以与任何其他 GCP 资源相同的方式配置 IAM 策略。 与 GCP 上托管的 GitHub 存储库无缝集成。</p> 
<p>AI Platform 笔记本支持以下运行时和包：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-srYJYANB-1681704646238)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/e6cb24d8-739b-4fd3-b9f0-3a9be023453b.png)]</p> 
<p>图 8.9-AI 平台支持的运行时和包</p> 
<p>为了在 AI 平台上使用笔记本，需要选择一个项目，并且需要启用 Compute Engine API 才能导航到笔记本页面。 让我们创建笔记本的新实例：</p> 
<ol>
<li>从导航菜单转到 AI 平台内的<code>Notebooks</code>笔记本菜单。</li>
<li>单击顶部菜单栏上的<code>NEW INSTANCE</code>链接。</li>
<li>从可用选项中选择用于创建实例，或单击“自定义实例”以对新实例的各种参数和容量进行精细控制。</li>
<li>选择具有或不具有 GPU 的实例。 如果实例是使用 GPU 创建的，请选择选项以自动安装 GPU 驱动。 创建实例后，可以在以后修改 GPU 计数。 以下屏幕快照描述了创建笔记本新实例的步骤：</li>
</ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-osA04ATg-1681704646238)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/d5e577f7-7f04-45af-bf2a-f9fa28f5c767.png)]</p> 
<p>图 8.10-创建新笔记本实例的步骤（1）</p> 
<p>让我们使用不带 GPU 的 TensorFlow 2.0 创建一个新的笔记本实例。</p> 
<ol start="5">
<li>AI 平台分配默认实例名称。 可以根据用例上下文修改此名称。 建议使用日期时间戳作为实例名称，以提高可维护性。</li>
<li>环境：AI 平台使用带有英特尔®MKL-DNN 和 CUDA 10.0 的 TensorFlow 2.0 创建图像，并且默认情况下包括 Python 2/3，scikit-learn，pandas 和 NLTK。</li>
<li>机器配置：AI 平台使用默认区域（us-west1-b），具有 15 GB RAM 的 4 个 vCPU 和 100 GB 的启动磁盘创建机器。</li>
<li>联网：子网是默认设置（10.138.0.0/20）。</li>
<li>估计成本：AI 平台根据持续使用折扣提供估计成本。</li>
<li>单击“创建”按钮分配笔记本实例。</li>
</ol> 
<p>以下屏幕截图显示了使用 TensorFlow 2.0 而不使用 GPU 创建新笔记本实例的步骤：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iVgABzEI-1681704646238)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/f3008a9c-85b0-4310-9fcd-48103fcaa3db.png)]</p> 
<p>图 8.11-创建新笔记本实例的步骤（2）</p> 
<ol start="11"><li>使用设定的配置创建笔记本后，您可以通过单击<code>OPEN JUPYTERLAB</code>超链接来打开 JupyterLab 界面，如以下屏幕截图所示：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9TeRrDue-1681704646239)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/f6ccd859-b3e4-4f4e-89c8-7672ea2d8fe9.png)]</p> 
<p>图 8.12-打开 Jupyter 笔记本</p> 
<h1>
<a id="_770"></a>数据标签服务</h1> 
<p>AI 平台提供了<strong>数据标注服务</strong>，该服务可以在人类标记者的帮助下轻松，高效地标注训练数据。 模型训练需要大量数据，有时无法获得人工为训练和评估数据加上标签的努力。 可以利用数据标签服务进行连续评估，这有助于基于一组新的输入数据来改进模型，以提高准确率。</p> 
<p>使用数据标签服务的一般过程始于创建一个数据集，其中包含样本，这些样本将作为人类标签的指南。 与样本数据集一起，需要提供一个标注规范集，其中包含用例上下文中训练数据的所有可能的分类类别。 我们还可以向贴标机提供一组额外的说明，以进行实际的贴标。 一旦满足先决条件，就可以根据样本，标注规范集和说明生成服务请求，人工贴标人员可以导出训练数据以用于模型的训练和评估。</p> 
<p>以下屏幕快照显示了使用数据标签服务的一般过程：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Kk9vgpKi-1681704646239)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/9fd527be-43b6-4447-8424-18930674c1f5.png)]</p> 
<p>图 8.13-使用数据标记服务涉及的步骤</p> 
<h1>
<a id="_782"></a>深度学习容器</h1> 
<p>这些容器提供了一个抽象的应用层，该层可以在各种环境中运行并且可以与基础操作系统无缝地协同工作。 这有助于开发人员专注于应用开发，因为所有依赖项均由容器管理，而与部署应用的环境无关。</p> 
<p>AI 平台提供了一个现成的深度学习容器，其中包含关键的数据科学框架，库和工具。 AI 平台上的深度学习容器包含 TensorFlow，PyTorch，scikit-learn 和 R 框架，以及 Python 和 R 运行时。 容器中还包括最常用的 Python 包。</p> 
<h1>
<a id="_TensorFlow__788"></a>训练和利用 TensorFlow 模型涉及的步骤</h1> 
<p>在本部分中，我们将逐步介绍在 AI 平台上训练 TensorFlow 模型所涉及的所有步骤。 本地机器学习管道以及 AI 平台上的核心组件是相似的，因此，应用开发人员很容易利用熟悉的过程在 AI 平台上构建和部署模型。 以下屏幕截图中的流程图表示在 AI 平台上训练和使用 TensorFlow 模型的一般步骤：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j3RqWxcx-1681704646239)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/13f9f8b1-2bde-4140-9811-3c1712971956.png)]</p> 
<p>图 8.14-在 AI 平台上训练和使用 TensorFlow 模型的通用步骤</p> 
<h1>
<a id="_796"></a>先决条件</h1> 
<p>为了在 AI 平台上训练，部署和利用 TensorFlow 模型，我们需要考虑以下组件的成本：</p> 
<ul>
<li>
<strong>AI 平台</strong>：训练/部署/预测</li>
<li>
<strong>云存储</strong>：用于训练/分段应用包/训练工件的输入数据</li>
</ul> 
<p>训练和部署 TensorFlow 模型的主要要求是创建一个项目。 创建项目并启用计费后，我们需要启用 AI 平台和 Compute Engine API。 此时，请安装云<strong>软件开发套件</strong>（<strong>SDK</strong>），并使用认证和授权对其进行初始化。</p> 
<p>至此，完成了与平台相关的先决条件。 现在，我们需要为应用运行设置环境。</p> 
<p>在 GCP 控制台中，单击顶部菜单栏上的“激活 Cloud Shell”按钮。 这将打开 Cloud Shell Web 界面。</p> 
<p>这是我们需要从 Cloud Shell 采取的步骤：</p> 
<ol>
<li>列出 AI 平台上存在的所有模型。</li>
<li>更新 AI 平台上的所有组件。</li>
<li>安装或升级 TensorFlow。</li>
</ol> 
<p>您可以在控制台的以下屏幕截图中看到突出显示的上述步骤：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ELviUvKY-1681704646239)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/3c725cfc-df57-4f53-83d8-715e25872d0b.png)]</p> 
<p>图 8.15-通过 GCP 控制台进行 AI 平台设置的要求</p> 
<p>至此，环境设置完成。 现在，我们可以在本地开发和验证训练应用。 在云上运行该应用之前，建议在本地运行该应用以进行快速调试，并确保所有程序都能按预期工作。 在本地运行应用时，云资源不会产生任何费用。</p> 
<h1>
<a id="_TensorFlow__823"></a>创建一个 TensorFlow 应用并在本地运行</h1> 
<p>训练应用是根据开发人员的偏好和项目的上下文构造的。 但是，有一个推荐的项目结构，可以确保各个项目之间的一致性，并且不需要进行上下文开发人员训练。</p> 
<h1>
<a id="_827"></a>项目结构推荐</h1> 
<p>让我们设置项目结构：</p> 
<ol>
<li>创建一个主项目目录，其中包含应用的所有代码。</li>
<li>在主项目目录中创建一个<code>setup.py</code>文件。 <code>setup.py</code>文件确保所有子目录都包含在用于应用分发的存档包中。 以下代码块显示了<code>setup.py</code>的典型实现：</li>
</ol> 
<pre><code class="prism language-py"><span class="token keyword">from</span> setuptools <span class="token keyword">import</span> setup<span class="token punctuation">,</span> find_packages
<span class="token keyword">import</span> os

NAME <span class="token operator">=</span> <span class="token string">'preprocessing'</span>
VERSION <span class="token operator">=</span> <span class="token string">'x.y'</span>
REQUIRED_PACKAGES <span class="token operator">=</span> <span class="token punctuation">[</span>COMMA_SEPARATED LIST OF PACKAGES<span class="token punctuation">]</span>

setup<span class="token punctuation">(</span>
    name<span class="token operator">=</span>NAME<span class="token punctuation">,</span>
    version<span class="token operator">=</span>VERSION<span class="token punctuation">,</span>
    packages<span class="token operator">=</span>find_packages<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    install_requires<span class="token operator">=</span>REQUIRED_PACKAGES<span class="token punctuation">,</span> 
    <span class="token punctuation">)</span>
</code></pre> 
<ol start="3">
<li> <p>创建一个名为<code>trainer</code>的子目录。 <code>trainer</code>目录包含应用模块代码，并且通常包含以下文件：</p> 
  <ul>
<li>
<code>task.py</code>：这是主要的应用模块，以及包含负责训练作业的编排的应用逻辑的文件。</li>
<li>
<code>model.py</code>：这是包含模型逻辑以及模型的各种属性和配置参数的文件。</li>
</ul> </li>
<li> <p>创建使应用模块化和逻辑可读的各种子目录。</p> </li>
<li> <p>建议在每个子目录中创建一个<code>__init__.py</code>文件。 通常，<code>Setuptools</code>将这些用作包装应用的标记。</p> </li>
<li> <p>当调用<code>gcloud</code>命令进行训练时，<code>package-path</code>参数设置为<code>trainer</code>目录。 运行时在父目录中搜索<code>setup.py</code>文件，并根据<code>trainer</code>目录中<code>task.py</code>和<code>model.py</code>文件中的代码训练模型。</p> </li>
</ol> 
<h1>
<a id="_858"></a>训练数据</h1> 
<p>在此示例中，我们将使用人口普查收入数据，它是公共可用的数据集之一。 这是数据集的特征：</p> 
<ul>
<li>
<strong>摘要</strong>：基于 14 个属性的数据集，用于预测一个人的收入是低于还是大于 50,000 美元。</li>
<li>
<strong>类型</strong>：多变量。</li>
<li>
<strong>实例数量</strong>：48,842。</li>
<li>
<strong>领域</strong>：社交。</li>
<li>
<strong>属性类型</strong>：类别/整数。</li>
</ul> 
<p>让我们继续进行模型训练。</p> 
<ol><li>在以下命令的帮助下，打开 Cloud Shell 并下载示例代码：</li></ol> 
<pre><code class="prism language-py">wget https<span class="token punctuation">:</span><span class="token operator">//</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>GoogleCloudPlatform<span class="token operator">/</span>cloudml<span class="token operator">-</span>samples<span class="token operator">/</span>archive<span class="token operator">/</span>master<span class="token punctuation">.</span><span class="token builtin">zip</span>
unzip master<span class="token punctuation">.</span><span class="token builtin">zip</span>
cd cloudml<span class="token operator">-</span>samples<span class="token operator">-</span>master<span class="token operator">/</span>census<span class="token operator">/</span>estimator
</code></pre> 
<ol start="2"><li>在以下命令的帮助下获取训练数据：</li></ol> 
<pre><code class="prism language-py">mkdir data
gsutil <span class="token operator">-</span>m cp gs<span class="token punctuation">:</span><span class="token operator">//</span>cloud<span class="token operator">-</span>samples<span class="token operator">-</span>data<span class="token operator">/</span>ai<span class="token operator">-</span>platform<span class="token operator">/</span>census<span class="token operator">/</span>data<span class="token operator">/</span><span class="token operator">*</span> data<span class="token operator">/</span>
TRAIN_DATA<span class="token operator">=</span>$<span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token operator">/</span>data<span class="token operator">/</span>adult<span class="token punctuation">.</span>data<span class="token punctuation">.</span>csv
EVAL_DATA<span class="token operator">=</span>$<span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token operator">/</span>data<span class="token operator">/</span>adult<span class="token punctuation">.</span>test<span class="token punctuation">.</span>csv
</code></pre> 
<ol start="3">
<li> <p>创建用于存储模型和中间文件的输出目录。</p> </li>
<li> <p>为了在本地运行模型，我们需要使用以下命令：</p> </li>
</ol> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform local train 
    <span class="token operator">-</span><span class="token operator">-</span>module<span class="token operator">-</span>name trainer<span class="token punctuation">.</span>task 
    <span class="token operator">-</span><span class="token operator">-</span>package<span class="token operator">-</span>path trainer<span class="token operator">/</span> 
    <span class="token operator">-</span><span class="token operator">-</span>job<span class="token operator">-</span><span class="token builtin">dir</span> $MODEL_DIR 
    <span class="token operator">-</span><span class="token operator">-</span> 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>files $TRAIN_DATA 
    <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">eval</span><span class="token operator">-</span>files $EVAL_DATA 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>steps <span class="token number">1000</span> 
    <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">eval</span><span class="token operator">-</span>steps <span class="token number">100</span>
</code></pre> 
<p>这是模型输出目录的屏幕截图：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2oPhBvvz-1681704646239)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/78df82a0-9299-494e-ad18-130ae8e416aa.png)]</p> 
<p>图 8.16-模型输出目录</p> 
<p>训练和评估模型后，即可使用 TensorBoard 分析各种模型训练参数。 TensorBoard 是 TensorFlow 打包的可视化工具包。 它有助于在模型图中可视化和分析损失和准确率。 以下命令用于将 TensorBoard 作为 Web 应用启动（默认在端口<code>8080</code>上）：</p> 
<pre><code class="prism language-py">tensorboard <span class="token operator">-</span><span class="token operator">-</span>logdir<span class="token operator">=</span>$MODEL_DIR <span class="token operator">-</span><span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">8080</span>
</code></pre> 
<p>前面的命令将返回以下输出。 我们来看一下：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c7KmER2A-1681704646240)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/6c033d7b-eb1c-46e4-a830-ea022591d639.png)]</p> 
<p>图 8.17 使用 TensorBoard 的模型视图</p> 
<p>正如我们从前面的屏幕截图中可以看到的那样，TensorBoard 可以通过直观的可视化工具轻松分析模型表现。</p> 
<p>在下一部分中，让我们看一下打包和部署训练应用所涉及的步骤。</p> 
<h1>
<a id="_Cloud_ML_Engine__925"></a>在 Cloud ML Engine 中打包和部署您的训练应用</h1> 
<p>重要的是要了解在 ML Engine 中打包和部署应用的正确方法。 在本节中，我们将讨论机器学习应用的打包和部署中的一些推荐方法和最佳实践。 我们可以使用<code>gcloud</code>命令行工具来打包和上传应用。 最简单的方法是使用以下命令进行打包以及上载应用，同时提交训练作业：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform jobs submit training
</code></pre> 
<p>让我们定义打包和部署应用所需的全局环境变量，如下所示：</p> 
<ul>
<li>
<code>PATH_TRAINER_PACKAGE</code>：训练作业所需的所有源代码文件的标准路径。</li>
<li>
<code>TRAINER_MODULE</code>：这是<code>.task</code>文件的名称，该文件代表主应用模块，并且该文件包含负责训练作业的编排的应用逻辑。</li>
<li>
<code>STAGING_BUCKET</code>：这是训练作业运行时用于存储中间结果和临时文件的 Google 存储空间上的路径。</li>
</ul> 
<p>除了这些之外，我们需要设置变量以表示作业名称，作业目录和区域。 作业名称可用于跟踪与作业相关的数据和沿袭点； 作业目录存储训练作业的中间结果和最终结果； 并且需要该区域在适当的位置运行训练工作，以优化计算和存储成本并最小化开销。</p> 
<p>这是一个使用<code>gcloud ai-platform</code>命令负责打包和部署应用的命令：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform jobs submit training $JOB_NAME 
    <span class="token operator">-</span><span class="token operator">-</span>staging<span class="token operator">-</span>bucket $STAGING_BUCKET 
    <span class="token operator">-</span><span class="token operator">-</span>job<span class="token operator">-</span><span class="token builtin">dir</span> $JOB_DIR 
    <span class="token operator">-</span><span class="token operator">-</span>package<span class="token operator">-</span>path $PATH_TRAINER_PACKAGE 
    <span class="token operator">-</span><span class="token operator">-</span>module<span class="token operator">-</span>name $TRAINER_MODULE 
    <span class="token operator">-</span><span class="token operator">-</span>region $REGION 
    <span class="token operator">-</span><span class="token operator">-</span> 
    <span class="token operator">-</span><span class="token operator">-</span>user_first_arg<span class="token operator">=</span>first_arg_value 
    <span class="token operator">-</span><span class="token operator">-</span>user_second_arg<span class="token operator">=</span>second_arg_value
</code></pre> 
<p>除了运行命令的必需参数之外，我们还可以将许多用户定义的和应用特定的参数传递给此脚本。 参数值可用于运行时和特定于应用的逻辑的实现。</p> 
<p>训练作业还可能需要一些依赖关系才能成功运行训练作业。 有两种类型的依赖关系需要解决：</p> 
<ul><li>
<strong>标准 Python 依赖项</strong>：这些是 PyPI 上可用的标准 Python 包。 AI 平台通过<code>pip install</code>命令安装了标准依赖项。 这类似于独立应用的依赖项解析。 定义 AI 平台上的依赖项的标准方法是提及<code>setup.py</code>文件中的依赖项。 <code>setup.py</code>文件需要放置在应用的根目录中。 在以下代码片段中可以看到<code>setup.py</code>文件的模板：</li></ul> 
<pre><code class="prism language-py"><span class="token keyword">from</span> setuptools <span class="token keyword">import</span> find_packages
<span class="token keyword">from</span> setuptools <span class="token keyword">import</span> setup

REQUIRED_PACKAGES <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'comma separated list of required packages'</span><span class="token punctuation">]</span>
setup<span class="token punctuation">(</span>
    name<span class="token operator">=</span><span class="token string">'trainer'</span><span class="token punctuation">,</span>
    version<span class="token operator">=</span><span class="token string">'0.1'</span><span class="token punctuation">,</span>
    install_requires<span class="token operator">=</span>REQUIRED_PACKAGES<span class="token punctuation">,</span>
    packages<span class="token operator">=</span>find_packages<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    include_package_data<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
    description<span class="token operator">=</span><span class="token string">'Setup details and required packages for the training application'</span>
<span class="token punctuation">)</span>
</code></pre> 
<ul><li>
<strong>用户定义和自定义依赖项</strong>：这些是应用在运行时所需的用户定义包。 AI 平台可以使用<code>pip install</code>命令解决这些依赖性。 定制依赖项包需要在运行时可供应用访问，因此，需要提供该包的标准 URI 作为脚本的参数。 建议将包文件存储在可访问的 Cloud Storage 位置。 使用<code>gcloud</code>命令时，依赖项可以放在本地计算机上，也可以放在 Cloud Storage 上。 AI 平台按照它们在命令中出现的顺序对这些依赖项进行分级。 需要将多个依赖项指定为以逗号分隔的列表。</li></ul> 
<p>在下一节中，我们将学习如何通过选择正确的计算选项和运行时参数来优化训练工作。</p> 
<h1>
<a id="_980"></a>为您的训练工作选择正确的计算选项</h1> 
<p>重要的是为训练工作选择正确的计算选项，以便最佳利用平台资源。 这导致训练时间和成本最小化。 我们需要为训练作业设置运行时属性。 训练工作是 AI 平台上的标准对象。 训练工作的结构如下（输入参数以<strong>粗体</strong>字体突出显示，<a href="https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Google-Cloud-Platform">请在此链接中找到完整的配置</a>：</p> 
<pre><code class="prism language-py"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"jobId"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span> <span class="token operator">//</span>Required<span class="token punctuation">:</span> user defined identifier <span class="token keyword">for</span> the job
  <span class="token string">"createTime"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>          <span class="token operator">//</span>Output Parameter<span class="token punctuation">:</span> indicates when a job was created 
  <span class="token string">"labels"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>                    <span class="token operator">//</span>Optional Input Parameter<span class="token punctuation">:</span> recommended to be used <span class="token keyword">for</span> organizing 
    string<span class="token punctuation">:</span> string<span class="token punctuation">,</span>              <span class="token operator">//</span><span class="token keyword">and</span> troubleshooting the run<span class="token operator">-</span>time jobs<span class="token punctuation">.</span>   
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token string">"trainingInput"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> <span class="token operator">//</span>Required<span class="token punctuation">:</span> specifies the <span class="token builtin">input</span> parameters <span class="token keyword">for</span> the training job<span class="token punctuation">.</span>  
 <span class="token builtin">object</span> <span class="token punctuation">(</span>TrainingInput<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">"predictionInput"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>           <span class="token operator">//</span>Required<span class="token punctuation">:</span> specifies the <span class="token builtin">input</span> parameters <span class="token keyword">for</span> the prediction job<span class="token punctuation">.</span> 
 <span class="token builtin">object</span> <span class="token punctuation">(</span>PredictionInput<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>具体来说，我们需要为运行时作业配置填充<code>TrainingInput</code>或<code>PredictionInput</code>资源。 这些对于特定请求是互斥的，并且在运行时仅需要使用这些输入参数之一。 让我们详细查看<code>TrainingInput</code>参数的以下 JSON 结构（<a href="https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Google-Cloud-Platform">请在此链接中找到完整的配置</a>）：</p> 
<pre><code class="prism language-py"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"scaleTier"</span><span class="token punctuation">:</span> enum <span class="token punctuation">(</span>ScaleTier<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token operator">//</span>Required<span class="token punctuation">:</span> specifies machine types<span class="token punctuation">,</span> count of replicas<span class="token punctuation">,</span> workers<span class="token punctuation">,</span>parameter servers
  <span class="token string">"packageUris"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                 <span class="token operator">//</span>Required<span class="token punctuation">:</span> These are the Google Cloud Storage locations <span class="token keyword">for</span>
    string                         <span class="token operator">//</span> the packages containing the training program along <span class="token keyword">with</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>                               <span class="token operator">//</span>          additional dependencies
  <span class="token string">"pythonModule"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>          <span class="token operator">//</span>Required<span class="token punctuation">:</span> The python module to run after importing <span class="token builtin">all</span> the 
  <span class="token string">"args"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                        <span class="token operator">//</span>packages <span class="token keyword">and</span> resolving the dependencies 
    string
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">"hyperparameters"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>             <span class="token operator">//</span>Optional<span class="token punctuation">:</span> The <span class="token builtin">set</span> of hyper<span class="token operator">-</span>parameters to be tuned<span class="token punctuation">.</span> 
    <span class="token builtin">object</span> <span class="token punctuation">(</span>HyperparameterSpec<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">"region"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>               <span class="token operator">//</span>Required<span class="token punctuation">:</span> The compute engine region on which the training job will run
<span class="token punctuation">}</span>
</code></pre> 
<p>我们将详细研究<code>ScaleTier</code>和<code>HyperParameterSpec</code>对象。 在此之前，让我们了解在提交预测作业时使用的<code>PredictionInput</code>对象的 JSON 结构，如以下代码块所示：</p> 
<pre><code class="prism language-py"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"dataFormat"</span><span class="token punctuation">:</span> enum <span class="token punctuation">(</span>DataFormat<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token operator">//</span>Required<span class="token punctuation">:</span> Format of the <span class="token builtin">input</span> data <span class="token builtin">file</span> <span class="token punctuation">(</span>JSON<span class="token punctuation">,</span> TEXT<span class="token punctuation">,</span> etc<span class="token punctuation">.</span><span class="token punctuation">)</span>    
  <span class="token string">"outputDataFormat"</span><span class="token punctuation">:</span> enum <span class="token punctuation">(</span>DataFormat<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token operator">//</span>Optional<span class="token punctuation">:</span> Format of the output data <span class="token builtin">file</span> <span class="token punctuation">(</span>default<span class="token operator">-</span>JSON<span class="token punctuation">)</span>
  <span class="token string">"inputPaths"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                         <span class="token operator">//</span>Required<span class="token punctuation">:</span> Cloud storage location of <span class="token builtin">input</span> data files
    string
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">"maxWorkerCount"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>               <span class="token operator">//</span>Optional<span class="token punctuation">:</span> Maximum number of workers <span class="token punctuation">(</span>default<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span>
  <span class="token string">"region"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>                       <span class="token operator">//</span>Required<span class="token punctuation">:</span> Google Compute Engine region
  <span class="token string">"runtimeVersion"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>               <span class="token operator">//</span>Optional<span class="token punctuation">:</span> AI Platform run<span class="token operator">-</span>time version
  <span class="token string">"batchSize"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>                    <span class="token operator">//</span>Optional<span class="token punctuation">:</span> Number of records per batch <span class="token punctuation">(</span>default<span class="token operator">-</span><span class="token number">64</span><span class="token punctuation">)</span>
  <span class="token string">"signatureName"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>                <span class="token operator">//</span>Optional<span class="token punctuation">:</span> Name of signature defined <span class="token keyword">in</span> the saved model
  <span class="token string">"modelName"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>                    
  <span class="token string">"versionName"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  <span class="token string">"uri"</span><span class="token punctuation">:</span> string
  <span class="token string">"outputPath"</span><span class="token punctuation">:</span> string
<span class="token punctuation">}</span>
</code></pre> 
<p>选择正确的参数后，可以极大地优化训练和预测表现。 我们需要了解各种规模的层和超参数，以进一步优化表现和成本。 根据训练数据的数量和算法的复杂性，选择合适的比例尺等级很重要。 想法是仅使用适当数量的资源进行训练和预测。 这有助于最小化训练单元的成本。 根据需要，高级层在 CPU 内核数和 GPU 利用率方面具有额外的容量。 但是，随着等级的提高，成本也会增加。 GCP 上有各种可用的规模级别，如下所示：</p> 
<ul>
<li>
<code>BASIC</code>：提供单个工作程序实例，适合于学习和实验。 这也可以用于小尺寸的概念证明（<strong>POC</strong>）。</li>
<li>
<code>STANDARD_1</code>：提供多个工作程序节点和仅几个参数服务器。</li>
<li>
<code>PREMIUM_1</code>：为大量工作器提供许多参数服务器。</li>
<li>
<code>BASIC_GPU</code>：为单个工作程序实例提供 GPU。</li>
<li>
<code>CUSTOM</code>：此层允许设置主服务器类型，工作程序计数，参数服务器计数和参数服务器类型的自定义值。 选择<code>CUSTOM</code>标度等级时，<code>TrainingInput</code>中的这些参数成为必需参数。</li>
</ul> 
<p>除了比例等级之外，我们还需要仔细选择超参数值，以进一步优化训练效果。</p> 
<h1>
<a id="_1051"></a>为训练工作选择超参数</h1> 
<p>通过<code>TrainingInput</code>对象中的<code>HyperparameterSpec</code>对象控制超参数。 以下代码块显示了<code>HyperParameterSpec</code>对象的结构：</p> 
<pre><code class="prism language-py"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"goal"</span><span class="token punctuation">:</span> enum <span class="token punctuation">(</span>GoalType<span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token operator">//</span>Required<span class="token punctuation">:</span> The <span class="token builtin">type</span> of goal used <span class="token keyword">for</span> tuning <span class="token punctuation">[</span>MAXIMIZE<span class="token operator">/</span>MINIMIZE<span class="token punctuation">]</span>
  <span class="token string">"params"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                         <span class="token operator">//</span>Required<span class="token punctuation">:</span> The <span class="token builtin">set</span> of parameters to be tuned
    <span class="token punctuation">{<!-- --></span>
      <span class="token builtin">object</span> <span class="token punctuation">(</span>ParameterSpec<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">"maxTrials"</span><span class="token punctuation">:</span> number<span class="token punctuation">,</span>               <span class="token operator">//</span>Optional<span class="token punctuation">:</span> Number of trials to be attempted <span class="token punctuation">(</span>default<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token string">"maxParallelTrials"</span><span class="token punctuation">:</span> number<span class="token punctuation">,</span>       <span class="token operator">//</span>Optional<span class="token punctuation">:</span> Number of parallel trials<span class="token punctuation">.</span> May <span class="token builtin">reduce</span> quality of                                              <span class="token operator">//</span>          optimization
  <span class="token string">"maxFailedTrials"</span><span class="token punctuation">:</span> number<span class="token punctuation">,</span>         <span class="token operator">//</span>Optional<span class="token punctuation">:</span> Number of failed trials before the hyper parameter tuning                                      <span class="token operator">//</span>          job <span class="token keyword">is</span> failed
  <span class="token string">"hyperparameterMetricTag"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span> <span class="token operator">//</span>Optional<span class="token punctuation">:</span> TensorFlow summary tag name <span class="token keyword">for</span> optimizing trials<span class="token punctuation">.</span> 
  <span class="token string">"resumePreviousJobId"</span><span class="token punctuation">:</span> string<span class="token punctuation">,</span>     
  <span class="token string">"enableTrialEarlyStopping"</span><span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>
  <span class="token string">"algorithm"</span><span class="token punctuation">:</span> enum <span class="token punctuation">(</span>Algorithm<span class="token punctuation">)</span>      <span class="token operator">//</span>Optional<span class="token punctuation">:</span> Search algorithm used by the hyper parameter tuning job
<span class="token punctuation">}</span>                                    <span class="token operator">//</span>          ALGORITHM_UNSPECIFIED <span class="token operator">/</span> GRID_SEARCH <span class="token operator">/</span> RANDOM_SEARCH
</code></pre> 
<p>虽然成本是选择计算资源时的基本考虑因素之一，但我们还需要了解，平台对训练资源的使用存在一些限制，这些限制由各种操作的配额设置。 让我们简要地看一下 AI 平台施加的配额限制。</p> 
<p>由于多租户云平台的固有性质，特定用户和项目所使用的资源需要受到配额的限制和控制，以防止错误地过度使用资源。 AI 平台还根据服务请求强加了一些配额限制。 分配给项目的任何用户帐户每分钟只能发起一定数量的单个 API 请求。 该限制适用于特定的 API 或一组 API，如下所示：</p> 
<ul>
<li>作业创建请求：1 分钟内最多可以发出 60 个请求。</li>
<li>预测请求：1 分钟内最多可以提出 6,000 个请求。</li>
<li>以下用于资源管理的子 API 的请求总数：每分钟最多 300 个请求： 
  <ul>
<li>
<code>list/get</code>（<code>projects.jobs</code>，<code>projects.model</code>秒，<code>projects.models.versions</code>，<code>projects.operations</code>）</li>
<li>
<code>delete/create</code>（<code>projects.models</code>，<code>projects.models</code>。<code>versions</code>）</li>
<li>
<code>cancel</code>（<code>projects.jobs</code>，<code>projects.operations</code>）</li>
<li><code>setDefault</code></li>
</ul> </li>
</ul> 
<p>除服务请求外，每个项目最多有 100 个模型，每个模型最多可以有 200 个版本。</p> 
<p>在某些情况下，无法创建具有这些限制的 AI 应用的生产版本。 GCP 允许通过管理控制台请求增加配额。 此外，AI 平台还限制了虚拟机的并发使用次数，如下所示：</p> 
<ul>
<li>并发预测节点数：72</li>
<li>预测节点中运行的并发 vCPU 数量：450</li>
</ul> 
<p>用于训练的 GPU 的限制如下：</p> 
<table>
<thead><tr>
<th><strong>GPU 类型</strong></th>
<th><strong>并行 GCP（训练）</strong></th>
<th><strong>并行 GPU（预测）</strong></th>
</tr></thead>
<tbody>
<tr>
<td>Tesla K80</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>Tesla P4</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>Tesla P100</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>Tesla V100</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>Tesla T4</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>我们需要从可用选项中仔细选择，以优化表现和成本。 在下一节中，我们将研究如何在 GCP 上监视 TensorFlow 模型作业。</p> 
<h1>
<a id="_TensorFlow__1104"></a>监控您的 TensorFlow 训练模型作业</h1> 
<p>模型训练工作所需的时间与训练数据量和训练模型的复杂度成比例。 应用必须能够报告训练工作的状态。 AI 平台提供了三种主要方法来监视训练工作。 GCP 控制台提供了用于列出训练作业的用户界面。 <code>gcloud</code> CLI 和自定义 Python 代码可用于获取训练作业的状态。</p> 
<p>以下是用于监视训练作业的<code>gcloud</code>命令：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform jobs describe job_name
</code></pre> 
<p>该命令返回当前正在运行的作业的状态，由<code>job_name</code>参数指示，如下所示：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform jobs <span class="token builtin">list</span> <span class="token operator">-</span><span class="token operator">-</span>limit<span class="token operator">=</span><span class="token number">5</span>
</code></pre> 
<p>此命令返回项目平台上当前正在运行的所有作业的列表。</p> 
<h1>
<a id="_1122"></a>总结</h1> 
<p>在本章中，我们已经了解了如何借助 Cloud ML Engine（AI 平台）在 GCP 上利用无服务器机器学习。 我们已经看到了访问 AI 平台的各种方法，以及构建 TensorFlow 应用以及打包和部署模型的方法。 我们还研究了在 AI 平台上组织应用，通过使用正确级别的基础架构来优化表现，同时节省成本的最佳实践。 最后，我们学习了如何使用命令行工具监视应用。</p> 
<p>在下一章中，我们将使用 TensorFlow 模型构建预测应用，并在 GCP 上采用实用的方法进行 AI 应用开发。</p> 
<h1>
<a id="_1128"></a>九、构建预测应用</h1> 
<p>云中的预测是关于开发预测机器学习模型，部署机器学习模型的最终版本，以及使用该部署模型使用云原生服务或基础架构从新到达的数据中预测目标值。 简而言之，云管理着基础架构和机器学习框架的高层抽象，可以轻松地用于训练或使用您的机器学习模型。</p> 
<p>与其他任何云提供商一样，Google Cloud 还提供了使用其本机服务运行基于机器学习的模型预测的功能。 在本章中，我们将研究使用 Google Cloud 服务执行预测所涉及的一些步骤，如下所示：</p> 
<ul>
<li>基于机器的智能预测概述</li>
<li>维护模型及其版本</li>
<li>深入研究已保存的模型</li>
<li>在 Google Cloud Platform（GCP）上部署模型</li>
<li>模型训练实例</li>
<li>使用服务端点执行预测</li>
</ul> 
<h1>
<a id="_1141"></a>基于机器的智能预测概述</h1> 
<p>预测分析是大数据的推动力：组织收集大量的实时客户数据，并且预测分析使用此历史数据结合消费者的直觉来预测未来事件。 预测分析使组织可以使用数据（历史数据和实时数据）从历史角度转换为客户的前瞻性角度。 预测分析使公司能够变得前瞻性和前瞻性，预测基于数据的结果和行动，而不是假设。</p> 
<p>规范性分析是建议采取行动以利用预测并提供决策选择的下一步骤，以从预测及其后果中受益。 可以使用部署在云上的服务进行预测。 这些服务可以作为易于使用的 API 公开，并且使分析人员可以轻松使用预测服务，而无需完全了解基础算法的细节。 GCP 组件使您可以更轻松地构建，部署和利用预测服务，而所需的精力和成本却更少。</p> 
<h1>
<a id="_1147"></a>了解预测过程</h1> 
<p>下图描述了在 GCP 上使用预测所涉及的高级步骤（这些步骤将在以下段落和章节中详细说明）：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ikvmCUuu-1681704646240)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/a706c49c-ee76-4601-b8ce-d9b01d660aac.png)]</p> 
<p>图 9.1：在 GCP 上使用预测的步骤</p> 
<p>开始预测过程的第一步是在完成模型训练后将模型导出为工件。 您需要将合格的机器学习模型导出为一个或多个工件，以实现来自 Google Cloud AI 平台的预测。 本章将说明如何在 GCP 上导出合格的 AI 系统预测模型。 根据用于构建模型的机器学习框架的类型，有多种选项可以导出模型。 例如，如果您已使用 TensorFlow 训练机器学习模型，则可以先使用<code>tf.save_model</code> API 保存模型，然后再使用 Google Cloud AI Platform 导出模型。</p> 
<p>下一步是部署模型。 Google Cloud AI 平台将托管模型，为您提供云预测。 模型部署是用于托管已保存模型文件的方法。 云预测供应商可以处理您的模型基础架构，并可以接受在线和批量预测的请求。 模型部署是预测过程中最重要的方面，必须对其进行详细了解。 在下一部分中，我们将详细介绍模型部署方面。</p> 
<p>部署模型后，就可以将模型用于在线预测或批量预测。 如果您想一次为一组观测值生成预测，然后对一定数量或一定百分比的观测值采取行动，则批量预测很有用。 通常，对于这样的请求，您没有低延迟要求。 这些预测然后存储在数据库中，开发人员或最终用户可以访问。 批量推断有时可以使用大数据技术（例如 Spark）来生成预测。</p> 
<p>批量推理技术规范比在线推理更简单。 例如，数据科学家可以简单地在执行批量推断的机器上反序列化经过训练的模型，而无需通过<strong>表述性状态转移</strong>（<strong>REST</strong>）API 公开经过训练的模型。 批量推断期间所做的预测也可以在最终利益相关者看到之前进行分析和处理。 下图显示了批量预测的工作原理：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CKPCJiII-1681704646240)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/914111e9-3c6e-4a00-86cf-84b917eeb6f2.png)]</p> 
<p>图 9.2：批量预测</p> 
<p>在线预测是根据请求实时创建用于机器学习的预测的方法。 这也称为实时或动态推理。 这些预测通常由运行时的单个数据观察生成。 在线推论预测可以在一天中的任何时间产生。 在线推论使我们能够实时使用机器模型。 它开辟了一个可以利用机器学习的全新技术领域。 无需等待数小时或数天的批量预测，我们可以在需要时立即生成预测，并立即提供服务。</p> 
<p>在线推论还有助于我们快速分析新数据，而不会产生延迟。 通常，在线推理比批量推理更具挑战性。 由于添加了满足延迟要求所需的工具和系统，因此在线推理往往更加复杂。 与需要 24 小时<strong>服务级别协议</strong>（<strong>SLA</strong>）的系统相比，需要在几毫秒内执行预测的程序要困难得多。 下图显示了在线预测的工作方式：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jq9VEu1c-1681704646240)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/d4756b43-32ab-46b1-91ff-fbb3de7f1192.png)]</p> 
<p>图 9.3：在线预测</p> 
<p>如果使用简单模型和少量输入案例，则完成在线预测和针对类似预防请求的批量分析所花费的时间将大大不同。 完成在线应用几乎立即返回的预测可能需要很长时间。 两种预测方法中使用的特定基础结构都有副作用。 提交订单后，AI 平台将分配并初始化批量预测资源。</p> 
<p>通常，可以根据要求准备在线预测。 下表总结了在线预测和批量预测之间的区别。</p> 
<table>
<thead><tr>
<th><strong>批量预测</strong></th>
<th><strong>在线预测</strong></th>
</tr></thead>
<tbody>
<tr>
<td>适用于具有复杂计算要求的海量大数据量。</td>
<td>适用于一次记录，具有低延迟和较简单的模型。</td>
</tr>
<tr>
<td>输出是具有多个预测结果的文件格式。</td>
<td>输出一次是一个响应，大多数为 JSON 格式。</td>
</tr>
<tr>
<td>异步请求和响应。</td>
<td>同步实时请求和响应。</td>
</tr>
<tr>
<td>它可以使用存储在某些外部存储（例如 Google Cloud 存储桶）中的模型，也可以使用通过 Google Cloud AI 平台进行部署的模型。</td>
<td>它只能使用通过 Google Cloud AI 平台部署的模型。</td>
</tr>
<tr>
<td>仅当使用通过 Google Cloud AI 平台部署的模型时，才对某些实例类型进行有限使用。</td>
<td>可以使用不同类型的计算实例进行运行预测。</td>
</tr>
</tbody>
</table>
<h1>
<a id="_1187"></a>维护模型及其版本</h1> 
<p>Google Cloud AI 平台可让您将机器学习解决方案组织为模型和版本。 模型是为您的机器学习解决方案提供的名称，该版本唯一地将部署的模型标识为工件。 例如，您可以创建一个名为<code>ProductCategoryIdentification</code>的模型，该模型表示用于对产品进行分类的机器学习解决方案。 在机器学习中，模型是要解决的问题的解决方案。</p> 
<p>换句话说，这是预测数据值的方法。 模型是 Google Cloud AI 平台上此 AI /机器学习解决方案的每次迭代的概念容器。 例如，要解决的问题是在给定与先前销售相关的一组数据的情况下，预测房屋的销售价格。 您构建一个称为房屋价格的 AI 应用模型，并尝试通过几种机器学习技术来解决问题。 您可以在每个级别上部署该模型的版本。 该版本可以与其他版本完全不同，但是如果适合您的工作流程，则可以将其布置在同一模型下。</p> 
<p>以下屏幕快照表示如何在 Google Cloud AI 平台上创建模型：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kQ6VQlMN-1681704646240)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/fb0e4ea1-9539-4f08-94fb-d2d15e01aecb.png)]</p> 
<p>图 9.4：创建新模型</p> 
<p>如您所见，模型创建用户界面与用户熟悉的 GCP 上的其他服务一致。 我们需要提供区分大小写的模型名称和区域作为强制属性。 建议提供可选描述，以提高模型的可维护性。 当我们针对各种用例构建和部署大量模型时，这一点尤其重要。 以下屏幕快照显示了平台上可通过用户界面或 API 使用的模型的列表：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-F3kibbe2-1681704646241)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/9281734d-dc30-4523-8ec6-4472d2fb5d84.png)]</p> 
<p>图 9.5：模型清单</p> 
<p>现在，在创建模型之后，您可以创建它的版本。 一个版本表示用来训练模型的机器学习代码和框架。 有时，数据科学家使用不同的框架（例如 XGBoost 或 TensorFlow）来设计针对同一问题的解决方案。 他们创建不同的版本来识别工件。 因此，模型版本或仅一个版本是存储在 AI 平台模型服务中的机器学习解决方案的实例。 您可以通过将经过训练的串行模型（作为保存的模型）传输到服务来制作版本。 您还可以提供自定义代码（在撰写本文时仍处于 beta 阶段），以在制作版本时管理预测。</p> 
<p>至少具有一个版本的每个模型都有一个默认版本。 生成第一个版本时，将设置默认值。 如果您请求仅指定模型名称的预测，则 AI 平台将使用该模型的默认版本。</p> 
<p>以下屏幕截图显示了如何管理版本：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uoFwrNIk-1681704646241)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/2eb319a2-c715-467d-8876-f7a75a83743a.png)]</p> 
<p>图 9.6：创建模型版本</p> 
<p>命名模型和版本的一些规则如下：</p> 
<ul>
<li>名称应仅包含字母（大小写混合），数字和下划线。</li>
<li>名称应以字母开头。</li>
<li>名称最多可包含 128 个字符。</li>
<li>该名称在项目中应该是唯一的（如果它是模型名称），在模型中应该是唯一的（如果它是版本名称）。</li>
</ul> 
<p>您还可以添加自定义内置代码所需的自定义包，如以下屏幕截图所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iavaQxaz-1681704646241)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/ba693e03-62d2-4baa-93b2-d10f755d1dbe.png)]</p> 
<p>图 9.7：添加自定义代码和包</p> 
<p>最终的输出屏幕将类似于以下屏幕截图中的屏幕：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZNX3pkw6-1681704646241)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/855bca73-b76e-4b4d-b64b-142d7d8110ff.png)]</p> 
<p>图 9.8：模型版本</p> 
<p>优良作法是，模型名称应简洁明了，因为您需要从多个名称列表中的日志或报告中选择它们。 简短的版本名称最适合维护。</p> 
<h1>
<a id="_1236"></a>深入研究已保存的模型</h1> 
<p>您需要将合格的机器学习模型导出（或保存）为一个或多个对象，以便执行 Google Cloud AI Platform 预测。 本部分介绍了导出用于 AI 系统预测部署的合格模型的各种方法。 根据您使用的机器学习平台的类型，Google Cloud AI 平台为您提供多种导出这些模型的方法。 这些方法特定于用于训练模型的框架。 我们将在本节中介绍 TensorFlow 保存的模型的某些方面。 您必须首先以 TensorFlow SavedModel 的格式将训练有素的模型导出到 Google Cloud AI 平台，以支持预测。</p> 
<p>保存的 TensorFlow 模型实际上包含具有权重和计算的 TensorFlow 程序。 它不是指向用于构建模型的代码，而是指向使用派生的数学参数进行预测所需的代码。 TensorFlow 被称为 SavedModel，是在 Google Cloud AI 平台中部署经过训练的模型的推荐格式。 建议导出 TensorFlow SavedModel。</p> 
<p>导出训练有素的 SavedModel 模型会将训练图保存为 Google Cloud AI Platform 特定的格式，可使用其元数据将其用于预测并还原。 SavedModel 提供了一种与语言无关的格式，用于保存可恢复且密封的机器学习模型。 它有助于更​​高级别的系统和资源生成，使用和处理 TensorFlow 模型。 以下是 SavedModel 的一些重要功能：</p> 
<ul>
<li> <p>可以使用单个变量和资产将单个 SavedModel 添加到多个图。 每个图都连接到一组标签，以便在加载或还原时进行标识。 图以协议缓冲区格式存储。</p> </li>
<li> <p>SavedModel 支持 SignatureDef（协议缓冲区消息的技术名称）。 SavedModel 使用此功能为与图存储的签名提供支持。 这些用于机器学习预测工作的图通常包含一堆数据输入和数据输出，称为签名。 签名具有以下结构：</p> </li>
<li> <p><code>inputs</code>：用于训练 TensorFlow 模型的相应数据输入存储了字符串映射列表。</p> </li>
<li> <p><code>outputs</code>：用于训练 TensorFlow 模型的相应数据输出存储了字符串映射列表。</p> </li>
<li> <p><code>method_name</code>：在 TensorFlow 框架中使用的受支持的命名方法。</p> </li>
<li> <p>SavedModel 也支持资产。 如果操作依赖于外部初始化文件（例如词汇表），则 SavedModel 将使用资产。 资产被复制到 SavedModel 目录，并在加载特定的元图定义时读取。</p> </li>
<li> <p>在生成 SavedModel 之前，它支持清除设备。</p> </li>
</ul> 
<p>如上一节所述，尽管 SavedModels 支持某些重要功能，但不支持其他功能。 这些如下：</p> 
<ul>
<li>它不支持隐式版本控制。</li>
<li>它本身不支持垃圾收集。 使用这些模型的外部工具可能对此提供支持。</li>
<li>它不支持对 TensorFlow SavedModels 的原子写入。</li>
</ul> 
<p>SavedModel 目录具有以下结构：</p> 
<pre><code class="prism language-py">assets<span class="token operator">/</span>
assets<span class="token punctuation">.</span>extra<span class="token operator">/</span>
variables<span class="token operator">/</span>
    variables<span class="token punctuation">.</span>data<span class="token operator">-</span>?????<span class="token operator">-</span>of<span class="token operator">-</span>?????
    variables<span class="token punctuation">.</span>index
saved_model<span class="token punctuation">.</span>pb
</code></pre> 
<p><code>saved_model.pb</code>或<code>saved_model.pbtxt</code>文件是协议缓冲区文件，其中包括所有图定义作为 MetaGraphDef 协议缓冲区消息。 <code>assets</code>子文件夹包含支持的辅助文件，例如文本词汇文件。 <code>assets.extra</code>子文件夹包含可以与模型共存的用户添加的资产，但是不会在运行时加载。 用户或最终开发人员必须自己管理它，因为 TensorFlow 库不管理它。 <code>variables</code>子文件夹包含 TensorFlow 库 TensorFlow 保护程序的输出。</p> 
<h1>
<a id="TensorFlow_SavedModel__SignatureDef_1272"></a>TensorFlow SavedModel 中的 SignatureDef</h1> 
<p>SignatureDef 确定 TensorFlow 图辅助计算的签名。 SignatureDefs 旨在为定义函数的输入和输出提供通用支持。 TF-Exporter 和 SessionBundle 使用的签名在概念上相似，但是允许用户区分命名签名和默认签名，以便在加载时可以正确检索它们。 对于以前使用 TF-Exporter / SessionBundle 的用户，TF-Exporter 中的签名将由 SavedModel 中的 SignatureDefs 替换。 TensorFlow Serving 提供高级 API 进行演绎。 要允许这些 API，模型应包含一个或多个 SignatureDef，它们描述了用于输入和输出的确切 TensorFlow 节点。 请参阅以下针对每个 API 支持 TensorFlow Serving 的 SignatureDef 示例。</p> 
<p>分类 SignatureDefs 支持对 TensorFlow Serving 的分类 API 的标准化调用。 这些指定应该有一个 Tensor 输入，并且有两个可能的 Tensor 输出：类和等级，至少需要存在一个。 以下屏幕快照显示了分类 SignatureDefs 的结构：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Fi8EMAd5-1681704646241)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/18e95aff-fb52-49e4-97bf-2ff83917e77e.png)]</p> 
<p>图 9.9：分类消息 API 有效负载</p> 
<p>预测 SignatureDefs 支持对 TensorFlow Serving 的 Predict API 的调用。 这样的签名使您可以任意支持多个输入和输出张量。 对于以下示例，我的预测签名具有特定的逻辑张量图像，该图像在您的图<code>x:0</code>中映射到实际张量。 预测 SignatureDefs 允许模型到模型的可移植性。 这意味着您可以在不同的 SavedModels 中处理不同的基础 Tensor 名称（例如，您可能具有张量<code>Z:0</code>而不是<code>x:0</code>的替代模型），因此您的客户将继续在网络上测试新旧模型，而不会改变客户方面。 预测 SignatureDefs 允许您向输出中添加其他张量，您可以显式请求这些张量。 假设除了<code>scores</code>下面的输出键之外，您还希望获取堆层用于调试或其他目的。 在这种情况下，只需添加带有池密钥和适当值的附加张量即可。 以下屏幕截图显示了预测 SignatureDefs 的结构：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Mp9axtQU-1681704646242)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/b1f2ac0e-43e1-4aee-912b-b959f87b56d6.png)]</p> 
<p>图 9.10：分类 API 响应</p> 
<p>回归 SignatureDefs 支持对 TensorFlow 服务回归 API 的结构化调用，该 API 恰好需要一个张量输入和一个张量输出。 以下屏幕截图显示了回归 SignatureDefs 的结构：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vaBMNZGU-1681704646242)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/a30276d6-aa5a-447f-9ff2-4bcd056be936.png)]</p> 
<p>图 9.11：回归 SignatureDef 的结构</p> 
<h1>
<a id="TensorFlow_SavedModel_API_1294"></a>TensorFlow SavedModel API</h1> 
<p>如下图所示，TensorFlow SavedModel 有两个主要的 API。 一个是 Builder API，另一个是 Loader API。 一旦 Loader API 加载了 SavedModel，它将用于预测：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rPBFEvP3-1681704646242)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/1a8077f3-8458-4058-aa5d-6c4a67e13c45.png)]</p> 
<p>图 9.12：Tensorflow SavedModel API</p> 
<p><code>SavedModelBuilder</code>类提供了多个要保存的元图定义，相关变量和属性。 必须使用变量保存第一个元图，以便构建 SavedModel。 以下元图及其图说明易于保存。 当必须保存属性并将其写入或复制到磁盘时，可以在插入元语法定义时提供属性。 如果将多个元图定义连接到同名资产，则仅保留第一个版本。 每个 SavedModel 元图必须用反映元图功能和特定于案例的用户标签的标签标注。</p> 
<p>这样的标签通常包括带有其属性（例如，服务或训练）以及可能的硬件特定方面（例如 GPU）的元图。 SavedModel 中的定义元图的标记集与 Loader API 中的标记集完全匹配，是加载程序加载的图元。 如果没有定义元图与列出的标签匹配，将返回错误。 例如，需要 GPU 服务的加载程序可以通过在<code>tensorflow::LoadSavedModel(...)</code>中指定标签来仅加载带有<code>tags=serve</code>（GPU）标注的元图。 以下屏幕快照中的代码表示如何使用 Builder API：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E8qnH5xy-1681704646243)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/80e8f419-229d-4752-a5b6-861f5cf779b8.png)]</p> 
<p>图 9.13：API Builder 代码</p> 
<p>使用 SavedModelBuilder 包，用户可以测试在添加 SavedModel 包元图时是否必须从 NodeDefs 中删除默认评估的属性。 <code>SavedModelBuilder.add</code>元语法和变量以及<code>SavedModelbuilder.add</code>元图都接受控制此行为的带状默认属性<code>boolean</code>标志。 通过将条带默认属性设置为<code>True</code>，模型创建者可以删除 NodeDefs 中任何具有值的默认属性。 这有助于确保具有默认值的新属性不会导致较旧的模型使用者无法加载已使用新训练二进制文件重新生成的模型。</p> 
<p>加载程序 API 用 C++ 和 Python 实现。 Python 的 SavedModel 加载程序版本包含 SavedModel 加载和还原功能。 加载功能包括用于恢复图形描述和变量的会话，用于定义默认加载元图的标签以及 SavedModel 的位置。 特定元图定义中提供的变量和资产的子集将还原到加载时提供的会话。 加载程序 API 的代表性 Python 代码如下所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LYbX4crt-1681704646243)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/bcef2cfa-6609-44fe-906b-e79ee83bf28c.png)]</p> 
<p>图 9.14：API 加载程序代码</p> 
<p>C++ 的 SavedModel 加载器版本提供了一个 API，用于从路径加载 SavedModel，允许使用<code>SessionOptions</code>和<code>RunOptions</code>。 与 Python 版本相比，C++ 版本需要加载和定义与图关联的标签。 加载的此版本 SavedModel 称为 SavedModelBundle，其中包括定义元图和加载会话。 Loader API 的代表性 C++ 代码如下所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NpSymrKF-1681704646244)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/b15edc53-8325-4b7c-a5b1-475273e1bab8.png)]</p> 
<p>图 9.15：Loader API 代码的 C++ 实现</p> 
<p>SavedModel 为构建和加载用于各种应用的 TensorFlow 图提供了灵活性。 SavedModel API 提供了许多 Python 和 C++ 常量，这些常量易于使用，并且在针对最常见的预期应用的工具之间始终保持共享。</p> 
<h1>
<a id="_GCP__1326"></a>在 GCP 上部署模型</h1> 
<p>要在导出机器学习模型后对其进行部署，则必须部署导出的模型。 部署模型的第一步是将它们存储在 Google Cloud Storage 存储桶中。 通常，专用的云存储分区更易于用于 Google Cloud AI 平台的同一项目。 如果您使用其他项目中的存储桶，则需要确保可以访问 Google Cloud AI Platform 服务帐户中的云存储模型。 没有必需的权限，您尝试构建 Google Cloud AI Platform 模型版本的尝试将失败。</p> 
<p>让我们开始研究如何创建 Google Cloud Storage 存储桶。 可以使用现有存储桶，但它必须位于您计划在 Google Cloud AI 平台上工作的同一区域。 以下代码可以帮助您创建新的存储桶：</p> 
<pre><code class="prism language-py">BUCKET_NAME<span class="token operator">=</span><span class="token string">"google_cloud_ai_platform_your_bucket_name"</span>
PROJECT_ID<span class="token operator">=</span>$<span class="token punctuation">(</span>gcloud config <span class="token builtin">list</span> project <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">format</span> <span class="token string">"value(core.project)"</span><span class="token punctuation">)</span>
BUCKET_NAME<span class="token operator">=</span>$<span class="token punctuation">{<!-- --></span>PROJECT_ID<span class="token punctuation">}</span><span class="token operator">-</span>mlengine
echo $BUCKET_NAME
REGION<span class="token operator">=</span>us<span class="token operator">-</span>east2
gsutil mb <span class="token operator">-</span>l $REGION gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME
</code></pre> 
<p>前面的代码指定您的新存储桶名称。 它定义了创建存储桶所需的项目 ID。 然后，您指定要在其中创建存储桶的区域的名称。 最后，使用<code>gsutil</code> <strong>命令行界面</strong>（<strong>CLI</strong>）创建存储桶。</p> 
<p><a href="https://cloud.google.com/storage/docs/gsutil">可以在以下链接中找到对<code>gsutil</code>工具的完整引用</a>。</p> 
<p>以下屏幕截图提供了有关如何使用控制台 UI 创建存储桶的指南：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8CXBNUL3-1681704646244)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/1c0f9278-c0a5-4626-b8be-2e9875d3bc0f.png)]</p> 
<p>图 9.16：GCP 控制台–存储和浏览</p> 
<p>从控制台菜单中，我们需要导航到“存储”部分，然后单击“浏览器”部分以找到存储在存储桶中的所有数据文件。 如果用户帐户有权创建多区域存储桶，则使用此控制台 UI 可以在一处看到跨区域存储桶的所有数据文件，如以下屏幕快照所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-t5rFVapK-1681704646244)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/fe1daa9b-28b0-44f6-832c-93da34fdee6d.png)]</p> 
<p>图 9.17：存储桶列表</p> 
<p>GCP 控制台提供了一个轻松的界面来创建新的存储桶。 这是我们单击<code>CREATE BUCKET</code>按钮时打开的初始页面的屏幕截图：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UDfND3P0-1681704646245)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/0c561492-db97-4393-ac82-31d31c6cee8c.png)]</p> 
<p>图 9.18：创建新存储桶</p> 
<p>我们需要为该存储桶提供一个在整个项目中唯一的名称。 此外，我们需要提供区域和默认存储类，并在 GCP 中创建存储桶时定义访问级别（可以访问存储桶的用户组和用户）。 提供详细信息后，GCP 提供了一个简单的界面来查看每月成本估计，以获取并保存正在创建的存储桶中的数据。 这有助于在创建存储桶时根据用例和应用的上下文选择适当的选项。 如果配置不正确，GCP 可以轻松避免可能导致高成本的错误。</p> 
<h1>
<a id="_Google_Cloud_Storage__1365"></a>将已保存的模型上传到 Google Cloud Storage 存储桶</h1> 
<p>下一步是将模型上传到 Google Cloud Storage 存储桶。 如果您正在使用 Tensorflow SavedModels，则可以使用以下代码上传模型：</p> 
<pre><code class="prism language-py">SAVED_MODEL_DIR<span class="token operator">=</span>$<span class="token punctuation">(</span>ls <span class="token punctuation">.</span><span class="token operator">/</span>your<span class="token operator">-</span>export<span class="token operator">-</span><span class="token builtin">dir</span><span class="token operator">-</span>base <span class="token operator">|</span> tail <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
gsutil cp <span class="token operator">-</span>r $SAVED_MODEL_DIR gs<span class="token punctuation">:</span><span class="token operator">//</span>your<span class="token operator">-</span>bucket
</code></pre> 
<p>如果您从<code>tf.keras</code>或 TensorFlow 估计器导出 SavedModel，则所选导出目录的子目录将另存为带有时间戳的代码目录/ <code>123201202301</code>。 本示例说明如何使用当前时间戳更新目录。 如果您以其他方式构建了 SavedModel，则可以将其放置在本地文件系统上的其他位置。</p> 
<p>如果您已使用 scikit-learn 或 XGBoost 导出了模型，则可以使用以下代码以<code>.joblib</code>，<code>*.pk1</code>或<code>*.bst</code>格式导出模型：</p> 
<pre><code class="prism language-py">gsutil cp <span class="token punctuation">.</span><span class="token operator">/</span>model<span class="token punctuation">.</span>joblib gs<span class="token punctuation">:</span><span class="token operator">//</span>your<span class="token operator">-</span>bucket<span class="token operator">/</span>model<span class="token punctuation">.</span>joblib

gsutil cp <span class="token punctuation">.</span><span class="token operator">/</span>model<span class="token punctuation">.</span>pkl gs<span class="token punctuation">:</span><span class="token operator">//</span>your<span class="token operator">-</span>bucket<span class="token operator">/</span>model<span class="token punctuation">.</span>pkl

gsutil cp <span class="token punctuation">.</span><span class="token operator">/</span>model<span class="token punctuation">.</span>bst gs<span class="token punctuation">:</span><span class="token operator">//</span>your<span class="token operator">-</span>bucket<span class="token operator">/</span>model<span class="token punctuation">.</span>bst
</code></pre> 
<p>如果您具有自定义的预测例程（测试版），则还可以将一些其他示例对象上载到应用目录。 如果您使用的是旧版计算机（MLS1）类型，则配置目录的最小文件大小必须为 500 MB 或更小；如果使用的是 Compute Engine（N1）类型的计算机（beta），则配置目录的最小文件大小必须为 2 GB 或更小。 在构建模式的后续迭代时，请将其存储在云存储桶中的单独目录中。 如果您部署带有自定义代码或自定义预测例程的 Science Learning 管道，则还必须上传包含自定义代码的源交付包。 您可以将以下代码用于相同的代码：</p> 
<pre><code class="prism language-py">gsutil cp dist<span class="token operator">/</span>google_cloud_ai_custom_code<span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz gs<span class="token punctuation">:</span><span class="token operator">//</span>ai<span class="token operator">-</span>ml<span class="token operator">-</span>bucket<span class="token operator">/</span>google_cloud_ai_custom_code<span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
</code></pre> 
<h1>
<a id="_1392"></a>测试机器学习模型</h1> 
<p>下一步是测试机器学习模型。 机器学习领域提供了一些工具，可以根据数据自动做出决策，以实现某些目标或要求。 手动指定的解决方案会遇到一些问题。 机器学习很重要，因为它为复杂的问题提供了解决方案。 与手动指定的解决方案相比，机器学习可为您提供自动，更快，更精确的问题解决方案。 机器学习应用并非 100% 准确，并且永远不会部分正确。 关于测试人员为何不能忽略对计算机教育和深度学习的思考，有多种解释。 主要原因是这些程序从用于构造算法的数据中学习。 由于机器学习应用几乎每天都在处理人类活动，因此错误可能导致严重的损失。 代替这些事实，机器学习模型测试非常重要。</p> 
<p>测试机器学习解决方案涉及多个方面。 这样的方面之一是确保用于训练的数据的质量。 您对训练的测试应确保没有可以歪曲结果的数据集。 训练数据的<strong>质量保证</strong>（<strong>QA</strong>）创建检查协议，以验证用于训练的数据是否已被消毒。 还必须执行检查以确定是否意外或故意发生了数据中毒攻击。 与数据统计有关的测试（中位数，平均值，样式等）描述了高级数据和关系。 您应该使用脚本创建测试以检查统计信息和相关性。 这些测试应定期进行。 必须定期跟踪列出的参数，并在每次发布之前进行验证。</p> 
<p>您还应该针对机器学习模型训练中使用的特征执行测试。 多次，一个或多个特征是冗余/不相关的，实际上会影响预测错误率。 需要采用质量保证/测试程序来主动确定设计技术，例如降低尺寸和选择特征。</p> 
<p>最后但并非最不重要的一点是，您还应该确保模型训练算法的质量。 不断发展的数据集可能会由于数据中毒攻击而导致预览错误级别增加。 随着机器学习模型的重新训练，增加的预测错误率意味着机器学习模型将被重新估值，以检测新算法，而现有算法的准确率更高。 重新训练所有模型，并使用新的数据集定期跟踪模型输出。 如果另一个模型比现有模型更可靠或更成功，则会引发缺陷。</p> 
<p>您可以在 Google Cloud AI Platform 预测中使用本地<code>predict</code>命令检查模型的预测方式，然后再使用它。 该命令使用本地依赖性来预测并以与执行在线预测后的 Google Cloud AI 平台相同的格式返回结果。 测试本地预测将使您能够在计算在线预测请求成本之前发现错误。 对于<code>--model-dir</code>语句，您可以定义一个目录，并将您的机器学习模型导出到本地计算机或云存储中。 另外，为<code>--framework</code>参数指定<code>tensorflow</code>，<code>sklearn</code>或<code>xgboost</code>。 您不能将本地预测命令 Google Cloud AI Platform 与自定义预测例程一起使用。 以下屏幕截图显示了用于本地模型测试的代码：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform local predict <span class="token operator">-</span><span class="token operator">-</span>model<span class="token operator">-</span><span class="token builtin">dir</span> local<span class="token operator">-</span><span class="token keyword">or</span><span class="token operator">-</span>cloud<span class="token operator">-</span>storage<span class="token operator">-</span>path<span class="token operator">-</span>to<span class="token operator">-</span>model<span class="token operator">-</span>directory<span class="token operator">/</span> 
  <span class="token operator">-</span><span class="token operator">-</span>json<span class="token operator">-</span>instances local<span class="token operator">-</span>path<span class="token operator">-</span>to<span class="token operator">-</span>prediction<span class="token operator">-</span><span class="token builtin">input</span><span class="token punctuation">.</span>json 
  <span class="token operator">-</span><span class="token operator">-</span>framework name<span class="token operator">-</span>of<span class="token operator">-</span>framework
</code></pre> 
<h1>
<a id="_1410"></a>部署模型及其版本</h1> 
<p>Google Cloud AI 平台使用模型和版本资源来组织您训练有素的模型。 AI 平台是学习机模型的容器。 在 AI 平台中，创建数据库资源以部署模型，构建模型版本，然后将模型版本连接到存储在云存储中的模型文件。 您可以使用<code>gcloud</code>控制台为您的产品版本构建默认工具，并在不附带括号的情况下填写您的首选模型名称，如下所示：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform models create <span class="token string">"[YOUR-MODEL-NAME]"</span>
</code></pre> 
<p>您还可以使用 REST API 创建模型资源。 以下是相同的步骤：</p> 
<ol><li>通过将模型对象插入请求主体来格式化规范。 您至少必须给模型起一个名字。 如下填写您的姓名（不带括号）：</li></ol> 
<pre><code class="prism language-py"><span class="token punctuation">{<!-- --></span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"[YOUR-MODEL-NAME]"</span><span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>将以下文章放入您的 REST API 中，并用正确的值替换[括号中的值]，如下所示：</li></ol> 
<pre><code class="prism language-py">POST https<span class="token punctuation">:</span><span class="token operator">//</span>ml<span class="token punctuation">.</span>googleapis<span class="token punctuation">.</span>com<span class="token operator">/</span>v1<span class="token operator">/</span>projects<span class="token operator">/</span><span class="token punctuation">[</span>YOUR<span class="token operator">-</span>PROJECT<span class="token operator">-</span>ID<span class="token punctuation">]</span><span class="token operator">/</span>models<span class="token operator">/</span>

curl <span class="token operator">-</span>X POST <span class="token operator">-</span>H <span class="token string">"Content-Type: application/json"</span> 
  <span class="token operator">-</span>d <span class="token string">'{"name": "[YOUR-MODEL-NAME]"}'</span> 
  <span class="token operator">-</span>H <span class="token string">"Authorization: Bearer `gcloud auth print-access-token`"</span> 
  <span class="token string">"https://ml.googleapis.com/v1/projects/[YOUR-PROJECT-ID]/models"</span>
</code></pre> 
<p>前面命令的示例 JSON 输出将类似于以下屏幕快照所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n6z8RpW1-1681704646245)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/cf45a00a-e7fc-4f0b-b924-f849bdc6e1e5.png)]</p> 
<p>图 9.19：REST API 调用的 JSON 输出</p> 
<p>创建模型资源后，即可创建模型版本。 我们将在这里看到如何做到这一点。 使用 Google Cloud API，您可以创建版本，如以下屏幕截图所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8uCrmq41-1681704646245)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/b0ba9e67-bed7-4d58-8a22-9cbcb35ec66a.png)]</p> 
<p>图 9.20：新创建的模型和模型列表页面</p> 
<p>如前面的屏幕快照所示，选择模型工具的名称以在“模型”选项卡上构建您的版本。 这将带您浏览产品页面。 在“模型详细信息”页面的顶部，单击“新版本”按钮。 这将带您到版本开发页面，如以下屏幕截图所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oqj4hREi-1681704646246)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/5b970c60-7e75-432a-b6ad-633e8ba806e7.png)]</p> 
<p>图 9.21：新模型版本开发屏幕</p> 
<p>创建模型版本时要注意的一件事是您可以选择手动和自动缩放的缩放选项。 如果选择“自动缩放”，则会显示可选的最小字段节点数。 您可以输入最少的节点数，以在服务减少时继续运行。 默认区域为<code>0</code>。 如果选择“手动缩放”，则需要始终输入要运行的节点数。 请参考以下屏幕截图：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-leJRv7LJ-1681704646246)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/eeda24b1-966d-4e59-8efa-44c061b7552b.png)]</p> 
<p>图 9.22：手动缩放配置</p> 
<p>需要仔细选择“手动缩放”选项。 无论群集上的负载如何，GCP 都会提供已配置的节点数（在手动扩展的情况下，这是必填字段）。 此操作适用于关键任务用例，这些用例需要频繁地在波动的级别上访问模型，并且不提供 Google Cloud AI Platform 在合理的时间内配置所需的节点。 在这种情况下，建议根据平均流量水平提供最少数量的节点。 即使没有发送任何模型访问请求，预配节点也将产生成本，如以下屏幕截图所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tp8ZdLqS-1681704646246)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/ae276099-4fb3-4d52-8f99-c872c49e1a18.png)]</p> 
<p>图 9.23：自动缩放比例配置</p> 
<p>实现此目的的另一种方法是使用<code>gcloud</code> CLI。 如果使用<code>gcloud</code>，则首先设置环境变量以保存云存储目录路径，模型名称，版本名称和框架选择。 创建<code>gcloud</code>工具版本时，可以在框架名称中使用大写字母（例如，<code>_SCIKIT-LEARN</code>）添加下划线，也可以使用小写字母（例如，<code>_scikit-learn</code>）添加连字符。 所有方法导致相同的行为。 以下代码块显示了如何在脚本中设置相关的环境变量：</p> 
<pre><code class="prism language-py">MODEL_DIR<span class="token operator">=</span><span class="token string">"gs://your_bucket_name/"</span>
VERSION_NAME<span class="token operator">=</span><span class="token string">"[YOUR-VERSION-NAME]"</span>
MODEL_NAME<span class="token operator">=</span><span class="token string">"[YOUR-MODEL-NAME]"</span>
FRAMEWORK<span class="token operator">=</span><span class="token string">"[YOUR-FRAMEWORK_NAME]"</span>
</code></pre> 
<p>在具有定制代码的 scikit-learn 管道的定制代码 tarball 的路径上设置一个附加变量，如下所示：</p> 
<pre><code class="prism language-py">MODEL_DIR<span class="token operator">=</span><span class="token string">"gs://your_bucket_name/"</span>
VERSION_NAME<span class="token operator">=</span><span class="token string">"[YOUR-VERSION-NAME]"</span>
MODEL_NAME<span class="token operator">=</span><span class="token string">"[YOUR-MODEL-NAME]"</span>
FRAMEWORK<span class="token operator">=</span><span class="token string">"scikit-learn"</span>
CUSTOM_CODE_PATH<span class="token operator">=</span><span class="token string">"gs://your_bucket_name/ai_platform_custom_code-0.1.tar.gz"</span>
</code></pre> 
<p>要执行自定义预测例程，请忽略<code>FRAMEWORK</code>变量，然后定义自定义代码 tarball 的路径以及预测变量类的名称。 检查以下代码：</p> 
<pre><code class="prism language-py">MODEL_DIR<span class="token operator">=</span><span class="token string">"gs://your_bucket_name/"</span>
VERSION_NAME<span class="token operator">=</span><span class="token string">"[YOUR-VERSION-NAME]"</span>
MODEL_NAME<span class="token operator">=</span><span class="token string">"[YOUR-MODEL-NAME]"</span>
CUSTOM_CODE_PATH<span class="token operator">=</span><span class="token string">"gs://your_bucket_name/ai_platform_custom_code-0.1.tar.gz"</span>
PREDICTOR_CLASS<span class="token operator">=</span><span class="token string">"[MODULE_NAME].[CLASS_NAME]"</span>
</code></pre> 
<p>一旦设置了相关的环境变量，就可以使用 CLI 通过以下代码创建版本：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform versions create $VERSION_NAME 
  <span class="token operator">-</span><span class="token operator">-</span>model $MODEL_NAME 
  <span class="token operator">-</span><span class="token operator">-</span>origin $MODEL_DIR 
  <span class="token operator">-</span><span class="token operator">-</span>runtime<span class="token operator">-</span>version<span class="token operator">=</span><span class="token number">1.15</span> 
  <span class="token operator">-</span><span class="token operator">-</span>framework $FRAMEWORK 
  <span class="token operator">-</span><span class="token operator">-</span>python<span class="token operator">-</span>version<span class="token operator">=</span><span class="token number">3.7</span>
</code></pre> 
<p>将<code>gcloud</code> beta 组件用于 scikit-learn 管道（beta），并确保您设置了<code>--package-uris-flag</code>，如下所示：</p> 
<pre><code class="prism language-py">gcloud components install beta

gcloud beta ai<span class="token operator">-</span>platform versions create $VERSION_NAME 
  <span class="token operator">-</span><span class="token operator">-</span>model $MODEL_NAME 
  <span class="token operator">-</span><span class="token operator">-</span>origin $MODEL_DIR 
  <span class="token operator">-</span><span class="token operator">-</span>runtime<span class="token operator">-</span>version<span class="token operator">=</span><span class="token number">1.15</span> 
  <span class="token operator">-</span><span class="token operator">-</span>framework $FRAMEWORK 
  <span class="token operator">-</span><span class="token operator">-</span>python<span class="token operator">-</span>version<span class="token operator">=</span><span class="token number">3.7</span>
  <span class="token operator">-</span><span class="token operator">-</span>package<span class="token operator">-</span>uris<span class="token operator">=</span>$CUSTOM_CODE_PATH
</code></pre> 
<p>将<code>gcloud</code> beta 部分用于自定义预测例程，删除<code>--frame</code>标志，并设置<code>--package-uris</code>和<code>--prediction-class</code>标志，如下所示：</p> 
<pre><code class="prism language-py">gcloud components install beta

gcloud beta ai<span class="token operator">-</span>platform versions create $VERSION_NAME 
  <span class="token operator">-</span><span class="token operator">-</span>model $MODEL_NAME 
  <span class="token operator">-</span><span class="token operator">-</span>origin $MODEL_DIR 
  <span class="token operator">-</span><span class="token operator">-</span>runtime<span class="token operator">-</span>version<span class="token operator">=</span><span class="token number">1.15</span> 
  <span class="token operator">-</span><span class="token operator">-</span>python<span class="token operator">-</span>version<span class="token operator">=</span><span class="token number">3.7</span>
  <span class="token operator">-</span><span class="token operator">-</span>package<span class="token operator">-</span>uris<span class="token operator">=</span>$CUSTOM_CODE_PATH
  <span class="token operator">-</span><span class="token operator">-</span>prediction<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">=</span>$PREDICTOR_CLASS
</code></pre> 
<p>您可以检查模型版本，如下所示：</p> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform versions describe $VERSION_NAME 
  <span class="token operator">-</span><span class="token operator">-</span>model $MODEL_NAME

<span class="token operator">/</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span>Output<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span><span class="token operator">/</span>
createTime<span class="token punctuation">:</span> <span class="token string">'2018-02-28T16:30:45Z'</span>
deploymentUri<span class="token punctuation">:</span> gs<span class="token punctuation">:</span><span class="token operator">//</span>your_bucket_name
framework<span class="token punctuation">:</span> <span class="token punctuation">[</span>YOUR<span class="token operator">-</span>FRAMEWORK<span class="token operator">-</span>NAME<span class="token punctuation">]</span>
machineType<span class="token punctuation">:</span> mls1<span class="token operator">-</span>c1<span class="token operator">-</span>m2
name<span class="token punctuation">:</span> projects<span class="token operator">/</span><span class="token punctuation">[</span>YOUR<span class="token operator">-</span>PROJECT<span class="token operator">-</span>ID<span class="token punctuation">]</span><span class="token operator">/</span>models<span class="token operator">/</span><span class="token punctuation">[</span>YOUR<span class="token operator">-</span>MODEL<span class="token operator">-</span>NAME<span class="token punctuation">]</span><span class="token operator">/</span>versions<span class="token operator">/</span><span class="token punctuation">[</span>YOUR<span class="token operator">-</span>VERSION<span class="token operator">-</span>NAME<span class="token punctuation">]</span>
pythonVersion<span class="token punctuation">:</span> <span class="token string">'3.7'</span>
runtimeVersion<span class="token punctuation">:</span> <span class="token string">'1.15'</span>
state<span class="token punctuation">:</span> READY
</code></pre> 
<p>例如，具有 Cloud ML 服务智能体<strong>身份和访问管理</strong>（<strong>IAM</strong>）功能的模型版本具有 Google 托管服务帐户的权限。 对于大多数情况，此默认服务帐户就足够了。 但是，如果您正在使用自定义预测例程，并且需要在模型版本中具有一组不同的权限，则可以添加另一个服务帐户以供使用。 例如，如果您的模型版本需要从特定的 Google Cloud 项目访问云存储存储桶，则可以定义具有该存储桶读取权限的服务帐户。 以下代码块显示了用于创建服务帐户的示例 Python 代码：</p> 
<pre><code class="prism language-py"><span class="token keyword">import</span> os

<span class="token keyword">from</span> google<span class="token punctuation">.</span>oauth2 <span class="token keyword">import</span> service_account
<span class="token keyword">import</span> googleapiclient<span class="token punctuation">.</span>discovery

<span class="token keyword">def</span> <span class="token function">create_service_account</span><span class="token punctuation">(</span>project_id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> display_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Creates a service account."""</span>

    credentials <span class="token operator">=</span> service_account<span class="token punctuation">.</span>Credentials<span class="token punctuation">.</span>from_service_account_file<span class="token punctuation">(</span>
        filename<span class="token operator">=</span>os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'GOOGLE_APPLICATION_CREDENTIALS'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        scopes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'https://www.googleapis.com/auth/cloud-platform'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    service <span class="token operator">=</span> googleapiclient<span class="token punctuation">.</span>discovery<span class="token punctuation">.</span>build<span class="token punctuation">(</span>
        <span class="token string">'iam'</span><span class="token punctuation">,</span> <span class="token string">'v1'</span><span class="token punctuation">,</span> credentials<span class="token operator">=</span>credentials<span class="token punctuation">)</span>

    my_service_account <span class="token operator">=</span> service<span class="token punctuation">.</span>projects<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>serviceAccounts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>create<span class="token punctuation">(</span>
        name<span class="token operator">=</span><span class="token string">'projects/'</span> <span class="token operator">+</span> project_id<span class="token punctuation">,</span>
        body<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>
            <span class="token string">'accountId'</span><span class="token punctuation">:</span> name<span class="token punctuation">,</span>
            <span class="token string">'serviceAccount'</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">'displayName'</span><span class="token punctuation">:</span> display_name
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Created service account: '</span> <span class="token operator">+</span> my_service_account<span class="token punctuation">[</span><span class="token string">'email'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> my_service_account
</code></pre> 
<p>部署模型版本的用户应为先前创建的服务帐户使用服务帐户令牌创建者角色。 在<code>serviceAccount</code>区域中指定模型版本的服务帐户名称。 使用<code>gcloud</code>方法时，可以使用<code>--service-account</code>标志，如以下代码示例所示：</p> 
<pre><code class="prism language-py">gcloud components install beta

gcloud beta ai<span class="token operator">-</span>platform versions create your<span class="token operator">-</span>version<span class="token operator">-</span>name 
  <span class="token operator">-</span><span class="token operator">-</span>service<span class="token operator">-</span>account your<span class="token operator">-</span>service<span class="token operator">-</span>account<span class="token operator">-</span>name@your<span class="token operator">-</span>project<span class="token operator">-</span><span class="token builtin">id</span><span class="token punctuation">.</span>iam<span class="token punctuation">.</span>gserviceaccount<span class="token punctuation">.</span>com

</code></pre> 
<h1>
<a id="_1593"></a>模型训练实例</h1> 
<p>在本节中，我们将研究如何使用 Google Cloud 平台训练模型以进行预测。 重点是如何使用 Google Cloud 平台训练模型以及其中涉及的步骤。 整个训练代码均来自 Google Cloud 示例示例。 <a href="https://github.com/GoogleCloudPlatform/cloudml-samples/archive/master.zip">请参阅以下链接</a>以获取训练代码。 您还可以从 Google Cloud 公共存储（<code>gs://cloud-samples-data/ai-platform/census/data/*</code>）下载数据：</p> 
<ol><li>您可以创建数据目录，然后使用<code>gsutil</code> copy 命令将数据从 Google Cloud 存储桶复制到本地目录。 这是必需的，因为您必须首先在本地训练和测试模型。 以下代码将执行相同的操作：</li></ol> 
<pre><code class="prism language-py">mkdir data
gsutil <span class="token operator">-</span>m cp gs<span class="token punctuation">:</span><span class="token operator">//</span>cloud<span class="token operator">-</span>samples<span class="token operator">-</span>data<span class="token operator">/</span>ai<span class="token operator">-</span>platform<span class="token operator">/</span>census<span class="token operator">/</span>data<span class="token operator">/</span><span class="token operator">*</span> data<span class="token operator">/</span>
</code></pre> 
<p><code>data</code>文件夹具有以下屏幕截图所示的结构：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rR0CvYZa-1681704646247)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/f0787e0c-e743-467a-aa24-5c275a7686f9.png)]</p> 
<p>图 9.24：测试和训练数据文件</p> 
<p>因此，假设您已经拥有训练代码和训练数据，并且已经设置了 Google Cloud SDK 的所有相关 Python 环境，我们现在可以研究使用 Google Cloud AI 平台训练模型的步骤。 您首先要从本地训练工作开始。</p> 
<ol start="2"><li>以下代码设置了<code>MODEL_DIR</code>环境变量，然后使用 Google Cloud AI Platform 命令在本地训练模型，如下所示：</li></ol> 
<pre><code class="prism language-py">MODEL_DIR<span class="token operator">=</span>output
rm <span class="token operator">-</span>rf $MODEL_DIR<span class="token operator">/</span><span class="token operator">*</span>
gcloud ai<span class="token operator">-</span>platform local train 
    <span class="token operator">-</span><span class="token operator">-</span>module<span class="token operator">-</span>name trainer<span class="token punctuation">.</span>task 
    <span class="token operator">-</span><span class="token operator">-</span>package<span class="token operator">-</span>path trainer<span class="token operator">/</span> 
    <span class="token operator">-</span><span class="token operator">-</span>job<span class="token operator">-</span><span class="token builtin">dir</span> $MODEL_DIR 
    <span class="token operator">-</span><span class="token operator">-</span> 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>files $TRAIN_DATA 
    <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">eval</span><span class="token operator">-</span>files $EVAL_DATA 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>steps <span class="token number">1000</span> 
    <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">eval</span><span class="token operator">-</span>steps <span class="token number">100</span>
</code></pre> 
<p>前面代码的输出看起来像下面的屏幕快照所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Vv9MMf2A-1681704646247)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/6bf40cdd-626f-4a60-9739-333a25c18787.png)]</p> 
<p>图 9.25：模型训练输出</p> 
<p>输出目录将包含以下内容：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Sw7JRzlN-1681704646247)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/5ce898a4-b699-4411-901d-f7bbf764de7c.png)]</p> 
<p>图 9.26：输出目录内容</p> 
<p>要显示局部模型训练测试的结果，可以使用 TensorBoard 可视化工具。 使用 TensorBoard，您可以查看 TensorFlow 映射，编辑有关模型运行方式的定量数据以及显示其他数据，例如遍历图表的图片。 作为 TensorFlow 安装的一部分，可以使用 TensorBoard。</p> 
<ol start="3"><li>运行以下命令以启动<code>tensorboard</code>：</li></ol> 
<pre><code class="prism language-py">tensorboard <span class="token operator">-</span><span class="token operator">-</span>logdir<span class="token operator">=</span>$MODEL_DIR <span class="token operator">-</span><span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">8080</span>
</code></pre> 
<p>前面的命令的输出看起来像下面的屏幕快照：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-g5NJ1r3M-1681704646248)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/8c3b6bd5-c2c6-4e44-a652-23b96418b675.png)]</p> 
<p>图 9.27：TensorBoard 命令输出</p> 
<p>以下屏幕快照提供了 TensorBoard 外观的概览：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-80stdZGf-1681704646248)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/18ccaa9b-9506-4a6d-84f4-6c8517c15099.png)]</p> 
<p>图 9.28：TensorBoard 显示模型训练图</p> 
<p>单击屏幕左侧菜单中的“下载 PNG”选项，以获取前面图形的更清晰图像。</p> 
<p>如您在此屏幕截图中所见，模型训练经历了各个阶段，TensorFlow 通过有效的日志记录来创建沿袭。 通过<strong>图形用户界面</strong>（<strong>GUI</strong>）可以轻松跟踪此沿袭。 在训练阶段处理输入值并产生中间结果时，可以跟踪它们。 可以通过将适当的值传递给运行时，基于训练图来调整模型：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZPqLhLs3-1681704646248)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/489d6fe7-05e7-4aef-b336-72cd36e76330.png)]</p> 
<p>图 9.29：TensorBoard 中的模型状态</p> 
<ol start="4"><li>现在，在进行本地测试之后，您需要在分布式本地模式下测试模型训练，以确保可以在分布式模式下训练模型，如果使用 Google Cloud AI Platform 训练模型，情况就是如此。 以下代码可用于相同的代码：</li></ol> 
<pre><code class="prism language-py">MODEL_DIR<span class="token operator">=</span>output<span class="token operator">-</span>dist
rm <span class="token operator">-</span>rf $MODEL_DIR<span class="token operator">/</span><span class="token operator">*</span>
gcloud ai<span class="token operator">-</span>platform local train 
    <span class="token operator">-</span><span class="token operator">-</span>module<span class="token operator">-</span>name trainer<span class="token punctuation">.</span>task 
    <span class="token operator">-</span><span class="token operator">-</span>package<span class="token operator">-</span>path trainer<span class="token operator">/</span> 
    <span class="token operator">-</span><span class="token operator">-</span>job<span class="token operator">-</span><span class="token builtin">dir</span> $MODEL_DIR 
    <span class="token operator">-</span><span class="token operator">-</span>distributed 
    <span class="token operator">-</span><span class="token operator">-</span> 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>files $TRAIN_DATA 
    <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">eval</span><span class="token operator">-</span>files $EVAL_DATA 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>steps <span class="token number">1000</span> 
    <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">eval</span><span class="token operator">-</span>steps <span class="token number">100</span>
</code></pre> 
<p>输出如下图所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qKdEDgrW-1681704646248)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/4d221b1d-bd41-48ad-81eb-b1b0a6f1e747.png)]</p> 
<p>图 9.30：本地训练模型输出</p> 
<p>输出模型目录具有以下内容。 检查点和日志文件夹启用 TensorBoard 上的图形视图，如以下屏幕快照所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-N55XtzUW-1681704646249)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/a9319876-c9ab-4c86-b37f-ad7416ed54f3.png)]</p> 
<p>图 9.31：模型训练输出目录</p> 
<ol start="5"><li>前面的步骤是关于运行模型训练作业以进行本地测试的。 此后，对于实际的生产级部署，您需要在云上运行模型训练。 为此，您必须先创建存储桶（或者也可以使用现有的存储桶）。 以下代码将为您创建存储桶：</li></ol> 
<pre><code class="prism language-py">BUCKET_NAME_PREFIX<span class="token operator">=</span><span class="token string">"ai_ml_book"</span>
PROJECT_ID<span class="token operator">=</span>$<span class="token punctuation">(</span>gcloud config <span class="token builtin">list</span> project <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">format</span> <span class="token string">"value(core.project)"</span><span class="token punctuation">)</span>
BUCKET_NAME<span class="token operator">=</span>$<span class="token punctuation">{<!-- --></span>PROJECT_ID<span class="token punctuation">}</span><span class="token operator">-</span>$<span class="token punctuation">{<!-- --></span>BUCKET_NAME_PREFIX<span class="token punctuation">}</span>
echo $BUCKET_NAME
REGION<span class="token operator">=</span>us<span class="token operator">-</span>central1
gsutil mb <span class="token operator">-</span>l $REGION gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME
</code></pre> 
<p>前面的代码的输出如下所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DEbivZhl-1681704646249)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/0146cc5b-86dc-4af7-8b22-6fd1686138a3.png)]</p> 
<p>图 9.32：桶创建输出</p> 
<ol start="6"><li>创建存储桶后，您可以使用以下代码将工件上传到存储桶。 此代码还设置了一些变量以更正值，以便可以运行下一组命令：</li></ol> 
<pre><code class="prism language-py">gsutil cp <span class="token operator">-</span>r data gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME<span class="token operator">/</span>data
TRAIN_DATA<span class="token operator">=</span>gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME<span class="token operator">/</span>data<span class="token operator">/</span>adult<span class="token punctuation">.</span>data<span class="token punctuation">.</span>csv
EVAL_DATA<span class="token operator">=</span>gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME<span class="token operator">/</span>data<span class="token operator">/</span>adult<span class="token punctuation">.</span>test<span class="token punctuation">.</span>csv
gsutil cp <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span>json gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME<span class="token operator">/</span>data<span class="token operator">/</span>test<span class="token punctuation">.</span>json
TEST_JSON<span class="token operator">=</span>gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME<span class="token operator">/</span>data<span class="token operator">/</span>test<span class="token punctuation">.</span>json
</code></pre> 
<p>输出如下所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yVDcA8gs-1681704646249)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/a91b6e87-ad21-4f64-b694-5beb043ee645.png)]</p> 
<p>图 9.33：存储桶上传输出</p> 
<ol start="7"><li>现在，您可以通过批准的单人和分布式模式练习，在云中工作。 您将首先申请一份实例的训练工作。 使用默认的 BASIC 规模计算层来执行单个实例的训练工作。 最初的作业请求可能需要几分钟才能开始，但是之后作业将运行得更快。 在改进和验证准备工作时，它可以帮助您轻松进行迭代。 以下是相同的代码：</li></ol> 
<pre><code class="prism language-py">JOB_NAME<span class="token operator">=</span>ai_book_model_single_1
OUTPUT_PATH<span class="token operator">=</span>gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME<span class="token operator">/</span>$JOB_NAME
gcloud ai<span class="token operator">-</span>platform jobs submit training $JOB_NAME 
    <span class="token operator">-</span><span class="token operator">-</span>job<span class="token operator">-</span><span class="token builtin">dir</span> $OUTPUT_PATH 
    <span class="token operator">-</span><span class="token operator">-</span>runtime<span class="token operator">-</span>version <span class="token number">1.14</span> 
    <span class="token operator">-</span><span class="token operator">-</span>module<span class="token operator">-</span>name trainer<span class="token punctuation">.</span>task 
    <span class="token operator">-</span><span class="token operator">-</span>package<span class="token operator">-</span>path trainer<span class="token operator">/</span> 
    <span class="token operator">-</span><span class="token operator">-</span>region $REGION 
    <span class="token operator">-</span><span class="token operator">-</span> 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>files $TRAIN_DATA 
    <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">eval</span><span class="token operator">-</span>files $EVAL_DATA 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>steps <span class="token number">1000</span> 
    <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">eval</span><span class="token operator">-</span>steps <span class="token number">100</span> 
    <span class="token operator">-</span><span class="token operator">-</span>verbosity DEBUG
</code></pre> 
<p>前面命令的输出如下所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Xs1VanSW-1681704646250)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/19c2e6dc-62b8-456c-9ea3-012a64d19d9f.png)]</p> 
<p>图 9.34：模型训练输出</p> 
<ol start="8"><li>运行<code>gcloud ai-platform jobs describe ai_book_model_single_1</code>命令后，将看到以下输出：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XBxt3B58-1681704646250)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/491fb058-0ec2-494c-95eb-2f2689c945fc.png)]</p> 
<p>图 9.35：模型训练输出（2）</p> 
<p>您也可以从 Google Cloud 控制台用户界面查看作业状态和日志。 以下屏幕截图表示相同：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-d7pGTZvj-1681704646250)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/ed1b0e12-4d60-405d-8235-8167e40e4709.png)]</p> 
<p>图 9.36：Google Cloud 控制台上的模型训练状态</p> 
<ol start="9"><li>在进行模型训练时，我们会在模型列表用户界面中看到一个进度栏。 可以实时访问日志，以了解模型训练进度以及了解中间结果。 此级别的日志记录在模型调整中很有用，可以在以下屏幕截图中看到：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SLZlDuNI-1681704646250)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/ab65b3f0-55e3-48df-bfbf-7df5da95b5bc.png)]</p> 
<p>图 9.37：模型训练日志</p> 
<p>存储在 Google Cloud 存储桶中的输出仅看起来像我们本地训练的输出模型，如以下屏幕截图所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ayJ9vYUa-1681704646251)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/be14ca52-1878-4267-bb7d-0392a743f02c.png)]</p> 
<p>图 9.38：Google Cloud 存储桶上的输出</p> 
<ol start="10"><li>通过启动 TensorBoard，可以检查您的训练工作的行为，并指向锻炼期间（锻炼期间和之后）生成的摘要日志。 由于摘要是由训练程序写入云存储位置的，因此 TensorBoard 可以从中读取内容，而无需手动复制事件文件。 以下屏幕快照是相同的：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Pl8hwHmp-1681704646251)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/90c4520c-0a5f-4f77-9af6-5b16446605fe.png)]</p> 
<p>图 9.39：TensorBoard 上的模型训练图</p> 
<p>单击屏幕左侧菜单中的“下载 PNG”选项，以获取前面图形的更清晰图像。</p> 
<ol start="11"><li>您应该以分布式模式配置训练工作，以便在执行训练工作时利用 Google 的灵活平台。 要将模型作为分布式流程在 AI 平台上运行，则无需更改代码。 将<code>--scale-tier</code>设置为高于基本级别的任何层以执行分布式作业。 以下是相同的示例代码：</li></ol> 
<pre><code class="prism language-py">JOB_NAME<span class="token operator">=</span>census_dist_1
OUTPUT_PATH<span class="token operator">=</span>gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME<span class="token operator">/</span>$JOB_NAME
gcloud ai<span class="token operator">-</span>platform jobs submit training $JOB_NAME 
    <span class="token operator">-</span><span class="token operator">-</span>job<span class="token operator">-</span><span class="token builtin">dir</span> $OUTPUT_PATH 
    <span class="token operator">-</span><span class="token operator">-</span>runtime<span class="token operator">-</span>version <span class="token number">1.14</span> 
    <span class="token operator">-</span><span class="token operator">-</span>module<span class="token operator">-</span>name trainer<span class="token punctuation">.</span>task 
    <span class="token operator">-</span><span class="token operator">-</span>package<span class="token operator">-</span>path trainer<span class="token operator">/</span> 
    <span class="token operator">-</span><span class="token operator">-</span>region $REGION 
    <span class="token operator">-</span><span class="token operator">-</span>scale<span class="token operator">-</span>tier STANDARD_1 
    <span class="token operator">-</span><span class="token operator">-</span> 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>files $TRAIN_DATA 
    <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">eval</span><span class="token operator">-</span>files $EVAL_DATA 
    <span class="token operator">-</span><span class="token operator">-</span>train<span class="token operator">-</span>steps <span class="token number">1000</span> 
    <span class="token operator">-</span><span class="token operator">-</span>verbosity DEBUG
</code></pre> 
<p>以下屏幕快照显示了上述代码的输出：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2FQSLaPX-1681704646251)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/991fc173-f47e-4fd3-bb33-4d39a6da3fc1.png)]</p> 
<p>图 9.40：带有刻度的训练作业输出</p> 
<ol start="12"><li>您可以使用<code>gcloud ai-platform jobs stream-logs $JOB_NAME</code>命令流式传输日志。 以下屏幕快照表示流日志的输出：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YeFst0gE-1681704646251)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/4cb994a2-3394-4509-b8f9-3124446d6283.png)]</p> 
<p>图 9.41：流作业</p> 
<ol start="13"><li>模型训练的最后一步是部署模型。 以下代码将使用一个版本来部署模型：</li></ol> 
<pre><code class="prism language-py">MODEL_NAME<span class="token operator">=</span>census
    gcloud ai<span class="token operator">-</span>platform models create $MODEL_NAME <span class="token operator">-</span><span class="token operator">-</span>regions<span class="token operator">=</span>$REGION
    OUTPUT_PATH<span class="token operator">=</span>gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME<span class="token operator">/</span>census_dist_1
    gsutil ls <span class="token operator">-</span>r $OUTPUT_PATH<span class="token operator">/</span>export
    MODEL_BINARIES<span class="token operator">=</span>gs<span class="token punctuation">:</span><span class="token operator">//</span>$BUCKET_NAME<span class="token operator">/</span>census_dist_1<span class="token operator">/</span>export<span class="token operator">/</span>census<span class="token operator">/</span><span class="token number">1578466652</span>
    gcloud ai<span class="token operator">-</span>platform versions create v1 
    <span class="token operator">-</span><span class="token operator">-</span>model $MODEL_NAME 
    <span class="token operator">-</span><span class="token operator">-</span>origin $MODEL_BINARIES 
    <span class="token operator">-</span><span class="token operator">-</span>runtime<span class="token operator">-</span>version <span class="token number">1.14</span>
</code></pre> 
<p>以下是上述命令的输出：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lhpRDNMY-1681704646252)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/9d58cf79-f0fd-4862-ab6b-3460eaeda14f.png)]</p> 
<p>图 9.42：模型部署输出</p> 
<p>您还可以在 Google Cloud 控制台用户界面上查看已部署的模型版本，如以下屏幕截图所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nypqul2Q-1681704646252)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/0d6106bc-e068-4a0b-a0b4-5b12c3e52557.png)]</p> 
<p>图 9.43：从 Google Cloud 控制台部署的模型视图</p> 
<p>在下一部分中，我们将研究如何使用已部署的人口普查模型进行在线和批量预测。</p> 
<h1>
<a id="_1846"></a>使用服务端点执行预测</h1> 
<p>通常，您已经在机器学习模型及其版本上训练并部署了 Google Cloud API 平台之后，才执行此步骤。 下图显示了在线预测如何在 Google Cloud AI 平台中工作：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kx2UTgme-1681704646252)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/6d0a8fd8-c053-41b3-9bef-830198dd16df.png)]</p> 
<p>图 9.44：在线预测工作流程</p> 
<p>您可以使用部署在 Google Cloud Storage 存储桶上的模型作为服务端点公开，并且这些服务端点可以由使用 REST API 或<code>gcloud</code>工具本身的某些应用使用。 <code>gcloud</code>工具用于快速测试在线预测。 在实际的生产案例中，您可以使用用 Python 编写的脚本或 cURL 工具来使用 Rest API，从而在已部署的模型版本上公开预测功能。</p> 
<p>以下代码显示了如何使用<code>gcloud</code>工具进行在线预测。 JSON 代码示例如下所示：</p> 
<pre><code class="prism language-py"><span class="token punctuation">{<!-- --></span><span class="token string">"values"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span>
<span class="token punctuation">{<!-- --></span><span class="token string">"values"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span>
</code></pre> 
<p>代码如下所示：</p> 
<pre><code class="prism language-py">MODEL_NAME<span class="token operator">=</span><span class="token string">"census"</span>
INPUT_DATA_FILE<span class="token operator">=</span><span class="token string">"instances.json"</span>
VERSION_NAME<span class="token operator">=</span><span class="token string">"v1"</span>
gcloud ai<span class="token operator">-</span>platform predict <span class="token operator">-</span><span class="token operator">-</span>model $MODEL_NAME 
                   <span class="token operator">-</span><span class="token operator">-</span>version $VERSION_NAME 
                   <span class="token operator">-</span><span class="token operator">-</span>json<span class="token operator">-</span>instances $INPUT_DATA_FILE
</code></pre> 
<p>使用此代码，我们能够使用已部署的模型并根据训练数据预测结果。</p> 
<h1>
<a id="_1876"></a>总结</h1> 
<p>在本章中，我们介绍了 AI 的基本方面，使我们能够根据历史数据预测结果。 我们了解了预测分析的一般流程，并以 GCP 为例对流程进行了深入研究。 借助命令行和 Google Cloud 控制台上的用户界面工具，可以简化 GCP 上的模型构建（训练，评估）和部署过程。 我们还研究了如何对模型进行版本控制以及如何使用适当的模型进行预测。 预测服务也以 API 调用的形式公开，可以以与语言无关的方式进行调用。</p> 
<p>在本书的最后一章中，我们将利用到目前为止研究的所有组件来构建 AI 应用。</p> 
<h1>
<a id="_4__1882"></a>第 4 节：构建应用和即将发布的功能</h1> 
<p>本节总结了从前几章获得的所有知识。 它由一章组成。 我们将使用 <strong>Google Cloud Platform</strong>（<strong>GCP</strong>）上的各种组件来构建端到端的 AI 应用。 本章提供了使用 GCP 快速构建生产就绪应用的一般过程。</p> 
<p>本节包括以下章节：</p> 
<ul><li>“第 10 章”，“构建 AI 应用”</li></ul> 
<h1>
<a id="_AI__1890"></a>十、构建一个 AI 应用</h1> 
<p>在本书的最后九章中，我们在 <strong>Google Cloud Platform</strong>（<strong>GCP</strong>）的背景下研究了人工智能的基本构成元素。</p> 
<p>在本章中，我们将概述在本书中学习的各种工具和技术，并将其应用于构建示例 AI 应用。 我们还将介绍 GCP 即将推出的功能，这些功能将通过使 AI 和 ML 普及来进一步增强其构建智能应用的能力。</p> 
<p>本章将涵盖以下主题：</p> 
<ul>
<li>开发 AI 应用的分步方法</li>
<li>用例概述– <strong>自动发票处理</strong>（<strong>AIP</strong>）</li>
<li>即将推出的功能</li>
</ul> 
<h1>
<a id="_AI__1902"></a>开发 AI 应用的分步方法</h1> 
<p>平台可通过补充人类智能来促进解决问题的现实应用和用例。 随着人工智能成为主流并被日常应用和软件平台所采用，开发人员社区以及大型组织必须利用 GCP 等平台以最少的时间和人力资源投资来构建功能强大的应用。 GCP 的 AI 还使我们在创建生产应用之前可以轻松进行各种实验和检验假设。 数据管理和 ML 作为 GCP 上的服务提供。 这样就无需管理基础架构和软件。 开发团队可以专注于解决实际问题，而无需担心平台和基础架构管理。 为此，开发人员社区可以使用 GCP 提供的复杂工具包，而无需前期投资。 我们将看到应用周转时间和易于开发方面的重大变化。</p> 
<p>这促进了尖端的创新，并解决了一些现实世界中无法解决的问题。</p> 
<p>通常，AI 应用的开发遵循循序渐进的方法。 总体上讲，AI 应用的开发和操作分为六个阶段，如下图所示。 在本节中，我们将研究这些通用阶段并学习基本的机器学习理论，在随后的部分中，我们将通过示例进行学习：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4y901dVX-1681704646252)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/b2761644-5f54-4f73-9122-0f8ae6fbb578.png)]</p> 
<p>图 10.1：AI 应用开发阶段</p> 
<h1>
<a id="_1914"></a>问题分类</h1> 
<p>根据投入的特征和预期成果，人工​​智能可以解决的问题可以大致分为以下几类。</p> 
<h1>
<a id="_1918"></a>分类</h1> 
<p>分类问题通常涉及将结果分类为预定义的类别。 结果称为因变量。 结果取决于一组输入变量或特征。 输入变量或特征称为自变量。 分类问题训练模型以数学方式将自变量的组合映射到因变量。 输出是集合中的值之一。 例如，当通过分类算法时，水果图像被分类为苹果或橙子。 通常，算法规定图像属于特定类别的概率。 概率最大的类别是基于训练数据的分类。</p> 
<h1>
<a id="_1922"></a>回归</h1> 
<p>与分类问题不同，回归问题期望连续的结果而不是离散的类。 例如，预测特定人口区域的降雨的模型可以基于各种输入参数来预测以毫米为单位的降雨。</p> 
<h1>
<a id="_1926"></a>聚类</h1> 
<p>聚类问题通常通过无监督的学习方法来解决。 根据相似度指标，将可变空间分为多个聚类。 这是根据数据点与组输入质心的距离进行数学建模的。 例如，可以通过聚类算法将生物细胞聚类为感染或正常类别。</p> 
<h1>
<a id="_1930"></a>优化</h1> 
<p>优化问题用于提高特定计算活动的表现。 例如，如果我们需要压缩文件，则可以尝试各种算法，然后根据数据类型选择最佳算法。 优化问题的另一个示例是根据实时交通和其他路况为车辆找到最佳路线。 该算法可帮助优化路线，以实现从 A 点到 B 点的最短行驶时间。</p> 
<h1>
<a id="_1934"></a>异常检测</h1> 
<p>异常检测是一种类型的问题，其中需要检测数据中的极端条件。 网络安全是异常检测的一个非常突出的用例。 生成了大量的网络日志，如果没有智能采样和智能算法，就不可能检测到异常值。</p> 
<h1>
<a id="_1938"></a>排名</h1> 
<p>排名问题涉及我们需要根据特定用例按堆叠排名对结果空间进行排序。 控制排名的规则充当输入变量，而顺序排名则作为输出。 这些问题可以通过有监督的学习方法和无监督的学习方法来解决。 这些排名算法的典型用法是通过推荐系统。 在零售的情况下，产品会根据各种用户偏好按相关性进行排名，并呈现给用户。</p> 
<h1>
<a id="_1942"></a>数据准备</h1> 
<p>数据准备问题是期望算法从历史模式生成数据的地方。 一个示例用例是基于神经网络和大量面部图像创建人脸，这些面部图像被馈送到算法中（使用生成对抗网络）以生成新图像。 该算法可以创建用于测试和实验目的的真实数据。</p> 
<h1>
<a id="_1946"></a>数据采集</h1> 
<p>AI 应用获得的用于训练基础模型的数据越多，表现就会越好。 数据的质量和数量对于 AI 应用真正补充人类智能至关重要。 这意味着从各种来源获取数据是该过程中的重要一步。 通常以批量或接近实时的方式获取数据。</p> 
<p>通常，历史数据在批量模式下用于训练和调整模型，而实时数据在流模式下用于进一步处理。 在某些用例中，期望 AI 应用的事件时间与操作时间之间的时间间隔最小。 在这种情况下，我们需要考虑使用高端计算基础架构，以确保数据采集和处理中的亚毫秒级延迟。</p> 
<h1>
<a id="_1952"></a>数据处理</h1> 
<p>随着更多设备连接到互联网，我们正在生成更多数据。 这称为大数据，并导致数据量增长。 必须使用尽可能多的数据来构建 AI 应用，因为各种形式的数据都包含可以用来构建智能应用的智能。 通过处理非结构化数据的功能，大数据现在包括例如图像，视频，音频文件，文本和无线数据。 大数据处理还涉及计算机视觉，<strong>自然语言处理</strong>（<strong>NLP</strong>），社交网络，语音识别，<strong>车联网</strong>（<strong>IoV</strong>）数据分析，实时<strong>物联网</strong>（<strong>IoT</strong>）数据分析以及无线大数据处理。</p> 
<p>近来，已集中实现了以<strong>人工智能</strong>（<strong>AI</strong>）为动力的大规模异构数据处理技术，这些技术专注于模式识别，机器学习和深度学习。 然而，人工智能驱动的大数据处理的发展仍然充满挑战。 在计算机视觉和图像处理中，越来越多的数据库和数据流已经被分发和处理。 大规模分析图像/视频数据的最大挑战之一是建立节能高效的实时方法，以从每秒产生的大量数据中提取有用的信息。 得益于大数据和新的 AI 技术的帮助，语音处理也取得了很多进展。</p> 
<h1>
<a id="_1958"></a>问题建模</h1> 
<p>我们需要了解特定的问题，并使用适当的模型来解决该特定的问题。 根据问题的具体类别，在决定在生产中使用特定模型之前，我们需要尝试各种算法。 在特定类别的算法中，可能会部署不正确的模型，而该模型不会在新数据集上产生准确的结果。</p> 
<p>在最终选择所部署的模型之前，我们需要了解一段时间内的数据模式。 对于增强人员功能的关键任务 AI 应用而言，这尤其重要。</p> 
<h1>
<a id="_1964"></a>验证与执行</h1> 
<p>在将训练后的模型用于 AI 应用之前，需要对其进行彻底的验证。 在 AI 应用中，该想法是对人类情报的补充，因此，在部署模型之前，确保已对异构数据样本（评估数据集）进行了验证，这一点变得尤为重要。 该模型不仅需要在预定义的评估样本上而且还需要在模型从未看到的新数据集上通过较高的阈值。 我们可以使用两种主要的验证类别来评估模型：保持和交叉验证。</p> 
<p>两种方法都使用测试集来评估模型输出（即算法看不到的数据）。 不建议使用我们用来开发模型的数据进行测试。 这是因为我们的模型会记住整个训练集，因此会在训练集中的任何点预测正确的标签。 这称为过拟合。 由于其速度，简单性和多函数式，所以保留方法很有用。 尽管如此，由于训练和测试数据集的变化会导致准确率估计值的显着差异，因此该方法通常具有很高的不确定性。</p> 
<h1>
<a id="_1970"></a>留存</h1> 
<p>留存方法的基本思想是通过将模型暴露于新数据集（与用于训练的数据集相比）来避免过拟合。 最初，它导致模型精度低于最小阈值； 然而，该方法提供了无偏的学习表现和准确的估计。 该方法将数据集随机分为三个子集：</p> 
<ul>
<li>
<strong>训练集</strong>：这是用于预测模型构建的数据集子集。</li>
<li>
<strong>验证集</strong>：这是一个数据集子集，用于评估在训练阶段构建的模型的表现。 它提供了一个测试平台，可以微调模型的参数并选择表现最佳的模型。 并非每种建模算法都需要一组验证。</li>
<li>
<strong>测试集</strong>：这是数据集的子集，用于预测产品的潜在未来输出。</li>
</ul> 
<h1>
<a id="_1978"></a>交叉验证</h1> 
<p>这是一种我们可以访问有限的数据集进行训练和评估的技术。 通过这种技术，我们将数据分解为不同的块。 这些独立的块以随机顺序用于评估过程中的多次迭代训练和评估。 这样可以确保在各种样本上训练模型，并且还可以通过训练数据的不同子集执行等效评估。</p> 
<p>这样可以确保模型结构有足够的变化，以避免过拟合和过拟合。 但是，即使使用交叉验证方法，也建议您拥有尽可能多的数据用于训练和评估。 这些方法的准确率计算是通过训练和评估使用的各种迭代的平均值。</p> 
<h1>
<a id="_1984"></a>模型评估参数（指标）</h1> 
<p>需要模型评估指标来度量模型效率。 选择评估指标取决于 ML 的特定任务（例如分类，回归，排名，聚类或主题建模等）。 某些指标（例如精确召回）对于多个任务很有用。 基于监督和经验（历史数据）的机器学习模型（例如分类和回归）构成了机器学习的大部分应用。</p> 
<h1>
<a id="_1988"></a>分类指标</h1> 
<p>让我们看一些常用的分类指标：</p> 
<ul>
<li> <p><strong>分类准确率</strong>：对于分类问题，准确率是标准的度量标准。 通常将其作为预测总数与正确预测数目之比来衡量。 例如，如果我们有一个基于图像对动物进行分类的用例，则可以通过比较训练和评估时间数据并与分类尝试的总数之比来衡量正确分类的数量。 我们需要通过将样本数据划分为各种评估测试来运行多个测试，以避免数据过大和不足。 我们还可以通过比较各种模型来部署交叉验证，以优化表现，而不是对同一模型使用不同的随机样本运行多个测试。 使用这些方法，我们可以迭代的方式提高分类的准确率。</p> </li>
<li> <p><strong>混淆矩阵</strong>：有关错误分类的信息对于提高模型的整体可靠性也很重要。 混淆矩阵是了解整体模型效率的有用技术。</p> </li>
<li> <p><strong>对数损失</strong>：当输入是介于 0 和 1 之间的概率值时，这是理解模型表现的重要指标。对于 ML 模型，最好具有最小的对数损失。 通常为此指标设置的阈值小于 0.1。</p> </li>
<li> <p><strong>曲线下面积（AUC）</strong>：AUC 提供了所有可能的额定水平的综合表现指标。</p> </li>
</ul> 
<h1>
<a id="_1998"></a>模型部署</h1> 
<p>AI 和 ML 模型的部署是全面运行模型的重要步骤。 GCP 使部署模型的多个版本变得容易且无缝。 以下是在生产中部署模型所需遵循的一般步骤：</p> 
<ol>
<li> <p>使模型文件在 Cloud Storage 存储桶中可用。</p> </li>
<li> <p>建议您在使用的同一 AI 系统项目中使用专用的 Cloud Storage 池。 如果您需要在其他项目中使用存储桶，则必须确保您的 AI 平台帐户能够访问您的 Cloud Storage 模型。 没有所需的权限，您尝试构建模型的 AI 平台版本将失败。 以下是设置 Google Cloud 存储桶所涉及的步骤：</p> </li>
<li> <p>为存储桶设置唯一的名称。 确保它具有唯一的名称，以使其与项目的云存储中的所有其他存储桶区分开。 通常，您可以通过在项目 ID 的末尾附加<code>-mlengine</code>来生成存储区名称。 为确保在整个项目中进行一致的部署，建议使用最佳实践。 例如，如果项目名称为 AIGCP，则用于存储模型文件的存储桶名称将为<code>AIGCP-mlengine</code>。</p> </li>
<li> <p>设置存储桶的区域并设置环境变量值。 建议您使用打算在其上运行 AI 平台作业的区域。</p> </li>
<li> <p>使用以下针对 TensorFlow SavedModel 的命令将模型上传到新创建的存储桶：</p> </li>
</ol> 
<pre><code class="prism language-py">SAVED_MODEL_DIR<span class="token operator">=</span>$<span class="token punctuation">(</span>ls <span class="token punctuation">.</span><span class="token operator">/</span>your<span class="token operator">-</span>export<span class="token operator">-</span><span class="token builtin">dir</span><span class="token operator">-</span>base <span class="token operator">|</span> tail <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
gsutil cp <span class="token operator">-</span>r $SAVED_MODEL_DIR gs<span class="token punctuation">:</span><span class="token operator">//</span>your<span class="token operator">-</span>bucket
</code></pre> 
<ol start="4"><li>在将模型用于 AI 平台预测之前，请测试<code>model—Gcloud ai-platform local predict</code>命令以检查模型如何处理预测。 该命令使用本地环境中的依赖项进行预测并在联机进行预测时以与<code>gcloud ai-platform predict</code>相同的方式产生输出。 为了节省成本，建议您在发送联机预测请求之前在本地检查预测以发现错误。 这是测试模型的示例命令：</li></ol> 
<pre><code class="prism language-py">gcloud ai<span class="token operator">-</span>platform local predict <span class="token operator">-</span><span class="token operator">-</span>model<span class="token operator">-</span><span class="token builtin">dir</span> model_storage_path<span class="token operator">/</span> 
 <span class="token operator">-</span><span class="token operator">-</span>JSON<span class="token operator">-</span>instances path<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">-</span>prediction<span class="token operator">-</span><span class="token builtin">input</span><span class="token punctuation">.</span>JSON 
 <span class="token operator">-</span><span class="token operator">-</span>framework tensorflow
</code></pre> 
<p>在本节中，我们已经看到了构建 AI 应用的各个阶段。 这是用于开发 AI 应用的高级构建块的简化视图：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2N95mIpo-1681704646253)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/c5a2dab7-0f88-43a6-8d39-4fc403d0476a.png)]</p> 
<p>图 10.1：AI 应用的高级构建块</p> 
<p>正如我们在图中所看到的，AI 应用管道中主要包含三个区域：数据获取，数据处理（特征工程），然后是模型执行和调整。 在本章的后续部分中，我们将考虑一个用例，并了解在 GCP 上使用 AI 工具包构建可运行的应用有多么容易。</p> 
<h1>
<a id="__AIP_2032"></a>用例概述 – 自动发票处理（AIP）</h1> 
<p>发票处理是遵循典型工作流程的重复性通用过程。 目前，大多数组织都需要大量的人工干预来管理发票处理的各个方面。 我们在本书中看到的各种 GCP 工具可以使组织的整个发票处理系统自动化。 在本节中，我们将通过逐步进行自动开票的过程来探索用例。</p> 
<p>例如，让我们考虑一家为客户提供 IT 咨询服务的软件开发公司。 通常，对于项目的时间和材料成本，在月底（或预定义的发票期）将发票发送给客户。 发票包含有关卖方提供给客户的服务的所有详细信息，以及各个服务的详细信息以及付款处理所需的详细信息（例如，银行帐户详细信息）。 在我们的示例中，让我们考虑发票文件为 PDF 格式，并通过电子邮件接收。 这是我们示例的发票示例：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ep7mNGtY-1681704646253)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/a042c018-fbc4-42d5-ba1e-302e9adbf12a.png)]</p> 
<p>图 10.2：示例用例的发票示例</p> 
<p>通常，发票包含以下部分：</p> 
<ol>
<li>客户名称，地址和电话号码。</li>
<li>发票抬头信息，例如发票编号，日期，SOW 编号，项目 ID 等。</li>
<li>发票金额明细和总计。</li>
<li>发票金额（以字为单位）。</li>
<li>用于汇款的银行帐户详细信息。</li>
</ol> 
<p>应付帐款团队收到发票后，他们将根据时间表系统验证各个应付款条目，并根据供应商的付款条件安排发票以进行付款。 以下流程图描述了此工作流程：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8D28yp1D-1681704646253)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/50d2ce44-a514-46a0-903b-2a39d485a8e6.png)]</p> 
<p>图 10.3：具有代表性 GCP 组件的发票处理流程</p> 
<p>我们将使用 GCP 组件来自动化此过程。 在下一节中，我们将介绍 GCP 上 AIP 系统的设计。</p> 
<h1>
<a id="_GCP__AI__AIP_2058"></a>在 GCP 上使用 AI 平台工具设计 AIP</h1> 
<p>我们将使用本书前面已经学习过的一些 GCP 组件来设计 AIP 应用。 下图突出显示了四个部分，这些部分分别有助于构建应用。 我们将使用原始发票 PDF 文件作为信息源。</p> 
<p>数据将存储在 Cloud SQL 中，并在 Cloud Functions 的帮助下传递给 AI 工具包以进行进一步处理。 然后，我们将利用 GCP 上的 AI 工具包在应用中构建智能。 首先，我们需要一个 ML，自然语言界面，视觉 API 和语音 API 来启用对话界面。 最后，我们将利用出站服务，特别是 Dialogflow。 这是使用 GCP 组件的 AIP 应用的高层组件交互：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7BVYBHsY-1681704646253)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/99b6ab75-9e79-4290-8aa4-23353eb46dcc.png)]</p> 
<p>图 10.4：AIP 应用的组件设计</p> 
<p>通过集成各种 GCP 组件，我们可以实现功能齐全的 AIP 应用。 以下列表显示了应用中涉及的各种 GCP 组件的功能摘要。</p> 
<p>以下组件可用作 GCP 中的数据存储区； 在我们的应用中，我们将利用 Cloud SQL：</p> 
<ul>
<li>
<strong>Cloud SQL</strong>：这是一个完全托管的数据库，可以充当 GCP 上的关系数据库。 在撰写本文时，Cloud SQL 可以与 MySQL，PostgreSQL 和 SQL Server 一起使用。</li>
<li>
<strong>Cloud Bigtable</strong>：这是 GCP 上的 NoSQL 数据库服务。 Bigtable 为数据集提供了低延迟，可大规模扩展的界面。 该存储是 ML 应用的理想选择，并且易于与各种开源大数据框架集成。</li>
<li>
<strong>Cloud Spanner</strong>：这是一种水平可伸缩的关系数据库服务，在各个实例和节点之间高度一致。 它结合了关系型数据库和非关系型数据库的最佳功能，其完全托管的特性使其成为用最少的时间投资来进行大型数据库部署的有吸引力的选择。</li>
<li>
<strong>Cloud Memorystore</strong>：这是一种完全托管的内存中数据存储服务，可用于构建应用缓存，并为数据访问提供极低的延迟。 该内存存储利用 Redis 协议，从而使它在各个部署之间保持一致。 缓存的移植很容易。</li>
<li>
<strong>Cloud Firestore</strong>：这是一个方便的 NoSQL 数据存储，用于使客户端和服务器端之间的数据保持同步。 它通常用于移动，Web 和服务器开发，并为构建响应式应用和跨设备应用提供支持。</li>
<li>
<strong>Cloud Datastore</strong>：这是另一个完全托管的 NoSQL 数据库，用于处理分片和复制，以确保跨部署区域的高可用性。 它支持 ACID 事务以及类似 SQL 的查询和索引。 数据存储区提供了 REST API，通过允许通过多级安全连接进行数据访问，可以轻松集成外部应用。 可以很容易地更改基础数据结构，并提供一种易于使用的查询语言。</li>
</ul> 
<p>以下组件可用于计算和处理； 在我们的应用中，我们将利用 Cloud Functions：</p> 
<ul>
<li>
<strong>Cloud SDK</strong>：这是用于使用 GCP 开发的一组工具和库。 这是所有 GCP 服务的命令行界面，例如虚拟机编排，计算引擎，网络和磁盘存储。 它通常用于自动执行各种应用管理任务。 对于 AIP 应用，我们可以使用 Cloud SDK 来管理开发，测试和部署管道，并自动管理整个应用。</li>
<li>
<strong>Cloud Functions</strong>：这是一个无服务器，事件驱动的计算平台。 根据工作负载和基于预定义的事件，可以轻松地进行伸缩。 对于 AIP 应用，一旦发票到达源位置，我们就可以使用 Cloud Functions 触发自动过程，以读取发票并进行处理。 它为跨各种语言和应用接口协议的互操作性提供了无缝支持。 它基于最小特权的核心安全原理工作，并根据为用户分配的角色，促进对事件和功能的安全访问。</li>
</ul> 
<p>以下是 AI 工具包中可利用的组件： 在我们的应用中，我们将利用云机器学习，自然语言 API，视觉 API，翻译 API，语音 API 和云视频智能 API：</p> 
<ul>
<li> <p><strong>Cloud ML</strong>：这是一个全面的平台，可利用 Google Cloud 的功能，使训练和部署可用于任何类型和大小的数据的 ML 模型变得容易。 在平台上训练的模型可以立即使用，并且可以通过安全的 API 进行访问，从而可以以最少的资金和时间投入轻松开发应用的快速原型。</p> </li>
<li> <p><strong>自然语言 API</strong>：自然语言 API 可用于执行 Web 规模的文本分析。 该 API 与 AutoML 集成在一起，并允许用户基于非结构化数据来训练，测试和部署其模型。 有预训练的模型，具有各种领域功能的各种应用可以轻松利用这些模型。 该平台使协作和共享不断被平台升级的模型变得容易，从而提供了一种一致且可靠的方式来创建用于处理自然语言形式输入的应用。 这样可以通过语音 API 与人进行数据交互。</p> </li>
<li> <p><strong>视觉 API</strong>：这在基于视觉输入（例如图像）的分析中非常方便。 如果机器具有补充人类视觉的能力（例如从 PDF 或 Word 文档抄录文本），我们可以将大量 API 用于此用例。 这样，可以以有效和具有成本效益的方式对大量文档进行分类。 无需大量设置即可使用该服务，因此，一旦为项目和用户帐户启用了该服务，就可以轻松无缝地开始使用它。 强大的 API 层使您可以轻松以安全的方式与第三方应用集成。</p> </li>
<li> <p><strong>翻译 API</strong>：这是一种便捷的服务，无需设置转换规则即可使用。 该 API 允许根据预先训练并不断发展的模型在各种语言之间进行翻译。 这些功能易于使用，为语言互操作性以及以各种语言构建的各种应用之间的集成打开了可能性。</p> </li>
<li> <p><strong>语音 API</strong>：这是智能机器的重要方面，它使人与应用之间具有类似人的界面。 首先，API 启用了文本到语音到文本的转换。 这些功能可用于创建对话应用。 DialogFlow 在内部利用语音 API 来促进对话。</p> </li>
<li> <p><strong>Cloud Video Intelligence API</strong>：此 API 使我们能够利用视频输入中的信息。 GCP 上有可用的预训练模型，这些模型可用于分类和识别视频帧内的特定对象。 它是自动驾驶汽车的组成部分之一，API 高效且可扩展，足以在关键任务应用中使用。</p> </li>
</ul> 
<p>在下一部分中，概述了 GCP 上可用于构建端到端 AI 应用的各种组件，下面让我们看一下如何在 GCP 上构建自动发票处理应用。</p> 
<h1>
<a id="_Vision_API__2096"></a>使用 Vision API 执行光学字符识别</h1> 
<p>收到 PDF 格式的发票后的第一步是解释其内容。 我们将通过以下步骤使用视觉 API 来执行<strong>光学字符识别</strong>（<strong>OCR</strong>）：</p> 
<ol>
<li>在 GCP 上创建一个新项目。 建议您使用一个新项目来尝试 OCR。 转录文档后，可以根据需要删除该项目，而不会影响任何其他应用。</li>
<li>从 GCP 控制台启用 Cloud Vision API，Cloud Pub/Sub，Cloud Functions 和 Cloud Storage。</li>
<li>从 Cloud Shell（从 GCP 控制台），确保使用以下命令更新所有组件：</li>
</ol> 
<pre><code class="prism language-py">gcloud components update
</code></pre> 
<ol start="4"><li>如下在 Cloud Storage 上创建两个存储桶：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EwEu4Zs7-1681704646254)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/952ec8cc-8d84-4c7d-a0f5-f59430ae43fc.png)]</p> 
<p>图 10.5：用于创建存储桶的<code>gsutil</code>命令</p> 
<ol start="5">
<li>创建<code>aigcp</code>存储桶以存储发票 PDF 文件，并使用<code>aigcp-text</code>存储桶存储转录的文本文件（JSON 格式）。</li>
<li>将发票 PDF 文件复制到<code>aigcp</code>存储桶（从 Cloud Shell 或从 GCP 控制台复制）。 这是 GCP 控制台中存储区内容的快速快照：</li>
</ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-57HmzNV6-1681704646254)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/ff1efc53-158f-42a9-b8f0-4471150d8ebf.png)]</p> 
<p>图 10.6：Google Cloud Storage 存储桶中的发票文件</p> 
<ol start="7"><li>运行以下命令以使用 Vision API 读取发票 PDF 文件并将其转录为文本：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Grm9BWPG-1681704646254)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/ec779176-2ead-4455-8bdb-4574a495cab5.png)]</p> 
<p>图 10.7：使用 Vision API 进行 OCR 和文本检测的命令</p> 
<ol start="8"><li>OCR 也可以通过任何一个编程接口执行。 GCP 提供了用于 C#，Go，Java，Node.js，PHP，Python 和 Ruby 的 API。 让我们看一下 OCR 的 Python 实现的一小段。 <a href="https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Google-Cloud-Platform">完整的实现在 GitHub 上</a>：</li></ol> 
<pre><code class="prism language-py"><span class="token keyword">def</span> <span class="token function">async_detect_document</span><span class="token punctuation">(</span>source_path_gcs<span class="token punctuation">,</span> destination_path_gcs<span class="token punctuation">)</span><span class="token punctuation">:</span>

    client <span class="token operator">=</span> vision<span class="token punctuation">.</span>ImageAnnotatorClient<span class="token punctuation">(</span><span class="token punctuation">)</span>

    feature <span class="token operator">=</span> vision<span class="token punctuation">.</span>types<span class="token punctuation">.</span>Feature<span class="token punctuation">(</span>
        <span class="token builtin">type</span><span class="token operator">=</span>vision<span class="token punctuation">.</span>enums<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>Type<span class="token punctuation">.</span>DOCUMENT_TEXT_DETECTION<span class="token punctuation">)</span>

    gcs_source <span class="token operator">=</span> vision<span class="token punctuation">.</span>types<span class="token punctuation">.</span>GcsSource<span class="token punctuation">(</span>uri<span class="token operator">=</span>source_path_gcs<span class="token punctuation">)</span>
    input_config <span class="token operator">=</span> vision<span class="token punctuation">.</span>types<span class="token punctuation">.</span>InputConfig<span class="token punctuation">(</span>
        gcs_source<span class="token operator">=</span>gcs_source<span class="token punctuation">,</span> mime_type<span class="token operator">=</span>mime_type<span class="token punctuation">)</span>

    async_request <span class="token operator">=</span> vision<span class="token punctuation">.</span>types<span class="token punctuation">.</span>AsyncAnnotateFileRequest<span class="token punctuation">(</span>
        features<span class="token operator">=</span><span class="token punctuation">[</span>feature<span class="token punctuation">]</span><span class="token punctuation">,</span> input_config<span class="token operator">=</span>input_config<span class="token punctuation">,</span>
        output_config<span class="token operator">=</span>output_config<span class="token punctuation">)</span>

    operation <span class="token operator">=</span> client<span class="token punctuation">.</span>async_batch_annotate_files<span class="token punctuation">(</span>
        requests<span class="token operator">=</span><span class="token punctuation">[</span>async_request<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<ol start="9"><li>JSON 格式的转录文本文件现在存储在<code>aigcp-text</code>存储桶中，如以下屏幕截图所示：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Y3ogxXWo-1681704646254)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/9952fc21-9b4c-4608-a539-d47ac7b1b2ee.png)]</p> 
<p>图 10.8：在 Google Cloud Storage 中输出 JSON 文件</p> 
<ol start="10"><li>为了从输出 JSON 文件中提取有意义的信息，我们需要了解输出 JSON 文件（<code>output-1-to-1.JSON</code>）的格式：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2vPy4A83-1681704646255)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/b29d176c-a200-46c6-814f-9c2110163980.png)]</p> 
<p>图 10.9：输出文件中的 JSON 标头</p> 
<p>这是输出文件中的头信息。 Vision API 自动检测 PDF 文档中使用的语言。 实际字符数据封装在[H​​TG0] &gt; <code>paragraphs</code> &gt; <code>words</code> &gt; <code>symbols</code>的层次结构中，如下图所示：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PzS3zEvg-1681704646255)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/9dbd5b37-d5ce-4eab-97e8-f0599b3f446b.png)]</p> 
<p>图 10.10：输出 JSON 结构</p> 
<p>Vision API 还将 PDF 文件中找到的所有符号收集到一个文本字段中。 这有助于我们快速从发票中收集有意义的内容。 以下是包含文本字段的输出 JSON 的代码段：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dlsJb9Qp-1681704646255)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/6bd6406d-6bd3-42e7-8196-cf4d48f2d0c2.png)]</p> 
<p>图 10.11：发票文件中的文字</p> 
<p>有关发票中的原始内容和 Vision API 提取的文本，请参见图 10.2。 发票内的所有字段在文本字段内的输出 JSON 文件中可用。</p> 
<p>至此，我们已经利用 Vision API 从发票中提取了有意义的信息，以便对其进行自动处理。 在接下来的部分中，我们将使用各种 GCP 工具存储相关数据，进行验证并安排发票付款。</p> 
<h1>
<a id="_Cloud_SQL__2177"></a>使用 Cloud SQL 存储发票</h1> 
<p>在本节中，我们将介绍一个完整的过程，该过程是从 OCR 输出生成的 JSON 文件中选取文本并将其通过 Cloud Functions 推送到 Cloud SQL 中的。 首先，我们将介绍在 GCP 上准备好 Cloud SQL 和 Cloud Functions 的步骤，然后我们将解释用于选择文本并将其转换为所需的结构化格式以将其插入表中的代码。</p> 
<h1>
<a id="_Cloud_SQL__2181"></a>创建一个 Cloud SQL 实例</h1> 
<p>首先，让我们通过执行以下步骤来创建 Cloud SQL 实例：</p> 
<ol><li>从左侧面板中，从“存储”部分中选择<code>SQL</code>：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UYiyDnBy-1681704646255)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/afb811fe-5538-49b6-b1ad-edd9b3e32501.png)]</p> 
<ol start="2"><li>单击“创建实例”：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oLrEIAok-1681704646256)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/8e244242-82f7-4d8c-8bc7-91485e5340e7.png)]</p> 
<ol start="3"><li>点击“选择 MySQL”：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q3uysCdX-1681704646256)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/5d452eb7-04ed-48e2-9453-3a017ac896d4.png)]</p> 
<ol start="4"><li>为实例命名，设置适当的密码，选择您的区域，保留默认数据库版本，然后单击“创建”。 记住您为 root 用户设置的密码，因为稍后将有用：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tVprQUq5-1681704646256)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/2108aa82-1ee0-4ce6-b304-f4cebb803d9c.png)]</p> 
<h1>
<a id="_2201"></a>设置数据库和表</h1> 
<p>现在，借助以下步骤来设置数据库和表：</p> 
<ol><li>单击创建的实例：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NZBRXKiG-1681704646257)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/7358ddf8-beac-4954-9a98-88c07ca01616.png)]</p> 
<ol start="2"><li>单击“使用 Cloud Shell 进行连接”，然后通过输入创建实例时设置的 root 用户的密码来连接到 MySQL：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7bj93ImA-1681704646257)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/104afa4d-0fc3-4cda-a650-396d7a8e8340.png)]</p> 
<ol start="3"><li>运行以下命令来创建数据库：</li></ol> 
<pre><code class="prism language-py">create database aip_db<span class="token punctuation">;</span>
</code></pre> 
<ol start="4"><li>运行以下命令以创建发票表。 SQL 文件<code>aip.sql</code>也可从<a href="https://github.com/vss-vikram/Hands-On-Artificial-Intelligence-on-Google-Cloud-Platform">这里</a>获得，以创建与数据库相关的工件：</li></ol> 
<pre><code class="prism language-py">create table invoice 
<span class="token punctuation">(</span>Company_Name VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Client_Name VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Client_Address VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
SOW_Number VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Project_ID VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Invoice_Number VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Invoice_Date DATE<span class="token punctuation">,</span>
Billing_Period DATE<span class="token punctuation">,</span>
Developer VARCHAR<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Rate VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Hours INT<span class="token punctuation">,</span>
Subtotal VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Balance_Due VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Bank_Account_Number INT<span class="token punctuation">,</span>
Bank_Name VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h1>
<a id="_Cloud_SQL_API_2240"></a>启用 Cloud SQL API</h1> 
<p>现在让我们启用 Cloud SQL API：</p> 
<ol><li>从控制台搜索 Cloud SQL Admin API：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xAxAhqbP-1681704646257)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/92dd76f0-35b1-4b1e-8efc-aacfe5b0b188.jpg)]</p> 
<ol start="2"><li>单击“启用”：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WTiSNZ9U-1681704646258)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/28271d91-b2f0-4ecd-b03b-a2d8706d133d.png)]</p> 
<h1>
<a id="_Cloud_Functions_API_2252"></a>启用 Cloud Functions API</h1> 
<p>现在启用 Cloud Functions API：</p> 
<ol><li>从控制台搜索 Cloud Functions API：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WDKfUF93-1681704646258)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/8251257b-38dd-4b06-ad85-57cf09eec21b.png)]</p> 
<ol start="2"><li>要启用 API，请单击“启用”：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1zBfhZDx-1681704646258)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/c46e3e5e-8993-4039-a4be-7e0bfc03ba5c.png)]</p> 
<ol start="3"><li>要建立从 Cloud Functions 到 Cloud SQL 的连接，需要以下 Cloud SQL 详细信息：</li></ol> 
<ul>
<li>实例名称</li>
<li>数据库名称</li>
<li>用户名：<code>root</code>
</li>
<li>创建实例时设置的<code>root</code>用户的密码</li>
</ul> 
<h1>
<a id="_Cloud_Function_2271"></a>创建 Cloud Function</h1> 
<p>现在让我们创建一个 Cloud Function：</p> 
<ol><li>从“计算”部分下的左侧面板中选择“云函数”：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-spi8oelp-1681704646259)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/201f4980-78e9-463a-89a0-b3d165eef2b9.png)]</p> 
<ol start="2"><li>单击“创建功能”：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SGmTdReJ-1681704646259)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/d446db1b-10dd-4607-99bd-2b012a915244.png)]</p> 
<ol start="3"><li>输入所需的功能名称。 分配的内存可以为 256 MB。 选择“触发器”作为“云存储”，然后选择“事件类型”作为“完成/创建”。 存储桶名称应为存储 PDF 到文本输出的存储桶的名称。 源代码应为内联编辑器：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dOMqXHdG-1681704646259)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/08d2a98e-b271-4acb-9d63-67a6b4cbb63e.png)]</p> 
<ol start="4">
<li>复制<code>aip_cloud_function.py</code>中的代码，并根据存储区名称和创建的 Pub/Sub 主题替换所需的详细信息。 要连接到 Cloud SQL 数据库，将需要再进行一次替换。 将“步骤 6”中提到的代码行替换为下载代码中的 Cloud SQL 详细信息。</li>
<li>从<a href="https://github.com/vss-vikram/Hands-On-Artificial-Intelligence-on-Google-Cloud-Platform">这里</a>下载 Cloud Functions 代码。</li>
<li>提供 MySQL 连接详细信息，如以下代码所示。 您将从上一步下载的 Cloud Function 代码中获得相同的代码行。 请使用适当的详细信息替换数据库用户，密码，名称和 Cloud SQL 实例：</li>
</ol> 
<p><code># MYSQL+pymysql://&lt;db_user&gt;:&lt;db_pass&gt;@/&lt;db_name&gt;?unix_socket=/cloudsql/&lt;cloud_sql_instance_name&gt;</code></p> 
<ol start="7"><li>替换该行后，复制并粘贴代码，如以下屏幕截图所示：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-b32XgZLD-1681704646260)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/b0db1663-c9d2-4f47-9c97-f0fd766eb6d5.png)]</p> 
<ol start="8"><li>对于依赖项设置，请从以下链接复制<code>requirement.txt</code>中的内容，并将其粘贴到<a href="https://github.com/vss-vikram/Hands-On-Artificial-Intelligence-on-Google-Cloud-Platform">中的需求文件中 https://github.com/vss-vikram/Hands-On-Artificial-Intelligence-on-Google -云平台</a>
</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UNJiCTaW-1681704646260)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/4132efba-5b24-440d-b322-fae469d349f8.png)]</p> 
<ol start="9">
<li>单击“创建功能”。</li>
<li>创建功能后，单击功能，然后转到“常规”选项卡。 检查用于运行该功能的服务帐户：</li>
</ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Tt6aN3Gz-1681704646260)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/3b693ce4-3130-4d10-a571-f0d9c3f4fc81.png)]</p> 
<h1>
<a id="_Cloud_SQL__2306"></a>提供 Cloud SQL 管理员角色</h1> 
<p>接下来，让我们向运行 Cloud Function 的服务帐户提供 Cloud SQL Admin 角色：</p> 
<ol><li>转到“IAM”部分：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8LNsavQk-1681704646260)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/71cd4bd7-4577-4e46-8747-7090a07d9c14.png)]</p> 
<ol start="2"><li>选择将用于运行 Cloud Functions 的服务帐户：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dsjRZ2f6-1681704646261)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/afadfc22-1ce8-444b-ac12-279458c0104b.png)]</p> 
<ol start="3"><li>将 Cloud Admin 角色分配给该帐户：</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-roWKisrM-1681704646261)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/80278a1e-2d2d-4ee4-accf-edb7400f6b72.png)]</p> 
<p>现在，让我们遍历 Cloud Function 的完整代码，以将 PDF 转换为文本后处理发票。 以下是部分代码段。 完整代码可在<a href="https://shorturl.at/yADV9">这个页面</a>处找到：</p> 
<pre><code class="prism language-py"><span class="token keyword">def</span> <span class="token function">validate_aip</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Triggered by a change to a Cloud Storage bucket.
    Args:
         event (dict): Event payload.
         context (google.cloud.functions.Context): Metadata for the event.
    """</span>
    <span class="token comment">#Code block to read file from GCS and load data in JSON format.</span>
    client <span class="token operator">=</span> storage<span class="token punctuation">.</span>Client<span class="token punctuation">(</span><span class="token punctuation">)</span>
    bucket <span class="token operator">=</span> client<span class="token punctuation">.</span>get_bucket<span class="token punctuation">(</span>bucket<span class="token punctuation">)</span>
    blob <span class="token operator">=</span> bucket<span class="token punctuation">.</span>get_blob<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span>
    contents <span class="token operator">=</span> blob<span class="token punctuation">.</span>download_as_string<span class="token punctuation">(</span><span class="token punctuation">)</span>
    contents <span class="token operator">=</span> contents<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>
    data <span class="token operator">=</span> JSON<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>contents<span class="token punctuation">)</span>

    <span class="token comment">#Reading required text field from data.</span>
    output <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'responses'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'fullTextAnnotation'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'text'</span><span class="token punctuation">]</span>
    output <span class="token operator">=</span> output<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token comment">#Code setup to convert output data from JSON file to the required format                                for loading into invoice table.</span>

    df_invoice <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">.</span>from_dict<span class="token punctuation">(</span>output_dict<span class="token punctuation">)</span>

    df_invoice<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Developer'</span><span class="token punctuation">,</span> <span class="token string">'Rate'</span><span class="token punctuation">,</span> <span class="token string">'Hours'</span><span class="token punctuation">,</span> <span class="token string">'Subtotal'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span>                               df_invoice<span class="token punctuation">[</span><span class="token string">'Developer Rate Hours Subtotal'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>expand<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

    df_invoice <span class="token operator">=</span> df_invoice<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Developer Rate Hours Subtotal'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment">#Establishing connection with Cloud SQL.</span>
    db_con <span class="token operator">=</span> sqlalchemy<span class="token punctuation">.</span>create_engine<span class="token punctuation">(</span><span class="token string">'MYSQL+pymysql://&lt;db_user&gt;:                                     &lt;db_pass&gt;@/&lt;db_name&gt;?                                                                  unix_socket=/cloudsql/&lt;cloud_sql_instance_name&gt;'</span>
    <span class="token punctuation">)</span>

</code></pre> 
<p>在代码的这一部分中，我们导入了所需的依赖关系，然后，当从 GCS 加载数据时，我们使用了 GCS 特定的库从 GCS 中存储的文件中加载数据。 加载文件后，将从 JSON 文件中提取包含我们在本章前面讨论的所有信息的特定文本。 使用正则表达式将文本字段分隔为单独的列，并使用正则表达式输出填充 Cloud SQL 中的发票表。</p> 
<h1>
<a id="_Cloud_Functions__2359"></a>使用 Cloud Functions 验证发票</h1> 
<p>在本节中，我们将遍历用于验证发票处理的代码。 您将需要在时间表表中加载数据以与发票表进行交叉验证（发票表是使用 PDF 文件填充的）。</p> 
<p>以下是在数据库中创建时间表表并将数据加载到表中的步骤：</p> 
<ol><li>正如我们在“使用 Cloud SQL 秘籍存储发票”的步骤 2 中所讨论的那样，使用 Cloud Shell 实例连接到 MySQL，并运行以下查询以创建表时间表表：</li></ol> 
<pre><code class="prism language-py">create table timesheet 
<span class="token punctuation">(</span>Company_Name VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
SOW_Number VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Project_ID VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Invoice_Number VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Invoice_Date DATE<span class="token punctuation">,</span>
Billing_Period DATE<span class="token punctuation">,</span>
Developer VARCHAR<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Rate VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Hours INT<span class="token punctuation">,</span>
Bank_Account_Number INT<span class="token punctuation">,</span>
Bank_Name VARCHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="2"><li>运行以下查询以将数据插入时间表表。 如前所述，您可以使用<code>aip.sql</code>来获取以下查询：</li></ol> 
<pre><code class="prism language-py">insert into timesheet <span class="token punctuation">(</span>Company_Name<span class="token punctuation">,</span> SOW_Number<span class="token punctuation">,</span> Project_ID<span class="token punctuation">,</span> Invoice_Number<span class="token punctuation">,</span> Invoice_Date<span class="token punctuation">,</span> Billing_Period<span class="token punctuation">,</span> Developer<span class="token punctuation">,</span> Rate<span class="token punctuation">,</span> Hours<span class="token punctuation">,</span> Bank_Account_Number<span class="token punctuation">,</span> Bank_name<span class="token punctuation">)</span>
values <span class="token punctuation">(</span><span class="token string">'Vsquare Systems'</span><span class="token punctuation">,</span> <span class="token string">'001'</span><span class="token punctuation">,</span> <span class="token string">'002'</span><span class="token punctuation">,</span> <span class="token string">'030'</span><span class="token punctuation">,</span> <span class="token string">'2020-01-31'</span><span class="token punctuation">,</span> <span class="token string">'2020-01-31'</span><span class="token punctuation">,</span> <span class="token string">'Developer1'</span><span class="token punctuation">,</span> <span class="token string">'$185'</span><span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">000000001</span><span class="token punctuation">,</span> <span class="token string">'Payment Bank'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

insert into timesheet <span class="token punctuation">(</span>Company_Name<span class="token punctuation">,</span> SOW_Number<span class="token punctuation">,</span> Project_ID<span class="token punctuation">,</span> Invoice_Number<span class="token punctuation">,</span> Invoice_Date<span class="token punctuation">,</span> Billing_Period<span class="token punctuation">,</span> Developer<span class="token punctuation">,</span> Rate<span class="token punctuation">,</span> Hours<span class="token punctuation">,</span> Bank_Account_Number<span class="token punctuation">,</span> Bank_name<span class="token punctuation">)</span>
values <span class="token punctuation">(</span><span class="token string">'Vsquare Systems'</span><span class="token punctuation">,</span> <span class="token string">'001'</span><span class="token punctuation">,</span> <span class="token string">'002'</span><span class="token punctuation">,</span> <span class="token string">'030'</span><span class="token punctuation">,</span> <span class="token string">'2020-01-31'</span><span class="token punctuation">,</span> <span class="token string">'2020-01-31'</span><span class="token punctuation">,</span> <span class="token string">'Developer2'</span><span class="token punctuation">,</span> <span class="token string">'$150'</span><span class="token punctuation">,</span> <span class="token number">152</span><span class="token punctuation">,</span> <span class="token number">000000001</span><span class="token punctuation">,</span> <span class="token string">'Payment Bank'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

insert into timesheet <span class="token punctuation">(</span>Company_Name<span class="token punctuation">,</span> SOW_Number<span class="token punctuation">,</span> Project_ID<span class="token punctuation">,</span> Invoice_Number<span class="token punctuation">,</span> Invoice_Date<span class="token punctuation">,</span> Billing_Period<span class="token punctuation">,</span> Developer<span class="token punctuation">,</span> Rate<span class="token punctuation">,</span> Hours<span class="token punctuation">,</span> Bank_Account_Number<span class="token punctuation">,</span> Bank_name<span class="token punctuation">)</span>
values <span class="token punctuation">(</span><span class="token string">'Vsquare Systems'</span><span class="token punctuation">,</span> <span class="token string">'001'</span><span class="token punctuation">,</span> <span class="token string">'002'</span><span class="token punctuation">,</span> <span class="token string">'030'</span><span class="token punctuation">,</span> <span class="token string">'2020-01-31'</span><span class="token punctuation">,</span> <span class="token string">'2020-01-31'</span><span class="token punctuation">,</span> <span class="token string">'Developer3'</span><span class="token punctuation">,</span> <span class="token string">'$140'</span><span class="token punctuation">,</span> <span class="token number">168</span><span class="token punctuation">,</span> <span class="token number">000000001</span><span class="token punctuation">,</span> <span class="token string">'Payment Bank'</span><span class="token punctuation">)</span>
</code></pre> 
<p>现在我们已经准备好数据，让我们深入验证过程。</p> 
<ol start="3"><li>让我们来看一下数据验证所需的代码。 在以下代码中，我们从先前创建的时间表表中提取数据，并基于<code>Company Name</code>，<code>SOW_Number</code>，<code>Project_ID</code>，<code>Invoice_Number</code>和<code>Developer</code>创建数据框：</li></ol> 
<pre><code class="prism language-py"><span class="token comment">#Reading data from timesheet table.</span>
 df_timesheet <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_sql<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'SELECT * FROM timesheet'</span></span><span class="token punctuation">,</span> con<span class="token operator">=</span>db_con<span class="token punctuation">)</span>
 joined_df <span class="token operator">=</span> pd<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>df_invoice<span class="token punctuation">,</span> df_timesheet<span class="token punctuation">,</span> on<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Company_Name'</span><span class="token punctuation">,</span><span class="token string">'SOW_Number'</span><span class="token punctuation">,</span><span class="token string">'Project_ID'</span><span class="token punctuation">,</span><span class="token string">'Invoice_Number'</span><span class="token punctuation">,</span><span class="token string">'Invoice_Date'</span><span class="token punctuation">,</span><span class="token string">'Developer'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>在以下代码中，我们根据费率和小时数匹配发票和时间表数据框。 如果所有记录都匹配，那么我们可以继续； 如果存在差异，则不会处理发票：</p> 
<pre><code class="prism language-py"><span class="token comment">#Matching data of both tables.</span>
 matched <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

 <span class="token keyword">for</span> index<span class="token punctuation">,</span> row <span class="token keyword">in</span> joined_df<span class="token punctuation">.</span>iterrows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

 <span class="token keyword">if</span> row<span class="token punctuation">[</span><span class="token string">'Rate_x'</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">'Rate_y'</span><span class="token punctuation">]</span> <span class="token keyword">and</span> row<span class="token punctuation">[</span><span class="token string">'Hours_x'</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">'Hours_y'</span><span class="token punctuation">]</span> <span class="token keyword">and</span>                                               row<span class="token punctuation">[</span><span class="token string">'Bank_Account_Number_x'</span><span class="token punctuation">]</span> <span class="token operator">==</span>                                                                   row<span class="token punctuation">[</span><span class="token string">'Bank_Account_Number_y'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>

     matched<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>

 <span class="token keyword">else</span><span class="token punctuation">:</span>

     matched<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="_2422"></a>为发票安排付款队列（发布/订阅）</h1> 
<p>在本节中，我们将学习如何将消息推送到 Pub/Sub 主题，以便发票处理系统处理发票。 我们将介绍创建发布/订阅主题的过程，以及如何发布和订阅该主题的消息。</p> 
<p>让我们创建一个主题并对其进行测试：</p> 
<ol>
<li> <p>要启用 Cloud Pub/Sub API，请执行以下步骤：</p> 
  <ol>
<li>从主页搜索发布/订阅 API。</li>
<li>启用 API。</li>
</ol> </li>
<li> <p>要创建发布/订阅主题和订阅，请执行以下步骤：</p> 
  <ol>
<li>从左侧面板中选择发布/订阅。</li>
<li>单击“创建主题”。</li>
<li>在左侧面板中，转到“订阅”，然后为创建的主题创建订阅。</li>
</ol> </li>
<li> <p>从以下屏幕快照中显示的选项中，将消息推送到主题中：</p> </li>
</ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eb8ClKTe-1681704646261)(https://gitcode.net/apachecn/apachecn-dl-zh/-/raw/master/docs/handson-ai-gcp/img/e7bec9a0-7db0-48d2-827b-7a288b6a70ca.png)]</p> 
<ol start="4"><li>以下代码演示了，一旦数据匹配，我们就将一条消息推送到 Pub/Sub 主题，该信息将由付款处理系统使用以处理发票：</li></ol> 
<pre><code class="prism language-py"> <span class="token comment">#Pushing successful message into Pub/Sub.</span>
 <span class="token keyword">if</span> <span class="token boolean">False</span> <span class="token keyword">not</span> <span class="token keyword">in</span> matched<span class="token punctuation">:</span>
     data <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f"Invoice Matched"</span></span>
     publisher <span class="token operator">=</span> pubsub_v1<span class="token punctuation">.</span>PublisherClient<span class="token punctuation">(</span><span class="token punctuation">)</span>
     topic_path <span class="token operator">=</span> publisher<span class="token punctuation">.</span>topic_path<span class="token punctuation">(</span><span class="token string">'project_id'</span><span class="token punctuation">,</span> <span class="token string">'topic_name'</span><span class="token punctuation">)</span>
     bdata <span class="token operator">=</span> data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>
     future <span class="token operator">=</span> publisher<span class="token punctuation">.</span>publish<span class="token punctuation">(</span>topic_path<span class="token punctuation">,</span> data<span class="token operator">=</span>bdata<span class="token punctuation">)</span>
</code></pre> 
<h1>
<a id="_AP__2452"></a>通知供应商和 AP 团队有关付款完成的信息</h1> 
<p>在撰写本文时，GCP 使用 SendGrid 发送电子邮件。 SendGrid 是一个受信任的电子邮件传递系统，该系统在全球范围内用于发送跨国和市场营销电子邮件。 这是一个非常强大的基于云的解决方案，它消除了维护电子邮件基础结构的所有复杂性。 在本节中，我们将学习如何使用 SendGrid 发送电子邮件。 它免费提供 12,000 封电子邮件。</p> 
<p>以下是启用 SendGrid API 的步骤：</p> 
<ol>
<li>从主页搜索云消息传递。</li>
<li>启用 S​​endGrid API。</li>
</ol> 
<p>现在，让我们看看如何从 SendGrid 配置和发送电子邮件。</p> 
<p>以下是示例 Python 代码，可用于从 SendGrid 发送电子邮件。 该代码非常简单，不言自明。 您只需要确保使用正确的 API 密钥即可：</p> 
<pre><code class="prism language-py"><span class="token comment"># using SendGrid's Python Library - https://github.com/sendgrid/sendgrid-python</span>
<span class="token keyword">import</span> sendgrid
​
sg <span class="token operator">=</span> sendgrid<span class="token punctuation">.</span>SendGridClient<span class="token punctuation">(</span><span class="token string">"YOUR_SENDGRID_API_KEY"</span><span class="token punctuation">)</span>
message <span class="token operator">=</span> sendgrid<span class="token punctuation">.</span>Mail<span class="token punctuation">(</span><span class="token punctuation">)</span>
​
message<span class="token punctuation">.</span>add_to<span class="token punctuation">(</span><span class="token string">"test@sendgrid.com"</span><span class="token punctuation">)</span>
message<span class="token punctuation">.</span>set_from<span class="token punctuation">(</span><span class="token string">"you@youremail.com"</span><span class="token punctuation">)</span>
message<span class="token punctuation">.</span>set_subject<span class="token punctuation">(</span><span class="token string">"Sending with SendGrid is Fun"</span><span class="token punctuation">)</span>
message<span class="token punctuation">.</span>set_html<span class="token punctuation">(</span><span class="token string">"and easy to do anywhere, even with Python"</span><span class="token punctuation">)</span>
sg<span class="token punctuation">.</span>send<span class="token punctuation">(</span>message<span class="token punctuation">)</span>
</code></pre> 
<p>前面的代码用于在电子邮件正文中配置 SendGrid 客户端，收件人，发件人，主题和消息。</p> 
<p>现在，您已经了解了如何以自动化方式处理发票。 接下来，我们将快速了解如何为 AIP 创建对话界面。</p> 
<h1>
<a id="_AIP__2483"></a>为 AIP 创建对话界面</h1> 
<p>使用存储在 Cloud SQL 中的数据构建应用后，我们可以通过启用 Dialogflow API 来启用会话界面。 我们可以创建应用上下文并训练智能体以处理与发票相关的各种用户查询。 我们需要连接到数据存储的外部集成服务，以根据应用上下文回答各种用户查询。 我们已经在第 6 章，“使用 Dialogflow 的智能会话应用”中，看到了使用 Dialogflow 启用对话接口的详细步骤。 通过启用 Dialogflow 智能体，自动发票处理的用例可以完全补充人的智能并避免人工干预和错误，并且可以更快，更高效地处理大量发票。</p> 
<p>在本章中，我们已经看到了各种 GCP 工具和应用在构建用于自动发票处理的智能应用中的实际应用。 如我们所见，通过使用 GCP 工具，可以轻松无缝地开发补充人类智能的功能。 该平台本身正在不断发展，并朝着高端功能的完全普及发展，这些高端功能利用了完全托管的服务来进行存储，计算，机器学习和高级分析。 在本章（和本书）的最后部分，我们将探讨 GCP 即将推出的一些功能。 我们期望，凭借不断的创新和 Google 在处理全球数据方面的经验，即将推出的工具，框架和应用将使在 GCP 上构建智能应用变得更加轻松，快捷和更具成本效益。</p> 
<h1>
<a id="_2489"></a>即将推出的功能</h1> 
<p>当务之急是，随着新功能的增加，GCP 将会进一步发展。 以下是我们认为将来会添加到 GCP 中的新增功能的代表列表：</p> 
<ul>
<li> <p>GCP 将具有更好的跨平台产品集成和可用性。 例如，IBM Power Systems 现在可以在 GCP 上使用。 这样，通过将整个平台迁移到 GCP，即可利用企业已经在大型生产系统中进行的投资。 这将为企业节省实现成本和基础设施成本。</p> </li>
<li> <p>即用型 AI 和 ML 模型将启用 GCP。 随着市场的成熟，GCP 将托管越来越多的 AI 和 ML 模型。 这些模型可通过具有固有互操作性的预定义 API 来使用。 GCP 将不断对模型进行训练和调整，并随着时间的推移产生越来越好的结果。 市场将随着使用量的增加而成熟。 签署和定价将简化，以使所有经验级别（包括入门级）的开发人员都能够快速构建其企业应用。</p> </li>
<li> <p>GCP 将提供一个拖放式用户界面，以构建从问题分类到模型部署的整个 AI 管道。 届时，人工智能的力量将完全掌握在业务团队手中，而对 IT 和开发团队的依赖将减少。 平台的简化和普及将带来进一步的创新，我们将体验不仅使用而且每个人都构建的智能应用。</p> </li>
<li> <p>GCP 将启用针对特定行业和企业的 AI 工具包，以提高各种规模企业的盈利能力和创新能力。 例如，谷歌已经在帮助零售商加速其数字和多渠道收入增长。 除此之外，Google 还帮助零售商变得完全由数据驱动，并提出建议（基于数据）以提高运营效率。 这可以通过利用 GCP，Chrome Enterprise 和 Android 上的 AI 工具以及整个连接的工具箱来实现。</p> </li>
<li> <p>GCP 上的 AI 工具包还将促进需要大量数据和计算能力以及用于构建 AI 管道的过程和接口的研究项目。 例如，谷歌正在帮助 FDA MyStudies 利用现实世界的数据进行生物学研究。 Google Cloud 正在与 FDA 合作开发 MyStudies 应用，并提供了更好，适应性更强的保护和可配置的隐私权策略。 目的是为研究组织提供自动识别和保护个人身份信息的能力。 Google Cloud 将继续投资于各种研究和研究计划，以对该平台进行总体改进，扩大支持的评估数量，并允许与下游分析和可视化工具集成。</p> </li>
<li> <p>AutoML Tables 使您的整个数据科学家团队能够以极高的速度和规模在结构化数据上自动构建和部署 ML 模型。 它具有出色的特征工程模型训练函数。 训练开始时，AutoML 表将自动执行某些特征工程任务，例如对输入进行标准化。 数值函数被限制在范围内，以实现更好的模型可靠性，日期时间输入参数的规范化，基本文本处理清除和停止单词删除，并为因变量创建单热编码和嵌入。 AutoML 表在线性，前馈深度神经网络，梯度提升决策树，AdaNet 和各种模型架构的集合上执行并行测试，以确定适合您的数据集的最佳模型架构。 用户将能够使用 StackDriver 日志记录查看 AutoML 表结构，并能够导出测试数据。</p> </li>
<li> <p>AI Hub 是即将加入 GCP 的另一个非常有用的功能。 AI Hub 是用于构建最复杂的 ML 管道的一站式设施。 可以使用预配置的笔记本使用一些预训练的模型来构建 AI 应用，以及轻松地训练新模型。 AI Hub 还确保以一致的方式访问相关事件数据集。 还可以在模型开发上进行协作，并利用基于通用框架（例如 TensorFlow）构建的模型。 这极大地促进了在 GCP 上训练和部署模型。</p> </li>
<li> <p>通过 AI 平台笔记本，可以通过受保护的，公开可用的笔记本实例 URL 轻松管理 JupyterLab 实例。 它将使您能够创建和管理与 JupyterLab 预先打包的虚拟机实例。 AI Platform Notebooks 实例将支持 PyTorch 和 TensorFlow 框架。 这些笔记本将受到 GCP 认证和授权的保护。 AI Platform Notebooks 将随附许多预装的常用软件。</p> </li>
<li> <p>AI 平台深度学习容器是 GCP 提供一种访问预训练模型的独特方法，可以在 GCP 上高度优化和一致的环境的帮助下快速对其进行原型化和使用。 这有助于快速构建工作流，并以最小的进入障碍和成本促进实验。 这是使 AI 开发功能完全普及的巨大飞跃。</p> </li>
<li> <p>AI 平台数据标记服务是在网络规模标记数据点时利用人类智能的绝佳方法。 组织可以向 Google 请求此服务以手动标记数据集。 当考虑新的用例且初始数据集不可用时，这有助于收集训练和评估数据。 Google 一直致力于在互联网上众包数据集标签的过程。 当我们要处理需要标记的高度安全的数据时，标记服务也很方便。 带有标签服务的接口是一种获取数据标签的安全有效的方法。</p> </li>
</ul> 
<h1>
<a id="_2507"></a>总结</h1> 
<p>在本章中，我们学习了创建 AI 应用的分步方法。 我们讨论了自动发票处理应用的设计和开发。 我们使用 OCR 和 Vision API 将发票 PDF 转换为文本，然后使用发票数据来验证时间表数据。 成功验证后，我们处理了发票。 我们学习了如何使用多种 Google 服务在 GCP 上开发端到端应用。 最后，我们简要讨论了 GCP 即将发布的功能。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>