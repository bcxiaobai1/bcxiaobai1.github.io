<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Web 前端基础知识面试大全 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Web 前端基础知识面试大全</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <h1><span style="color:#0d0016"><strong>一、HTML</strong></span></h1> 
<h2><span style="color:#0d0016">1.对 HTML 语义化的理解</span></h2> 
<p><span style="color:#0d0016">见标签知其意思     header main nav aside footer h1-h6 ul li</span></p> 
<p><span style="color:#0d0016">优点：结构清晰、方便搜索引擎搜素（seo）、方便理解维护</span></p> 
<h2><span style="color:#0d0016"><strong>2.区别：src 和 href</strong></span></h2> 
<ul><li>src</li></ul>
<p>比如常见的 &lt;img src=""&gt; 这里的 src 所指的是这个图片的所在的位置路径，script 和 iframe 也是，src 被解析的时候，会进行下载并编译，同时会暂停该文档其他资源的下载和处理，所以 js 文件的载入最好在 body 中，而不是在 head 中。</p> 
<ul><li>href</li></ul>
<p>href被添加，元素会被识别为 css 文件进行处理，且不会停止其它资源的运行。所以建议用 link 加载 css 文件，而不是 @import。</p> 
<p>常用的有：</p> 
<p>&lt;a href=""&gt;&lt;/a&gt; 超链接</p> 
<p>&lt;link rel="stylesheet" href=""&gt; 引用css样式</p> 
<h2><span style="color:#0d0016"><strong>3.DOCTYPE 的作用</strong></span></h2> 
<p><span style="color:#0d0016"><strong>作用</strong></span>： DOCTYPE 是文档类型 document type 的缩写。 主要作用是告诉浏览器的解析器使用哪种 HTML 规范来解析页面。而如果 DOCTYPE 缺失，或形式不正确，会导致 html 文档或 HTML 文档不是以标准模式（浏览器对页面的渲染具有统一的规范）而是以混杂模式（不同浏览器有不同的的页面渲染）运行。</p> 
<h2><span style="color:#0d0016"><strong>4.HTML5 的新特性</strong></span></h2> 
<ul>
<li> 简化了文档声明，HTML5 的文档声明只需要 &lt;!DOCTYPE HTML&gt;</li>
<li>简化了编码声明，只需要 &lt;meta charset='utf-8'&gt;</li>
<li>删除了一些能用 CSS 代替的就标签，比如 &lt;i&gt;</li>
<li>增加了一些新标签，改善文档结构的有：&lt;header&gt;&lt;footer&gt;等。减少插件依赖的 &lt;canvas&gt;&lt;audio&gt; 等</li>
<li>增加了一些新的 JavaScript 的 API ，比如地理定位、请求动画帧、离线存储等</li>
<li>配合一些框架，例如 cordova 和 react 等，可以开发基于 HTML5 的移动应用。</li>
</ul>
<h2><span style="color:#0d0016"><strong>5.script 标签中的 defer 和 async</strong></span></h2> 
<p><span style="color:#0d0016"><strong>作用</strong></span>：平常的 script 标签如果直接使用， html 会按顺序下载和执行脚本，并阻碍后续 DOM 的渲染。 如果 script 发生延迟，就会阻碍后续的渲染，使得页面白屏。</p> 
<ol><li>defer</li></ol>
<ul>
<li>异步下载文件</li>
<li>不阻碍 dom 的渲染</li>
<li>如果有多个 defer 会按顺序执行</li>
<li>执行顺序：在文档渲染后执行，在 DOMContentLoader 事件调用前执行。</li>
</ul>
<p>     2.async</p> 
<ul>
<li>异步下载文件</li>
<li>不影响 dom</li>
<li>如果有多个 defer 谁快先执行谁</li>
</ul>
<p>推荐的应用场景：</p> 
<p>defer：如果你的脚本代码依赖于页面中的 dom 元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。</p> 
<p>async：如果你的脚本并不关心页面中的 dom 元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。</p> 
<h2><span style="color:#0d0016"><strong>6. 行内元素 块级元素 空元素</strong></span></h2> 
<ol>
<li>行内元素： a  b  span  input  img  strong  br  em  big  small</li>
<li>块元素： div  ul  ol  li  h1-h6  p  dl  dt  address</li>
<li>空元素： img  input  link  meta</li>
</ol>
<h2><span style="color:#0d0016"><strong>7.meta 标签</strong></span></h2> 
<p>meta 元素被用于规定页面的描述、关键词、文档的作者、最后的修改时间以及其他元数据。标签始终位于 head 元素中。</p> 
<p>meta 属性：必选属性 content-进行描述说明的， 相当于键值； 可选属性 http-equiv、name 和 scheme, http-equiv-添加 http 头部内容，name-浏览器解析</p> 
<p>    包括：</p> 
<p>①charset charset定义使用的字符编码</p> 
<p>&lt;meta charset="utf-8"&gt;</p> 
<p>&lt;meta http-euiqv="Content-Type" content="text/html;charset=utf-8"&gt;</p> 
<p>②SEO</p> 
<p>&lt;meta name="keyword" content="csdn"&gt; #网页关键词</p> 
<p>&lt;meta name="author" content="LiHua"&gt;</p> 
<p>&lt;meta name="description" content="we are world"&gt;#网页描述</p> 
<p>③viewport </p> 
<p>&lt;meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0"&gt;</p> 
<h2 id="8.JPG%E5%92%8CPNG%E7%9A%84%E5%8C%BA%E5%88%AB"><span style="color:#0d0016"><strong>8.JPG和PNG的区别</strong></span></h2> 
<p>1.JPG是有损压缩格式，PNG是无损压缩格式</p> 
<p>2.JPG图片没有透明背景，PNG有透明背景 </p> 
<h1><span style="color:#0d0016">二、CSS</span></h1> 
<h2> <span style="color:#0d0016"><strong>1.CSS 选择器，优先级</strong></span>
</h2> 
<p> Import&gt;内联1000&gt;id100&gt;class==伪类==属性选择器10&gt;元素选择器 伪元素选择器 </p> 
<h2><span style="color:#0d0016"><strong>2.CSS 动画</strong></span></h2> 
<ul><li> <span style="color:#fe2c24">transition和animation的区别</span>
</li></ul>
<p>大部分都是相同，都是随着时间改变元素的属性值，</p> 
<p>他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件就可以实行。</p> 
<p>transition为两帧，从from…to… 而animation可以一帧一帧的通过keyframes。</p> 
<h2>
<strong><span style="color:#0d0016">3.CSS选择器效率从高到低的排序如下</span></strong>：</h2> 
<p>Id&gt;class&gt;元素选择器&gt;兄弟选择器&gt;子代选择器&gt;后代选择器&gt;属性选择器&gt;伪元素 伪类</p> 
<p>ID选择器 比如#header</p> 
<p>类选择器 比如.promo</p> 
<p>元素选择器 比如 div</p> 
<p>兄弟选择器 比如 h2 + p</p> 
<p>子选择器 比如 li &gt; ul</p> 
<p>后代选择器 比如 ul a 7. 通用选择器 比如 *</p> 
<p>属性选择器 比如 type = “text”</p> 
<p>伪类/伪元素选择器 比如 a:hover</p> 
<h2><strong><span style="color:#0d0016">4.flex 布局</span></strong></h2> 
<p> flex是css3新增的一种布局方式,我们可以同时设置一个元素的display属性值设置为flex,<br> 从而使它成为一个flex容器，它的所有子元素都成为它的项目。</p> 
<p>一个容器默认有两条轴，一个水平轴，一条是与主轴垂直的交叉轴</p> 
<p>flex-direction来指定主轴的方向。</p> 
<p>justify-content来指定标签在主轴的排列方式，</p> 
<p>使用align-items来指定元素在交叉轴的排序方式。</p> 
<p>还可以使用flex-wrap来规定当一行排列不下时的换行方式。</p> 
<p>对于一个容器的项目，</p> 
<p>使用order属性来指定项目的排列顺序，</p> 
<p>flex-grow来指定当前排序空间有剩余的时候，项目放大比例。</p> 
<p>flex-shrink来指定当前排序空间不足时， 项目缩小比例。</p> 
<h2><span style="color:#0d0016"><strong>5.position 有几个值，absolute 是相对于谁的定位。</strong></span></h2> 
<p> absolute ：生成绝对定位的元素，相对于最近一级的父元素，且该父元素不能是static，来进行定位。</p> 
<p>fixed：（老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。</p> 
<p>relative：生成相对定位的元素，相对于其在普通流中的位置进行定位。</p> 
<p>static：默认值。没有定位，元素出现在正常的流中</p> 
<h1><span style="color:#0d0016">三.Javascript</span></h1> 
<h2> <span style="color:#0d0016"><strong>1.原始值和引用值类型及区别</strong></span>
</h2> 
<p>         原始值（简单数据类型）：存储在栈中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。<br>         包含五种简单数据类型：undefined、null、boolean、number 和 string ；可以通过typeof 运算符来判断一个值是否在某种类型的范围内，如果它是原始类型，还可以判断它表示哪种原始类型。</p> 
<p>        引用值（复杂数据类型）：存储在堆中的对象，放在变量的栈空间中的值是该对象存储在堆中的地址，也就是说，存储在变量处的值是一个指针（内存地址），指向存储对象的堆内存中。</p> 
<p>包含：Object、function、array等。</p> 
<h2 id="2.JavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%20typeof%20%E8%BF%94%E5%9B%9E%E5%80%BC">2.JavaScript 数据类型以及 typeof 返回值</h2> 
<p>数据类型：number、string、null、boolean、object、undefined、symbol</p> 
<pre><code class="language-javascript">typeof x   undefined
 
typeof undefined  undefined
 
typeof true   boolean
 
function A() {}
 
typeof A function
 
 
 
const arr = []
 
const obj = {}
 
typeof arr object
 
typeof obj object</code></pre> 
<h2><span style="color:#0d0016"><strong>3.如何判断一个对象是 Array 还是 Object？</strong></span></h2> 
<p>在 typeof 判断 Array 或者 Object 的时候，其结果都是 object 那么我们怎么知道源对象是 Arrary 还是 Object 的呢？</p> 
<p class="img-center"><img alt="" height="478" src="https://images2.imgbox.com/e5/f2/CnQnvJsQ_o.png" width="764"></p> 
<h2><span style="color:#0d0016"><strong>4.类数组与数组的区别：</strong></span></h2> 
<p>相同点：</p> 
<ul><li>都可用下标访问每个元素，都有length属性。</li></ul>
<p>不同点：</p> 
<ul>
<li>数组对象的类型是Array,类数组对象的类型是object;</li>
<li>类数组不具有数组所具有的方法，</li>
<li>数组遍历可以用 for in 和 for 循环</li>
<li>类数组只能用 for 循环遍历。</li>
</ul>
<p>常见的类数组有: 函数的参数 arguments，arguments是一个类数组对象，包含着传入函数中的所有实参集合</p> 
<h2><span style="color:#0d0016"><strong>5.数组常用的api</strong></span></h2> 
<ul>
<li>字符转换 toString 方法将数组表示为字符串</li>
<li>join（）方法，将数组里 各元素组合成字符串，但连接符可自己指定</li>
<li>unshift方法，是将元素插入数组的首部。</li>
<li>shift方法移除数组的第一个元素并将其返回</li>
<li>push方法一次可添加单个或多个元素到数组末端，也可以添加数组。</li>
<li>pop方法的作用是移除数组末尾的一个元素</li>
</ul>
<h2>
<strong><span style="color:#0d0016">6.bind、call、apply的区别</span></strong><span style="color:#0d0016"><strong>：</strong></span>
</h2> 
<p>         三者都是用于改变函数体内this的指向，但是bind与apply和call的最大的区别是：bind不会立即调用，而是返回一个新函数，称为绑定函数，其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数</p> 
<p>        apply和call都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）；apply和call的调用返回函数执行结果；</p> 
<p>        如果使用apply或call方法，那么this指向他们的第一个参数，apply的第二个参数是一个参数数组，call的第二个及其以后的参数都是数组里面的元素，就是说要全部列举出来；</p> 
<p>        Bind:返回绑定函数，传入参数数列</p> 
<p>        Apply:传入参数数组</p> 
<p>        Call:传入参数数列</p> 
<h2><span style="color:#0d0016"><strong>7.new原理</strong></span></h2> 
<p>     mdn上把内部操作大概分为4步：  </p> 
<p></p> 
<ul>
<li>创建一个空的简单JavaScript对象（即{ } ）；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；(因此this就指向了这个新对象)</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>如果该函数没有返回对象，则返回this。</li>
</ul>
<h2><strong><span style="color:#0d0016">8.闭包</span></strong></h2> 
<p>有权访问另一个函数作用域中的变量的函数；</p> 
<ul>
<li>第一，闭包是一个函数，而且存在于另一个函数当中</li>
<li>第二，闭包可以访问到父级函数的变量，且该变量不会销毁</li>
<li>作用1：隐藏变量，避免全局污染</li>
<li>作用2：可以读取函数内部的变量</li>
</ul>
<h2><span style="color:#0d0016"><strong>9.原型和原型链</strong></span></h2> 
<p>        在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。 </p> 
<ul><li>原型链  __proto__ 和 constructor</li></ul>
<p>        每一个对象数据类型(普通的对象、实例、prototype......)也天生自带一个属性__proto__，属性值是当前实例所属类的原型(prototype)。实例原型中有一个属性constructor, 它指向函数对象，即构造函数。</p> 
<p class="img-center"><img alt="" height="291" src="https://images2.imgbox.com/4d/30/VA011lyK_o.png" width="603"></p> 
<p> </p> 
<p>通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链</p> 
<p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果没有则会去原型对象中寻找，直到找到Object对象的原型，Object对象的原型，如果在Object原型中依然没有找到，则返回undefined。</p> 
<p>原型链的终点：object.prototype=null</p> 
<h2><span style="color:#0d0016"><strong>10.实现继承的几种方式以及他们的优缺点</strong></span></h2> 
<p>        其实js的继承本质上是通过<a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%9E%8B%E9%93%BE&amp;spm=1001.2101.3001.7020" title="原型链">原型链</a>机制实现的扩展。不管是哪种继承方式，都是通过操作父类原型链和子类原型链形成关联关系实现的。只是不同实现中需要考虑不同的问题。在实际项目开发中，建议尽可能使用ES6的class extends实现。其他实现方式主要是理解背后的原理和思想。</p> 
<ul><li><strong>原型链继承</strong></li></ul>
<p>通过修改<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&amp;spm=1001.2101.3001.7020" title="子类">子类</a>的原型为父类的实例，从而实现子类可以访问到父类构造函数以及原型上的属性或者方法。属性没有私有化，原型上属性的改变会作用到所有的实例上。</p> 
<p>实现逻辑简单,但是父类<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" title="构造函数">构造函数</a>中的引用类型（比如对象/数组），会被所有子类实例共享。其中一个子类实例进行修改，会导致所有其他子类实例的这个值都会改变</p> 
<pre><code class="language-javascript">function Parent() {
  this.name = 'fedaily'
}
Parent.prototype.getName = function() {
  return this.name;
}
function Child() {}
// 这里也可以直接写出Child.prototype = Parent.prototype
// 但是这样就不能访问到父类的构造函数的属性了，即this.name
Child.prototype = new Parent()
var child = new Child()
console.log(child.getName()) // fedaily
</code></pre> 
<ul><li>
<strong>构造函数继承</strong>：</li></ul>
<p>在构造子类构造函数时内部使用call或apply来调用父类的构造函数</p> 
<p>实现了属性的私有化，但是子类无法访问父类原型上的属性。</p> 
<p>可以实现多继承</p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/3c/c0/0VkGIo9R_o.png" width="721"></p> 
<ul><li><strong>组合继承</strong></li></ul>
<p>同时结合原型链继承、构造函数继承就是组合继承了。</p> 
<p>同时解决了构造函数引用类型的问题，同时避免了方法会被创建多次的问题，但是父类构造函数被调用了两次。同时子类实例以及子类原型对象上都会存在name属性。虽然根据原型链机制，并不会访问到原型对象上的同名属性，但总归是不美。</p> 
<p class="img-center"><img alt="" height="494" src="https://images2.imgbox.com/24/23/Qdo38Gg7_o.png" width="730"></p> 
<ul><li><strong>寄生继承</strong></li></ul>
<p>　　核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点。</p> 
<pre><code class="language-javascript">function Parent() {
  this.name = 'fedaily'
}

Parent.prototype.getName = function() {
  return this.name
}

function Child() {
  Parent.call(this)
  this.topic = 'fe'
}

// 仔细看这个函数的实现
inherit(Child, Parent)
</code></pre> 
<pre><code class="language-javascript">function inherit(child, parent) {
  var prototype = object(parent.prototype)
  prototype.constructor = child
  child.prototype = prototype
}

// 这个函数的作用可以理解为复制了一份父类的原型对象
// 如果直接将子类的原型对象赋值为父类原型对象
// 那么修改子类原型对象其实就相当于修改了父类的原型对象
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
</code></pre> 
<p>这种方式就解决了组合继承中的构造函数调用两次，构造函数引用类型共享，以及原型对象上存在多余属性的问题。是推荐的最合理实现方式（排除<a href="https://so.csdn.net/so/search?q=ES6&amp;spm=1001.2101.3001.7020" title="ES6">ES6</a>的class extends继承哈哈哈）。</p> 
<ul><li> <p><span style="color:#0d0016"><strong>ES6继承</strong></span></p> </li></ul>
<p>ES6提供了class语法糖，同时提供了extends用于实现类的继承。这也是项目开发中推荐使用的方式。<br> 使用class继承很简单，也很直观：</p> 
<p class="img-center"><img alt="" height="575" src="https://images2.imgbox.com/16/d4/syAca4rY_o.png" width="730"></p> 
<h2><span style="color:#0d0016">11.浅拷贝与深拷贝</span></h2> 
<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 </p> 
<p><strong><span style="color:#0d0016">赋值和浅拷贝的区别</span></strong></p> 
<p>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。</p> 
<p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址</p> 
<p><span style="color:#0d0016"><strong>浅拷贝的实现方式</strong></span></p> 
<ul><li>Object.assign()</li></ul>
<p>Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。当object只有一层的时候，是深拷贝</p> 
<ul><li>Array.prototype.concat()</li></ul>
<p>修改新对象会改到源对象</p> 
<h2><span style="color:#0d0016"><strong>12.作用域</strong></span></h2> 
<p>为可访问变量，对象，函数的集合</p> 
<p>作用域链是[[Scope]]中所存储的执行期上下文的集合</p> 
<p>一个执行期上下文定义了一个函数执行的环境</p> 
<h2><span style="color:#0d0016">13.防抖与节流</span></h2> 
<p>对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。</p> 
<p>如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。</p> 
<h2><strong><span style="color:#0d0016">14.Dom节点操作常用方法</span></strong></h2> 
<ul><li><span style="color:#fe2c24">访问/获取节点</span></li></ul>
<p>document.getElementById(id);　　　　　　　　 　　//返回对拥有指定id的第一个对象进行访问</p> 
<p>document.getElementsByName(name);　　　　　　//返回带有指定名称的节点集合　　 注意拼写:Elements</p> 
<p>document.getElementsByTagName(tagname); 　　//返回带有指定标签名的对象集合　  注意拼写：Elements</p> 
<p>document.getElementsByClassName(classname);  //返回带有指定class名称的对象集合 注意拼写：Elements</p> 
<ul><li><span style="color:#fe2c24">创建节点/属性</span></li></ul>
<p>document.createElement(eName);　　//创建一个节点</p> 
<p>document.createAttribute(attrName); //对某个节点创建属性</p> 
<p>document.createTextNode(text);　　　//创建文本节点</p> 
<ul><li><span style="color:#fe2c24">添加节点</span></li></ul>
<p>document.insertBefore(newNode,referenceNode);　 //在某个节点前插入节点</p> 
<p>parentNode.appendChild(newNode);　　　　　　　　//给某个节点添加子节点</p> 
<ul><li><span style="color:#fe2c24">复制节点</span></li></ul>
<p>cloneNode(true | false);　　//复制某个节点  参数：是否复制原节点的所有属性</p> 
<ul><li><span style="color:#fe2c24">删除节点</span></li></ul>
<p>parentNode.removeChild(node);</p> 
<h2 id="15.BOM%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span style="color:#0d0016"><strong>15.BOM属性对象方法</strong></span></h2> 
<ul>
<li><span style="color:#fe2c24">window对象</span></li>
<li><span style="color:#fe2c24">location对象</span></li>
</ul>
<p>它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能</p> 
<ul><li><span style="color:#fe2c24">history对象</span></li></ul>
<p>history对象是window对象的属性，它保存着用户上网的记录，从窗口被打开的那一刻算起</p> 
<h2><span style="color:#0d0016">16.ajax的请求过程</span></h2> 
<p>一、原生JS中的Ajax</p> 
<p>1、使用ajax发送数据的步骤</p> 
<p>第一步：创建异步对象</p> 
<p>var xhr = new XMLHttpRequest();</p> 
<p>第二步：设置 请求行 open(请求方式，请求url):</p> 
<p>// get请求如果有参数就需要在url后面拼接参数，</p> 
<p>// post如果有参数，就在请求体中传递 xhr.open("get","validate.php?username="+name)</p> 
<p>xhr.open("post","validate.php");</p> 
<p>第三步：设置请求（GET方式忽略此步骤）头:setRequestHeader()</p> 
<p>// 1.get不需要设置</p> 
<p>// 2.post需要设置请求头：Content-Type:application/x-www-form-urlencoded</p> 
<p>xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");</p> 
<p>第四步：设置请求体 send()</p> 
<p>// 1.get的参数在url拼接了，所以不需要在这个函数中设置</p> 
<p>// 2.post的参数在这个函数中设置(如果有参数)</p> 
<p>xhr.send(null) xhr.send("username="+name);</p> 
<p>第五步：让异步对象接收服务器的响应数据</p> 
<h2><strong>17.总结JS中string、math、array的常用的方法</strong></h2> 
<p><span style="color:#fe2c24">一、String </span></p> 
<p>①charAt()方法用于返回指定索引处的字符。返回的字符是长度为 1 的字符串</p> 
<p>②indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置</p> 
<p>③split()方法将字符串分割成字符串数组，并返回此数组</p> 
<p>④substring()方法用于提取字符串中介于两个指定下标之间的字符，其内容是从 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。</p> 
<p><span style="color:#fe2c24">二、Math</span></p> 
<p>①ceil()方法 对一个数进行向上取整</p> 
<p>语法：Math.ceil(x)  返回大于等于x 并且与x最接近的整数</p> 
<p>②floor()方法 对一个数进行向下取整</p> 
<p>语法：Math.floor(x) 返回小于等于x 并且与x最接近的整数</p> 
<p>③round()方法 对一个数进行四舍五入取整</p> 
<p>语法：Math.round(x) 返回最接近x的整数</p> 
<p>④random()方法 返回介于 0 ~ 1 之间的一个随机数</p> 
<p>语法：Math.random() 返回0.0 ~ 1.0 之间的一个随机数。</p> 
<p>⑤max()方法返回指定的数中带有较大的值的那个数</p> 
<p>语法：Math.max(x1,x2,.....) 返回x1,x2,.....中带有最高值的数字  如果有某个参数为 NaN，或是不能转换成数字的非数字值，则返回 NaN。</p> 
<p>⑥min()方法返回指定的数中带有较小的值的那个数</p> 
<p><span style="color:#fe2c24">三、Array</span></p> 
<p>①concat()方法用于连接两个或多个数组。返回一个新的数组</p> 
<p>②join()方法用于把数组中的所有元素放入一个字符串。返回一个字符串,不改变原数组。</p> 
<p>③reverse()方法用于颠倒数组中元素的顺序，该方法会改变原来的数组，而不会创建新的数组。</p> 
<p>⑤sort()方法使数组中的元素按照一定的顺序进行重新排序，该方法会改变原来的数组。</p> 
<p>⑦map()方法按照原始数组元素顺序依次处理元素。map()方法可以方便的遍历数组。返回一个新数组，不会改变原始数组。</p> 
<p>语法：arrayObject.map(function(currentValue,index,arr), thisValue)</p> 
<p>function(currentValue, index,arr) 必需，函数，数组中的每个元素都会执行这个函数。</p> 
<p>currentValue （必选 当前元素的值）；</p> 
<p>index （可选 当前元素索引）</p> 
<p>arr （可选 当前元素属于的数组对象。后两者在回调函数中根据是否需要来决定是否作为参数传入）。</p> 
<p>thisValue 可选，网上查到的说法是：对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue ，"this" 的值为 "undefined"。一般用不到该参数。</p> 
<pre><code class="language-javascript">1 var oldArray=[1,2,3];
 
2  var newArray=oldArray.map(function(val){
 
3    return val+=3;
 
4 });
 
5  alert(newArray);//4,5,6</code></pre> 
<p>⑧reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce()方法可以方便的迭代数组。不会改变原数组。</p> 
<p>语法：arrayObject.reduce(function(previousValue, currentValue, currentIndex, arr), initialValue)</p> 
<p>function(previousValue, currentValue, currentIndex, arr) 必需，函数，</p> 
<p>reduce()方法可给该回调函数传入四个值：</p> 
<p>previousValue （必选 上一次调用回调返回的值，或者是提供的初始（initialValue））；</p> 
<p>currentValue （必选 数组中当前被处理的元素）；</p> 
<p>currentIndex（可选 当前元素在数组中的索引）；</p> 
<p>arr （可选 调用 reduce 的数组） 。</p> 
<p>initialValue 可选，若不设置。则初始值将变成数组中的第一项，而currentValue即从数组中的第二项开始。</p> 
<pre><code class="language-javascript">1 var arr=[2,4,3,7];
 
2 //数组中的元素进行累加
 
3 var val=arr.reduce(function(n1,n2){
 
4   return n1+n2;
 
5 },0);</code></pre> 
<p> </p> 
<h2><strong>18.js中“==”与"==="的区别</strong></h2> 
<p><br> == 表示相等 （值相等）</p> 
<p>===表示恒等（类型和值都要相等）</p> 
<p>js在比较的时候如果是 == 会先做类型转换，再判断值得大小，如果是===类型和值必须都相等。</p> 
<h2><strong>19.JS事件绑定（addEventListener）和普通事件（onclick）有什么区别</strong></h2> 
<p><br> 普通事件（onclick）</p> 
<p>普通事件就是直接触发事件，同一时间只能指向唯一对象，所以会被覆盖掉。代码如下：<br>  </p> 
<pre><code class="language-javascript">var btn = document.getElementById("btn");

btn.onclick = function(){undefined

        alert("你好111");

}

btn.onclick = function(){undefined

        alert("你好222");

}
</code></pre> 
<p>只运行你好222</p> 
<p><strong>事件绑定（addEventListener）</strong></p> 
<p>事件绑定就是对于一个可以绑定的事件对象，进行多次绑定事件都能运行。代码如下：</p> 
<pre><code class="language-javascript">var btn = document.getElementById("btn");

btn.addEventListener("click",function(){undefined

        alert("你好111");

},false);

btn.addEventListener("click",function(){undefined

        alert("你好222");

},false);
</code></pre> 
<p>运行结果会依次弹出你好111，你好222的弹出框。</p> 
<p>onclick属性不适用以下元素：&lt;base&gt;、&lt;bdo&gt;、&lt;br&gt;、&lt;head&gt;、&lt;html&gt;、&lt;iframe&gt;、&lt;meta&gt;、&lt;param&gt;、&lt;script&gt;、&lt;style&gt; 或 &lt;title&gt;。</p> 
<h2>20.重绘和回流</h2> 
<p><br> 我们增删DOM节点，修改一个元素的宽高，页面布局发生变化，DOM树结构发生变化，那么肯定要重新构建DOM树，而DOM树与渲染树是紧密相连的，DOM树构建完，渲染树也会随之对页面进行再次渲染，这个过程就叫回流</p> 
<p>当你给一个元素更换颜色，这样的行为是不会影响页面布局的，DOM树不会变化，但颜色变了，渲染树得重新渲染页面，这就是重绘。</p> 
<h2>21.函数柯里化及其通用封装</h2> 
<p><br> 函数柯里化，其实就是把多次调用的变量保存在闭包中，每次调用都查看一下变量数和原函数的形参数量是否相等。不相等就继续递归。直到相等为止就处理了。<br>  </p> 
<h2 id="22.JS%E4%B8%ADEventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><strong>22.JS中EventLoop事件循环机制</strong></h2> 
<ul><li>JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)</li></ul>
<p>宏任务：包括整体代码script，setTimeout，setInterval </p> 
<p>微任务：Promise.then(非new Promise)，process.nextTick(node中) </p> 
<pre><code class="language-javascript">    &lt;script&gt;
      setTimeout(function () {
        undefined

        console.log('setTimeout')
      }, 1000)

      new Promise(function (resolve) {
        undefined

        console.log('promise')
      }).then(function () {
        undefined

        console.log('then')
      })

      console.log('console')
    &lt;/script&gt;</code></pre> 
<p> </p> 
<p>首先setTimeout，放入Event Table中，1秒后将回调函数放入宏任务的Event Queue中</p> 
<p>new Promise 同步代码，立即执行console.log('promise'),然后看到微任务then，因此将其放入微任务的Event Queue中</p> 
<p>接下来执行同步代码console.log('console')</p> 
<p>主线程的宏任务，已经执行完毕，接下来要执行微任务，因此会执行Promise.then，到此，第一轮事件循环执行完毕</p> 
<p>第二轮事件循环开始，先执行宏任务，即setTimeout的回调函数，然后查找是否有微任务，没有，时间循环结束</p> 
<p>总结：</p> 
<p>事件循环，先执行宏任务，其中同步任务立即执行，异步任务加载到对应的的Event Queue中(setTimeout等加入宏任务的Event Queue，Promise.then加入微任务的Event Queue)，所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。<br>  </p> 
<h2><strong>23.前端性能优化</strong></h2> 
<p>减少请求数：合并资源(精灵图)，减少http请求数。</p> 
<p>加快请求速度：预解析DNS，减少域名数，CDN分支。</p> 
<p>缓存：http请求协议缓存，离线缓存，离线数据缓存(localStorage)。</p> 
<p>渲染：js/css优化，服务器渲染，加快顺序。</p> 
<p> </p> 
<h2><span style="color:#0d0016"><strong>24.Object.create 和new </strong></span></h2> 
<p>Object.create是内部定义一个<strong>funcition</strong><strong>对象</strong><strong>f</strong>，并且让F.prototype对象 赋值为base，并return出一个新的对象实例。 </p> 
<pre><code class="language-javascript">Object.create =  function (o) {undefined

    var F = function () {};

    F.prototype = o;

    return new F();

};</code></pre> 
<p>new做法是新建一个<strong>obj</strong><strong>对象</strong>o1，并且让o1的__proto__指向了Base.prototype对象。并且使用call 进行强转作用环境。从而实现了实例的创建。</p> 
<p>JavaScript 实际上执行的是：</p> 
<pre><code class="language-javascript">var o1 = new Object();

o1.[[Prototype]] = Base.prototype;

Base.call(o1);</code></pre> 
<h2 id="25.Location%20%E5%AF%B9%E8%B1%A1"><span style="color:#0d0016"><strong>25.Location 对象</strong></span></h2> 
<p>Location 对象包含有关当前 URL 的信息。把用户带到一个新地址</p> 
<p>window.location="/index.html"</p> 
<h2><span style="color:#0d0016"><strong>26.跨域解决方案 </strong></span></h2> 
<p>跨域：在同源策略的限制下，会阻止非同源下域的内容进行交互</p> 
<p>跨域：同协议、域名、端口</p> 
<p>1) JSONP原理</p> 
<p>利用 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</p> 
<p>2) JSONP和AJAX对比</p> 
<p>JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</p> 
<p>3) JSONP优缺点</p> 
<p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</p> 
<p>4）实现</p> 
<p>在a的script标签下，把那个跨域的API数据接口地址，赋值给script的src 传了个test.js</p> 
<p>Test.js具体实现一个功能 比如alert</p> 
<p>2.cors</p> 
<p>在服务端设置</p> 
<p>Access-control-allow-Origin 允许哪些域名可以访问</p> 
<p>Access-control-allow-methods 允许哪些请求方式</p> 
<p>3.第三方服务器代理</p> 
<p>实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</p> 
<p>代理服务器，需要做以下几个步骤：</p> 
<p>接受客户端请求 。</p> 
<p>将请求 转发给服务器。</p> 
<p>拿到服务器 响应 数据。</p> 
<p>将 响应 转发给客户端。</p> 
<h2><span style="color:#0d0016"><strong>27.JS 垃圾回收机制 </strong></span></h2> 
<p>“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。</p> 
<p>怎么使这些可达的值，变得不可达，特别是在有很多引用的情况下</p> 
<p>基本的垃圾回收算法称为“标记-清除”，定期执行以下“垃圾回收”步骤:</p> 
<p>垃圾回收器获取根并“标记”(记住)它们。</p> 
<p>然后它访问并“标记”所有来自它们的引用。</p> 
<p>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</p> 
<p>以此类推，直到有未访问的引用(可以从根访问)为止。</p> 
<p>除标记的对象外，所有对象都被删除。<br>  </p> 
<h2><span style="color:#0d0016"><strong>28.前端进阶之setTimeout 倒计时为什么会出现误差</strong>？ </span></h2> 
<p>定时器是属于 宏任务(macrotask) 。如果当前 <strong>执行栈</strong> <strong>所花费的时间大于</strong> <strong>定时器</strong> <strong>时间</strong>，那么定时器的回调在 宏任务(macrotask) 里，来不及去调用，所有这个时间会有误差。</p> 
<h1><span style="color:#0d0016"><strong> 四、数据结构</strong></span></h1> 
<ul><li><span style="color:#fe2c24">1.树和图的遍历方式</span></li></ul>
<p>数的遍历方式</p> 
<p>前中后序遍历 递归||非递归 非递归用栈</p> 
<p>层次遍历(层次遍历可以设一个队列，把元素放在队列里，每次输出队头元素。)</p> 
<p>图的遍历方式</p> 
<p>DFS BFS</p> 
<ul><li><span style="color:#fe2c24">2.数组和链表的区别</span></li></ul>
<p>数组是将元素在内存中连续存放，</p> 
<p>由于每个元素占用内存相同，可以通过下标迅速访问任何元素</p> 
<p>链表中的元素在内存中不是顺序存储的，而是通过元素中的指针联系到一起。</p> 
<p>数组 遍历方便 插入删除麻烦 链表恰好相反<br>  </p> 
<h1><span style="color:#0d0016">五、计网 </span></h1> 
<h2><span style="color:#0d0016"><strong>1.ios七层模型</strong></span></h2> 
<h2>
<img alt="" height="150" src="https://images2.imgbox.com/5d/d7/NBlyyGSL_o.png" width="1200"><span style="color:#0d0016"><strong> 2.TCP 和 UDP 的区别。</strong></span>
</h2> 
<p><img alt="" height="424" src="https://images2.imgbox.com/05/4e/tlKwmYBG_o.png" width="1200"></p> 
<h2><strong>3.HTTP 2.0 新增</strong></h2> 
<p><br> 二进制协议，多路复用(共享连接)，数据流，信息头压缩，客户端推送</p> 
<p>4.HTTP状态码<br> 200 请求成功</p> 
<p>301 永久重定向</p> 
<p>302 临时重定向</p> 
<p>304 not Modified 未修改</p> 
<p>400 客户端错误</p> 
<p>401 当前身份验证</p> 
<p>403 服务器已经得到请求，但是拒绝执行</p> 
<p>404 not found</p> 
<p>500 客户端在执行时发生错误，无法完成请求。<br>  </p> 
<p> </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>