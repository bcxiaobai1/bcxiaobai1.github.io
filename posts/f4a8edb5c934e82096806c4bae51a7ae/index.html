<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>java经典笔试题大全(50道含答案) - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java经典笔试题大全(50道含答案)</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <pre><code>  java经典笔试题大全(50道含答案)

   整理了一套常用的Java笔试题，选择题50道，简答题5道，试试你能做对多少题吧，含答案。
</code></pre> 
<p>选择题(共50题，每题1.5分，共75分。多选题选不全或选错都不得分。)</p> 
<p>1. 以下属于面向对象的特征的是(C,D)。(两项)</p> 
<p>A) 重载</p> 
<p>B) 重写</p> 
<p>C) 封装</p> 
<p>D) 继承</p> 
<p>2. 以下代码运行输出是©</p> 
<p>public class Person{<!-- --></p> 
<p>private String name=”Person”;</p> 
<p>int age=0;</p> 
<p>}</p> 
<p>public class Child extends Person{<!-- --></p> 
<p>public String grade;</p> 
<p>public static void main(String[] args){<!-- --></p> 
<p>Person p = new Child();</p> 
<p>System.out.println(p.name);</p> 
<p>}</p> 
<p>}</p> 
<p>A) 输出：Person</p> 
<p>B) 没有输出</p> 
<p>C) 编译出错</p> 
<p>D) 运行出错</p> 
<p>3. 在使用super 和this关键字时，以下描述正确的是(A)</p> 
<p>A) 在子类构造方法中使用super()显示调用父类的构造方法，super()必须写在子类构造方法的第一行，否则编译不通过</p> 
<p>B) super()和this()不一定要放在构造方法内第一行</p> 
<p>C) this()和super()可以同时出现在一个构造函数中</p> 
<p>D) this()和super()可以在static环境中使用，包括static方法和static语句块</p> 
<p>4. 以下对封装的描述正确的是(D)</p> 
<p>A) 只能对一个类中的方法进行封装，不能对属性进行封装</p> 
<p>B) 如果子类继承了父类，对于父类中进行封装的方法，子类仍然可以直接调用</p> 
<p>C) 封装的意义不大，因此在编码时尽量不要使用</p> 
<p>D) 封装的主要作用在于对外隐藏内部实现细节，增强程序的安全性</p> 
<p>5. 以下对继承的描述错误的是(A)</p> 
<p>A) Java中的继承允许一个子类继承多个父类</p> 
<p>B) 父类更具有通用性，子类更具体</p> 
<p>C) Java中的继承存在着传递性</p> 
<p>D) 当实例化子类时会递归调用父类中的构造方法</p> 
<p>6. 以下程序的运行结果是(D)</p> 
<p>class Person{<!-- --></p> 
<p>public Person(){<!-- --></p> 
<p>System.out.println(“this is a Person”);</p> 
<p>}</p> 
<p>}</p> 
<p>public class Teacher extends Person{<!-- --></p> 
<p>private String name=”tom”;</p> 
<p>public Teacher(){<!-- --></p> 
<p>System.out.println(“this is a teacher”);</p> 
<p>super();</p> 
<p>}</p> 
<p>public static void main(String[] args){<!-- --></p> 
<p>Teacher teacher = new Teacher();</p> 
<p>System.out.println(this.name);</p> 
<p>}</p> 
<p>}</p> 
<p>A) this is a Person</p> 
<p>this is a teacher</p> 
<p>tom</p> 
<p>B) this is a teacher</p> 
<p>this is a Person</p> 
<p>tom</p> 
<p>C) 运行出错</p> 
<p>D) 编译有两处错误</p> 
<p>7. 以下说法错误的是()</p> 
<p>A) super.方法()可以调用父类的所有非私有方法</p> 
<p>B) super()可以调用父类的所有非私有构造函数</p> 
<p>C) super.属性可以调用父类的所有非私有属性</p> 
<p>D) this和super关键字可以出现在同一个构造函数中</p> 
<p>8. 以下关于final关键字说法错误的是(A,C)(两项)</p> 
<p>A) final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性</p> 
<p>B) final修饰的类肯定不能被继承</p> 
<p>C) final修饰的方法不能被重载</p> 
<p>D) final修饰的变量不允许被再次赋值</p> 
<p>9. 访问修饰符作用范围由大到小是(D)</p> 
<p>A) private-default-protected-public</p> 
<p>B) public-default-protected-private</p> 
<p>C) private-protected-default-public</p> 
<p>D) public-protected-default-private</p> 
<p>10. 以下(D)不是Object类的方法</p> 
<p>A) clone()</p> 
<p>B) finalize()</p> 
<p>C) toString()</p> 
<p>D) hasNext()</p> 
<p>11. 多态的表现形式有(A)</p> 
<p>A) 重写</p> 
<p>B) 抽象</p> 
<p>C) 继承</p> 
<p>D) 封装</p> 
<p>12. 以下对重载描述错误的是(B)</p> 
<p>A) 方法重载只能发生在一个类的内部</p> 
<p>B) 构造方法不能重载</p> 
<p>C) 重载要求方法名相同，参数列表不同</p> 
<p>D) 方法的返回值类型不是区分方法重载的条件</p> 
<p>13. 以下(D)添加到ComputerBook中不会出错</p> 
<p>class Book{<!-- --></p> 
<p>protected int getPrice(){<!-- --></p> 
<p>return 30;</p> 
<p>}</p> 
<p>}</p> 
<p>public class ComputerBook extends Book{<!-- --></p> 
<p>}</p> 
<p>A) protected float getPrice(){}</p> 
<p>B) protected int getPrice(int page){}</p> 
<p>C) int getPrice(){}</p> 
<p>D) public int getPrice(){return 10;}</p> 
<p>14. 以下对抽象类的描述正确的是©</p> 
<p>A) 抽象类没有构造方法</p> 
<p>B) 抽象类必须提供抽象方法</p> 
<p>C) 有抽象方法的类一定是抽象类</p> 
<p>D) 抽象类可以通过new关键字直接实例化</p> 
<p>15. 以下对接口描述错误的有(D)</p> 
<p>A) 接口没有提供构造方法</p> 
<p>B) 接口中的方法默认使用public、abstract修饰</p> 
<p>C) 接口中的属性默认使用public、static、final修饰</p> 
<p>D) 接口不允许多继承</p> 
<p>16. 以下代码，描述正确的有(A)</p> 
<p>interface IDemo{<!-- --></p> 
<p>public static final String name; 1</p> 
<p>void print(); 2</p> 
<p>public void getInfo(); 3</p> 
<p>}</p> 
<p>abstract class Person implements IDemo{ 4</p> 
<p>public void print(){<!-- --></p> 
<p>}</p> 
<p>}</p> 
<p>A) 第1行错误，没有给变量赋值</p> 
<p>B) 第2行错误，方法没有修饰符</p> 
<p>C) 第4行错误，没有实现接口的全部方法</p> 
<p>D) 第3行错误，没有方法的实现</p> 
<p>17. 接口和抽象类描述正确的有(B,C)(两项)</p> 
<p>A) 抽象类没有构造函数</p> 
<p>B) 接口没有构造函数</p> 
<p>C) 抽象类不允许多继承</p> 
<p>D) 接口中的方法可以有方法体</p> 
<p>18. 以下描述错误的有©</p> 
<p>A) abstract 可以修饰类、接口、方法</p> 
<p>B) abstract修饰的类主要用于被继承</p> 
<p>C) abstract 可以修饰变量</p> 
<p>D) abstract修饰的类，其子类也可以是abstract修饰的</p> 
<p>19. 以下描述正确的有(B)</p> 
<p>A) 方法的重写应用在一个类的内部</p> 
<p>B) 方法的重载与返回值类型无关</p> 
<p>C) 构造方法不能重载</p> 
<p>D) 构造方法可以重写</p> 
<p>20. 以下程序运行结果是(A)</p> 
<p>public class Test extends Father{<!-- --></p> 
<p>private String name=”test”;</p> 
<p>public static void main(String[] args){<!-- --></p> 
<p>Test test = new Test();</p> 
<p>System.out.println(test.getName());</p> 
<p>}</p> 
<p>}</p> 
<p>class Father{<!-- --></p> 
<p>private String name=”father”;</p> 
<p>public String getName() {<!-- --></p> 
<p>return name;</p> 
<p>}</p> 
<p>}</p> 
<p>A) father</p> 
<p>B) test</p> 
<p>C) 编译出错</p> 
<p>D) 运行出错，无输出</p> 
<p>21. 以下对异常的描述不正确的有©</p> 
<p>A) 异常分为Error和Exception</p> 
<p>B) Throwable是所有异常类的父类</p> 
<p>C) Exception是所有异常类父类</p> 
<p>D) Exception包括RuntimeException和RuntimeException之外的异常</p> 
<p>22. 在try-catch-finally语句块中，以下可以单独与finally一起使用的是(B)</p> 
<p>A) catch</p> 
<p>B) try</p> 
<p>C) throws</p> 
<p>D) throw</p> 
<p>23. 下面代码运行结果是(B)</p> 
<p>public class Demo{<!-- --></p> 
<p>public int add(int a,int b){<!-- --></p> 
<p>try{<!-- --></p> 
<p>return a+b;</p> 
<p>}catch(Exception e){<!-- --></p> 
<p>System.out.println(“catch 语句块”);</p> 
<p>}finally{<!-- --></p> 
<p>System.out.println(“finally 语句块”);</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<p>public static void main(String[] args){<!-- --></p> 
<p>Demo demo = new Demo();</p> 
<p>System.out.println(“和是：”+demo.add(9,34));</p> 
<p>}</p> 
<p>}</p> 
<p>A) 编译异常</p> 
<p>B) finally语句块 和是：43</p> 
<p>C) 和是：43 finally语句块</p> 
<p>D) catch语句块 和是：43</p> 
<p>24. 以下描述不正确的有(D)</p> 
<p>A) try块不可以省略</p> 
<p>B) 可以使用多重catch块</p> 
<p>C) finally块可以省略</p> 
<p>D) catch块和finally块可以同时省略</p> 
<p>25. 以下对自定义异常描述正确的是©</p> 
<p>A) 自定义异常必须继承Exception</p> 
<p>B) 自定义异常可以继承自Error</p> 
<p>C) 自定义异常可以更加明确定位异常出错的位置和给出详细出错信息</p> 
<p>D) 程序中已经提供了丰富的异常类，使用自定义异常没有意义</p> 
<p>26. 以下程序运行结果是(D)</p> 
<p>public class Test {<!-- --></p> 
<p>public int div(int a, int b) {<!-- --></p> 
<p>try {<!-- --></p> 
<p>return a / b;</p> 
<p>}catch(Exception e){<!-- --></p> 
<p>System.out.println(“Exception”);</p> 
<p>}catch(NullPointerException e){<!-- --></p> 
<p>System.out.println(“ArithmeticException”);</p> 
<p>}</p> 
<p>catch (ArithmeticException e) {<!-- --></p> 
<p>System.out.println(“ArithmeticException”);</p> 
<p>} finally {<!-- --></p> 
<p>System.out.println(“finally”);</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<p>public static void main(String[] args) {<!-- --></p> 
<p>Test demo = new Test();</p> 
<p>System.out.println(“商是：” + demo.div(9, 0));</p> 
<p>}</p> 
<p>}</p> 
<p>A) Exception finally 商是：0</p> 
<p>B) ArithmeticException finally 商是：0</p> 
<p>C) finally商是：0</p> 
<p>D) 编译报错</p> 
<p>27. 以下对TCP和UDP描述正确的是(D)</p> 
<p>A) TCP不能提供数据的可靠性</p> 
<p>B) UDP能够保证数据库的可靠性</p> 
<p>C) TCP数据传输效率高于UDP</p> 
<p>D) UDP数据传输效率高于TCP</p> 
<p>28. 在Java中，下面对于构造函数的描述正确的是(D)。(选择一项)</p> 
<p>A) 类必须显示定义构造函数</p> 
<p>B) 构造函数的返回类型是void</p> 
<p>C) 构造函数和类有相同的名称，并且不能带任何参数</p> 
<p>D) 一个类可以定义多个构造函数</p> 
<p>29. 根据下面的代码，</p> 
<p>String s = null;</p> 
<p>会抛出NullPointerException异常的有(A,C)。[两项]</p> 
<p>A) if( (s!=null) &amp; (s.length()&gt;0) )</p> 
<p>B) if( (s!=null) &amp; &amp; (s.length()&gt;0) )</p> 
<p>C) if( (s==null) | (s.length()==0) )</p> 
<p>D) if( (s==null) || (s.length()==0) )</p> 
<p>30. .在Java中，关于HashMap类的描述，以下廉洁错误的是( B )。</p> 
<p>A) HashMap使用键/值得形式保存数据</p> 
<p>B) HashMap 能够保证其中元素的顺序</p> 
<p>C) HashMap允许将null用作键</p> 
<p>D) HashMap允许将null用作值</p> 
<p>31. 下列选项中关于java中super关键字的说法错误的是( B )</p> 
<p>A) super关键字是在子类对象内部指代其父类对象的引用</p> 
<p>B) super关键字不仅可以指代子类的直接父类，还可以指代父类的父类</p> 
<p>C) 子类可以通过super关键字调用父类的方法</p> 
<p>D) 子类可以通过super关键字调用父类的属性</p> 
<p>32. 在Java中，以下代码( A )正确地创建了一个InputStreamReader对象。</p> 
<p>A) InuptStreamReader(new FileInputStream(“1.dat”));</p> 
<p>B) InuptStreamReader(new FileReader(“1.dat”));</p> 
<p>C) InuptStreamReader(new BufferReader(“1.dat”));</p> 
<p>D) InuptStreamReader (“1.dat”);</p> 
<p>33. 在Java中，( D )类提供定位本地文件系统，对文件或目录及其属性进行基本操作。</p> 
<p>A) FileInputStream</p> 
<p>B) FileReader</p> 
<p>C) FileWriter</p> 
<p>D) File</p> 
<p>34. Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述错误的是©(选择一项)</p> 
<p>A) ArrayList和LinkedList均实现了List接口</p> 
<p>B) ArrayList的访问速度比LinkedList快</p> 
<p>C) 添加和删除元素时，ArrayList的表现更佳</p> 
<p>D) HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值</p> 
<p>35. 在Java中开发JDBC应用程序时，使用DriverManager类的getConnection()方法建立与数据源的连接语句为：</p> 
<p>Connection con = DriverManager.getConnection(“jdbc:odbc:news”);</p> 
<p>URL连接中的“news”表示的是©(选择一项)</p> 
<p>A) 数据库中表的名称</p> 
<p>B) 数据库服务器的机器名</p> 
<p>C) 数据源的名称</p> 
<p>D) 用户名</p> 
<p>36. 在Java中,JDBCAPI定义了一组用于与数据库进行通信的接口和类，它们包括在(B)包中。</p> 
<p>A) java.lang</p> 
<p>B) java.sql</p> 
<p>C) java.util</p> 
<p>D) java.math</p> 
<p>37. Java中，以下( B )接口以键_值对的方式存储对象。</p> 
<p>A) java.util.Collection</p> 
<p>B) java.util.Map</p> 
<p>C) java.util.List</p> 
<p>D) java.util.Set</p> 
<p>38. 以下关于对象序列化描述正确的是( C,D )[两项]</p> 
<p>A) 使用FileOutputStream可以将对象进行传输</p> 
<p>B) 使用PrintWriter可以将对象进行传输</p> 
<p>C) 使用ObjectOutputStream类完成对象存储，使用ObjectInputStream类完成对象读取</p> 
<p>D) 对象序列化的所属类需要实现Serializable接口</p> 
<p>39. 在Java中，( A )类可用于创建链表数据结构的对象。</p> 
<p>A) LinkedList</p> 
<p>B) ArrayList</p> 
<p>C) Collection</p> 
<p>D) HashMap</p> 
<p>40. 分析下面这段Java代码，它的运行结果是( C )。</p> 
<p>import java.io.*;</p> 
<p>public class B{<!-- --></p> 
<p>public static void main(string [] args){<!-- --></p> 
<p>int i=12;</p> 
<p>System.out.println(i+=i-=i*=i);</p> 
<p>}</p> 
<p>}</p> 
<p>A) 100</p> 
<p>B) 0</p> 
<p>C) -120</p> 
<p>D) 程序无法编译</p> 
<p>41. 使用JDBC事务的步骤是(C,A,B,D)(多选)</p> 
<p>A) 取消Connection的事务自动提交方式</p> 
<p>B) 发生异常回滚事务</p> 
<p>C) 获取Connection对象</p> 
<p>D) 操作完毕提交事务</p> 
<p>42. 以下对JDBC事务描述错误的是( B )</p> 
<p>A) JDBC事务属于JAVA事务的一种</p> 
<p>B) JDBC事务属于容器事务类型</p> 
<p>C) JDBC事务可以保证操作的完整性和一致性</p> 
<p>D) JDBC事务是由Connection发起的，并由Connection控制</p> 
<p>43. 要通过可滚动的结果集更新数据，以下正确的是(A</p> 
<p>A) pst=con.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE)</p> 
<p>B) pst=con.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY)</p> 
<p>C) pst=con.prepareStatement(sql, Resu ltSet.TYPE_SCROLL_SENSITIVE)</p> 
<p>D) pst=con.prepareStatement(sql, ResultSet.CONCUR_UPDATABLE)</p> 
<p>44. 存储过程pro有两个参数，第一个为输入参数，第二个为输出参数，以下代码正确的是©</p> 
<p>A) CallableStatement cst=con.prepareCall(“(call pro(?,?))”);</p> 
<p>B) CallableStatement cst=con.prepareCall(“(call pro(?))”);</p> 
<p>C) CallableStatement cst=con.prepareCall(“{call pro(?,?)}”);</p> 
<p>D) CallableStatement cst=con.prepareCall(“{call pro(?,?,?)}”);</p> 
<p>45. 以下描述正确的是(B)</p> 
<p>A) CallableStatement是PreparedStatement的父接口</p> 
<p>B) PreparedStatement是CallableStatement的父接口</p> 
<p>C) CallableStatement是Statement的子接口</p> 
<p>D) PreparedStatement是Statement的父接口</p> 
<p>46. 要删除book表中书籍(bookName)是”java”的记录，以下代码正确的是(A)</p> 
<p>String sql=”delete from book where bookName=?”;</p> 
<p>PreparedStatement pst=con.preparedStatement(sql);</p> 
<p>______________________________</p> 
<p>pst.execute();</p> 
<p>A) pst.setString(1,”java”);</p> 
<p>B) pst.setString(0,”java”);</p> 
<p>C) pst.setInt(0,”java”);</p> 
<p>D) 以上选项都不正确</p> 
<p>47. 获取ResutlSet对象rst的第一行数据，以下正确的是(B)</p> 
<p>A) rst.hashNext();</p> 
<p>B) rst.next();</p> 
<p>C) rst.first();</p> 
<p>D) rst.nextRow();</p> 
<p>48. 以下可以正确获取结果集的有(AD)(多选)</p> 
<p>A) Statement sta=con.createStatement();</p> 
<p>ResultSet rst=sta.executeQuery(“select * from book”);</p> 
<p>B) Statement sta=con.createStatement(“select * from book”);</p> 
<p>ResultSet rst=sta.executeQuery();</p> 
<p>C) PreparedStatement pst=con.preparedStatement();</p> 
<p>ResultSet rst=pst.executeQuery(“select * from book”);</p> 
<p>D) PreparedStatement pst=con.preparedStatement(“select * from book”);</p> 
<p>ResultSet rst=pst.executeQuery();</p> 
<p>49. 以下负责建立与数据库连接的是(D)</p> 
<p>A) Statement</p> 
<p>B) PreparedStatement</p> 
<p>C) ResultSet</p> 
<p>D) DriverManager</p> 
<p>50. 使用JDBC连接数据库的顺序是(B,A,D,C,E)(多选)</p> 
<p>A) 加载驱动</p> 
<p>B) 导入驱动包</p> 
<p>C) 发送并处理SQL语句</p> 
<p>D) 建立于数据库的连接</p> 
<p>E 关闭连接</p> 
<p>二、简答题(各5分，共25分)</p> 
<p>1、在java中如果声明一个类为final，表示什么意思? (不计分)</p> 
<p>答：final是最终的意思，final可用于定义变量、方法和类但含义不同，声明为final的类不能被继承。</p> 
<p>1、父类的构造方法是否可以被子类覆盖(重写)?</p> 
<p>答：父类的构造方法不可以被子类覆盖，因为父类和子类的类名是不可能一样的。</p> 
<p>2、请讲述String 和StringBuffer的区别。</p> 
<p>答：String 类所定义的对象是用于存放”长度固定”的字符串。</p> 
<p>StringBuffer类所定义的对象是用于存放”长度可变动”的字符串。</p> 
<p>3、如果有两个类A、B(注意不是接口)，你想同时使用这两个类的功能，那么你会如何编写这个C类呢?</p> 
<p>答：因为类A、B不是接口，所以是不可以直接继承的，但可以将A、B类定义成父子类，那么C类就能实现A、B类的功能了。假如A为B的父类，B为C的父类，此时C就能实现A、B的功能。</p> 
<p>4、分析sleep()和wait()方法的区别。</p> 
<p>答： sleep睡眠的意思 : sleep() 方法用来暂时中止执行的线程。在睡眠后，线程将进入就绪状态。</p> 
<p>wait等待的意思: 如果调用了 wait() 方法，线程将处于等待状态。用于在两个或多个线程并发运行时。</p> 
<p>5、谈谈你对抽象类和接口的理解。</p> 
<p>答：定义抽象类的目的是提供可由其子类共享的一般形式、子类可以根据自身需要扩展抽象类、抽象类不能实例化、抽象方法没有函数体、抽象方法必须在子类中给出具体实现。他使用extends来继承。</p> 
<p>接口：一个接口允许一个类从几个接口继承而来，Java 程序一次只能继承一个类但可以实现几个接口，接口不能有任何具体的方法，接口也可用来定义可由类使用的一组常量。其实现方式是interface来实现。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>