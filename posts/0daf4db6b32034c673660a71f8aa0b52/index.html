<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>谈一谈在两个商业项目中使用MVI架构后的感悟 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">谈一谈在两个商业项目中使用MVI架构后的感悟</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <h2>
<a id="_0"></a>前言</h2> 
<p>MVI并非新兴事物，在2020年时亦曾有通过撰写一篇文章与诸位读者探讨一二的念头。</p> 
<p>当时项目采用MVP分层设计，组员的代码风格差异也较大，代码中类职责赋予与封装风格各成一套，随着业务急速膨胀，代码越发混乱。试图用 <code>MVI架构</code> + <code>单向流</code> 形成 <code>掣肘</code> 带来一致风格。<br> 但这种做法不够以人为本，最终采用 <strong>“在MVP的基础上进行了适当改造+设计约定的方式”</strong> 解决了问题，并未将MVI投入到商业项目中，于是 <strong>放弃了纸上谈兵</strong>。</p> 
<p>在半年前终于有机会在商业项目中进行实践，同诸位谈一谈使用后的 <strong>个人感悟</strong> ，并藉此讲透MVI等架构。</p> 
<p>所有内容将按照以下要点展开：</p> 
<ul>
<li>从架构的理念出发 – <strong>简单列明各种 <code>MVX</code> 的理念</strong> ， <em>MVX：指代 MVC、MVP、MVVM、MVI</em>
</li>
<li>拥抱复杂的同时实现简化 – <strong>通过对比理解单向数据流动所解决的痛点、设计Intent的原因等问题</strong>
</li>
<li>单一可信数据源，不可僵化信奉</li>
<li>要想优雅，需要工具 – <strong>借助声明式、响应式编程工具，构建<code>流</code></strong>，<em>屏蔽命令式编程中的细节，同样是聚焦和简化</em>
</li>
<li>状态和事件分家，绝不是吃饱了撑的 – <strong>为什么要裂变出状态和事件，如何界定</strong>
</li>
</ul> 
<p><em>内容会很长，我会酌情再写一些 <code>解</code> ，结合实例和代码演示内容。</em></p> 
<h3>
<a id="_19"></a>两个项目的基本情况</h3> 
<p>相比于之前的巨型项目，<strong>这两个项目的业务量均不大</strong>，一个是基于蓝牙和局域网的操控类APP，下午简称APP-A，一个是内部使用的工具，分析公司各个产品的日志，简称APP-B。</p> 
<p>虽然他们的业务深度要比一般的APP要深，但在 <strong>本质上一致</strong> ，毕竟同类型业务量再多也仅仅是重复运用一套模式 ，并不影响本质。</p> 
<p><strong>和诸多项目的本质一致</strong>，均符合如下图所示的逻辑分层，并在人机交互过程中执行业务逻辑：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1u5uz9FQ-1661322561053)(https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b226761ddc34491996ebe199d2238b6~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<ul>
<li>APP-A 是Android项目，图方便纯kotlin</li>
<li>APP-B 是 Compose-Desktop项目，不得不kotlin</li>
</ul> 
<p>过于絮叨了，我们进入正文。</p> 
<h2>
<a id="_34"></a>从架构的理念出发</h2> 
<blockquote> 
 <p>谨记，实际情况中，MVI、MVVM这些架构均先由Web应用领域提出，用于解决浏览器Web应用研发中的问题。</p> 
 <p>在后续的应用领域发展过程中，存在共性问题，便引入了这些设计，并结合自身特点进行了拓展。</p> 
</blockquote> 
<p>接下来我们聊一聊理念，不比武功。</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rNtjyHrJ-1661322561054)(https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e22a5bc38798404e959a6533a384adae~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<p><em>图片出自电影一代宗师</em></p> 
<h3>
<a id="MVI_46"></a>MVI的理念</h3> 
<p><code>MVI</code> 脱胎于 <code>Model View Intent</code></p> 
<ul>
<li>Intent：驱动model发生改变的意图，以UI中的事件最为常见；</li>
<li>Model：业务模型，包含数据和逻辑，是对应 <code>客观实体</code> 的 <code>程序建模</code>；</li>
<li>View：表现层的视图，以UI方式呈现Model的状态（以及事件），接受用户输入，转换为UI事件</li>
</ul> 
<p>官方的这幅图很好的呈现了三者之间的驱动关系：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ep8Uej99-1661322561054)(https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d56842e0964f388f41fd6e27825849~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<p>这张图非常简单，它摒弃了驱动方式的细节，只体现了角色与驱动关系。</p> 
<p>注意，只要设计中满足 <code>角色和驱动关系</code> 符合上图，就是MVI架构设计，并不限制 <code>驱动方式的实现细节</code></p> 
<p><em>经典的MVI驱动细节要比上图复杂很多，下文再聊。</em></p> 
<p>从软件设计的原则出发：<code>职责分离并封装</code> 的目的是 <code>解耦</code> 、 <code>可独立变化</code>、<code>复用</code>。</p> 
<p>显然，区别于 <code>MVVM</code> 、 <code>MVP</code> 、 <code>MVC</code>，角色上的差别在于 ViewModel、Presenter、Controller、Intent四者，而它们又是View和Model之间的纽带。除此之外，V和M亦稍有不同。</p> 
<h4>
<a id="MVCMVP_68"></a>MVC、MVP</h4> 
<p>MVC、MVP 中，C和P的职责体现为 <code>控制、调度</code>。</p> 
<p>MVP中 <code>V</code> 和 <code>M</code> 完全解耦可独立变化，MVC中 <code>M</code> 直接操作 <code>V</code> 耦合高，在web应用中，<code>C</code> 需要直接操作DOM。</p> 
<h4>
<a id="MVVM_74"></a>MVVM</h4> 
<p>MVVM中，提倡 <code>数据驱动</code>， <code>数据源</code> 被剥离到 <code>VM</code> 中，在 <code>双向绑定框架</code> 的加持下，View层的输入反映为数据的变化，数据的变化驱动视图内容。</p> 
<p>显然，VM的职责限于维护数据状态，<em>如有必要，驱动View层消费数据状态，</em> 不必再关注如何操作视图。</p> 
<p><em>一般来说，双向绑定框架已经引入观察者模式实现，可响应式驱动，VM一般没有必要关心 <strong>响应式驱动和下游观察者生命周期问题</strong></em></p> 
<p>简单思考之后会发现MVVM的问题，它的侧重点在于 <code>利用双向绑定让开发者专注于数据状态的维护，从操作视图更新中得以解放</code>，它难以解决 <code>无天然状态</code> 问题，例如：按钮点击这类事件。</p> 
<h4>
<a id="MVI_84"></a>MVI</h4> 
<p>在MVI中，结合业务背景将UI事件等内容转换为 <code>Intent</code> ，驱动Model层业务，Model层的业务结果反映为 <code>视图状态</code> + <code>事件</code>。</p> 
<p>因此View层和Model层之间已经解耦，并可以吸收MVVM中的优点采用如下设计：</p> 
<ul>
<li>将双向绑定退化为单向绑定，View层消费UI状态流和事件流，这也意味着UI状态的职责精简，它不再承载View层的用户输入等事件</li>
<li>将UI状态独立，Model层仅产生 <code>UI状态的局部变化</code> 和 <code>事件</code>
</li>
</ul> 
<p>下图为经典的MVI原理示意图：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4ag8in4l-1661322561055)(https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9dc25d054bd4693a23714e090af4476~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<p>在上文中，我们已经讨论了各个角色的职责，下面逐步展开讨论角色具备的特性和细节知识。</p> 
<p>在此之前，还请谨记：合适的才是最好的</p> 
<blockquote> 
 <p>没有绝对的最好的设计，只有最合适的设计。</p> 
</blockquote> 
<p>再好的架构，都需要遵循其理念并结合项目因地制宜地进行调整，以获得最佳使用效果。所以请读者诸君务必在阅读时，结合自身项目的情况仔细思考以下问题：</p> 
<ul>
<li><strong>引入新框架所解决的痛点、衍生的问题、是否需要进行框架调整？</strong></li>
<li><strong>框架中的角色功能，为什么出现，又有怎样的局限？</strong></li>
</ul> 
<h2>
<a id="_108"></a>单向数据流动</h2> 
<blockquote> 
 <p>MVI拥抱了结构复杂，但能够灵活应对业务编码时的各种情况，按部就班即可。</p> 
</blockquote> 
<p>从MVI原理图中，可以清晰的看到 <strong>“数据”</strong> 的流动方向。<br> 起始于 <code>Intent</code>，经过分类和选择性消费后产生 <code>Result</code>，对应的reducer函数计算后，得到最新的 <code>State</code> <em>（以及裂变出必要的 <code>Event</code>，图中未体现）</em> ，驱动视图。</p> 
<p>注意：</p> 
<ul>
<li>
<code>单向</code> 是指 <strong>单一方向</strong>
</li>
<li>此处的 <code>数据</code> 是广义的、宽泛的。</li>
<li>仅描述数据流的 <strong>变化方向</strong> ，与数据流的数量无关，但一般 <strong>形成有效工作</strong> 均需要两条数据流（上行数据流和下行数据流）</li>
</ul> 
<p>即驱动数据流变化的方向是唯一的，在英文中的术语为：<code>Unidirectional Data Flow</code> 简称 <code>UDF</code>。</p> 
<h3>
<a id="MVCMVP_123"></a>MVC、MVP中的痛点</h3> 
<p>前文我们提到，在MVC和MVP中，着眼于 <strong>控制、调度</strong> ，并不强调 <code>数据流</code> 的概念。</p> 
<p>View和Model间之间的交互，一般有两种编码风格：双向的API调用、单向的API调用+回调：</p> 
<p><em>注意：以下两图并未体现Controller和Presenter细节，仅表意，从View层出发的API调用和回到View层的UI更新</em></p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-raPCbsF1-1661322561056)(https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a48429062dc0450689ffe61248694d34~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<p>双向API调用如上图。</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jinHZxl2-1661322561056)(https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5795fa2dbe0643a1a21cddc6bdd59824~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<p>单向API调用+回调更新UI如上图。</p> 
<p>显而易见，这两种方式无法继续抽象，需根据实际业务进行命令式编码。当UI复杂时，难以写出清晰、易读的代码，维护难度激增。</p> 
<h3>
<a id="MVVMUI_141"></a>MVVM解决UI更新代码混乱问题</h3> 
<p>前文我们已经提到：MVVM中通过绑定框架，将UI事件转化为数据变化，驱动业务；业务结果表现为数据变化，驱动UI更新。</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6i929K10-1661322561057)(https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7a30f35aafe41a7bee581ba03363114~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<p>显而易见，<strong>维护朴素的数据要比直接维护复杂的UI要简单</strong>。</p> 
<p>但问题也同时产生，data1的变化有两个可能的原因：</p> 
<ul>
<li>Model层业务结果使其变化，并期望它驱动UI更新</li>
<li>View层发生事件，反馈数据变化，并期望它驱动Model层逻辑</li>
</ul> 
<p>因此，框架需要考虑标识数据变化来源、或者其他手段消除方向性所带来的问题。</p> 
<p>并且MVVM难以灵活决定的 “何时调用Model层逻辑”，即大多数业务中，都需要结合多个属性的变化形成组合条件来驱动Model层逻辑。</p> 
<p><strong>本篇并不重点讨论MVVM，故不再展开MVVM解决循环更新的方案，以及衍生的问题。</strong></p> 
<p>尽管如此，MVVM中的数据绑定依旧解决了View层更新繁杂的问题。</p> 
<h3>
<a id="IntentModel_162"></a>用Intent灵活决定何时调用Model</h3> 
<p>既然数据驱动UI有极大的益处，且View层事件驱动ViewModel的数据变化有很多弊端 <em>（需要建立很高的复杂度）</em> ，那自然需要 <strong>趋利避害</strong></p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-574JyZra-1661322561058)(https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/751562b00d3b418cbe28fa793442967d~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<p>仅保留数据驱动UI的部分，并增加Intent用以驱动Model层业务</p> 
<p>在于 <code>MVC/MVP</code> 以及 <code>MVVM</code> 对比后不难得出结论：</p> 
<ul>
<li>MVC/MVP中，View层通过调用C/P层API的方式最终调用到Model层业务，方式质朴、无难度。但业务量规模增大后接口方法数也会增多，导致C/P层尾大不掉，难以重用。</li>
<li>MVVM中，VM层总是需要利用 <code>技巧</code> 进行模型概念转换，以满足业务响应满足实际需求，需要很深厚的设计经验才能写出非常优秀的代码，这并不友好。</li>
</ul> 
<p><em>作者按：我个人认为一个友好的设计，不应当剑走偏锋，而应当大巧不工，能够以力破法，达成 “使用者只需要吃透理论就可以解决各类问题” 的目标。</em></p> 
<p>而MVI在架构角色中设计了Intent的角色：</p> 
<ul>
<li>它包含了业务调用的意图和数据</li>
<li>从设计上可满足 <code>调用</code> 与 <code>实现</code> 的分离</li>
<li>架构模型中以Intent流的形式出现，下游对其的 <code>筛选</code> 、<code>转换</code> 、 <code>消费</code> 等行为可遵循 <code>FP范式</code> <em>（即函数式编程范式、Functional Programming Patterns）</em> ，逻辑的复用粒度为方法级，复用度更高更灵活</li>
<li>解决了MVVM中的方向性问题、MVC/MVP 中的灵活度问题等</li>
</ul> 
<h2>
<a id="_185"></a>单一可信数据源</h2> 
<p>我猜测读者诸君都曾听过这个词，将 <code>单一可信数据源</code> 拆解一下：</p> 
<ul>
<li>单一</li>
<li>可信</li>
<li>数据源</li>
</ul> 
<p>在MVI背景下，<code>数据源</code> 指的是视图对应的数据实体，它代表视图的内容状态。</p> 
<p>可信指从数据源中获取的数据是 <code>最新的</code>、<code>完整的</code>、<code>可靠的</code>，否则是不可信的，<em>我们没有理由在编码中使用不可信的数据源</em>。</p> 
<p>单一是指这样的数据源仅一个。</p> 
<p>在经典设计中，其内涵如下图:</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-701xDWl6-1661322561058)(https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aaddb2c9d634584b7280e648ea1faf0~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<ul>
<li>按照视图的 <strong>所有的</strong> 内容状态，定义一个不可变的 <code>ViewState</code>
</li>
<li>按照业务初始化 ViewState 实例</li>
<li>Model业务生成驱动 ViewState变化的Result</li>
<li>计算出新状态，Reduce(Pre-ViewState,Result) -&gt; New-ViewState</li>
<li>更新数据源</li>
<li>View层消费ViewState</li>
</ul> 
<p>借助于数据绑定框架，可以很方便地解决视图更新的问题。</p> 
<blockquote> 
 <p>想象一下，此时页面UI非常复杂……<br> <img src="https://images2.imgbox.com/a1/39/vY6eYFWH_o.png" alt=""></p> 
</blockquote> 
<p>如果僵化的信奉这样的 <code>单一</code> ，情况会如何呢？</p> 
<ul>
<li>复杂（大量属性）的ViewState</li>
<li>复杂的UI更新计算，<em>e.g. 100个属性变了2个，依然需要计算98个属性未变或者全量强制更新</em>
</li>
</ul> 
<p>在 APP-A和APP-B中，我分别使用了 DataBinding和Compose，但均无法避免该问题。</p> 
<h3>
<a id="_222"></a>何为单一</h3> 
<p>从机器执行程序的原理上看，我们无法实现 <strong>多个内容一致的数据源</strong> 在 <strong>任意时刻</strong> 满足 <code>最新的</code>、<code>可靠的</code>。</p> 
<p>将视图视为一个整体，规定它只拥有 <strong>一个</strong> 可信的数据源。在此基础上看局部的视图，它们也顺其自然地仅拥有一个可信的数据源。</p> 
<p>反过来看，当任意的局部视图仅具有一个可信数据源时，整体视图也仅有一个逻辑上的可信数据源。</p> 
<p>据此，我们可以对 <code>经典MVI实现</code> 进行一定程度的改造，将ViewState进行局部分解，使得UI绑定部分的业务逻辑更 <strong>清晰、干净</strong>。</p> 
<p><em>请注意，复杂度不会凭空消失，我们为了让 “UI绑定的业务逻辑更清晰、干净”、“更新UI的计算量更少”，将复杂度转移到了ViewState的拆分。拆分后，将具有 <strong>多个视图部件的单一可信数据源</strong>，注意，为了不引起额外的麻烦、并且便于维护扩展，建议遵守以下条件：</em></p> 
<ul>
<li>基于业务需求，组合数据源形成新数据源</li>
<li>不在数据源的逻辑范围之外进行数据源组合操作</li>
</ul> 
<blockquote> 
 <p>举个虚拟的例子：用户需要实名认证 且 关注博主 ，才在界面上显示某功能按钮。下面使用代码分别演示。</p> 
</blockquote> 
<p><em>考虑到RxJava的广泛度依旧高于Kotlin-Coroutine+flow，数据流的实现采用RxJava</em></p> 
<p><em>注意，考虑到读者可能会编写demo做UDF局部的验证，下文中的代码以示例目的为主，兼顾编写场景冒烟的方便性，流的类型不一定是构建完整UDF的最佳选择。</em></p> 
<h4>
<a id="_243"></a>经典实现</h4> 
<p>在经典MVI实现中，需要先定义ViewState</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">ViewState</span><span class="token punctuation">(</span>
    <span class="token comment">/*unique id of current login user*/</span>
    <span class="token keyword">val</span> userId<span class="token operator">:</span> Int<span class="token punctuation">,</span>
    <span class="token comment">/*true if the current login user has complete real-name verified*/</span>
    <span class="token keyword">val</span> realNameVerified<span class="token operator">:</span> Boolean<span class="token punctuation">,</span>
    <span class="token comment">/*true if the current login user has followed the author*/</span>
    <span class="token keyword">val</span> hasFollowAuthor<span class="token operator">:</span> Boolean
<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>并定义ViewModel，创建ViewState流，忽略掉其初始化和其他部分</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> VM <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> viewState <span class="token operator">=</span> BehaviorSubject<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>ViewState<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">//ignore</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>并定义View层，忽略掉其他部分，简单起见暂时不使用数据绑定框架</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> View <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">val</span> vm <span class="token operator">=</span> <span class="token function">VM</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> imgRealNameVerified<span class="token operator">:</span> ImageView
    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> cbHasFollowAuthor<span class="token operator">:</span> CheckBox
    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> someButton<span class="token operator">:</span> Button

    <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//ignore view initialize</span>

        vm<span class="token punctuation">.</span>viewState<span class="token punctuation">.</span><span class="token function">subscribe</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">render</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">render</span><span class="token punctuation">(</span>state<span class="token operator">:</span> ViewState<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        imgRealNameVerified<span class="token punctuation">.</span>isVisible <span class="token operator">=</span> state<span class="token punctuation">.</span>realNameVerified
        cbHasFollowAuthor<span class="token punctuation">.</span>isChecked <span class="token operator">=</span> state<span class="token punctuation">.</span>hasFollowAuthor
        someButton<span class="token punctuation">.</span>isVisible <span class="token operator">=</span> state<span class="token punctuation">.</span>realNameVerified <span class="token operator">&amp;&amp;</span> state<span class="token punctuation">.</span>hasFollowAuthor

        <span class="token comment">//ignore other</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在JS中，JSON并不能附加逻辑，基本等价于Java中的POJO，故在数据源外部处理简单逻辑的情况较为常见。而在Java、Kotlin中可以进行适当的优化，适当封装，使得代码更加干净便于维护：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">ViewState</span><span class="token punctuation">(</span>
    <span class="token comment">//ignore</span>
<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fun</span> <span class="token function">isSomeFuncEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>Boolean <span class="token operator">=</span> realNameVerified <span class="token operator">&amp;&amp;</span> hasFollowAuthor
<span class="token punctuation">}</span>

<span class="token keyword">class</span> View <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//ignore</span>
    
    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">render</span><span class="token punctuation">(</span>state<span class="token operator">:</span> ViewState<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//...</span>
        
        someButton<span class="token punctuation">.</span>isVisible <span class="token operator">=</span> state<span class="token punctuation">.</span><span class="token function">isSomeFuncEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4>
<a id="_316"></a>拆分实现</h4> 
<p>依旧先定义逻辑上完整的ViewState：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">ComposedViewState</span><span class="token punctuation">(</span>
    <span class="token comment">/*unique id of current login user*/</span>
    <span class="token keyword">val</span> userId<span class="token operator">:</span> Int<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * real-name-verified observable subject,feed true if the current login user has complete real-name verified
     * */</span>
    <span class="token keyword">val</span> realNameVerified <span class="token operator">=</span> BehaviorSubject<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>Boolean<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">/**
     * follow-author observable subject, feed true if the current login user has followed the author
     * */</span>
    <span class="token keyword">val</span> hasFollowAuthor <span class="token operator">=</span> BehaviorSubject<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>Boolean<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">val</span> someFuncEnabled <span class="token operator">=</span> BehaviorSubject<span class="token punctuation">.</span><span class="token function">combineLatest</span><span class="token punctuation">(</span>realNameVerified<span class="token punctuation">,</span> hasFollowAuthor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> a<span class="token punctuation">,</span> b <span class="token operator">-&gt;</span> a <span class="token operator">&amp;&amp;</span> b <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>定义ViewModel，子模块数据流均已定义，故而无需再定义全ViewState的流</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">VM</span><span class="token punctuation">(</span><span class="token keyword">val</span> userId<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> viewState <span class="token operator">=</span> <span class="token function">ComposedViewState</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span>
    <span class="token comment">//ignore</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编写View层的UI绑定，同样简单起见，不使用数据绑定框架</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> View <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">val</span> vm <span class="token operator">=</span> <span class="token function">VM</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> imgRealNameVerified<span class="token operator">:</span> ImageView
    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> cbHasFollowAuthor<span class="token operator">:</span> CheckBox
    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> someButton<span class="token operator">:</span> Button

    <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//ignore view initialize</span>
        <span class="token function">bindViewStateWithUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">bindViewStateWithUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vm<span class="token punctuation">.</span>viewState<span class="token punctuation">.</span>realNameVerified<span class="token punctuation">.</span><span class="token function">subscribe</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">renderSection1</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        vm<span class="token punctuation">.</span>viewState<span class="token punctuation">.</span>hasFollowAuthor<span class="token punctuation">.</span><span class="token function">subscribe</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">renderSection2</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        vm<span class="token punctuation">.</span>viewState<span class="token punctuation">.</span>someFuncEnabled<span class="token punctuation">.</span><span class="token function">subscribe</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">renderSection3</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//...</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">renderSection1</span><span class="token punctuation">(</span>foo<span class="token operator">:</span>Boolean<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        imgRealNameVerified<span class="token punctuation">.</span>isVisible <span class="token operator">=</span> foo
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">renderSection2</span><span class="token punctuation">(</span>foo<span class="token operator">:</span>Boolean<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cbHasFollowAuthor<span class="token punctuation">.</span>isChecked <span class="token operator">=</span> foo
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">renderSection3</span><span class="token punctuation">(</span>foo<span class="token operator">:</span>Boolean<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        someButton<span class="token punctuation">.</span>isVisible <span class="token operator">=</span> foo
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>例子较为简单，在实际项目中，如果遇到复杂页面，则可以分块进行处理。</p> 
<p><em>注意：实际情况中，并没有必要将每一个子数据源拆分到一个View级别的控件，那样过于啰嗦，例子因非常简单而无法丰满起来。<br> e.g. 针对每一块视图区，例如作者区域，定义子ViewState类，创建其数据流即可。</em></p> 
<blockquote> 
 <p>作者按：务必评估，在一次Model业务产生的Result中，会引起数据流下游的更新次数。<br> 为避免产生不可预期的问题，可通过类似以下方式，使下游响应次数表现和经典实现的情况一致。</p> 
</blockquote> 
<p>额外定义PartialChange流或者功能等价的流，它用于标识 <code>reduce</code> 计算的开始和结束，可以将此期间的数据流的变化延迟到最后发送终态</p> 
<p><em>更加推荐定义功能上等价的流</em></p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">ComposedViewState</span><span class="token punctuation">(</span>
    <span class="token comment">/*unique id of current login user*/</span>
    <span class="token keyword">val</span> userId<span class="token operator">:</span> Int<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">internal</span> <span class="token keyword">val</span> changes <span class="token operator">=</span> BehaviorSubject<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>PartialChange<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">//ignore</span>

    <span class="token keyword">val</span> someFuncEnabled <span class="token operator">=</span>
        BehaviorSubject<span class="token punctuation">.</span><span class="token function">combineLatest</span><span class="token punctuation">(</span>realNameVerified<span class="token punctuation">,</span> hasFollowAuthor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> a<span class="token punctuation">,</span> b <span class="token operator">-&gt;</span> a <span class="token operator">&amp;&amp;</span> b <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span>PartialChange<span class="token punctuation">.</span>Tag<span class="token punctuation">,</span> changes<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> T<span class="token punctuation">,</span> S<span class="token operator">&gt;</span> Observable<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span>tag<span class="token operator">:</span> S<span class="token punctuation">,</span> sync<span class="token operator">:</span> BehaviorSubject<span class="token operator">&lt;</span>S<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> BehaviorSubject<span class="token punctuation">.</span><span class="token function">combineLatest</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> sync<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> source<span class="token punctuation">,</span> syncItem <span class="token operator">-&gt;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>syncItem <span class="token operator">==</span> tag<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            syncItem
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            source
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{<!-- --></span> it <span class="token keyword">is</span> T <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>T<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>修改PartialChange，为reduce函数添加边界：</p> 
<p><em>PartialChange是Model产生的Result的表现物，封装了ViewState的reduce函数逻辑，即如何从 Pre-ViewState 生成 新 ViewState</em></p> 
<pre><code class="prism language-kotlin"><span class="token keyword">sealed</span> <span class="token keyword">class</span> PartialChange <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">reduce</span><span class="token punctuation">(</span>state<span class="token operator">:</span> ComposedViewState<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 同步标记，从头开始到真实PartialChange之间，流的状态生效
     * */</span>
    <span class="token keyword">object</span> Tag <span class="token operator">:</span> <span class="token function">PartialChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">object</span> None <span class="token operator">:</span> <span class="token function">PartialChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">class</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">val</span> a<span class="token operator">:</span> Boolean<span class="token punctuation">,</span> <span class="token keyword">val</span> b<span class="token operator">:</span> Boolean<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">PartialChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">reduce</span><span class="token punctuation">(</span>state<span class="token operator">:</span> ComposedViewState<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            state<span class="token punctuation">.</span>changes<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span>Tag<span class="token punctuation">)</span>
            state<span class="token punctuation">.</span>realNameVerified<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
            state<span class="token punctuation">.</span>hasFollowAuthor<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
            state<span class="token punctuation">.</span>changes<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="_457"></a>要想优雅，需要工具</h2> 
<h3>
<a id="_459"></a>采用响应式流，避免命令式编码</h3> 
<p>想来这一点已不需要多做解释。</p> 
<p>在Android中，存在 <code>LiveData</code> 组件，它通过简单的方式封装了可观测的数据，但实现方式简单也限制了它的功能 <strong>不够强大</strong> 。因此，建议使用 <code>RxJava</code> 或者 <code>Kotlin-Coroutine &amp; flow</code> 构建数据流。</p> 
<p>本节便不再展开。</p> 
<h3>
<a id="_467"></a>采用数据绑定框架</h3> 
<p>采用 <code>jetpack-compose</code> 或者 <code>DataBinding</code> 均可以移除枯燥的UI命令式逻辑，在APP-A中我使用了DataBinding，在APP-B中我使用了Compose。</p> 
<p>在 ViewState的代码很棒时，均可以获得优秀的编程体验，从啰嗦的UI中解放出来。</p> 
<blockquote> 
 <p>作者的个人观点:</p> 
 <p>关于Compose。Compose依旧属于较新的事物，在商业项目中使用存在学习门槛和造轮工作。在目标用户具有较高容忍度的情况下，已然可以进行尝试。</p> 
 <p>关于DataBinding。一个近乎毁誉参半的工具，关于它的批判，大多集中于：<strong>xml中实现的逻辑难以阅读、维护</strong>，这实际上是对DataBinding设计的误解而带来的错误使用。</p> 
 <p>DataBinding本身具有生成VM层的功能，但这一功能并不足够强大，且没有完善的使用指导，而在官方Demo中过度宣传了它，导致大家认为DataBinding就该这样使用。</p> 
 <p>仅使用基础的数据绑定功能、和Resource或者Context有关的功能（例如字符串模板）、组件生命周期绑定等，适度自定义绑定。</p> 
</blockquote> 
<h2>
<a id="_483"></a>何为状态、何为事件。最后的一公里</h2> 
<p>首先区别于上文提到的UI事件，这里的状态和事件均产生于数据流的末段，而UI事件处于数据流的首段。</p> 
<blockquote> 
 <p>UI事件属于：A possible action that the user can perform that is monitored by an application or the operating system (event listener). When an event occurs an event handler is called which performs a specific task</p> 
</blockquote> 
<p>在展开之前，先用一张图回顾总结上文中对于 <code>单向数据流</code> &amp; <code>单一可信数据源</code> 的知识</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-85qa2v8F-1661322561060)(https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c774951cc97a4e5684b4e092ea95e61e~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<p>在 <strong>单向数据流动</strong> 章节中，提到了MVI的UDF设计：</p> 
<ul>
<li>系统捕获的UI事件、其他侦听事件（例如熄屏、应用生命周期事件），生成Intent，压入Intent流中</li>
<li>ViewModel层中筛选、转换、处理Intent，实际是使用Model层业务，产生业务结果，即PartialChange</li>
<li>PartialChange经过Reducer计算处理得到最新的ViewState，压入ViewState流</li>
<li>View层（广义的表现层）响应并呈现最新的ViewState</li>
</ul> 
<p>在 <strong>单一可信数据源</strong> 章节中，提到View层应当采用 <code>单一可信数据源</code></p> 
<p>在这张图中，我们仅体现了 <code>状态</code> 即 ViewState。</p> 
<h3>
<a id="GUI_504"></a>关于GUI程序的认知</h3> 
<p>在展开前，先聊点理念上的内容。请读者诸君思考下自己对于GUI程序的认知。</p> 
<blockquote> 
 <p>作者的理解：</p> 
 <p>程序狭义上是计算机能识别和执行的一组指令集，编程工作是在程序世界对 <code>客观实体</code> 、 <code>业务逻辑</code> 进行 建模和逻辑表达。</p> 
 <p>而GUI程序拥有 <code>用户图形界面</code> , 除了结合硬件接收用户交互输入外，可以将 <code>程序世界中的模型</code> 以 <code>用户图形界面</code> 等方式表现给用户。</p> 
 <p>表现出来的内容代表着客观实体</p> 
 <p>其本质目的在于：通过 <strong>描述特征属性</strong> 、 <strong>描述变化过程</strong> 等方式让用户感知并理解 <code>客观实体</code></p> 
</blockquote> 
<p>而除了通过 <strong>程序语言描述</strong> 、 <strong>程序世界模拟展现</strong> 外，同样可以通过 <strong>自然语言描述</strong> 达到目的，这也是产品经理的工作。</p> 
<p><em>当然，产品经理往往需要借助一些工具来提升自己的自然语言表达能力，但无奈的是能用数学公式和逻辑推演表达需求的产品经理太少见了。</em></p> 
<p>写这段只是为了引入 <code>他山之石</code> 。</p> 
<h3>
<a id="FirstOrder_logic_524"></a>First-Order logic</h3> 
<p>在数学、哲学、语言学、计算机科学中，有一个概念 <code>First-Order logic</code>，无论是产品需求还是计算机程序，<strong>都可以建立FOL表达</strong>。</p> 
<p><em>当然，本篇不讨论FOL，那是一个很庞大且偏离主题的事情。我仅仅是想借用其中的概念。</em></p> 
<p>FOL表达 Event或者State时：</p> 
<ul>
<li>Event 体现的是特定的变化</li>
<li>State 体现的是客观实体在任意时刻都适用的一组情况，即一段时间内无变化的条件或者特征</li>
</ul> 
<p>不难理解，变化是瞬时的，连续的变化是可分的。</p> 
<p>但在人机交互中，瞬时意义很小，我们的目的在于让用户感知。</p> 
<p>例如：“好友向你发送了一条消息的场景中”，消息抵达就是Event，它背后潜藏着 “消息数的变化”、“最新消息内容的变化” 等。 在常见的设计中:</p> 
<ul>
<li>应用需要弹出一个气泡通知用户这一事件</li>
<li>应用需要更新消息数，消息列表内容等，以呈现出最新的State</li>
</ul> 
<p>而为了让用户感知到，气泡呈现时长并不是瞬时的，但在产品交互设计中依旧将其定义为事件。</p> 
<h3>
<a id="_546"></a>分离状态和事件，不是吃饱撑得</h3> 
<blockquote> 
 <p>看山是山、看水是水</p> 
</blockquote> 
<p>此时此刻，答案已经很明显。</p> 
<p>在通用的产品设计中，状态和事件有不同的意义，如果程序中不分离出两者，则必然是自找麻烦，这是公然挑衅 <code>面向对象编程</code> 的行为。如果不明确定义不同的Class，则势必导致代码混乱不堪，毕竟这是违背编程原则的事情。</p> 
<p>在大多MVVM设计中，状态和事件未分家，导致bug丛生，这一点便不再展开。</p> 
<h3>
<a id="EventState_556"></a>如何区分Event和State</h3> 
<p>State是一段时间内无变化的条件或者特征，它天然的 <strong>契合</strong> 了位于表现层的主体内容所对应的 <strong>数据模型特征</strong>。</p> 
<p>Event是特定的变化，它在表现层体现，但与State的生命周期不一致，且并无一一对应的关系。</p> 
<p>基于经验主义，我们可以机械地、笼统地认为：页面主体静态内容所需要的数据属于State范畴，气泡提醒等短暂的物体所需要的数据属于Event范畴。</p> 
<p>从逻辑推演的角度出发，进行 <strong>等价逻辑推断</strong> 和 <strong>条件限定下的逻辑推断</strong> ，一定序列的Event可以模型转换为State。</p> 
<h3>
<a id="bug_566"></a>事件粘性导致重复？只是框架设计的bug</h3> 
<blockquote> 
 <p>看山不是山，看水不是水</p> 
</blockquote> 
<p>前面提到，State是一段时间内无变化的条件或者特征，所以在程序设计中State具有粘性的特征。</p> 
<p>如果Event也设计出这样的粘性特征并造成重复消费，明显是违背需求的，无疑是框架设计的Bug。此问题在各大论坛中很常见。</p> 
<p><em>注意，我们无法脱离实际需求去二元化的讨论事件本身该不该有粘性特征，只能结合实际讨论框架功能是否存在bug</em></p> 
<p>如果要实现以力破法，在框架设计层面上 <strong>Event体系的设计要比State体系要复杂</strong> 。因为从交互设计上：</p> 
<ul>
<li>State 只需要考虑呈现的准确性和及时性，<em>除去美观、可理解性等等</em>
</li>
<li>Event 需要考虑准确性、优先级、及时性、按条件丢弃等等，<em>除去美观、可理解性等等</em>
</li>
</ul> 
<p>举个例子：网络连接问题导致的Web-API调用失败需要使用Toast提示网络连接失败</p> 
<p>不难想象：</p> 
<ul>
<li>可能一瞬间的断开网络连接，会导致多个连接均返回失败</li>
<li>可能连接问题未修复，10秒前请求失败，当前请求又失败了</li>
</ul> 
<p>难道连续弹出吗？难道和上一次Event一致就不消费吗？…</p> 
<p>或许您会使用一些 <code>剑走偏锋的技巧</code> 来解决问题，但技巧总是建立在特定条件下生效的，一旦条件发生变化，就会带来烦恼，您很难控制上游的PM和交互设计师。</p> 
<p>所以在框架层面需要针对产品、交互设计的泛化理念，设计准确的、灵活的Event体系。</p> 
<h3>
<a id="Event_595"></a>准确的、灵活的Event体系</h3> 
<blockquote> 
 <p>看山还是山，看水还是水</p> 
</blockquote> 
<p>回到FOL中，为了更加准确的表达Event和State的含义，还需要一些额外的参数，例如：<code>参与者</code>、<code>地点</code>、<code>时间</code> 等。</p> 
<p>想通这一点会发现，产品中定义的Event事件、及其消费逻辑均含有隐藏属性，例如：</p> 
<ul>
<li>发生时间</li>
<li>客观有效期</li>
<li>判断有效的条件（如呈现的条件）</li>
<li>判断失效的条件 ，用于实现提前失效</li>
</ul> 
<p><em>产品经理和交互设计师一般会使用 “响应时间”、“优先级” 等词描述它们，但一般不严谨、不成体系，带来期望不一致的问题</em></p> 
<p>反观State流，它代表了界面主体内容在时间轴上的完整变化，任意一个时间点均可以得出界面内容所对应的条件和特征。一旦State流中出现一个新的状态，它均被及时的、准确的在表现层予以体现。</p> 
<p>不难理解，一个State的生命周期为 <code>从init或者reducer计算生成开始</code> 至 <code>reducer计算出新State、宿主生命期结束为止</code>，在State流中已然暗含：</p> 
<ul>
<li>State之间无生命周期重叠</li>
<li>所有State的生命周期相加可填满时间轴</li>
</ul> 
<blockquote> 
 <p>前文提到Event是瞬时的，所以Event本身并没有实质意义上的生命周期，为了方便表述，我们将 “Event从生成到在表现层不可观测的阶段” 定义为Event生命周期</p> 
</blockquote> 
<p>而Event流 <strong>不同于</strong> State流 ，因为Event的生命周期情况更加复杂：</p> 
<ul>
<li>Event可能存在生命周期重叠</li>
<li>所有Event的生命周期相加可能无法覆盖完整的时间轴</li>
</ul> 
<p><strong>需要额外设计实现</strong> 。实现这一点后，从Event流中分流（以及裂变+组合）出的 <strong>子流</strong> 将和State流 <strong>性质一致</strong>。</p> 
<p>此刻，您会发现，根据不同类型的事件交互控件所对应的交互特征，又将Event流结合条件流衍生出各个State流。完整的数据流细节如下：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TKMSoGoK-1661322561061)(https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccba63aa47a340eaad4bb90e59f812be~tplv-k3u1fbpfcp-watermark.image?)]</p> 
<p><em>作者按：在图中省略了Event分流转变为子State流的过程，因为它需要遵循特定产品交互机制</em></p> 
<h2>
<a id="_632"></a>结语</h2> 
<p>这篇文章，从5月计划写，到6月动笔，断断续续，草稿写了很长，几经删改依旧留有很长的篇幅，虽已竭力尽智，但任觉文字上有表意未通透之处，欢迎在评论区讨论。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>