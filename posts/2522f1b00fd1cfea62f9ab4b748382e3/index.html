<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C&#43;&#43;】智能指针 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】智能指针</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-tomorrow-night">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>文章目录</h3> 
 <ul>
<li><a href="#1__1">1. 为什么需要智能指针</a></li>
<li><a href="#2_7">2.内存泄露</a></li>
<li>
<ul><li>
<ul>
<li><a href="#_9">什么是内存泄漏</a></li>
<li><a href="#_89">内存泄漏的危害</a></li>
<li><a href="#_109">内存泄漏分类</a></li>
<li><a href="#_124">如何避免内存泄漏</a></li>
</ul> 
  </li></ul> 
  </li>
<li><a href="#3_146">3.智能指针的使用及原理</a></li>
<li>
<ul>
<li><a href="#RAII_148">RAII</a></li>
<li>
<ul><li><a href="#_159">模拟实现</a></li></ul> 
   </li>
<li><a href="#_253">总结一下智能指针的原理：</a></li>
<li><a href="#stdauto_ptr_294">std::auto_ptr</a></li>
<li>
<ul><li><a href="#_320">模拟实现</a></li></ul> 
   </li>
<li><a href="#stdunique_ptr_391">std::unique_ptr</a></li>
<li>
<ul><li><a href="#_403">模拟实现</a></li></ul> 
   </li>
<li><a href="#stdshared_ptr_461">std::shared_ptr</a></li>
<li>
<ul>
<li><a href="#_492">模拟实现</a></li>
<li><a href="#_616">关于引用变量的位置</a></li>
<li><a href="#_646">线程安全问题</a></li>
<li>
<ul><li><a href="#_698">模拟实现改进</a></li></ul> 
    </li>
<li><a href="#shared_ptr_932">shared_ptr的循环引用问题</a></li>
</ul> 
   </li>
<li><a href="#stdweak_ptr_1032">std::weak_ptr</a></li>
<li>
<ul>
<li><a href="#_1034">解决循环引用问题</a></li>
<li><a href="#_1087">模拟实现</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#4_1132">4.定制删除器</a></li>
<li><a href="#5C11boost_1461">5.C++11和boost中智能指针的关系</a></li>
</ul> 
</div> 
<p></p> 
<h1>
<a id="1__1"></a>1. 为什么需要智能指针</h1> 
<p>程序员自己控制的内存,在一些特殊场景之下,有可能发生内存泄漏,智能指针则可以帮助对内存进行管理比如程序员忘记释放内存,发生异常安全问题（因为抛异常会影响执行流）,可能会导致内存泄漏</p> 
<hr> 
<h1>
<a id="2_7"></a>2.内存泄露</h1> 
<h3>
<a id="_9"></a>什么是内存泄漏</h3> 
<p>内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况,内存泄漏并不是指内存在物理上的消失,而是应用程序分配某段内存后,因为设计错误,失去了对该段内存的控制,因而造成了内存的浪费</p> 
<blockquote> 
 <p>例如：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"除0错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行上述代码时,如果用户输入的除数为0.那么div函数中就会抛出异常,这时程序的执行流会直接跳转到主函数中的catch块中执行,最终导致func函数中申请的内存资源没有得到释放</p> 
<blockquote> 
 <p>做法:利用异常的重新捕获解决</p> 
</blockquote> 
<p>对于这种情况,我们可以在func函数中先对div函数中抛出的异常进行捕获,捕获后先将之前申请的内存资源释放,然后再将异常重新抛出,但是这种方式并没有从根源上解决问题, 比如</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"除0错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
		<span class="token keyword">throw</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3>
<a id="_89"></a>内存泄漏的危害</h3> 
<p>内存泄漏的危害：长期运行的程序出现内存泄漏,影响很大,如操作系统、后台服务等等,出现内存泄漏会导致响应越来越慢,最终卡死</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">MemoryLeaks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 1.内存申请了忘记释放</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 2.可能存在异常安全问题</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果这里Func函数抛异常,会导致delete[] p3未执行,导致p3没被释放.</span>
    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3>
<a id="_109"></a>内存泄漏分类</h3> 
<p>C/C++程序中一般我们关心两种方面的内存泄漏：</p> 
<p>1)堆内存泄漏(Heap leak)</p> 
<ul>
<li>堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存,用完后必须通过调用相应的 free或者delete 删掉</li>
<li>假设程序的设计错误导致这部分内存没有被释放,那么以后这部分空间将无法再被使用,就会产生Heap Leak</li>
</ul> 
<p>2)系统资源泄漏</p> 
<ul><li>指程序使用系统分配的资源,比如: 套接字、文件描述符、管道等没有使用对应的函数释放掉,导致系统资源的浪费,严重可导致系统效能减少,系统执行不稳定</li></ul> 
<hr> 
<h3>
<a id="_124"></a>如何避免内存泄漏</h3> 
<p>1)工程前期良好的设计规范,养成良好的编码规范,申请的内存空间记着匹配的去释放</p> 
<ul><li>ps：这个是理想状态 但是如果碰上异常时,就算注意释放了还是可能会出问题,需要智能指针来管理才有保证</li></ul> 
<p>2)采用RAII思想或者智能指针来管理资源</p> 
<p>3)有些公司内部规范使用内部实现的私有内存管理库,这套库自带内存泄漏检测的功能选项</p> 
<p>4)出问题了使用内存泄漏工具检测 ps：不过很多工具都不够靠谱,或者收费昂贵</p> 
<hr> 
<p>总结一下:内存泄漏非常常见,解决方案分为两种：</p> 
<p>1、事前预防型,如智能指针等</p> 
<p>2、事后查错型,如泄漏检测工具</p> 
<hr> 
<h1>
<a id="3_146"></a>3.智能指针的使用及原理</h1> 
<h2>
<a id="RAII_148"></a>RAII</h2> 
<p>RAII（Resource Acquisition Is Initialization）是一种<strong>利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术</strong>, <strong>在对象构造时获取资源</strong>,接着控制对资源的访问使之在对象的生命周期内始终保持有效,<strong>最后在对象析构的时候释放资源</strong></p> 
<p>借此,我们实际上把管理一份资源的责任托管给了一个对象,这种做法有两大好处:</p> 
<ul>
<li>不需要显式地释放资源</li>
<li>采用这种方式,对象所需的资源在其生命期内始终保持有效</li>
</ul> 
<hr> 
<h3>
<a id="_159"></a>模拟实现</h3> 
<blockquote> 
 <p>使用RAII思想设计的SmartPtr类</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">// 使用RAII思想设计的SmartPtr类</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SmartPtr</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">SmartPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token comment">//重载operator-&gt;和operator* 像指针一样使用</span>
	T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">*</span>_ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> _ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token keyword">delete</span> _ptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span>	<span class="token comment">//管理一个指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>上述问题也可以使用智能指针进行解决.比如：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"除0错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//invalid_argument是标准库的异常,用exception捕获</span>

	<span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SmartPtr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	SmartPtr<span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    <span class="token comment">//像指针一样使用</span>
	<span class="token operator">*</span>sp1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//10</span>
	sp2<span class="token operator">-&gt;</span>_day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	sp2<span class="token operator">-&gt;</span>_year <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	sp2<span class="token operator">-&gt;</span>_month<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> sp2<span class="token operator">-&gt;</span>_year <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> sp2<span class="token operator">-&gt;</span>_month <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> sp2<span class="token operator">-&gt;</span>_day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//无论是否抛异常,都能正确释放空间资源</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//func可能抛异常</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">const</span> exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//打印抛了什么异常  what:发生了什么</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2d/6a/mpIomiVQ_o.png" alt="image-20220801203155874"></p> 
<p>代码中将申请到的内存空间交给了一个SmartPtr对象进行管理</p> 
<ul>
<li>在构造SmartPtr对象时,SmartPtr将传入的需要被管理的内存空间保存起来.</li>
<li>在SmartPtr对象析构时,SmartPtr的析构函数中会自动将管理的内存空间进行释放.</li>
<li>此外.为了让SmartPtr对象能够像原生指针一样使用,还需要对<code>*</code>和<code>-&gt;</code>运算符进行重载</li>
</ul> 
<p>无论程序是正常执行完毕返回了,还是因为某些原因中途返回了,或是因为抛异常返回了,只要SmartPtr对象的生命周期结束就会调用其对应的析构函数,进而完成内存资源的释放</p> 
<hr> 
<h2>
<a id="_253"></a>总结一下智能指针的原理：</h2> 
<p>实现智能指针时需要考虑以下三个方面的问题：</p> 
<ol>
<li>在对象构造时获取资源.在对象析构的时候释放资源,利用对象的生命周期来控制程序资源.即RAII特性.</li>
<li>对<code>*</code>和<code>-&gt;</code>运算符进行重载,使得该对象具有像指针一样的行为</li>
<li>智能指针对象的拷贝问题.</li>
</ol> 
<hr> 
<blockquote> 
 <p>为什么要解决智能指针对象的拷贝问题</p> 
</blockquote> 
<p>对于当前实现的SmartPtr类,如果用一个SmartPtr对象来拷贝构造另一个SmartPtr对象,或是将一个SmartPtr对象赋值给另一个SmartPtr对象,都会导致程序崩溃</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SmartPtr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//拷贝构造</span>
	SmartPtr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sp3<span class="token punctuation">;</span>
	sp3 <span class="token operator">=</span> sp1<span class="token punctuation">;</span>
	<span class="token comment">//赋值重载</span>
	SmartPtr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sp2  <span class="token operator">=</span> sp1<span class="token punctuation">;</span> 

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/07/b8/4QCzCbTj_o.png" alt="image-20220801203437016"></p> 
<ul>
<li>编译器默认生成的拷贝构造函数对内置类型完成值拷贝（浅拷贝）,因此用sp1拷贝构造sp2后,相当于这sp1和sp2管理了同一块内存空间,<strong>当sp1和sp2析构时就会导致这块空间被释放两次</strong>
</li>
<li>编译器默认生成的拷贝赋值函数对内置类型也是完成值拷贝（浅拷贝）,因此将sp4赋值给sp3后,相当于sp3和sp4管理的都是原来sp3管理的空间,当sp3和sp4析构时就会导致这块空间被释放两次,并且还会导致sp4原来管理的空间没有得到释放</li>
</ul> 
<hr> 
<p>需要注意的是,智能指针就是要模拟原生指针的行为,<strong>当我们将一个指针赋值给另一个指针时,目的就是让这两个指针指向同一块内存空间,所以这里本就应该进行浅拷贝</strong>,但单纯的浅拷贝又会导致空间被多次释放,因此根据解决智能指针拷贝问题方式的不同,从而衍生出了不同版本的智能指针</p> 
<hr> 
<p>C++库中的智能指针都定义在memory头文件中</p> 
<h2>
<a id="stdauto_ptr_294"></a>std::auto_ptr</h2> 
<blockquote> 
 <p>管理权转移</p> 
</blockquote> 
<p>auto_ptr是C++98中引入的智能指针,通过管理权转移的方式解决智能指针的拷贝问题,保证一个资源在任何时刻都只有一个对象在对其进行管理,这时同一个资源就不会被多次释放了</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//auto_ptr的问题：当对象拷贝或者赋值后,前面的对象就悬空了</span>
	auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span>sp1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 管理权转移,sp1就变成空指针了</span>
	<span class="token operator">*</span>sp2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//10</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//崩溃,sp1已经变成空指针了！</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由于拷贝和赋值会<strong>导致资源管理权转移</strong>,一个对象的管理权转移后也就意味着该对象不能再用对原来管理的资源进行访问了,<strong>再次解引用访问这个资源就会造成对空指针的访问,程序就会崩溃</strong></p> 
<p>由于auto_ptr 的拷贝和赋值拷贝都会出现资源转移的情况,所以用的时候很容易出错,因此<strong>实际之中,一般不允许使用</strong></p> 
<hr> 
<h3>
<a id="_320"></a>模拟实现</h3> 
<blockquote> 
 <p>auto_ptr的模拟实现 实现原理：管理权转移的思想</p> 
</blockquote> 
<ol>
<li>在构造函数中获取资源,在析构函数中释放资源,利用对象的生命周期来控制资源.</li>
<li>对<code>*</code>和<code>-&gt;</code>运算符进行重载,使auto_ptr对象具有指针一样的行为.</li>
<li>在拷贝构造函数中,用传入对象管理的资源来构造当前对象,并将传入对象管理资源的指针置空.</li>
<li>在拷贝赋值函数中,先将当前对象管理的资源释放.然后再接管传入对象管理的资源.最后将传入对象管理资源的指针置空.</li>
</ol> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> Mango	<span class="token comment">//为了和库里面的做区分</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">auto_ptr</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">auto_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	
	<span class="token comment">//sp1(sp2)</span>
    <span class="token comment">// 一旦发生拷贝,就将sp中资源转移到当前对象中,然后另sp与其所管理资源断开联系</span>
    <span class="token comment">//这样就解决了一块空间被多个对象使用而造成程序奔溃问题,一块空间只关联一个对象</span>
	<span class="token function">auto_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> auto_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sp<span class="token punctuation">.</span>_ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//管理权转移,原来的对象悬空</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//sp1 = sp2</span>
	auto_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> auto_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>sp<span class="token punctuation">)</span><span class="token comment">//防止sp1 = sp1自己给自己赋值的情况</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//1.释放当前对象中资源</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span> <span class="token keyword">delete</span> _ptr<span class="token punctuation">;</span>
			<span class="token comment">//2.转移是sp中资源到当前对象中</span>
			_ptr <span class="token operator">=</span> sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">;</span>
			<span class="token comment">//3.原来的对象悬空</span>
			sp<span class="token punctuation">.</span>_ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 像指针一样使用</span>
	T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">*</span>_ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">auto_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> _ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">delete</span> _ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span><span class="token comment">//管理一个原生指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2>
<a id="stdunique_ptr_391"></a>std::unique_ptr</h2> 
<blockquote> 
 <p>防拷贝</p> 
</blockquote> 
<p>既然auto_ptr的拷贝和赋值会发生资源转移,那么unique_ptr:<strong>就禁止拷贝和赋值的发生</strong>,<strong>即在拷贝和赋值成员函数后面加上delete(C++11的处理方式)</strong></p> 
<blockquote> 
 <p>看库里面的:</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4d/48/WHDGMcYg_o.png" alt="image-20220801211810967"></p> 
<hr> 
<h3>
<a id="_403"></a>模拟实现</h3> 
<blockquote> 
 <p>unique_ptr的模拟实现 实现原理：<strong>简单粗暴的防拷贝</strong></p> 
</blockquote> 
<ol>
<li>在构造函数中获取资源,在析构函数中释放资源,利用对象的生命周期来控制资源.</li>
<li>对<code>*</code>和<code>-&gt;</code>运算符进行重载,使unique_ptr对象具有指针一样的行为.</li>
<li>用C++98的方式将拷贝构造函数和拷贝赋值函数声明为私有,或者用C++11的方式在这两个函数后面加上<code>=delete</code>, 防止外部进行拷贝和赋值</li>
</ol> 
<pre><code class="prism language-cpp"><span class="token comment">// unique_ptr/scoped_ptr   守卫指针！</span>
<span class="token comment">// 原理：简单粗暴 -- 防拷贝</span>
<span class="token keyword">namespace</span> Mango
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">unique_ptr</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">unique_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
			<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

		<span class="token operator">~</span><span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete:"</span> <span class="token operator">&lt;&lt;</span> _ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token keyword">delete</span> _ptr<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 像指针一样使用</span>
		T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">*</span>_ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//方法1: C++98防拷贝的方式：只声明不实现+声明成私有 </span>
		<span class="token comment">//方法2:用delete修饰	-C++11</span>
		unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
		<span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">//防止拷贝！</span>

	<span class="token keyword">private</span><span class="token operator">:</span>
		T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span>	<span class="token comment">//管理的资源</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p>缺陷: 如果有需要拷贝的场景,就无法使用了 <strong>需要拷贝场景怎么办？使用shared_ptr</strong></p> 
<hr> 
<h2>
<a id="stdshared_ptr_461"></a>std::shared_ptr</h2> 
<blockquote> 
 <p>引用计数</p> 
</blockquote> 
<p>auto_ptr 的拷贝和赋值存在不安全因素,unnique_ptr直接禁止了拷贝和赋值<strong>shared_ptr的原理：是通过<font color="red">引用计数</font>的方式来实现多个shared_ptr对象之间共享资源,解决智能指针的拷贝问题</strong></p> 
<blockquote> 
 <p>看看库里面的:</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sp2 <span class="token operator">=</span> sp1<span class="token punctuation">;</span><span class="token comment">//拷贝构造</span>
	<span class="token operator">*</span>sp2 <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//101</span>

	shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	sp1 <span class="token operator">=</span> sp3<span class="token punctuation">;</span><span class="token comment">//赋值</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp3<span class="token punctuation">;</span><span class="token comment">//20 101 20</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul>
<li>每一个被管理的资源都有一个对应的引用计数,通过这个引用计数记录着当前有多少个对象在管理着这块资源,</li>
<li>当新增一个对象管理这块资源时则将该资源对应的引用计数进行<code>++</code>,当一个对象不再管理这块资源或该对象被析构时则将该资源对应的引用计数进行<code>--</code>
</li>
<li>当一个资源的引用计数减为0时说明已经没有对象在管理这块资源了,这时就可以将该资源进行释放了</li>
</ul> 
<p>通过这种引用计数的方式就能支持多个对象一起管理某一个资源,也就是支持了智能指针的拷贝,并且只有当一个资源对应的引用计数减为0时才会释放资源,因此保证了同一个资源不会被释放多次</p> 
<hr> 
<h3>
<a id="_492"></a>模拟实现</h3> 
<blockquote> 
 <p>shared_ptr的模拟实现</p> 
</blockquote> 
<ol>
<li>在shared_ptr类中增加一个成员变量count，表示智能指针对象管理的资源对应的引用计数</li>
<li>在构造函数中获取资源.并将该资源对应的引用计数设置为1，表示当前只有一个对象在管理这个资源.</li>
<li>在拷贝构造函数中,与传入对象一起管理它管理的资源,同时将该资源对应的引用计数<code>++</code>.</li>
<li>在拷贝赋值函数中,先将当前对象管理的资源对应的引用计数<code>--</code>（如果减为0则需要释放）,然后再与传入对象一起管理它管理的资源,同时需要将该资源对应的引用计数<code>++</code>.</li>
<li>在析构函数中,将管理资源对应的引用计数<code>--</code>,如果减为0则需要将该资源释放.</li>
<li>对<code>*</code>和<code>-&gt;</code>运算符进行重载,使shared_ptr对象具有指针一样的行为.</li>
</ol> 
<hr> 
<p>总结起来就是:</p> 
<p>1)shared_ptr在其内部,<strong>给<code>每个资源</code>都维护了着一份计数空间</strong>,用来记录<strong>该份资源被几个对象共享</strong><br> 2)在<strong>对象被销毁时(也就是析构函数调用)</strong>,就说明自己不使用该资源了,对象的<strong>引用计数减一</strong><br> 3)如果引用计数是0,就说明<strong>自己是最后一个使用该资源的对象,必须释放该资源</strong><br> 4)<strong>如果引用计数不是0</strong>,就说明除了自己还有其他对象在使用该份资源,<strong>不能释放该资源</strong>,否则其他对象就成野指针</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> Mango
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">shared_ptr</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">shared_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>	<span class="token comment">//不能加const,否则赋值给_ptr相当于权限放大,报错</span>
		<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_pRefCount</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//构造的时候,该资源只被一个对象共享</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token comment">//拷贝构造 sp1(sp2)</span>
	<span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span>	
		<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">)</span><span class="token comment">//指向同一块资源</span>
		<span class="token punctuation">,</span><span class="token function">_pRefCount</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>_pRefCount<span class="token punctuation">)</span><span class="token comment">//指向同一个计数空间</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//_pRefCount:计数空间		*_pRefCount: 多少个对象共享这块空间(资源)</span>

		<span class="token punctuation">(</span><span class="token operator">*</span>_pRefCount<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//多了一个共享该资源的对象,计数++, </span>
	<span class="token punctuation">}</span>

	<span class="token comment">//赋值 sp1 = sp2</span>
	shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr <span class="token operator">!=</span> sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">)</span><span class="token comment">//判断是不是管理的同一份资源</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//1.现在_ptr要管理另外一份资源了,先处理原来资源的计数问题</span>
			<span class="token comment">//如果--之后为0,(注意是前置--) 说明_ptr是最后一个指向原来的资源的对象</span>
			<span class="token comment">//现在_ptr要指向新资源了,释放原来的资源和计数空间</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token operator">*</span>_pRefCount<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">delete</span> _ptr<span class="token punctuation">;</span>
				<span class="token keyword">delete</span> _pRefCount<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//2.赋值  共享管理新对象的资源,并增加引用计数</span>
			_ptr <span class="token operator">=</span> sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">;</span><span class="token comment">//指向新资源</span>
			_pRefCount <span class="token operator">=</span> sp<span class="token punctuation">.</span>_pRefCount<span class="token punctuation">;</span><span class="token comment">//指向同一个计数空间</span>
			<span class="token punctuation">(</span><span class="token operator">*</span>_pRefCount<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//多了一个指向该资源的对象, 计数++</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token comment">//获取引用计数</span>
    <span class="token keyword">int</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token operator">*</span>_pRefCount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//引用计数减1,如果减到0,说明自己是最后一个管理该资源的对象</span>
		<span class="token comment">//就释放这块资源和计数空间</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token operator">*</span>_pRefCount<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> _ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete:"</span> <span class="token operator">&lt;&lt;</span> _ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">delete</span> _ptr<span class="token punctuation">;</span>
			<span class="token keyword">delete</span> _pRefCount<span class="token punctuation">;</span>

			_ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
			_pRefCount <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//像指针一样使用</span>
	T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">*</span>_ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span>	<span class="token comment">//管理的资源</span>
	<span class="token comment">//引用计数,多少个指针指向这块空间,就说明该份资源被几个对象共享</span>
	<span class="token keyword">int</span><span class="token operator">*</span> _pRefCount<span class="token punctuation">;</span>	<span class="token comment">//管理的资源对应的引用计数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>关于上面operator=的另类写法:</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/50/55/973BptK7_o.png" alt="image-20221020202603070"></p> 
<p>析构函数是可以显示调用的！所以可以写成下述的形式:</p> 
<pre><code class="prism language-cpp">shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr <span class="token operator">!=</span> sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">)</span><span class="token comment">//判断是不是管理的同一份资源</span>
    <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示调用析构函数</span>
        _ptr <span class="token operator">=</span> sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">;</span><span class="token comment">//指向新资源</span>
        _pRefCount <span class="token operator">=</span> sp<span class="token punctuation">.</span>_pRefCount<span class="token punctuation">;</span><span class="token comment">//指向同一个计数空间</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>_pRefCount<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//多了一个指向该资源的对象, 计数++</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由于很多地方都用到这个引用计数++和–的逻辑,所以我们可以封装成两个函数:ReleaseRef和AddRef</p> 
<hr> 
<h3>
<a id="_616"></a>关于引用变量的位置</h3> 
<blockquote> 
 <p>问题:<strong>为什么引用计数需要存放在堆区,为什么不能是静态的成员变量,普通的成员变量?</strong></p> 
</blockquote> 
<p>case1: shared_ptr中的引用计数count不能单纯的定义成一个int类型的成员变量,因为这就意味着每个shared_ptr对象都有一个自己的count成员变量,是不可行的！</p> 
<img src="https://images2.imgbox.com/a3/eb/CSiedCeK_o.png" alt="image-20221020161145901"> 
<p><strong>当多个对象要管理同一个资源时,这几个对象应该用到的是同一个引用计数</strong></p> 
<hr> 
<p>case2:shared_ptr中的引用计数count也不能定义成一个静态的成员变量,因为<strong>静态成员变量是所有类型对象共享</strong>的,这会导致<strong>管理相同资源的对象和管理不同资源的对象用到的都是同一个引用计数</strong></p> 
<img src="https://images2.imgbox.com/46/ef/iHGue61P_o.png" alt="image-20221020161404834"> 
<hr> 
<p>case3:如果将shared_ptr中的引用计数count定义成一个指针</p> 
<ul>
<li>当一个资源第一次被管理时就在堆区开辟一块空间用于存储其对应的引用计数</li>
<li>如果有其他对象也想要管理这个资源,那么除了将这个资源给它之外,还需要把这个引用计数也给它, 这时管理同一个资源的多个对象访问到的就是同一个引用计数</li>
<li>而管理不同资源的对象访问到的就是不同的引用计数了,相当于将各个资源与其对应的引用计数进行了绑定</li>
</ul> 
<p><img src="https://images2.imgbox.com/7e/42/WzO8PbCL_o.png" alt="image-20221020161723735"></p> 
<p>但同时需要注意,由于引用计数的内存空间也是在堆上开辟的,因此当一个资源对应的引用计数减为0时,除了需要将该资源释放,还需要将该资源对应的引用计数的内存空间进行释放</p> 
<hr> 
<h3>
<a id="_646"></a>线程安全问题</h3> 
<blockquote> 
 <p>shared_ptr的线程安全问题</p> 
</blockquote> 
<p>当前模拟实现的shared_ptr还存在线程安全的问题,由于<strong>管理同一个资源的多个对象的引用计数是共享的</strong>,因此<strong>多个线程可能会同时对同一个引用计数进行自增或自减操作</strong>,而自增和自减操作都不是原子操作,因此需要通过加锁来对引用计数进行保护,否则就会导致线程安全问题</p> 
<hr> 
<blockquote> 
 <p>例子:下面代码中用一个shared_ptr管理一个整型变量,然后用两个线程分别对这个shared_ptr对象进行1000次拷贝操作,这些对象被拷贝出来后又会立即被销毁,</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token comment">//对同一个shared_ptr对象进行n次拷贝,所以传引用</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">copy</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝构造sp对象</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">const</span> size_t n <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注意:线程中的传引用要加ref！！！</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//获取引用计数 预期：1</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果share_ptr不加锁在多线程的情况下是不安全的, 在这个过程中两个线程会不断对引用计数进行自增和自减操作,理论上最终两个线程执行完毕后引用计数的值应该是1,因为拷贝出来的对象都被销毁了,只剩下最初的shared_ptr对象还在管理这个资源</p> 
<p>但每次运行程序得到引用计数的值可能都是不一样的,甚至可能出现崩溃,根本原因就是**因为对引用计数的自增和自减不是原子操作,**可能两个线程对引用计数空间进行了两次自减,但是最终只减了1次或者引用计数原来是1,++了两次,可能还是2.这样引用计数就错乱了,会导致资源未释放或者程序崩溃的问题</p> 
<ul><li>总结起来就是: 多个线程多同一个智能指针对象</li></ul> 
<hr> 
<blockquote> 
 <p>如何解决呢？</p> 
</blockquote> 
<p>加锁解决线程安全问题! 要解决引用计数的线程安全问题,<strong>本质就是要让对引用计数的自增和自减操作变成一个原子操作,因此可以对引用计数的操作进行加锁保护,也可以用原子类atomic对引用计数进行封装,这里以加锁为例,</strong></p> 
<ul>
<li>在shared_ptr类中<strong>新增互斥锁成员变量</strong>,为了让管理同一个资源的多个线程访问到的是同一个互斥锁,管理不同资源的线程访问到的是不同的互斥锁,<strong>因此互斥锁也需要在堆区创建</strong>
</li>
<li>在调用拷贝构造函数和拷贝赋值函数时,除了需要将对应的资源和引用计数交给当前对象管理之外,还需要将对应的互斥锁也交给当前对象</li>
<li>当一个资源对应的引用计数减为0时,除了需要将对应的资源和引用计数进行释放,由于互斥锁也是在堆区创建的,因此还需要将对应的互斥锁进行释放</li>
<li>为了简化代码逻辑,可以将拷贝构造函数和拷贝赋值函数中引用计数的自增操作提取出来,封装成AddRef函数,将拷贝赋值函数和析构函数中引用计数的自减操作提取出来,封装成ReleaseRef函数,这样就只需要对AddRef和ReleaseRef函数进行加锁保护即可</li>
</ul> 
<h4>
<a id="_698"></a>模拟实现改进</h4> 
<pre><code class="prism language-cpp"><span class="token comment">// 引用计数支持多个拷贝管理同一个资源，最后一个析构对象释放资源</span>
<span class="token keyword">namespace</span> Mango
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">shared_ptr</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">shared_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token comment">//第一次指向新资源,计数为1 配一把锁</span>
			<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pRefCount</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pmtx</span><span class="token punctuation">(</span><span class="token keyword">new</span> mutex<span class="token punctuation">)</span>   
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

		<span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span> <span class="token comment">//指向同一个计数空间,同一个锁的指针</span>
			<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pRefCount</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>_pRefCount<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pmtx</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>_pmtx<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">AddRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">ReleaseRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//释放资源+计数空间</span>
		<span class="token punctuation">{<!-- --></span>
			_pmtx<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加锁</span>
			<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token comment">//减减计数 如果减到0就释放这块资源和计数空间</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token operator">*</span>_pRefCount<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> _ptr<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete:"</span> <span class="token operator">&lt;&lt;</span> _ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token keyword">delete</span> _ptr<span class="token punctuation">;</span>
				<span class="token keyword">delete</span> _pRefCount<span class="token punctuation">;</span>
 
				flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//当前线程是最后一个管理这个资源的对象 </span>
			<span class="token punctuation">}</span>
 
			_pmtx<span class="token operator">-&gt;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//解锁</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">delete</span> _pmtx<span class="token punctuation">;</span> <span class="token comment">//释放这把锁</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">AddRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//增加引用计数</span>
		<span class="token punctuation">{<!-- --></span>
			_pmtx<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加锁</span>
			<span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>_pRefCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_pmtx<span class="token operator">-&gt;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解锁</span>
		<span class="token punctuation">}</span>

		shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//if (this != &amp;sp)  //判断是否是自己给自己赋值</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr <span class="token operator">!=</span> sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">)</span> <span class="token comment">//优化:判断二者是否指向同一块资源</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">ReleaseRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				_ptr <span class="token operator">=</span> sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">;</span><span class="token comment">//指向新资源</span>
				_pRefCount <span class="token operator">=</span> sp<span class="token punctuation">.</span>_pRefCount<span class="token punctuation">;</span><span class="token comment">//指向新资源对应的引用空间</span>
				_pmtx <span class="token operator">=</span> sp<span class="token punctuation">.</span>_pmtx<span class="token punctuation">;</span><span class="token comment">//指向同一把锁</span>
				<span class="token function">AddRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">int</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//查看这个计数是多少</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">*</span>_pRefCount<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token operator">~</span><span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">ReleaseRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 像指针一样使用</span>
		T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">*</span>_ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment">//返回原生指针,用于获取其管理的资源</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span>
		<span class="token keyword">int</span><span class="token operator">*</span> _pRefCount<span class="token punctuation">;</span>
		 <span class="token comment">//只要管理这个资源的对象都应该访问的是同一把锁  所以用指针！</span>
		 <span class="token comment">//托管一个资源的时候,配一个引用计数,同时配一个锁</span>
		mutex<span class="token operator">*</span> _pmtx<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>需要注意的是:</p> 
<ul><li>在ReleaseRef函数中,当引用计数被减为0时需要释放互斥锁资源,但不能在临界区中释放互斥锁,因为后面还需要进行解锁操作,而且引用计数没有为0的时候,不能是否这个互斥锁, 因此代码中借助了一个flag变量,通过flag变量来判断解锁后是否需要释放互斥锁资源</li></ul> 
<blockquote> 
 <p>问:flag变量是线程安全的吗?</p> 
</blockquote> 
<p>是的！因为flag是局部变量,在加锁逻辑的内部,在加锁期间,其他线程不能访问这个flag变量</p> 
<hr> 
<blockquote> 
 <p>上面为什么使用<code>_ptr != sp._ptr</code>更好,而不是<code>this!=&amp;s</code></p> 
</blockquote> 
<p>因为可能存在这种情况:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span>sp1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	sp1 <span class="token operator">=</span> sp1<span class="token punctuation">;</span>
	sp1 <span class="token operator">=</span> sp2<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>针对sp1赋值给sp1,此时使用<code>this!=&amp;s</code>可以防止它进入if内部执行,直接返回, 而针对sp1 = sp2这种情况是避免不了的, 二者已经指向的是同一块资源,但是如果使用<code>this!=&amp;s</code>,此时会进入if内部,先–计数,最后又++回来, 多次一举！ 所以更好的就是比较赋值的shared_ptr对象是否指向的是同一块资源</p> 
<hr> 
<blockquote> 
 <p>例子2: 在上面已经对计数变量加锁的基础上:</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> _year <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> _month <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> _day <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">SharePtrFunc</span><span class="token punctuation">(</span>Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">,</span> size_t n<span class="token punctuation">,</span> mutex<span class="token operator">&amp;</span> mtx<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里智能指针拷贝会++计数，智能指针析构会--计数，这里是线程安全的。</span>
        Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span> <span class="token function">copy</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝构造</span>
        <span class="token comment">// 这里智能指针访问管理的资源，不是线程安全的</span>
        <span class="token comment">//所以我们看看这些值两个线程++了2n次，但是最终看到的结果，并一定是加了2n</span>
        copy<span class="token operator">-&gt;</span>_year<span class="token operator">++</span><span class="token punctuation">;</span>
        copy<span class="token operator">-&gt;</span>_month<span class="token operator">++</span><span class="token punctuation">;</span>
        copy<span class="token operator">-&gt;</span>_day<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">const</span> size_t n <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>
	mutex mtx<span class="token punctuation">;</span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span>SharePtrFunc<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span>SharePtrFunc<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>_year <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>_month <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>_day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们可以发现:对Date的成员++ 了2n次,但是最终看到的结果,并不是加了2n ,但是因为我们对引用计数加锁了,所以我们可以保证引用计数是正确的</p> 
<p><font color="red">shared_ptr只需要保证引用计数的线程安全问题,而不需要保证管理的资源的线程安全问题,就像原生指针管理一块内存空间一样,原生指针只需要指向这块空间,而这块空间的线程安全问题应该由这块空间的操作者来保证,</font></p> 
<ul><li>指向的资源不归智能指针管理,是用的人自己控制的 但是要管引用计数的线程安全</li></ul> 
<img src="https://images2.imgbox.com/c5/40/uzkwoDg1_o.png" alt="image-20221020200534965"> 
<p>原因就是因为:这里智能指针访问管理的资源,不是线程安全的,为了保证线程安全,在访问智能指针管理的资源的时候还要手动加锁</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">SharePtrFunc</span><span class="token punctuation">(</span>bit<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">,</span> size_t n<span class="token punctuation">,</span> mutex<span class="token operator">&amp;</span> mtx<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里智能指针拷贝会++计数，智能指针析构会--计数，这里是线程安全的。</span>
        Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span> <span class="token function">copy</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝构造</span>
        unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加锁保护</span>
        copy<span class="token operator">-&gt;</span>_year<span class="token operator">++</span><span class="token punctuation">;</span>
        copy<span class="token operator">-&gt;</span>_month<span class="token operator">++</span><span class="token punctuation">;</span>
        copy<span class="token operator">-&gt;</span>_day<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果后面还有语句,但是我们指向保护这个访问这个资源的时候是安全的,怎么做呢?</p> 
<ul><li>使用局部域！**锁只保护这一个局部域,**出了局部域就解锁了</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 这里智能指针拷贝会++计数，智能指针析构会--计数，这里是线程安全的。</span>
    Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span> <span class="token function">copy</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝构造</span>
    <span class="token punctuation">{<!-- --></span>
        unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加锁保护,这个局部域</span>
        copy<span class="token operator">-&gt;</span>_year<span class="token operator">++</span><span class="token punctuation">;</span>
        copy<span class="token operator">-&gt;</span>_month<span class="token operator">++</span><span class="token punctuation">;</span>
        copy<span class="token operator">-&gt;</span>_day<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment">//解锁</span>
    
    <span class="token comment">//....其它语句</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当然也可以手动解锁 lt.unlock()</p> 
<hr> 
<blockquote> 
 <p><font color="red"><strong>shared_ptr智能指针是线程安全的吗</strong></font></p> 
</blockquote> 
<ul>
<li>是的,引用计数的加减是加锁保护的,但是智能指针管理的资源（,<strong>其指向的资源不是线程安全的）,需要使用者管</strong>
</li>
<li>指向堆上资源的线程安全问题是访问的人处理的,智能指针不管,也管不了,引用计数的线程安全问题,是智能指针要处理的</li>
</ul> 
<hr> 
<h3>
<a id="shared_ptr_932"></a>shared_ptr的循环引用问题</h3> 
<p>shared_ptr的循环引用问题在一些特定的场景下才会产生,比如定义如下的结点类,并在结点类的析构函数中打印一句提示语句,便于判断结点是否正确释放</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
	ListNode<span class="token operator">*</span> _next<span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> _prev<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _val<span class="token punctuation">;</span>
	<span class="token operator">~</span><span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~ListNode()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>现在以<code>new</code>的方式在堆上构建两个结点,并将这两个结点首尾连接起来,最后以<code>delete</code>的方式释放这两个结点</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	ListNode<span class="token operator">*</span> node1 <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> node2 <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>

	node1<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> node2<span class="token punctuation">;</span>
	node2<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> node1<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> node1<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> node2<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述程序是没有问题的,两个结点都能够正确释放,为了防止程序中途返回或抛异常等原因导致结点未被释放,<strong>我们将这两个结点分别交给两个shared_ptr对象进行管理,</strong> 这时<strong>为了让连接节点时的赋值操作能够执行</strong>,就需要把ListNode类中的next和prev成员变量的类型也改为shared_ptr类型,</p> 
<ul><li>原因: shared_ptr不支持隐式类型转化</li></ul> 
<p><img src="https://images2.imgbox.com/36/87/at7I4cG0_o.png" alt="image-20221020165106142"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> _next<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> _prev<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _val<span class="token punctuation">;</span>
	<span class="token operator">~</span><span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~ListNode()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//注意:shared_ptr不支持隐式类型转化  </span>
	<span class="token comment">//std::shared_ptr&lt;ListNode&gt; n1 = new ListNode; 是不行滴！</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> <span class="token function">node1</span><span class="token punctuation">(</span><span class="token keyword">new</span> ListNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> <span class="token function">node2</span><span class="token punctuation">(</span><span class="token keyword">new</span> ListNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//循环引用问题</span>
	node1<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> node2<span class="token punctuation">;</span>
	node2<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> node1<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这时程序运行结束后两个结点都没有被释放,但如果去掉连接结点时的两句代码中的任意一句,那么这两个结点就都能够正确释放**,根本原因就是因为这两句连接结点的代码导致了循环引用**</p> 
<hr> 
<blockquote> 
 <p>原因解释:</p> 
</blockquote> 
<p>1)当以new的方式申请到两个ListNode结点并交给两个智能指针管理后,这两个资源对应的引用计数都被加到了1</p> 
<p><img src="https://images2.imgbox.com/1f/e3/Mns5ju3d_o.png" alt="image-20221020165635563"></p> 
<p>2)将这两个结点连接起来后,资源1当中的next成员与node2一同管理资源2.资源2中的prev成员与node1一同管理资源1.此时这两个资源对应的引用计数都被加到了2</p> 
<p><img src="https://images2.imgbox.com/a3/71/2NI0lsm2_o.png" alt="image-20221020165758680"></p> 
<p>3)出了main函数的作用域后,node1和node2的生命周期就结束了,因此这两个资源对应的引用计数最终都减到了1</p> 
<p><img src="https://images2.imgbox.com/b3/77/VlJ33A4X_o.png" alt="image-20221020165923293"></p> 
<blockquote> 
 <p>循环引用导致资源未被释放的原因：</p> 
</blockquote> 
<ul><li>当资源对应的引用计数减为0时对应的资源才会被释放,因此资源1的释放取决于资源2当中的prev成员,而资源2的释放取决于资源1当中的next成员, 而资源1当中的next成员的释放又取决于资源1.资源2当中的prev成员的释放又取决于资源2.<strong>于是这就变成了一个死循环,最终导致资源无法释放,</strong>
</li></ul> 
<hr> 
<blockquote> 
 <p>为什么只有一条连接的时候,这两个节点就能正确释放呢?</p> 
</blockquote> 
<p>如果连接结点时只进行一个连接操作,那么当node1和node2的生命周期结束时,就会有一个资源对应的引用计数被减为0,此时这个资源就会被释放,这个释放后另一个资源的引用计数也会被减为0,最终两个资源就都被释放了,这就是为什么只进行一个连接操作时这两个结点就都能够正确释放的原因</p> 
<ul><li>例如: 只有node1-&gt;_next = node2的时候</li></ul> 
<p><img src="https://images2.imgbox.com/b0/c8/Vq5E8Ltl_o.png" alt="image-20221020201443223"></p> 
<p>先定义node1然后node2后定义,所以node2先析构, node2这块空间的引用引用计数减到1 ,然后node1再析构,node1这块空间的引用计数减到0, 然后释放node1节点的空间,node1节点调用它的析构函数成员也要进行析构,然后把node2的引用计数减到0,node2的空间就被销毁了, node1的空间也被销毁了</p> 
<hr> 
<h2>
<a id="stdweak_ptr_1032"></a>std::weak_ptr</h2> 
<h3>
<a id="_1034"></a>解决循环引用问题</h3> 
<p>weak_ptr是C++11中引入的智能指针,weak_ptr不是用来管理资源的释放的,它主要是用来解决shared_ptr的循环引用问题的</p> 
<p><img src="https://images2.imgbox.com/c2/ed/KJBsq5GZ_o.png" alt="image-20221020171355312"></p> 
<p>weak_ptr支持用shared_ptr对象来构造weak_ptr对象,<strong>构造出来的weak_ptr对象与shared_ptr对象管理同一个资源,但不会增加这块资源对应的引用计数</strong></p> 
<ul><li>weak_ptr不是常规意义的智能指针,它没有接收一个原生指针的构造函数,也不符合RAII,它支持拷贝构造</li></ul> 
<p>其中weak_ptr也有use_count的成员函数:</p> 
<p><img src="https://images2.imgbox.com/3f/f5/YJyawScN_o.png" alt="image-20221020203358371"></p> 
<hr> 
<blockquote> 
 <p>上述代码解决循环引用的方法：</p> 
</blockquote> 
<p>将ListNode中的next和prev成员的类型换成weak_ptr就不会导致循环引用问题了,此时当node1和node2生命周期结束时两个资源对应的引用计数就都会被减为0,进而释放这两个结点的资源</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//这里weak_ptr的next和prev对象可以访问指定节点资源,但是不参与节点资源释放管理,其实就是不增加计数</span>
	std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> _next<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> _prev<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _val<span class="token punctuation">;</span>
	<span class="token operator">~</span><span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~ListNode()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> <span class="token function">node1</span><span class="token punctuation">(</span><span class="token keyword">new</span> ListNode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//会调用weak_ptr的无参的构造函数</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> <span class="token function">node2</span><span class="token punctuation">(</span><span class="token keyword">new</span> ListNode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//会调用weak_ptr的无参的构造函数</span>

	cout <span class="token operator">&lt;&lt;</span> node1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//1</span>
	cout <span class="token operator">&lt;&lt;</span> node2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//1</span>
    
	node1<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> node2<span class="token punctuation">;</span>
	node2<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> node1<span class="token punctuation">;</span>
    
	cout <span class="token operator">&lt;&lt;</span> node1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//1</span>
	cout <span class="token operator">&lt;&lt;</span> node2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//1</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过use_count获取这两个资源对应的引用计数就会发现,在结点连接前后这两个资源对应的引用计数就是1,根本原因就是<strong>weak_ptr不会增加管理的资源对应的引用计数</strong></p> 
<hr> 
<h3>
<a id="_1087"></a>模拟实现</h3> 
<blockquote> 
 <p>weak_ptr的模拟实现</p> 
</blockquote> 
<ol>
<li>提供一个无参的构造函数,比如刚才new ListNode时就会调用weak_ptr的无参的构造函数</li>
<li>支持用shared_ptr对象拷贝构造weak_ptr对象,构造时获取shared_ptr对象管理的资源</li>
<li>支持用shared_ptr对象拷贝赋值给weak_ptr对象,赋值时获取shared_ptr对象管理的资源</li>
<li>对<code>*</code>和<code>-&gt;</code>运算符进行重载,使weak_ptr对象具有指针一样的行为</li>
<li>shared_ptr还会提供一个get函数,用于获取其管理的资源,</li>
</ol> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">weak_ptr</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">weak_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>  <span class="token comment">//无参构造</span>
    <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    
	<span class="token comment">//sp.get()返回原生指针</span>
    <span class="token function">weak_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span>	<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">//用shared_ptr去去构造</span>
    <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    
    weak_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        _ptr <span class="token operator">=</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//指向同一块资源,参与资源的访问,但是不参与资源管理(引用计数)</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//像指针一样使用</span>
    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token operator">*</span>_ptr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>  <span class="token comment">//返回原生指针,用于获取其管理的资源</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span><span class="token comment">//原生指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h1>
<a id="4_1132"></a>4.定制删除器</h1> 
<blockquote> 
 <p><strong><font color="red">关于delete和new的补充</font></strong></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _a2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果写了析构函数,就会崩溃！</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

</code></pre> 
<ul>
<li> <p>如果A的析构函数没有显示写,这里不会报错也不会有内存泄漏,原因: new底层是用malloc开辟空间,delete底层是free,而free不管你开辟多少个空间,开多少字节释放多少字节</p> 
  <ul><li> <pre><code class="prism language-cpp">A<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment">//A没有写析构函数,这里没报错！也没有内存泄漏！</span>
</code></pre> </li></ul> </li>
<li> <p>但是如果A的析构函数显示写,这里就会出问题,原因 : new的时候如果有析构函数的情况下,假设一个对象是4字节,10个对象是40个字节,它不会只开40个字节,它还要在头部多开4个字节去存对象的个数,delete的时候,delete[]没有指明delete几个对象,它去头部取那4个字节,发现是10,就会调用10次析构函数,如果没有显示写析构函数,就不会多开4个字节去存个数</p> </li>
</ul> 
<blockquote> 
 <p>定制删除器的用法</p> 
</blockquote> 
<p><font color="red"><strong>当智能指针对象的生命周期结束时,所有的智能指针默认都是以<code>delete</code>的方式将资源释放,</strong></font> 因为智能指针并不是只管理以<code>new</code>方式申请的内存空间,智能指针管理的也可能是以<code>new[]</code>的方式申请到的空间,或管理的是一个文件指针</p> 
<blockquote> 
 <p>例如:错误例子</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
	ListNode<span class="token operator">*</span> _next<span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> _prev<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _val<span class="token punctuation">;</span>
	<span class="token operator">~</span><span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~ListNode()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> ListNode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//没问题</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> ListNode<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//error</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>FILE<span class="token operator">&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.cpp"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//error</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这时当智能指针对象的生命周期结束时,再以<code>delete</code>的方式释放管理的资源就会导致程序崩溃,因为以<code>new[]</code>的方式申请到的内存空间必须以<code>delete[]</code>的方式进行释放,而文件指针必须通过调用<code>fclose</code>函数进行释放</p> 
<hr> 
<p>这时就需要用到定制删除器来控制释放资源的方式.C++标准库中的shared_ptr提供了如下构造函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">&gt;</span>
<span class="token function">shared_ptr</span> <span class="token punctuation">(</span>U<span class="token operator">*</span> p<span class="token punctuation">,</span> D del<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>参数说明</p> 
</blockquote> 
<ul>
<li>p：需要让智能指针管理的资源</li>
<li>del：删除器,这个删除器是一个可调用对象,比如函数指针,仿函数,lambda表达式以及被包装器包装后的可调用对象</li>
</ul> 
<hr> 
<p>当shared_ptr对象的生命周期结束时就会调用传入的删除器完成资源的释放,调用该删除器时会将shared_ptr管理的资源作为参数进行传入</p> 
<p>因此当智能指针管理的资源不是以<code>new</code>的方式申请到的内存空间,就需要在构造智能指针对象时传入定制的删除器</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">DelArr</span> <span class="token comment">//删除器</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete[]: "</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> ListNode<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">DelArr</span><span class="token generic class-name"><span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//lambda表达式作为删除器</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>FILE<span class="token operator">&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.cpp"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fclose: "</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">fclose</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<blockquote> 
 <p><font color="red"><strong>定制删除器的模拟实现</strong></font></p> 
</blockquote> 
<p>定制删除器的实现问题：</p> 
<ul>
<li>C++标准库中实现shared_ptr时是分成了很多个类的,因此C++标准库中可以将删除器的类型设置为构造函数的模板参数,然后将删除器的类型在各个类之间进行传递,</li>
<li>但我们是直接用一个类来模拟实现shared_ptr的,因此不能将删除器的类型设置为构造函数的模板参数,因为删除器不是在构造函数中调用的,而是需要在ReleaseRef函数中进行调用,因此势必需要用一个成员变量将删除器保存下来,而在定义这个成员变量时就需要指定删除器的类型,因此这里模拟实现的时候不能将删除器的类型设置为构造函数的模板参数,</li>
<li>要在当前模拟实现的shared_ptr的基础上支持定制删除器,就只能给shared_ptr类再增加一个模板参数,在构造shared_ptr对象时就需要指定删除器的类型,然后增加一个支持传入删除器的构造函数,在构造对象时将删除器保存下来,在需要释放资源的时候调用该删除器进行释放即可,最好在设置一个默认的删除器,如果用户定义shared_ptr对象时不传入删除器,则默认以<code>delete</code>的方式释放资源,</li>
</ul> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> cl
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//默认的删除器</span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Delete</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">=</span> Delete<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">shared_ptr</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">ReleaseRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_pmutex<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token operator">*</span>_pcount<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//将管理的资源对应的引用计数--</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete: "</span> <span class="token operator">&lt;&lt;</span> _ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
					<span class="token function">_del</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使用定制删除器释放资源</span>
					_ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">delete</span> _pcount<span class="token punctuation">;</span>
				_pcount <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
				flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			_pmutex<span class="token operator">-&gt;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">delete</span> _pmutex<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">shared_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">,</span> D del<span class="token punctuation">)</span>
			<span class="token operator">:</span> <span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_pcount</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_pmutex</span><span class="token punctuation">(</span><span class="token keyword">new</span> mutex<span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_del</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span>        <span class="token comment">//管理的资源</span>
		<span class="token keyword">int</span><span class="token operator">*</span> _pcount<span class="token punctuation">;</span>   <span class="token comment">//管理的资源对应的引用计数</span>
		mutex<span class="token operator">*</span> _pmutex<span class="token punctuation">;</span> <span class="token comment">//管理的资源对应的互斥锁</span>
		D _del<span class="token punctuation">;</span>         <span class="token comment">//管理的资源对应的删除器</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这时我们模拟实现的shared_ptr就支持定制删除器了,但是使用起来没有C++标准库中的那么方便,</p> 
<ul>
<li>如果传入的删除器是一个仿函数,那么需要在构造shared_ptr对象时指明仿函数的类型,</li>
<li>如果传入的删除器是一个lambda表达式就更麻烦了,因为lambda表达式的类型不太容易获取,这里可以将lambda表达式的类型指明为一个包装器类型,让编译器传参时自行进行推演,也可以先用auto接收lambda表达式,然后再用decltype来声明删除器的类型</li>
</ul> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">DelArr</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete[]: "</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//仿函数示例</span>
	Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token punctuation">,</span> DelArr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> ListNode<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">DelArr</span><span class="token generic class-name"><span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//lambda示例1</span>
	Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>FILE<span class="token punctuation">,</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.cpp"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fclose: "</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">fclose</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//lambda示例2</span>
	<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fclose: "</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">fclose</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	Mango<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>FILE<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">sp3</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.cpp"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<blockquote> 
 <p><font color="red"><strong>关于unique_ptr的定制删除器</strong></font></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f7/41/Od0jg8SJ_o.png" alt="image-20221020203742270"></p> 
<p>它是在构造这个对象的时候传这个定制删除器</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> Mango
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">default_delete</span> <span class="token comment">//定制删除器</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete:"</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">// 释放方式由删除器决定</span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">=</span> default_delete<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> <span class="token comment">//D：默认删除器</span>
	<span class="token keyword">class</span> <span class="token class-name">unique_ptr</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">unique_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
			<span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

		<span class="token operator">~</span><span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;</span>
				<span class="token comment">//delete _ptr;</span>
				D del<span class="token punctuation">;</span>	
				<span class="token function">del</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用一个仿函数去释放</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 像指针一样使用</span>
		T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">*</span>_ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
		unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

	<span class="token keyword">private</span><span class="token operator">:</span>
		T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<blockquote> 
 <p>测试:</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _a2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">DeleteArray</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete[]:"</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">DeleteFile</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fclose:"</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">fclose</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//删除器是一个可调用对象</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// unique_ptr的删除器在类模板参数给 -- 所以传的是类型</span>
	Mango<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">up1</span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//可以不传,使用默认的</span>
    <span class="token comment">//可以显示的传删除器,注意:在unique_ptr中传的是类模板参数 是类型！</span>
	Mango<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>A<span class="token punctuation">,</span> DeleteArray<span class="token operator">&lt;</span>A<span class="token operator">&gt;&gt;</span> <span class="token function">up2</span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Mango<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>FILE<span class="token punctuation">,</span> DeleteFile<span class="token operator">&gt;</span> <span class="token function">up3</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//shared_ptr的删除器在构造函数的参数给 -- 所以传的是对象</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">DeleteArray</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>FILE<span class="token operator">&gt;</span> <span class="token function">sp3</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DeleteFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传仿函数作为删除器</span>

	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">sp4</span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>A<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传lammbda表达式作为删除器</span>
	std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>FILE<span class="token operator">&gt;</span> <span class="token function">sp5</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token function">fclose</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<blockquote> 
 <p>总结</p> 
</blockquote> 
<ul>
<li>定制删除器,实际在平时的工作中使用有价值</li>
<li>定制删除器的意义 : 默认情况,智能指针底层都是delete资源 ,那么如果你的资源不是new出来的呢？比如：new[]、malloc、fopen ,定制删除器 – 传入可调用对象,自定义释放资源</li>
</ul> 
<h1>
<a id="5C11boost_1461"></a>5.C++11和boost中智能指针的关系</h1> 
<ol>
<li>C++98中产生了第一个智能指针auto_ptr.</li>
<li>C++boost给出了更实用的scoped_ptr、shared_ptr和weak_ptr.</li>
<li>C++TR1引入了boost中的shared_ptr等,不过注意的是TR1并不是标准版,</li>
<li>C++11引入了boost中的unique_ptr、shared_ptr和weak_ptr,需要注意的是.unique_ptr对应的就是boost中的scoped_ptr,并且这些智能指针的实现原理是参考boost中实现的,</li>
</ol> 
<p>说明一下：boost库是为C++语言标准库提供扩展的一些C++程序库的总称</p> 
<hr>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>