<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C&#43;&#43;入门到精通】C&#43;&#43;入门 —— 类和对象（初始化列表、Static成员、友元、内部类、匿名对象） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;入门到精通】C&#43;&#43;入门 —— 类和对象（初始化列表、Static成员、友元、内部类、匿名对象）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p style="text-align:center"><img alt="" class="left" height="265" src="https://images2.imgbox.com/b4/ae/xtLS6WeT_o.jpg" width="404"></p> 
<h1 id="%C2%A0"> </h1> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">一、初始化列表</a></p> 
<p id="%E2%AD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#%E2%AD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%A6%82%E5%BF%B5">⭕初始化列表概念</a></p> 
<p id="%E2%AD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:40px"><a href="#%E2%AD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E4%BC%98%E7%82%B9">⭕初始化列表的优点</a></p> 
<p id="%E2%AD%95%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px"><a href="#%E2%AD%95%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">⭕使用场景</a></p> 
<p id="%E2%AD%95explicit%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px"><a href="#%E2%AD%95explicit%E5%85%B3%E9%94%AE%E5%AD%97">⭕explicit关键字</a></p> 
<p id="%E4%BA%8C%E3%80%81Static%E6%88%90%E5%91%98-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81Static%E6%88%90%E5%91%98">二、Static成员</a></p> 
<p id="%E2%AD%95Static%E6%88%90%E5%91%98%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#%E2%AD%95Static%E6%88%90%E5%91%98%E6%A6%82%E5%BF%B5">⭕Static成员概念</a></p> 
<p id="%F0%9F%94%B4%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%9A-toc" style="margin-left:80px"><a href="#%F0%9F%94%B4%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%9A">?静态数据成员：</a></p> 
<p id="%F0%9F%94%B4%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98%EF%BC%9A-toc" style="margin-left:80px"><a href="#%F0%9F%94%B4%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98%EF%BC%9A">?静态函数成员：</a></p> 
<p id="%E2%AD%95%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:40px"><a href="#%E2%AD%95%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E4%BC%98%E7%82%B9">⭕使用静态成员的优点</a></p> 
<p id="%E2%AD%95%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px"><a href="#%E2%AD%95%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">⭕使用静态成员的注意事项</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8F%8B%E5%85%83-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81%E5%8F%8B%E5%85%83">三、友元</a></p> 
<p id="%E2%AD%95%E5%8F%8B%E5%85%83%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#%E2%AD%95%E5%8F%8B%E5%85%83%E7%9A%84%E6%A6%82%E5%BF%B5">⭕友元的概念</a></p> 
<p id="%E2%AD%95%E7%B1%BB%E5%8F%8B%E5%85%83-toc" style="margin-left:40px"><a href="#%E2%AD%95%E7%B1%BB%E5%8F%8B%E5%85%83">⭕类友元</a></p> 
<p id="%E2%AD%95%E5%87%BD%E6%95%B0%E5%8F%8B%E5%85%83-toc" style="margin-left:40px"><a href="#%E2%AD%95%E5%87%BD%E6%95%B0%E5%8F%8B%E5%85%83">⭕函数友元</a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:0px"><a href="#%C2%A0%E5%9B%9B%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"> 四、内部类</a></p> 
<p id="%E2%AD%95%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#%E2%AD%95%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5">⭕内部类的概念</a></p> 
<p id="%E2%AD%95%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:40px"><a href="#%E2%AD%95%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9">⭕内部类的特点</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px"><a href="#%E4%BA%94%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">五、匿名对象</a></p> 
<p id="%E2%AD%95%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#%E2%AD%95%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5">⭕匿名对象概念</a></p> 
<p id="%E2%AD%95%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px"><a href="#%E2%AD%95%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8">⭕匿名对象的作用</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px"><a href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93">六、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h1 id="%E5%89%8D%E8%A8%80">前言</h1> 
<p>        这一篇文章是上一篇的续集（<a class="link-info" href="http://t.csdn.cn/RkeFr" title="这里有上篇链接">这里有上篇链接</a>）前面我们讲了C语言的基础知识，也了解了一些数据结构，并且讲了有关C++的命名空间的一些知识点以及关于C++的缺省参数、函数重载，引用 和 内联函数。也相信大家都掌握的不错，接下来博主将会带领大家继续学习有关C++比较重要的知识点——类和对象（<strong>初始化列表、Static成员、友元、内部类、匿名对象</strong>）。下面话不多说坐稳扶好咱们要开车了。</p> 
<h1 id="%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><strong>一、初始化列表</strong></h1> 
<h2 id="%E2%AD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%A6%82%E5%BF%B5">⭕<strong>初始化列表概念</strong>
</h2> 
<p>        在C++中，初始化列表是一种在对象或类的构造函数中初始化成员变量的特殊语法。它在构造函数的参数列表之后（<a class="link-info" href="http://t.csdn.cn/wUeSs" title="详细介绍构造函数">详细介绍构造函数</a>），使用冒号分隔，后跟成员初始化列表。</p> 
<p>初始化列表的语法如下所示：</p> 
<pre><code class="language-cpp">ConstructorName(Initialization1, Initialization2, ...)</code></pre> 
<p>        其中， <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">ConstructorName</span></strong></span> 是构造函数的名称， <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">Initialization</span></strong></span> 是成员的初始化，可以包括<strong>成员变量、常量、引用以及调用其他构造函数</strong>等。</p> 
<h2 id="%E2%AD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E4%BC%98%E7%82%B9" style="background-color:transparent">⭕初始化列表的优点</h2> 
<blockquote> 
 <p>1. <span style="color:#0d0016"><strong><span style="background-color:#fbd4d0">初始化成员变量</span></strong></span>：使用初始化列表可以直接在构造函数中初始化成员变量，而不需要在构造函数体内分别对每个成员进行赋值。<br> 2. <span style="color:#0d0016"><strong><span style="background-color:#fbd4d0">常量成员初始化</span></strong></span>：对于类中的常量成员，只能在初始化列表中进行初始化，而不能在构造函数体内赋值。<br> 3. <span style="color:#0d0016"><strong><span style="background-color:#fbd4d0">避免无效构造</span></strong></span>：初始化列表可以避免在构造函数体内对成员变量进行默认初始化，然后再赋予新值的过程，从而提高效率。<br> 4. <span style="color:#0d0016"><strong><span style="background-color:#fbd4d0">初始化顺序控制</span></strong></span>：使用初始化列表可以控制成员变量的初始化顺序，而不仅仅是它们在类中的声明顺序。</p> 
</blockquote> 
<p>下面这段代码，展示了如何在构造函数中使用初始化列表初始化成员变量：</p> 
<pre><code class="language-cpp">class MyClass {
private:
  int num;
  double value;

public:
  MyClass(int n, double v) 
        : num(n) 
        , value(v) 
    {

    // 构造函数体

    }
};</code></pre> 
<p>        在上述示例中， <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">MyClass</span></strong></span> 类的构造函数使用初始化列表初始化了成员变量 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">num</span></strong></span> 和 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">value</span></strong></span> ，分别使用参数 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">n</span></strong></span> 和 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">v</span></strong></span> 来进行初始化。</p> 
<p>        注意：<strong>冒号后面的代码就是初始化列表</strong>，其中 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">num(n)</span></strong></span> 表示将参数 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">n</span></strong></span> 的值赋给成员变量 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">num</span></strong></span> ， <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">value(v)</span></strong></span> 表示将参数 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">v</span></strong></span> 的值赋给成员变量 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">value</span></strong></span> 。</p> 
<h2 id="%E2%AD%95%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">⭕使用场景</h2> 
<p>1、<span style="color:#0d0016"><strong><span style="background-color:#edf6e8">每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)</span></strong></span></p> 
<p>2、类中包含以：引用成员变量，const成员变量，自定义类型成员(且该类没有默认构造函数时）必须放在初始化列表位置进行初始化。</p> 
<pre><code class="language-cpp">class A
{
public:
    A(int a)
    :_a(a)
    {

    }
private:
    int _a;
    
};
class B
{
public:
    B(int a, int ref)
        :_aobj(a)
        ,_ref(ref)
        ,_n(10)
    {
    
    }
private:

    A _aobj; // 没有默认构造函数
    int&amp; _ref; // 引用
    const int _n; // const

};</code></pre> 
<p>3、<span style="color:#0d0016"><strong><span style="background-color:#fbd4d0">尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，</span><span style="background-color:#fbd4d0">一定会先使用初始化列表初始化。</span></strong></span></p> 
<p>4、<span style="color:#0d0016"><strong><span style="background-color:#c7e6ea">成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后</span><span style="background-color:#c7e6ea">次序无关。</span></strong></span></p> 
<h2 id="%E2%AD%95explicit%E5%85%B3%E9%94%AE%E5%AD%97">⭕explicit关键字</h2> 
<p>        在C++中，<span style="color:#1a439c"><strong><span style="background-color:#fef2f0">explicit</span></strong></span> 是一个关键字，用于修饰类的构造函数。<strong>它的主要作用是防止隐式类型转换，限制只能进行显示（显式）的类型转换，对于单个参数或者除第一个参数无默认值其余均有默认值的构造函数，还具有类型转换的作用。</strong></p> 
<p>        当一个构造函数被声明为 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">explicit</span></strong></span> 时，<strong>它将不会被用于隐式转换。这意味着在使用该构造函数创建对象时，不能使用隐式转换来将参数类型转换为构造函数所需的类型，而必须使用显式的方式进行类型转换</strong>。</p> 
<p>下面我会用几行代码来说明 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">explicit</span></strong></span> 关键字的使用：</p> 
<pre><code class="language-cpp">class MyClass {
private:
  int num;

public:
  explicit MyClass(int n) : num(n) {
    // 构造函数体
  }
};

int main() {
  MyClass obj1(5);      // 直接调用构造函数，隐式转换不起作用
  MyClass obj2 = 10;   // 错误！使用了隐式转换, explicit构造函数无法隐式地将int类型转换为MyClass类型
  MyClass obj3 = MyClass(10); // 正确！使用显式转换
  
  return 0;
}</code></pre> 
<p>        在上述示例中， <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">MyClass</span></strong></span> 类的构造函数被声明为 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">explicit</span></strong></span> ，当我们创建对象时，不能使用隐式转换方式将整型参数转换为 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">MyClass</span></strong></span> 类型的对象。因此， <span style="color:#511b78"><strong><span style="background-color:#fef2f0">MyClass obj2 = 10;</span></strong></span> 这行代码会引发编译错误。而 <span style="color:#511b78"><strong><span style="background-color:#fef2f0">MyClass obj3 = MyClass(10);</span> </strong></span>这行代码是合法的，它使用显式转换方式将整型参数转换为 <span style="color:#1a439c"><strong><span style="background-color:#fef2f0">MyClass</span></strong></span> 类型的对象。</p> 
<h1 id="%E4%BA%8C%E3%80%81Static%E6%88%90%E5%91%98"><strong>二、Static成员</strong></h1> 
<h2 id="%E2%AD%95Static%E6%88%90%E5%91%98%E6%A6%82%E5%BF%B5">⭕<strong>Static成员概念</strong>
</h2> 
<p>        静态(static)成员是类的成员，而不是对象的成员。静态成员在类的所有对象之间共享，并且它们不与任何特定的对象关联，可以将静态成员分为两个类型：静态数据成员和静态函数成员。</p> 
<h3 id="%F0%9F%94%B4%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%9A">?静态数据成员：</h3> 
<p>        静态数据成员是与类关联的变量，而不是与类的对象关联的。它们存储在类的一个独立的存储区域中，而不是存储在类的对象中。静态数据成员在类的所有对象之间共享。可以通过类名加作用域解析运算符(::)来访问静态数据成员。</p> 
<p>   静态数据成员需要在类的声明中进行定义，并且在类外进行初始化。例如：</p> 
<pre><code class="language-cpp">   class MyClass 
   {
   private:
     static int count; // 静态数据成员的声明
   public:
     // 静态数据成员的初始化
     static int initialize;
     // ...
   };

   int MyClass::count = 0; // 静态数据成员的定义和初始化</code></pre> 
<p><strong>静态数据成员被所有类的对象共享，因此它们的值在多个对象之间是共享的。</strong></p> 
<h3 id="%F0%9F%94%B4%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98%EF%BC%9A">?静态函数成员：</h3> 
<p>        静态函数成员是与类关联的函数，而不是与类的对象关联的。静态函数成员可以在不创建类的对象的情况下被调用，<strong><span style="background-color:#f9eda6">通过使用类名加作用域解析运算符(::)来访问静态函数成员</span>。</strong></p> 
<p>   <strong>静态函数成员可以访问类的静态数据成员，但不能访问非静态的数据成员</strong>。静态函数成员在类的对象上操作的是静态成员，而不是对象的特定实例。 </p> 
<pre><code class="language-cpp">   class MyClass {
   private:
     static int count; // 静态数据成员的声明
   public:
     static void increment() {
       count++;   // 静态函数成员可以访问静态数据成员
     }
   };

   int MyClass::count = 0; // 静态数据成员的定义和初始化

   int main() {
     MyClass::increment(); // 调用静态函数成员
     return 0;
   }</code></pre> 
<p><strong>静态函数成员不需要通过类的对象进行调用，而是直接通过类名调用。</strong></p> 
<h2 id="%E2%AD%95%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E4%BC%98%E7%82%B9">⭕使用静态成员的优点</h2> 
<p>        静态成员能够提供<span style="color:#0d0016"><strong>在类的所有对象之间共享的数据、全局访问的能力、一致性和效率的优势，以及更好的命名空间管理</strong></span>。这使得它们在某些情况下非常有用，并可以提高代码的可维护性和性能。</p> 
<p>        1. <span style="color:#0d0016"><strong><span style="background-color:#fef2f0">共享数据</span></strong></span>：静态数据成员在类的所有对象之间共享，它们只有一个副本。这意味着无论创建了多少个对象，它们都可以访问和修改同一个静态数据成员，从而实现数据的共享。这对于存储一些在类的所有对象中都具有相同值或状态的数据非常有用。例如，可以使用静态成员来记录某个类实例的数量，或者作为全局设置信息的存储器。</p> 
<p>        2. <span style="color:#0d0016"><strong><span style="background-color:#fef2f0">全局访问</span></strong></span>：静态数据成员和静态函数成员都可以在不创建类对象的情况下直接访问和调用。这使得它们可以在类的外部被其他类、函数或文件访问，并且不需要通过类的对象进行访问。这提供了一种全局访问数据和功能的方式，而无需创建类对象。例如，可以通过类名访问静态数据成员来获取全局配置信息，或者直接调用静态函数成员来执行某些全局操作。</p> 
<p>        3. <span style="color:#0d0016"><strong><span style="background-color:#fef2f0">一致性和效率</span></strong></span>：静态数据成员在整个类的对象之间保持一致的值，无论创建了多少个对象，它们始终具有相同的状态。这可以提高代码的一致性和可维护性。另外，由于静态数据成员只有一个副本，因此可以节省内存空间。而静态函数成员在调用时无需创建类的对象，可以直接通过类名调用，提高了代码的效率。</p> 
<p>        4. <span style="color:#0d0016"><strong><span style="background-color:#fef2f0">访问权限控制</span></strong></span>：静态成员可以被用于实现一些对于类的所有对象具有一致性的配置、计数或限制。通过将这些成员声明为私有的，可以确保只有类的成员函数可以访问和修改它们，从而保证了对其状态的控制。这允许在类中进行一些特殊的操作，可以确保只有类内部的特定成员函数能够对静态成员进行操作和修改，而外部代码无法直接访问。</p> 
<p>        5. <span style="color:#0d0016"><strong><span style="background-color:#fef2f0">命名空间扩展</span></strong></span>：静态成员可以用于扩展类的命名空间。通过在类中添加静态成员，可以将相关的函数和数据组织在一起，提供更好的命名空间管理，避免全局名称冲突。这使得代码更具可读性和可维护性，因为相关的函数和数据在类的范围内是分组的，并且可以通过类名进行访问。</p> 
<h2 id="%E2%AD%95%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">⭕使用静态成员的注意事项</h2> 
<blockquote> 
 <p>?<span style="color:#0d0016"><strong>静态成员为所有类对象所共享，不属于某个具体的对象，存放在静态区</strong></span><br> ?<strong>静态成员变量必须在类外定义，定义时不添加static关键字，类中只是声明</strong><br> ?<span style="color:#0d0016"><strong>类静态成员即可用 类名::静态成员 或者 对象.静态成员 来访问</strong></span><br> ?<span style="color:#0d0016"><strong>静态成员函数没有隐藏的this指针，不能访问任何非静态成员</strong></span><br> ?<strong>静态成员也是类的成员，受public、protected、private 访问限定符的限制</strong></p> 
 <p>?<strong>静态成员可以被类的所有对象共享，所以在修改静态数据成员时应谨慎考虑它们的影响范围。<br> ?静态数据成员在类外部定义和初始化，并且需要在类的声明中进行声明。<br> ?静态函数成员不能访问非静态的数据成员，因为静态函数成员不与任何特定对象关联。</strong></p> 
</blockquote> 
<h1 id="%E4%B8%89%E3%80%81%E5%8F%8B%E5%85%83"><strong>三、友元</strong></h1> 
<h2 id="%E2%AD%95%E5%8F%8B%E5%85%83%E7%9A%84%E6%A6%82%E5%BF%B5">⭕友元的概念</h2> 
<p>        友元(friend)是一种机制，允许一个类或函数访问另一个类的私有成员。<span style="color:#0d0016"><strong><span style="background-color:#fef2f0">通过友元关系，可以将某个外部实体（类或函数）授权以特殊的方式访问另一个类的非公开成员，而不需要违反封装的原则，</span></strong></span>友元可以分为两种类型：类友元和函数友元。</p> 
<p>     注意：<span style="color:#0d0016"><strong><span style="background-color:#fefcd8">友元关系是单向的</span></strong></span>。例如，如果类A声明了类B为友元，使得B可以访问A的私有成员，这并不意味着A能够自动访问B的私有成员。友元关系需要在每个需要访问私有成员的类或函数中单独声明。<span style="color:#0d0016"><strong><span style="background-color:#fefcd8">友元关系可以破坏封装性</span></strong></span>，<span style="color:#0d0016"><span style="background-color:#fbd4d0">因为它使得另一个类或函数可以访问私有成员。因此，应该谨慎使用友元机制，只在确实需要访问私有成员的情况下使用</span></span>。同时，<span style="color:#0d0016"><strong>友元应尽可能地减少</strong></span>，以保持良好的封装性和代码可读性。</p> 
<h2 id="%E2%AD%95%E7%B1%BB%E5%8F%8B%E5%85%83">⭕类友元</h2> 
<p>        可以将一个类声明为另一个类的友元类。这将使得友元类可以访问被授权类的私有成员。在类的定义中使用  <span style="color:#1a439c"><strong><code><span style="background-color:#fef2f0">friend</span> </code></strong></span>关键字声明友元类，并且该声明通常放在被授权类的私有部分或公有部分的起始位置，<span style="color:#0d0016"><strong>被授权类的所有成员对友元类的所有成员都具有访问权限</strong></span>。</p> 
<pre><code class="language-cpp">class MyClass {
private:
  // 声明友元类
  friend class FriendClass;
  int privateData;

public:
  // 公有成员
};

class FriendClass {
public:
  void accessPrivateData(const MyClass&amp; obj) {
    // 可以访问MyClass的私有成员
    int data = obj.privateData;
  }
};</code></pre> 
<p>在上面的代码中，<code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">FriendClass</span></strong></span> </code>被声明为 <code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">MyClass</span></strong></span> </code>的友元类，因此在 <code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">FriendClass</span></strong></span> </code>中可以访问 <code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">MyClass</span></strong></span> </code>的私有成员 <span style="color:#1a439c"><strong><code><span style="background-color:#fef2f0">privateData</span> </code></strong></span> </p> 
<h2 id="%E2%AD%95%E5%87%BD%E6%95%B0%E5%8F%8B%E5%85%83">⭕函数友元</h2> 
<p>        可以将一个函数声明为另一个类的友元函数。这将使得友元函数可以直接访问被授权类的私有成员。在类的定义中使用  <code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">friend</span></strong></span> </code>关键字声明友元函数。被授权类的所有成员对友元函数具有访问权限。</p> 
<pre><code class="language-cpp">class MyClass {
private:
  int privateData;

public:
  // 声明友元函数
  friend void friendFunction(const MyClass&amp; obj);
};

void friendFunction(const MyClass&amp; obj) {
  // 可以访问MyClass的私有成员
  int data = obj.privateData;
}</code></pre> 
<p>        在上面的代码中，<code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">friendFunction</span></strong></span> </code>被声明为  <code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">MyClass</span></strong></span> </code>的友元函数，因此在 <code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">friendFunction</span></strong></span> </code>中可以直接访问  <code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">MyClass</span></strong></span> </code>的私有成员  <span style="color:#1a439c"><code><strong><span style="background-color:#fef2f0">privateData</span></strong><span style="background-color:#fef2f0"> </span></code></span></p> 
<p>        友元是一种特殊的关系，<strong>允许一个类或函数访问另一个类的私有成员。友元可以是类或函数，并通过使用  <code><span style="color:#1a439c"><span style="background-color:#fef2f0">friend</span></span> </code>关键字进行声明。友元关系在某些情况下是有用的，但应该谨慎使用。</strong></p> 
<h1 id="%C2%A0%E5%9B%9B%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"> <strong>四、内部类</strong>
</h1> 
<h2 id="%E2%AD%95%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5">⭕<strong>内部类的概念</strong>
</h2> 
<p>        如果一个类定义在另一个类的内部，这个内部类就叫做内部类。<span style="color:#0d0016"><strong><span style="background-color:#fbd4d0">内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去访问内部类的成员。</span></strong></span>外部类对内部类没有任何优越的访问权限。<br>         注意：<strong><span style="background-color:#e7fafa">内部类就是外部类的友元类，参见友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。</span></strong></p> 
<h2 id="%E2%AD%95%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9">⭕<strong>内部类的特点</strong>
</h2> 
<blockquote> 
 <p>1. <strong>内部类可以定义在外部类的public、protected、private都是可以的。</strong><br> 2. <strong>注意内部类可以直接访问外部类中的static成员，不需要外部类的对象/类名。</strong><br> 3. <span style="color:#0d0016"><strong>sizeof(外部类)=外部类，和内部类没有任何关系。</strong></span></p> 
</blockquote> 
<pre><code class="language-cpp">class A
{
private:
    static int k;
    int h;
public:
    class B // B天生就是A的友元
    {
        public:
        void foo(const A&amp; a)
        {
            cout &lt;&lt; k &lt;&lt; endl;//OK
            cout &lt;&lt; a.h &lt;&lt; endl;//OK
        }
    };
};

int A::k = 1;

int main()
{
    A::B b;

    b.foo(A());

    return 0;
}</code></pre> 
<h1 id="%E4%BA%94%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><strong>五、匿名对象</strong></h1> 
<h2 id="%E2%AD%95%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5">⭕匿名对象概念</h2> 
<p>        <strong>匿名对象指的是在没有被命名的情况下创建的临时对象。<span style="background-color:#fef2f0">它们在表达式中被直接使用，并且通常用于一次性的操作或作为函数调用的参数</span></strong>。匿名对象的创建方式是在类名后紧跟一对小括号，即类名后面加上一对空括号，或者在构造函数后调用无参构造函数。</p> 
<pre><code class="language-cpp">class MyClass {
public:
  MyClass() {
    // 构造函数代码
  }
  
  void doSomething() {
    // 成员函数代码
  }
};

int main() {
  // 创建匿名对象并调用成员函数
  MyClass().doSomething();
  
  // 将匿名对象作为函数参数
  someFunction(MyClass());
  
  return 0;
}</code></pre> 
<p>        在上面的代码中，<span style="color:#1a439c"><strong><code><span style="background-color:#fef2f0">MyClass().doSomething()</span> </code></strong></span>创建了一个匿名对象，并在该对象上调用了<code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">doSomething()</span></strong></span> </code>成员函数。同样地，<code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">someFunction(MyClass())</span></strong></span> </code>将匿名对象作为函数<code><span style="color:#1a439c"><strong><span style="background-color:#fef2f0">someFunction</span></strong></span> </code>的参数。</p> 
<p>        <strong>匿名对象是在没有被命名的情况下直接使用的临时对象</strong>。它们适用于一次性操作或作为函数调用的参数，并且通常用于临时任务。匿名对象的生命周期仅限于所在的表达式。但要注意匿名对象没有具名对象的灵活性和可重用性，因此在需要引用对象或保留对象状态的情况下，最好使用具名对象。</p> 
<h2 id="%E2%AD%95%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8">⭕匿名对象的作用</h2> 
<p>        匿名对象在某些情况下非常有用，<strong>特别是在需要执行一系列临时操作时。由于匿名对象没有被命名，也无法再次访问，因此它们通常被用于临时操作，而不是保存数据。<span style="color:#0d0016"><span style="background-color:#fbd4d0">匿名对象的生命周期仅限于所在的表达式，一旦表达式结束，匿名对象将被销毁。</span></span></strong></p> 
<p>        <strong><span style="background-color:#fbd4d0">匿名对象还可以用于链式调用方法</span></strong>。这种用法允许在一行代码中依次调用多个成员函数，并对同一个对象进行串联操作。</p> 
<pre><code class="language-cpp">MyClass().doSomething().doSomethingElse().processData();</code></pre> 
<p>在面的代码中，<strong><span style="background-color:#fefcd8">每个成员函数都返回一个新的临时对象，这样就可以在一行代码中依次调用多个成员函数。</span></strong></p> 
<p>        <span style="color:#be191c"><strong>由于匿名对象没有被命名，无法在其作用域之外引用它。因此，如果需要在多个地方使用相同的对象或需要保留对象的状态，最好创建一个具名对象来替代匿名对象。</strong></span></p> 
<h1></h1> 
<h1 id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><strong>六、总结</strong></h1> 
<p>        在上面我们介绍了：初始化列表、静态成员、友元、内部类和匿名对象，并且博主提供了对这些概念的全面介绍，帮助您理解和应用它们在C++编程中的作用和用法。</p> 
<p>        在初始化列表部分，我们了解了初始化列表的概念和优点，包括提高效率和简化代码。我们还学习了explicit关键字的作用和使用场景。</p> 
<p>        在静态成员部分，我们探讨了静态数据成员和静态函数成员的概念，并阐述了使用静态成员的优点，如共享数据、全局访问和一致性。我们还提到了使用静态成员时需要注意的事项。</p> 
<p>        在友元部分，我们理解了友元的概念，并学习了类友元和函数友元的用法。我们明白了友元允许其他类或函数访问私有成员的能力，同时强调了谨慎使用友元的重要性。</p> 
<p>        在内部类部分，我们了解了内部类的概念和特点。我们知道内部类是在另一个类的内部定义的类，并且具有访问外部类的成员的能力。</p> 
<p>        最后，在匿名对象部分，我们学习了匿名对象的概念和作用。我们了解到匿名对象通常用于一次性操作或作为函数调用的参数，但它们的生命周期仅限于所在的表达式。</p> 
<h1 id="%E6%B8%A9%E9%A6%A8%E6%8F%90%E7%A4%BA">温馨提示</h1> 
<p>        感谢您对博主文章的关注与支持！在阅读本篇文章的同时，我们想提醒您留下您宝贵的意见和反馈。如果您喜欢这篇文章，可以点赞、评论和分享给您的同学，这将对我提供巨大的鼓励和支持。另外，我计划在未来的更新中持续探讨与本文相关的内容。我会为您带来更多关于C++以及编程技术问题的深入解析、应用案例和趣味玩法等。请继续关注博主的更新，不要错过任何精彩内容！</p> 
<p>        再次感谢您的支持和关注。我们期待与您建立更紧密的互动，共同探索C++、算法和编程的奥秘。祝您生活愉快，排便顺畅！</p> 
<p><img alt="" src="https://images2.imgbox.com/91/ef/lo1Uv3Uz_o.jpg">       <br>  </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>