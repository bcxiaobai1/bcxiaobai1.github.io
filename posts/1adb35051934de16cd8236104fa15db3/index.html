<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>全面解析C语言多媒体开源框架GStreamer - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">全面解析C语言多媒体开源框架GStreamer</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81GStreamer%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px"><a href="#1%E3%80%81GStreamer%E7%AE%80%E4%BB%8B">1、GStreamer简介</a></p> 
<p id="2%E3%80%81GStreamer%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#2%E3%80%81GStreamer%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2、GStreamer基本概念</a></p> 
<p id="2.1%E3%80%81%E5%85%83%E4%BB%B6%EF%BC%88Element%EF%BC%89-toc" style="margin-left:80px"><a href="#2.1%E3%80%81%E5%85%83%E4%BB%B6%EF%BC%88Element%EF%BC%89">2.1、元件（Element）</a></p> 
<p id="2.2%E3%80%81%E7%AE%B1%E6%9F%9C%EF%BC%88Bin%EF%BC%89-toc" style="margin-left:80px"><a href="#2.2%E3%80%81%E7%AE%B1%E6%9F%9C%EF%BC%88Bin%EF%BC%89">2.2、箱柜（Bin）</a></p> 
<p id="2.3%E3%80%81%E7%AE%A1%E9%81%93%EF%BC%88Pipeline%EF%BC%89-toc" style="margin-left:80px"><a href="#2.3%E3%80%81%E7%AE%A1%E9%81%93%EF%BC%88Pipeline%EF%BC%89">2.3、管道（Pipeline）</a></p> 
<p id="2.4%E3%80%81%E8%A1%AC%E5%9E%AB%EF%BC%88Pad%EF%BC%89-toc" style="margin-left:80px"><a href="#2.4%E3%80%81%E8%A1%AC%E5%9E%AB%EF%BC%88Pad%EF%BC%89">2.4、衬垫（Pad）</a></p> 
<p id="2.5%E3%80%81%E8%83%BD%E5%8A%9B%E9%9B%86%EF%BC%88Caps%EF%BC%89-toc" style="margin-left:80px"><a href="#2.5%E3%80%81%E8%83%BD%E5%8A%9B%E9%9B%86%EF%BC%88Caps%EF%BC%89">2.5、能力集（Caps）</a></p> 
<p id="2.6%E3%80%81%E5%B9%BD%E7%81%B5pad%EF%BC%88ghost%20pad%EF%BC%89-toc" style="margin-left:80px"><a href="#2.6%E3%80%81%E5%B9%BD%E7%81%B5pad%EF%BC%88ghost%20pad%EF%BC%89">2.6、幽灵pad（ghost pad）</a></p> 
<p id="%C2%A02.7%E3%80%81Bus-toc" style="margin-left:80px"><a href="#%C2%A02.7%E3%80%81Bus"> 2.7、Bus</a></p> 
<p id="2.8%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89-toc" style="margin-left:80px"><a href="#2.8%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89">2.8、缓冲区（Buffer）</a></p> 
<p id="2.9%E3%80%81%E6%8F%92%E4%BB%B6%EF%BC%88Plugin%EF%BC%89-toc" style="margin-left:80px"><a href="#2.9%E3%80%81%E6%8F%92%E4%BB%B6%EF%BC%88Plugin%EF%BC%89">2.9、插件（Plugin）</a></p> 
<p id="3%E3%80%81GStreamer%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px"><a href="#3%E3%80%81GStreamer%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84">3、GStreamer基本架构</a></p> 
<p id="4%E3%80%81GStreamer%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px"><a href="#4%E3%80%81GStreamer%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6">4、GStreamer通信机制</a></p> 
<p id="4.1%E3%80%81Message-toc" style="margin-left:80px"><a href="#4.1%E3%80%81Message">4.1、Message</a></p> 
<p id="4.2%E3%80%81Event-toc" style="margin-left:80px"><a href="#4.2%E3%80%81Event">4.2、Event</a></p> 
<p id="4.3%E3%80%81Signal-toc" style="margin-left:80px"><a href="#4.3%E3%80%81Signal">4.3、Signal</a></p> 
<p id="4.4%E3%80%81Probe-toc" style="margin-left:80px"><a href="#4.4%E3%80%81Probe">4.4、Probe</a></p> 
<p id="4.5%E3%80%81Quary-toc" style="margin-left:80px"><a href="#4.5%E3%80%81Quary">4.5、Quary</a></p> 
<p id="5%E3%80%81GStreamer%E5%85%83%E4%BB%B6%E7%8A%B6%E6%80%81-toc" style="margin-left:40px"><a href="#5%E3%80%81GStreamer%E5%85%83%E4%BB%B6%E7%8A%B6%E6%80%81">5、GStreamer元件状态</a></p> 
<p id="6%E3%80%81GStreamer%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#6%E3%80%81GStreamer%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5">6、GStreamer中的几个关键概念</a></p> 
<p id="6.1%E3%80%81%E8%AF%86%E5%88%AB%E6%B5%81%E7%9A%84MIME%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px"><a href="#6.1%E3%80%81%E8%AF%86%E5%88%AB%E6%B5%81%E7%9A%84MIME%E7%B1%BB%E5%9E%8B">6.1、识别流的MIME类型</a></p> 
<p id="6.2%E3%80%81%E5%AA%92%E4%BD%93%E6%B5%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%EF%BC%88typefind%EF%BC%89-toc" style="margin-left:80px"><a href="#6.2%E3%80%81%E5%AA%92%E4%BD%93%E6%B5%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%EF%BC%88typefind%EF%BC%89">6.2、媒体流类型检测（typefind）</a></p> 
<p id="6.3%E3%80%81%E6%95%B0%E6%8D%AE%E6%8E%A2%E6%B5%8B-toc" style="margin-left:80px"><a href="#6.3%E3%80%81%E6%95%B0%E6%8D%AE%E6%8E%A2%E6%B5%8B">6.3、数据探测</a></p> 
<p id="6.4%E3%80%81%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px"><a href="#6.4%E3%80%81%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B">6.4、插件加载流程</a></p> 
<p id="7%E3%80%81GStreamer%E5%BC%80%E5%8F%91%E7%A4%BA%E4%BE%8B-MP3%E6%96%87%E4%BB%B6%E6%92%AD%E6%94%BE%E5%99%A8-toc" style="margin-left:40px"><a href="#7%E3%80%81GStreamer%E5%BC%80%E5%8F%91%E7%A4%BA%E4%BE%8B-MP3%E6%96%87%E4%BB%B6%E6%92%AD%E6%94%BE%E5%99%A8">7、GStreamer开发示例-MP3文件播放器</a></p> 
<p id="8%E3%80%81%E6%9C%80%E5%90%8E-toc" style="margin-left:40px"><a href="#8%E3%80%81%E6%9C%80%E5%90%8E">8、最后</a></p> 
<hr id="hr-toc">
<p>       之前参与的万能视频播放器项目采用了多媒体GStreamer开源框架，在最上层业务层通过连接各个插件形成一个pipeline来完成相应的业务需求。但之前没接触过GStreamer框架，所以从项目的前期预研开始，就从GStreamer最基本的概念开始熟悉，逐步解决项目中遇到的多个问题。本文根据此次项目实践，对GStreamer多媒体框架做一个相对全面的总结。</p> 
<h2 id="1%E3%80%81GStreamer%E7%AE%80%E4%BB%8B">1、GStreamer简介</h2> 
<p class="img-center"><img alt="" height="116" src="https://images2.imgbox.com/14/33/JvLsgCaN_o.png" width="510"></p> 
<p>       GStreamer是GNOME桌面环境下用来创建流媒体应用的多媒体框架，其基本设计思想来自于俄勒冈(Oregon)研究生学院有关视频管道的创意，同时也借鉴了DirectShow的设计思想。</p> 
<p>       GStreamer是用c语言实现的，使用了面向对象的思维。GStreamer 框架是基于插件和管道的，所有的插件都能够被链接到任意的已经定义的数据流管道中，数据通过管道机制进行统一交换。GStreamer的很多优点来源于其框架的模块化，使得新的插件能够无缝合并。</p> 
<p>       <span style="color:#1a439c"><strong>GStreamer能够处理任意类型的数据流，其目标是要简化音/视频应用程序的开发，其最显著的用途是在构建音视频播放器、编辑音视频文件、音视频格式转换和流媒体服务上，GStreamer已经能够被用来处理像 MP3、Ogg、MPEG1、MPEG2、AVI、Quicktime 等多种格式的多媒体数据。</strong></span></p> 
<blockquote> 
 <p>GStreamer核心库函数是一个处理插件、数据流和媒体操作的框架。另外，其还提供了一套API，用于程序员使用其它插件来编写他所需要的应用程序时使用。但是，由于追求模块化和高效率，使得GStreamer在整个框架上变的复杂，也同时因为复杂度的提高，使得开发一个新的应用程序显得不是那么的简单。</p> 
</blockquote> 
<h2 id="2%E3%80%81GStreamer%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2、GStreamer基本概念</h2> 
<h3 id="2.1%E3%80%81%E5%85%83%E4%BB%B6%EF%BC%88Element%EF%BC%89">2.1、元件（Element）</h3> 
<p>       元件是GStreamer的核心，是具有一定功能的基本单元，可将其描述为一个具有特定属性的黑盒子。其在代码里面的类型是GstElement，可以理解为Gstreamer里面的基类。Gstreamer默认安装了很多有用的元件，按照功能上的差异，element分为以下几类：</p> 
<blockquote> 
 <p>（1）<strong>source element 数据源元件</strong>，只有输出端，用来产生供管道消费的数据，例如，音频捕捉单元，它从声卡读取原始音频数据，供其它模块用；<br> （2）<strong>filter(/filter-like) element 中间元件</strong>，包括过滤器、转换器、复用器、解复用器、编解码器等，其既有输入端又有输出端，从输入端获得相应数据，经过处理之后传递给输出端，有的element可能有一个source pad多个sink pads（demux），有的可能有多个source pads一个sink pad（mux），有的有一个source pad一个sink pad，例如，音频编码单元，它从外界获得音频数据之后，根据压缩算法编码后，给其它模块使用；<br> （3）<strong>sink elements 接收器元件</strong>，只有输入端，仅有消费数据的能力，是整条媒体管道的终端，例如，音频回放单元，负责将接收到的数据写到声卡上；</p> 
</blockquote> 
<h3 id="2.2%E3%80%81%E7%AE%B1%E6%9F%9C%EF%BC%88Bin%EF%BC%89">2.2、箱柜（Bin）</h3> 
<p>       由多个基本单元组成的一个高级的功能单元，是装载元件的容器，可以通过改变一个Bin的状态来改变其内部所有元件的状态，Bin可以发送总线消息(bus message)给其子集元件。</p> 
<p>       Bin和pipeline的区别就是pipeline肯定是bin，但bin不一定是pipeline，bin就像一个盒子，里面放了什么东西，功能具体是怎么实现的，用户可以不关心，bin是元件的集合，而pipeline更强调应用的可执行性。</p> 
<h3 id="2.3%E3%80%81%E7%AE%A1%E9%81%93%EF%BC%88Pipeline%EF%BC%89">2.3、管道（Pipeline）</h3> 
<p>       最高等级的Bin，是一种允许对所包含的元件进行安排（scheduling）的普通容器。顶层（toplevel）箱柜必须为一个管道，因此每个GStreamer应用程序都至少需要一个管道。当应用程序启动后，管道会自动运行在后台线程中，下面是一个典型的pipeline示例：</p> 
<p class="img-center"><img alt="" height="261" src="https://images2.imgbox.com/67/34/o60dIYSG_o.png" width="704"></p> 
<h3 id="2.4%E3%80%81%E8%A1%AC%E5%9E%AB%EF%BC%88Pad%EF%BC%89">2.4、衬垫（Pad）</h3> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p>       不同Elements之间的链接点，数据流在元件之间流动就是依靠Pads。Pads有处理特殊数据的能力，也就是其支持特定媒体类型的能力，一个Pads能够限制数据流类型的通过，链接成功的条件是，两个Pads允许通过的数据类型一致时才能建立（数据类型协商）。</p> 
<p>        Pads按照数据导向，可分为source pads(element的输出)，sink pads(element 的输入)，按照时效性可分为，永久型(always)、随机型(sometimes)、请求型(on request)，三种时效性的意义顾名思义: 永久型的衬垫一直会存在，随机型的衬垫只在某种特定的条件下才存在(会随机消失的衬垫也属于随机型)，请求型的衬垫只在应用程序明确发出请求时才出现。</p> 
<p>       Pads通过GstCaps对象进行描述，一个GstCaps对象包括一个或者多个GstStructure对象，一个GstStructure描述一种媒体类型，其结构中只包含功能集中规定的固定值。</p> 
<h3 id="2.5%E3%80%81%E8%83%BD%E5%8A%9B%E9%9B%86%EF%BC%88Caps%EF%BC%89">2.5、能力集（Caps）</h3> 
<p>       Pad的属性描述，例如：</p> 
<pre><code class="language-cpp">  SRC template: 'src'
    Availability: Always
    Capabilities:
      audio/x-raw-float
                   rate: [ 8000, 50000 ]
               channels: [ 1, 2 ]
             endianness: 1234
                  width: 32
          buffer-frames: 0

  SINK template: 'sink'
    Availability: Always
    Capabilities:
      audio/x-vorbis</code></pre> 
<h3 id="2.6%E3%80%81%E5%B9%BD%E7%81%B5pad%EF%BC%88ghost%20pad%EF%BC%89">2.6、幽灵pad（ghost pad）</h3> 
<p>       bin本身没有pad，所以就没有办法把两个bin链接起来。但可以用bin中的一个元件的pad构造一个代理pad，这样bin就有一个代理pad了。这个pad实际指向被代理的那个单元的pad，示例如下：</p> 
<p class="img-center"><img alt="" height="222" src="https://images2.imgbox.com/d9/3e/1bNojXMz_o.png" width="651"></p> 
<h3 id="%C2%A02.7%E3%80%81Bus"> 2.7、Bus</h3> 
<p>       Bus采用自己的线程机制，负责pipeline线程和应用程序程序之间的通信。每个pipeline缺省创建一个Bus，应用程序在总线上设置一个类似于对象的信号处理的消息处理器，当主循环运行的时候，总线将会轮询这个消息处理器是否有新的消息，当消息被采集到后，总线将呼叫相应的回调函数来完成相关操作。</p> 
<p>       应用程序有两种方法使用Bus，第一种是使用 GLib/Gtk+ main loop及gst_bus_add_watch () or gst_bus_add_signal_watch()事件回调函数机制，第二种是程序通过gst_bus_peek () /gst_bus_poll ()主动检查Bus中的消息；</p> 
<h3 id="2.8%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89">2.8、缓冲区（Buffer）</h3> 
<p>       管道的数据流由一组缓冲区和事件组成，缓冲区包括实际的管道数据，事件包括控制信息，如寻找信息和流的终止信号。所有这些数据流在运行的时候自动的流过管道。<br> 缓冲区包含了你创建的管道里的数据流，通常一个源元件会创建一个新的缓冲区，同时元件还将会把缓冲区的数据传递给下一个元件。一个缓冲区主要由以下一个组成： </p> 
<blockquote> 
 <p>（1）指向某块内存的指针；<br> （2）内存的大小；<br> （3）缓冲区的时间戳；<br> （4）一个引用计数，指出了缓冲区所使用的元件数。没有元件可引用的时候，这个引用将用于销毁缓冲区。 </p> 
</blockquote> 
<p>       buffer的创建有2种方式，一种是由当前的element自己创建，然后把这个buffer传递给下一个element；另外一种方式就是dwonstream-allocated buffers，就是由下一个element来创建要求大小的buffer，并提供buffer操作函数，当前element通过调用buffer操作函数将数据写入这个buffer中完成buffer数据传递。其区别在于buffer的创建是在数据传输的源端element创建还是在数据接收端element来创建。</p> 
<h3 id="2.9%E3%80%81%E6%8F%92%E4%BB%B6%EF%BC%88Plugin%EF%BC%89">2.9、插件（Plugin）</h3> 
<p>       元件必须封装在插件中才能被使用，一个插件是一块可以加载的代码，通常被称为共享对象文件（shared object file）或动态链接库（dynamically linked library），一个插件中可以包含一个或若干element。</p> 
<h2 id="3%E3%80%81GStreamer%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84">3、GStreamer基本架构</h2> 
<p>        GStreamer core、Plugins以及依赖的第三方开源库的架构关系，如下图所示，</p> 
<p class="img-center"><img alt="" height="291" src="https://images2.imgbox.com/90/94/PyrJh0wD_o.png" width="598"></p> 
<p>Gstreamer的组成结构如下图所示：</p> 
<p class="img-center"><img alt="" height="424" src="https://images2.imgbox.com/f8/1b/Fa1z1Arm_o.png" width="662"></p> 
<h2 id="4%E3%80%81GStreamer%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6">4、GStreamer通信机制</h2> 
<p>        Gstreamer的通信机制示意图及解释如下：</p> 
<p class="img-center"><img alt="" height="366" src="https://images2.imgbox.com/2e/9a/0SDALQu0_o.png" width="627"></p> 
<h3 id="4.1%E3%80%81Message">4.1、Message</h3> 
<p>       pipeline用来主动向外报告自己的运行状态。这些Message被发送到一个消息队列，也就是pipeline的Bus，应用程序可以从Bus中获取Message，并作出自定义的反应。Message是GST提供的，属于异步操作；</p> 
<h3 id="4.2%E3%80%81Event">4.2、Event</h3> 
<p>       pipeline中插件之间进行通信的机制，分为下行事件，上行事件和双向事件。也可以由应用程序直接向某一个插件发送事件，但起作用的前提是：该插件定义了该事件的响应操作。 通过事件可以控制整个pipeline的运行状态。</p> 
<p>       下行事件是由source插件向sink插件方向传输，例如，</p> 
<blockquote> 
 <p>GST_EVENT_EOS （流的终止信号）<br> GST_EVENT_NEWSEGMENT</p> 
</blockquote> 
<p>       上行事件是由sink插件向source插件方向传输，用于改变管道中数据流的状态，例如：</p> 
<blockquote> 
 <p>GST_EVENT_QOS<br> GST_EVENT_SEEK（查找）</p> 
</blockquote> 
<p>       双向事件，例如：</p> 
<blockquote> 
 <p>GST_EVENT_FLUSH_START<br> GST_EVENT_FLUSH_STOP</p> 
</blockquote> 
<h3 id="4.3%E3%80%81Signal">4.3、Signal</h3> 
<p>        应用程序控制某一插件的运行状态，signal可以看做Glib对象的一个属性，是由Gobject系统提供的，属于同步操作，与linux中的系统信号有差别。通过信号可以让某个插件做一些对插件本身变量的操作，比如增加或者删除一些维护信息等等。</p> 
<h3 id="4.4%E3%80%81Probe">4.4、Probe</h3> 
<p>        应用程序可以通过探针Probe来探测某个插件的pad中流过的数据，比如：在audioconert 插件的src pad 加一个探针，每当有buf到达时，就调用callback_have_data()，这里这个函数只是打印一下buf的大小，统计一下buf流过的个数；</p> 
<pre><code class="language-cpp">//main
GstPad *m_pad_concert_src = gst_element_get_static_pad(m_gst_convert, "src");   
gst_pad_add_buffer_probe(m_pad_concert_src, G_CALLBACK(callback_have_data), NULL);
gst_object_unref(m_pad_concert_src);

/*******Callback handler when probe date received***********/
static gboolean callback_have_data(GstPad *padsrc, GstBuffer *buffer, gpointer data)
{
    gint    iBufSize = 0;
    gchar*     pBuffer = NULL;
    iBufSize = GST_BUFFER_SIZE(buffer);
    pBuffer = (gchar*)GST_BUFFER_DATA(buffer);
    static gint numBuf = 0;
    g_print("rBUF %d  Size=%d   ", numBuf++, iBufSize);
    return TRUE;
}</code></pre> 
<h3 id="4.5%E3%80%81Quary">4.5、Quary</h3> 
<p>       应用程序可以查询pipline当前的运行状态，比如：以下代码用来查询当前播放的位置，和总的播放时间。</p> 
<pre><code class="language-cpp">GstFormat m_format = GST_FORMAT_TIME;
gint64 m_position , m_length;
if( gst_element_query_position(pipeline, &amp;m_format,&amp;m_position) &amp;&amp;
  gst_element_query_duration(pipeline, &amp;m_format, &amp;m_length))
{
        g_print("Current: %"GST_TIME_FORMAT"   Total: %" GST_TIME_FORMAT "r", 
            GST_TIME_ARGS(m_position),GST_TIME_ARGS(m_length));
}</code></pre> 
<h2 id="5%E3%80%81GStreamer%E5%85%83%E4%BB%B6%E7%8A%B6%E6%80%81">5、GStreamer元件状态</h2> 
<p>       一个元件在被创建后，它不会执行任何操作，通过改变元件的状态，才能使它做某些事情。元件有四种状态，每种状态都有其特定的意义，具体如下：</p> 
<blockquote> 
 <p><strong>GST_STATE_NULL 默认状态</strong>：没有分配任何资源，没有载入插件，不能处理数据；<br><strong>GST_STATE_READY 预备状态</strong>：分配或载入所有与流无关的资源(非硬件资源)，所有数据流的位置信息应该自动置0，如果数据流先前被打开过，它应该被关闭，并且其位置信息、特性信息应该被重新置为初始状态；<br><strong>GST_STATE_PAUSED 暂停状态</strong>：准备好全部资源，接受数据流，只是sink element暂停，收到数据不处理，只是block；<br><strong>GST_STATE_PLAYING 播放状态</strong>：准备好全部资源，接受并处理数据流；其实这个状态除了当前运行时钟外，其它与PAUSED状态一样，可以通过gst_element_set_state()来改变一个元件的状态，当元件处于GST_STATE_PLAYING状态，管道会开始自动处理数据。</p> 
</blockquote> 
<h2 id="6%E3%80%81GStreamer%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5">6、GStreamer中的几个关键概念</h2> 
<h3 id="6.1%E3%80%81%E8%AF%86%E5%88%AB%E6%B5%81%E7%9A%84MIME%E7%B1%BB%E5%9E%8B">6.1、识别流的MIME类型</h3> 
<p>       元件通过caps来描述其能处理的媒体格式，元件之间交互数据流通过caps协商，caps是一个mime类型或者一些特性集的组合。</p> 
<p class="img-center"><img alt="" height="234" src="https://images2.imgbox.com/6a/c0/Y1M2oOLz_o.png" width="658"></p> 
<p>       一个加载进系统的元件必须提供其源衬垫和接收衬垫支持的mime类型。通过Gstreamer注册中心可以知道目前注册的不同的元件，以及他们所期望得到的与他们能够产生的媒体类型，下图显示了管道中每个Pads所处理的MIME类型。</p> 
<h3 id="6.2%E3%80%81%E5%AA%92%E4%BD%93%E6%B5%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%EF%BC%88typefind%EF%BC%89">6.2、媒体流类型检测（typefind）</h3> 
<p>       通常当加载一个新的媒体流时，媒体的类型并不明了。这意味着选择一条管道来对媒体流进行解码之前，首先需要检测媒体流的类型。 GStreamer 使用了类型检测 (typefinding) 来达到此目的。类型检测是构建管道所必经的步骤。</p> 
<p>       首先它会一直读取数据流，在此期间，它会把数据提供给所有的实现了类型检测器 (typefinder) 的插件，当其中任何一个类型检测器识别出数据流，这个类型检测器元件将会发送一个信号，并开始像一个关卡 (passthrough)模块一样工作。如果数据流的类型没有被任何类型检测器识别出来，管道会发送一个错误信息，并终止所有正在处理该数据流的动作。一旦类型检测元件找到一个类型，应用程序将会使用该元件作为管道的一部分来解码媒体流。</p> 
<h3 id="6.3%E3%80%81%E6%95%B0%E6%8D%AE%E6%8E%A2%E6%B5%8B">6.3、数据探测</h3> 
<p>       探测是衬垫监听器的形象比喻，从技术上，探针仅仅是一个可以依附于衬垫的回调信号。这些信号默认是没有被发射(fired)的(不然的话会降低性能)，但是可以通过附加探针调用gst_pad_add_data_probe() 或类似的函数被激活，这些函数附加了信号处理器，并激活实际信号的发射。</p> 
<p>       同样地，你可以用 gst_pad_remove_data_probe () 或相关函数来删除信号处理器，也可以只是监听时间或缓冲区。 探针在管道的线程context运行，所以回调不应该阻塞，而且通常不能有异常的阻塞，否则会降低管道的性能，如果出现这样的缺陷，会导致死锁甚至崩溃。</p> 
<h3 id="6.4%E3%80%81%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B">6.4、插件加载流程</h3> 
<p>       如下图所示，基于插件的程序，其工作原理本质上都是通过读取动态库实现的，只需要每个动态库中实现某一个特定的接口就可以了，比如XX_init等，这里就是plugin_init。里面会有个像注册表一样的数据结构会存储所有的插件的信息。</p> 
<p class="img-center"><img alt="" height="1002" src="https://images2.imgbox.com/ef/34/re6GKbdH_o.png" width="833"></p> 
<h2 id="7%E3%80%81GStreamer%E5%BC%80%E5%8F%91%E7%A4%BA%E4%BE%8B-MP3%E6%96%87%E4%BB%B6%E6%92%AD%E6%94%BE%E5%99%A8">7、GStreamer开发示例-MP3文件播放器</h2> 
<p>       利用GStreamer框架提供的组件，来实现一个简单的MP3播放器。数据源元件负责从磁盘上读取数据，过滤器元件负责对数据进行解码，而接受器元件则负责将解码后的数据写入声卡，示例代码和注释如下：</p> 
<pre><code class="language-cpp">#include &lt;gst/gst.h&gt;
#include &lt;glib.h&gt;

//定义消息处理函数,
static gboolean bus_call(GstBus *bus,GstMessage *msg,gpointer data)
{
    GMainLoop *loop = (GMainLoop *) data;//主循环的指针，接受EOS消息时退出
    switch (GST_MESSAGE_TYPE(msg))
    {
        case GST_MESSAGE_EOS:
            g_print("End of streamn");
            g_main_loop_quit(loop);
            break;
        case GST_MESSAGE_ERROR:
        {
            gchar *debug;
            GError *error;
            gst_message_parse_error(msg,&amp;error,&amp;debug);
            g_free(debug);
            g_printerr("ERROR:%sn",error-&gt;message);
            g_error_free(error);
            g_main_loop_quit(loop);
            break;
        }
        default:
             break;
    }
    return TRUE;
}

int main(int argc,char *argv[])
{
    GMainLoop *loop;
    GstElement *pipeline,*source,*decoder,*sink;//定义组件
    GstBus *bus;
    gst_init(&amp;argc,&amp;argv); //初始化gstreamer
    loop = g_main_loop_new(NULL,FALSE);//创建主循环，在执行 g_main_loop_run后正式开始循环

    if(argc != 2)
    {
        g_printerr("Usage:%s &lt;mp3 filename&gt;n",argv[0]);
        return -1;
    }
    //创建管道和元件
    pipeline = gst_pipeline_new("audio-player"); //管道用来容纳元件
    source = gst_element_factory_make("filesrc","file-source");//数据源元件
    decoder = gst_element_factory_make("mad","mad-decoder");//过滤器元件
    sink = gst_element_factory_make("autoaudiosink","audio-output");//接收器元件

    if(!pipeline||!source||!decoder||!sink){
        g_printerr("One element could not be created.Exiting.n");
        return -1;
    }
    //设置 source的location 参数，即文件地址.
    g_object_set(G_OBJECT(source),"location",argv[1],NULL);
    //得到管道的消息总线
    bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline));
    //添加消息监视器
    gst_bus_add_watch(bus,bus_call,loop);
    gst_object_unref(bus);
    //把元件添加到管道中。管道是一个特殊的组件，可以更好的让数据流动
    gst_bin_add_many(GST_BIN(pipeline),source,decoder,sink,NULL);
    //通过衬垫依次连接元件
    gst_element_link_many(source,decoder,sink,NULL);
    //启动管道，开始播放
    gst_element_set_state(pipeline,GST_STATE_PLAYING);
    g_print("Runningn");
    //开始循环
    g_main_loop_run(loop);
    g_print("Returned,stopping playbackn");
    //终止管道，释放资源
    gst_element_set_state(pipeline,GST_STATE_NULL);
    gst_object_unref(GST_OBJECT(pipeline));
    return 0;
}</code></pre> 
<p>编译运行</p> 
<blockquote> 
 <p>gcc -Wall $(pkg-config --cflags --libs gstreamer-0.10) -g test2.c -o test2<br> ./test2 /home/phinecos/test.mp3</p> 
</blockquote> 
<h2 id="8%E3%80%81%E6%9C%80%E5%90%8E">8、最后</h2> 
<p>       本文总结了多媒体框架GStreamer一些基本概念及流程，希望能给使用GStreamer开源库的朋友提供一个借鉴或参考。</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>