<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C&#43;&#43;万字自学笔记 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;万字自学笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-tomorrow-night">
                    
                        
                    
                    <p>[@TOC]</p> 
<h1>
<a id="_C_1"></a>一、 C++基础</h1> 
<p>C++的IDE有CLion、Visual Studio、DEV C++、eclipse等等，这里使用<a href="https://www.jetbrains.com/clion/">CLion</a>进行学习。</p> 
<h2>
<a id="0_C_7"></a>0. C++初识</h2> 
<h3>
<a id="01_C_9"></a>0.1 第一个C++程序</h3> 
<p>编写一个C++程序总共分为4个步骤</p> 
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

int main()
{
	using namespace std;
	cout &lt;&lt; "Come up and C++ me some time.";
	cout &lt;&lt; endl;
	cout &lt;&lt; "You won't regret it!" &lt;&lt; endl;
	return 0;
}
</code></pre> 
<ul>
<li>C语言中省略int只写main()相当于函数的类型为int，相当于int main(),C++中不建议省略</li>
<li>C++中int main()等价于int main(void)</li>
<li>C++中main函数可以省略return 0;</li>
</ul> 
<h3>
<a id="02__39"></a>0.2 注释</h3> 
<p><strong>作用</strong>：在代码中加一些说明和解释，方便阅读代码</p> 
<p><strong>两种格式</strong></p> 
<ol>
<li>
<strong>单行注释</strong>：<code>//注释</code> 
  <ul><li>通常放在一行代码的上方或者一条语句的末尾，对该行代码进行说明</li></ul> </li>
<li>
<strong>多行注释</strong>：<code>/*多行注释*/</code> 
  <ul><li>通常放在一行代码上方，对该行代码进行整体说明</li></ul> </li>
</ol> 
<blockquote> 
 <p>编译器在编译代码时会忽略注释的内容</p> 
</blockquote> 
<h3>
<a id="03__60"></a>0.3 变量</h3> 
<p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p> 
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p> 
<p><strong>变量声明的语法</strong></p> 
<pre><code class="prism language-C++">typename variablename;

int year;
</code></pre> 
<p><strong>初始化</strong></p> 
<pre><code class="prism language-C++">//C++98中可以使用初始化数组的方式初始化变量
int num = {10};
//C++11中这种用法更常见,也可以不使用=
int num{10};
//{ }也可以不包含东西
int num{};//此时变量的值初始化为0
</code></pre> 
<blockquote> 
 <p>在C++11中可以将 { }大括号初始化器用于任何类型({}前面可以使用=，也可以不使用=)，这是一种通用的初始化语法</p> 
</blockquote> 
<hr> 
<h3>
<a id="03_95"></a>0.3常量</h3> 
<p><strong>作用</strong>：用于记录程序中不可更改的数据</p> 
<p>C++定义常量的两种方式</p> 
<ol>
<li>#define 宏常量：<code>#define 常量名 常量值</code> 
  <ul><li>通常在文件上方定义，表示一个常量</li></ul> </li>
<li>
<strong>const</strong>修饰的变量<code>const 数据类型 常量名 = 常量值</code> 
  <ul><li>通常在变量定义前加关键字const，修饰该变量为常量，不可修改</li></ul> </li>
</ol> 
<p>exp：</p> 
<pre><code class="prism language-C++">//1、宏常量
#define day = 7;

int main()
{
	cout&lt;&lt;"一周总共有"&lt;&lt;day&lt;&lt;"天"&lt;&lt;endl;
	//day = 8;会报错
	
	//2. const修饰变量
	const int month = 12;
	cout&lt;&lt;"一年总共有"&lt;&lt;month&lt;&lt;"个月"&lt;&lt;endl;
    //month = 24;报错，常量不可更改
}
</code></pre> 
<h3>
<a id="04__124"></a>0.4 关键字</h3> 
<p><strong>作用</strong>：关键字时C++中预先保留的标识符</p> 
<p>C++关键字如下：</p> 
<table>
<thead><tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr></thead>
<tbody>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</p> 
</blockquote> 
<h3>
<a id="05__157"></a>0.5 标识符命名规则</h3> 
<p><strong>作用</strong>：C++规定给变量和常量命名有一定的规则</p> 
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul> 
<blockquote> 
 <p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p> 
</blockquote> 
<h2>
<a id="1__176"></a>1. 数据类型和运算符</h2> 
<h3>
<a id="11__182"></a>1.1 数据类型</h3> 
<p>创建一个变量或者常量时必须指出相应的数据类型，否则无法给变量分配内存空间</p> 
<p>数据类型存在的意义是方便编译器分配空间</p> 
<h4>
<a id="111__190"></a>1.1.1 整型</h4> 
<table>
<thead><tr>
<th>变量类型</th>
<th>所占字节大小</th>
</tr></thead>
<tbody>
<tr>
<td>short</td>
<td>至少16位 64位windows下sizeof short = 2字节=16位，同下</td>
</tr>
<tr>
<td>int</td>
<td>至少与short一样长 sizeof int = 4，32位</td>
</tr>
<tr>
<td>long</td>
<td>至少32位且至少与int一样长 sizeof long = 4，32位</td>
</tr>
<tr>
<td>long long</td>
<td>至少64位且至少与long一样长 sizeof long long = 8，64位</td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>无符号类型：</p> 
 <ol>
<li> <p>在变量类型前加unsigned可以使之称为无符号类型的变量，如果short类型变量所占字节大小为2，所占位数16位，则第一位用于表示变量的正负，则可用位数为15位，能表示的范围为-2<sup>15~2</sup>15，如果添加了unsigned关键字，则无符号位，可以表示的数据大小为0~2^16，无负数。</p> </li>
<li> <p>unsigned是unsigned int的缩写</p> </li>
<li> <p>无符号类型的优点是可以增大变量能够存储的范围(仅当数值不为负时)</p> </li>
</ol> 
</blockquote> 
<blockquote> 
 <p>一个整型数据在不设置数据类型的情况下默认为int型，如果不想使用int可以通过设置后缀可以为一个值确定数据类型</p> 
 <pre><code>unsigned可以用u表示
long可以用L表示
unsigned和long的后缀可以叠加使用：
ul表示unsigned long
ull表示unsigned long long
</code></pre> 
 <p>不区分大小写</p> 
</blockquote> 
<blockquote> 
 <p>查看数据类型所占空间大小使用sizeof关键字</p> 
 <pre><code class="prism language-C++">int main() {

	cout &lt;&lt; "short 类型所占内存空间为： " &lt;&lt; sizeof(short) &lt;&lt; endl;

	cout &lt;&lt; "int 类型所占内存空间为： " &lt;&lt; sizeof(int) &lt;&lt; endl;

	cout &lt;&lt; "long 类型所占内存空间为： " &lt;&lt; sizeof(long) &lt;&lt; endl;

	cout &lt;&lt; "long long 类型所占内存空间为： " &lt;&lt; sizeof(long long) &lt;&lt; endl;

	system("pause");

	return 0;
}
</code></pre> 
</blockquote> 
<p><strong>C++中进制的表示</strong></p> 
<table>
<thead><tr>
<th>十进制</th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td>八进制</td>
<td>以0开头</td>
</tr>
<tr>
<td>十六进制</td>
<td>以0x开头</td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>不管数据以几进制的形式表现出来，在内存中都是以二进制进行存储</p> 
</blockquote> 
<p>C++中以四种进制进行输出</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bitset&gt;</span></span>
 
using namespace std<span class="token punctuation">;</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//二进制32位输出</span>
    cout<span class="token operator">&lt;&lt;</span>oct<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>dec<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>hex<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4>
<a id="112_273"></a>1.1.2浮点型（实型）</h4> 
<p>浮点数能表示带小数的数字</p> 
<p>浮点数有两种表示方法：</p> 
<ol>
<li> <p>标准小数点表示法</p> <p>exp:</p> <pre><code>3.14
12.3
</code></pre> </li>
<li> <p>科学计数法</p> <p>exp:</p> <pre><code>3.45e6
10.12E-6
5.98E+10
</code></pre> </li>
</ol> 
<p>同科学计数E、e(不区分大小写)，表示10的多少次方</p> 
<pre><code class="prism language-C++">int main()
{
	float f1 = 3.14f;
    double d1 = 3.14;
    
    cout&lt;&lt;f1&lt;&lt;endl;
    cout&lt;&lt;d1&lt;&lt;endl;
    
    cout&lt;&lt;"float sizeof = "&lt;&lt;sizeof(f1)&lt;&lt;endl;
    cout&lt;&lt;"double sizeof = "&lt;&lt;sizeof(d1)&lt;&lt;endl;
    
    //科学计数法
    float f2 = 3e2;//3*10^2
    cout&lt;&lt;"f2 = "&lt;&lt;f2&lt;&lt;endl;
    
    float f3 = 3e-2;//3*0.1^2
    cout&lt;&lt;"f3 = "&lt;&lt;f3&lt;&lt;endl;
    
}
</code></pre> 
<p>3种浮点类型：</p> 
<table>
<thead><tr>
<th>float</th>
<th>至少32位64位windows中：sizeof float = 4字节32位,7位有效数字</th>
</tr></thead>
<tbody>
<tr>
<td>double</td>
<td>至少48位sizeof double = 8，64位，15~16位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>sizeof long double = 16，128位</td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>默认情况下浮点数是double类型的，如果想使用float类型，可以在值后面加上后缀F或者f</p> 
 <p>使用long double类型可以在值后面加上L或者l，因为l与1不好分辨，建议使用L</p> 
</blockquote> 
<h4>
<a id="113__345"></a>1.1.3 字符型</h4> 
<p><strong>作用</strong>：字符型变量用于显示单个字符</p> 
<p><strong>语法</strong>：<code>char ch = 'a';</code></p> 
<blockquote> 
 <ol>
<li>使用单引号</li>
<li>单引号内只能有一个字符</li>
</ol> 
</blockquote> 
<p>char类型常用于表示字符与小整数，大小为<strong>1个字节</strong>，表示范围-128~127</p> 
<p>char类型也可以使用unsigned关键字修饰，unsigned char表示的范围是0~255</p> 
<p>char型使用单引号 ’ ’ 括起来</p> 
<p>exp:</p> 
<pre><code class="prism language-C++">char ch = 'a';
</code></pre> 
<p>字符型变量并不是把字符本身放到内存中，而是将对应的ASCII编码放入存储单元</p> 
<p>ASCII码表格：</p> 
<table>
<thead><tr>
<th>
<strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th>
<strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th>
<strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th>
<strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr></thead>
<tbody>
<tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>"</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{<!-- -->
</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody>
</table> 
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p> 
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul> 
<p><strong>转义字符</strong></p> 
<p><strong>作用</strong>：用于表示一些不能显示出来的ASCII字符</p> 
<p>exp:</p> 
<table>
<thead><tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th>
<strong>ASCII</strong>码值（十进制）</th>
</tr></thead>
<tbody>
<tr>
<td>a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>t</strong></td>
<td><strong>水平制表(HT) （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td><strong>\</strong></td>
<td><strong>代表一个反斜线字符""</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>’</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>"</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td></td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>xhh</td>
<td>16进制转义字符，h范围0<sub>9，a</sub>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody>
</table> 
<p>示例：</p> 
<pre><code class="prism language-c++">int main()
{
	cout&lt;&lt;"\"&lt;&lt;endl;
    cout&lt;&lt;"tHello"&lt;&lt;endl;
    cout&lt;&lt;"n"&lt;&lt;endl;
}
</code></pre> 
<h4>
<a id="114__bool_456"></a>1.1.4 布尔型 bool</h4> 
<p><strong>作用</strong>：布尔数据类型代表真或假的值</p> 
<p><strong>语法</strong>：<code>bool x;</code></p> 
<p>布尔型有两个值：</p> 
<ul>
<li>true —真(本质是1)</li>
<li>false —假(本质是0)</li>
</ul> 
<p>占用一个字节</p> 
<p>exp:</p> 
<pre><code class="prism language-C++">int main()
{
    bool flag = true;
    cout&lt;&lt;flag&lt;&lt;endl;//1
    
    flag = false;
    cout&lt;&lt;flag&lt;&lt;endl;//0
    
    cout&lt;&lt;"sizeof bool = "sizeof(bool)&lt;&lt;endl;
}
</code></pre> 
<hr> 
<h3>
<a id="12__494"></a>1.2 类型转换</h3> 
<p>三种类型转换：</p> 
<ul>
<li>初始化和赋值时进行的转换</li>
<li>表达式中包含不同的类型时进行的转换</li>
<li>参数传递给函数时进行的转换</li>
</ul> 
<h4>
<a id="121__502"></a>1.2.1. 初始化类型转换</h4> 
<p>C++允许将一种类型的值赋给另一种类型的变量，这时值会自动转换为变量的类型</p> 
<p>exp:</p> 
<pre><code>int a = 1.23;//double赋给int，结果转换为int，值为1
float a = 1;//int赋给float，结果转换为float 值为1.0
</code></pre> 
<blockquote> 
 <p>将表示范围小的类型值赋给表示范围大的类型没有问题，将表示范围大的类型的值赋给表示范围小的类型时，会出现失真</p> 
 <p><img src="https://images2.imgbox.com/e6/8e/swdXODWR_o.png" alt=""></p> 
</blockquote> 
<h4>
<a id="2__517"></a>2. 表达式中的转换</h4> 
<p>当表达式中存在多种类型时，一些类型会自动进行类型转换，一些类型在遇到某些类型时才进行转换。</p> 
<p>整型提升：bool、unsigned char、char、short会自动转换为int</p> 
<p>当表达式中存在表示范围比int大的类型时，较小的类型会转换为较大的类型。</p> 
<h4>
<a id="3__525"></a>3. 传递参数时</h4> 
<p>传递参数时对char、short进行整型提升</p> 
<h4>
<a id="_529"></a>强制类型转换</h4> 
<p>语法：</p> 
<ul>
<li>
<code>(typename)value</code>来自C语言的用法</li>
<li>
<code>typename(value)</code>来自C++的用法，使其更像是函数的用法</li>
<li>
<code>static_cast&lt;typename&gt; (value)</code> C++中的强制转换符</li>
</ul> 
<p>exp:</p> 
<pre><code class="prism language-C++">(int)1.5;//C语言中的方式
int(1.5);//C++中的方式
</code></pre> 
<blockquote> 
 <p>在C++中使用typeid(typename).name()查看数据类型名称</p> 
 <p>exp:</p> 
 <pre><code class="prism language-C++">cout&lt;&lt;typeid(int).name();//使用类型名查看

int a;
cout&lt;&lt;typeid(a).name();//使用变量名
</code></pre> 
</blockquote> 
<hr> 
<h4>
<a id="C_561"></a>C++中的缩窄转换</h4> 
<p>C++中的列表初始化（使用{}进行初始化）不允许缩窄转换(narrawing convertions)，即变量的类型无法表示赋给它的值。</p> 
<ul>
<li>从<a href="https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9&amp;spm=1001.2101.3001.7020">浮点</a>数转换为整数</li>
<li>从取值范围大的浮点数转换为取值范围小的浮点数（在编译期可以计算并且不会溢出的<a href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;spm=1001.2101.3001.7020">表达式</a>除外）</li>
<li>从整数转换为浮点数（在编译期可以计算并且转换之后值不变的表达式除外）</li>
<li>从取值范围大的整数转换为取值范围小的整数（在编译期可以计算并且不会溢出的表达式除外）</li>
</ul> 
<h4>
<a id="Cauto_572"></a>C++中的auto声明</h4> 
<p>auto是C++11中根据初始值类型推断变量的类型的关键字</p> 
<p>作用：在初始化声明中如果使用auto，而不指定变量的类型，编译器会把变量的类型设置成与初始值相同</p> 
<p>常用于STL中</p> 
<p>exp:</p> 
<pre><code class="prism language-C++">vector&lt;double&gt; scores;
vector&lt;double&gt;::iterator v = scores.begin();
//可以简写为
auto v = scores.begin();
</code></pre> 
<h3>
<a id="_591"></a>算术运算符</h3> 
<p><strong>加法：+</strong></p> 
<hr> 
<p><strong>减法：-</strong></p> 
<hr> 
<p><strong>乘法：</strong>*</p> 
<hr> 
<p><strong>除法：/</strong></p> 
<p>除法分为：</p> 
<ul><li>整数和整数</li></ul> 
<p><strong>即使使用float接收参数结果也是取整的，因为运算符进行运算时就已经根据运算规则进行了取整</strong></p> 
<p>C：</p> 
<pre><code class="prism language-c++">float a = 9/2;
cout&lt;&lt;a&lt;&lt;endl;

结果：
4
</code></pre> 
<ul><li>整数和浮点数</li></ul> 
<p>根据运算规则，操作数会自动类型转换，int转float再运算</p> 
<ul><li>浮点数和浮点数</li></ul> 
<hr> 
<p><strong>求模：%</strong></p> 
<hr> 
<h3>
<a id="_661"></a>算术运算符的优先级</h3> 
<h3>
<a id="_663"></a>递增递减运算符</h3> 
<table>
<thead><tr>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td>++</td>
<td>自增</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
</tr>
</tbody>
</table> 
<h3>
<a id="_672"></a>组合赋值运算符</h3> 
<table>
<thead><tr>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td>+=</td>
<td></td>
</tr>
<tr>
<td>-=</td>
<td></td>
</tr>
<tr>
<td>*=</td>
<td></td>
</tr>
<tr>
<td>/=</td>
<td></td>
</tr>
<tr>
<td>%=</td>
<td></td>
</tr>
</tbody>
</table> 
<h3>
<a id="_682"></a>关系运算符</h3> 
<p>关系运算符不能用于C风格的字符串，可以用于string类型的字符串，对于关系表达式，如果判断结果为真，则返回true，如果为假返回false，对于C风格的字符串，如果使用 == 运算符进行判断则判断两者的地址是否相等。如果要判断内容是否相等，可以使用strcmp()函数，该函数接收两个字符串地址作为参数。</p> 
<table>
<thead><tr>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
</tbody>
</table> 
<h2>
<a id="2__699"></a>2. 数组</h2> 
<h3>
<a id="_701"></a>数组的声明和初始化</h3> 
<p><strong>数组的声明</strong>：<code>typename arrayname[arraySize];</code></p> 
<p>exp:</p> 
<pre><code class="prism language-C++">int array[10];
</code></pre> 
<p><strong>数组的初始化：</strong></p> 
<ol><li>使用逗号分隔的值列表(初始化列表)：<code>{}</code>
</li></ol> 
<pre><code class="prism language-C++">int array[3] = {1,2,3};
</code></pre> 
<ol start="2"><li>使用数组下标为数组元素赋值</li></ol> 
<pre><code class="prism language-C++">int array[3];
array[0] = 0;
array[1] = 1;
array[2] = 2;
</code></pre> 
<p>如果初始化数组时 [ ] 中为空则编译器自动计算元素个数</p> 
<pre><code class="prism language-C++">int array[] = {0};
</code></pre> 
<p>注意事项：</p> 
<ul>
<li> <p>只有在数组定义时才能进行初始化。</p> </li>
<li> <p>如果不为数组赋值，则数组中的值则是该数组内存单元中遗留的数据。</p> </li>
<li> <p>只要将数组的一部分进行初始化，则编译器将其他的部分初始化为0，如果初始化一个为0的数组则将首个元素设置为0即可。</p> </li>
</ul> 
<p><strong>C++11数组初始化</strong></p> 
<p>C++11中新增列表初始化( { } )的方式</p> 
<ul>
<li>可以不加 =</li>
<li>不允许缩窄转换</li>
<li>可以在大括号内不包含任何东西,所有的值初始化为0</li>
</ul> 
<p>exp:</p> 
<pre><code class="prism language-C++">int array[] {};
</code></pre> 
<h3>
<a id="_763"></a>二维数组</h3> 
<p>二维数组的定义方式：</p> 
<pre><code class="prism language-C++">int arr[][4] = {
        {1,2,3},
        {4,5,6},
        {7,8,9},
        {10,11,12}
};


int arr2[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
</code></pre> 
<blockquote> 
 <ol>
<li> <p>两个中括号必须有一个有值，否则编译器无法确定二维数组的排列方式</p> </li>
<li> <p>二维数组在内存空间中的排列方式与一维数组一致，都是连续的内存空间，编译器将其分为几个一维数组并且每个一维数组中的元素又包含了一个一维数组</p> </li>
<li> <p>在一维数组中数组名是<strong>指向数组的起始地址的指针</strong>，也是第1个元素的地址，在二维数组中同理，数组名<code>arr=&amp;arr[0]</code>,因为<code>arr[0]</code>也是一个一维数组，所以数组名也等于<code>&amp;arr[0][0]</code>,但本质上还是<code>arr[0][0]</code>的地址。因为对<code>arr</code>解引用两次才能取到值</p> </li>
<li> <p>使用指针的方式访问数组中的元素：</p> <pre><code class="prism language-C++">*(*(arr+1)+1)取的是arr[1][1]的值

arr:arr是一个指针，指针存放的是arr[0]的地址

arr+1:指针+1表示指针指向的地址向后移动1 * sizeof(typename)位

*(arr+1):指针解引用出来是arr[1]这个地址，同时arr[1]也是一个一维数组，arr[1]相当于数组名，也是个指针，指向arr[1]这个数组的第一个元素arr[1][0]

*(arr+1)+1:arr[1]这个数组所指向的地址arr[1][0]向后移动1 * sizeof(typename)位指向arr[1][1]这个地址

*(*(arr+1)+1):将指向arr[1][1]这个地址的指针解引用得到arr[1][1]这个地址中的值
</code></pre> </li>
</ol> 
</blockquote> 
<h3>
<a id="_813"></a>字符串</h3> 
<p>字符串是一个或多个字符的序列，是用双引号括起来的。</p> 
<p>exp：</p> 
<pre><code>"Today is Thursday!"
</code></pre> 
<p>C语言中没有指定存储字符串的基本数据类型，C语言中的字符串都是由char类型的数组组成的，字符串的末尾一定是以’’结束的，因此数组的容量必须比字符的数量多1</p> 
<p>字符串有两种声明方式：</p> 
<ul>
<li>使用char数组，C语言的方式</li>
<li>使用string类，C++的方式</li>
</ul> 
<p>C风格的字符串：</p> 
<pre><code class="prism language-C++">char str[] = "xxx";
char str[] = {'a','b','c'};

char *str = "abcd";
</code></pre> 
<blockquote> 
 <p>因为C风格的字符串本质是一个数组，所以除了使用引号的方式进行声明之外，还可以使用数组的初始化方式进行初始化。</p> 
 <p>C风格的字符串与char数组的区别是字符串有内置的结束字符 <code>''</code></p> 
</blockquote> 
<p>C++风格的字符串：</p> 
<pre><code class="prism language-C++">string str = "xxx";
</code></pre> 
<blockquote> 
 <p>C++中使用string类需要包含string头文件，头文件iostream中已经隐式的包含了这个头文件。</p> 
 <p>string类在命名空间std中</p> 
</blockquote> 
<p>string类相比于char数组有很多优势，比如：</p> 
<ul>
<li>可以将一个字符串赋值给另一个字符串</li>
<li>可以使用+，=，+=，==等操作符</li>
<li>不用考虑数组内存不足的问题</li>
</ul> 
<p>String 类型对象包括三种求解字符串长度的函数：size() 和 length()、 maxsize() 和 capacity()：</p> 
<ul>
<li>size() 和 length()：这两个函数会返回 string 类型对象中的字符个数，且它们的执行效果相同。</li>
<li>max_size()：max_size() 函数返回 string 类型对象最多包含的字符数。一旦程序使用长度超过 max_size() 的 string 操作，编译器会拋出 length_error 异常。max_size = 4611686018427387903</li>
<li>capacity()：该函数返回在重新分配内存之前，string 类型对象所能包含的最大字符数</li>
</ul> 
<h2>
<a id="3__875"></a>3. 结构体</h2> 
<p>语法：</p> 
<pre><code class="prism language-C++">struct stname{
	typename1 variable1;
	typename2 variable2;
};

stname s {value1,value2};//C++中的初始化列表

cout&lt;&lt;s.variable1&lt;&lt;endl;//使用成员运算符 . 访问结构体元素
</code></pre> 
<blockquote> 
 <p>C++中初始化结构体时可以省略struct关键字</p> 
 <p>而c语言中需要加struct关键字</p> 
</blockquote> 
<p>常用typedef关键字与结构体一起使用</p> 
<pre><code class="prism language-c++">typedef struct student{
    string name;
    int age;
}stu;//给student这个结构体起一个别名
</code></pre> 
<p><strong>结构体的内存对齐</strong></p> 
<ul>
<li> <p>结构体成员的内部起始地址能够被其所占字节的大小整除</p> </li>
<li> <p>结构体的大小是最大成员所占字节的整数倍</p> </li>
<li> <p>对于结构体中的结构体要按照结构体展开之后的内存对齐来处理</p> </li>
<li> <p>人为制定规则，<code>#pragma pack(n)</code>按照n进行对齐，覆盖第一条规则，如果n比原来的规则大，则用小的规则</p> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">test</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	<span class="token keyword">char</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//结果是2+4+2=8</span>
</code></pre> </li>
<li> <p><strong>不内存对齐</strong>：用于单片机等</p> <p><code>#pragma pack(1)</code></p> </li>
</ul> 
<p><strong>结构体数组</strong></p> 
<p>声明：</p> 
<pre><code class="prism language-C++">stname s[] = {
    {value1,value2},
    {v1,v2}
};
</code></pre> 
<h4>
<a id="_947"></a>结构体指针&amp;结构体数组&amp;结构体指针数组</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

using namespace std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">pstruct</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">double</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//创建两个结构体变量</span>
	pstruct s1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	pstruct s2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">//创建两个结构体指针</span>
	pstruct <span class="token operator">*</span>ps1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span>
	pstruct <span class="token operator">*</span>ps2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s2<span class="token punctuation">;</span>

	<span class="token comment">//创建一个结构体数组</span>
	pstruct sarr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">//创建一个结构体指针数组</span>
	pstruct <span class="token operator">*</span>sparr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>ps1<span class="token punctuation">,</span>ps2<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>


<span class="token punctuation">}</span>

</code></pre> 
<h2>
<a id="4union_996"></a>4.共用体（union）</h2> 
<p>共用体与结构体类似，能存储多种数据类型，但是同时只能存一种数据类型。</p> 
<pre><code class="prism language-C++">    union u{
        int i_value;
        float f_value;
        double d_value;
    };
    u u1{};
    u1.d_value=3.14;
</code></pre> 
<p>共用体常用于节省内存</p> 
<h2>
<a id="5__1012"></a>5. 枚举</h2> 
<p>枚举</p> 
<pre><code>enum spectrum {red,black,green,blue};
</code></pre> 
<h2>
<a id="6__1022"></a>6. 指针</h2> 
<p>指针是一种变量，指针中存储的值为地址。</p> 
<p>指针的声明：</p> 
<p><code>typename* p;</code></p> 
<p>exp:</p> 
<pre><code>int *p;//C语言中常用的格式
int* p;//C++中常用的格式
int * p;//
int*p;//这几种格式都可以

int* p1,p2;//注意: p2的类型是int，对于每个指针变量名都需要使用一个*
</code></pre> 
<blockquote> 
 <p>int的意思是 指针是指向int类型数据的指针</p> 
</blockquote> 
<p>指针的初始化：</p> 
<pre><code class="prism language-C++">int* p = 地址;//因为指针中存储的是地址，所以初始化需要给指针一个地址，可以使用 &amp;变量 的方式,也可以使用数组名等其他方式，总之需要是一个地址。如果不为其赋初值，最好使其指向NULL，防止野指针。
</code></pre> 
<p>指针中处理存储数据的策略是解引用，*运算符被称为间接值(indirect value)或解除引用(dereferencing)运算符,将其放在指针变量的前面可以获得指针指向的地址中存储的值</p> 
<h3>
<a id="_1055"></a>指针常量和常量指针</h3> 
<p><strong>左定值，右定向</strong></p> 
<blockquote> 
 <p>const在*左边值是常数，const在*右边指针的指向是固定的</p> 
</blockquote> 
<p>指针常量：</p> 
<p>指针常量的含义是<strong>指针类型的常量</strong>，指针常量中指针自身的值是一个常量，即指针指向的地址是一个常量，不可修改，<code>在定义时必须初始化</code></p> 
<pre><code class="prism language-C++">    int a = 10,b = 20;
    int* const p = &amp;a;
    cout&lt;&lt;"a = "&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;"*p = "&lt;&lt;*p&lt;&lt;endl;
    //p = &amp;b;报错：cannot assign to variable 'p' with const-qualified type 'int *const'不能复制给具有const属性的变量p
    *p = 20;//可以修改地址指向的值但是不可以修改地址
    cout&lt;&lt;"修改后*p = "&lt;&lt;*p&lt;&lt;endl;
</code></pre> 
<blockquote> 
 <p>a = 10<br> <em>p = 10<br> 修改后</em>p = 20</p> 
 <p>可以修改指针指向的值，不可以修改地址</p> 
 <p>const在 p 前就是修饰p，p是地址，所以地址不可以改</p> 
</blockquote> 
<p>常量指针：</p> 
<p>常量指针的含义是指向常量的指针</p> 
<pre><code class="prism language-C++">    int a = 10,b = 20;
    const int *p = &amp;a;

    cout&lt;&lt;"*p = "&lt;&lt;*p&lt;&lt;endl;
    p = &amp;b;//可以修改指针的指向
    //*p = 20;报错：Read-only variable is not assignable 只读变量不可赋值
</code></pre> 
<h3>
<a id="const_1104"></a>const修饰符</h3> 
<p>const限定符用于将变量变为常量</p> 
<p><strong>初始化时一定要赋值</strong></p> 
<pre><code class="prism language-C++">    const int c1 = sum(1,2);//运行时初始化
    const int c2 = c1;
    const int c3 = 1;//编译时初始化

	const int c4;//不正确
</code></pre> 
<p>const与引用</p> 
<pre><code class="prism language-C++">    const int num = 10;
    int &amp;c1 = num;//报错，因为引用可以修改变量值，但是这是个常量，不能修改，需要加const修饰
    const int &amp;c1 = num;
</code></pre> 
<pre><code class="prism language-C++">double pi = 3.14;
const int &amp;c1 = pi;

实际上发生了自动类型转换
int temp = pi;
const int &amp;c1 = temp;
</code></pre> 
<p><strong>extern关键字</strong></p> 
<p>作用：当在一个文件中声明了一个变量而想在所有文件中使用的时候需要在变量定义前加extern关键字</p> 
<h3>
<a id="new_1145"></a>new操作符</h3> 
<ul>
<li>C++中利用new在堆区开辟数据，利用delete释放</li>
<li>语法：<code>new 数据类型</code>
</li>
<li>利用new创建的数据会返回改数据对应类型的指针</li>
<li>
</li>
</ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//利用new关键字开辟堆区</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//不会自动释放</span>
	cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	
	<span class="token comment">//释放</span>
	delete p<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//内存已经被释放了</span>

	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>使用delete只能删除使用new产生的内存</p> 
</blockquote> 
<p>在堆区new一个数组</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//使用new关键字返回的是指针</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> <span class="token operator">*</span>arr <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//给数组赋值</span>
    <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//打印数组</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//释放数组</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>
    arr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>释放数组对象时使用delete[]</p> 
 <p>在C++中数组名表示的是地址</p> 
</blockquote> 
<p>指针指向的数组的访问</p> 
<pre><code>直接使用指针名[number]即可访问，不需要*指针名
指针名+1表示指针指向数组下一个元素，解引用*(p+1)表示下一个值
</code></pre> 
<p>在数组中数组名和指针的区别：</p> 
<p>数组名是常量而指针是变量</p> 
<h2>
<a id="7__1226"></a>7. 循环和关系表达式</h2> 
<h3>
<a id="for_1228"></a>for循环</h3> 
<pre><code class="prism language-C++">for(int i=0;i&lt;5;i++)
{
	cout&lt;&lt;"第"&lt;&lt;i&lt;&lt;"次输出"&lt;&lt;endl;
}
</code></pre> 
<blockquote> 
 <p>程序执行的顺序：</p> 
 <ol>
<li>设置初始值，初始化循环变量 i</li>
<li>执行测试，判断 i 是否符合要求</li>
<li>执行循环体内容，打印输出</li>
<li>更新用于测试的值， i++</li>
</ol> 
</blockquote> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

int main()
{
    char ch[] = "abcd";
    for(int i=0, j=strlen(ch)-1; i&lt;j; ++i,--j)
    {
        char temp;
        temp = ch[i];
        ch[i] = ch[j];
        ch[j] = temp;
    }
    for(int i=0;i&lt;4;i++)
    {
        cout&lt;&lt;ch[i]&lt;&lt;endl;
    }
}
</code></pre> 
<h4>
<a id="forC11rangedbase_1266"></a>基于范围的for循环（C++11）（ranged-base）</h4> 
<p>C++11中引入的新特性，可以遍历容器或者其他序列的所有元素</p> 
<p>语法：<code>for(声明:表达式){语句}</code></p> 
<p>声明建议使用<code>auto</code>进行自动类型推断，如果要修改值可以使用引用的方式</p> 
<pre><code class="prism language-C++">double arr = {12.1,3.14,5.23,3.56};
for(double x:arr)
{
	cout&lt;&lt;x&lt;&lt;endl;
}


for(double &amp;x:arr)//引用的方式
{
	cout&lt;&lt;x&lt;&lt;endl;
}
</code></pre> 
<h4>
<a id="while_1288"></a>while循环</h4> 
<pre><code class="prism language-C++">while(条件表达式)
{
	循环体;
}
</code></pre> 
<h4>
<a id="do_while_1299"></a>do while循环</h4> 
<p>do…while与while的区别是不管表达式是否成立do while<strong>至少执行一次</strong></p> 
<pre><code class="prism language-C++">do
{
	循环体;
}
while(条件表达式);
</code></pre> 
<p>do while循环至少执行一次</p> 
<h2>
<a id="8__1313"></a>8. 分支语句和逻辑运算符</h2> 
<p>语法：</p> 
<pre><code class="prism language-C++">if(条件表达式)
{
	语句;
}
</code></pre> 
<p>if-else语句：</p> 
<pre><code class="prism language-C++">if(条件表达式)
{
	语句1;
}
else
{
	语句2;
}
</code></pre> 
<p>if else if else语句：</p> 
<pre><code class="prism language-C++">if(条件表达式)
{
	语句1;
}
else
	if(条件表达式2)
	{
		语句2;
	}
	else
		if(条件表达式3)
		{
			语句3;
		}
		else
		{
			语句4;
		}
</code></pre> 
<blockquote> 
 <p>其实是多个if else的嵌套，一般写为下面这种形式</p> 
 <pre><code class="prism language-C++">if(条件表达式)
{
	语句1;
}
else if(条件表达式2)
{
	语句2;
}
else if(条件表达式3)
{
	语句3;
}
else
{
	语句4;
}
</code></pre> 
</blockquote> 
<h4>
<a id="_1381"></a>逻辑表达式</h4> 
<p><strong>逻辑或 ||</strong>，||两边有一个或者都为真时返回真，可以使用or替代</p> 
<p>用法：</p> 
<pre><code class="prism language-C++">5&gt;3||5&lt;4
</code></pre> 
<p>因为||为顺序点，所以运算符左边的表达式优先于右边的表达式</p> 
<blockquote> 
 <pre><code>i++ &lt; 6 || i == j;
</code></pre> 
 <p>假设 i 的值为10，则在 i 与 j 进行比较时，i 的值为11</p> 
</blockquote> 
<p>||左边表达式为真时右边的表达式不会执行</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

int main()
{
    1||cout&lt;&lt;"||后边不执行"&lt;&lt;endl;
    0||cout&lt;&lt;"||后边执行"&lt;&lt;endl;
}
//结果输出第二句
</code></pre> 
<p>**逻辑与&amp;&amp;**可以使用and替代</p> 
<p>两侧的表达式都为真则返回真</p> 
<p>第一个为假则直接返回假，不再判断右侧表达式</p> 
<p>用于确定取值范围：</p> 
<pre><code class="prism language-C++">if(age&gt;17&amp;&amp;age&lt;35)
{
	...
}
</code></pre> 
<p><strong>逻辑非</strong>也可以使用not替代</p> 
<p>！将后面的表达式真值取反</p> 
<p>总结：</p> 
<p>&amp;&amp;和||优先级低于所有关系运算符和算术运算符</p> 
<p>!的优先级高于所有关系运算符和算术运算符</p> 
<h4>
<a id="_1445"></a>顺序点</h4> 
<p><a href="https://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022330.html">顺序点的解释</a></p> 
<p>C++中的顺序点有以下几个：</p> 
<p>1)分号;</p> 
<p>2)未重载的逗号运算符的左操作数赋值之后(即’,'处)</p> 
<p>3)未重载的’||‘运算符的左操作数赋值之后(即’||'处);</p> 
<p>4)未重载的’&amp;&amp;'运算符的左操作数赋值之后(即"&amp;&amp;"处);</p> 
<p>5)三元运算符’? : ‘的左操作数赋值之后(即’?'处);</p> 
<p>6)在函数所有参数赋值之后但在函数第一条语句执行之前;</p> 
<p>7)在函数返回值已拷贝给调用者之后但在该函数之外的代码执行之前;</p> 
<p>8)每个基类和成员初始化之后;</p> 
<p>9)在每一个完整的变量声明处有一个顺序点，例如int i, j;中逗号和分号处分别有一个顺序点;</p> 
<p>10)for循环控制条件中的两个分号处各有一个顺序点。</p> 
<p>尽量保证在两个相邻顺序点之间同一个变量不可以被修改两次以上或者同时有读取和修改，否则，就会产生未定义(无法预测)的行为。</p> 
<h4>
<a id="cctype_1473"></a>字符函数库cctype</h4> 
<p>头文件<code>cctype</code></p> 
<p>作用：用于确定字符是不是大写字母，数字，标点等工作，<strong>返回值为int</strong>，但也可以当做bool类型用</p> 
<p>包含的函数：</p> 
<table>
<thead><tr>
<th>函数</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>isalpha(char)</td>
<td>判断是否是字母</td>
</tr>
<tr>
<td>ispunct(char)</td>
<td>判断是否是标点符号</td>
</tr>
<tr>
<td>isdigit(char)</td>
<td>判断是否是数字</td>
</tr>
<tr>
<td>isspace(char)</td>
<td>判断是否是空白</td>
</tr>
<tr>
<td>isalnum(char)</td>
<td>字母或数字</td>
</tr>
<tr>
<td>iscntrl(char)</td>
<td>是否是控制字符</td>
</tr>
<tr>
<td>isgraph(char)</td>
<td>是否是除空白以外的字符</td>
</tr>
<tr>
<td>isupper(char)</td>
<td>是否是大写字母</td>
</tr>
<tr>
<td>islower(char)</td>
<td>是否是小写字母</td>
</tr>
<tr>
<td>toupper(char)</td>
<td>如果是小写，返回大写形式，否则返回该参数</td>
</tr>
<tr>
<td>isxdigit(char)</td>
<td>是否是16进制</td>
</tr>
<tr>
<td>tolower(char)</td>
<td>如果是大写返回小写形式，否则返回该参数</td>
</tr>
</tbody>
</table> 
<h4>
<a id="____1498"></a>三元运算符( ? : )</h4> 
<p>语法：<code>expression1 ? expression2 : expression3</code></p> 
<p>如果expression1表达式结果为true，整个表达式的值为expression2的值，否则为exoression3的值</p> 
<h3>
<a id="switch_1506"></a>switch语句</h3> 
<pre><code class="prism language-C++">    switch (inter-expression)//inter-expression是一个返回值为整型的表达式
    {
        case 1:
            expression1;
            break;
        case 2:
            expression2;
            break;
        default:
            expression3;
    }
</code></pre> 
<blockquote> 
 <p>switch语句和if else 语句的作用一样，但是switch语句的效率更高一点，当选项超过3个时，优先选用if else</p> 
</blockquote> 
<h2>
<a id="9__1532"></a>9. 文件读写</h2> 
<p>写文件</p> 
<p>使用文件读写的主要步骤：</p> 
<ol>
<li>包含头文件fstream</li>
<li>创建一个ofstream对象</li>
<li>将这个ofstream同一个文件关联起来</li>
<li>像使用cout那样使用ofstream</li>
</ol> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

int main()
{
	ofstream of;//创建一个输出流对象
    of.open("test.txt");//与文件关联起来
    if(of.is_open())
    {
        of&lt;&lt;"这句话会输出到文件中";
        of.close;//关闭文件
    }
}
</code></pre> 
<blockquote> 
 <p>​ 创建的文件对象和cout用法一样，对象的方法也一样,setf(), precision()</p> 
 <ol>
<li>运行程序之前，要绑定的文件不存在则自动创建这个文件，如果存在，则覆盖写入</li>
<li>在写文件之前还要判断文件是否打开</li>
</ol> 
</blockquote> 
<p>读文件</p> 
<p>方法与写文件类似使用 istream 创建对象</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

int main()
{
    string s;
    ifstream ifs;
    ifs.open("test.txt");
    if(!ifs.is_open())
    {
        exit(-1);//如果文件打开失败，退出程序
    }
    else
    {
        ifs&gt;&gt;s;//读取文件内容给字符串s
        cout&lt;&lt;s&lt;&lt;endl;//输出s
        ifs.close();//关闭文件
    }
}
</code></pre> 
<blockquote> 
 <p>exit(-1)用于退出程序</p> 
</blockquote> 
<p>I/O操作中的方法：</p> 
<table>
<thead><tr>
<th>方法</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>open(文件名,)</td>
<td>将文件对象绑定文件</td>
</tr>
<tr>
<td>is_open()</td>
<td>判断文件是否打开</td>
</tr>
<tr>
<td>eof()</td>
<td>判断是否读取到文件尾，是返回true</td>
</tr>
<tr>
<td>fail()</td>
<td>如果最后一次文件读取发生了类型不匹配和读取到文件尾，则返回true</td>
</tr>
<tr>
<td>bad()</td>
<td>如果文件受损或硬件问题，则返回true</td>
</tr>
<tr>
<td>good()</td>
<td>该方法在没有任何问题的情况下返回true</td>
</tr>
</tbody>
</table> 
<h2>
<a id="10__1611"></a>10. 函数</h2> 
<p>函数的作用是将一段经常使用的代码封装起来，减少重复代码，一个较大的程序一般分为若干块，每个模块实现特定的功能</p> 
<p><strong>函数的定义</strong>：</p> 
<p>函数的定义一般主要有5个步骤：</p> 
<p>1、返回值类型</p> 
<p>2、函数名</p> 
<p>3、参数表列</p> 
<p>4、函数体语句</p> 
<p>5、return 表达式</p> 
<p><strong>语法：</strong></p> 
<pre><code class="prism language-C++">返回值类型 函数名 （参数列表）
{

       函数体语句

       return表达式

}
</code></pre> 
<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul> 
<p><strong>函数原型语句</strong>（函数的声明）：</p> 
<p><strong>作用</strong>：</p> 
<ol>
<li>在C++使用函数时，C++编译器需要知道这个函数的参数类型和返回值类型，C++中使用函数原形来提供这些信息。</li>
<li>当函数写在main函数之后时，编译器从上往下执行，在main函数中又调用了写的函数，编译器又找不到函数的实现，这时需要在main函数之前写一个函数原型，告诉编译器有这个函数</li>
</ol> 
<p>例如：</p> 
<pre><code class="prism language-c++">double sqrt(double);
</code></pre> 
<blockquote> 
 <p>函数的声明可以多次，但是定义只能有一次</p> 
</blockquote> 
<h4>
<a id="_1673"></a>默认参数</h4> 
<p>作用：在调用函数时可以不传参，使用默认的参数。</p> 
<p>语法：<code>int func(const char *, int n = 1);</code></p> 
<p>如果有多个参数需要默认参数，默认参数必须<strong>从右往左进行赋值</strong>，实参按照从左到右的方式传参，但是不能少传参</p> 
<p><code>func(1, ,2);</code>这是不允许的</p> 
<h4>
<a id="_1683"></a>占位参数</h4> 
<p>语法：</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

void func(int a;int )
{
    cout&lt;&lt;"占位参数"&lt;&lt;endl;
}
void func2(int a=10, int = 10)//占位参数也有默认值
{
    cout&lt;&lt;"占位参数2"&lt;&lt;endl;
}
int main()
{
    func(10,20);//占位参数也要传进去，否则报错
}
</code></pre> 
<h3>
<a id="_1710"></a>函数的调用</h3> 
<h4>
<a id="_1714"></a>函数和数组</h4> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
#define ArrSize 8
using namespace std;

int sum_arr(int *,int);
int main()
{
    int cookies[ArrSize] = {1,2,4,8,16,32,64,128};
    cout&lt;&lt;"数组名cookies的地址是"&lt;&lt;cookies&lt;&lt;"大小为"&lt;&lt; sizeof(cookies)&lt;&lt;endl;
    int sum = sum_arr(cookies,4);
    cout&lt;&lt;"the first sum = "&lt;&lt;sum&lt;&lt;endl;
//    sum = sum_arr(cookies+4,4);
//    cout&lt;&lt;"the last sum = "&lt;&lt;sum&lt;&lt;endl;
}

int sum_arr(int arr[],int n)
{
    cout&lt;&lt;"形参arr的地址是"&lt;&lt;arr&lt;&lt;"大小为"&lt;&lt; sizeof(arr)&lt;&lt;endl;
//    cout&lt;&lt;typeid(arr).name()&lt;&lt;endl;
    int total = 0;
    for(int i=0; i &lt; n;i++)
    {
        total += arr[i];
    }
    return total;

}
</code></pre> 
<blockquote> 
 <p>输出结果：</p> 
 <p>数组名cookies的地址是0xc1dabff5f0大小为32<br> 形参arr的地址是0xc1dabff5f0大小为8<br> the first sum = 15</p> 
</blockquote> 
<blockquote> 
 <ol>
<li>数组名就是一个地址，作为参数传入函数中后编译器无法推断数组的大小，所以需要传入数组元素的个数，我们也可以指定元素的个数来进行求和等操作</li>
<li>数组名作为地址传入函数中，函数操作的是数组本身而不是数组的副本(比如int类型作为形参传入就是一个副本)，这样可以不用再复制一个副本来占用内存空间</li>
<li>函数原型的作用是告知编译器这个函数的返回类型以及参数类型以及提前告知编译器存在这个函数，只不过在main函数之后，让编译器不要报错。参数类型可以只写类型不写变量名，函数定义在main函数之后需要使用函数原型，如果函数定义在main函数之前则不需要函数原型</li>
</ol> 
</blockquote> 
<p><strong>使用const保护数组</strong></p> 
<p>因为数组作为参数传入数组不是以副本的形式传入的，而是传入地址，而使用地址能够修改地址中的值，所以如果在函数中使用数组，又不想误操作修改数组的话可以使用const关键字</p> 
<pre><code class="prism language-C++">void show_array(const double arr[], int n)
{
	for(int i=0;i&lt;n;i++)
	{
		cout&lt;&lt;arr[i]&lt;&lt;endl;
        //arr[i]++;编译器将会报错
	}
}
</code></pre> 
<blockquote> 
 <p>注意：使用const修饰之后数组在函数范围内是只读的，并不会修改数组本身的可读可写性</p> 
</blockquote> 
<p>除了使用<code>数组地址+元素个数</code>的方式进行传参，还可以使用<code>首地址+尾地址</code>数组区间的方式进行传参，即传入首地址+尾地址就能够确定数组的大小，这也是STL中使用的方法</p> 
<p>exp：</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
#define ArrSize 8
using namespace std;

int sum_arr(int *,int*);
int main()
{
    int cookies[ArrSize] = {1,2,4,8,16,32,64,128};
    cout&lt;&lt;"首地址"&lt;&lt;cookies&lt;&lt;endl&lt;&lt;"尾地址"&lt;&lt;cookies+ArrSize&lt;&lt;endl;
    int sum = sum_arr(cookies,cookies+ArrSize);
    cout&lt;&lt;"sum = "&lt;&lt;sum&lt;&lt;endl;
}

int sum_arr(int* begin,int* end)
{
    int total = 0;
    for(int i=0; begin+i&lt;end; i++)
    {
        total += *(begin+i);//*解引用的优先级高于+，需要使用 ( )
    }
    return total;
    /*
    for(int p=begin; p!=end; p++)
    {
    	total += *p;
    }
    */

}
</code></pre> 
<blockquote> 
 <p>结果</p> 
 <p>首地址0x3fa6dff7b0<br> 尾地址0x3fa6dff7d0<br> sum = 255</p> 
 <p>首地址为****b0</p> 
 <p>尾地址为****d0</p> 
 <p>(d-b)*16^1 = 32</p> 
</blockquote> 
<h4>
<a id="C_1823"></a>函数和C风格字符串</h4> 
<h4>
<a id="_1827"></a>函数和指针</h4> 
<p>函数名(不加括号)就是函数的地址</p> 
<pre><code class="prism language-c++">handel(test);//参数为函数地址
handel(test());//参数为函数的返回值
</code></pre> 
<p>声明一个函数指针</p> 
<pre><code class="prism language-c++">//先声明一个函数
double func(int);

//声明一个函数指针
double (*pf)(int)
    
pf = func;
    
(*pf) = func所以(*pf)和func的作用一致
所以pf是函数指针，指向的是func的地址
</code></pre> 
<blockquote> 
 <p>c++也允许使用函数指针作函数使用，不必使用(*pf)进行调用，而是pf</p> 
</blockquote> 
<h5>
<a id="_1855"></a>回调函数</h5> 
<p>在一个函数中传入另一个函数，并调用这个函数。</p> 
<p>现阶段理解的回调函数的作用(也算是实际使用场景)是当一个线程在循环执行时因为不能及时的返回运行状态因此可以使用回调函数返回当前程序的状态</p> 
<pre><code class="prism language-c++">//这是函数指针的一个例子
#include &lt;iostream&gt;

using namespace std;

double a_estimate(int);//声明a估计的函数
double b_estimate(int);//声明b估计的函数
void estimate(int, double(*)(int));//声明调用估计的函数

int main()
{
    estimate(1000,a_estimate);
    estimate(1000,b_estimate);
}


double a_estimate(int line)
{
    return 0.05 * line;
}

double b_estimate(int line)
{
    return 0.01 * line + 0.1 * 0.2 * line;
}

void estimate(int line,double (*pf)(int))
{
    cout&lt;&lt;line&lt;&lt;"行代码需要"&lt;&lt;pf(line)&lt;&lt;"小时"&lt;&lt;endl;
    cout&lt;&lt;line&lt;&lt;"行代码需要"&lt;&lt;(*pf)(line)&lt;&lt;"小时"&lt;&lt;endl;
}
</code></pre> 
<h5>
<a id="_1895"></a>函数数组</h5> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;
//函数指针数组(指针数组)
double fa(int n);
double fb(int n);

int main()
{
    double (*p[2])(int) = {fa, fb};
    cout&lt;&lt;p[0](1)&lt;&lt;endl;
    cout&lt;&lt;p[1](2)&lt;&lt;endl;
}
double fa(int a)
{
    return a;
}

double fb(int a)
{
    return a;
}
</code></pre> 
<blockquote> 
 <p>C++中cout无法直接通过函数名输出函数地址，可以通过强制类型转换输出函数地址</p> 
 <pre><code class="prism language-c++">int func(int);
cout&lt;&lt;(int*)func&lt;&lt;endl;
</code></pre> 
</blockquote> 
<blockquote> 
 <p>声明函数指针只需要将函数声明换为(*p)即可声明一个函数指针</p> 
 <pre><code class="prism language-c++">double func(int);
double (*p)(int);
</code></pre> 
</blockquote> 
<h4>
<a id="_1938"></a>递归</h4> 
<p>递归程序的基本结构</p> 
<pre><code class="prism language-C++">void recurs(arguments)
{
    statement1;
    if(test)
    {
        recurs(arguments)
    }
    statement2;
}
</code></pre> 
<h3>
<a id="_1954"></a>内联函数</h3> 
<p>语法：</p> 
<p>在函数声明和定义之前加关键字<code>inline</code></p> 
<h4>
<a id="_1962"></a>内联函数的介绍</h4> 
<p>一般的函数在被调用的时候会跳转到存放函数的地址，调用结束后再返回。内联函数直接将再调用函数的位置创建一个该函数的副本，不需要进行跳转，程序运行速度更快，如果函数被调用十次就会被创建十个副本，需要消耗更多的内存。是典型的以空间换时间。<br> <strong>语法</strong><br> 在函数声明和定义之前加关键字<code>inline</code></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

using namespace std<span class="token punctuation">;</span>

<span class="token keyword">inline</span> <span class="token keyword">double</span> <span class="token function">my_inline_square</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x<span class="token operator">*</span>x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout<span class="token operator">&lt;&lt;</span><span class="token function">my_inline_square</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果函数代码执行的时间比函数跳转的时间短，则可以节省跳转所消耗的大部分时间。<br> 反之则无法节省时间还会浪费内存空间</p> 
<p>在C语言中一般通过宏定义来实现这样的功能，在C++中可以使用内联函数来替代</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">SQUARE</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	reutrn <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="_1998"></a>函数重载</h3> 
<p>重载也叫多态，是面向对象程序设计三大特点之一，意思是一个函数可以有多种形态，就像呵呵有两层意思一样。</p> 
<p>编译器只根据函数的参数列表进行区分函数的多种形态，因此函数的返回值可以不同。</p> 
<p>在没有重载的时候当我们传入参数与形参类型不同的时，系统可能会自动类型转换，而重载后，如果输入参数类型与形参列表类型不符则不会自动类型转换，并且报错。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

using namespace std<span class="token punctuation">;</span>    
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">//    print(a);报错</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">double</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span>string n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


</code></pre> 
<p><strong>重载的每个函数都需要声明</strong></p> 
<h3>
<a id="_2045"></a>函数模板</h3> 
<p>C++面向对象的一个思想是<strong>泛型编程</strong>，减少代码量，增加复用性。</p> 
<p>语法：<code>template &lt;typename T&gt;</code></p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
using namespace std;
template &lt;typename T&gt;//或者使用template &lt;class T&gt;//T的名称可以随便起，早期的C++只有class，后期才有的typename  
void mySwap(T &amp;a,T &amp;b);

int main()
{
    int a = 10;
    int b = 20;
    mySwap(a,b);
    cout&lt;&lt;"a ="&lt;&lt;a&lt;&lt;'n'&lt;&lt;"b ="&lt;&lt;b&lt;&lt;endl;
    double c = 1.0;
    double d = 2.0;
    mySwap(c,d);
    cout&lt;&lt;"c ="&lt;&lt;c&lt;&lt;'n'&lt;&lt;"d ="&lt;&lt;d&lt;&lt;endl;
}

template &lt;typename T&gt;
void mySwap(T &amp;a,T &amp;b)
{
    T temp = a;
    a = b;
    b = temp;
}
</code></pre> 
<blockquote> 
 <p>模板函数声明的时候也需要带上模板关键字</p> 
</blockquote> 
<p><strong>函数模板的作用</strong>：一个函数需要重复使用，且重复使用时参数类型不一样时可以使用函数模板，减少重复代码。</p> 
<p>函数模板并没有创建一个函数，而是一个用于生成函数定义的方案</p> 
<p>在使用的时候实例化为一个函数<code>mySwap(1,2)</code>，这种方式称为隐式实例化</p> 
<p>显式实例化，语法：<code>template void mySwap&lt;int&gt;(int, int);</code></p> 
<p>模板的使用方式有两种：</p> 
<ul>
<li>自动类型推导</li>
<li>手动类型选择</li>
</ul> 
<p>自动类型转换即上述代码使用的方式<code>mySwap(a,b)</code>编译器会自动类型推导</p> 
<p>手动类型选择语法：<code>mySwap&lt;类型名&gt;(参数列表)</code>，即自己选择参数类型</p> 
<p><strong>显式具体化</strong></p> 
<p>显式具体化可以对结构进行操作</p> 
<p>语法：</p> 
<pre><code class="prism language-c++">template&lt;&gt; void swap(int&amp;,int&amp;);
</code></pre> 
<p>示例：</p> 
<pre><code class="prism language-c++">struct job{
	string name;
    int salary;
};
template &lt;typename T&gt;
void swap(T a,T b)
{
    T temp = a;
    a = b;
    b = temp;
}

template&lt;&gt; void swap(job&amp; a,job&amp; b)
{
    int temp = a.salary;
    a.salary = b.salary;
    b.salary = temp;
}

int main()
{
    job a = {"james",100};
    job b = {"tom",2000};
    swap(a,b);//使用显式具体化
    swap&lt;int&gt;(a.salary,b.salary);//显示实例化
    swap(a.salary,b.salary);//使用隐式转换
}
</code></pre> 
<ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型，否则会报错</li></ul> 
<p><strong>decltype关键字</strong></p> 
<h3>
<a id="_2159"></a>引用</h3> 
<ul>
<li>给一个变量起别名</li>
<li>语法：<code>数据类型 &amp;别名 = 原名;</code>
</li>
</ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

using namespce std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意事项：</p> 
<ul>
<li>引用必须初始化</li>
<li>引用在初始化后不可改变</li>
</ul> 
<p>引用一般用于函数参数，不需要创建副本即可使用和修改原始数据。<br> 在c语言中讲解形参的一个典型例子是交换两个值的函数，现在使用引用的方式展示一下</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

using namespace std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">cswap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>pa<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>pb<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>pa<span class="token punctuation">;</span>
	<span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token operator">*</span>pb<span class="token punctuation">;</span>
	<span class="token operator">*</span>pb <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">cppswap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>
	a <span class="token operator">=</span> b<span class="token punctuation">;</span>
	b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">cppswap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>" a <span class="token operator">=</span> <span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>"<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>" b <span class="token operator">=</span> <span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>"<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

	<span class="token function">cswap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>" a <span class="token operator">=</span> <span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>"<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>" b <span class="token operator">=</span> <span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>"<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>c++11新特性：使用&amp;&amp;进行右值引用<br> <code>double &amp;&amp; res = std::sqrt(36);</code></p> 
</blockquote> 
<p><strong>引用也常用于结构体和类</strong></p> 
<ol>
<li> <p>在使用引用作为函数参数且不修改值的情况下建议搭配const关键字进行修饰，防止误改数据。</p> </li>
<li> <p>引用也可作为返回值使用，<strong>链式编程</strong></p> </li>
</ol> 
<p>例：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

using namespace std<span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">person</span>
<span class="token punctuation">{<!-- --></span>
    string name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">showPerson</span><span class="token punctuation">(</span><span class="token keyword">const</span> person <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token operator">&amp;</span> <span class="token function">addAge</span><span class="token punctuation">(</span>person<span class="token operator">&amp;</span><span class="token punctuation">,</span>person<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    person p1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"孙悟空"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    person p2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"猪八戒"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    person p3 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"沙和尚"</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    person p <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"total"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">showPerson</span><span class="token punctuation">(</span><span class="token function">addAge</span><span class="token punctuation">(</span><span class="token function">addAge</span><span class="token punctuation">(</span><span class="token function">addAge</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">,</span>p3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">showPerson</span><span class="token punctuation">(</span><span class="token keyword">const</span> person <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"姓名："</span><span class="token operator">&lt;&lt;</span>p<span class="token punctuation">.</span>name<span class="token operator">&lt;&lt;</span><span class="token string">"n"</span><span class="token operator">&lt;&lt;</span><span class="token string">"年龄："</span><span class="token operator">&lt;&lt;</span>p<span class="token punctuation">.</span>age<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
person<span class="token operator">&amp;</span> <span class="token function">addAge</span><span class="token punctuation">(</span>person<span class="token operator">&amp;</span>p1<span class="token punctuation">,</span>person<span class="token operator">&amp;</span>p2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    p1<span class="token punctuation">.</span>age <span class="token operator">=</span> p1<span class="token punctuation">.</span>age<span class="token operator">+</span>p2<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="_2276"></a>命名空间</h2> 
<p>C++的新特性：命名空间</p> 
<p>命名空间有三种格式：</p> 
<ul><li><code>using namespace std</code></li></ul> 
<p>可以直接使用std命名空间中的cout，cin等等</p> 
<ul><li><code>using std::cout</code></li></ul> 
<p>只能使用cout</p> 
<ul><li><code>std::cout</code></li></ul> 
<p>使用时使用std::cout</p> 
<hr> 
<h1>
<a id="_C_2298"></a>二、 C++核心</h1> 
<h2>
<a id="1__2302"></a>1. 分文件编写程序</h2> 
<p>CC++是编译型语言，运行程序之前需要编译代码，将程序源码编译为机器语言再通过链接器将.o文件链接起来，生成可执行文件。编译型语言比较依靠编译器。</p> 
<p><strong>单独编译</strong><br> 当程序比较大时，需要分模块、分文件编写程序代码，这样做的好处是每个文件都可以独立编译。当修改一个文件时，只需要重新编译修改过的文件，编译器包含编译器和链接器，编译完成后通过链接器将相关文件链接起来。</p> 
<p><strong>怎么分模块写程序</strong><br> 通常将</p> 
<ul>
<li>函数声明</li>
<li>#define或者const修定义的符号常量</li>
<li>结构声明</li>
<li>类声明</li>
<li>模板声明</li>
<li>内联函数</li>
</ul> 
<p>这种<strong>没有实例化</strong>或<strong>没有生成变量</strong>只是告诉编译器如何生成一个变量或者结构的代码放在.h文件中(const或#define除外)，<br> 一个程序被分为三部分：</p> 
<ul>
<li>头文件(后缀.h)，</li>
<li>头文件的实现代码(后缀.cpp)，</li>
<li>源代码(主程序/调用头文件的程序,后缀.cpp)</li>
</ul> 
<p><strong>#include中的<code>" "</code>和<code>&lt; &gt;</code></strong></p> 
<p>使用<code>#include "xxx.h"</code>包含头文件，编译器会优先在工程目录下搜索该头文件，找不到再从C++标准库中找，而使用<code>&lt; &gt;</code>时，编译器直接从C++库中寻找指定的头文件，不会从工程目录下寻找。</p> 
<p><strong>C中的头文件保护机制</strong></p> 
<p>在同一个文件中只能将同一个头文件包含一次，为了避免不小心导致的多次引用，C/C++引入了头文件保护机制，只需要在头文件中使用</p> 
<pre><code class="prism language-c++">#ifndef _XXX_H_
#define _XXX_H_
//这里写头文件代码
...
#endif
</code></pre> 
<p>这样的格式，即可保证不会重复引用。</p> 
<p>当编译器第一次引用这个头文件的时候，<code>#ifndef</code>的意思是<code>if not define</code>，然后就会<code>#define</code>这个名称，这个名称是没有在其他地方声明过的名称一般都使用大写字母+下划线组成，程序运行到<code>endif</code>结束。</p> 
<p>当程序中第二次引用这个头文件的时候，因为已经define过这个名称了，所以<code>#ifndef</code>不成立，直接跳过这个头文件不引用。</p> 
<p><strong>链接的内部性与外部性</strong></p> 
<p>一个变量可以在单文件中使用也可以在多文件中使用，这就是链接的内部性与外部性。</p> 
<ul>
<li> <p>不加<code>static</code>关键字且不在代码块（大括号内）定义变量时变量是外部性的，只需要在使用这个变量的文件中使用<code>extern</code>关键字声明一下这个变量即可在另一个文件中使用。</p> </li>
<li> <p>加<code>static</code>关键字且不在代码块内变量的链接性变为内部链接性，只能在单文件中使用。</p> </li>
</ul> 
<p><strong>单定义规则：一个变量只能定义一次，但是可以声明多次</strong></p> 
<p>如果在一个文件中声明了一个链接性为外部的变量，而另一个文件中也要使用同名变量，因为单定义规则，这时我们无法在另一个文件中重新定义这个变量。因此我们需要使用static关键字将这个变量定义为内部性的变量即可正常使用。</p> 
<p>单定义规则的一个例外是局部变量，当在函数内部或者类内部(统称为代码块内部)定义一个与全局变量重名的函数时，局部变量会隐藏(hide)掉全局变量，此时如果想要访问重名的全局变量，我们可以使用域作用解析运算符(::)来访问全局变量</p> 
<p><strong>总结：</strong></p> 
<ul>
<li>链接性分为内部链接性和外部链接性，使用关键字<code>static</code>控制，不加static关键字默认为外部链接性，可在本程序的其他文件中访问，加static关键字后变量为内部链接性，仅在本文件中可以访问</li>
<li>在一个文件使用另一个文件定义的变量需要使用关键字<code>extern</code>声明，注意是声明不是定义，不能初始化值。</li>
</ul> 
<p>全局变量</p> 
<p>静态全局变量</p> 
<p>全局常量</p> 
<p>静态全局常量</p> 
<p>局部变量</p> 
<p>静态局部变量</p> 
<p>局部常量</p> 
<h2>
<a id="2__2399"></a>2. 内存分区模型</h2> 
<ul>
<li> <p><strong>代码区</strong>：存放函数体的二进制代码</p> </li>
<li> <p><strong>全局区</strong>：存放<strong>全局变量</strong>，<strong>静态变量</strong>，以及<strong>常量</strong></p> </li>
<li> <p><strong>栈区</strong>：由编译器自动分配释放，存放函数的参数值，局部变量</p> </li>
<li> <p><strong>堆区</strong>：用new操作符由程序员分配和释放，若程序员不释放，程序结束时操作系统回收</p> <p><strong>意义</strong>:不同区域赋予不同的生命周期，更灵活</p> </li>
</ul> 
<h3>
<a id="_2413"></a>程序执行前：</h3> 
<p>代码区的特点：</p> 
<ul>
<li>共享</li>
<li>只读</li>
</ul> 
<p>全局区的特点：</p> 
<ul><li>该区域的数据在程序结束后系统自动释放</li></ul> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
using namespace std;
int g_a = 10;
const int c_g_a = 10;
int main()
{
    int a = 10;
    static int s_a = 10;


    cout&lt;&lt;"局部变量的a的地址为："&lt;&lt;&amp;a&lt;&lt;endl;
    cout&lt;&lt;"全局变量的g_a的地址为："&lt;&lt;&amp;g_a&lt;&lt;endl;
    cout&lt;&lt;"静态变量的地址"&lt;&lt;&amp;s_a&lt;&lt;endl;
    cout&lt;&lt;"字符串常量的地址"&lt;&lt;&amp;"hello world"&lt;&lt;endl;
    cout&lt;&lt;"全局常量的地址"&lt;&lt;&amp;c_g_a&lt;&lt;endl;
}
</code></pre> 
<p>运行结果：</p> 
<blockquote> 
 <p>局部变量的a的地址为：0x6d1cfffafc<br> 全局变量的g_a的地址为：0x7ff6346b4010<br> 静态变量的地址0x7ff6346b4014<br> 字符串常量的地址0x7ff6346b5056<br> 全局常量的地址0x7ff6346b5004</p> 
</blockquote> 
<p>示例2：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
using namespace std;

//定义全局变量
int g_a = 1;
static int s_g_a = 1;
const int c_g_a = 1;
static const int s_c_g_a = 1;

int main()
{
    cout&lt;&lt;"全局变量的地址"&lt;&lt;endl;
    cout&lt;&lt;&amp;g_a&lt;&lt;endl;
    cout&lt;&lt;&amp;s_g_a&lt;&lt;endl;
    cout&lt;&lt;&amp;c_g_a&lt;&lt;endl;
    cout&lt;&lt;&amp;s_c_g_a&lt;&lt;endl;

    cout&lt;&lt;"字符串常量的地址"&lt;&lt;endl;
    cout&lt;&lt;&amp;"hello world"&lt;&lt;endl;
    //定义两个静态局部变量
    static int s_l_a = 1;
    const static int s_c_l_a = 1;
    //两个局部变量
    int l_a = 1;
    const int c_l_a = 1;

    cout&lt;&lt;"静态局部变量的地址"&lt;&lt;endl;
    cout&lt;&lt;&amp;s_c_l_a&lt;&lt;endl;
    cout&lt;&lt;&amp;s_l_a&lt;&lt;endl;
    cout&lt;&lt;"局部变量的地址"&lt;&lt;endl;
    cout&lt;&lt;&amp;l_a&lt;&lt;endl;
    cout&lt;&lt;&amp;c_l_a&lt;&lt;endl;
}
</code></pre> 
<blockquote> 
 <ul><li>运行结果：</li></ul> 
 <p>全局变量的地址<br> 0x7ff7ec244010<br> 0x7ff7ec244014<br> 0x7ff7ec245004<br> 0x7ff7ec245008<br> 字符串常量的地址<br> 0x7ff7ec245030<br> 静态局部变量的地址<br> 0x7ff7ec24500c<br> 0x7ff7ec244018<br> 局部变量的地址<br> 0x8855ff64c<br> 0x8855ff648</p> 
 <ul>
<li> <p>可以看到静态变量和静态局部变量在地址上是没有区别的，定义在代码块内的静态变量也是全局存在的，但是在使用过程中却不能作为全局变量使用</p> </li>
<li> <p>因此可以将静态局部变量作为一个记录函数状态的变量</p> </li>
<li> <p>静态局部变量在第一次使用前分配，在程序结束后销毁</p> <p>示例：</p> <pre><code class="prism language-c++">#include &lt;iostream&gt;
using namespace std;

const int Arsize = 10;

void strcount(const char* str);

int main()
{
    char input[Arsize];//定义一个字符数组
    char next;

    cout&lt;&lt;"请输入一行"&lt;&lt;endl;
    cin.get(input,Arsize);
    while(cin)
    {
        cin.get(next);
        while(next != 'n')
        {
            cin.get(next);
        }
        strcount(input);
        cout&lt;&lt;"请输入下一行(空行退出)"&lt;&lt;endl;
        cin.get(input,Arsize);
    }
    cout&lt;&lt;"再见"&lt;&lt;endl;
}
void strcount(const char* str)
{
    static int total = 0;//定义一个静态局部变量用于记录字符总数
    int count = 0;

    cout&lt;&lt;"""&lt;&lt;str&lt;&lt;""包含";
    while(*str++)
        count++;
    total+=count;
    cout&lt;&lt;count&lt;&lt;"个字符"&lt;&lt;endl;
    cout&lt;&lt;"总共输入"&lt;&lt;total&lt;&lt;"个字符"&lt;&lt;endl;
}
</code></pre> 
   <blockquote> 
    <p>运行结果：</p> 
    <p>请输入一行<br> asdfg<br> "asdfg"包含5个字符<br> 总共输入5个字符<br> 请输入下一行(空行退出)<br> dfg<br> "dfg"包含3个字符<br> 总共输入8个字符<br> 请输入下一行(空行退出)</p> 
   </blockquote> <p>count是一个局部变量，total是一个静态局部变量</p> <p>count用于记录每次传进函数的字符个数，因为局部变量随函数的运行而创建，随函数的结束而消失，所以每次调用strcount这个函数的时候count都是重新赋值的。</p> <p>而total是一个静态局部变量，虽然在其他地方无法访问这个变量，但因其存放在全局区，随程序的结束而结束，其值是全局存在的，不会随函数的创建而创建，消失而消失，因此可以用来记录函数的状态</p> </li>
</ul> 
</blockquote> 
<p><strong>总结</strong></p> 
<ul>
<li>C++在运行前分为全局区和代码区</li>
<li>代码区的特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放const修饰的全局常量和字符串常量</li>
</ul> 
<h3>
<a id="_2584"></a>程序执行后</h3> 
<h4>
<a id="_2586"></a>栈区</h4> 
<ul>
<li>栈区由编译器管理</li>
<li>存放函数的<strong>参数</strong>
</li>
</ul> 
<blockquote> 
 <p>注意事项：不要返回局部变量的地址</p> 
</blockquote> 
<pre><code class="prism language-C">#include &lt;iostream&gt;
using namespace std;

int* func()
{
	int a = 10;
	return &amp;a;
}
int main()
{
    int* p = func();
	cout&lt;&lt; *p &lt;&lt;endl;//第一次可以打印正确的数据，是因为编译器保留
	cout&lt;&lt; *p &lt;&lt;endl;//第二次报错，内存已经被释放了
    
	system("pause");
}
</code></pre> 
<h4>
<a id="_2615"></a>堆区</h4> 
<ul>
<li>由程序员分配和释放，若一直不释放，程序运行结束时释放</li>
<li>利用new可以在堆中开辟新数据</li>
<li>利用delete在堆区删除数据</li>
</ul> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
using namespace std;

int* func()
{
	//利用new关键字开辟堆区
	int* p = new int(10);
	return p;
}
int main()
{
    int* p = func();

	cout&lt;&lt; *p&lt;&lt;endl;

	system("pause");
}
</code></pre> 
<h3>
<a id="_2641"></a>动态内存</h3> 
<p>动态内存是由new关键字分配内存和delete释放内存</p> 
<blockquote> 
 <p>注意new和delete关键字是一对运算符</p> 
</blockquote> 
<h2>
<a id="3__2653"></a>3. 类和对象</h2> 
<p>类的三大特性：</p> 
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul> 
<p>通用的写法：将类名大写</p> 
<p><strong>类的语法</strong></p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class People	//类的声明
{
private:
    string p_name;
    int p_age;
public:
    void setName(string name)
    {
        p_name = name;
    }
    string getName()
    {
        return p_name;
    }
};

int main()
{
    People p;//类的实例化
    p.setName("james");
    cout&lt;&lt;p.getName()&lt;&lt;endl;
}
</code></pre> 
<h3>
<a id="_2696"></a>封装</h3> 
<p><strong>封装的意义：</strong></p> 
<ul>
<li>将属性和行为作为一个整体</li>
<li>将属性和行为加以权限控制</li>
<li>尽可能将公有接口与实现细节分开</li>
</ul> 
<p>语法：</p> 
<pre><code class="prism language-c++">class People
{
private://权限
	int p_name;//行为和方法
    int func(){};
};
</code></pre> 
<p>示例：设计一个圆类</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
using namespace std;

class Circle
{
public:
    double radius;
    const double PI = 3.14;
    double round;
    
    double c_round()
    {
        return 2 * PI * radius;
    }
};

int main()
{
    Circle c1;
    c1.radius = 10;
    cout&lt;&lt;"The round of circle is:"&lt;&lt;c1.c_round()&lt;&lt;endl;
}
</code></pre> 
<h4>
<a id="_2746"></a>类属性和行为的三种访问权限</h4> 
<table>
<thead><tr>
<th>名称</th>
<th>权限</th>
</tr></thead>
<tbody>
<tr>
<td>public</td>
<td>类内类外都可以访问</td>
</tr>
<tr>
<td>private</td>
<td>类内可以访问，类外不可以访问</td>
</tr>
<tr>
<td>protected</td>
<td>类内可以访问，类外不可以访问</td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>protected和private的区别主要在继承中体现</p> 
 <ul>
<li> <p>保护权限子类可以继承</p> </li>
<li> <p>私有权限子类不可以继承</p> </li>
</ul> 
</blockquote> 
<p>点和圆的关系示例：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

class Circle
{
private:
    int c_x,c_y;
    int c_radius;
public:
    void setRadius(int radius)
    {
        c_radius = radius;
    }
    void setX(int x)
    {
        c_x = x;
    }
    void setY(int y)
    {
        c_y = y;
    }
    int getRadius()
    {
        return c_radius;
    }
    int getX()
    {
        return c_x;
    }
    int getY()
    {
        return c_y;
    }
};

class Point
{
private:
    int p_x,p_y;
public:
    void setX(int x)
    {
        p_x = x;
    }
    void setY(int Y)
    {
        p_y = Y;
    }
    int getX()
    {
        return p_x;
    }
    int getY()
    {
        return p_y;
    }
};
void relationC2p(Circle &amp;c,Point &amp;p);
int main()
{
    Circle c;
    Point p;
    c.setX(10);
    c.setY(10);
    c.setRadius(1);
    p.setX(20);
    p.setY(20);
    relationC2p(c,p);
}
void relationC2p(Circle &amp;c,Point &amp;p)
{
    if((c.getX()-p.getX())*(c.getX()-p.getX()) + (c.getY()-p.getY())*(c.getY()-p.getY()) == c.getRadius()*c.getRadius())
    {
        cout&lt;&lt;"on the circle"&lt;&lt;endl;
    }
    else if((c.getX()-p.getX())*(c.getX()-p.getX()) + (c.getY()-p.getY())*(c.getY()-p.getY()) &lt; c.getRadius()*c.getRadius())
    {
        cout&lt;&lt;"in the circle"&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;"out of circle"&lt;&lt;endl;
    }
}
</code></pre> 
<h3>
<a id="_2858"></a>构造函数和析构函数</h3> 
<ul>
<li>构造函数初始化</li>
<li>析构函数清理</li>
</ul> 
<p><strong>构造函数语法</strong></p> 
<ul><li><code>类名( ){ }</code></li></ul> 
<p><strong>特点：</strong></p> 
<ul>
<li>可以有参数</li>
<li>可以重载</li>
<li>创建对象的时候，构造函数会自动调用，且只会调用一次</li>
</ul> 
<p><strong>构造器按参数分：</strong></p> 
<ul>
<li>有参构造</li>
<li>无参构造(默认)</li>
</ul> 
<p><strong>按类型分：</strong></p> 
<ul>
<li>普通构造</li>
<li>拷贝构造</li>
</ul> 
<p><strong>析构函数：</strong></p> 
<ul><li><code>~类名( ) { }</code></li></ul> 
<p>对象在销毁前会自动调用析构函数，且只会调用一次</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;
class Person
{
private:
    int age;
public:
    Person()
    {
        cout&lt;&lt;"这是一个无参构造(默认构造)"&lt;&lt;endl;
    }
    
    Person(int a)
    {
        age = a;
        cout&lt;&lt;"这是一个有参构造"&lt;&lt;endl;
    }
    
    Person(const Person &amp;p)
    {
        cout&lt;&lt;"这是一个拷贝构造"&lt;&lt;endl;
    }
    
    ~Person()
    {
        cout&lt;&lt;"这是一个析构函数"&lt;&lt;endl;
    }
}

int main()
{
    //括号法
    Person p1;//默认构造函数调用，调用默认构造函数时不加( )
    //Person p1();	编译器会认为是一个函数声明
    Person p2(10);//有参构造调用
    Person p3(p2);//拷贝

    //显示法
    Person p4;
    Person p5 = Person(10);//Person(10)是一个匿名对象
    Perosn p6 = Person(p5);//不要使用拷贝初始化匿名对象
    //Person(p3)	编译器会认为是重定义p3
    
    //隐式转换法
    Person p7 = 10;
    Person p8 = p7;
}
</code></pre> 
<h4>
<a id="_2958"></a>深拷贝与浅拷贝</h4> 
<p><strong>析构函数为在堆区开辟的数据做释放</strong></p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

class Person
{
public:
    int m_age;
    int *m_height;
    Person(int age,int height)
    {
        m_age = age;
        m_height = new int(height);
    }
//    Person(const Person &amp;p)//默认拷贝构造器
//    {
//        m_age = p.m_age;
//        m_height = p.m_height;
//    }
	Person(const Person &amp;p)//自己写拷贝构造器实现深拷贝
	{
		m_age = p.m_age;
        m_height = new int(*p.m_height);
	}
    
    ~Person()//析构函数
    {
    	cout&lt;&lt;"这是一个析构函数"&lt;&lt;endl;
        if(m_height!=NULL)
        {
            delete m_height;
            m_height = NULL;
        }
    }
};

void test()
{
    Person p1(12,160);
    Person p2(p1);
}

int main()
{
    test();
    cout&lt;&lt;"a"&lt;&lt;endl;
}
</code></pre> 
<p>值传递一个类会调用拷贝构造拷贝一个新的对象</p> 
<p>值返回会返回一个拷贝对象</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rBcb2maZ-1688987036670)(image-20220923155843763.png)]</p> 
<p>初始化列表</p> 
<pre><code class="prism language-c++">//初始化列表
Person(int a,int b,int c):m_a(a),m_b(b),m_c(c);
</code></pre> 
<hr> 
<h3>
<a id="_3029"></a>静态成员</h3> 
<p>静态成员变量：</p> 
<ul>
<li> <p>编译阶段分配内存</p> </li>
<li> <p><strong>类内声明类外初始化</strong></p> </li>
<li> <p>不属于某个对象，<strong>所有对象共享一份数据</strong></p> </li>
</ul> 
<p>访问方式：因为所有对象共享一份数据，所以除了使用对象访问，还可以使用类名进行访问</p> 
<ul><li>通过对象进行访问</li></ul> 
<pre><code class="prism language-c++">Person p;
cout&lt;&lt;p.name&lt;&lt;endl;
</code></pre> 
<ul><li><strong>通过类名进行访问</strong></li></ul> 
<pre><code>Person::name
</code></pre> 
<p>静态成员函数：</p> 
<ul>
<li>共享的</li>
<li>只能访问静态成员</li>
</ul> 
<p>访问：</p> 
<ul><li>通过对象访问</li></ul> 
<pre><code>Person p;
p.func();
</code></pre> 
<ul><li>通过类名访问</li></ul> 
<pre><code>Person::func();
</code></pre> 
<h4>
<a id="const_3083"></a>const成员函数</h4> 
<p>如果实例化一个静态对象则需要在类里面的函数添加const关键字，确保静态对象不会修改对象的值</p> 
<pre><code class="prism language-c++">const Person p(1,2,3);
p.show();//如果show函数没有添加const时这是不允许的
void Person::show() const {}//添加const关键字之后即可
</code></pre> 
<h3>
<a id="Cthis_3097"></a>C++对象模型和this指针</h3> 
<p>C++空对象占用1字节用于占位</p> 
<p>成员变量和成员函数是分开存储的</p> 
<p><strong>只有非静态成员变量属于类的对象</strong>，其他的都不属于类的对象上</p> 
<p>this指针</p> 
<p>本质是一个指针常量，指向的地址不可以改变</p> 
<p>this指针是隐含在每个非静态成员函数内的一种指针，不需要定义</p> 
<p>作用：</p> 
<ul>
<li>当形参和成员变量重名时通过this指针区分</li>
<li>类的非静态成员函数中返回对象本身可以用<code>return *this</code>（链式）</li>
</ul> 
<p>示例：</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class Person
{
public:	
	int apple;
	Person(int apple)
	{
		this-&gt;apple = apple;
	}

	Person&amp; addApple(Person &amp;p)//如果使用Person作为返回值返回的是一个拷贝，使用Person&amp;返回的是p本体
	{
		this-&gt;apple+=p.apple;
        return *this;//this指向p，解引用就是p这个对象
	}
};

void test()
{
	Person p1(1);
	Person p2(2);
	p1.addApple(p2).addApple(p2);
	cout&lt;&lt;p1.apple&lt;&lt;endl;
}

int main()
{
	test();
}
</code></pre> 
<p>空指针访问成员函数</p> 
<p>空指针可以访问成员，但是如果访问静态成员变量会导致程序无法运行，可以在需要静态成员变量的函数添加一条判断语句，保证代码的健壮性</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class Person()
{
	int m_Age;
	void showClassName()
	{
		cout&lt;&lt;"class name is Person";
	}
	void showPersonName()
	{
		if(this==NULL)
		{
			return;
		}
		cout&lt;&lt;"age = "&lt;&lt; m_Age&lt;&lt;endl;
	}
};

void test01()
{
	Person * p = NULL;
	p-&gt;showClassName();
	p-&gt;showPersonName();
}
void main()
{
	test01();
}
</code></pre> 
<p>const修饰成员函数</p> 
<p>常函数</p> 
<ul>
<li>在函数声明后面加const为常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>加mutable后可以修改</li>
</ul> 
<p>常对象</p> 
<ul>
<li> <p>声明对象前添加const</p> </li>
<li> <p>常对象只能调用常函数</p> </li>
</ul> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class Person()
{
//this指针本质是指针常量，指针指向的地址不可以改变 Person * const this
//在函数后面添加const代表常函数，相当于const Person * const this,值和地址都不可以改变
public:
	int m_Age;
	mutable m_B;
	void showPerson() const
	{
		//相当于this-&gt;m_age = 10;
		m_Age = 10;//报错
		m_B = 10;//可以
	}
};

void test01()
{
	const Person p;//在对象前加const成为常对象
	p.m_Age = 10;//不可以修改
	p.m_B = 10;//可以修改
}
</code></pre> 
<p>友元</p> 
<ul><li>关键字<code>friend</code>
</li></ul> 
<p>三种实现：</p> 
<ul><li>全局函数做友元</li></ul> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class Building
{
	friend void goodGay(Building &amp;building);
public:
	string sittingRoom;
private:
	string bedRoom;
public:
	Building()
	{
		sittingRoom="客厅";
		bedRoom="卧室";
	}
};

void goodGay(Building &amp;building)
{
    cout&lt;&lt;"好机油正在访问"&lt;&lt;building.sittingRoom&lt;&lt;endl;
    cout&lt;&lt;"好机油正在访问"&lt;&lt;building.bedRoom&lt;&lt;endl;
}

int main()
{
	Building building;
	goodGay(building);
}
</code></pre> 
<ul><li>类做友元</li></ul> 
<h3>
<a id="_3288"></a>运算符重载</h3> 
<p>*可以用于定义一个指针，也可以用作解析符，也可以作为乘法运算，一个符号在不同的地方有不同的作用就是运算符的重载</p> 
<p>在一个类中进行运算符的重载需要使用运算符函数：<code>operator op(参数列表)</code></p> 
<ul><li>只能使用C语言中已经定义的符号</li></ul> 
<h3>
<a id="_3298"></a>继承</h3> 
<p>继承优点：减少代码重复</p> 
<p>语法：<code>class 子类 : 继承方式 父类</code></p> 
<p>子类也称为<strong>派生类</strong></p> 
<p>父类称为<strong>基类</strong></p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class BasePAge
{
public:
    void content(){}

    void foot()
    {
        cout&lt;&lt;"这是一个底部栏"&lt;&lt;endl;
    }
    void left()
    {
        cout&lt;&lt;"这是一个左侧栏"&lt;&lt;endl;
    }
};

class CPP : BasePAge
{
public:
    void content()
    {
        cout&lt;&lt;"这是Java学科的栏"&lt;&lt;endl;
    }
};

void test01()
{
    CPP p;
    p.content();

}
int main() {
    test01();
    return 0;
}
</code></pre> 
<h4>
<a id="_3349"></a>继承方式</h4> 
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul> 
<p><img src="https://images2.imgbox.com/f1/50/HDztKxuc_o.png" alt="image-20221015202433989"></p> 
<h4>
<a id="_3357"></a>继承中的对象模型</h4> 
<p>父类中所有<strong>非静态成员属性</strong>都会被子类继承下去（父类中的私有成员属性都会被被编译器隐藏，所以访问不到）</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;



class Base
{
public:
	int m_A;
	static int m_B;
	
protected:
	int m_C;
private:
	int m_D;
};

int m_B = 100;
class Son:Base
{
	
};

void test01()
{
	Son s;
	cout&lt;&lt;"sizeof Son = "&lt;&lt;sizeof(s)&lt;&lt;endl;
}


int main()
{
	test01();
}
</code></pre> 
<blockquote> 
 <p>输出结果sizeof Son = 12</p> 
</blockquote> 
<h4>
<a id="_3401"></a>继承中构造和析构顺序</h4> 
<p>子类继承父类后，当创建子类对象时，也会调用父类的构造函数</p> 
<p>具体的执行顺序是</p> 
<pre><code>父类构造
子类构造
子类析构
父类析构
</code></pre> 
<h4>
<a id="_3414"></a>同名成员处理</h4> 
<ul>
<li>访问子类同名成员：直接访问即可</li>
<li>访问父类同名成员：需要加作用域</li>
</ul> 
<h4>
<a id="_3419"></a>同名函数处理</h4> 
<ul><li>加作用域</li></ul> 
<blockquote> 
 <p>如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中的所有同名成员函数（即使父类中的同名成员函数重载了也无法调用，必须加作用域）</p> 
</blockquote> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
using namespace std;

class Base
{
public:
    Base()
    {
        m_A = 100;
    }
    int m_A;

    void sayHi()
    {
        cout&lt;&lt;"Base: Hello World"&lt;&lt;endl;
    }
};

class Son:public Base
{
public:
    Son()
    {
        m_A = 200;
    }
    int m_A;

    void sayHi()
    {
        cout&lt;&lt;"Son: Hello World"&lt;&lt;endl;
    }
};


void test01()
{
    Son s;
    cout&lt;&lt; s.m_A&lt;&lt;endl;
    cout&lt;&lt; s.Base::m_A&lt;&lt;endl;//加作用域访问父类成员
}

void test02()
{
    Son s;
    s.sayHi();
    s.Base::sayHi();//加作用域访问父类函数
}
int main() {
    test01();
    test02();
    return 0;
}
</code></pre> 
<h4>
<a id="_3480"></a>同名静态成员处理</h4> 
<p>与非静态成员使用方式一致，但是静态成员的访问方式有两种</p> 
<ul>
<li>通过对象访问</li>
<li>通过类名访问</li>
</ul> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class Base {
public:
    int static m_A;

    static void func() {
        cout &lt;&lt; "这是Base" &lt;&lt; endl;
    }
};

int  Base::m_A = 100;

class Son : public Base {
public:
    int static m_A;

    static void func() {
        cout &lt;&lt; "这是Son" &lt;&lt; endl;
    }
};

int Son::m_A = 200;

void test01() {
    Son s;
    cout &lt;&lt; s.m_A &lt;&lt; endl;//通过对象访问
    cout &lt;&lt; s.Base::m_A &lt;&lt; endl;//通过对象访问
    cout &lt;&lt; Son::m_A &lt;&lt; endl;//通过类名访问
    cout &lt;&lt; Base::m_A &lt;&lt; endl;//通过类名访问
    cout &lt;&lt; "sizeof Base = " &lt;&lt; sizeof(Base) &lt;&lt; endl;
    cout &lt;&lt; "sizeof Son = " &lt;&lt; sizeof(Son) &lt;&lt; endl;

    //调用同名函数func
    //通过对象访问
    s.func();
    s.Base::func();
    //通过类名的方式访问
    Son::func();
    Base::func();
}


int main() {
    test01();
    return 0;
}
</code></pre> 
<h4>
<a id="_3539"></a>多继承语法</h4> 
<p><code>class 子类 : 继承方式 父类1, 父类2...</code></p> 
<p>多继承会引发父类中有同名重圆出现，需要加做哦用于区分</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class Base1
{
public:
    int m_A=100;
};
class Base2
{
public:
    int m_A=200;
};
class Son:public Base1,public Base2
{
public:
    int m_C = 300;
    int m_D = 400;
};
void test01() {
    Son s;
    cout&lt;&lt;"sizeof Son = "&lt;&lt; sizeof(Son)&lt;&lt;endl;
    //cout&lt;&lt;s.m_A&lt;&lt;endl;会报错找到多个
    cout&lt;&lt;s.Base1::m_A&lt;&lt;endl;
    cout&lt;&lt;s.Base2::m_A&lt;&lt;endl;
}


int main() {
    test01();
    return 0;
}
</code></pre> 
<h4>
<a id="_3581"></a>菱形继承</h4> 
<p>利用虚拟继承解决菱形继承的问题</p> 
<p>继承之前加上关键字<code>virtual</code>变为虚继承，被继承的称为虚基类</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class Animal{//虚基类
public:
    int m_Age;
};
class Sheep:virtual public Animal{//继承前加virtual后变为徐济成
};
class Tuo:virtual public Animal{
};
class Sheeptuo:public Sheep,public Tuo{
};
void test01() {
    Sheeptuo st;
    st.Sheep::m_Age = 18;
    st.Tuo::m_Age = 28;
    //cout&lt;&lt;st.m_Age;直接使用会报错，可以通过加域名的方式使用，但是这个属性还是会有两份，怎么将其变为一份呢？
    //加上virtual关键字,变量只有一份
    cout&lt;&lt;st.Sheep::m_Age&lt;&lt;endl;//28
    cout&lt;&lt;st.Tuo::m_Age&lt;&lt;endl;//28
    cout&lt;&lt;sizeof(Sheep)&lt;&lt;endl;//16
    cout&lt;&lt;sizeof(Tuo)&lt;&lt;endl;//16
    cout&lt;&lt;sizeof(Sheeptuo)&lt;&lt;endl;//24
}


int main() {
    test01();
    return 0;
}
</code></pre> 
<p>现在类的内部结构</p> 
<p><img src="https://images2.imgbox.com/c8/2c/KJ7o1gVc_o.png" alt="image-20221016155246546"></p> 
<pre><code>vbptr
v -virtual
b -base
ptr -pointer
虚基类指针

sheeptuo继承的是sheep和tuo中的指针，指向Animal中的m_Age
</code></pre> 
<p>总结：</p> 
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费</li>
<li>利用虚拟继承可以解决菱形继承问题</li>
</ul> 
<h3>
<a id="_3641"></a>多态</h3> 
<p>多态分为两类：</p> 
<ul>
<li>静态多态：函数重载和运算符重载属于静态多态，复用函数名</li>
<li>动态多态：派生类和虚函数实现运行时多态</li>
</ul> 
<p>静态多态和动态多态的区别</p> 
<ul>
<li>静态多态的函数地址早绑定-编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定-<strong>运行阶段</strong>确定函数地址，无法在编译阶段确定地址</li>
</ul> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class Animal{
public:
    virtual void speak()//加virtual关键字成为虚函数
    {
        cout&lt;&lt;"Animal Speak"&lt;&lt;endl;
    }
};
class Cat:public Animal{
public:
    void speak()
    {
        cout&lt;&lt;"Cat Speak"&lt;&lt;endl;
    }
};
void dospeak(Animal &amp;animal)
{
    animal.speak();
}
void test01() {
    Cat c;
    dospeak(c);
}


int main() {
    test01();
    return 0;
}
</code></pre> 
<p>动态多态满足条件：</p> 
<ol>
<li>有继承关系</li>
<li>子类要重写父类的虚函数</li>
</ol> 
<p>动态多态的使用：</p> 
<ul><li><strong>父类的指针或者引用 指向子类对象</strong></li></ul> 
<p>底层</p> 
<pre><code>vfptr
v -virtual
f -function
ptr -pointer
虚函数（表）指针
指针指向一个表vftable虚函数表
v - virtual
f -function
table
表内部记录虚函数的地址
</code></pre> 
<p><img src="https://images2.imgbox.com/3c/7d/OEt4Qjrt_o.png" alt="image-20221016194544062"></p> 
<h4>
<a id="_3714"></a>纯虚函数和抽象类</h4> 
<p>纯虚函数语法：</p> 
<pre><code>virtual 返回值类型 函数名 （参数列表） = 0;
virtual void func() = 0;
</code></pre> 
<p>当类中有了纯虚函数，这个类也称为抽象类</p> 
<p>抽象类特点：</p> 
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类，无法实例化对象</li>
</ul> 
<h4>
<a id="_3730"></a>虚析构和纯虚析构</h4> 
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p> 
<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p> 
<p>虚析构和纯虚析构共性:</p> 
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul> 
<p>虚构和纯虚析构区别：</p> 
<ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul> 
<p>虚析构语法：</p> 
<p><code>virtual ~类名(){}</code></p> 
<p>纯虚析构语法：</p> 
<p><code>virtual ~类名() = 0;</code></p> 
<p><strong>虚析构函数就是用来解决通过父类指针释放子类对象</strong></p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;
class Animal {
public:
	Animal()
	{
		cout &lt;&lt; "Animal 构造函数调用！" &lt;&lt; endl;
	}
	virtual void Speak() = 0;

	//析构函数加上virtual关键字，变成虚析构函数
	//virtual ~Animal()
	//{
	//	cout &lt;&lt; "Animal虚析构函数调用！" &lt;&lt; endl;
	//}


	virtual ~Animal() = 0;
};

Animal::~Animal()
{
	cout &lt;&lt; "Animal 纯虚析构函数调用！" &lt;&lt; endl;
}

//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。

class Cat : public Animal {
public:
	Cat(string name)
	{
		cout &lt;&lt; "Cat构造函数调用！" &lt;&lt; endl;
		m_Name = new string(name);
	}
	virtual void Speak()
	{
		cout &lt;&lt; *m_Name &lt;&lt;  "小猫在说话!" &lt;&lt; endl;
	}
	~Cat()
	{
		cout &lt;&lt; "Cat析构函数调用!" &lt;&lt; endl;
		if (this-&gt;m_Name != NULL) {
			delete m_Name;
			m_Name = NULL;
		}
	}

public:
	string *m_Name;
};

void test01()
{
	Animal *animal = new Cat("Tom");
	animal-&gt;Speak();

	//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏
	//怎么解决？给基类增加一个虚析构函数
	//虚析构函数就是用来解决通过父类指针释放子类对象
	delete animal;
}

int main() {

	test01();


	return 0;
}
</code></pre> 
<p>内存泄漏(Memory Leak)是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成的内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p> 
<p>案例：</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class CPU
{
public:
    virtual void calculate() = 0;
};
class VedioCard
{
public:
    virtual void display() = 0;
};
class Memory
{
public:
    virtual void storage() = 0;
};

class IntelCPU:public CPU
{
    virtual void calculate()
    {
        cout&lt;&lt;"Intel的CPU开始计算了"&lt;&lt;endl;
    }
};
class IntelVedioCard:public VedioCard
{
    void display()
    {
        cout&lt;&lt;"Intel的显卡开始工作了"&lt;&lt;endl;
    }
};
class IntelMemory:public Memory
{
    void storage()
    {
        cout&lt;&lt;"Intel的存储开始存储了"&lt;&lt;endl;
    }
};

class LenovoCPU:public CPU
{
    void calculate()
    {
        cout&lt;&lt;"Lenovo的CPU开始计算了"&lt;&lt;endl;
    }
};
class LenovoVedioCard:public VedioCard
{
    void display()
    {
        cout&lt;&lt;"Lenovo的显卡开始工作了"&lt;&lt;endl;
    }
};
class LenovoMemory:public Memory
{
    void storage()
    {
        cout&lt;&lt;"Lenovo的存储开始存储了"&lt;&lt;endl;
    }
};

class Computer
{
public:
    Computer(CPU *cpu, VedioCard *vediocard,Memory *memory) {
        m_cpu = cpu;
        m_vc = vediocard;
        m_mem = memory;
    }
    void work()
    {
        m_cpu-&gt;calculate();
        m_vc-&gt;display();
        m_mem-&gt;storage();
    }
    ~Computer()
    {
        if (m_cpu !=NULL)
        {
            delete m_cpu;
            m_cpu = NULL;
        }
        if (m_vc !=NULL)
        {
            delete m_vc;
            m_vc = NULL;
        }
        if (m_mem !=NULL)
        {
            delete m_mem;
            m_mem = NULL;
        }
    }
private:
    CPU * m_cpu;
    VedioCard * m_vc;
    Memory * m_mem;
};
void test01()
{
    //组装第一台
    CPU *intelcpu = new IntelCPU;
    VedioCard *intelvc = new IntelVedioCard;
    Memory *intelmemory = new IntelMemory;
    Computer c1(intelcpu,intelvc,intelmemory);
    c1.work();
    Computer c2 (new LenovoCPU,new LenovoVedioCard,new LenovoMemory);
    c2.work();
}

int main()
{
    test01();
}
</code></pre> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

//创建抽象员工类
class Staff
{
public:
    int staffNum;
    int departNum;
    string staffName;
};
//创建老板类
class Boss:Staff
{
};
//创建经理类
class Manager:Staff
{
};
//创建员工类
class Employee:Staff
{
};
ofstream fs;
//添加员工的函数
void addStaff(Staff * staff)
{
    fs.open("./职工管理表.txt",ios::out|ios::app);
    if (fs.is_open())
    {
        cout&lt;&lt;"请输入员工姓名:"&lt;&lt;endl;
        cin&gt;&gt;staff-&gt;staffName;
        cout&lt;&lt;"请输入员工编号:"&lt;&lt;endl;
        cin&gt;&gt;staff-&gt;staffNum;
        cout&lt;&lt;"请输入部门编号:"&lt;&lt;endl;
        cin&gt;&gt;staff-&gt;departNum;
        fs&lt;&lt;staff-&gt;staffName&lt;&lt;endl;
        fs&lt;&lt;staff-&gt;staffNum&lt;&lt;endl;
        fs&lt;&lt;staff-&gt;departNum&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;"文件打开失败"&lt;&lt;endl;
    }
}







//显示和选择函数
void show_choose()
{
    while (true)
    {
        int choose;
        cout&lt;&lt;"****************"&lt;&lt;endl;
        cout&lt;&lt;"欢迎使用职工管理系统"&lt;&lt;endl;
        cout&lt;&lt;"0.退出管理系统"&lt;&lt;endl;
        cout&lt;&lt;"1.增加职工信息"&lt;&lt;endl;
        cout&lt;&lt;"2.显示职工信息"&lt;&lt;endl;
        cout&lt;&lt;"3.删除离职职工"&lt;&lt;endl;
        cout&lt;&lt;"4.修改职工信息"&lt;&lt;endl;
        cout&lt;&lt;"5.查找职工信息"&lt;&lt;endl;
        cout&lt;&lt;"6.按照编号排序"&lt;&lt;endl;
        cout&lt;&lt;"7.清空所有文档"&lt;&lt;endl;
        cout&lt;&lt;"****************"&lt;&lt;endl;
        cout&lt;&lt;"请输入您的选择:"&lt;&lt;endl;
        cin&gt;&gt;choose;
        if (choose==0)//退出管理系统
        {
            cout&lt;&lt;"成功退出!"&lt;&lt;endl;
            break;
        }
        else if (choose==1)//增加职工信息
        {
            addStaff(new Staff);
        }
        else if (choose==2)//显示职工信息
        {

        }
        else if (choose==3)//删除职工信息
        {

        }
        else if (choose==4)//修改职工信息
        {

        }
        else if (choose==5)//查找职工信息
        {

        }
        else if (choose==6)//按照编号排序
        {

        }
        else if (choose==7)//清空所有文档
        {

        }
        else
        {
            cout&lt;&lt;"输入有误，请重新输入"&lt;&lt;endl;
        }
    }

}
int main()
{
    show_choose();
}
</code></pre> 
<hr> 
<h1>
<a id="_C_4076"></a>三、 C++提高</h1> 
<h3>
<a id="1__4080"></a>1. 模板</h3> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

template &lt;class NameType, class AgeType&gt;
class Person
{
public:
    Person(NameType name,AgeType age)
    {
        this-&gt;m_name = name;
        this-&gt;m_age = age;
    }
    void showPerson()
    {
        cout&lt;&lt;"name:"&lt;&lt;this-&gt;m_name&lt;&lt;endl;
        cout&lt;&lt;"age:"&lt;&lt;this-&gt;m_age&lt;&lt;endl;
    }

private:
    NameType m_name;
    AgeType m_age;
};

void test01()
{
    Person&lt;string,int&gt; p1("孙悟空",999);
    p1.showPerson();
}

int main()
{
    test01();
}
</code></pre> 
<h4>
<a id="_4119"></a>类模板和函数模板的区别</h4> 
<ol>
<li>类模板没有自动类型推导</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;
//类模板和函数模板的区别

template &lt;class NameType = string, class AgeType = int&gt;//默认参数
class Person
{
public:
    Person(NameType name,AgeType age)
    {
        this-&gt;m_name = name;
        this-&gt;m_age = 999;
    }
    void showPerson()
    {
        cout&lt;&lt;"name: "&lt;&lt;this-&gt;m_name&lt;&lt;endl;
        cout&lt;&lt;"age: "&lt;&lt;this-&gt;m_age&lt;&lt;endl;
    }

private:
    NameType m_name;
    AgeType m_age;
};

void test01()
{
//    Person p("孙悟空",1000)错误的，无法自动类型推导
    Person&lt;string,int&gt; p("孙悟空",999);
    p.showPerson();
}
//1. 类模板没有自动类型推到
//2. 类模板在模板参数列表中可以有默认参数
void test02()
{
    Person&lt;&gt; p("猪八戒",999);
}
int main()
{
    test01();
    test02();
}
</code></pre> 
<h4>
<a id="_4169"></a>类模板中成员函数的创建时机</h4> 
<p>类模板中的成员函数和普通类中成员函数创建时机是有区别的：</p> 
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

class Person1
{
public:
    void showPerson1()
    {
        cout&lt;&lt;"Person1 show"&lt;&lt;endl;
    }
};

class Person2
{
public:
    void showPerson2()
    {
        cout&lt;&lt;"Person2 show"&lt;&lt;endl;
    }
};
template&lt;class T&gt;
class MyClass
{
public:
    T obj;
    //类模板中的成员函数在调用时创建
    void func1()
    {
        obj.showPerson1();
    }
    void func2()
    {
        obj.showPerson2();
    }
};

void test01()
{
    MyClass&lt;Person2&gt; m;
//    m.func1();编译出错，说明函数调用时才会创建成员函数
    m.func2();
}


int main()
{
    test01();
}
</code></pre> 
<h4>
<a id="_4228"></a>类模板对象做函数参数</h4> 
<p>三种传入方式：</p> 
<ul>
<li>指定传入的类型 --直接显示对象的数据类型</li>
<li>参数模板化 --将对象中的参数变为模板进行传递</li>
<li>整个类模板化 --将这个对象类型模板化进行传递</li>
</ul> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;
//类模板对象做函数参数
template&lt;class T1,class T2&gt;
class Person
{
public:
    Person(T1 name,T2 age)
    {
        this-&gt;m_name=name;
        this-&gt;m_age=age;
    }
    T1 m_name;
    T2 m_age;
    void personShow()
    {
        cout&lt;&lt;"姓名： "&lt;&lt;this-&gt;m_name;
        cout&lt;&lt;"年龄: "&lt;&lt;this-&gt;m_age&lt;&lt;endl;
    }
};

//1. 指定传入类型
void printPerson1(Person&lt;string,int&gt; &amp;p)
{
    p.personShow();
}
void test01()
{
    Person&lt;string, int&gt; p("孙悟空",10);
    printPerson1(p);
}

//2. 参数模板化
template&lt;class T1, class T2&gt;
void printPerson2(Person&lt;T1,T2&gt; &amp;p)
{
    p.personShow();
    cout&lt;&lt;"T1的类型为："&lt;&lt;typeid(T1).name()&lt;&lt;endl;
    cout&lt;&lt;"T2的类型为："&lt;&lt;typeid(T2).name()&lt;&lt;endl;
}
void test02()
{
    Person&lt;string, int&gt; p("猪八戒",20);
    printPerson2(p);
}
//3. 整个类模板化
template&lt;class T&gt;
void printPerson3(T &amp;p)
{
    p.personShow();
    cout&lt;&lt;"T的类型为： "&lt;&lt; typeid(T).name()&lt;&lt;endl;
}
void test03()
{
    Person&lt;string ,int&gt; p("唐僧",30);
    printPerson3(p);
}
int main()
{
    test01();
    test02();
    test03();
}
</code></pre> 
<h4>
<a id="_4303"></a>类模板与继承</h4> 
<ul><li>当子类继承的父类是一个类模板时，子类在声明的时候要指出父类中T的类型</li></ul> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

template&lt;class T&gt;
class Base
{
    T m;
};
class Son:public Base&lt;int&gt;//继承时必须要知道父类T的类型才能继承给子类
{

};


void test01()
{
    Son s1;
}
</code></pre> 
<ul><li>如果想灵活指定父类中T的类型，子类也要写成一个类模板</li></ul> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;

template&lt;class T&gt;
class Base
{
    T m;
};
class Son1:public Base&lt;int&gt;
{

};
template&lt;class T1,class T2&gt;
class Son2:public Base&lt;T2&gt;
{
public:
    Son2()
    {
        cout&lt;&lt;"T1的数据类型为: "&lt;&lt;typeid(T1).name()&lt;&lt;endl;
        cout&lt;&lt;"T2的数据类型为: "&lt;&lt;typeid(T2).name()&lt;&lt;endl;
    }
    T1 obj;
};


void test01()
{
    Son1 s1;
}
void test02()
{
    Son2&lt;int,char&gt; s2;
}

int main()
{
    test01();
    test02();
}
</code></pre> 
<h4>
<a id="_4376"></a>模板类中函数的类外实现</h4> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;

using namespace std;
//类模板函数的类外实现
template&lt;class T1,class T2&gt;
class Person
{
public:
    T1 m_name;
    T2 m_age;
    Person(T1,T2);
    void showPerson();
};
template&lt;class T1, class T2&gt;
Person&lt;T1,T2&gt;::Person(T1 name, T2 age)
{
    this-&gt;m_name=name;
    this-&gt;m_age=age;
}
template&lt;class T1,class T2&gt;
void Person&lt;T1, T2&gt;::showPerson()
{
    cout&lt;&lt;"姓名： "&lt;&lt;this-&gt;m_name&lt;&lt;"年龄: "&lt;&lt;this-&gt;m_age&lt;&lt;endl;
}
void test01()
{
    Person&lt;string,int&gt; p("孙悟空",100);
    p.showPerson();
}
int main()
{
    test01();
}
</code></pre> 
<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p> 
<h4>
<a id="_4416"></a>类模板分文件编写</h4> 
<h3>
<a id="2_STLStandard_Template_Library_4420"></a>2. STL(Standard Template Library)标准模板库</h3> 
<p><strong>面向对象</strong>和<strong>泛型编程</strong>都是为了提高代码的复用性，STL就是为了提高数据结构和算法的复用性制作出来的</p> 
<p><strong>STL六大组件</strong></p> 
<ul><li><strong>容器</strong></li></ul> 
<p>各种数据结构vector list deque set map</p> 
<ul><li><strong>算法</strong></li></ul> 
<p>各种常用的算法 sort find copy for_each</p> 
<ul><li><strong>迭代器</strong></li></ul> 
<p>容器和算法之间的胶合剂</p> 
<ul><li>仿函数</li></ul> 
<p>行为类似函数，可作为算法的某种策略</p> 
<ul><li>适配器(配接器)</li></ul> 
<p>一种用来修饰容器或者仿函数或迭代器接口的东西</p> 
<ul><li>空间配置器</li></ul> 
<p>负责空间的配置与管理</p> 
<blockquote> 
 <p>容器和算法之间通过迭代器进行无缝连接</p> 
 <p>STL中的所有技术都采用了模板类或者模板函数</p> 
</blockquote> 
<h4>
<a id="_4456"></a>容器</h4> 
<p>STL容器就是将应用最广泛的数据结构表示出来</p> 
<p><strong>常用的数据结构</strong>：数组 链表 树 栈 几何 映射表等等</p> 
<p>容器分为序列式容器和关联式容器</p> 
<p><strong>序列式容器</strong>：强调值的排序，序列式容器的每个元素均有固定位置</p> 
<p><strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序</p> 
<h5>
<a id="vector_4472"></a>vector</h5> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

using namespace std<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">myPrint</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//创建了一个vector容器</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    
    <span class="token comment">//想容器中插入数据</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//通过迭代器访问容器中的数据</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator itBegin <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//其实迭代器</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator itEnd <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结束迭代器，指向容器最后一个元素的下一个位置</span>
   
    <span class="token comment">//第一种遍历方式</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>itBegin<span class="token operator">!=</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>itBegin <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        itBegin<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//第二种遍历方式</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator it<span class="token operator">=</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>v<span class="token punctuation">.</span>end<span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//第三种遍历方式</span>
    <span class="token function">for_each</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>myPrint<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//回调函数</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>vector是STL中最常用的一种数据结构</p> 
<p><strong>特点：</strong></p> 
<ul>
<li> <p>与数组类似，但是数组是固定长度，vector是长度可变的，可以动态扩展的。</p> </li>
<li> <p>支持随机访问</p> </li>
<li> <p><img src="https://images2.imgbox.com/fd/07/RNj3ydUY_o.png" alt="image-20221123123028010"></p> </li>
<li> <p>动态扩展并不是在原有的空间进行扩展，而是新建一个比原来更大的空间，空间的大小由vector内部的算法确定</p> </li>
</ul> 
<p><strong>vector的构造函数</strong></p> 
<ul>
<li>
<code>vector&lt;T&gt; v;</code>用类模板实现，默认构造函数</li>
<li>
<code>vector(v.begin(), v.end());</code>将一个<code>v[v.begin(),v.end())</code>前闭后开的区间的内容给vector，</li>
<li>
<code>vector(n,elem);</code>将n个elem给vector</li>
<li>
<code>vector(const vector&amp; v);</code>拷贝构造函数</li>
</ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printVector</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> n <span class="token operator">:</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span><span class="token comment">//默认构造</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"v1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">printVector</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将v1迭代器区间的内容给v2</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"v2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">printVector</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//n个elem</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"v3"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">printVector</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v4</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝构造</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"v4"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">printVector</span><span class="token punctuation">(</span>v4<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>vector赋值</strong></p> 
<p>函数原型：</p> 
<ul>
<li>
<code>vector&amp; operator=(const vector&amp; v);</code>//重载=操作符</li>
<li>
<code>assign(v.begin(),v.end());</code>将左闭右开区间<code>[begin,end)</code>赋值给本身</li>
<li>
<code>assign(n,elem);</code>将n个elem赋值给本身</li>
</ul> 
<p>示例：</p> 
<pre><code class="prism language-c++">void test01()
{
    vector&lt;int&gt; v1;
    for(int i=0;i&lt;10;i++)
    {
        v1.push_back(i);
    }
    vector&lt;int&gt; v2 = v1;//等号操作符进行赋值

    vector&lt;int&gt; v3;//将左闭右开区间赋值给本身
    v3.assign(v1.begin(),v1.end());

    vector&lt;int&gt; v4;
    v4.assign(10,1);//n个elem

}
</code></pre> 
<p>vector<strong>容器的容量和大小</strong></p> 
<p>函数原型</p> 
<ul>
<li>
<code>empty()</code>判断容器是否为空</li>
<li>
<code>capacity()</code>容器的容量,vector容器的容量会比存放的数据多一点</li>
<li>
<code>size()</code>容器中元素的个数</li>
<li>
<code>resize(int num)</code>，重新指定容器的大小，如果容器变长，原数据填充原位置，若变短，则超出容器范围的数据被删除</li>
<li>
<code>resize(innt num,elem)</code>重新指定容器的大小，如果容器变长，原数据填充原位置，以elem填充原位置，若变短，则超出容器范围的数据被删除</li>
</ul> 
<pre><code class="prism language-c++">void test01()
{
    vector&lt;int&gt; v1;
    for(int i=0;i&lt;10;i++)
    {
        v1.push_back(i);
    }
    cout&lt;&lt;"v1是否为空"&lt;&lt;v1.empty()&lt;&lt;endl;

    cout&lt;&lt;"v1的容量"&lt;&lt;v1.capacity()&lt;&lt;endl;

    cout&lt;&lt;"v1元素个数"&lt;&lt;v1.size()&lt;&lt;endl;

    v1.resize(5);
    printVector(v1);

    v1.resize(10,1);
    printVector(v1);
}
</code></pre> 
<p>vector<strong>的插入和删除</strong></p> 
<p>函数原型</p> 
<ul>
<li>
<code>push_back(elem)</code>尾部插入元素</li>
<li>
<code>pop_back()</code>删除最后一个元素</li>
<li>
<code>insert(const_iterator pos,elem)</code>迭代器向指定位置pos插入元素elem</li>
<li>
<code>insert(const_iterator pos,int count,elem)</code>向指定位置插入count个elem</li>
<li>
<code>erase(const_iterator pos)</code>删除指定位置元素</li>
<li>
<code>erase(const_iterator begin,const_iterator end)</code>删除从begin到end的元素</li>
<li>
<code>clear()</code>删除元素中所有的元素</li>
</ul> 
<p>vector<strong>数据的存取</strong></p> 
<p>函数原型</p> 
<ul>
<li>
<code>at(int index)</code>获取index位置的元素</li>
<li>
<code>operator[int index]</code>获取index处的元素</li>
<li>
<code>front()</code>获取第一个元素</li>
<li>
<code>back()</code>获取最后一个元素</li>
</ul> 
<p>vector<strong>互换容器</strong></p> 
<p>函数原型</p> 
<ul><li>
<code>swap(vector&amp; v)</code>容器本身与容器v互换</li></ul> 
<p>作用1：收缩内存</p> 
<pre><code class="prism language-C++">void test01()
{
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10000; ++i) {
        v.push_back(i);
    }
    cout&lt;&lt;"v的容量"&lt;&lt;v.capacity()&lt;&lt;endl;//v的容量16384
    v.resize(3);
    cout&lt;&lt;"resize后的容量"&lt;&lt;v.capacity()&lt;&lt;endl;//resize后的容量16384
    vector&lt;int&gt;(v).swap(v);

    cout&lt;&lt;"交换后v的容量"&lt;&lt;v.capacity()&lt;&lt;endl;//交换后v的容量3
}
</code></pre> 
<p>vector<strong>预留空间</strong></p> 
<p>作用：提前预留空间，减少动态扩展容量时的扩展次数</p> 
<p>函数原型</p> 
<ul><li>
<code>reserve(int len)</code>预留len个空间</li></ul> 
<p>​</p> 
<p>reserve只预留空间不初始化数据</p> 
<p>如果vector要存放的数据比较多，可以直接预留足够的空间，不用一次次地动态扩展，影响性能</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>

    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            num<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"v1动态扩展的次数:"</span><span class="token operator">&lt;&lt;</span>num<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>


    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>
    <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
    v2<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token operator">&amp;</span>v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            num2<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"v2动态扩展的次数:"</span><span class="token operator">&lt;&lt;</span>num2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="string_4760"></a>string容器</h5> 
<p>string是C++中用于管理字符的一个类</p> 
<p>本质上字符在string类中是char *类型的变量，只不过被封装成了一个类,这个类中重载了很多运算符，使其像个数组一样。下面总结了一些string类的函数和重载的运算符</p> 
<p><strong>string的构造函数</strong></p> 
<p><code>string()</code>默认构造</p> 
<p><code>string(const char* s)</code>字符串构造</p> 
<p><code>string(const string&amp; s)</code>拷贝构造</p> 
<p><code>string(int num, char c)</code>数值*字符构造</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

using namespace std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>
    string s1<span class="token punctuation">;</span><span class="token comment">//默认构造</span>
    string <span class="token function">s2</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用字符常量构造</span>
    string <span class="token function">s3</span><span class="token punctuation">(</span><span class="token string">"hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同上</span>
    string <span class="token function">s4</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝构造</span>
    string <span class="token function">s5</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数量*字符</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"s1 = "</span><span class="token operator">&lt;&lt;</span>s1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"s2 = "</span><span class="token operator">&lt;&lt;</span>s2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"s3 = "</span><span class="token operator">&lt;&lt;</span>s3<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"s4 = "</span><span class="token operator">&lt;&lt;</span>s4<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"s5 = "</span><span class="token operator">&lt;&lt;</span>s5<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>string的赋值操作</strong></p> 
<p><code>string&amp; operator=(const char* s)</code></p> 
<p><code>string&amp; operator=(const string&amp; s)</code></p> 
<p><code>string&amp; operator=(const char c)</code></p> 
<p><code>string&amp; assign(const char* s)</code> 把字符串赋值给string对象</p> 
<p><code>string&amp; assign(const char* s, int n)</code> 把字符串前n个字符赋值给string对象</p> 
<p><code>string&amp; assign(string&amp; s)</code> 另一个string给这个string</p> 
<p><code>string&amp; assign(int n,char c)</code> n个字符</p> 
<p><strong>string字符串拼接</strong></p> 
<p><code>string&amp; operator+=(const char* s)</code></p> 
<p><code>string&amp; operator+=(const string&amp; s)</code></p> 
<p><code>string&amp; operator+=(const char c)</code></p> 
<p><code>string&amp; append(const char* s)</code></p> 
<p><code>string&amp; append(const string&amp; s)</code></p> 
<p><code>string&amp; append(const char c)</code></p> 
<p><code>string&amp; append(const string&amp; s, int pos, int n)</code></p> 
<p><strong>string查找和替换</strong></p> 
<p>函数原型</p> 
<blockquote> 
 <p>在类里面的函数后面加const使函数变为调用时不可修改类内部数据的函数</p> 
</blockquote> 
<ul>
<li> <p><code>int find(const string&amp; str, int pos=0) const</code> //查找str<strong>第一次</strong>出现的位置，从pos开始查找，<strong>找不到返回-1</strong></p> </li>
<li> <p><code>int find(const char* str,int pos=0) const</code> //同上</p> </li>
<li> <p><code>int find(const char* str, int pos=0, int n) const</code> //从pos位置查找str的前n个元素的位置</p> </li>
<li> <p><code>int find(const char c, int pos=0) const</code> //从pos位置查找字符c</p> </li>
<li> <p><code>int rfind(const string&amp; str, int pos=npos) const</code>//查找str的<strong>最后出现</strong>的位置，从pos开始查找</p> </li>
<li> <p><code>int rfind(const char* str,int pos=npos) const</code> //同上</p> </li>
<li> <p><code>int rfind(const char* str, int pos, int n) const</code> //从pos位置查找str的前n个元素的位置</p> </li>
<li> <p><code>int rfind(const char c, int pos=0) const</code> //从pos位置查找字符c</p> </li>
<li> <p><code>string&amp; replace(int pos, int n, const string&amp; str)</code>从pos开始n个字符为字符串str</p> </li>
<li> <p><code>string&amp; replace(int pos, int n, const char* s)</code></p> </li>
</ul> 
<p>示例：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    string str <span class="token operator">=</span> <span class="token string">"abcdefef"</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"ef"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>pos<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//4</span>
    <span class="token keyword">int</span> pos2 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">rfind</span><span class="token punctuation">(</span><span class="token string">"ef"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>pos2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//6</span>
    
    str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>str<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//a1111efef,从位置1开始后面的三个字符变为1111</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>总结：</p> 
<p>find从左往右，rfind从右往左</p> 
<p>find返回查找的第一个字符，找不到返回-1</p> 
<p>replace在替换时将从哪个位置起，多少个字符，替换为 什么</p> 
<p><strong>string的字符串比较</strong></p> 
<p>按ASCII码进行比较</p> 
<p>=返回0</p> 
<p>&gt;返回1</p> 
<p>&lt;返回-1</p> 
<pre><code>test01()
{
	string str1 = "hello";
	string str2 = "world";
	if(str1.compare(str2)==0)
	{
		cout&lt;&lt;"str1=str2"&lt;&lt;endl;
	}
}
</code></pre> 
<p><strong>string字符存取</strong></p> 
<ul>
<li>
<code>char&amp; operator[](int n)</code>[ ]方式</li>
<li>
<code>char&amp; at(int)</code>//at方式</li>
</ul> 
<pre><code class="prism language-c"><span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	string str <span class="token operator">=</span> <span class="token string">"abcdefg"</span><span class="token punctuation">;</span>
    <span class="token comment">//第一种方式</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout<span class="token operator">&lt;&lt;</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//第二种方式</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout<span class="token operator">&lt;&lt;</span>str<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>string插入和删除</strong></p> 
<p>函数原型</p> 
<ul>
<li>
<code>string&amp; insert(int pos, const char* s);</code>//插入字符串</li>
<li>
<code>string&amp; insert(int pos, const string&amp; str);</code>插入字符串</li>
<li>
<code>string&amp; insert(int pos, int n, char c);</code>在指定位置插入n个字符</li>
<li>
<code>string&amp; erase(int pos, int = npos);</code>删除从pos开始的n个字符</li>
</ul> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    string str1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    string str2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
    str1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>str1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//hello空格</span>
    str1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>str1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//hello world</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>string子串</strong></p> 
<p>函数原型：</p> 
<ul><li>
<code>string substr(int pos=0, int n=npos) const;</code>//返回由pos开始的n个字符串组成的字符串</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    string str1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>

    string str2 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>str2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="deque_4994"></a>deque容器</h5> 
<p>deque是一个双端数组，可对头端进行插入</p> 
<p>deque与vector的区别：</p> 
<ul>
<li>deque的头部插入比vector快</li>
<li>deque的访问速度不如vector</li>
</ul> 
<p><img src="https://images2.imgbox.com/60/b3/Hq2iyigB_o.png" alt="image-20221123162825275"></p> 
<p>deque内部原理：</p> 
<p><img src="https://images2.imgbox.com/99/49/bhNVL9WC_o.png" alt="image-20221123163056518"></p> 
<p><strong>构造函数</strong></p> 
<p>函数原型：</p> 
<ul>
<li>
<code>deque&lt;T&gt; deqT;</code>默认构造</li>
<li><code>deque(beg,end);</code></li>
<li><code>deque(n, elem);</code></li>
<li><code>deque(const deque&amp; deq);</code></li>
</ul> 
<p><strong>deque赋值</strong></p> 
<p>与vector类似</p> 
<p>函数原型：</p> 
<ul>
<li><code>deque&amp; operator=(const deque&amp; deq);</code></li>
<li><code>assign(begin,end);</code></li>
<li><code>assign(n,elem);</code></li>
</ul> 
<p><strong>deque大小</strong></p> 
<p>函数原型：</p> 
<ul>
<li>
<code>deque.empty();</code>判断容器是否为空</li>
<li>
<code>deque.size();</code>返回容器中元素的个数</li>
<li>
<code>deque.resize(num);</code>重新指定容器长度为num，容器变长以0填充，容器变短，超出部分被删除</li>
<li>
<code>deque.resize(num, elem);</code>重新指定容器长度为num，容器变长以elem填充，容器变短，超出部分被删除</li>
</ul> 
<p><strong>deque插入和删除</strong></p> 
<p>函数原型：</p> 
<p>两端插入操作</p> 
<ul>
<li>
<code>push_back(elem);</code>尾部插入</li>
<li>
<code>push_front(elem);</code>头部插入</li>
<li>
<code>pop_back();</code>删除最后一个数据</li>
<li>
<code>pop_front();</code>删除第一个数据</li>
</ul> 
<p>指定位置插入删除：</p> 
<ul>
<li>
<code>insert(pos, elem);</code> 在pos位置插入一个elem元素的拷贝，返回数据的位置</li>
<li>
<code>insert(pos,n,elem);</code>在pos位置插入n个elem，无返回值</li>
<li>
<code>insert(pos, begin,end);</code>在pos位置插入[begin,end)区间的数据，无返回值</li>
<li>
<code>clear();</code>清空容器</li>
<li>
<code>erase(begin, end);</code>删除[begin,end)区间的数据，返回邪恶一个数据的位置</li>
<li>
<code>erase(pos);</code>删除pos位置的数据，返回下一个数据的位置</li>
</ul> 
<p><strong>deque数据存取</strong></p> 
<p>函数原型：</p> 
<ul>
<li>
<code>at(int index);</code>返回索引index所指的数据</li>
<li>
<code>operator[]</code>返回索引index所指的数据</li>
<li>
<code>front();</code>返回第一个数据</li>
<li>
<code>back();</code>返回最后一个数据</li>
</ul> 
<p><strong>deque排序操作</strong></p> 
<p>利用算法实现deque内部数据的排序</p> 
<p><code>#include &lt;algorithm&gt;</code></p> 
<p>函数原型：</p> 
<ul><li>
<code>sort(iterator begin,iterator end);</code>对beg,end区间内的元素进行排序</li></ul> 
<pre><code class="prism language-c++">void test01()
{
    deque&lt;int&gt; deq;
    deq.push_back(10);
    deq.push_back(20);
    deq.push_back(30);
    deq.push_front(100);
    deq.push_front(200);
    deq.push_front(300);
    //300 200 100 10 20 30
    printDeque(deq);
    sort(deq.begin(),deq.end());
    printDeque(deq);//10 20 30 100 200 300
}
</code></pre> 
<p><img src="https://images2.imgbox.com/a8/b6/hKJblyP5_o.png" alt="image-20221123170301314"></p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;

using namespace std;

class Person;
void createPlayer(vector&lt;Person&gt;&amp;);

void setScore(vector&lt;Person&gt;&amp;);

void showScores(vector&lt;Person&gt;);

class Person
{
public:
    explicit Person(string name, double score=0): m_name(std::move(name)), m_score(score){}
    string m_name;
    double m_score;
};
int main()
{
    //1. 创建一个vector容器存放5个选手
    vector&lt;Person&gt; v;
    createPlayer(v);
    //测试
//    for(auto p:v)
//    {
//        cout&lt;&lt;p.m_name&lt;&lt;endl;
//    }

    //2. 打分
    setScore(v);

    //3. 展示
    showScores(v);

}

void showScores(const vector&lt;Person&gt;&amp; v) {
    for(const auto &amp; it : v)
    {
        cout&lt;&lt;"姓名："&lt;&lt;it.m_name&lt;&lt;" 得分："&lt;&lt;it.m_score&lt;&lt;endl;
    }
}

void setScore(vector&lt;Person&gt;&amp; v) {
    srand((unsigned int)time(nullptr));//随机数种子
    for(auto &amp; it : v)
    {
        deque&lt;int&gt; scores;
        for (int i = 0; i &lt; 10; ++i) {
            int score = rand() % 40 +60;
            scores.push_back(score);
        }
        scores.pop_front();
        scores.pop_back();

        int sum = 0;
        for(int &amp; score : scores)
        {
            sum += score;
        }
        double average = sum / scores.size();

        it.m_score = average;
    }
}

void createPlayer(vector&lt;Person&gt;&amp; v) {
    string nameSeed = "ABCDE";
    for (int i = 0; i &lt; 5; ++i) {
        string name = "选手";
        name += nameSeed[i];

        Person p(name);

        v.push_back(p);
    }
}
</code></pre> 
<p>随机数种子</p> 
<pre><code class="prism language-c++">srand((unsigned int)time(nullptr));//随机数种子
rand() % 40 + 60//产生60~100的随机数
</code></pre> 
<p>Parameter ‘name’ is passed by value and only copied once; consider moving it to avoid unnecessary copies</p> 
<p><strong>explicit关键字</strong></p> 
<p>explicit的一个英文意思是显式的</p> 
<p>explicit用于构造函数前，使用该关键字后，在参数列表有默认参数的情况下，构造函数不能进行隐式转换</p> 
<p><strong>std::move函数</strong></p> 
<p>C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。<br> std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。<br> 对指针类型的标准库对象并不需要这么做.</p> 
<h5>
<a id="stack_5243"></a>stack</h5> 
<p><img src="https://images2.imgbox.com/f7/25/1YKNgcoT_o.png" alt="image-20221127171258461"></p> 
<ul>
<li> <p>先进后出，后进先出的结构，只有一个出口</p> </li>
<li> <p>不允许遍历</p> </li>
</ul> 
<p>构造函数</p> 
<ul>
<li>
<code>stack&lt;T&gt; stk</code>//默认构造</li>
<li>
<code>stack(const stack &amp;stk)</code>//拷贝构造函数</li>
</ul> 
<p>赋值</p> 
<ul><li><code>stack&amp; operator=(const stack&amp; stk);</code></li></ul> 
<p>数据存取</p> 
<ul>
<li>
<code>pop()</code>//从栈顶移除第一个元素</li>
<li>
<code>push()</code>//向栈顶添加元素</li>
<li>
<code>top()</code>//返回栈顶元素</li>
</ul> 
<p>大小操作</p> 
<ul>
<li>判断栈是否为空empty()</li>
<li>返回栈元素个数size()</li>
</ul> 
<h5>
<a id="queue_5281"></a>queue容器</h5> 
<p><img src="https://images2.imgbox.com/0f/de/FAdG51TG_o.png" alt="image-20221128101847399"></p> 
<ul><li>先进先出，只能访问队头队尾元素，不允许有遍历行为</li></ul> 
<p>构造函数</p> 
<ul>
<li>
<code>queue&lt;T&gt; que</code>//queue采用模板类实现，queue对象的默认构造</li>
<li>
<code>queue(const queue&amp; que)</code>//拷贝构造函数</li>
</ul> 
<p>赋值操作</p> 
<ul><li>
<code>queue&amp; operator=(const queue&amp; que)</code>//重载等号运算符</li></ul> 
<p>数据存取</p> 
<ul>
<li>
<code>push()</code>//往队尾添加元素</li>
<li>
<code>pop()</code>//从对头移除第一个元素</li>
<li>
<code>back()</code>//返回最后一个元素</li>
<li>
<code>front()</code>//返回第一个元素</li>
</ul> 
<p>大小操作</p> 
<ul>
<li>
<code>empty()</code>判断是否为空</li>
<li>
<code>size()</code>//返回队列的大小</li>
</ul> 
<h5>
<a id="list_5312"></a>list容器</h5> 
<p><img src="https://images2.imgbox.com/82/15/uPckMP65_o.png" alt="image-20221128103224913"></p> 
<ul>
<li> <p>将数据进行链式存储，物理地址上是非连续的，逻辑地址通过指针进行链接</p> </li>
<li> <p>链表由一系列结点组成</p> </li>
<li> <p>结点由存储数据的数据域和存储下一个结点地址的指针域</p> </li>
<li> <p>STL中的链表是双向循环列表</p> </li>
</ul> 
<p>优点：</p> 
<ul><li>可以对一个位置进行快速的插入或删除元素</li></ul> 
<p>缺点：</p> 
<ul>
<li> <p>遍历速度没有数组快</p> </li>
<li> <p>占用的空间比数组大</p> </li>
</ul> 
<p><strong>构造函数</strong></p> 
<ul>
<li>
<code>list&lt;T&gt; lst;</code>//默认构造</li>
<li>
<code>list(beg,end);</code>//构造函数将[begin,end)区间内的内容赋值给list</li>
<li>
<code>list(n.elem);</code>//n个elem</li>
<li>
<code>list(const list&amp; lst);</code>//拷贝构造</li>
</ul> 
<p><strong>赋值和交换</strong></p> 
<ul>
<li>
<code>assign(begin,end);</code>//赋区间[begin,end)的值</li>
<li>
<code>assign(n,elem);</code>//n个elem</li>
<li>
<code>list&amp; operator=(const list &amp;lst);</code>//重载=操作符</li>
<li>
<code>swap(lst);</code>//将自身内容与lst互换交换</li>
</ul> 
<p><strong>大小操作</strong></p> 
<ul>
<li>
<code>empty()</code>判断容器是否为空</li>
<li>
<code>size()</code>容器中元素的个数</li>
<li>
<code>resize(int num)</code>，重新指定容器的大小，如果容器变长，原数据填充原位置，若变短，则超出容器范围的数据被删除</li>
<li>
<code>resize(innt num,elem)</code>重新指定容器的大小，如果容器变长，原数据填充原位置，以elem填充原位置，若变短，则超出容器范围的数据被删除</li>
</ul> 
<p><strong>list插入和删除</strong></p> 
<p><strong>函数原型：</strong></p> 
<ul>
<li> <p>push_back(elem);//在容器尾部加入一个元素</p> </li>
<li> <p>pop_back();//删除容器中最后一个元素</p> </li>
<li> <p>push_front(elem);//在容器开头插入一个元素</p> </li>
<li> <p>pop_front();//从容器开头移除第一个元素</p> </li>
<li> <p>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</p> </li>
<li> <p>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</p> </li>
<li> <p>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</p> </li>
<li> <p>clear();//移除容器的所有数据</p> </li>
<li> <p>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</p> </li>
<li> <p>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</p> </li>
<li> <p>remove(elem);//删除容器中所有与elem值匹配的元素。</p> </li>
<li> <p>尾插 — push_back</p> </li>
<li> <p>尾删 — pop_back</p> </li>
<li> <p>头插 — push_front</p> </li>
<li> <p>头删 — pop_front</p> </li>
<li> <p>插入 — insert</p> </li>
<li> <p>删除 — erase</p> </li>
<li> <p>移除 — remove</p> </li>
<li> <p>清空 — clear</p> </li>
</ul> 
<p><strong>list 数据存取</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>对list容器中数据进行存取</li></ul> 
<p><strong>函数原型：</strong></p> 
<ul>
<li>
<code>front();</code> //返回第一个元素。</li>
<li>
<code>back();</code> //返回最后一个元素。</li>
</ul> 
<p>list容器中不可以通过[]或者at方式访问数据</p> 
<p><strong>list 反转和排序</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul> 
<p><strong>函数原型：</strong></p> 
<ul>
<li>
<code>reverse();</code> //反转链表</li>
<li>
<code>sort();</code> //链表排序</li>
</ul> 
<pre><code class="prism language-c++">void printList(const list&lt;int&gt;&amp; L) {

	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

bool myCompare(int val1 , int val2)
{
	return val1 &gt; val2;
}

//反转和排序
void test01()
{
	list&lt;int&gt; L;
	L.push_back(90);
	L.push_back(30);
	L.push_back(20);
	L.push_back(70);
	printList(L);

	//反转容器的元素
	L.reverse();
	printList(L);

	//排序
	L.sort(); //默认的排序规则 从小到大
	printList(L);

	L.sort(myCompare); //指定规则，从大到小，myCompare是一个回调函数
	printList(L);
}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre> 
<h5>
<a id="set_5476"></a>set基本概念</h5> 
<p><strong>简介：</strong></p> 
<ul><li>所有元素都会在插入时自动被排序</li></ul> 
<p><strong>本质：</strong></p> 
<ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul> 
<p><strong>set和multiset区别</strong>：</p> 
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul> 
<p><strong>set构造和赋值</strong></p> 
<p>功能描述：创建set容器以及赋值</p> 
<p>构造：</p> 
<ul>
<li>
<code>set&lt;T&gt; st;</code> //默认构造函数：</li>
<li>
<code>set(const set &amp;st);</code> //拷贝构造函数</li>
</ul> 
<p>赋值：</p> 
<ul><li>
<code>set&amp; operator=(const set &amp;st);</code> //重载等号操作符</li></ul> 
<p>插入：</p> 
<ul><li>只有<code>insert()</code>
</li></ul> 
<p>并且元素在插入之后会自动排序</p> 
<p><strong>大小和交换</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>统计set容器大小以及交换set容器</li></ul> 
<p><strong>函数原型：</strong></p> 
<ul>
<li>
<code>size();</code> //返回容器中元素的数目</li>
<li>
<code>empty();</code> //判断容器是否为空</li>
<li>
<code>swap(st);</code> //交换两个集合容器</li>
</ul> 
<p><strong>set插入和删除</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>set容器进行插入数据和删除数据</li></ul> 
<p><strong>函数原型：</strong></p> 
<ul>
<li>
<code>insert(elem);</code> //在容器中插入元素。</li>
<li>
<code>clear();</code> //清除所有元素</li>
<li>
<code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li>
<code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li>
<code>erase(elem);</code> //删除容器中值为elem的元素。</li>
</ul> 
<p><strong>set查找和统计</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>对set容器进行查找数据以及统计数据</li></ul> 
<p><strong>函数原型：</strong></p> 
<ul>
<li>
<code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li>
<code>count(key);</code> //统计key的元素个数</li>
</ul> 
<p><strong>set和multiset区别</strong></p> 
<p><strong>学习目标：</strong></p> 
<ul><li>掌握set和multiset的区别</li></ul> 
<p><strong>区别：</strong></p> 
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

int main()
{
    set&lt;int&gt; s;
    pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s.insert(10);
    if(ret.second){
        cout&lt;&lt;"第一次插入成功"&lt;&lt;endl;
    }else{
        cout&lt;&lt;"第一次插入失败"&lt;&lt;endl;
    }
    ret = s.insert(10);
    if(ret.second){
        cout&lt;&lt;"第二次插入成功"&lt;&lt;endl;
    }else{
        cout&lt;&lt;"第二次插入失败"&lt;&lt;endl;
    }
    multiset&lt;int&gt; ms;
    ret = ms.insert(10);
    if(ret.second){
        cout&lt;&lt;"multiset插入成功"&lt;&lt;endl;
    }else{
        cout&lt;&lt;"multiset插入失败"&lt;&lt;endl;
    }
    ret = ms.insert(10);
    ret = ms.insert(10);
    cout&lt;&lt;ret.second&lt;&lt;endl;
    cout&lt;&lt;ret.second&lt;&lt;endl;
}
</code></pre> 
<p><strong>pair的使用</strong></p> 
<p>pair是成对存在的一组数据</p> 
<p>对组的创建</p> 
<ul>
<li><code>pair&lt;type1,type2&gt; p(value1,value2);</code></li>
<li><code>pair&lt;type1,type2&gt; p = make_pair(value1,value2);</code></li>
</ul> 
<p>访问</p> 
<ul>
<li><code>p.first</code></li>
<li><code>p.second</code></li>
</ul> 
<p><strong>set容器排序规则</strong></p> 
<p>默认排序规则从小到大，利用仿函数改变规则</p> 
<p>使用仿函数</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;set&gt;
using namespace std;
class MyCompare{
public:
    bool operator()(const int&amp;v1,const int&amp;v2){
        return v1&gt;v2;
    }
};
int main(){
    set&lt;int,MyCompare&gt; s;
    s.insert(1);
    s.insert(2);
    s.insert(3);
    for(const auto&amp;i:s){
        cout&lt;&lt;i&lt;&lt;endl;
    }
}
</code></pre> 
<p>set容器使用自定义数据类型插入时会报错，所以需要指定排序规则</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;utility&gt;

using namespace std;
class Person{
public:
    Person(string name,int age){
        this-&gt;name = std::move(name);
        this-&gt;age=age;
    }
    string name;
    int age;
};
class comparePerson{
public:
    bool operator()(const Person&amp; p1, const Person&amp; p2){
        return p1.age&gt;p2.age;
    }
};

int main(){
    set&lt;Person,comparePerson&gt; s;
    s.insert(Person("刘备",12));
    s.insert(Person("关羽",21));

    for(const auto&amp;i:s){
        cout&lt;&lt;"姓名:"&lt;&lt;i.name&lt;&lt;" 年龄:"&lt;&lt;i.age&lt;&lt;endl;
    }
}
</code></pre> 
<h5>
<a id="map_5717"></a><strong>map容器</strong>
</h5> 
<p><strong>map基本概念</strong></p> 
<p><strong>简介：</strong></p> 
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul> 
<p><strong>本质：</strong></p> 
<ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul> 
<p><strong>优点：</strong></p> 
<ul><li>可以根据key值快速找到value值</li></ul> 
<p>map和multimap<strong>区别</strong>：</p> 
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul> 
<p><strong>map构造和赋值</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>对map容器进行构造和赋值操作</li></ul> 
<p><strong>函数原型：</strong></p> 
<p><strong>构造：</strong></p> 
<ul>
<li>
<code>map&lt;T1, T2&gt; mp;</code> //map默认构造函数:</li>
<li>
<code>map(const map &amp;mp);</code> //拷贝构造函数</li>
</ul> 
<p><strong>赋值：</strong></p> 
<ul><li>
<code>map&amp; operator=(const map &amp;mp);</code> //重载等号操作符</li></ul> 
<pre><code class="prism language-c++">int main(){
    map&lt;int,int&gt; mp;
    
    map.insert(pair&lt;int,int&gt;(1,10));
    map.insert(pair&lt;int,int&gt;(3,30));
    map.insert(pair&lt;int,int&gt;(2,20));
    
    for(const auto&amp; i:mp){
        cout&lt;&lt;"key值="&lt;&lt;i.first&lt;&lt;"value="&lt;&lt;i.second&lt;&lt;endl;
    }
}
</code></pre> 
<p><strong>map大小和交换</strong></p> 
<ul><li>统计map容器大小以及交换map容器</li></ul> 
<p>函数原型：</p> 
<ul>
<li>
<code>size();</code> //返回容器中元素的数目</li>
<li>
<code>empty();</code> //判断容器是否为空</li>
<li>
<code>swap(st);</code> //交换两个集合容器</li>
</ul> 
<p><strong>map插入和删除</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>map容器进行插入数据和删除数据</li></ul> 
<p><strong>函数原型：</strong></p> 
<ul>
<li>
<code>insert(elem);</code> //在容器中插入元素。</li>
<li>
<code>clear();</code> //清除所有元素</li>
<li>
<code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li>
<code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li>
<code>erase(key);</code> //删除容器中值为key的元素。</li>
</ul> 
<p><strong>map查找和统计</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>对map容器进行查找数据以及统计数据</li></ul> 
<p><strong>函数原型：</strong></p> 
<ul>
<li>
<code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li>
<code>count(key);</code> //统计key的元素个数</li>
</ul> 
<p><strong>map容器排序</strong></p> 
<p><strong>学习目标：</strong></p> 
<ul><li>map容器<strong>默认排序规则为 按照key值进行 从小到大排序</strong>，掌握如何改变排序规则</li></ul> 
<p><strong>主要技术点:</strong></p> 
<ul><li>利用<strong>仿函数</strong>，可以改变排序规则</li></ul> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;
using namespace std;
class MyCompare{
    public:
    bool operator()(const int&amp;v1,const int&amp;v2){
        return v1&gt;v2;
    }
}

test01(){
    map&lt;int,int,MyCompare&gt; mp;
    mp.insert(pair&lt;int,int&gt;(1,10));
    mp.insert(pair&lt;int,int&gt;(4,40));
    mp.insert(make_pair(2,20));
    mp.insert(make_pair(3,30));
    
    for(const auto&amp;i:mp){
        cout&lt;&lt;"key="&lt;&lt;i.first&lt;&lt;"value="&lt;&lt;i.second&lt;&lt;endl;
    }
}
int main(){
    test01();
}
</code></pre> 
<h4>
<a id="_5887"></a>函数对象</h4> 
<p><strong>概念：</strong></p> 
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong>
</li>
<li>
<strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong>
</li>
</ul> 
<p><strong>本质：</strong></p> 
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p> 
<ul>
<li>函数对象在使用的时候可以像普通函数那样调用，可以有参数，可以有返回值</li>
<li>函数对象可以拥有自己的状态</li>
</ul> 
<pre><code class="prism language-C++">class MyAdd{
public:
    int operator()(int&amp; v1,int&amp; v2){
        status++;
        return v1+v2;
    }
	int status;
};
</code></pre> 
<p>一元谓词和二元谓词</p> 
<ul>
<li>返回<strong>bool类型的仿函数称为谓词</strong>
</li>
<li>如果operator()接收一个参数，那么叫做一元谓词</li>
<li>如果operator()接收两个参数，那么叫做二元谓词</li>
</ul> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class MyCompare{
public:
    bool operator()(const int&amp;v1,const int&amp;v2){
        return v1&gt;v2;
    }
};
bool mycompare(const int&amp; v1,const int&amp;v2){
    return v1&gt;v2;
}

int main(){
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    v.push_back(50);

    sort(v.begin(),v.end(), MyCompare());//使用放函数的形式
    sort(v.begin(),v.end(), mycompare);//也可以不使用仿函数，直接使用bool类型的函数
    for(const auto&amp; i:v){
        cout&lt;&lt;i&lt;&lt;endl;//遍历容器输出结果
    }
}
</code></pre> 
<h5>
<a id="STL_5964"></a><strong>STL内建函数对象</strong>
</h5> 
<p>分类：</p> 
<ul>
<li>算数仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul> 
<blockquote> 
 <p>这些仿函数所产生对象的用法和一般函数一样</p> 
 <p>使用内建函数对象需要引入头文件<code>#include &lt;functional&gt;</code></p> 
</blockquote> 
<p><strong>算数仿函数</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul> 
<p><strong>仿函数原型：</strong></p> 
<ul>
<li>
<code>template&lt;class T&gt; T plus&lt;T&gt;</code> //加法仿函数</li>
<li>
<code>template&lt;class T&gt; T minus&lt;T&gt;</code> //减法仿函数</li>
<li>
<code>template&lt;class T&gt; T multiplies&lt;T&gt;</code> //乘法仿函数</li>
<li>
<code>template&lt;class T&gt; T divides&lt;T&gt;</code> //除法仿函数</li>
<li>
<code>template&lt;class T&gt; T modulus&lt;T&gt;</code> //取模仿函数</li>
<li>
<code>template&lt;class T&gt; T negate&lt;T&gt;</code> //取反仿函数</li>
</ul> 
<pre><code class="prism language-c++">void test01(){
    negate&lt;int&gt;n;
    cout&lt;&lt;n(50)&lt;&lt;endl;//-50
    
    plus&lt;int&gt;p;
    cout&lt;&lt;p(10,40)&lt;&lt;endl;//50
}
</code></pre> 
<p><strong>关系仿函数</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>实现关系对比</li></ul> 
<p><strong>仿函数原型：</strong></p> 
<ul>
<li>
<code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code> //等于</li>
<li>
<code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code> //不等于</li>
<li>
<code>template&lt;class T&gt; bool greater&lt;T&gt;</code> //大于</li>
<li>
<code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code> //大于等于</li>
<li>
<code>template&lt;class T&gt; bool less&lt;T&gt;</code> //小于</li>
<li>
<code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code> //小于等于</li>
</ul> 
<pre><code class="prism language-c++">void test01(){
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    v.push_back(50);
    
    sort(v.begin(),v.end(),greater&lt;int&gt;());
}
</code></pre> 
<p><strong>逻辑仿函数</strong></p> 
<p><strong>功能描述：</strong></p> 
<ul><li>实现逻辑运算</li></ul> 
<p><strong>函数原型：</strong></p> 
<ul>
<li>
<code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code> //逻辑与</li>
<li>
<code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code> //逻辑或</li>
<li>
<code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code> //逻辑非</li>
</ul> 
<pre><code class="prism language-c++">#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
void test01()
{
    vector&lt;int&gt; v;//如果类型为int型，则除0以外的都是true
    v.push_back(true);
    v.push_back(false);
    v.push_back(true);
    v.push_back(3);

    for (auto &amp;&amp; it : v)
    {
        cout &lt;&lt; it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    //逻辑非  将v容器搬运到v2中，并执行逻辑非运算
    vector&lt;int&gt; v2;
    v2.resize(v.size());
    transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;&gt;());
    for (auto &amp;&amp; it : v2)
    {
        cout &lt;&lt; it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

int main() {

    test01();

    system("pause");

    return 0;
}
</code></pre>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>