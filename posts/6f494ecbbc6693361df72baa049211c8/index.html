<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>初始C语言——详细讲解操作符以及操作符的易错点 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初始C语言——详细讲解操作符以及操作符的易错点</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h1 id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">
<a id="_0"></a>系列文章目录</h1> 
<p> 第一章 <a href="http://t.csdn.cn/Rt8VK" title="“C“浒传——初识C语言（更适合初学者体质哦！）">“C“浒传——初识C语言（更适合初学者体质哦！）</a></p> 
<p> 第二章 <a href="http://t.csdn.cn/pTO5k" title="详细认识分支语句和循环语句以及他们的易错点">详细认识分支语句和循环语句以及他们的易错点</a> </p> 
<p> 第三章 <a href="http://t.csdn.cn/R6aDv" title="初阶C语言——特别详细地介绍函数">初阶C语言——特别详细地介绍函数</a></p> 
<p> 第四章 <a class="link-info" href="http://t.csdn.cn/z7pdJ" title="初始C语言——详细地讲解数组的内容以及易错点">初始C语言——详细地讲解数组的内容以及易错点</a></p> 
<p> 第五章 <span style="background-color:#ff9900">初始C语言——详细讲解操作符以及操作符的易错点</span></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-toc" style="margin-left:0px"><a href="#%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">系列文章目录</a></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px"><a href="#%E5%89%8D%E8%A8%80">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%86%E7%B1%BB-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%86%E7%B1%BB">一、操作符分类</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">二、算术操作符（两个操作数）</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">三、移位操作符（两个操作数）</a></p> 
<p id="3.1%20%E5%B7%A6%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%20%3C%3C-toc" style="margin-left:40px"><a href="#3.1%20%E5%B7%A6%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%20%3C%3C">3.1 左移操作符 &lt;&lt;</a></p> 
<p id="%C2%A03.2%20%E5%8F%B3%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%20%3E%3E-toc" style="margin-left:40px"><a href="#%C2%A03.2%20%E5%8F%B3%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%20%3E%3E"> 3.2 右移操作符 &gt;&gt;</a></p> 
<p id="3.3%20%E8%AD%A6%E5%91%8A%C2%A0-toc" style="margin-left:40px"><a href="#3.3%20%E8%AD%A6%E5%91%8A%C2%A0">3.3 警告 </a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">四、位操作符（两个操作数）</a></p> 
<p id="4.1%20%E6%8C%89%E4%BD%8D%E4%B8%8E%20%26-toc" style="margin-left:40px"><a href="#4.1%20%E6%8C%89%E4%BD%8D%E4%B8%8E%20%26">4.1 按位与 &amp;</a></p> 
<p id="%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%EF%BC%9A-toc" style="margin-left:80px"><a href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%EF%BC%9A">按位与的具体应用：</a></p> 
<p id="%C2%A04.2%20%E6%8C%89%E4%BD%8D%E6%88%96%C2%A0%20%7C-toc" style="margin-left:40px"><a href="#%C2%A04.2%20%E6%8C%89%E4%BD%8D%E6%88%96%C2%A0%20%7C"> 4.2 按位或  |</a></p> 
<p id="4.3%20%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%20%5E%C2%A0-toc" style="margin-left:40px"><a href="#4.3%20%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%20%5E%C2%A0">4.3 按位异或 ^ </a></p> 
<p id="%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%EF%BC%9A-toc" style="margin-left:80px"><a href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%EF%BC%9A">按位异或的具体应用：</a></p> 
<p id="4.4%20%E6%9C%89%E5%85%B3%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E7%9A%84%E7%BB%83%E4%B9%A0%C2%A0-toc" style="margin-left:40px"><a href="#4.4%20%E6%9C%89%E5%85%B3%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E7%9A%84%E7%BB%83%E4%B9%A0%C2%A0">4.4 有关二进制位的练习 </a></p> 
<p id="%E4%BA%94%E3%80%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px"><a href="#%E4%BA%94%E3%80%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6">五、赋值操作符</a></p> 
<p id="%C2%A0%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E7%AC%A6-toc" style="margin-left:40px"><a href="#%C2%A0%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E7%AC%A6"> 复合赋值符</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89-toc" style="margin-left:0px"><a href="#%E5%85%AD%E3%80%81%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">六、单目操作符（一个操作数）</a></p> 
<p id="6.1%20%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px"><a href="#6.1%20%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%8B%E7%BB%8D">6.1 单目操作符介绍</a></p> 
<p id="6.2%20%E9%80%BB%E8%BE%91%E5%8F%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%20%EF%BC%81%C2%A0-toc" style="margin-left:40px"><a href="#6.2%20%E9%80%BB%E8%BE%91%E5%8F%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%20%EF%BC%81%C2%A0">6.2 逻辑反操作符 ！ </a></p> 
<p id="%C2%A06.3%20%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%20%26%20%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%20*%C2%A0-toc" style="margin-left:40px"><a href="#%C2%A06.3%20%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%20%26%20%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%20*%C2%A0"> 6.3 取地址操作符 &amp; 和解引用操作符 * </a></p> 
<p id="6.4%20%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%20sizeof-toc" style="margin-left:40px"><a href="#6.4%20%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%20sizeof">6.4 计算操作数的类型长度 sizeof</a></p> 
<p id="6.5%20%2B%2B%20%E5%92%8C%20--%20%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#6.5%20%2B%2B%20%E5%92%8C%20--%20%E6%93%8D%E4%BD%9C%E7%AC%A6">6.5 ++ 和 -- 操作符</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89-toc" style="margin-left:0px"><a href="#%E4%B8%83%E3%80%81%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89">七、关系操作符（两个操作符）</a></p> 
<p id="%E5%85%AB%E3%80%81%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89-toc" style="margin-left:0px"><a href="#%E5%85%AB%E3%80%81%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89">八、逻辑操作符（两个操作符）</a></p> 
<p id="8.1%20%E9%80%BB%E8%BE%91%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%20%26%26-toc" style="margin-left:40px"><a href="#8.1%20%E9%80%BB%E8%BE%91%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%20%26%26">8.1 逻辑与操作符 &amp;&amp;</a></p> 
<p id="8.2%20%E9%80%BB%E8%BE%91%E6%88%96%E6%93%8D%E4%BD%9C%E7%AC%A6%20%7C%7C%C2%A0-toc" style="margin-left:40px"><a href="#8.2%20%E9%80%BB%E8%BE%91%E6%88%96%E6%93%8D%E4%BD%9C%E7%AC%A6%20%7C%7C%C2%A0">8.2 逻辑或操作符 || </a></p> 
<p id="8.3%20%E9%80%BB%E8%BE%91%E7%9F%AD%E8%B7%AF%C2%A0-toc" style="margin-left:40px"><a href="#8.3%20%E9%80%BB%E8%BE%91%E7%9F%AD%E8%B7%AF%C2%A0">8.3 逻辑短路 </a></p> 
<p id="%E4%B9%9D%E3%80%81%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%89%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89-toc" style="margin-left:0px"><a href="#%E4%B9%9D%E3%80%81%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%89%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89">九、条件操作符（三目操作符）</a></p> 
<p id="%E5%8D%81%E3%80%81%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0-toc" style="margin-left:0px"><a href="#%E5%8D%81%E3%80%81%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0">十、逗号表达式 </a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%C2%A0-toc" style="margin-left:0px"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%C2%A0">十一、下标引用、函数调用和结构成员 </a></p> 
<p id="11.1%20%5B%20%5D%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89-toc" style="margin-left:40px"><a href="#11.1%20%5B%20%5D%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">11.1 [ ]下标引用操作符（两个操作数）</a></p> 
<p id="11.2%20%EF%BC%88%20%EF%BC%89%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E8%87%B3%E5%B0%91%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89-toc" style="margin-left:40px"><a href="#11.2%20%EF%BC%88%20%EF%BC%89%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E8%87%B3%E5%B0%91%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">11.2 （ ）函数调用操作符（至少一个操作数）</a></p> 
<p id="11.3%20%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E7%9A%84%E6%88%90%E5%91%98%C2%A0-toc" style="margin-left:40px"><a href="#11.3%20%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E7%9A%84%E6%88%90%E5%91%98%C2%A0">11.3 访问一个结构的成员 </a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px"><a href="#%E6%80%BB%E7%BB%93">总结</a></p> 
<hr> 
<h1 id="%E5%89%8D%E8%A8%80">
<a id="_12"></a>前言</h1> 
<blockquote> 
 <p>       在上一章内，小编带领大家详细地学习了<strong>有关数组的相关内容，</strong>学习了<strong><u>一维数组和二维数组的创建与初始化</u>，<u>一维数组和二维数组在内存中如何存储</u>，<u>数组越界</u>，<u>数组作为函数参数怎么办？</u></strong></p> 
 <p>       而在这一章内，<strong>小编将要带领大家进行学习<span style="color:#fe2c24"><span style="background-color:#511b78">操作符</span></span>的内容</strong>，大家从目录也不难看出这章内容也是很多，已经囊括了所有操作符，希望大家也能有耐心地将这一章看完。</p> 
</blockquote> 
<hr> 
<h1 id="%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%86%E7%B1%BB" style="background-color:transparent">一、操作符分类</h1> 
<p>       <strong>为什么要学习操作符？<span style="color:#fe2c24"><u><span style="background-color:#511b78">是为了进行表达式求值。</span></u></span></strong>在学习操作符之前，先跟着小编进行学习操作符的分类吧！</p> 
<blockquote> 
 <ul>
<li>算术操作符：<u><strong><span style="background-color:#38d8f0">+、-、*、/、%</span></strong></u>
</li>
<li>移位操作符：<u><strong><span style="background-color:#38d8f0">&lt;&lt;、&gt;&gt;</span></strong></u>
</li>
<li>位操作符：<u><strong><span style="background-color:#38d8f0">&amp;、|、^</span></strong></u>
</li>
<li>赋值操作符：<u><strong><span style="background-color:#38d8f0">=、+=、-=、/=、*=、%=……</span></strong></u>
</li>
<li>单目操作符：<u><strong><span style="background-color:#38d8f0">！、-、+、sizeof、~、（类型）</span></strong></u>
</li>
<li>关系操作符：<u><strong><span style="background-color:#38d8f0">&gt;、&lt;、&gt;=、&lt;=、!=、==</span></strong></u>
</li>
<li>逻辑操作符：<u><strong><span style="background-color:#38d8f0">&amp;&amp;、||</span></strong></u>
</li>
<li>条件操作符：<u><strong><span style="background-color:#38d8f0">exp1？exp2：exp3</span></strong></u>
</li>
<li>逗号表达式：<u><strong><span style="background-color:#38d8f0">exp1，exp2，exp3，……expN</span></strong></u>
</li>
<li>下标引用、函数调用和结构成员：<u><strong><span style="background-color:#38d8f0">[ ]、（）、.、-&gt;</span></strong></u>
</li>
</ul> 
</blockquote> 
<hr> 
<h1 id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">二、算术操作符（两个操作数）</h1> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/7d/16/yYGeFDcD_o.png"></p> 
<p>       在这一部分，小编认为没什么可以讲的，但是这篇博客是详细讲解操作符，所以还是要讲解一下易错点吧！<strong>算术操作符，顾名思义就是数学上的一些运算</strong>：<u><strong><span style="background-color:#38d8f0">+、-、*、/、%。</span></strong></u><span style="color:#fe2c24"><strong>+、-、*</strong></span>这三个运算符没有什么可以讲的，接下来，小编重点讲解<strong>：<span style="color:#fe2c24">/、%。</span> </strong></p> 
<blockquote> 
 <ol>
<li>除了 % 操作符之外，<span style="color:#fe2c24"><strong><span style="background-color:#511b78">其他的几个操作符可以作用于整数和浮点数</span></strong></span>。</li>
<li>对于 / 操作符，如果<span style="color:#fe2c24"><strong><span style="background-color:#511b78">两个操作数都为整数，执行整数除法</span></strong></span>。而两个数中<span style="color:#fe2c24"><strong><span style="background-color:#511b78">只要有浮点数执行的就是浮点数除法。</span></strong></span>
</li>
<li>
<strong>% 操作符的两个操作数必须为<span style="color:#fe2c24"><span style="background-color:#511b78">整数</span></span></strong>，返回的是整除之后的余数。</li>
</ol> 
</blockquote> 
<hr> 
<h1 id="%E4%B8%89%E3%80%81%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">三、移位操作符（两个操作数）</h1> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/8f/a4/P4iga5n9_o.png"></p> 
<p>       小编在讲之前先提一嘴，<u><strong>移位操作符移动的是<span style="color:#fe2c24">二进制的位</span></strong></u>。在这里，我们先来讲一下C语言的二进制。</p> 
<blockquote> 
 <p>       对于<strong>一个整数来说是<span style="color:#fe2c24"><span style="background-color:#511b78">四个字节</span></span></strong>，也就是<span style="color:#fe2c24"><strong><span style="background-color:#511b78">==32bit位</span></strong></span>。<u>一个整数写成二进制序列的时候，就是32个bit位。</u>下面看图理解：</p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/e5/90/mmG9LDK0_o.png"></p> 
 <p>    <strong>  <span style="background-color:#38d8f0"> 1）</span>对于有符号的整数来说，最高位的一位是符号位：符号位是1，表示负数；符号位是0，表示正数。 </strong></p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/44/c0/mvWLJ2zL_o.png"></p> 
 <p>     <span style="background-color:#38d8f0">  </span><strong><span style="background-color:#38d8f0">2）</span>对于无符号整数来说，没有符号位，所有位都是有效位。</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>整数的<u>二进制表示形式有<span style="color:#fe2c24">三种</span>：<span style="color:#fe2c24"><span style="background-color:#511b78">原码</span></span>、<span style="color:#fe2c24"><span style="background-color:#511b78">反码</span></span>、<span style="color:#fe2c24"><span style="background-color:#511b78">补码</span></span></u>。</strong></p> 
 <p><strong><span style="color:#fe2c24"><span style="background-color:#511b78">原码：</span></span><u>按照数值的正负，直接写出的二进制序列就是原码。</u></strong></p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/b7/1e/9biHQKGq_o.png"></p> 
 <p><strong><span style="color:#fe2c24"><span style="background-color:#511b78">反码：</span></span><u>原码的符号位不变，其他位按位取反。</u></strong></p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/56/14/zJwFtWUN_o.png"></p> 
 <p><strong><span style="color:#fe2c24"><span style="background-color:#511b78">补码：</span></span><u>反码的二进制 +1 就是补码。</u></strong> </p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/0e/bf/rNoM7Oit_o.png"></p> 
 <p>       从例子中，我们可以看出<strong>对于<span style="color:#fe2c24"><span style="background-color:#511b78">正的整数原码，反码，补码是相同的</span></span>，无需计算；对于<span style="color:#fe2c24"><span style="background-color:#511b78">负的整数原码，反码，补码是需要进行计算的。</span></span></strong></p> 
 <p><strong><span style="color:#fe2c24">            <span style="background-color:#511b78">   整数在内存中存放的都是补码，整数在计算的时候也是用二进制进行计算。</span></span></strong></p> 
</blockquote> 
<hr> 
<h2 id="3.1%20%E5%B7%A6%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%20%3C%3C">3.1 左移操作符 &lt;&lt;</h2> 
<blockquote> 
 <p><strong>移位规则：<span style="color:#fe2c24"><u>左边抛弃，右边补0。</u></span></strong></p> 
</blockquote> 
<p>       在常规的数字里面是不会出现特殊情况的，<strong>一般地，在效果上，<span style="color:#fe2c24"><span style="background-color:#511b78">左移一位相当于乘2</span></span>。</strong>对于<span style="color:#fe2c24"><strong>正数</strong></span>来说，还是对于<span style="color:#fe2c24"><strong>负数</strong></span>来说，其实都一样，只是在一些特别大的数是不一样的，<u><strong>基本都遵循：<span style="color:#fe2c24"><span style="background-color:#511b78">丢弃符号位，不管左边高位是什么，后面补的数字成为符号位。</span></span></strong></u></p> 
<blockquote> 
 <p>下面举个例子：</p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/bf/d8/NDfVjXYS_o.png"></p> 
</blockquote> 
<h2 id="%C2%A03.2%20%E5%8F%B3%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%20%3E%3E"> </h2> 
<hr> 
<h2>3.2 右移操作符 &gt;&gt;</h2> 
<p>       小编先说一句：右移操作符比较难。首先<u><strong>右移运算分为两种：<span style="color:#fe2c24"><span style="background-color:#511b78">1.逻辑右移</span></span>；<span style="color:#fe2c24"><span style="background-color:#511b78">2.算术右移</span></span>。</strong></u>这两种<u>主要的区别是：<strong>关键看左边补什么</strong></u>。</p> 
<blockquote> 
 <p><strong>移位规则：<span style="color:#fe2c24">1.逻辑移位：左边用0填充，右边丢弃；2.算术移位：左边用原该值的符号位填充，右边丢弃。</span></strong></p> 
</blockquote> 
<p>       同样地，在常规的数字里面是不会出现特殊情况的，<strong>一般地，在效果上，<span style="color:#fe2c24"><span style="background-color:#511b78">右移一位相当于除以2</span></span>。</strong>对于<span style="color:#fe2c24"><strong>正数</strong></span>来说，<strong><u>遵循：<span style="color:#fe2c24"><span style="background-color:#511b78">丢弃右边一位，左边直接补0</span></span></u>。</strong>而对于<span style="color:#fe2c24"><strong>负数</strong></span>来说，有两种情况，所以一般请先了解你所使用的编译器是哪种右移运算，方法在下面。<u><strong>遵循：<span style="color:#fe2c24"><span style="background-color:#511b78">如果是算术右移：左边用原改制的符号位填充；如果是逻辑右移：左边补0。</span></span></strong></u></p> 
<blockquote> 
 <p> 下面举个例子：</p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/45/45/IUDnRJ9H_o.png"></p> 
</blockquote> 
<p>       <strong>对于<span style="color:#fe2c24"><span style="background-color:#511b78">正整数</span></span>来说，<span style="color:#fe2c24"><span style="background-color:#511b78">这两种右移操作都一样</span></span>；而对于<span style="color:#fe2c24"><span style="background-color:#511b78">负整数</span></span>来说，这<span style="color:#fe2c24"><span style="background-color:#511b78">两种右移操作不太一样</span></span>，所以要重点来看负整数。</strong>我们可以根据这个差异，编写一个代码看你们所使用的编译器支持哪种右移操作。<span style="color:#fe2c24"><strong><span style="background-color:#511b78">vs用的是算术右移，大部分编译器用的都是算术右移</span></strong></span>。下面看代码：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
	int a = -10 &gt;&gt; 1;
	if (a &lt; 0)
		printf("该编译器用的是算术右移!n");
	else
		printf("该编译器用的是逻辑右移!n");
	return 0;
}</code></pre> 
<hr> 
<h2 id="3.3%20%E8%AD%A6%E5%91%8A%C2%A0">3.3 警告 </h2> 
<blockquote> 
 <p>对于移位操作符，不要移动负数位，这个是标准未定义的。看下图：</p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/75/60/1Nea9cv4_o.png"></p> 
</blockquote> 
<hr> 
<h1 id="%E5%9B%9B%E3%80%81%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">四、位操作符（两个操作数）</h1> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/99/e7/Dp67mmYO_o.png"></p> 
<p>       在初学C语言时，老师应该是不会讲这一部分的，起码我们老师没有讲，但<strong><span style="color:#fe2c24"><span style="background-color:#511b78">这一部分是非常重要的， 他在二进制的一些题目中有大作用</span></span>。<u>但大家不要将位操作符与逻辑操作符搞混！</u></strong>下面，就由小编我来带领大家进行分开学习吧！</p> 
<h2 id="4.1%20%E6%8C%89%E4%BD%8D%E4%B8%8E%20%26"><strong>4.1 按位与 &amp;</strong></h2> 
<blockquote> 
 <p><strong>运算规则：<u><span style="color:#fe2c24">同时为1，才为1；一旦有0，则为0。</span></u></strong></p> 
</blockquote> 
<p> 我们<strong>记住这个运算规则后进行计算</strong>即可，下面进行代码讲解：</p> 
<pre><code class="language-cpp">int main()
{
	int a = 7;
	int b = -10;
	int c = a &amp; b;//按二进制的位与
	//00000000 00000000 00000000 00000111 ----- 7的补码
	//10000000 00000000 00000000 00001010
	//11111111 11111111 11111111 11110101
    //*************************************
	//*11111111 11111111 11111111 11110110*----- -10的补码
	//*00000000 00000000 00000000 00000111*----- 7的补码
    //*************************************
	//同1为1，有0则0
	//00000000 00000000 00000000 00000110 ----- 6
	printf("%d", c);
	return 0;
}</code></pre> 
<h3 id="%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%EF%BC%9A">按位与的具体应用：</h3> 
<p>       如果我想得到某个数的二进制补码上某一位到底是1还是0，我们可以使用按位与运算进行得到。为什么呢？</p> 
<p>      <strong> <u>基本思路是：因为<span style="color:#fe2c24">按位与的运算规则是：同1为1，有0则0</span>。假如你想要求某个数的二进制补码上<span style="color:#fe2c24"><span style="background-color:#511b78">最后一位的数</span></span>，你只需<span style="color:#fe2c24"><span style="background-color:#511b78">按位与上1(2^0)</span></span>，则可以得出某个数的二进制补码上最后一位的数是什么，如果按位与上1等于1的话，最后一个数是1，如果是0，则最后一个数是0。同理，如果你想要求某个数的二进制补码上<span style="color:#fe2c24"><span style="background-color:#511b78">倒数第二位的数</span></span>，你只需<span style="color:#fe2c24"><span style="background-color:#511b78">按位与上2(2^1)</span></span>。</u></strong></p> 
<blockquote> 
 <p><u><strong>题目一：</strong>求某个数的二进制补码上某一位的数是什么？</u></p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><u><strong>方法：</strong>由上面的基本思路可以总结出一个<span style="color:#fe2c24"><span style="background-color:#511b78">公式</span></span>：如果你想要<strong>求某个数的二进制补码上<span style="color:#fe2c24"><span style="background-color:#511b78">倒数第N位的数</span></span>，你只需要<span style="color:#fe2c24"><span style="background-color:#511b78">用某个数按位与上2的(N-1)次方(2^(N-1))</span></span>即可。</strong></u></p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><strong>代码：</strong></p> 
 <pre><code class="language-cpp">int main()
{
	int num = 10;
	//如果想要求10的二进制补码中最后一位数
	int ans = num &amp; 1;
	printf("ans = %dn", ans);
	return 0;
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><strong>题目二：</strong> 求出某一个数的二进制补码的最后一个为1的位置的数。</p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><strong>方法：</strong></p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/6c/d9/cyYPGwFJ_o.png"></p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><strong>代码：</strong></p> 
 <pre><code class="language-cpp"> int onlyone = eor &amp; (~eor + 1);</code></pre> 
</blockquote> 
<h2 id="%C2%A04.2%20%E6%8C%89%E4%BD%8D%E6%88%96%C2%A0%20%7C"> 4.2 按位或  |</h2> 
<blockquote> 
 <p><strong>运算规则：<u><span style="color:#fe2c24">同时为0，才为0；一旦有1，则为1。</span></u></strong></p> 
</blockquote> 
<p>这种运算是不需要进行讲解的，只要<strong>记住运算规则就会做运算</strong>，下面进行代码讲解：</p> 
<pre><code class="language-cpp">int main()
{
	int a = 7;
	int b = -10;
	int c = a | b;//按二进制的位或
	//00000000 00000000 00000000 00000111 ----- 7的补码
	//10000000 00000000 00000000 00001010
	//11111111 11111111 11111111 11110101
	//*************************************
	//*11111111 11111111 11111111 11110110*----- -10的补码
	//*00000000 00000000 00000000 00000111*----- 7的补码
	//*************************************
	//同0为0，有1则1
	// 11111111 11111111 11111111 11110111 补码
	// 11111111 11111111 11111111 11110110 反码
	// 10000000 00000000 00000000 00001001 原码 --- -9
	printf("%d", c);
	return 0;
}</code></pre> 
<h2 id="4.3%20%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%20%5E%C2%A0"><strong>4.3 按位异或 ^ </strong></h2> 
<blockquote> 
 <p><strong><span style="color:#0d0016">运算规则：</span><u><span style="color:#fe2c24">相同为0，不同为1。</span></u></strong><span style="color:#0d0016"><strong>在这里提两个式子要记住：</strong></span><strong><u><span style="color:#fe2c24">a ^ a = 0;a ^ 0 = a。</span></u></strong></p> 
 <p><strong><u><span style="color:#fe2c24">性质：按位运算遵循交换律和结合律。</span></u></strong></p> 
</blockquote> 
<p>       虽然，按位异或的运算规则比较简单，但是以后还要学习一个<strong>按位同或的运算规则：<span style="color:#fe2c24"><u>相同为1，不同为0。</u></span></strong>所以，这两种运算容易搞混。</p> 
<p>那怎么记按位异或呢？<u><strong>按位异或——<span style="color:#fe2c24">就是无进制相加</span>。</strong></u>怎么理解无进制相加呢？看下图：</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/8d/0f/AjEcJUig_o.png"></p> 
<pre><code class="language-cpp">int main()
{
	int a = 7;
	int b = -10;
	int c = a ^ b;//按二进制的位异或
	//00000000 00000000 00000000 00000111 ----- 7的补码
	//10000000 00000000 00000000 00001010
	//11111111 11111111 11111111 11110101
	//*************************************
	//*11111111 11111111 11111111 11110110*----- -10的补码
	//*00000000 00000000 00000000 00000111*----- 7的补码
	//*************************************
	//相同为0，不同为1
	// 11111111 11111111 11111111 11110001 补码
	// 11111111 11111111 11111111 11110000 反码
	// 10000000 00000000 00000000 00001111 原码 --- -15
	printf("%d", c);
	return 0;
}</code></pre> 
<h3 id="%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%EF%BC%9A">按位异或的具体应用：</h3> 
<p><strong> 一道很变态的面试题：</strong> </p> 
<blockquote> 
 <p><u><strong>题目一：</strong>不能创建临时变量（第三个变量），实现两个数的交换。</u></p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><u><strong>方法1：</strong>先将a，b两个数进行相加赋给a，然后用a减去b赋给b，这样b中存的就是a，然后再用a减去b（b的值此时是a）赋给a，则a的值就是b的值了。</u></p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><strong>代码：</strong></p> 
 <pre><code class="language-cpp">int main()
{
	int a = 10;
	int b = 90;
	printf("交换前：a = %d, b = %dn", a, b);
	//方法一：
	a = a + b;
	b = a - b;
	a = a - b;
	printf("交换后：a = %d, b = %dn", a, b);
	return 0;
}</code></pre> 
 <p><u><strong>缺陷：</strong>如果变量的值非常大的话，就会出现<span style="color:#fe2c24"><span style="background-color:#511b78">数据截断</span></span>。</u></p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><u><strong>方法2：</strong>用按位异或，根据<span style="color:#fe2c24"><strong><span style="background-color:#511b78">a ^ a = 0，a ^ 0 = a</span></strong></span>，就可以得出。在这个过程中不会产生进位，则数据不会溢出。</u></p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><strong>代码：</strong></p> 
 <pre><code class="language-cpp">int main()
{
	int a = 10;
	int b = 90;
	printf("交换前：a = %d, b = %dn", a, b);
	//方法二：
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("交换后：a = %d, b = %dn", a, b);
	return 0;
}</code></pre> 
 <p><u><strong>缺陷：</strong>这个代码<span style="color:#fe2c24"><span style="background-color:#511b78">可读性不高</span></span>，<span style="color:#fe2c24"><span style="background-color:#511b78">效率也不高</span></span>。</u></p> 
</blockquote> 
<blockquote> 
 <p><u><strong>题目二：</strong> 给定一个数字arr，其中只有两个数字出现了奇数次，其它数字都出现了偶数次，按照从小到大顺序输出这两个数。</u></p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><u><strong>方法：</strong>先将这些数全部异或一下，可以得到出现奇数次的两个数的异或结果赋给eor，说明这两个数一定不相等，<span style="color:#fe2c24"><strong>而且eor的二进制中一定有一个位置是1，求出此位置为1的数（看4.1 按位与的具体应用）</strong></span>，然后将数组里的数分成两个部分，一个部分是此位置为1的数，另一部分是此位置为0的数。那么这两个数就分开了，随便挑一组数据进行异或就可以求出一个数，再用eor异或就求出了另一个数。</u></p> 
 <p><strong>********************************************************************************************************</strong></p> 
 <p><strong>代码：</strong></p> 
 <pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main() 
{
    int n = 0;
    int eor = 0, eor1 = 0;
    int temp = 0, ans = 0;
    scanf("%d", &amp;n);
    int arr[100000];
    for(int i = 0; i &lt; n; i++)
    {
        scanf("%d", &amp;arr[i]);
    }
    for(int i = 0; i &lt; n; i++)
    {
        eor ^= arr[i];
    }
    int onlyone = eor &amp; (~eor + 1);
    for(int i = 0; i &lt; n; i++)
    {
        if((onlyone &amp; arr[i]) != 0)
            eor1 ^= arr[i];
    }
    ans = eor ^ eor1;
    if(eor1 &gt; ans)
    {
        temp = eor1;
        eor1 = ans;
        ans = temp;
    }
    printf("%d %dn", eor1, ans);
    return 0;
}</code></pre> 
</blockquote> 
<h2 id="4.4%20%E6%9C%89%E5%85%B3%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E7%9A%84%E7%BB%83%E4%B9%A0%C2%A0">4.4 有关二进制位的练习 </h2> 
<p>题目：编写代码实现：求一个整数存储在内存中的二进制中1的个数。</p> 
<hr> 
<h1 id="%E4%BA%94%E3%80%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6">五、赋值操作符</h1> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/40/36/P7snq17n_o.png"></p> 
<p>       赋值操作符是一个很棒的操作符，如果之前的值你不满意，使用这个操作符你可以给自己重新赋值。</p> 
<blockquote> 
 <p>举个例子：</p> 
 <pre><code class="language-cpp">int weight = 120;//体重
weight = 80;//不满意就赋值
double salary = 100000.0;
salary = 200000.0; //使用赋值操作符赋值</code></pre> 
</blockquote> 
<blockquote> 
 <p><strong>赋值操作符可以<span style="color:#fe2c24"><span style="background-color:#511b78">连续使用</span></span>，不过要<span style="color:#fe2c24"><span style="background-color:#511b78">从右向左</span></span>依次执行。 </strong></p> 
 <pre><code class="language-cpp">	int a = 10;
	int x = 0;
	int y = 20;
	a = x = y + 1; //连续赋值，可读性不高
	//改进
	x = y + 1;
	a = x;//这样写更加清晰爽朗而且便于调试</code></pre> 
</blockquote> 
<h2 id="%C2%A0%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E7%AC%A6"> 复合赋值符</h2> 
<blockquote> 
 <pre><code class="language-cpp">+=
-=
*=
/=
%=
&gt;&gt;=
&lt;&lt;=
&amp;=
|=
^=</code></pre> 
 <p>这些运算符都可以写成复合的效果，<span style="color:#fe2c24"><strong><span style="background-color:#511b78">使代码更加整洁</span></strong></span>。</p> 
</blockquote> 
<blockquote> 
 <p>举个例子：</p> 
 <pre><code class="language-cpp">	int x = 10;
	x = x + 10;
	x += 10; //这样写比较整洁</code></pre> 
</blockquote> 
<hr> 
<h1 id="%E5%85%AD%E3%80%81%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">六、单目操作符（一个操作数）</h1> 
<h2 id="6.1%20%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%8B%E7%BB%8D">6.1 单目操作符介绍</h2> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/75/12/NFFgCSoj_o.png"></p> 
<h2 id="6.2%20%E9%80%BB%E8%BE%91%E5%8F%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%20%EF%BC%81%C2%A0">6.2 逻辑反操作符 ！ </h2> 
<blockquote> 
 <p><strong>运算规则：<u><span style="color:#fe2c24">将真的变成假的，将假的变成真的</span></u>。</strong></p> 
</blockquote> 
<p> 下面看使用场景：</p> 
<pre><code class="language-cpp">int main()
{
    int a = 0;
    if(!a)
        printf("hehen");
    return 0;
}</code></pre> 
<h2 id="%C2%A06.3%20%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%20%26%20%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%20*%C2%A0"> 6.3 取地址操作符 &amp; 和解引用操作符 * </h2> 
<p>       取地址操作符是<span style="color:#fe2c24"><u><strong><span style="background-color:#511b78">将一个变量的地址取出来存放在p中</span></strong></u></span>，解引用操作符是<span style="color:#fe2c24"><u><strong><span style="background-color:#511b78">通过p所存放的地址找到p所指向的对象。</span></strong></u></span></p> 
<h2 id="6.4%20%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%20sizeof">6.4 计算操作数的类型长度 sizeof</h2> 
<pre><code class="language-cpp">int main()
{
	int a = 10;
	printf("%dn", sizeof(a));
    printf("%dn", sizeof a); //这种写法是正确的，证明了sizeof不是函数，函数后的括号省略不了
	printf("%dn", sizeof(int));
	return 0;
}</code></pre> 
<p>       由上图代码可知，<span style="color:#fe2c24"><strong><span style="background-color:#511b78">sizeof既能计算变量的长度，也能计算类型长度。</span></strong></span>此代码运行后，为什么会出现下图情况：</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/8d/63/eNKwmBUR_o.png"></p> 
<p>       因为<u><strong>sizeof计算的结果是<span style="color:#fe2c24"><span style="background-color:#511b78">size_t类型的</span></span></strong></u>，<u><strong>size_t是<span style="color:#fe2c24"><span style="background-color:#511b78">无符号整形的</span></span></strong></u>，对size_t类型的数据进行打印，<u><strong>可以使用<span style="color:#fe2c24"><span style="background-color:#511b78">%zd</span></span></strong></u>。 在一些古老的编译器是不支持%zd的，也<u><strong>可以使用<span style="color:#fe2c24"><span style="background-color:#511b78">%u</span></span></strong></u>。</p> 
<h2 id="6.5%20%2B%2B%20%E5%92%8C%20--%20%E6%93%8D%E4%BD%9C%E7%AC%A6">6.5 ++ 和 -- 操作符</h2> 
<blockquote> 
 <p><strong>运算规则：<u><span style="color:#fe2c24">前置++（--）：先+（-）1，后使用；后置++（--）：先使用，后+（-）1。</span></u></strong> </p> 
</blockquote> 
<hr> 
<h1 id="%E4%B8%83%E3%80%81%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89">七、关系操作符（两个操作符）</h1> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/c0/e5/RiMXPQXg_o.png"></p> 
<p>        这些操作符比较简单，没有什么可以讲的，但是我们要注意一些运算符使用时候的陷阱。</p> 
<blockquote> 
 <p><strong>警告：<u><span style="color:#fe2c24">在编程的过程中 == 和 = 不小心写错，导致的错误。</span></u></strong></p> 
</blockquote> 
<hr> 
<h1 id="%E5%85%AB%E3%80%81%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89">八、逻辑操作符（两个操作符）</h1> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/5e/b7/P2ovLdza_o.png"></p> 
<h2 id="8.1%20%E9%80%BB%E8%BE%91%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%20%26%26">8.1 逻辑与操作符 &amp;&amp;</h2> 
<blockquote> 
 <p><strong>运算规则：<u><span style="color:#fe2c24"> 逻辑与就是并且，全真为真，有假即假。</span></u></strong></p> 
</blockquote> 
<p>区分<strong>逻辑与</strong>和<strong>按位与</strong></p> 
<pre><code class="language-cpp">1 &amp; 2  --------&gt;0
1 &amp;&amp; 2 --------&gt;1</code></pre> 
<h2 id="8.2%20%E9%80%BB%E8%BE%91%E6%88%96%E6%93%8D%E4%BD%9C%E7%AC%A6%20%7C%7C%C2%A0">8.2 逻辑或操作符 || </h2> 
<blockquote> 
 <p><strong>运算规则：<u><span style="color:#fe2c24">逻辑或就是或者，全假为假，有真即真。</span></u></strong></p> 
</blockquote> 
<p> 区分<strong>逻辑或</strong>和<strong>按位或</strong></p> 
<pre><code class="language-cpp">1 | 2 --------&gt;3
1 || 2 -------&gt;1</code></pre> 
<h2 id="8.3%20%E9%80%BB%E8%BE%91%E7%9F%AD%E8%B7%AF%C2%A0">8.3 逻辑短路 </h2> 
<blockquote> 
 <p><strong>运算规则：<u><span style="color:#fe2c24">&amp;&amp; 左边操作数如果为假，右边的运算式可以不算；|| 右边操作数如果为真，右边的运算式可以不算 。</span></u></strong></p> 
</blockquote> 
<p>学到这个操作符后，我突然想到了我同学问我的一道题目：</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/67/8b/V7ZiMywW_o.png"></p> 
<p>       我刚看到这个题是有疑惑的，因为b和c选项感觉都是错的，其实并不是。因为c选项是涉及一些知识点是我不知道的，<strong>因为有逻辑短路，<u>在C语言中，我们进行运算的时候，我们需要进行优化代码，不让这个程序进行超负荷的运算。</u>在程序中，因为，a||(b = c)是这个逻辑运算，<u>为什么会有逻辑短路呢？为了减少程序的计算量，</u>在进行这个逻辑运算的时候，C语言采用了在保持原逻辑运算正确的同时，通过已确定表达式的确切值的情况下，不计算后面的运算来简化运算。</strong></p> 
<p>       <strong><u>在或运算中，如果a为真，后面的值不管是什么，我们都不需要进行计算，因为程序的结果已经知道了，就应该进行逻辑短路</u>，</strong>然后就不计算b = c,所以没有将c赋值给b, b还是等于原值。如果a为假，说明后面的结果可能会影响整个结果，所以就不能进行逻辑短路。</p> 
<blockquote> 
 <p><strong>下面有一道笔试题：</strong></p> 
 <p><strong>题目：</strong></p> 
 <pre><code class="language-cpp">int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	i = a++ &amp;&amp; ++b &amp;&amp; d++;
	printf(" a = %dn b = %dn c = %dn d = %dn", a, b, c, d);
	return 0;
}</code></pre> 
 <p><strong>答案：</strong></p> 
 <p style="text-align:center"><img alt="" src="https://images2.imgbox.com/c0/93/7FvzdPnk_o.png"></p> 
</blockquote> 
<hr> 
<h1 id="%E4%B9%9D%E3%80%81%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%89%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89">九、条件操作符（三目操作符）</h1> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/16/6e/9foHCjLP_o.png"></p> 
<p> 我感觉这个操作符是用来简化代码的，具体看下面代码：</p> 
<pre><code class="language-cpp">if (a &gt; 5)
	b = 3;
else
	b = -3;
//等价于
b = a &gt; 5 ? 3 : -3;</code></pre> 
<p><strong>具体应用： </strong></p> 
<blockquote> 
 <p><u><strong>题目：</strong>使用条件表达式实现找两个数中的较大值</u></p> 
 <p><u><strong>方法：</strong>利用条件表达式</u></p> 
 <p><strong>代码：</strong></p> 
 <pre><code class="language-cpp">int main()
{
	int a = 90, b = 78;
	int ans = a &gt; b ? a : b;
	printf("%dn", ans);
	return 0;
}</code></pre> 
</blockquote> 
<hr> 
<h1 id="%E5%8D%81%E3%80%81%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0">十、逗号表达式 </h1> 
<p><img alt="" src="https://images2.imgbox.com/7d/34/PGHe1yOa_o.png"></p> 
<blockquote> 
 <p><strong>运算规则：<u><span style="color:#fe2c24">从左向右依次执行计算，整个表达式的结果是最后一个表达式的结果，前面的计算可能会影响后面的结果。 </span></u></strong></p> 
</blockquote> 
<p> 下面看使用场景：</p> 
<pre><code class="language-cpp">	a = get_val();
	couny_val(a);
	while (a &gt; 0)
	{
		//业务处理
		a = get_val();
		couny_val(a);
	}
	//如果使用逗号表达式，改写：
	while (a = get_val(), couny_val(a), a &gt; 0)
	{
		//业务处理
	}</code></pre> 
<hr> 
<h1 id="%E5%8D%81%E4%B8%80%E3%80%81%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%C2%A0">十一、下标引用、函数调用和结构成员 </h1> 
<h2 id="11.1%20%5B%20%5D%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">11.1 [ ]下标引用操作符（两个操作数）</h2> 
<blockquote> 
 <p><strong>操作数：<u><span style="color:#fe2c24">一个数组名 + 一个索引值</span></u></strong></p> 
</blockquote> 
<pre><code class="language-cpp">int arr[10]; //创建数组
arr[9] = 10; //使用下标引用操作符
[ ]的两个操作数是arr和9。</code></pre> 
<h2 id="11.2%20%EF%BC%88%20%EF%BC%89%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E8%87%B3%E5%B0%91%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">11.2 （ ）函数调用操作符（至少一个操作数）</h2> 
<blockquote> 
 <p><strong>接受一个或者多个操作数：<u><span style="color:#fe2c24">第一个操作数是函数名，剩余的操作数就是传递给函数的参数。</span></u></strong></p> 
</blockquote> 
<h2 id="11.3%20%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E7%9A%84%E6%88%90%E5%91%98%C2%A0">11.3 访问一个结构的成员 </h2> 
<blockquote> 
 <p><strong>.         结构体.成员名</strong></p> 
 <p><strong>-&gt;       结构体指针-&gt;成员名</strong></p> 
</blockquote> 
<hr> 
<h1 id="%E6%80%BB%E7%BB%93">总结</h1> 
<p>       在这一部分，小编详细地编写了有关操作符详解的一篇博客。希望大家看完以后，进行点评，谢谢大家！</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>