<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>学习链表相关（上） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">学习链表相关（上）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8" title="一、什么是链表">一、什么是链表</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%95%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%95%E9%93%BE%E8%A1%A8" title=" 二、创建静态单链表"> 二、创建静态单链表</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E5%8D%95%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px"><a href="#%C2%A0%E4%B8%89%E3%80%81%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E5%8D%95%E9%93%BE%E8%A1%A8" title=" 三、创建动态单链表"> 三、创建动态单链表</a></p> 
<p id="1%E3%80%81%E5%85%B3%E4%BA%8E%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px"><a href="#1%E3%80%81%E5%85%B3%E4%BA%8E%E5%88%9D%E5%A7%8B%E5%8C%96" title="1、关于初始化">1、关于初始化</a></p> 
<p id="2%E3%80%81%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A-toc" style="margin-left:40px"><a href="#2%E3%80%81%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A" title="2、关于内存分配：">2、关于内存分配：</a></p> 
<p id="3%E3%80%81%E5%90%84%E7%BB%93%E6%9E%84%E5%9C%B0%E5%9D%80%E5%AD%98%E6%94%BE%E6%83%85%E5%86%B5%EF%BC%9A-toc" style="margin-left:40px"><a href="#3%E3%80%81%E5%90%84%E7%BB%93%E6%9E%84%E5%9C%B0%E5%9D%80%E5%AD%98%E6%94%BE%E6%83%85%E5%86%B5%EF%BC%9A" title="3、各结构地址存放情况">3、各结构地址存放情况</a></p> 
<p id="%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A-toc" style="margin-left:80px"><a href="#%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A" title="尾插法建立单链表">尾插法建立单链表</a></p> 
<p id="%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A-toc" style="margin-left:80px"><a href="#%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A" title="头插法建立单链表">头插法建立单链表</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9" title="三、链表的增删查改">三、链表的增删查改</a></p> 
<p id="1%E3%80%81%E5%A2%9E-toc" style="margin-left:40px"><a href="#1%E3%80%81%E5%A2%9E" title="1、增">1、增</a></p> 
<p id="2%E3%80%81%E5%88%A0-toc" style="margin-left:40px"><a href="#2%E3%80%81%E5%88%A0" title="2、删">2、删</a></p> 
<p id="3%E3%80%81%E6%9F%A5-toc" style="margin-left:40px"><a href="#3%E3%80%81%E6%9F%A5" title="3、查">3、查</a></p> 
<p id="4%E3%80%81%E6%94%B9-toc" style="margin-left:40px"><a href="#4%E3%80%81%E6%94%B9" title="4、改">4、改</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%89%80%E6%9C%89%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81%E6%89%80%E6%9C%89%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%EF%BC%9A" title="四、所有基础实现综合">四、所有基础实现综合</a></p> 
<hr id="hr-toc">
<p>链表是啥呢？光听名字就知道大概是个有连续性的东西，我第一次听到“链表”这个概念的时候想到的是一节节的火车箱。</p> 
<p>上一篇博客讲述了结构体的相关知识，<u>实际上链表是通过结构体和指针来实现的</u>。</p> 
<hr>
<h1 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8">一、什么是链表</h1> 
<p>链表是一种动态存储分配的一种结构，相当于<strong><span style="color:#be191c">结构体</span>们通过<span style="color:#be191c">指针</span>连接的方式形成一个个节点，并且每一个节点有<u>一个前驱节点和一个后继节点</u>（除了首节点没有前驱节点，尾节点没有后继节点），最后由它们组为一个完整的有序结构</strong>。其中指针的追踪保证链表中的每一项都包含着在何处能够找到下一项的信息。</p> 
<p>现在我声明一个简单结构体：</p> 
<pre><code>struct A
{
  char firstname[10];  //定义数据域

  struct A *next;  //定义指针域，用于储存后继节点地址
};

struct A *head = NULL;  //头指针初始化为空</code></pre> 
<p> 相关单链表结构就是：</p> 
<p style="text-align:center"><img alt="" height="263" src="https://images2.imgbox.com/34/2d/gPD49QVg_o.png" width="507"></p> 
<p><strong>*head</strong>为头指针，指向头节点；<strong>*next</strong>为后继节点，用于存储后继节点的地址，方便访问并连接下一节点<s><span style="color:#cccccc">（这个next应该是和“yan”连在一起的，因为他们都在一个结构当中，图做完没备份改不了了你们凑合看着...）</span></s>。<strong>如果想要表明<u>该结构后面没有其它结构</u>，就要把<u><span style="background-color:#98c091">next成员指针设置为NULL</span></u>，即表示<span style="background-color:#98c091">链表结束</span>。</strong></p> 
<p>这里区分一下<strong><span style="color:#be191c"><u>头节点</u></span><span style="color:#0d0016"><u>和</u></span><span style="color:#be191c"><u>首节点</u></span></strong>：</p> 
<blockquote> 
 <p><span style="color:#0d0016"><strong>头节点</strong></span>：在单链表的第一个结点前附设一个结点，它没有直接前驱。<u>其数据域可以不存任何信息，指针域指向第一个节点（首节点）的地址。</u>头节点的作用是<strong>使所有链表（包括空表）的头指针非空</strong>。</p> 
 <p><span style="color:#0d0016"><strong>首节点</strong></span>：存放第一个有效数据的节点。</p> 
 <p><span style="color:#ad720d"><s>即<u>头节点</u>在首节点之前，它指向首节点的地址。</s></span></p> 
</blockquote> 
<p>头节点之所以存在肯定有它的道理。那么<strong><u>为什么要设置头节点</u></strong>呢？</p> 
<blockquote> 
 <ul>
<li>增加头节点后，首节点的地址保存在头节点的指针域中。也就是说<strong>第一个数据元素</strong>也存在了前驱节点，它就与其他数据元素没啥不一样了，<strong>无需进行特殊处理</strong>。</li>
<li>当链表<u>不设</u>头节点时，假设head为单链表的头指针，它应该指向首节点，则当单链表为长度n为0的空表时，head指针为空。<span style="color:#a5a5a5"><strong>（</strong></span><span style="color:#0d0016"><strong>判断空表</strong></span><span style="color:#a5a5a5"><strong>的条件可记为：<u>head==NULL</u>）</strong></span>
</li>
</ul>
</blockquote> 
<hr>
<h1 id="%C2%A0%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%95%E9%93%BE%E8%A1%A8"> 二、创建静态单链表</h1> 
<p> 静态链表比动态链表简单，所以我们先设置一个静态链表的显示来感受下链表的连接方式:</p> 
<p style="text-align:center"><img alt="" height="1200" src="https://images2.imgbox.com/48/c5/W8VfEZkP_o.png" width="1200"></p> 
<p>这种链表为<span style="color:#b95514"><strong><span style="background-color:#cccccc">静态链表</span></strong></span>。所有节点在程序中的内存并不是我们自己申请的，而是<strong>由<span style="color:#be191c">系统自动分配</span>的内存空间，用完后系统<span style="color:#be191c">自动释放</span></strong>。</p> 
<p>我们可以看得出链表中结构与结构之间主要通过三个指针连接：<span style="color:#98c091"><strong>*head, *p, *next</strong></span>。其中<u><strong>next</strong></u>指针存放在结构体内尾部，<strong><u>方便指向链表的下一结构</u></strong>，具体连接方式可参考代码第15行。</p> 
<p>那么问题就来了，<strong>为何要设置p指针</strong>呢？直接用head指向不就好了吗？这是<strong>因为如果直接使用head指针的话，head指针的值就会被改变，<span style="color:#1a439c"><u>程序就会找不到链表的开始处</u></span></strong>，所以中间需要增加一个p指针。</p> 
<p>上面代码的输出结果为：</p> 
<p style="text-align:center"><img alt="" height="157" src="https://images2.imgbox.com/5f/05/prcNgH06_o.png" width="296"></p> 
<hr>
<h1 id="%C2%A0%E4%B8%89%E3%80%81%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E5%8D%95%E9%93%BE%E8%A1%A8"> 三、创建动态单链表</h1> 
<p>链表的特点之一是其<strong>高效性和灵活</strong>性，与数组相比而言链表能够更加轻松地对数据进行删除和插入等一系列改动操作，并且能够使得<strong>内存空间的合理利用率更高，修改弹性更大</strong>。</p> 
<p>那为什么说使用链表的内存空间利用率更高呢？这体现在<strong>动态链表创建时<u>它对内存的分配</u></strong>：</p> 
<p>所谓<strong><span style="color:#b95514"><span style="background-color:#cccccc">动态链表</span></span></strong><span style="color:#494949">，就是<strong>需要我们</strong></span><span style="color:#be191c"><strong>手动申请</strong></span><span style="color:#494949"><strong>内存（使用</strong></span><u><span style="color:#1a439c"><strong>malloc</strong></span><span style="color:#494949"><strong>或</strong></span><span style="color:#1a439c"><strong>new</strong></span></u><span style="color:#494949"><strong>函数）去存放节点，结束后还需要</strong></span><span style="color:#be191c"><strong>手动释放</strong></span><span style="color:#494949"><strong>内存</strong>。</span></p> 
<p>并且在动态链表中，<u>每个节点没有自己的名字，节点间全靠指针连接</u>。这就意味着<strong><span style="background-color:#be191c">一旦某一节点出现了指针断开的情况，后面的节点将会再也无法找回</span></strong><span style="background-color:#be191c">！</span><span style="color:#a5a5a5">（断啦断啦）</span></p> 
<blockquote> 
 <p><span style="color:#a5a5a5">一个完整的结构链表大概可以分为三个板块：<strong>创建、显示和释放</strong>。接下来谈谈最重要也是最复杂的板块：</span><strong><span style="color:#0d0016">创建链表</span></strong></p> 
 <ol>
<li>使用malloc（）为各个节点分配内存空间；</li>
<li>安放、存储好各个节点的地址使其连接；</li>
<li>收集节点信息。</li>
</ol>
</blockquote> 
<p>上代码：</p> 
<pre><code>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;
struct Stu *create(int n);     //创建链表
void print(struct Stu *head);  //显示链表
struct Stu{
	int id;
	char name[50];
	struct Stu *next;
};

//声明完成
int main()
{
	int n;
	struct Stu *head = NULL;   //创建头指针，初始化head指针为NULL
	printf("请输入你想要创建的节点个数：n");
	scanf("%d",&amp;n);
	head = create(n);     //引用
	print(head);          //引用
}

//上为主函数，引用了两个自定义函数，接下来这就是这两个自定义函数的定义
struct Stu *create(int n)
{
	struct Stu *head,*p,*end;   						//定义头节点，普通节点，尾节点 
	head = (struct Stu *)malloc(sizeof(struct Stu)); 	//给头节点申请内存 
	end = head;        									//设置空表, 即头尾地址一致 
	for(int i=0;i&lt;n;i++)
	{							                    	//利用for循环向链表中添加数据 
		p = (struct Stu *)malloc(sizeof(struct Stu));   //给普通节点申请内存空间 
		scanf("%d %s",&amp;p-&gt;id,p-&gt;name);              	//给数据域赋值 
		end-&gt;next = p;				                	//让上一个节点的数据域指向当前节点 
		end = p;     				             		//end指向当前节点，最终end指向尾节点 
	}
	end-&gt;next = NULL;                                   //给end的指针域置空表示链表结束
	return head;                                        //返回头节点的地址 
}

void print(struct Stu *head)
{
	struct Stu *t = head;
	int j =1;
	t = t -&gt; next;       //不打印头节点 （如果不明白不打印它的原因，可返回上面“头节点和首节点的区别”中查看）
	while(t != NULL)
	{
		printf("%dn%dn%sn", j, t-&gt;id, t-&gt;name);
		t = t-&gt;next;
		j++;
	}
}</code></pre> 
<p>输出结果如下：</p> 
<p style="text-align:center"><img alt="" height="272" src="https://images2.imgbox.com/77/2d/hmotJubM_o.png" width="472"></p> 
<p> 其中第一个自定义函数为<u><em>创建链表</em></u>，第二个自定义函数为<em><u>显示链表</u></em>。具体步骤作用可通过代码注释查看，下面是一些需要注意的点：</p> 
<h2 id="1%E3%80%81%E5%85%B3%E4%BA%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span style="background-color:#cccccc">1、关于初始化</span></h2> 
<p>刚开始设置<span style="color:#be191c"><u><strong>头指针</strong></u></span>（head）时，记得将其<u><strong>初始化为NULL</strong></u>。</p> 
<p>再者就是刚开始创建链表时，需设<u><span style="color:#be191c"><strong>空表</strong></span></u>，即<strong>将头尾指针地址设为一致（<u>end = head</u>）。</strong></p> 
<h2 id="2%E3%80%81%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A"><span style="background-color:#cccccc">2、关于内存分配：</span></h2> 
<p>上面的链表中主要进行了两部分内存分配，一个是对头节点，一个是对普通节点。不难发现分配内存的形式是：</p> 
<blockquote> 
 <p style="text-align:center"><span style="color:#be191c"><strong>指向节点的指针名(即其地址) = (struct 结构名 *)malloc(sizeof(struct 结构名)); </strong></span></p> 
</blockquote> 
<p><span style="color:#a5a5a5">记得一定要先分配地址，再进行指针连接节点的操作。</span></p> 
<p>如果你不放心，想<strong><span style="background-color:#f9eda6">检查malloc()是否成功请求到内存</span></strong>时，就可<strong>以<span style="background-color:#f9eda6">检查malloc的返回值</span>是否为NULL</strong>。<u>如果返回NULL，则表明未获取到相对应的内存。</u></p> 
<h2 id="3%E3%80%81%E5%90%84%E7%BB%93%E6%9E%84%E5%9C%B0%E5%9D%80%E5%AD%98%E6%94%BE%E6%83%85%E5%86%B5%EF%BC%9A"><span style="background-color:#cccccc">3、各结构地址存放情况：</span></h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr>
<td>第一个结构的地址</td>
<td>存放在head指针中</td>
</tr>
<tr>
<td>之后每个结构的地址</td>
<td>存放在上一结构的next指针成员中。</td>
</tr>
</tbody></table>
<p>来看看上面代码的核心部分，也就是它的创建链表部分：</p> 
<h3 id="%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A">
<span style="color:#0d0016"><u><span style="background-color:#6eaad7">尾插法</span></u></span><span style="background-color:#6eaad7">建立单链表：</span>
</h3> 
<p style="text-align:center"><img alt="" height="644" src="https://images2.imgbox.com/85/e2/ggzRGymx_o.png" width="1200"></p> 
<p>尾插法建立链表算是一个较为常规的操作。其实从设断点的<u>第30和31行代码</u>可以看得出来，end指针和p指针是同时移动的，这看起来好像让你感觉这俩指针多此一举，觉得取其一不就好了。nonono，还是那句话，<strong><span style="color:#1a439c"><u><span style="background-color:#cccccc">p指针</span></u>的作用是用于连接</span>，<span style="color:#1c7892">而<u><span style="background-color:#cccccc">end指针</span></u>主要是追踪最新节点，当没有新的节点加入时好把最后一个节点内的next成员设为NULL代表链表结束</span>。</strong>因此设断点的这两步<u>无论是删除其一还是调换顺序，都会导致链表断开，没有输出</u>。</p> 
<p><strong>在程序的for循环中，每每输入一次p就会更新一个新结构，也就可以理解为：<u>在for循环中scanf语句后面的两个赋值语句中，对于等号而言，<span style="background-color:#edf6e8">左边是上一个节点的信息，而右边是新节点的信息</span>。</u></strong></p> 
<h3 id="%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A"><strong><span style="color:#0d0016"><u><span style="background-color:#6eaad7">头插法</span></u></span><span style="background-color:#6eaad7">建立单链表：</span></strong></h3> 
<p style="text-align:center"><img alt="" height="568" src="https://images2.imgbox.com/d4/9a/QSOv0FJY_o.png" width="1200"></p> 
<p>和尾插法的代码做个对比其实就能看得出来，头插法和尾插法其实区别不大。<u>因为头插法的尾节点已经固定，所以我们就不需要额外再设置end指针去跟踪尾节点了。</u> 同时头插法也删除了尾插法第25行的空表设置操作，主要区别依旧在第30行和31行。</p> 
<hr>
<h1 id="%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9">三、链表的增删查改</h1> 
<h2 id="1%E3%80%81%E5%A2%9E"><span style="background-color:#cccccc">1、增</span></h2> 
<p><span style="color:#a5a5a5">插入元素的位置有三种：头、中、尾，但插入形式都是一样的：</span></p> 
<blockquote> 
 <p><span style="color:#0d0016">1）将新节点的 next 指针指向插入位置后的节点；</span></p> 
 <p><span style="color:#0d0016">2）将插入位置前节点的 next 指针指向插入节点；</span></p> 
</blockquote> 
<p><img alt="" height="400" src="https://images2.imgbox.com/03/fd/Madn3uiC_o.png" width="1200"></p> 
<p><span style="color:#be191c"><strong>千万注意1和2的先后顺序不能对调！！</strong></span>必须是<strong>先接后、再接前</strong>，如果顺序对调则会导<u>致插入位置后的这部分链表丢失</u>，就无法进行下一步连接操作了。</p> 
<p>下面我们设计一个函数，在单链表中的第n个位置上插入新节点。</p> 
<pre><code>void ADD(struct Stu *head, int n)     
{    
	struct Stu *p = head,*pr;
	pr = (struct Stu*)malloc(sizeof(struct Stu));  //pr是指向新插节点的指针

	printf("请输入要插入的数据n");
	scanf("%d %s",&amp;pr-&gt;id,pr-&gt;name);
	int i = 0;

    while( i&lt;n-1 &amp;&amp; p!=NULL )   //使p指向将要插入节点n-1的位置 
    {          
    	p = p-&gt;next;
		i++;
	}   
		pr-&gt;next = p-&gt;next;   //将新建节点的地址指向将要插入节点的后一个节点的地址 
		p-&gt;next = pr;        //使插入节点指向新建节点 
}</code></pre> 
<p>首先从头节点开始，找到链表中的第n-1个节点的地址p，然后在其后面插入第n个节点。插入时，先将新节点的指针pr指向原来的第n个节点，然后再将n-1个节点指向新的节点，即完成插入操作。</p> 
<h2 id="2%E3%80%81%E5%88%A0"><span style="background-color:#cccccc">2、删 </span></h2> 
<p><span style="color:#a5a5a5">删除链表中的节点实质上就是<u>对节点的摘除</u>，同时需要注意<u>释放不用的内存空间</u>。</span></p> 
<blockquote> 
 <p><span style="color:#0d0016">1）将结点从链表中摘下来；</span></p> 
 <p><span style="color:#0d0016">2）手动释放节点，回收被已删除节点占用的存储空间；</span></p> 
</blockquote> 
<p style="text-align:center"><img alt="" height="155" src="https://images2.imgbox.com/95/20/6d8vBfuS_o.png" width="734"></p> 
<p> 其实<strong>摘取节点</strong>的操作很简单，就是：</p> 
<p style="text-align:center"><span style="color:#be191c"><strong>temp-&gt;next=temp-&gt;next-&gt;next;</strong></span></p> 
<p>下面我们设置一个函数，删除单链表的第n个节点：</p> 
<pre><code>void DELETE(struct Stu *head,int n)  //删除n处的节点
{          
	struct  Stu *p = head,*pr;
	int i =0;
	while(i&lt;n-1 &amp;&amp; p!=NULL)     //找到第n-1个节点
   {      
		p = p-&gt;next;  
		i++;
	}
	if(p!=NULL)   //p不能指向尾节点之后的节点（n节点不存在）
    {           
	    pr= p-&gt;next;   //pr指向第n个节点 
		p-&gt;next = pr-&gt;next;    //连接删除节点左右两边的节点（把这个节点忽视掉了）
		free(pr);        //释放删除节点内存
	} else{
		printf("节点不存在n"); 
	}
} 
</code></pre> 
<p> 你会发现除了最后一个if语句的内容，前面的操作和“增”的操作代码类似。所以其实链表中的各类操作都是大同小异，主要难点只是在于其连接方式罢了（会有点容易乱）。</p> 
<h2 id="3%E3%80%81%E6%9F%A5"><span style="background-color:#cccccc">3、查</span></h2> 
<p>在链表中查找指定节点通常使用<span style="color:#be191c"><strong>遍历</strong></span>的方法：<u>从表头依次遍历表中节点，用被查找元素与各节点数据元素进行比对，直到比对成功或遍历至链表最末端的 NULL（查找失败）。</u></p> 
<p>接下来我们构造函数查找节点元素，其中p为原链表，elem表示被查找元素：</p> 
<pre><code>int selectElem(struct Stu * p,int id)
{
    struct Stu * t=p;  //新建一个指针t，初始化为头指针 p
    int i=1;
   
    while (t-&gt;next)    //由于头节点的存在，因此while中的判断为t-&gt;next
    {
        t=t-&gt;next;
        if (t-&gt;id==id) 
        {
			printf("yes");  //表示查找到含有此元素的节点
            return i;
        }
        i++;
    }
	printf("no");  //表示没有查找到
    return -1;  //程序执行至此处，表示查找失败
}</code></pre> 
<p>在查找到想要查找的节点时，也可以选择<u>打印输出该节点数据域的内容</u>。</p> 
<p>同时也要注意，<strong>在遍历有头节点的链表时</strong>，需避免头节点对测试数据的影响。因此在遍历时，应该建立使用上面代码中的遍历方法，<strong><span style="color:#be191c">直接越过头节点</span>对链表进行有效遍历</strong>。</p> 
<h2 id="4%E3%80%81%E6%94%B9"><span style="background-color:#cccccc">4、改 </span></h2> 
<p>链表节点的修改，其实就只需<u>通过遍历找到存储此元素的节点，然后对节点中的数据域做更改操作即可。 </u></p> 
<p>依旧是定义函数操作，上代码：</p> 
<pre><code>void change(struct Stu *head,int n)
{
	struct Stu *p = head;
	int i = 0;
	while(i&lt;n &amp;&amp; p!=NULL)   //使p指向需修改节点 
   {     
		p = p-&gt;next;
		i++;
	}
	if(p != NULL)
    {             
	    printf("请输入修改之后的值:n");
	   scanf("%d %s",&amp;p-&gt;id,p-&gt;name);	
	}else{
		printf("节点不存在！n");
	} 
}</code></pre> 
<hr>
<h1 id="%E5%9B%9B%E3%80%81%E6%89%80%E6%9C%89%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%EF%BC%9A"><strong>四、所有基础实现综合：</strong></h1> 
<p><span style="color:#cccccc">（有部分注释还没注，所以显得有些粗糙大家将就看）</span></p> 
<pre><code>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;
struct Stu *create(int n);     //创建链表
void print(struct Stu *head);  //显示链表
int selectElem(struct Stu * p,int id);  //查找节点
typedef struct Stu{
	int id;
	char name[50];
	struct Stu *next;
}BE;

int main()
{
	int n;
	struct Stu *head = NULL;              //创建头指针 
	printf("请输入你想要创建的节点个数：n");
	scanf("%d",&amp;n);
	head = create(n);
	ADD(head,3);
	DELETE(head,2);
	change(head,3);
	print(head);
	selectElem(head,2);
	
}

void change(struct Stu *head,int n)     
{
	struct Stu *p = head;
	int i = 0;
	while(i&lt;n &amp;&amp; p!=NULL)   //使p指向需修改节点 
   {     
		p = p-&gt;next;
		i++;
	}
	if(p != NULL)
    {             
	    printf("请输入修改之后的值:n");
	   scanf("%d %s",&amp;p-&gt;id,p-&gt;name);	
	}else{
		printf("节点不存在！n");
	} 
}

int selectElem(struct Stu * p,int id)
{
    struct Stu * t=p;  //新建一个指针t，初始化为头指针 p
    int i=1;
   
    while (t-&gt;next)    //由于头节点的存在，因此while中的判断为t-&gt;next
    {
        t=t-&gt;next;
        if (t-&gt;id==id) 
        {
			printf("yes");
            return i;
        }
        i++;
    }
	printf("no");
    return -1;  //程序执行至此处，表示查找失败
}

struct Stu *create(int n)
{
	struct Stu *head,*p;   				        		//定义头节点，普通节点
	head = (struct Stu *)malloc(sizeof(struct Stu)); 	//给头节点申请内存 

	for(int i=0;i&lt;n;i++)
	{							                    	//利用for循环向链表中添加数据 
		p = (struct Stu *)malloc(sizeof(struct Stu));   //给普通节点申请内存空间 
		scanf("%d %s",&amp;p-&gt;id,p-&gt;name);              	//给数据域赋值 
		p-&gt;next = head-&gt;next;                           //新节点指向原来的首节点
		head-&gt;next = p;                                 //链表的头节点指向新节点
	}
	return head;                                        //返回头节点的地址 
}

void ADD(struct Stu *head, int n)     
{    
	struct Stu *p = head,*pr;
	pr = (struct Stu*)malloc(sizeof(struct Stu));  //pr是指向新插节点的指针

	printf("请输入要插入的数据n");
	scanf("%d %s",&amp;pr-&gt;id,pr-&gt;name);
	int i = 0;

    while( i&lt;n-1 &amp;&amp; p!=NULL )   //使p指向将要插入节点n-1的位置 
    {          
    	p = p-&gt;next;
		i++;
	}   
		pr-&gt;next = p-&gt;next;   //将新建节点的地址指向将要插入节点的后一个节点的地址 
		p-&gt;next = pr;        //使插入节点指向新建节点 
}

void DELETE(struct Stu *head,int n)  //删除n处的节点
{          
	struct  Stu *p = head,*pr;
	int i =0;
	while(i&lt;n-1 &amp;&amp; p!=NULL)     //找到第n-1个节点
{      
		p = p-&gt;next;  
		i++;
	}
	if(p!=NULL)   //p不能指向尾节点之后的节点（n节点不存在）
{           
	    pr= p-&gt;next;   //pr指向第n个节点 
		p-&gt;next = pr-&gt;next;    //连接删除节点左右两边的节点（把这个节点忽视掉了）
		free(pr);        //释放删除节点内存
	} else
{
		printf("节点不存在n"); 
	}
} 

void print(struct Stu *head)
{
	struct Stu *t = head;
	int j =1;
	t = t-&gt;next;       //不打印头节点 
	while(t != NULL)
	{
		printf("%dt%dt%sn",j,t-&gt;id,t-&gt;name);
		t = t-&gt;next;
		j++;
	}
}</code></pre> 
<hr>
<p>链表魅力无穷大（虽然有时候会让你很暴躁。</p> 
<p>篇幅多少有点大了，还会开篇链表（下）写一下无头节点单链表的增删查改、链表逆置、循环链表、双链表以及二叉树和链表之间等等。</p> 
<p>链表学透彻了打出来上百行代码去实现不同的功能，有点心还能整得花里胡哨些,做出来真的很有成就感。</p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>