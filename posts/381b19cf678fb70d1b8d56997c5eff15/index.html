<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Private market：借助ZK实现的任意计算的trustless交易 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Private market：借助ZK实现的任意计算的trustless交易</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="1__0"></a>1. 引言</h1> 
<p>Private market，借助zk-SNARKs和以太坊来 隐私且trustlessly selling：</p> 
<ul>
<li>1）以太坊地址的私钥（ECDSA keypair）</li>
<li>2）EdDSA签名</li>
<li>3）Groth16 proof：借助递归性来匿名交易Groth16 proofs。</li>
</ul> 
<p>开源代码实现见：</p> 
<ul>
<li>
<a href="https://github.com/dmpierre/eth-private-market">https://github.com/dmpierre/eth-private-market</a>（Circom、TypeScript、Solidity）</li>
<li>
<a href="https://github.com/nulven/EthDataMarketplace">https://github.com/nulven/EthDataMarketplace</a>（TypeScript、Solidity）</li>
</ul> 
<p>Private market定位为permissionless P2P时长，支持任意用户bid/ask私钥、签名和Groth16 proof。</p> 
<p>数据交易需同时解决2大问题：</p> 
<ul>
<li>数据仅对buyer可用。</li>
<li>数据具有可验证的属性。</li>
</ul> 
<p><img src="https://images2.imgbox.com/cc/06/w7wAfXpO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/68/1a/SXV8edLX_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/06/4f/s4JEuPQZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9e/b7/H0ZQJSal_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cd/1a/UaLSquoT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ca/fe/V6j5v5wT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b1/fa/yMoJcluD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/aa/z2XmED6v_o.png" alt="在这里插入图片描述"><br> 相关示例有：</p> 
<ul>
<li>1）zkML：基于proven accuracy来交易机器学习模型。 
  <ul><li>
<a href="https://github.com/zk-ml/linear-regression-demo">https://github.com/zk-ml/linear-regression-demo</a>（Solidity&amp;Javascript）</li></ul> </li>
<li>2）Yi Protocol：Down-sampled versions of images for private NFT transfer。</li>
<li>3）Nightmarket：Dark Forest Coordinate交易市场 
  <ul><li>
<a href="https://github.com/0xSage/nightmarket">https://github.com/0xSage/nightmarket</a>（Solidity&amp;Javascript）</li></ul> </li>
<li>4）Image blurring：<br> <img src="https://images2.imgbox.com/ce/86/jWFMRfvg_o.png" alt="在这里插入图片描述">
</li>
</ul> 
<h1>
<a id="2__32"></a>2. 三大基石</h1> 
<p>本协议基于以下3大基石来构建：</p> 
<ul>
<li>1）Assertion proof：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          ( 
         
        
          d 
         
        
          a 
         
        
          t 
         
        
          a 
         
        
          , 
         
        
          p 
         
        
          r 
         
        
          o 
         
        
          p 
         
        
          e 
         
        
          r 
         
        
          t 
         
        
          y 
         
        
          ) 
         
        
          = 
         
        
          t 
         
        
          r 
         
        
          u 
         
        
          e 
         
        
       
         f(data, property)=true 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal" style="margin-right: 0.1076em">f</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right: 0.0278em">er</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0359em">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span>，即assertion proof用于证明所售数据中的片段满足某个属性。 
  <ul><li>如知道对应特定以太坊地址的私钥：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            f 
           
          
            ( 
           
          
            s 
           
          
            e 
           
          
            c 
           
          
            r 
           
          
            e 
           
          
            t 
           
          
            K 
           
          
            e 
           
          
            y 
           
          
            , 
           
          
            a 
           
          
            d 
           
          
            d 
           
          
            r 
           
          
            e 
           
          
            s 
           
          
            s 
           
          
            ) 
           
          
            = 
           
          
            t 
           
          
            r 
           
          
            u 
           
          
            e 
           
          
         
           f(secretKey,address)=true 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal" style="margin-right: 0.1076em">f</span><span class="mopen">(</span><span class="mord mathnormal">secre</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0359em">Key</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">ress</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span>，从而让buyer信服代售数据中的private piece确实具有其感兴趣的某种属性。</li></ul> </li>
<li>2）Encryption proof：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          e 
         
        
          n 
         
        
          c 
         
        
          ( 
         
        
          d 
         
        
          a 
         
        
          t 
         
        
          a 
         
        
          , 
         
        
          k 
         
        
          e 
         
        
          y 
         
        
          ) 
         
        
       
         enc(data,key) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mord mathnormal" style="margin-right: 0.0315em">k</span><span class="mord mathnormal" style="margin-right: 0.0359em">ey</span><span class="mclose">)</span></span></span></span></span> 
  <ul><li>encryption proof旨在让buyer信服某数据的private piece用要求的key进行了加密。该key类似于某shared buyer-seller ECDH value。</li></ul> </li>
<li>3）Commitment proof：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          h 
         
        
          ( 
         
        
          d 
         
        
          a 
         
        
          t 
         
        
          a 
         
        
          ) 
         
        
       
         h(data) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span></span>。commitment proof可承担不同角色，存在不同种类的commitment proofs。通常，commitment proof致力于证明what is being sold and how it is sold verifies some earlier committed value。如： 
  <ul>
<li>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            h 
           
          
            ( 
           
          
            d 
           
          
            a 
           
          
            t 
           
           
           
             a 
            
            
            
              s 
             
            
              o 
             
            
              l 
             
            
              d 
             
            
           
          
            ) 
           
          
            = 
           
          
            = 
           
          
            h 
           
          
            ( 
           
          
            d 
           
          
            a 
           
          
            t 
           
           
           
             a 
            
            
            
              l 
             
            
              i 
             
            
              s 
             
            
              t 
             
            
              e 
             
            
              d 
             
            
           
          
            ) 
           
          
         
           h(data_{sold})==h(data_{listed}) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">so</span><span class="mord mathnormal mtight" style="margin-right: 0.0197em">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em"></span><span class="mrel">==</span><span class="mspace" style="margin-right: 0.2778em"></span></span><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em"><span class="" style="margin-left: 0em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em">l</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，交易的数据与初始化列出的数据已知。</li>
<li>提前计算承诺值<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            h 
           
          
            ( 
           
          
            s 
           
          
            h 
           
          
            a 
           
          
            r 
           
          
            e 
           
          
            d 
           
          
            K 
           
          
            e 
           
          
            y 
           
          
            ) 
           
          
         
           h(sharedKey) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">ha</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right: 0.0359em">Key</span><span class="mclose">)</span></span></span></span></span>，销售时，确保buyer和seller共享了正确的加密秘钥。</li>
</ul> </li>
</ul> 
<h1>
<a id="3__42"></a>3. 案例一：卖某个奇数</h1> 
<p>假设Alice向Bob出售某个奇数，基本流程为：</p> 
<ul>
<li>1）Alice知道某个秘密奇数，希望能卖1Ether： 
  <ul>
<li>Alice对该奇数进行commit，并将相应哈希结果推送到某合约中。</li>
<li>Alice发布其公钥，任何人都可用于计算共享密钥。</li>
</ul> </li>
<li>2）Bob想要知道Alice卖的奇数： 
  <ul>
<li>Bob根据Alice发布的公钥计算二者的共享密钥。</li>
<li>Bob发布 其计算共享密钥时的公钥。</li>
<li>Bob对其私钥进行commit。</li>
<li>Bob托管1Ether。</li>
</ul> </li>
<li>3）Alice现在可向Bob出售其奇数了。Alice会计算包含如下信息的single proof： 
  <ul>
<li>展示其数字无法被2整除——即assertion proof。</li>
<li>展示其对该奇数进行了正确加密——即encryption proof。该加密数据会提交上链。</li>
<li>展示其使用了与Bob相同的共享密钥，且所售奇数与早前commit的一致——即Commitment proof。</li>
</ul> </li>
</ul> 
<p>一旦合约验证Alice的proof通过，则将释放Bob托管的1Ether给Alice。至此，Alice获利1ETH，Bob使用共享密钥解密链上数据，可获得相应的奇数。</p> 
<h1>
<a id="4__58"></a>4. 案例二：卖私钥</h1> 
<p>有趣的是，有一个围绕以太坊流动性最强的资产之一创建市场的计划。私钥起着访问账户和发起交易的作用，我们可能想知道这样的设置能起到什么作用。<br> 首先，能够不信任地出价或索要私钥可能会成为将股份委托给未知方的威慑机制。如果一把钥匙从具有委托金额的赌注者那里泄露，任何拥有它的人都可以使用这种设置匿名、不信任地出售它。因此，这种设置可以发出私人和有价值信息泄露的信号。<br> 它还提出了有关治理协议和投票机制的问题。来自私人钥匙被提议出售或出售的地址的选票应该被计算在内吗？在市场上出售私钥可能不是操纵选票的最直接方式。事实上，购买私钥并不能以任何方式保证买家出价的地址会以特定的方式投票。然而，治理协议可能容易受到恶意实体以一定ETH金额出售或购买一组地址的攻击，从而使对特定决定的投票可能无效。一旦参与地址的私钥在私人市场上播出，这些地址是否仍应该在治理决策中有发言权？<br> 最后，私钥市场设置的某些部分可能与帐户抽象的上下文相关。钱包可能会采用旋转密钥对方案来对其交易进行签名。对于账户借贷等用例来说，能够使用这种设置出售对钱包的临时访问可能特别有趣。<br> 我们的建设在任何方面都不是决定性的。相反，它指向了一个方向，可以使以太坊钱包这一非流动性资产具有流动性。</p> 
<p>secp256k1 keypair为以太坊和比特币的基石，卖以太坊私钥 分为2种情况：</p> 
<ul>
<li>1）ask</li>
<li>2）bid</li>
</ul> 
<h2>
<a id="41_Placing_an_ask_on_an_ethereum_address_69"></a>4.1 Placing an ask on an ethereum address</h2> 
<p>Placing an ask on an ethereum address的流程为：</p> 
<ul>
<li>1）seller对其地址进行commit，表示其愿意出售相应的私钥，并标价。</li>
<li>2）buyer在合约内托管相应数量的ETH，并提交其公钥。buyer会计算： 
  <ul>
<li>使用seller的公钥来计算出共享密钥ECDH value</li>
<li>对该共享密钥进行commit。</li>
</ul> </li>
<li>3）为获利，seller向链上提交的proof需满足： 
  <ul>
<li>Assertion correctness：即地址派生自所提供的私钥。</li>
<li>Encryption correctness：即私钥已被正确加密。</li>
<li>Commitment correctness：即： 
    <ul>
<li>加密秘钥对应 Bob提交的committed shared key。</li>
<li>派生地址对应之前commit的地址。</li>
</ul> </li>
</ul> </li>
</ul> 
<p>由于proof data中包含了encrypted data，因此现在buyer可访问链上的encrypted private key。<br> <img src="https://images2.imgbox.com/51/ba/HcAHKW19_o.png" alt="在这里插入图片描述"><br> 相应的<a href="https://github.com/dmpierre/eth-private-market/blob/main/packages/circuits/circom/eth-address/no-ecdh-check/sellETHAddressNoECDH.circom">电路</a>为：</p> 
<pre><code class="prism language-circom">/*
     This circuit is used within the ask setup. It does not require to check
     the validity of an ECDH shared key, since it is not used. The shared key
     has been committed onchain, we make the hash of this shared key public 
     and check against this commmitment when posting the proof.
*/

template SellETHAddressNoECDH(n, k) {

     signal input sharedKey[2]; // private
     signal input sharedKeyHash; // public

     signal input poseidonNonce; // public
     signal input encryptedPrivECDSAKey[7]; // public
     
     signal input privECDSAKey[4]; // private

     signal output address;

     var i;

     /* 
          1. Hash the shared key 
          Ensure that it corresponds to the committed one. 
     */

     component poseidonSharedKey = Poseidon(2);
     poseidonSharedKey.inputs[0] &lt;== sharedKey[0];
     poseidonSharedKey.inputs[1] &lt;== sharedKey[1];

     poseidonSharedKey.out === sharedKeyHash;

     /*
          2. Check that the private key derives to the sold address and that its encryption is correct
     */
     component sellETHAddress = CheckAndEncryptETHAddress(n, k);

     sellETHAddress.sharedKey[0] &lt;== sharedKey[0];
     sellETHAddress.sharedKey[1] &lt;== sharedKey[1];
     sellETHAddress.poseidonNonce &lt;== poseidonNonce;


     for (i = 0; i &lt; 7; i++) {
          sellETHAddress.encryptedPrivECDSAKey[i] &lt;== encryptedPrivECDSAKey[i];
     }

     for (i = 0; i &lt; 4; i++) {
          sellETHAddress.privECDSAKey[i] &lt;== privECDSAKey[i];
     }

     address &lt;== sellETHAddress.address;
}

component main{ public [ sharedKeyHash, poseidonNonce, encryptedPrivECDSAKey ] } = SellETHAddressNoECDH(64, 4);
</code></pre> 
<h2>
<a id="42_Placing_a_bid_on_an_ethereum_address_142"></a>4.2 Placing a bid on an ethereum address</h2> 
<p>bid与ask流程不同。bid是buyer先表达购买某地址的意图，因此是buyer在seller之前发布其公钥。从seller的角度来看，具有与ask流程不同的proof。</p> 
<p>Placing a bid on an ethereum address的流程为：</p> 
<ul>
<li>1）buyer对某以太坊地址出价，并在market合约中托管相应数量的ETH。</li>
<li>2）seller提交上链的proof中需包含： 
  <ul>
<li>Assertion correctness：即地址派生自所提供的私钥。</li>
<li>Encryption correctness：即私钥已被正确加密。</li>
<li>Commitment correctness：即： 
    <ul>
<li>seller使用了buyer的committed公钥。</li>
<li>派生地址对应当前所bid的地址。</li>
</ul> </li>
<li>Key exchange correctness：seller的communicated公钥，对应于，用于计算共享加密密钥的公钥。</li>
</ul> </li>
</ul> 
<p><img src="https://images2.imgbox.com/0f/48/dOXYRVdk_o.png" alt="在这里插入图片描述"><br> bid流程具有更少的步骤。但seller需要添加一个key exchange correctness proof。否则，seller could communicate a different public key from the one he derived using the private key used to compute the shared encryption key.</p> 
<p>相应的<a href="https://github.com/dmpierre/eth-private-market/blob/main/packages/circuits/circom/eth-address/ecdh-check/sellETHAddressECDH.circom">电路</a>为：</p> 
<pre><code class="prism language-circom">/*
     This circuit is used within the bid setup. We check here that 
     the ECDH value has been correctly computed. We make the public key of the seller
     public so that the buyer - bidder - can compute the shared key value after the
     sale has been made. 
*/

template SellETHAddressECDH(n, k) {
     
     signal input sellerPubJubJub[2]; // public
     signal input sellerPrivJubJub; // private

     signal input buyerPubJubJub[2]; // public

     signal input sharedKey[2]; // private

     signal input poseidonNonce; // public
     signal input encryptedPrivECDSAKey[7]; // public
     
     signal input privECDSAKey[4]; // private

     signal output address;

     /*
          1. Check that the shared key is correctly computed
     */
     component sharedKeyCheck = SharedJubJubKeyCheck();
     
     sharedKeyCheck.pubA[0] &lt;== sellerPubJubJub[0];
     sharedKeyCheck.pubA[1] &lt;== sellerPubJubJub[1];
     sharedKeyCheck.privA &lt;== sellerPrivJubJub;
     
     sharedKeyCheck.pubB[0] &lt;== buyerPubJubJub[0];
     sharedKeyCheck.pubB[1] &lt;== buyerPubJubJub[1];
     
     sharedKeyCheck.sharedKey[0] &lt;== sharedKey[0];
     sharedKeyCheck.sharedKey[1] &lt;== sharedKey[1];

     /*
          2. Check the sold address is correct
     */
     component sellETHAddress = CheckAndEncryptETHAddress(n, k);

     sellETHAddress.sharedKey[0] &lt;== sharedKey[0];
     sellETHAddress.sharedKey[1] &lt;== sharedKey[1];
     sellETHAddress.poseidonNonce &lt;== poseidonNonce;

     var i;

     for (i = 0; i &lt; 7; i++) {
          sellETHAddress.encryptedPrivECDSAKey[i] &lt;== encryptedPrivECDSAKey[i];
     }

     for (i = 0; i &lt; 4; i++) {
          sellETHAddress.privECDSAKey[i] &lt;== privECDSAKey[i];
     }

     address &lt;== sellETHAddress.address;
}

component main{ public [ sellerPubJubJub, buyerPubJubJub, poseidonNonce, encryptedPrivECDSAKey ] } = SellETHAddressECDH(64, 4);
</code></pre> 
<h1>
<a id="5_EdDSA_223"></a>5. 案例三：卖EdDSA签名</h1> 
<p>在我们的应用程序中，签名的购买者要求签名其公钥的哈希。利用一些公钥注册表，这种设置可以成为构建web3本地订阅平台的一种令人信服的方式。在市场上购买的签名是<a href="https://dspace.mit.edu/bitstream/handle/1721.1/61151/698133641-MIT.pdf?sequence=2&amp;isAllowed=y">PCD（Proof-Carrying Data）</a>，表明买方知道“由特定服务的公钥签名的签名”。因此，签名的购买者可以不受信任地获得感兴趣的服务。</p> 
<p>买家也可以将这些签名收集在钱包中，选择我们希望完全或部分泄露给服务提供商的签名。例如，提交了一个<a href="https://github.com/proofcarryingdata/zupass/pull/154">PR</a>，将该<a href="https://github.com/dmpierre/jubjub-signature-pcd">jubjub-signature-pcd</a>添加到<a href="https://github.com/proofcarryingdata/zupass/tree/main">Zupass repo</a>中，允许将此类签名存储在Zuzalu护照中。</p> 
<p>让我们看一个具体的例子。比特币杂志建议使用这种设置订阅其内容。Alice 支付0.01 ETH访问该报一年。报纸服务从发布在链上的内容中获取Alice的公钥，对其进行哈希签名，并在链上发布加密签名。Alice可以解密签名，现在可以将其添加到PCD钱包中。登录后，Alice将被要求证明：</p> 
<ul>
<li>（1）她知道由报纸的密钥对签名的签名，该密钥对的消息是她的公钥的散列，</li>
<li>（2）她知道该公钥的私钥。公钥将保持隐藏状态，Alice只需提供proof即可。因此，她将不信任地私下登录并阅读比特币杂志文章。</li>
</ul> 
<p>在我们的设置中，我们要求买家发布卖家需要签名的哈希预图像。尽管这会产生额外的调用数据，但卖家知道要签名的消息。</p> 
<p>EdDSA签名的ask流程与ECDSA keypair的ask流程没有太大区别。签名的买方可以要求由卖方提交的公钥对任意公共消息进行签名，具体流程为：</p> 
<ul>
<li>1）seller对其public keypair进行commit，声称只要给特定价格，可对消息进行签名。</li>
<li>2）buyer托管相应数量的ETH到market合约并提交其公钥，以下单要求签名。buyer会在链下计算： 
  <ul>
<li>使用seller的公钥来计算ECDH value（即“shared key”）</li>
<li>对shared key进行commit</li>
<li>待签名消息，包含了buyer的公钥哈希。</li>
</ul> </li>
<li>3）seller提交上链的proof中需包含： 
  <ul>
<li>assertion correctness：签名是对特定的哈希进行签署。</li>
<li>encryption correctness：签名解密正确</li>
<li>commitment correctness： 
    <ul>
<li>加密密钥对应committed shared key。</li>
<li>签名消息对应buyer的链上committed hash。</li>
</ul> </li>
</ul> </li>
</ul> 
<p>本方案中，卖家可能对签署任意数据感到不舒服。作为补救措施，买家还发布了正在签名的哈希的pre-image。卖家现在必须检查正在签名的哈希是否与所传递的pre-image相对应，并做出相应的决定。</p> 
<p>相应的<a href="https://github.com/dmpierre/eth-private-market/blob/main/packages/circuits/circom/eddsa-signature/sellSigPublicMessageEdDSA.circom">电路</a>见：</p> 
<pre><code class="prism language-circom">/*
     A seller has placed an ask order for a signature over a public message
     A buyer has escrowed some value for it, along with a public preimage
     The seller makes a proof that:
          1. The signature has been encrypted with the committed shared key
          2. The signature signs a hash whose preimage is the publicly committed one
          3. The signature is correct
          4. The encryption is correct
*/

template SellSigPublicMessageEdDSA() {

     signal input pubKeyJubJubSeller[2]; // public
     signal input messagePreImage[2]; // public

     signal input message; // public h( messagePreImage )

     signal input sharedKey[2]; // private
     signal input sharedKeyHash; // public
     signal input signaturePoseidonNonce; // public
     
     signal input eddsaSigR8[2]; // private
     signal input eddsaSigS; // private
     signal input poseidonEncryptedSig[4]; // public 

     var i;

     /* 
          1. Hash the shared key 
          Ensures that it corresponds to the committed one
     */

     component poseidonSharedKey = Poseidon(2);
     poseidonSharedKey.inputs[0] &lt;== sharedKey[0];
     poseidonSharedKey.inputs[1] &lt;== sharedKey[1];

     poseidonSharedKey.out === sharedKeyHash;

     /*
          2. Hash message preimage
          Check that h( messagePreImage ) === message
     */

     component poseidonPubJubJubBuyer = Poseidon(2);
     poseidonPubJubJubBuyer.inputs[0] &lt;== messagePreImage[0];
     poseidonPubJubJubBuyer.inputs[1] &lt;== messagePreImage[1];

     poseidonPubJubJubBuyer.out === message;

     /* 
          3. Check correctness of the signature
          Ensures that no other message than h( payload ) has been signed
     */

     component sigVerifier = EdDSAPoseidonVerifier_patched();
 
     sigVerifier.Ax &lt;== pubKeyJubJubSeller[0];
     sigVerifier.Ay &lt;== pubKeyJubJubSeller[1];
     sigVerifier.S &lt;== eddsaSigS;
     sigVerifier.R8x &lt;== eddsaSigR8[0];
     sigVerifier.R8y &lt;== eddsaSigR8[1];
     sigVerifier.M &lt;== message;
 
     sigVerifier.valid === 1;

     /*
          4. Check correctness of the encryption
          Ensures that encryption has been carried out with correct shared key
     */

     component pSig = PoseidonEncryptCheck(3);

     pSig.nonce &lt;== signaturePoseidonNonce;
     for (i = 0; i &lt; 4; i++) {
          pSig.ciphertext[i] &lt;== poseidonEncryptedSig[i];
     }
     pSig.message[0] &lt;== eddsaSigR8[0];
     pSig.message[1] &lt;== eddsaSigR8[1];
     pSig.message[2] &lt;== eddsaSigS;
     pSig.key[0] &lt;== sharedKey[0];
     pSig.key[1] &lt;== sharedKey[1];

     pSig.out === 1;

}
</code></pre> 
<h1>
<a id="6_Groth16_proof_338"></a>6. 案例四：卖Groth16 proof</h1> 
<p>当我们开始这个项目时，我们首先想知道如何让proof-gated服务的用户能够完全拥有他们所拥有的访问权限。</p> 
<p>最近，<a href="https://personaelabs.org/">Personae Labs</a>发布了<a href="https://nouns.nymz.xyz/">heyanoun</a>，这是一个专门为名词所有者设计的工具，可以匿名地在网上构思和讨论DAO道具。这对名词群体来说是相当有力量的。虽然是公开的，但该应用程序的验证性确保了只有名词持有者才能参与，从而起到过滤机制的作用，提高了讨论质量。<br> 然而，假设非名词持有者也可能有有趣的观点可能并不太牵强。如果一个非名词持有者想匿名为一个道具团队背书，该怎么办？或者，如果一个道具有一个损坏的启动器，只有非名词持有者（可能希望保持匿名）才能报告恶意，该怎么办？另外，名词持有者自己呢？他们利用自己的访问权限，让匿名者能够在自己的平台上表达自己，这不是很有趣吗？这可能会为他们持有的NFT增加一些价值。<br> 这就是销售groth16 proofs所能做到的。举个例子，我最近发现了一个访问heyanon群组的请求命令。当我的订单被一位匿名群成员填写后，我在相应的heyanon群中发布了一条消息，甚至没有将我的地址包含在这个群中！太酷了。填写我订单的地址认为我的信息很有趣，并有机会利用它不再使用的访问权限做一些事情。在我这边，我有幸发布了一条厚脸皮的信息，并为一个我一直想成为其中一员的团体做出了贡献。<br> 这是一个非常激动人心的成就。我们相信，它可以为proof-gated应用程序开辟另一个设计空间。<br> 首先，由于递归性允许选择性的输入公开，dapps制造商可以根据公开信号的公开来设计不同的访问策略。这将导致不同的证明可能具有不同的值，遵循它们提供的访问类型。<br> 例如，在heyanoun上，“匿名访问”证明的购买者可以使用通用的“假名”发布消息。但也有可能购买稍微贵一点的“冒充”证明，从而可以用一个随着时间的推移而积累声誉的“假名”发布消息，在社区中具有更大的影响力和影响力。<br> 对于能够访问此类应用程序的NFT持有者来说，这也是令人兴奋的。他们现在可以不信任地从他们的NFT中提取价值，这与围绕他们资产的投机动态不同。围绕其公用事业的市场可能会在NFT社区内形成动态生态系统。结合PCD钱包，可以设想一套全新的应用程序和用户体验。<br> 在链上游戏的背景下，出售证明而不是输入证明可以被视为设计“作弊代码”的一种方式。在<a href="https://zkga.me/">darkforest</a>，<a href="https://nightmart.xyz/">Nightmarket</a>的设置是出售行星坐标。但如果proof被出售，proof买家可能会让其他玩家相信他正在探索某个特定区域，四处传播虚假信息。他还可以让其他玩家或nft兑换服务机构相信他赢得了一轮比赛或进入了排行榜前5名。<br> 我们很高兴听到您对如何使用此设置的想法。实现这一点的一个途径是开发一个递归电路库，该库适用于之前（或未）引用的每个dapp。</p> 
<p>我们在这里详细介绍了如何可靠地销售groth16 proof。通过利用递归，我们可以私下出售groth16 proof，然后买家可以使用该proof访问相应的proof-gated服务。</p> 
<h2>
<a id="61_Placing_an_ask_for_a_groth16_proof_353"></a>6.1 Placing an ask for a groth16 proof</h2> 
<p><a href="https://nouns.nymz.xyz/">heyanoun</a> app中一样的groth16 proof为例。</p> 
<p>为访问这些服务，用户需提供 a proof that he knows a valid signature <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
      
        s 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em"></span><span class="mord mathnormal">s</span></span></span></span></span> over a message <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
      
        m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em"></span><span class="mord mathnormal">m</span></span></span></span></span> emanating from a public key <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
        
        
          k 
         
        
          i 
         
        
       
      
        pk_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em;vertical-align: -0.1944em"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em"><span class="" style="margin-left: -0.0315em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span> stored in a tree <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         t 
        
       
      
        t 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em"></span><span class="mord mathnormal">t</span></span></span></span></span> with root <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
      
        r 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em"></span><span class="mord mathnormal" style="margin-right: 0.0278em">r</span></span></span></span></span> and leaves <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
        
        
          k 
         
        
          0 
         
        
       
         , 
        
       
         ⋯ 
         
       
         , 
        
       
         p 
        
        
        
          k 
         
        
          i 
         
        
       
         , 
        
       
         ⋯ 
         
       
         , 
        
       
         p 
        
        
        
          k 
         
        
          n 
         
        
       
      
        pk_0,cdots,pk_i,cdots,pk_n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em;vertical-align: -0.1944em"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em"><span class="" style="margin-left: -0.0315em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em"><span class="" style="margin-left: -0.0315em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em"><span class="" style="margin-left: -0.0315em;margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em"><span class=""></span></span></span></span></span></span></span></span></span></span>。</p> 
<p>我们首先开始设想，heyanon用户可以直接将merkle路径和签名出售给感兴趣的买家。问题是，这将打破卖家的匿名性。merkle路径和签名都会向买家透露merkle树中的哪个公钥已经出售了他的访问权限。<br> 相反，我们将利用递归性。这使我们获得了选择性的隐私，只泄露我们想要的输入——消息和群根。卖方必须生成一个证明，表明他知道消息m（公共）上的有效签名s（私有）和解析为根r（公共）的merkle路径p（私有）的证明。<br> 出售proof本身不会打破卖家的匿名性，同时授予买家相同的访问级别。具体流程为：</p> 
<ul>
<li>1）seller对group root <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          r 
         
        
       
         r 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em"></span><span class="mord mathnormal" style="margin-right: 0.0278em">r</span></span></span></span></span>进行commit，声称其可访问该group，以及verification key hash <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          v 
         
        
       
         v 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em"></span><span class="mord mathnormal" style="margin-right: 0.0359em">v</span></span></span></span></span>——与proof-gated服务中的verification key关联。</li>
<li>2）在链下，buyer使用seller的公钥计算shared key，然后托管相应数量的ETH到market，提交公钥，并对其希望发送到该group的消息进行commit，来下单proof。【注意在本步骤中，若buyer使用所计算的shared key来机密message的话，则buyer和seller都将对所交易的message获得匿名性。】</li>
<li>3）seller提交上链的proof需包含： 
  <ul>
<li>assertion correctness：所售groth16 proof是正确的——为recursive part。</li>
<li>encryption correctness：该proof经正确加密</li>
<li>commitment correctness： 
    <ul>
<li>加密密钥和verification密钥的哈希正确</li>
<li>所售proof的group root和message哈希，与初始committed值对应。</li>
</ul> </li>
</ul> </li>
</ul> 
<p><img src="https://images2.imgbox.com/e4/55/kz0dTxr1_o.png" alt="在这里插入图片描述"><br> 相应的<a href="https://github.com/dmpierre/eth-private-market/blob/main/packages/circuits/circom/proof-sig-merkle/verifyAndEncryptSigMerkleProof.circom">电路</a>见：</p> 
<pre><code class="prism language-circom">/*
     This circuit:
          1. verifies a proof
          2. encrypts the proof's content
          3. hashes the verification key
          4. hashes the shared key
*/

template verifyAndEncryptSigMerkleProof(publicInputCount, l, nPoseidonHash, nHashInputs) {
     /*
          In our setup, we werify a proof of a proof of:
               1. a valid signature over a message m 
               2. a merkle path resolving to root r
     */
     var k = 6;
     var m;
     var i;
     var j;
     var encryptedProofLength = l + 1;

     // verification key
     signal input negalfa1xbeta2[6][2][k]; // private
     signal input gamma2[2][2][k]; // private
     signal input delta2[2][2][k]; // private
     signal input IC[publicInputCount+1][2][k]; // private
     signal input vkHash; // public

     // proof
     signal input negpa[2][k]; // private
     signal input pb[2][2][k]; // private
     signal input pc[2][k]; // private
     signal input pubInput[publicInputCount]; // public

     // encryption
     signal input encryptedProof[encryptedProofLength]; // public
     signal input poseidonNonce; // public
     signal input sharedKey[2]; // private
     signal input sharedKeyHash; // public

     component verify = verifyProof(publicInputCount);
     component encrypt = EncryptGroth16Proof(l);
     component hash = HashGroth16Vkey(nPoseidonHash, nHashInputs);
     component poseidonSharedKey = Poseidon(2);

     var startIdxHashGamma2 = (k * 2 * k); // offset 
     var startIdxHashDelta2 = startIdxHashGamma2 + (k * 4);
     var startIdxHashIC = startIdxHashDelta2 + (k * 4);

     for (i = 0; i &lt; 2; i ++) {
          for (j = 0; j &lt; k; j++) {

               for (m = 0; m &lt; k; m++) {
                    verify.negalfa1xbeta2[m][i][j] &lt;== negalfa1xbeta2[m][i][j];

                    var idx = (m * k * 2) + (k * i) + (j);
                    hash.inputs[idx] &lt;== negalfa1xbeta2[m][i][j];

               }

               verify.negpa[i][j] &lt;== negpa[i][j];
               encrypt.negpa[i][j] &lt;== negpa[i][j];

               verify.pc[i][j] &lt;== pc[i][j];
               encrypt.pc[i][j] &lt;== pc[i][j];

               for (m = 0; m &lt; 2; m++) {

                    verify.gamma2[m][i][j] &lt;== gamma2[m][i][j];

                    var idxGamma2 = startIdxHashGamma2 + (m * k * 2) + (k * i) + (j);
                    hash.inputs[idxGamma2] &lt;== gamma2[m][i][j];

                    verify.delta2[m][i][j] &lt;== delta2[m][i][j];

                    var idxDelta2 = startIdxHashDelta2 + (m * k * 2) + (k * i) + (j);
                    hash.inputs[idxDelta2] &lt;== delta2[m][i][j];

                    verify.pb[m][i][j] &lt;== pb[m][i][j];
                    encrypt.pb[m][i][j] &lt;== pb[m][i][j];
               }

          }
     }

     for (i = 0; i &lt; publicInputCount; i++) {
          verify.pubInput[i] &lt;== pubInput[i];
          for (j = 0; j &lt; k; j++) {
               for (m = 0; m &lt; 2; m++) {
                    verify.IC[i][m][j] &lt;== IC[i][m][j];

                    var idxIC = startIdxHashIC + (i * k * 2) + (k * m) + (j);
                    hash.inputs[idxIC] &lt;== IC[i][m][j];
               }
          }
     }

     var lastStartHashIdx = startIdxHashIC + (publicInputCount * k * 2);
     for (j = 0; j &lt; k; j++) {
          // last IC input
          for (m = 0; m &lt; 2; m++) {
               verify.IC[publicInputCount][m][j] &lt;== IC[publicInputCount][m][j];

               var lastIdxIC = lastStartHashIdx + (k * m) + (j);
               hash.inputs[lastIdxIC] &lt;== IC[publicInputCount][m][j];

          }
     }

     for (i = 0; i &lt; encryptedProofLength; i++) {
          encrypt.encryptedProof[i] &lt;== encryptedProof[i];
     }

     encrypt.poseidonNonce &lt;== poseidonNonce;
     encrypt.sharedKey[0] &lt;== sharedKey[0];
     encrypt.sharedKey[1] &lt;== sharedKey[1];

     poseidonSharedKey.inputs[0] &lt;== sharedKey[0];
     poseidonSharedKey.inputs[1] &lt;== sharedKey[1];
     
     poseidonSharedKey.out === sharedKeyHash; // check shared key commitment

     hash.out === vkHash; // check vkey commitment

     verify.out === 1; // check proof
}

component main { public [ vkHash, pubInput, encryptedProof, poseidonNonce, sharedKeyHash ] } = verifyAndEncryptSigMerkleProof(5, 48, 12, 16);
</code></pre> 
<h1>
<a id="7__501"></a>7. 案例五：卖以太坊交易</h1> 
<p>还有一种设置，出售的是在以太坊上执行交易。这可以以一种有趣的方式实现隐形交易。具体流程为：</p> 
<ul>
<li>1）Alice发布ask，表明其想要执行一笔交易的意图。该交易将提供一定数量的ETH托管在market中。</li>
<li>2）Bob想要Alice将一定数量的ETH发送到其持有私钥的地址中。Bob在market中为Alice托管一定数量的ETH。Bob会计算： 
  <ul>
<li>使用Alice的公钥计算shared key</li>
<li>对shared key进行commit</li>
<li>其想要Alice执行的加密交易数据，其中包含了转账地址和数量。</li>
<li>对交易数据进行commit，可包含<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            h 
           
          
            ( 
           
          
            a 
           
          
            d 
           
          
            d 
           
          
            r 
           
          
            e 
           
          
            s 
           
          
            s 
           
          
            , 
           
          
            a 
           
          
            m 
           
          
            o 
           
          
            u 
           
          
            n 
           
          
            t 
           
          
            ) 
           
          
         
           h(address, amount) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">ress</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em"></span><span class="mord mathnormal">am</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span>
</li>
</ul> </li>
<li>3）Alice对交易数据解密。Alice将相应数量发送到特定地址。通过提供包含如下信息的proof，Alice可获得Bob给的相应托管： 
  <ul>
<li>assertion correctness：使用merkle path来对应交易trie root，Alice展示了存在与交易收据trie中的某交易收据，其满足Bob初始请求的交易参数。</li>
<li>encryption correctness：Alice使用shared key对交易收据加密。</li>
<li>commitment correctness： 
    <ul>
<li>所执行交易参数的哈希，等于之前bob提交的承诺值。</li>
<li>加密的交易收据使用了正确的shared key。</li>
</ul> </li>
</ul> </li>
</ul> 
<p>需要注意的是，Bob可以托管与他要求Alice执行的不同数量的ETH。如果他托管了更多的ETH，他将在某种程度上为执行的交易向Alice“小费”。他还将进一步将智能合约上托管的金额与Alice交易的金额脱钩。</p> 
<p>这种设置可以通过将交易收据trie的连续根存储在市场的合同上来实现。</p> 
<p>然而，由于时间和技术限制，我们在此不提供实施。除其他困难外，我们无法找到方法轻松获得证明在交易收据trie中包含交易收据的merkle路径-在geth上使用类似于eth_getProof的API。我们必须同时实现这个API和一种有效的方式来生成包含交易收据的证据——类似于<a href="https://www.axiom.xyz/">Axiom</a>对以太坊的state trie所做的。</p> 
<p>我们感到惊讶的是，以太坊的黄皮书明确提到，生成与交易收据相关的零知识证明可能很有趣。事实上，这种设置可以很容易地从证明简单事务的执行推广到更复杂的合同交互，也就是隐形交互。</p> 
<h1>
<a id="8__524"></a>8. 改进点</h1> 
<p>我们的构建承担着某角色向市场发送他知道自己无法完成的询价单的风险。有三种机制可以用来防止这种情况：通过提供proof证明买家知道解决该房产的数据来启动询问，大幅削减询问者只有提供相应proof才能取消询问的规则，并最终在市场上建立声誉协议。<br> 我们还详细介绍了买方-卖方序列，最多需要三个不同的步骤：询问、订单和填写。然而，我们不应该局限于这种特定的流动。可以想象，增加一个步骤，使买家和卖家能够私下交流和/或承诺提供一些额外的数据。</p> 
<p>除此之外，我们今天的设置仅适用于escrowing ether。然而，可以允许将NFT或ERC-20等各种资产用作托管。也可以有一个集体托管设置，买家将ETH集中在一起。例如，一个链上游戏DAO团队可以将他们的ETH集中起来购买一个昂贵的作弊代码，从而获得不公平的决定性战略优势。<br> 我们也没有讨论证明无效的问题。然而，启用此类方案的proof-gated应用程序可能需要想办法避免proof在其协议中被“双重使用”。</p> 
<p>待改进技术点：<br> groth16 proof的卖家将不得不从calldata中承担不可忽略的成本。我们没有致力于实现压缩证明表示，这可能有助于我们降低此类成本。这也指出，如果以太坊的普通日常用户采用这种设置，加密数据将发布在链上，那么这种设置将要求简洁。</p> 
<p>我们不得不得到强大的服务器来生成zkeys和proofs4。一般来说，groth16递归证明成本在今天的日常机器上运行是令人望而却步的。我们很高兴看到团队使用Nova的证明方案，正在努力实现在移动设备上递归生成证明的能力。</p> 
<h1>
<a id="_536"></a>参考资料</h1> 
<p>[1] 2023年8月PSE视频 <a href="https://www.youtube.com/watch?v=Im2OHxEhl6k">Private markets on Ethereum - 0xPARC Pierre</a><br> [2] <a href="https://www.privatemarket.dev/whatisthis">Private Market</a><br> [3] 2022年6月 Applied ZK, Devconnect AMS’22视频 <a href="https://www.youtube.com/watch?v=Fgmkjw3W1qE">ZK Data Marketplace, Applied ZK - Day 1</a></p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>