<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【计算机网络】计算机网络基础知识总结（秋招篇） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【计算机网络】计算机网络基础知识总结（秋招篇）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>文章目录</h3> 
 <ul>
<li><a href="#_6">前言</a></li>
<li><a href="#_11">计算机网络笔记</a></li>
<li>
<ul>
<li><a href="#TCPUDP__15">TCP和UDP分别是什么 有什么区别</a></li>
<li><a href="#TCP_UDP_39">基于TCP UDP这两个协议的上层协议有哪些？</a></li>
<li><a href="#TCPUDP_65">TCP和UDP分别在哪些领域被用的多？</a></li>
<li><a href="#TCPTCP_85">TCP实现可靠性传输用了哪些技术？（TCP如何实现可靠性传输）</a></li>
<li><a href="#_103">讲一下超时重传和超时定时器</a></li>
<li><a href="#_111">讲一下滑动窗口控制</a></li>
<li><a href="#_135">滑动窗口过大过小的危害</a></li>
<li><a href="#_149">滑动窗口如何实现流量控制？</a></li>
<li><a href="#TCP_161">TCP的拥塞控制技术是什么？常见的拥塞控制算法有哪些？</a></li>
<li><a href="#TCP_200">TCP的流量控制和拥塞控制的区别</a></li>
<li><a href="#TCP_210">讲一下TCP建立连接的工作原理</a></li>
<li><a href="#TCP_225">重点讲一下TCP的三次握手和四次挥手过程</a></li>
<li><a href="#TCP_284">讲一下TCP的三次握手和四次挥手的状态转移过程（有哪些状态）</a></li>
<li><a href="#MSL_TIME_WAIT2MSL_345">MSL是什么 TIME_WAIT这里为何要等待2MSL时间呢？</a></li>
<li><a href="#TCP__362">TCP建立的字节流 每一个字节都要按顺序编号是什么意思？（序列号的作用）(字节流保持有序的方法)</a></li>
<li><a href="#TCP_382">TCP中确认号是什么？有什么作用？</a></li>
<li><a href="#TCP_389">TCP报文段的首部包含什么？</a></li>
<li><a href="#FIN_ACK_SYN_409">讲一下FIN标志位 ACK标志位 SYN标志位</a></li>
<li><a href="#SACK_419">SACK是什么？</a></li>
<li><a href="#TCPkeepalive_435">TCP的keepalive是啥？</a></li>
<li><a href="#_446">心跳机制是什么意思</a></li>
<li><a href="#TCPACK_456">TCP的延迟ACK和累计应答是什么？用在什么场景</a></li>
<li><a href="#TCP_469">什么是TCP数据粘包问题？</a></li>
<li><a href="#TCP_477">TCP数据粘包问题的解决方法有？</a></li>
<li><a href="#Http_490">讲一下Http协议</a></li>
<li><a href="#Http_506">Http协议的请求方法有哪些？</a></li>
<li><a href="#Http_527">Http协议常见的状态码有哪些？</a></li>
<li><a href="#Get_567">讲一下Get请求方式的过程</a></li>
<li><a href="#Get___581">讲一下Get请求消息的组成部分 以及响应消息的组成部分</a></li>
<li><a href="#ContentType_677">Content-Type有哪些</a></li>
<li><a href="#Post_694">讲一下Post请求方式的过程</a></li>
<li><a href="#Post___711">讲一下Post请求消息的组成部分 以及响应消息的组成部分</a></li>
<li><a href="#GETPOST_755">GET和POST请求方式的区别是？</a></li>
<li><a href="#URL_768">URL是什么，它的的组成部分是？</a></li>
<li><a href="#GetPostURL_803">Get方式和Post方式的URL有何不同？</a></li>
<li><a href="#HTTPHTTPS_829">HTTP和HTTPS的区别</a></li>
<li><a href="#_NAT_NAT_848">讲一下 NAT技术产生的原因 NAT提供的技术是啥</a></li>
<li><a href="#IP_862">什么是动态IP地址？</a></li>
<li><a href="#_873">端口转换和端口映射有啥区别？</a></li>
<li><a href="#DHCP_911">DHCP服务器和网关分别是什么</a></li>
<li><a href="#19216801_932">网络中的出口点是什么？192.168.0.1是不是出口点</a></li>
</ul> 
 </li>
</ul> 
</div> 
<p></p> 
<hr> 
<h1>
<a id="_6"></a>前言</h1> 
<p>秋招笔记汇总篇之<strong>计算机网络</strong><br> 笔者是拿chatgpt写的，所以可能部分答案存在一定出路（3.5版本GPT有些缺陷），大部分答案我是写完了之后校正过一遍，有出入的地方还望各位同学指出。<br> <strong>参考教材：计算机网络 第7版</strong><br> 2023.7.25 首次更新</p> 
<h1>
<a id="_11"></a>计算机网络笔记</h1> 
<p>这篇笔记重点研究了TCP和HTTP协议</p> 
<h2>
<a id="TCPUDP__15"></a>TCP和UDP分别是什么 有什么区别</h2> 
<p><img src="https://images2.imgbox.com/9b/79/JWqwViu7_o.png" alt="在这里插入图片描述"></p> 
<p>TCP（传输控制协议）和UDP（用户数据报协议）是在计算机网络中常用的两种<strong>传输层</strong>协议。</p> 
<p>TCP是一面向连接的协议，它提供可靠的数据传输。它通过使用序列号、确认号、重传机制、拥塞控制等技术来确保数据的可靠传输。TCP建立连接、传输数据、保证数据的顺序和完整性，并在传输完成后释放连接。TCP适用于对数据传输的可靠性要求较高的应用，如文件传输、电子邮件、网页浏览等。</p> 
<p>UDP是一种无连接的协议，它提供不可靠的数据传输。UDP将数据封装成数据报，每个数据报都是独立的，没有先后顺序，也没有确认和重传机制。UDP不需要建立连接，直接发送数据。UDP适用于对实时性要求较高、数据可靠性要求相对较低的应用，如实时音视频传输、在线游戏等。</p> 
<p><strong>区别：</strong></p> 
<ol>
<li>连接性：TCP是面向连接的协议，UDP是无连接的协议。TCP在通信之前需要建立连接，而UDP直接发送数据。</li>
<li>可靠性：TCP提供可靠的数据传输，UDP不提供可靠性保证。TCP使用确认和重传机制来确保数据的完整性和可靠性，而UDP不提供这些机制。</li>
<li>顺序性：TCP保证数据的顺序传输，UDP不保证数据的顺序。TCP会对数据包进行排序，以确保数据按照发送的顺序接收，而UDP不会对数据包进行排序。</li>
<li>拥塞控制：TCP具有拥塞控制机制，可以根据网络状况调整数据传输速率，以避免网络拥塞。UDP没有拥塞控制机制，数据包的传输速率由应用程序决定。</li>
<li>传输效率：UDP具有较低的传输开销和较高的传输效率，而TCP的传输开销较大。TCP需要建立连接、维护状态信息和进行错误检测，这些额外的开销会导致传输效率较低。</li>
<li>应用场景：TCP适用于对数据传输的可靠性要求较高的应用，如文件传输、电子邮件、网页浏览等。UDP适用于对实时性要求较高、数据可靠性要求相对较低的应用，如实时音视频传输、在线游戏等。</li>
<li>大小限制：TCP没有固定的数据包大小限制，可以根据网络条件和应用需求进行调整。UDP的数据包大小受限于网络的最大传输单元（MTU），通常为1500字节。</li>
<li>连接数量：TCP可以支持一对一、一对多和多对一的连接，而UDP通常用于一对一或一对多的简单通信。</li>
</ol> 
<p>需要根据具体的应用需求来选择使用TCP还是UDP。如果数据传输的可靠性和顺序性很重要，可以选择TCP。如果实时性和传输效率更重要，可以选择UDP。</p> 
<h2>
<a id="TCP_UDP_39"></a>基于TCP UDP这两个协议的上层协议有哪些？</h2> 
<p>基于TCP协议的上层协议有：</p> 
<ol>
<li>HTTP（超文本传输协议）：用于在Web浏览器和Web服务器之间传输超文本数据，是Web应用最常用的协议。</li>
<li>FTP（文件传输协议）：用于在客户端和服务器之间传输文件。</li>
<li>SMTP（简单邮件传输协议）：用于在邮件客户端和邮件服务器之间传输电子邮件。</li>
<li>POP3（邮局协议版本3）：用于从邮件服务器上接收电子邮件。</li>
<li>IMAP（Internet邮件访问协议）：用于在邮件客户端和邮件服务器之间管理电子邮件。</li>
</ol> 
<p>基于UDP协议的上层协议有：</p> 
<ol>
<li> <p>DNS（域名系统）：用于将域名解析为IP地址，使得计算机能够通过域名访问互联网资源。</p> </li>
<li> <p>DHCP（动态主机配置协议）：用于自动分配IP地址和其他网络配置信息给计算机。</p> </li>
<li> <p>TFTP（简单文件传输协议）：用于在客户端和服务器之间传输文件，类似于FTP但更简单。</p> </li>
<li> <p>SNMP（简单网络管理协议）：用于网络设备之间的管理和监控。</p> </li>
<li> <p>RTP（实时传输协议）：用于在实时应用中传输音频和视频数据。</p> </li>
</ol> 
<h2>
<a id="TCPUDP_65"></a>TCP和UDP分别在哪些领域被用的多？</h2> 
<p>TCP的应用领域：</p> 
<ol>
<li>网页浏览：TCP被广泛用于传输HTTP协议的数据，确保网页内容的可靠传输。</li>
<li>文件传输：TCP的可靠性和顺序性使其成为FTP和SFTP等文件传输协议的首选。</li>
<li>电子邮件：TCP的可靠性和连接性使其成为SMTP和POP3等电子邮件协议的基础。</li>
<li>远程登录：TCP被用于SSH（Secure Shell）等远程登录协议，确保远程终端的可靠连接。</li>
<li>数据库访问：TCP被用于数据库访问协议，如MySQL、PostgreSQL等，以确保数据的可靠传输。</li>
</ol> 
<p>UDP的应用领域：</p> 
<ol>
<li>实时音视频传输：UDP的低延迟和较高的传输效率使其成为实时音视频传输的首选协议，如VoIP（语音IP）和视频会议。</li>
<li>在线游戏：UDP被广泛用于在线游戏，因为它能够提供较低的延迟和更快的传输速度，适合实时性要求高的游戏场景。</li>
<li>实时数据传输：UDP适用于需要快速传输实时数据的应用，如传感器数据、股票行情等。</li>
<li>DNS解析：UDP被用于域名系统（DNS）的解析过程，以快速地将域名解析为IP地址。</li>
<li>广播和组播：UDP支持广播和组播功能，使其适用于多点通信和流媒体传输。</li>
</ol> 
<h2>
<a id="TCPTCP_85"></a>TCP实现可靠性传输用了哪些技术？（TCP如何实现可靠性传输）</h2> 
<p>TCP实现可靠性的一些主要技术：</p> 
<ol>
<li> <p>序列号与确认机制：TCP将数据分割成小的数据块，并为每个数据块分配一个唯一的序列号。接收方通过发送确认报文段来确认已经接收到的数据。发送方根据接收到的确认报文段来确定哪些数据已经被接收，哪些数据需要进行重传。</p> </li>
<li> <p>超时重传：如果发送方在指定的时间内没有收到确认报文段，它会假设数据丢失，并重新发送这些数据。超时时间会根据网络状况和拥塞程度进行动态调整。</p> </li>
<li> <p>滑动窗口：TCP使用滑动窗口机制来控制发送方发送数据的速率。滑动窗口大小取决于接收方的可用缓冲区大小和网络的拥塞程度。发送方只能发送在滑动窗口范围内的数据，接收方通过确认报文段来更新滑动窗口的位置。</p> </li>
<li> <p>拥塞控制：TCP通过拥塞控制算法来避免网络拥塞。它通过动态调整发送速率，监测网络的拥塞情况，并根据网络的反馈进行相应的调整。</p> </li>
<li> <p>重排序和重组：TCP能够处理网络中报文段的乱序和重组。它会根据序列号对接收到的报文段进行排序和重组，以确保数据的正确性。</p> </li>
<li> <p>奇偶校验和校验：TCP在传输数据时，会计算校验和，并将校验和附加到数据报文段中。接收方在接收数据时，会重新计算校验和，并与报文段中的校验和进行比较，以检测数据是否出现错误或损坏。</p> </li>
</ol> 
<h2>
<a id="_103"></a>讲一下超时重传和超时定时器</h2> 
<p>超时重传和超时定时器是TCP协议中用于实现可靠数据传输的两个重要机制。</p> 
<p>超时重传是指当发送方发送数据后，如果在一定时间内没有接收到确认（ACK）信息，就会认为数据丢失，触发超时重传机制。发送方会重新发送未收到确认的数据，以确保数据的可靠传输。超时重传的时间通常由超时定时器来控制。</p> 
<p>超时定时器是发送方用来计时的定时器。当发送方发送数据时，会启动一个超时定时器，并设置一个超时时间。如果在超时时间内没有收到确认信息，超时定时器会触发，发送方会认为数据丢失，触发超时重传机制。超时定时器的时间通常由拥塞控制算法来动态调整，以适应不同的网络环境。（如果网络拥塞较为严重，发送方会将超时定时器的时间设置得较短，以便更快地检测到丢包并触发超时重传机制。相反，如果网络拥塞程度较低，发送方会将超时定时器的时间设置得较长，以避免不必要的重传。）</p> 
<h2>
<a id="_111"></a>讲一下滑动窗口控制</h2> 
<p>滑动窗口控制是一种基于窗口的流量控制机制，用于实现可靠的数据传输。它通过发送方和接收方之间的窗口来控制数据的传输。</p> 
<p>滑动窗口控制的原理如下：</p> 
<ol>
<li>发送窗口：发送方维护一个发送窗口，它表示发送方可以发送的数据段的范围。发送窗口的大小取决于网络的带宽和延迟，并且可以根据网络的状况进行动态调整。</li>
<li>接收窗口：接收方维护一个接收窗口，它表示接收方可以接收的数据段的范围。接收窗口的大小取决于接收方的处理能力和缓冲区大小。</li>
<li>窗口滑动：发送方在发送数据时，将数据分成多个数据段，并将它们依次发送到接收方。发送方会等待接收方发送确认信息，确认已经成功接收的数据。一旦接收方确认接收到某个数据段，发送方就可以将发送窗口向前滑动，允许发送更多的数据。</li>
<li>确认和重传：接收方在接收到数据段后，会发送确认信息给发送方。如果发送方在一定时间内没有收到确认信息，就会认为该数据段丢失，并进行重传。发送方可以选择性地重传丢失的数据段，而不需要重传整个数据流。</li>
</ol> 
<p>滑动窗口控制的工作流程如下：</p> 
<ol>
<li>发送方将数据分割成多个数据段，并按照窗口大小依次发送。</li>
<li>接收方接收到数据段后，将其存储在接收缓冲区中，并发送确认信息给发送方。</li>
<li>发送方收到确认信息后，将发送窗口向前滑动，允许发送更多的数据。</li>
<li>如果发送方在一定时间内没有收到确认信息，就会认为该数据段丢失，并进行重传。</li>
</ol> 
<p>通过滑动窗口控制，发送方和接收方可以根据窗口的大小和滑动的速度来控制数据的传输。这种机制可以提高数据传输的效率和可靠性，同时适应不同的网络环境和条件。</p> 
<p>总结起来，滑动窗口控制通过发送窗口和接收窗口来控制数据的传输。发送方根据接收方的确认信息来滑动窗口，允许发送更多的数据。接收方根据接收窗口的大小来确认已经成功接收的数据，并发送确认信息给发送方。通过这种机制，滑动窗口控制可以提高数据传输的效率和可靠性。</p> 
<h2>
<a id="_135"></a>滑动窗口过大过小的危害</h2> 
<p>滑动窗口过大或过小都会对数据传输的效率和可靠性产生不利影响。</p> 
<ol>
<li>滑动窗口过大： 
  <ul>
<li>带宽浪费：如果滑动窗口过大，发送方会连续发送大量的数据段，而接收方可能无法及时处理和确认这些数据段。这会导致接收方的缓冲区溢出，造成数据丢失，从而浪费了网络带宽。</li>
<li>拥塞加剧：滑动窗口过大会导致网络拥塞的加剧。当发送方连续发送大量的数据段时，网络可能会出现拥塞，导致延迟增加和丢包率上升。这会降低整体的传输效率和可靠性。</li>
</ul> </li>
<li>滑动窗口过小： 
  <ul>
<li>传输效率低：如果滑动窗口过小，发送方每次只能发送少量的数据段，而且需要等待接收方发送确认信息后才能发送下一批数据。这会导致发送方无法充分利用网络带宽，降低数据传输的效率。</li>
<li>延迟增加：滑动窗口过小会增加数据传输的延迟。发送方需要等待接收方的确认信息，这会导致发送方的等待时间增加，从而延长了数据的传输时间。</li>
</ul> </li>
</ol> 
<p>因此，滑动窗口的大小需要根据网络的带宽、延迟和拥塞情况进行合理的设置。如果窗口过大，可能会导致带宽浪费和拥塞加剧；如果窗口过小，可能会导致传输效率低和延迟增加。通过合适的窗口大小，可以实现高效和可靠的数据传输。</p> 
<h2>
<a id="_149"></a>滑动窗口如何实现流量控制？</h2> 
<p>下面是滑动窗口实现流量控制的基本原理：</p> 
<ol>
<li>发送方维护发送窗口的大小：发送方通过维护一个发送窗口来控制发送的数据量。发送窗口的大小取决于网络的带宽和延迟，并且可以根据网络的状况进行动态调整。</li>
<li>接收方维护接收窗口的大小：接收方通过维护一个接收窗口来控制自己的处理能力和缓冲区大小。接收窗口的大小表示接收方当前可以接收的数据量。</li>
<li>发送方根据接收方的接收窗口大小发送数据：发送方根据接收方的接收窗口大小来确定可以发送的数据量。发送方只能发送发送窗口内的数据，而不能超过接收窗口的大小。</li>
<li>接收方发送窗口大小的信息给发送方：接收方会将自己的接收窗口大小信息包含在确认信息中发送给发送方。这样，发送方可以根据接收方的接收窗口大小来调整自己的发送窗口大小。</li>
<li>动态调整发送窗口的大小：发送方根据接收方发送的接收窗口大小信息来动态调整自己的发送窗口大小。如果接收方的接收窗口变大，发送方可以发送更多的数据；如果接收方的接收窗口变小，发送方需要减少发送的数据量。</li>
</ol> 
<p>通过这种方式，滑动窗口机制实现了流量控制，确保发送方和接收方之间的数据传输速率适应网络的状况。发送方会根据接收方的接收窗口大小来控制发送的数据量，避免发送过多的数据导致接收方无法及时处理，从而提高数据传输的效率和可靠性。</p> 
<h2>
<a id="TCP_161"></a>TCP的拥塞控制技术是什么？常见的拥塞控制算法有哪些？</h2> 
<p><img src="https://images2.imgbox.com/d8/9a/LVjd8TL0_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dO7etMCJ-1690270230621)(C:Users93701AppDataRoamingTyporatypora-user-imagesimage-20230723144208996.png)]"></p> 
<p>拥塞控制是一种网络流量管理机制，用于在计算机网络中避免或减少网络拥塞的发生。当网络中的数据流量超过网络链路、交换机或路由器的处理能力时，就会发生拥塞，导致网络性能下降、延迟增加甚至数据丢失。</p> 
<p>拥塞控制的目标是通过限制发送方的数据传输速率或调整网络资源的分配，以确保网络中的流量不会超过网络的容量，从而维持网络的稳定性和可靠性。</p> 
<p><strong>拥塞窗口</strong>（Congestion Window）是在TCP协议中用于控制发送方发送数据量的一种机制。它是为了避免网络拥塞而引入的一种流量控制机制。</p> 
<p>拥塞窗口的大小表示发送方可以发送的数据量。初始时，拥塞窗口的大小比较小，发送方只能发送少量的数据。随着网络的正常运行和数据包的成功传输，拥塞窗口会逐渐增大，发送方可以发送更多的数据。</p> 
<p>TCP使用的拥塞控制技术主要包括<strong>慢启动、拥塞避免、快速重传和快速恢复</strong>。</p> 
<ol>
<li> <p>慢启动（Slow Start）：在TCP连接刚建立时，发送方将初始的拥塞窗口设置为一个较小的值，然后每经过一个往返时间（RTT）就将拥塞窗口大小加倍，以逐渐增加发送方的发送速率，直到达到网络的拥塞点或拥塞窗口的最大值。（由小到大增大发送窗口，不断试探）</p> </li>
<li> <p>拥塞避免（Congestion Avoidance）：在慢启动阶段结束后，发送方将进入拥塞避免阶段。在该阶段，发送方每经过一个RTT只增加一个拥塞窗口的大小，以缓慢增加发送速率，以避免过多的数据流量进入网络。（而不是慢启动的那种加倍增长，属于是线性规律增长，“加法增大”）</p> </li>
<li> <p>快速重传（Fast Retransmit）：当发送方连续收到三个重复的确认（ACK）时，它会认为某个数据包丢失，<strong>而不是网络拥塞造成的</strong>。发送方会立即重传丢失的数据包，而不必等待超时定时器的触发。（快重传可以使整个网络吞吐量提高20%左右）</p> </li>
<li> <p>快速恢复（Fast Recovery）：在快速重传后，发送方将进入快速恢复阶段。在该阶段，发送方将拥塞窗口减半，并将拥塞窗口的大小设置为丢失数据包之前的一半。然后，发送方继续以拥塞避免算法逐渐增加拥塞窗口的大小。</p> </li>
</ol> 
<p><strong>常见的拥塞控制算法</strong>包括：</p> 
<ul>
<li> <p>Tahoe算法：最早的TCP拥塞控制算法，只有慢启动和拥塞避免阶段。</p> </li>
<li> <p>Reno算法：在Tahoe算法的基础上添加了快速恢复和快速重传机制。</p> </li>
<li> <p>New Reno算法：对Reno算法进行了改进，增加了更灵活的快速恢复和快速重传机制。</p> </li>
<li> <p>Cubic算法：基于拥塞窗口的平方函数，具有更好的网络适应性和公平性。</p> </li>
<li> <p>BBR算法：基于带宽和往返时间的估计，能够更准确地调整发送速率，提高网络吞吐量。</p> </li>
</ul> 
<h2>
<a id="TCP_200"></a>TCP的流量控制和拥塞控制的区别</h2> 
<p>TCP的流量控制和拥塞控制是TCP协议中两个不同的机制，它们的目标和实现方式也有所不同。</p> 
<p>流量控制是为了确保接收方能够处理来自发送方的数据，防止发送方发送过多的数据导致接收方无法及时处理。流量控制是在发送方和接收方之间进行的，通过接收方向发送方发送窗口大小的信息，告诉发送方它还有多少可用的接收缓冲区空间。发送方根据接收方的窗口大小来控制发送数据的速率，以保证接收方能够及时处理数据。</p> 
<p>拥塞控制是为了避免网络拥塞而引入的一种机制。拥塞控制是在网络中进行的，通过监测网络的拥塞程度和接收方的反馈信息来调整发送方的发送速率。当网络拥塞时，拥塞控制会降低发送方的发送速率，以减少对网络的负载，防止拥塞进一步加重。拥塞控制算法会根据网络的拥塞情况动态地调整发送方的拥塞窗口大小，以实现合理的流量控制。</p> 
<p>总结起来，流量控制是为了确保接收方能够处理数据而进行的控制，而拥塞控制是为了避免网络拥塞而进行的控制。流量控制是在发送方和接收方之间进行的，而拥塞控制是在网络中进行的。两者都是为了保证数据的可靠传输和网络性能的优化，但是它们的目标和实现方式有所不同。</p> 
<h2>
<a id="TCP_210"></a>讲一下TCP建立连接的工作原理</h2> 
<p>TCP（Transmission Control Protocol）是一种面向连接的可靠的传输层协议，它在网络通信中扮演着重要的角色。下面是TCP的工作原理的简要介绍：</p> 
<ol>
<li>建立连接：在进行TCP通信之前，客户端和服务器需要通过三次握手建立连接。首先，客户端发送一个SYN（同步）报文给服务器，服务器收到后回复一个SYN+ACK（同步+确认）报文给客户端，最后，客户端再回复一个ACK（确认）报文给服务器。这样，连接就建立起来了。<strong>（三次握手）</strong>
</li>
<li>数据传输：一旦连接建立，客户端和服务器就可以开始传输数据。TCP使用滑动窗口机制来进行流量控制和拥塞控制。发送方将数据切分成称为TCP段的小块，并将它们发送给接收方。接收方会确认已经收到的数据，并且发送方可以根据接收方的确认信息调整发送速率。</li>
<li>确认和重传：接收方收到数据后会发送确认消息给发送方，表示已经成功接收。如果发送方在一定时间内没有收到确认消息，就会认为数据丢失，会进行重传。接收方可以通过序列号来检查是否有丢失的数据段，并将其丢弃，以避免重复处理。</li>
<li>关闭连接：当数据传输完成或者需要终止连接时，可以通过四次握手来关闭连接。首先，一方发送一个FIN（结束）报文给另一方，另一方收到后回复一个ACK报文表示确认。然后，另一方发送一个FIN报文给第一方，第一方收到后回复一个ACK报文表示确认。最后，连接就关闭了。<strong>（四次挥手）</strong>
</li>
</ol> 
<p>TCP的工作原理保证了数据的可靠传输和顺序性，同时还具备流量控制和拥塞控制的机制，以适应不同网络环境下的传输需求。这使得TCP成为了互联网上应用最广泛的传输协议之一。</p> 
<h2>
<a id="TCP_225"></a>重点讲一下TCP的三次握手和四次挥手过程</h2> 
<p>当建立TCP连接时，需要进行三次握手；而在关闭连接时，需要进行四次挥手。下面我会重点讲解一下TCP的三次握手和四次挥手过程。</p> 
<ol>
<li> <p>三次握手（Three-way Handshake）：</p> <p>a. 第一步：客户端向服务器发送一个S<strong>YN（同步）报文，其中包含一个初始的序列号（seq）</strong>。这个SYN报文相当于客户端发起连接请求的信号，表示客户端希望与服务器建立连接。</p> <p>b. 第二步：服务器接收到SYN报文后，会回复一个SYN+ACK（同步+确认）报文，其中包含确认号（ack）和服务器的初始序列号（seq）。</p> <p>c. 第三步：客户端收到服务器的SYN+ACK报文后，会发送一个ACK（确认）报文，其中包含确认号（ack），表示连接已经建立。</p> <p>这样，通过三次握手，客户端和服务器都确认了对方的收发能力和初始序列号，建立了双向的可靠连接。</p> </li>
<li> <p>四次挥手（Four-way Handshake）： a. 第一步：当客户端要关闭连接时，会发送一个FIN（结束）报文给服务器。 b. 第二步：服务器收到FIN报文后，会发送一个ACK报文作为确认。 c. 第三步：服务器发送一个FIN报文给客户端，表示服务器也要关闭连接。 d. 第四步：客户端收到服务器的FIN报文后，发送一个ACK报文作为确认。</p> <p>这样，通过四次挥手，双方都确认了对方的关闭意图，并完成了连接的关闭过程。</p> </li>
</ol> 
<p>在三次握手和四次挥手过程中，每一步都需要双方发送和接收确认信息，以确保连接的可靠性和顺序性。这些过程中的报文和确认号的交换是为了确保双方能够正确理解对方的状态和意图，以保证连接的建立和关闭是可靠的。（下面的两张图图很重要，里面状态也重要）</p> 
<p><img src="https://images2.imgbox.com/8f/b4/LXHZN22b_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z1iG7e2e-1690270230621)(C:Users93701AppDataRoamingTyporatypora-user-imagesimage-20230723112552073.png)]"></p> 
<p>小写的ack是序列号，大写的ACK是标志位。</p> 
<p>SYN=1表示一个同步序列号（SYN）的标志被设置为1。</p> 
<p>图中握手的过程通常如下：</p> 
<ol>
<li> <p>客户端发送一个TCP数据包到服务器，并将SYN标志设置为1，而ACK（确认）标志设置为0。同时，客户端生成一个随机序列号，例如x。</p> </li>
<li> <p>服务器接收到SYN=1的数据包后，会向客户端回应一个数据包，其中SYN和ACK标志都被设置为1。服务器也生成一个随机序列号，例如y，并且将确认号设为x+1。</p> </li>
<li> <p>客户端接收到服务器的SYN=1和ACK=1的数据包后，再发送一个确认数据包给服务器，其中SYN标志为0，ACK标志为1，并将确认号设为y+1。序列号应该还是x+1（在第二次握手时，服务器的确认号是x+1，表明它期待接收的下一个字节的序列号为x+1）</p> 
  <hr> </li>
</ol> 
<p><img src="https://images2.imgbox.com/64/f3/Kvx5Dir7_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-baVz2K76-1690270230621)(C:Users93701AppDataRoamingTyporatypora-user-imagesimage-20230723121127429.png)]"></p> 
<p>四次挥手是指在TCP连接关闭时，双方通信结束的过程。下面是四次挥手的过程及相关字段的变化：</p> 
<ol>
<li>第一次挥手： 
  <ul>
<li>主动关闭方（Client）发送一个带有FIN标志位设置为1的报文段给被动关闭方（Server）。FIN=1</li>
<li>报文段中的序列号（sequence number）表示主动关闭方发送的最后一个字节的序列号。seq=u</li>
</ul> </li>
<li>第二次挥手： 
  <ul>
<li>被动关闭方收到第一次挥手的报文段后，发送一个带有ACK标志位设置为1的报文段给主动关闭方，表示已经收到了关闭请求。ACK=1</li>
<li>报文段中的确认号（acknowledgment number）表示被动关闭方期望收到的下一个字节的序列号。ack=u+1,seq=v</li>
</ul> </li>
<li>第三次挥手： 
  <ul>
<li>被动关闭方发送一个带有FIN标志位设置为1的报文段给主动关闭方，表示自己也准备关闭连接。FIN=1,ACK=1 ack=u+1</li>
<li>报文段中的序列号表示被动关闭方发送的最后一个字节的序列号。seq=w(<strong>之所以和第二部seq=v不一样，是因为服务器端可能一直在发数据，只是客户端那边停止发数据了</strong>)</li>
</ul> </li>
<li>第四次挥手： 
  <ul>
<li>主动关闭方收到第三次挥手的报文段后，发送一个带有ACK标志位设置为1的报文段给被动关闭方，表示已经收到了关闭请求。ACK =1</li>
<li>报文段中的确认号表示主动关闭方期望收到的下一个字节的序列号。ack=w+1,seq=u+1</li>
</ul> </li>
</ol> 
<h2>
<a id="TCP_284"></a>讲一下TCP的三次握手和四次挥手的状态转移过程（有哪些状态）</h2> 
<p>三次握手过程：（具体可以参考下图）</p> 
<p><img src="https://images2.imgbox.com/fb/b9/ryqz85Ah_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uMoc55wm-1690270230622)(C:Users93701AppDataRoamingTyporatypora-user-imagesimage-20230723112552073.png)]"></p> 
<ol>
<li> <p>初始状态：Client端处于CLOSED状态，Server端处于LISTEN状态。</p> </li>
<li> <p>第一次握手：Client发送一个SYN标志位为1的报文段给Server，同时选择一个初始的序列号（ISN）。</p> 
  <ul><li>Client状态变为SYN_SENT，等待Server的确认。</li></ul> </li>
<li> <p>第二次握手：Server收到Client的SYN报文段后，发送一个ACK标志位为1的报文段给Client，同时也发送一个SYN标志位为1的报文段给Client，确认收到Client的SYN，并选择一个自己的初始序列号。</p> 
  <ul><li>Server状态变为SYN_RCVD。</li></ul> </li>
<li> <p>第三次握手：Client收到Server的SYN/ACK报文段后，发送一个ACK标志位为1的报文段给Server，确认收到Server的SYN/ACK。</p> 
  <ul><li>Client状态变为ESTABLISHED。</li></ul> </li>
<li> <p>Server收到Client的ACK报文段后，也进入ESTABLISHED状态。</p> 
  <ul><li>Server状态变为ESTABLISHED。</li></ul> </li>
</ol> 
<p>四次挥手过程：（具体可以参考下图）</p> 
<p><img src="https://images2.imgbox.com/d3/07/3A4ezadb_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CaRvbyiU-1690270230622)(C:Users93701AppDataRoamingTyporatypora-user-imagesimage-20230723121127429.png)]"></p> 
<ol>
<li>初始状态：Client和Server都处于ESTABLISHED状态。</li>
<li>第一次挥手：Client发送一个FIN标志位为1的报文段给Server，表示自己已经没有数据要发送了，但仍然可以接收数据。 
  <ul><li>Client状态变为FIN_WAIT_1。</li></ul> </li>
<li>第二次挥手：Server收到Client的FIN报文段后，发送一个ACK标志位为1的报文段给Client，确认收到Client的FIN。 
  <ul><li>Server状态变为CLOSE_WAIT，Client状态变为FIN_WAIT_2。</li></ul> </li>
<li>第三次挥手：Server发送一个FIN标志位为1的报文段给Client，表示自己也没有数据要发送了。 
  <ul><li>Server状态变为LAST_ACK。</li></ul> </li>
<li>第四次挥手：Client收到Server的FIN报文段后，发送一个ACK标志位为1的报文段给Server，确认收到Server的FIN。 
  <ul><li>Client状态变为TIME_WAIT，等待2倍的最长报文段寿命（MSL）后进入CLOSED状态。</li></ul> </li>
<li>Server收到Client的ACK报文段后，也进入CLOSED状态。 
  <ul><li>Server状态变为CLOSED。</li></ul> </li>
</ol> 
<p><strong>涉及到TCP连接的状态时，有以下一些常见的状态：</strong></p> 
<ol>
<li>CLOSED（关闭）：初始状态或连接已经关闭的状态。在该状态下，TCP连接未建立或已经关闭。</li>
<li>LISTEN（监听）：服务器等待客户端连接的状态。在该状态下，服务器正在监听指定的端口，准备接受客户端的连接请求。</li>
<li>SYN_SENT（同步已发送）：客户端发送了SYN报文段后等待服务器的确认的状态。在该状态下，客户端已经发送了连接请求，并等待服务器的响应。</li>
<li>SYN_RECEIVED（同步已接收）：服务器收到客户端的SYN报文段后发送了自己的SYN报文段的状态。在该状态下，服务器已经收到了客户端的连接请求，并发送了自己的连接确认。</li>
<li>ESTABLISHED（已建立）：连接已经建立，双方可以进行数据传输的状态。在该状态下，客户端和服务器之间的连接已成功建立，可以进行数据的传输。</li>
<li>FIN_WAIT_1（终止等待1）：客户端发送了FIN报文段后等待服务器的确认的状态。在该状态下，客户端已经发送了连接终止请求，并等待服务器的确认。</li>
<li>CLOSE_WAIT（关闭等待）：服务器收到客户端的FIN报文段后等待关闭连接的状态。在该状态下，服务器已经收到了客户端的连接终止请求，并等待关闭连接。</li>
<li>FIN_WAIT_2（终止等待2）：客户端等待服务器发送FIN报文段的状态。在该状态下，客户端已经收到了服务器的连接终止请求，并等待服务器发送自己的连接终止请求。</li>
<li>LAST_ACK（最后确认）：服务器发送了FIN报文段后等待客户端的确认的状态。在该状态下，服务器已经发送了连接终止请求，并等待客户端的确认。</li>
<li>TIME_WAIT（时间等待）：连接已经关闭，等待一段时间后进入CLOSED状态的状态。在该状态下，客户端等待一段时间，以确保所有的报文段都已经被接收，然后才进入CLOSED状态。</li>
</ol> 
<h2>
<a id="MSL_TIME_WAIT2MSL_345"></a>MSL是什么 TIME_WAIT这里为何要等待2MSL时间呢？</h2> 
<p>MSL（Maximum Segment Lifetime）是指TCP协议中的最长报文段寿命。<strong>它表示一个TCP报文段在网络中的最大存活时间。</strong></p> 
<p>在TCP协议中，每个报文段都会被分割成多个较小的数据包进行传输。这些数据包在网络中通过各种网络设备和链路进行传递。由于网络中可能存在延迟、拥塞、路由器故障等因素，报文段的传输可能会遇到一些问题，比如丢失、重复或失序。为了确保报文段能够在网络中正常传输并被正确接收，TCP协议规定了一个最长报文段寿命（MSL）的概念。MSL表示一个报文段在网络中的最大存活时间，超过这个时间后，报文段将被丢弃。MSL的具体值是根据网络的特性和配置来确定的，通常在几分钟到几十分钟之间。TCP协议中的等待2MSL时间就是为了确保在此期间内所有延迟的报文段都被丢弃，并避免对后续连接的干扰。</p> 
<p><strong>为啥等待2MSL时间？</strong></p> 
<p>选择等待2倍MSL的时间有几个原因：</p> 
<ol>
<li>
<strong>确保网络中的所有延迟报文段都被丢弃：等待2倍MSL的时间可以更加保守地确保网络中的所有延迟报文段都已经消失。这样可以避免任何可能的混乱和错误。</strong>（下一次新连接中不会出现旧的连接请求报文段）</li>
<li>避免新连接与旧连接的混淆：如果只等待1倍MSL的时间，那么在这段时间内，网络中可能仍然存在一些延迟的报文段。如果在这段时间内重新启动并使用相同的IP地址和端口号建立新的连接，那么这些延迟报文段可能会被错误地分配给新的连接，导致数据的混乱和错误。等待2倍MSL的时间可以确保在新连接建立之前，所有旧连接的报文段都已经被丢弃。</li>
<li>兼容网络中的不同设备和实现：不同的网络设备和TCP实现可能对报文段的存活时间有不同的处理方式。一些设备可能会丢弃报文段的时间更快，而另一些设备可能会保留报文段的时间更长。等待2倍MSL的时间可以更好地适应不同设备和实现之间的差异，确保连接的可靠性和正确性。</li>
<li>
<strong>网络不可靠的情况</strong>：如果主机在等待1倍MSL的时间后立即关闭连接，那么在这段时间内，<strong>如果服务器端的重传数据在网络中延迟或丢失</strong>，主机将无法接收到这些重传数据（FIN+ACK报文段），从而可能导致数据的丢失或错误。等待2倍MSL的时间可以提供更长的接收窗口，确保主机能够接收到服务器端的<strong>超时重传数据</strong>。这样可以增加连接的可靠性，避免数据的丢失或错误。</li>
</ol> 
<h2>
<a id="TCP__362"></a>TCP建立的字节流 每一个字节都要按顺序编号是什么意思？（序列号的作用）(字节流保持有序的方法)</h2> 
<p>TCP协议通过序列号来对字节流进行编号，以保证数据的有序传输和可靠性。</p> 
<p>在TCP连接建立后，发送方会将要发送的数据划分为多个数据段（数据段就是TCP报文段），并为每个数据段分配一个序列号。序列号是一个32位的整数，用于标识数据段在字节流中的位置。每个数据段都有一个起始序列号，表示该数据段中第一个字节在整个字节流中的位置。后续的数据段则依次递增序列号。</p> 
<p><strong>举个例子：</strong></p> 
<p>假设发送方要发送一个包含100个字节的数据流。</p> 
<p>发送方将数据流划分为多个数据段，并按顺序编号。假设每个数据段的大小为10个字节，那么就会有10个数据段。</p> 
<p>第一个数据段的起始序列号为1，表示第一个字节在整个字节流中的位置。第二个数据段的起始序列号为11，第三个数据段的起始序列号为21，以此类推。</p> 
<p>当发送方发送数据时，每个数据段都会带有序列号。接收方根据序列号来确认已经接收到的数据段，并通知发送方下一个期望接收的数据段的序列号。</p> 
<p>假设接收方已经成功接收到序列号为1的数据段和序列号为11的数据段，那么接收方会向发送方发送一个确认号为21的确认报文，表示下一个期望接收的数据段的起始序列号为21。</p> 
<p>如果发送方在发送数据段时发现序列号为21的数据段丢失，它会根据接收到的确认号进行重传，以确保数据的可靠传输。</p> 
<h2>
<a id="TCP_382"></a>TCP中确认号是什么？有什么作用？</h2> 
<p><strong>确认号有两个作用：</strong></p> 
<ol>
<li>表示已经成功接收的数据段：确认号指示了接收方已经成功接收到的数据段的最后一个字节的序列号。通过确认号，发送方可以知道哪些数据已经被接收方正确接收。<strong>（比如确认号为N，则表明N-1为止的所有数据都已经正确收到）</strong>
</li>
<li>表示期望接收的下一个数据段的序列号：<strong>确认号的值通常是已经接收到的数据段的最后一个字节的序列号加1</strong>。发送方在收到确认报文后，可以根据确认号确定下一个需要发送的数据段的序列号。（<strong>发送方发送的数据段的初始序号为1001，长度为200字节。接收方成功接收到该数据段，并希望接收下一个序号为1201的数据段。在这种情况下，接收方向发送方发送的ACK包应该包含确认号为1201。</strong>）</li>
</ol> 
<h2>
<a id="TCP_389"></a>TCP报文段的首部包含什么？</h2> 
<p><img src="https://images2.imgbox.com/ed/86/srwQEtcg_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uopPAgt4-1690270230622)(C:Users93701AppDataRoamingTyporatypora-user-imagesimage-20230723114411399.png)]"></p> 
<p>TCP报文段的首部包含以下字段：</p> 
<ol>
<li>源端口号（Source Port）：16位字段，表示发送方的端口号。</li>
<li>目的端口号（Destination Port）：16位字段，表示接收方的端口号。</li>
<li>序列号（Sequence Number）：32位字段，用于对发送的字节进行编号，用于保证数据的有序传输。</li>
<li>确认号（Acknowledgement Number）：32位字段，仅在<strong>ACK标志位</strong>为1时有效，表示期望接收的下一个字节的序号。</li>
<li>数据偏移（Data Offset）：4位字段，表示TCP首部的长度，以4字节为单位。最大值为15，因此TCP首部的最大长度为60字节。</li>
<li>保留（Reserved）：6位字段，保留供将来使用，目前置为0。</li>
<li>控制位（Flags）：共6个标志位，分别为：URG（紧急指针有效位）、ACK（确认号有效位）、PSH（接收方应该尽快将数据交给应用层位）、RST（重置连接位）、SYN（同步序号位）和FIN（结束连接位）。</li>
<li>窗口大小（Window Size）：16位字段，表示发送方的接收窗口大小，用于流量控制。</li>
<li>校验和（Checksum）：16位字段，用于检测TCP首部和数据是否出现错误。</li>
<li>紧急指针（Urgent Pointer）：16位字段，仅在URG标志位为1时有效，表示紧急数据的字节偏移量。</li>
<li>选项（Options）：可变长度的字段，用于扩展TCP的功能，如选择确认、时间戳等。</li>
<li>填充（Padding）：用于保证TCP首部长度为4字节的倍数。</li>
</ol> 
<h2>
<a id="FIN_ACK_SYN_409"></a>讲一下FIN标志位 ACK标志位 SYN标志位</h2> 
<p>FIN（Finish）标志位：用于表示发送方已经完成了数据的发送，并请求关闭连接。当一个TCP连接的一方发送了带有FIN标志位设置为1的报文段时，表示该方不再发送数据，但仍然可以接收数据。</p> 
<p>ACK（Acknowledgement）标志位：用于表示报文段中的确认号（acknowledgment number）字段有效。当ACK标志位设置为1时，确认号字段才被认为是有效的。在TCP连接的建立和关闭过程中，ACK标志位用于确认对方发送的报文段的接收情况。</p> 
<p>SYN（Synchronize）标志位：用于在TCP连接的建立过程中进行同步。当一个TCP连接的一方发送一个带有SYN标志位设置为1的报文段时，表示该方请求建立连接，并指定初始的序列号（sequence number）。</p> 
<p><strong>标志位的大小是一个比特（bit），即只占用一个二进制位</strong></p> 
<h2>
<a id="SACK_419"></a>SACK是什么？</h2> 
<p>SACK是指Selective Acknowledgment（选择性确认），它是一种用于TCP协议的可选扩展。SACK允许接收方向发送方报告丢失的数据段，从而提高TCP的可靠性和性能。</p> 
<p>在传统的TCP协议中，当接收方收到乱序的数据段时，它只能发送一个累积确认给发送方，告诉发送方它已经接收到哪个数据段，并期望发送方重传该数据段之后的所有数据。这种方式存在一个问题，即如果有多个数据段丢失，发送方需要重传整个丢失的窗口，导致网络资源的浪费和延迟的增加。</p> 
<p>SACK通过引入选择性确认的机制来解决这个问题。接收方可以向发送方报告丢失的数据段的具体范围，而不仅仅是最后一个已接收的数据段。这样，发送方就可以只重传丢失的数据段，而不需要重传整个窗口。</p> 
<p>SACK的工作原理如下：</p> 
<ol>
<li>接收方收到乱序的数据段后，会记录下丢失的数据段的范围。</li>
<li>接收方在确认报文中包含SACK选项，指示发送方丢失的数据段范围。</li>
<li>发送方收到SACK选项后，可以根据丢失的数据段范围进行有选择性地重传。</li>
</ol> 
<p>通过使用SACK，TCP可以更有效地处理丢失的数据段，减少不必要的重传，提高网络的吞吐量和性能。SACK是一种可选的TCP扩展，需要发送方和接收方都支持才能生效。</p> 
<h2>
<a id="TCPkeepalive_435"></a>TCP的keepalive是啥？</h2> 
<p>Keepalive是一种网络协议或机制，用于检测和维护网络连接的活跃状态。它通过定期发送小型的探测数据包来确认对方是否仍然处于活跃状态，从而避免连接因为长时间没有数据传输而被关闭。（也就是说服务器可以以此来判断客户端是否断开来连接）</p> 
<p>在TCP协议中，Keepalive是通过在空闲连接上定期发送Keepalive探测包来实现的。当TCP连接处于空闲状态时，即没有数据传输时，Keepalive机制会定期发送探测包给对方。如果对方在一定时间内没有响应，就会认为连接已经失效，并关闭连接。这样可以避免因为网络故障或对方异常退出而长时间保持无效的连接。</p> 
<p>Keepalive的使用可以提高网络连接的可靠性和稳定性。它可以用于检测连接的可用性，防止连接空闲时间过长导致连接被关闭，以及检测网络故障或对方异常退出等情况。</p> 
<p>需要注意的是，Keepalive机制需要在操作系统或应用程序中进行配置和开启。不同的操作系统和应用程序可能有不同的Keepalive参数和默认设置，可以根据具体需求进行配置和调整。</p> 
<h2>
<a id="_446"></a>心跳机制是什么意思</h2> 
<p>Heartbeat（心跳）是一种用于保持活跃连接的机制，类似于Keepalive。它通过定期发送小型的探测消息来确认通信双方的活跃状态。</p> 
<p>Heartbeat通常在应用层上实现，用于检测和维护应用程序之间的连接。它可以是一种周期性地发送消息或信号的机制，以确保通信双方仍然处于活跃状态。通常，一个应用程序会定期发送心跳消息给另一个应用程序，如果一段时间内没有收到心跳消息，就会认为连接已经断开或对方不再活跃。</p> 
<p>Heartbeat机制在分布式系统中很常见，用于监测和管理节点之间的连接状态。它可以用于检测节点的故障或异常，并采取相应的处理措施，例如重新分配任务、重新连接等。Heartbeat还可以用于协调分布式系统中的各个节点，确保节点之间的同步和一致性。</p> 
<p>Heartbeat的频率和具体实现方式可以根据应用程序的需求进行配置和调整。通常，心跳消息的频率应根据网络延迟、连接稳定性和应用程序的实时性要求来确定。较低的心跳频率可以减少网络带宽的占用，但可能会导致连接状态检测的延迟。较高的心跳频率可以更快地检测到连接状态的变化，但会增加网络带宽的消耗。</p> 
<h2>
<a id="TCPACK_456"></a>TCP的延迟ACK和累计应答是什么？用在什么场景</h2> 
<p>延迟ACK（Delayed ACK）和累计应答（Cumulative Acknowledgment）是与TCP协议中的数据确认相关的概念。</p> 
<p>延迟ACK是指TCP接收方在接收到数据后，不立即发送确认（ACK）消息，而是等待一段时间，以期望可以一次性发送一个ACK来确认多个数据包。这样可以减少ACK消息的数量，从而节省网络带宽。延迟ACK的默认时间通常是200毫秒。</p> 
<p>累计应答是指TCP接收方在发送ACK消息时，确认的是连续接收到的一系列数据包，而不是逐个确认每个数据包。例如，如果接收方接收到了数据包1、2、3、4，它可以只发送一个ACK消息来确认这四个数据包的接收。这样可以减少ACK消息的数量，并提高网络传输的效率。</p> 
<p>延迟ACK和累计应答的使用可以有效地减少网络中的ACK消息数量，从而减少网络延迟和带宽消耗。然而，延迟ACK和累计应答也可能导致一定的延迟，因为接收方需要等待一段时间或一定数量的数据包才发送确认消息。在某些特定的应用场景中，如实时通信或高速数据传输，可能需要调整延迟ACK和累计应答的参数来平衡延迟和带宽的需求。</p> 
<p>需要注意的是，延迟ACK和累计应答是TCP协议中的一种优化机制，并不是必须使用的。具体是否使用延迟ACK和累计应答，以及参数的设置，取决于具体的网络环境和应用需求。</p> 
<h2>
<a id="TCP_469"></a>什么是TCP数据粘包问题？</h2> 
<p>TCP数据粘包问题是指在使用TCP协议进行数据传输时，发送方发送的数据被接收方粘在一起，导致接收方无法正确解析和处理数据的现象。</p> 
<p>TCP是一种面向连接的可靠传输协议，它将数据划分为一个个的数据包进行传输。然而，由于网络传输的不确定性，接收方可能无法按照发送方发送的数据包边界进行接收，从而导致多个数据包被粘在一起形成一个更大的数据块，这就是TCP数据粘包问题。</p> 
<p>TCP数据粘包问题可发生的原因有多种，包括网络延迟、拥塞、带宽限制等。当接收方收到粘在一起的数据块时，需要进行处理才能正确解析出每个数据包的边界和内容。</p> 
<h2>
<a id="TCP_477"></a>TCP数据粘包问题的解决方法有？</h2> 
<p>为了解决TCP数据粘包问题，通常可以采取以下几种方法：</p> 
<ol>
<li>消息定长：发送方将每个数据包固定长度，接收方按照固定长度进行拆分。</li>
<li>特殊字符分隔：发送方在数据包之间添加特殊字符作为分隔符，接收方根据特殊字符进行拆分。</li>
<li>消息头部标识：发送方在每个数据包的头部添加标识信息，包括数据包长度等，接收方根据标识信息进行拆分。</li>
<li>使用消息边界：发送方在每个数据包的末尾添加消息边界标识，接收方根据消息边界进行拆分。</li>
</ol> 
<p>根据具体的应用场景和需求，选择适合的解决方案来处理TCP数据粘包问题是很重要的。</p> 
<h2>
<a id="Http_490"></a>讲一下Http协议</h2> 
<p>HTTP（Hypertext Transfer Protocol）是一种用于在Web浏览器和Web服务器之间传输数据的协议。它是一个无状态的、应用层的协议，基于客户端-服务器模型。</p> 
<p>以下是HTTP协议的一些关键特点：</p> 
<ol>
<li>
<strong>无状态性</strong>：HTTP是无状态的，这意味着服务器不会记住之前的请求。每个请求都是独立的，服务器不会保留客户端的状态信息。为了处理状态，可以使用会话（Session）或者使用Cookie来跟踪客户端的状态。</li>
<li>
<strong>请求-响应模型</strong>：HTTP是基于请求-响应模型的。客户端发送一个HTTP请求到服务器，服务器处理该请求并返回一个HTTP响应给客户端。请求和响应都包含一个起始行、头部字段和一个可选的消息体。</li>
<li>
<strong>URL（Uniform Resource Locator）</strong>：HTTP使用URL来指定要访问的资源。URL由协议类型（例如<code>http://</code>）、主机名、端口号、路径和可选的查询参数组成。</li>
<li>
<strong>请求方法</strong>：HTTP定义了几种请求方法，最常见的是GET和POST。GET方法用于请求获取资源，而POST方法用于提交数据给服务器。其他常见的请求方法包括PUT（更新资源）、DELETE（删除资源）等。</li>
<li>
<strong>状态码</strong>：HTTP响应包含一个状态码，用于表示请求的处理结果。常见的状态码包括200（成功）、404（未找到）、500（服务器内部错误）等。</li>
<li>
<strong>头部字段</strong>：HTTP请求和响应中包含一些头部字段，用于传递关于请求或响应的附加信息。例如，<code>Content-Type</code>头部字段用于指定响应的内容类型，<code>User-Agent</code>头部字段用于标识发送请求的客户端。</li>
<li>
<strong>持久连接</strong>：HTTP/1.1引入了持久连接（Keep-Alive），允许在单个TCP连接上发送多个HTTP请求和响应，以减少连接的建立和关闭的开销。</li>
</ol> 
<p>HTTP协议是Web应用程序通信的基础，它定义了客户端和服务器之间的通信规则。通过HTTP，客户端可以向服务器请求资源，服务器可以将资源返回给客户端。这种简单而灵活的协议使得Web的发展和互联网的普及成为可能。</p> 
<h2>
<a id="Http_506"></a>Http协议的请求方法有哪些？</h2> 
<p>HTTP协议定义了多种请求方法，每种方法都有不同的目的和语义。以下是HTTP协议中常见的请求方法：</p> 
<ol>
<li>
<strong>GET</strong>：用于请求获取指定资源的数据。GET请求是幂等的，即多次发送相同的GET请求应该返回相同的结果。</li>
<li>
<strong>POST</strong>：用于向服务器提交数据，通常用于创建新资源或提交表单数据。POST请求不是幂等的，即多次发送相同的POST请求可能会导致不同的结果。</li>
<li>
<strong>PUT</strong>：用于向服务器上传或更新指定资源的内容。PUT请求通常用于更新已存在的资源，如果资源不存在，则会创建一个新资源。</li>
<li>
<strong>DELETE</strong>：用于删除指定的资源。</li>
<li>
<strong>HEAD</strong>：类似于GET请求，但只返回响应头部，不返回响应体。主要用于获取资源的元数据，例如资源的大小、类型等。</li>
<li>
<strong>OPTIONS</strong>：用于获取服务器支持的请求方法、响应头部字段等信息。</li>
<li>
<strong>PATCH</strong>：用于对资源进行部分更新。与PUT请求不同，PATCH请求只需要传递需要更新的部分数据，而不是整个资源。</li>
<li>
<strong>TRACE</strong>：用于在请求-响应链路上回显请求信息，主要用于测试或诊断。</li>
</ol> 
<p>除了上述常见的请求方法，HTTP协议还允许扩展自定义的请求方法。但在实际应用中，常用的是GET、POST、PUT、DELETE这几种请求方法。</p> 
<p><strong>用的最多的是get和post</strong></p> 
<h2>
<a id="Http_527"></a>Http协议常见的状态码有哪些？</h2> 
<p>HTTP协议定义了一组状态码，用于表示请求的处理结果。每个状态码都有特定的含义，用于指示请求成功、重定向、客户端错误或服务器错误等情况。以下是HTTP协议中常见的状态码：</p> 
<ol>
<li> <p><strong>1xx（信息性状态码）</strong>：表示请求已接收，正在处理或需要进一步操作。</p> 
  <ul>
<li>100 Continue：服务器已接收到请求的初始部分，客户端应继续发送剩余部分。</li>
<li>101 Switching Protocols：服务器已理解请求，将切换到新的协议。</li>
</ul> </li>
<li> <p><strong>2xx（成功状态码）</strong>：表示请求已成功处理。</p> 
  <ul>
<li>200 OK：请求成功，返回所请求的数据。</li>
<li>201 Created：请求已成功处理，并创建了新的资源。</li>
<li>204 No Content：请求成功，但响应不包含任何内容。</li>
</ul> </li>
<li> <p><strong>3xx（重定向状态码）</strong>：表示需要进一步操作以完成请求。</p> 
  <ul>
<li>301 Moved Permanently：请求的资源已永久移动到新位置。</li>
<li>302 Found：请求的资源暂时移动到新位置。</li>
<li>304 Not Modified：请求的资源未修改，可使用缓存的版本。</li>
</ul> </li>
<li> <p><strong>4xx（客户端错误状态码）</strong>：表示请求包含错误或无法完成请求。</p> 
  <ul>
<li>400 Bad Request：请求无效，服务器无法理解。</li>
<li>401 Unauthorized：请求需要身份验证。</li>
<li>403 Forbidden：服务器拒绝请求访问资源。</li>
<li>404 Not Found：请求的资源不存在。</li>
</ul> </li>
<li> <p><strong>5xx（服务器错误状态码）</strong>：表示服务器在处理请求时发生错误。</p> 
  <ul>
<li> <p>500 Internal Server Error：服务器遇到了意外错误。</p> </li>
<li> <p>502 Bad Gateway：服务器作为网关或代理，从上游服务器接收到无效响应。</p> </li>
<li> <p>503 Service Unavailable：服务器当前无法处理请求，可能是由于过载或维护。</p> </li>
</ul> </li>
</ol> 
<h2>
<a id="Get_567"></a>讲一下Get请求方式的过程</h2> 
<p>当客户端发送GET请求时，以下是一般的过程：</p> 
<ol>
<li>客户端构建GET请求：客户端创建一个HTTP请求，包括请求行、请求头和可选的请求体。请求行中包含了请求方法（GET）、请求的URL和协议版本。</li>
<li>客户端发送GET请求：客户端将构建好的GET请求发送到目标服务器。请求中包含了要获取的资源的URL和其他相关信息。</li>
<li>服务器接收GET请求：目标服务器接收到GET请求后，开始处理请求。</li>
<li>服务器处理GET请求：服务器根据请求中的URL和其他信息，查找并获取对应的资源。一般情况下，服务器会从文件系统、数据库或其他数据源中获取资源的内容。</li>
<li>服务器生成响应：服务器根据获取到的资源内容，生成一个HTTP响应。响应包括响应行、响应头和响应体。响应行中包含了协议版本、状态码和状态消息。</li>
<li>服务器发送响应：服务器将生成的HTTP响应发送回客户端。</li>
<li>客户端接收响应：客户端接收到服务器发送的响应。</li>
<li>客户端处理响应：客户端根据响应中的状态码和其他相关信息，处理响应内容。处理方式可以是显示响应内容、解析响应头、执行其他操作等。</li>
<li>客户端显示响应结果：客户端将响应结果显示给用户，例如在浏览器中展示网页内容。</li>
</ol> 
<h2>
<a id="Get___581"></a>讲一下Get请求消息的组成部分 以及响应消息的组成部分</h2> 
<p>当客户端发送GET请求时，请求消息由以下组成部分：</p> 
<ol>
<li>
<strong>请求行</strong>：包含请求方法、请求的URL和协议版本。 
  <ul><li>例如：GET /api/users HTTP/1.1</li></ul> </li>
<li>
<strong>请求头</strong>：包含关于请求的附加信息，以键值对的形式表示。 
  <ul><li>例如： 
    <ul>
<li>Host: example.com</li>
<li>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36</li>
<li>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8</li>
</ul> </li></ul> </li>
<li>
<strong>空行</strong>：用于分隔请求头和请求体。</li>
<li>
<strong>请求体</strong>：GET请求通常没有请求体，因为它主要用于获取资源，而不是发送数据。</li>
</ol> 
<p>以下是一个示例GET请求消息的完整示例：</p> 
<pre><code>GET /api/users?name=John&amp;age=25 HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
Accept: application/json
Authorization: Bearer abc123

</code></pre> 
<p>每一行的含义如下：</p> 
<ol>
<li> <p><code>GET /api/users?name=John&amp;age=25 HTTP/1.1</code>：请求行，包括HTTP方法（GET）、请求路径（/api/users）和查询参数（name=John&amp;age=25），以及使用的HTTP协议版本（HTTP/1.1）。</p> </li>
<li> <p><code>Host: example.com</code>：请求头字段，指定了请求的目标主机（example.com）。</p> </li>
<li> <p><code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36</code>：请求头字段，包含了发送请求的用户代理（浏览器）的信息。</p> </li>
<li> <p><code>Accept: application/json</code>：请求头字段，指定了客户端可以接受的响应内容类型（application/json）。</p> </li>
<li> <p><code>Authorization: Bearer abc123</code>：请求头字段，用于身份验证，其中Bearer是身份验证方案，abc123是身份验证令牌。</p> </li>
<li> <p><strong>空行表示请求头的结束，之后没有请求体。</strong></p> </li>
</ol> 
<hr> 
<p>响应消息由三个主要部分组成：响应行、响应头和响应体。</p> 
<ol>
<li>响应行：响应行包含了HTTP协议的版本号、状态码和状态消息。它的格式通常是<code>HTTP/1.1 200 OK</code>，其中<code>HTTP/1.1</code>表示协议版本，<code>200</code>表示状态码，<code>OK</code>表示状态消息。</li>
<li>响应头：响应头包含了与响应相关的元信息。它包含了一系列的键值对，每个键值对由一个字段名和一个字段值组成。常见的响应头字段包括<code>Content-Type</code>（指定响应体的内容类型）、<code>Content-Length</code>（指定响应体的长度）、<code>Date</code>（指定响应的日期和时间）等。</li>
<li>响应体：响应体包含了服务器返回的实际数据。它可以是HTML、JSON、XML等各种格式的数据，取决于服务器的处理逻辑和客户端的需求。</li>
</ol> 
<p>以下是一个对应的响应消息的例子，包括响应行、响应头和响应体的组成部分：</p> 
<p>HTTP/1.1 200 OK</p> 
<p>Content-Type: application/json</p> 
<p>Content-Length: 120</p> 
<p>Date: Mon, 25 Jul 2023 06:46:32 GMT</p> 
<p>{<!-- --></p> 
<p>“id”: 1,</p> 
<p>“name”: “John”,</p> 
<p>“age”: 25,</p> 
<p>“email”: “<a href="mailto:john@example.com">john@example.com</a>”</p> 
<p>}</p> 
<p>解析如下：</p> 
<ol>
<li>
<code>HTTP/1.1 200 OK</code>：响应行，表示服务器成功处理了请求，并返回了200状态码（OK）。</li>
<li>
<code>Content-Type: application/json</code>：响应头字段，指定了响应体的内容类型为application/json。</li>
<li>
<code>Content-Length: 120</code>：响应头字段，指定了响应体的长度为120字节。</li>
<li>
<code>Date: Mon, 25 Jul 2023 06:46:32 GMT</code>：响应头字段，指定了响应的日期和时间。</li>
<li>空行：表示响应头的结束。</li>
<li>响应体：包含了服务器返回的数据，这里是一个JSON格式的对象，包括id、name、age和email等属性。</li>
</ol> 
<h2>
<a id="ContentType_677"></a>Content-Type有哪些</h2> 
<p>Content-Type是HTTP头部字段之一，用于指示发送或接收的实体正文的媒体类型。以下是一些常见的Content-Type类型：</p> 
<ol>
<li>text/plain：纯文本类型。</li>
<li>text/html：HTML文档类型。</li>
<li>text/css：CSS样式表类型。</li>
<li>application/json：JSON数据类型。</li>
<li>application/xml：XML数据类型。</li>
<li>application/pdf：PDF文档类型。</li>
<li>image/jpeg：JPEG图像类型。</li>
<li>image/png：PNG图像类型。</li>
<li>audio/mpeg：MPEG音频类型。</li>
<li>video/mp4：MP4视频类型。</li>
</ol> 
<p>除了上述类型之外，还有许多其他的Content-Type类型，用于表示不同的媒体类型和数据格式。可以根据实际需求来选择适当的Content-Type类型。</p> 
<h2>
<a id="Post_694"></a>讲一下Post请求方式的过程</h2> 
<p>当使用POST请求方式时，客户端向服务器发送的请求会包含一个请求体，该请求体中包含了要传输给服务器的数据。下面是POST请求方式的一般过程：</p> 
<ol>
<li>客户端建立与服务器的连接：客户端通过建立TCP连接或使用其他协议与服务器建立连接。</li>
<li>构建请求消息：客户端构建HTTP请求消息，其中包括请求行、请求头和请求体。请求行中指定了请求方法为POST，以及请求目标的URL。请求头中可以包含一些额外的信息，如Content-Type、Content-Length等。请求体中包含了要传输给服务器的数据。</li>
<li>发送请求消息：客户端将构建好的请求消息发送给服务器。请求消息会通过网络传输到服务器端。</li>
<li>服务器接收请求消息：服务器端接收到客户端发送的请求消息。</li>
<li>处理请求：服务器根据接收到的请求消息，进行相应的处理。这可能涉及到验证用户身份、处理请求数据、执行相应的业务逻辑等。</li>
<li>返回响应：服务器生成HTTP响应消息，其中包括响应行、响应头和响应体。响应行指定了HTTP协议的版本号、状态码和状态消息。响应头包含了与响应相关的元信息。响应体中包含了服务器返回的数据。</li>
<li>接收响应：客户端接收到服务器返回的响应消息。</li>
<li>处理响应：客户端根据接收到的响应消息，进行相应的处理。这可能包括解析响应体中的数据、处理响应头中的元信息、根据状态码进行错误处理等。</li>
</ol> 
<p>POST请求方式适用于需要向服务器提交数据的场景，比如提交表单数据、上传文件等。相对于GET请求方式，POST请求方式更适合传输大量数据或敏感数据，因为POST请求将数据包含在请求体中，而不是在URL中可见。</p> 
<h2>
<a id="Post___711"></a>讲一下Post请求消息的组成部分 以及响应消息的组成部分</h2> 
<p>当使用POST请求发送消息时，消息通常由请求行、请求头和请求体组成。下面是一个POST请求的示例，展示了消息的组成部分：</p> 
<pre><code>POST /api/login HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 43

{
  "username": "exampleuser",
  "password": "secretpassword"
}
</code></pre> 
<ul>
<li>请求行：POST请求的请求行指定了请求方法为POST，请求目标为<code>/api/login</code>，使用的HTTP协议版本为HTTP/1.1。</li>
<li>请求头：请求头中包含了一些额外的信息。在这个示例中，<code>Host</code>头指定了服务器的主机名，<code>Content-Type</code>头指定了请求体的数据类型为JSON，<code>Content-Length</code>头指定了请求体的长度为43字节。</li>
<li>请求体：请求体中包含了要传输给服务器的数据。在这个示例中，请求体是一个JSON对象，包含了用户名和密码。</li>
</ul> 
<p>请注意，这只是一个示例，实际的POST请求消息可以根据具体的需求和场景来定制。</p> 
<p>当使用POST请求发送消息后，服务器会返回一个响应消息。下面是一个响应消息的示例：</p> 
<pre><code>HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 26

{
  "message": "Login successful"
}
</code></pre> 
<ul>
<li> <p>响应行：响应行指定了HTTP协议版本和状态码。在这个示例中，响应行中的状态码为200，表示请求成功。</p> </li>
<li> <p>响应头：响应头中包含了一些额外的信息。在这个示例中，<code>Content-Type</code>头指定了响应体的数据类型为JSON，<code>Content-Length</code>头指定了响应体的长度为26字节。</p> </li>
<li> <p>响应体：响应体中包含了服务器返回的数据。在这个示例中，响应体是一个JSON对象，包含了一个名为<code>message</code>的字段，其值为<code>Login successful</code>。</p> </li>
</ul> 
<h2>
<a id="GETPOST_755"></a>GET和POST请求方式的区别是？</h2> 
<p>GET和POST是HTTP协议中两种常见的请求方法，它们在使用方式和特点上有一些区别：</p> 
<ol>
<li>数据传输位置：GET请求将数据附加在URL的查询参数中，而POST请求将数据包含在请求体中。</li>
<li>数据长度限制：由于GET请求将数据附加在URL中，所以数据长度受到URL长度限制的限制。而POST请求将数据包含在请求体中，没有明确的长度限制，可以传输大量数据。</li>
<li>数据安全性：GET请求的数据会显示在URL中，因此对于敏感信息，不适合使用GET请求，因为URL可能会被保存在浏览器历史记录、服务器日志等地方。POST请求将数据包含在请求体中，不会在URL中暴露，相对来说更安全。</li>
<li>数据缓存：GET请求可以被浏览器缓存，因此对于相同的请求，浏览器可能会直接从缓存中获取响应，而不发送请求到服务器。POST请求不会被缓存，每次都会发送请求到服务器。</li>
<li>幂等性：GET请求是幂等的，即多次相同的GET请求不会对服务器产生副作用。而POST请求不是幂等的，多次相同的POST请求可能会对服务器产生不同的结果。</li>
<li>使用场景：GET请求适用于获取资源、查询数据等操作，而POST请求适用于提交数据、修改数据等操作。</li>
</ol> 
<p>总结起来，GET请求适合获取数据，对于无副作用的操作，以及对数据安全性要求不高的场景。POST请求适合提交数据，对于有副作用的操作，以及对数据安全性要求较高的场景。</p> 
<h2>
<a id="URL_768"></a>URL是什么，它的的组成部分是？</h2> 
<p>URL（统一资源定位符）是用于标识和定位互联网上资源的字符串。一个URL通常由以下几个组成部分构成：</p> 
<ol>
<li> <p>协议（Protocol）：URL的第一部分是协议，它指定了客户端与服务器之间通信所使用的协议，例如HTTP、HTTPS、FTP等。协议通常以<code>://</code>结尾。</p> </li>
<li> <p>域名（Domain）：域名是URL中的主要部分，它指定了要访问的服务器的名称或IP地址。域名可以是一个完整的主机名（例如www.example.com），也可以是一个IP地址（例如192.168.0.1）。</p> </li>
<li> <p>端口（Port）：端口是可选的，它指定了服务器上正在监听的特定端口号。如果未指定端口，则使用默认的端口号。常见的HTTP协议的默认端口号是80，HTTPS的默认端口号是443。</p> </li>
<li> <p>路径（Path）：路径指定了服务器上资源的具体位置。它以斜杠<code>/</code>开头，可以包含多个路径段，用斜杠分隔。例如，<code>/products/123</code>表示访问服务器上的<code>products</code>目录下的<code>123</code>资源。</p> </li>
<li> <p>查询参数（Query Parameters）：查询参数用于向服务器传递额外的数据。它们以问号<code>?</code>开头，多个参数之间使用<code>&amp;</code>分隔。每个参数由参数名和参数值组成，中间使用等号<code>=</code>连接。例如，<code>?page=1&amp;limit=10</code>表示请求的页码为1，每页显示10条数据。</p> </li>
<li> <p>锚点（Fragment）：锚点是URL的可选部分，用于指定页面内的特定位置。它以井号<code>#</code>开头，后面跟着锚点名称。例如，<code>#section1</code>表示页面滚动到ID为<code>section1</code>的元素处。</p> <p>这里有一个示例URL，-更好地理解URL的组成部分：</p> <pre><code>https://www.example.com:8080/products/123?category=electronics&amp;sort=price#reviews
</code></pre> <p>在这个示例中，URL的组成部分如下：</p> 
  <ul>
<li>协议：<code>https://</code>
</li>
<li>域名：<code>www.example.com</code>
</li>
<li>端口：<code>:8080</code>
</li>
<li>路径：<code>/products/123</code>
</li>
<li>查询参数：<code>?category=electronics&amp;sort=price</code>
</li>
<li>锚点：<code>#reviews</code>
</li>
</ul> <p>这个URL表示一个使用HTTPS协议访问位于<code>www.example.com</code>主机的服务器。服务器监听的端口号是8080。路径是<code>/products/123</code>，表示要访问服务器上的<code>products</code>目录下的<code>123</code>资源。查询参数中有两个参数，<code>category</code>的值是<code>electronics</code>，<code>sort</code>的值是<code>price</code>。最后，锚点是<code>#reviews</code>，表示页面滚动到ID为<code>reviews</code>的元素处。</p> </li>
</ol> 
<h2>
<a id="GetPostURL_803"></a>Get方式和Post方式的URL有何不同？</h2> 
<p>当使用GET方法时，查询参数会直接附加在URL的末尾。以下是一个使用GET方法的URL示例：</p> 
<p>GET请求的URL示例：</p> 
<pre><code>https://www.example.com/api/products?id=123&amp;category=electronics
</code></pre> 
<p>在上面的示例中，查询参数<code>id=123</code>和<code>category=electronics</code>直接附加在URL的末尾，用于向服务器请求具有特定ID和类别的产品数据。</p> 
<p>而当使用POST方法时，数据会被放置在请求体中，而不是直接附加在URL上。以下是一个使用POST方法的URL示例：</p> 
<p>POST请求的URL示例：</p> 
<pre><code>https://www.example.com/api/products
</code></pre> 
<h2>
<a id="HTTPHTTPS_829"></a>HTTP和HTTPS的区别</h2> 
<p>HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是用于在客户端和服务器之间传输数据的协议。它们之间的主要区别如下：</p> 
<ol>
<li>安全性： 
  <ul>
<li>HTTP：数据在传输过程中是明文的，不加密。因此，HTTP协议存在安全风险，例如，黑客可以拦截和窃取传输的数据。</li>
<li>HTTPS：数据在传输过程中通过SSL/TLS加密，确保数据的安全性和完整性。HTTPS使用公钥加密和私钥解密的方式，防止数据被窃取或篡改。</li>
</ul> </li>
<li>端口： 
  <ul>
<li>HTTP：默认使用端口号80。</li>
<li>HTTPS：默认使用端口号443。</li>
</ul> </li>
<li>证书： 
  <ul>
<li>HTTP：不需要使用证书。</li>
<li>HTTPS：需要使用SSL证书，用于验证服务器的身份。SSL证书由可信任的第三方机构颁发，用于建立安全连接。</li>
</ul> </li>
<li>SEO（搜索引擎优化）： 
  <ul>
<li>HTTP：搜索引擎对HTTP网站的排名没有特殊优待。</li>
<li>HTTPS：搜索引擎倾向于将使用HTTPS的网站排名更高，因为HTTPS提供了更好的安全性和用户隐私保护。</li>
</ul> </li>
</ol> 
<p>总结起来，HTTP是一种不加密的协议，而HTTPS通过使用SSL/TLS加密传输数据，提供了更高的安全性和数据保护。在传输敏感信息、进行在线支付或需要保护用户隐私的情况下，建议使用HTTPS。</p> 
<h2>
<a id="_NAT_NAT_848"></a>讲一下 NAT技术产生的原因 NAT提供的技术是啥</h2> 
<p>NAT（Network Address Translation，网络地址转换）技术的产生是为了解决IPv4地址不足的问题。在早期的互联网发展中，IPv4地址资源有限，无法满足大量设备的连接需求。NAT技术通过在私有网络和公共网络之间进行地址转换，实现了多个设备共享一个公共IP地址的功能。<br> NAT技术提供了以下几种功能：</p> 
<p>IP地址转换：NAT将私有网络中的设备使用私有IP地址进行通信，而在与公共网络通信时，NAT会将私有IP地址转换为公共IP地址，以实现与公共网络的通信。</p> 
<p>端口转换：NAT还可以将私有网络中的设备使用的端口号转换为公共网络中的端口号。这样，即使多个设备使用相同的私有IP地址，也可以通过不同的端口号进行区分，从而实现多个设备共享一个公共IP地址。</p> 
<p>地址映射：NAT技术还可以实现地址映射功能，将公共IP地址映射到私有网络中的特定设备上。这样，外部网络可以通过访问公共IP地址来访问私有网络中的设备，实现远程访问、端口转发等功能。</p> 
<h2>
<a id="IP_862"></a>什么是动态IP地址？</h2> 
<p>动态IP地址是指在网络中分配给设备的临时IP地址。与静态IP地址相对，动态IP地址是临时性的，每次设备连接到网络时都会重新获取一个新的IP地址。<br> 动态IP地址的分配通常由DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）服务器来管理。当设备连接到网络时，它会发送一个DHCP请求，请求获取一个可用的IP地址。DHCP服务器会从一个地址池中选择一个可用的IP地址分配给设备，并将分配的IP地址及其他网络配置信息发送给设备。设备在使用完IP地址后，会将其释放回DHCP服务器，以便其他设备可以再次使用。<br> 动态IP地址的优点在于它们可以更高效地利用IP地址资源。由于动态IP地址是临时性的，设备不再使用时可以释放回地址池，供其他设备使用，从而减少了IP地址的浪费。此外，动态IP地址的分配过程也更加简单和自动化，减少了网络管理员的工作量。<br> 然而，动态IP地址也有一些限制。由于IP地址是临时性的，设备每次连接到网络时都会获得一个新的IP地址，这可能导致一些网络应用或服务的配置问题。对于需要远程访问或需要固定IP地址的设备，静态IP地址可能更为适合。</p> 
<p><strong>动态IP地址可以发生在公有网络和私有网络中。</strong><br> 在公有网络中，动态IP地址是由互联网服务提供商（ISP）分配给用户的临时IP地址。当用户连接到互联网时，ISP会为其分配一个可用的动态IP地址。这样，用户可以通过该动态IP地址与互联网进行通信。<br> 在私有网络中，动态IP地址是由本地网络的DHCP服务器分配给设备的临时IP地址。当设备连接到私有网络时，DHCP服务器会为其分配一个可用的动态IP地址。这样，设备可以在私有网络中进行通信，与其他设备进行数据交换。</p> 
<h2>
<a id="_873"></a>端口转换和端口映射有啥区别？</h2> 
<p>端口映射和端口转换都是用于实现公网用户访问私网设备或服务的功能。<br> 端口映射是指将公网IP地址的特定端口映射到私网设备的特定端口上。这样，当公网用户发送请求到公网IP地址和映射的端口时，路由器会将这些请求转发到相应的私网设备上的对应端口上。<br> 端口转换（也称为NAT转换）是一种更广义的概念，它包括端口映射。端口转换是指在私网内部进行的一种转换过程，将私网用户的请求从一个端口转换为另一个端口，并将其转发到私网中的其他设备上。这样可以实现私网内部设备之间的通信，同时也可以实现公网用户访问私网设备的功能。<br> 所以，<strong>端口映射是端口转换的一种形式，用于公网用户访问私网设备或服务。而端口转换还可以包括私网用户之间的端口转发</strong>，以实现私网内部设备之间的通信。</p> 
<p><strong>端口转换举例：</strong><br> 想象一下，您有一个家庭网络，其中有三台设备连接到同一个路由器：设备A、设备B和设备C。您的家庭网络使用一个公有IP地址。<br> 设备A运行着一个Web服务器，监听着80端口。假设设备B和设备C都想通过Internet访问设备A上的这个Web服务器。<br> 由于您的家庭网络只有一个公有IP地址，设备B和设备C都无法直接通过Internet访问设备A上的Web服务器。<br> 这时，您可以在路由器上进行端口转换配置。您可以指定一个外部端口（例如8080），并将它映射到设备A的80端口。<br> 现在，当设备B或设备C通过Internet访问路由器的公有IP地址和映射的端口（例如http://your_public_ip:8080）时，路由器会将这些请求转发给设备A上的Web服务器。<br> 这样，设备B和设备C就可以通过Internet访问设备A上的Web服务器了，而无需直接连接到设备A。<br> <strong>端口映射举例：</strong><br> 假设你有一个家庭网络，其中有一个摄像头设备，你希望能够通过公共互联网访问这个摄像头。首先，你需要在路由器上进行端口映射的配置。</p> 
<p>找到你的摄像头设备的IP地址，比如192.168.1.101。</p> 
<p>登录到你的路由器管理界面，在网络设置或端口转发等选项中找到端口映射设置。</p> 
<p>创建一个新的端口映射规则。输入以下信息：</p> 
<p>公共端口：选择一个未被占用的公共端口号，比如8080。</p> 
<p>内部IP地址：输入摄像头设备的IP地址，即192.168.1.101。</p> 
<p>内部端口：输入摄像头设备监听的端口号，比如80。</p> 
<p>协议：选择TCP或UDP，根据摄像头设备的要求。</p> 
<p>保存并应用这个端口映射规则。</p> 
<p>现在，当你在公共互联网上访问你的路由器的公共IP地址，并指定端口号8080时，路由器会将这个请求转发到摄像头设备的IP地址192.168.1.101的端口80上。这样，你就可以通过公共互联网访问你的摄像头设备了。</p> 
<h2>
<a id="DHCP_911"></a>DHCP服务器和网关分别是什么</h2> 
<p>DHCP服务器和网关在网络中扮演不同的角色，它们有以下区别：</p> 
<p>功能：DHCP服务器负责为连接到网络的设备动态分配IP地址和其他网络配置信息。它通过接收设备的DHCP请求，并从预先配置的IP地址池中选择一个可用的IP地址分配给设备。而网关是网络中的出口点，它连接了局域网（LAN）与外部网络（如Internet）之间的通信，负责将数据包从一个网络传输到另一个网络。</p> 
<p>工作方式：DHCP服务器通过DHCP协议与设备进行通信，接收和处理设备的DHCP请求，并将分配的IP地址和其他配置信息发送回设备。它的工作是在设备加入网络时自动分配IP地址和配置信息。而网关则是根据网络层的路由表和转发规则，将数据包从源网络传输到目标网络。</p> 
<p>地址分配：DHCP服务器负责动态分配IP地址，为连接到网络的设备提供临时的、可变的IP地址。这使得设备可以自动获取一个可用的IP地址，而无需手动配置。而网关通常具有一个静态的IP地址，它是<strong>网络中的出口点</strong>，用于将数据包从一个网络传输到另一个网络。</p> 
<p>作用范围：DHCP服务器的作用范围是局域网（LAN）内的设备，它为连接到该局域网的设备提供IP地址和其他配置信息。而网关的作用范围是整个网络，它连接了局域网与外部网络，负责将数据包从局域网传输到外部网络，或从外部网络传输到局域网。</p> 
<p>总结来说，DHCP服务器负责为设备动态分配IP地址和其他网络配置信息，而网关是网络中的出口点，负责将数据包从一个网络传输到另一个网络。它们在功能、工作方式、地址分配和作用范围等方面有所不同。</p> 
<p><strong>DHCP服务器通常会放置在路由器或网络设备上。路由器在私人网络中充当网关的角色，它连接了局域网（LAN）与外部网络（如Internet）之间的通信。</strong></p> 
<h2>
<a id="19216801_932"></a>网络中的出口点是什么？192.168.0.1是不是出口点</h2> 
<p>网络中的出口点指的是网络通信的出口，也可以称为默认网关或网关。它是连接一个局域网（LAN）或私有网络与外部网络（如Internet）之间的交换点。<br> 出口点通常是一个网络设备，如路由器或防火墙。它具有两个或多个网络接口，一个连接到局域网，一个或多个连接到外部网络。出口点通过转发数据包将局域网中的数据传输到外部网络，或将外部网络中的数据传输到局域网。<br> 192.168.0.1是一个常见的私有IP地址，通常用作默认网关或出口点的IP地址。默认网关是指设备在发送数据包时，如果目标IP地址不在同一个子网内，就将数据包发送到默认网关，由默认网关负责将数据包转发到外部网络。<br> 因此，192.168.0.1可以是一个网络中的出口点，作为默认网关，负责将数据包从局域网传输到外部网络，或从外部网络传输到局域网。但需要注意的是，实际的出口点IP地址可能会有所不同，具体取决于网络的配置和设备的设置。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>