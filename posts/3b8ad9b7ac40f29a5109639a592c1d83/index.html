<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>从CPU缓存结构到原子操作 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从CPU缓存结构到原子操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>文章目录</h3> 
 <ul>
<li><a href="#CPU_1">一、CPU缓存结构</a></li>
<li>
<ul>
<li><a href="#11_CPU_2">1.1 CPU的多级缓存</a></li>
<li><a href="#12_Cache_Line_10">1.2 Cache Line</a></li>
</ul> 
  </li>
<li><a href="#_18">二、写回策略</a></li>
<li><a href="#_34">三、缓存一致性问题及解决方案</a></li>
<li>
<ul>
<li><a href="#31__35">3.1 缓存一致性问题</a></li>
<li><a href="#32__40">3.2 解决方案</a></li>
<li>
<ul>
<li><a href="#321__41">3.2.1 总线嗅探</a></li>
<li><a href="#322__48">3.2.2 事务的串行化</a></li>
<li><a href="#323_MESI_70">3.2.3 MESI</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#_83">四、原子操作</a></li>
<li>
<ul>
<li><a href="#41__84">4.1 什么是原子操作</a></li>
<li><a href="#42_c__94">4.2 c++ 标准库的原子类型</a></li>
<li>
<ul>
<li><a href="#421_atomicT_95">4.2.1 atomic&lt;T&gt;</a></li>
<li><a href="#422_is_lock_free_107">4.2.2 is_lock_free()</a></li>
<li><a href="#423_load_117">4.2.3 load()</a></li>
<li><a href="#424_store_124">4.2.4 store()</a></li>
<li><a href="#425_exchange_132">4.2.5 exchange()</a></li>
<li><a href="#426_compare_exchange_weak_140">4.2.6 compare_exchange_weak()</a></li>
<li><a href="#427_compare_exchange_strong_206">4.2.7 compare_exchange_strong()</a></li>
</ul> 
  </li>
</ul> 
  </li>
<li><a href="#_213">五、内存序问题</a></li>
<li>
<ul>
<li><a href="#51__214">5.1 什么是内存序问题</a></li>
<li><a href="#52__238">5.2 内存序</a></li>
<li>
<ul>
<li><a href="#521_memory_order_relaxed_242">5.2.1. memory_order_relaxed</a></li>
<li><a href="#522_memory_order_release_245">5.2.2. memory_order_release</a></li>
<li><a href="#523_memory_order_acquire_250">5.2.3. memory_order_acquire</a></li>
<li><a href="#524_memory_order_acq_rel_255">5.2.4. memory_order_acq_rel</a></li>
<li><a href="#525_memory_order_seq_cst_257">5.2.5. memory_order_seq_cst</a></li>
</ul> 
   </li>
<li><a href="#53__260">5.3 内存屏障</a></li>
<li>
<ul><li><a href="#531atomic_thread_fence_271">5.3.1atomic_thread_fence()</a></li></ul> 
  </li>
</ul> 
  </li>
<li><a href="#_283">六、测试代码</a></li>
<li>
<ul>
<li><a href="#61__284">6.1 多线程加锁</a></li>
<li><a href="#62__364">6.2 内存序问题</a></li>
<li><a href="#63__420">6.3 多线程同步问题</a></li>
<li>
<ul>
<li><a href="#631__424">6.3.1 问题</a></li>
<li><a href="#632__467">6.3.2 解法一：标志位</a></li>
<li><a href="#633__517">6.3.3 解法二：互斥锁</a></li>
<li><a href="#634__562">6.3.4 解法三：内存屏障</a></li>
</ul> 
  </li>
</ul> 
 </li>
</ul> 
</div> 
<p></p> 
<h1>
<a id="CPU_1"></a>一、CPU缓存结构</h1> 
<h2>
<a id="11_CPU_2"></a>1.1 CPU的多级缓存</h2> 
<p>因为CPU的计算速度非常快，但内存的访问速度相对较慢。因此，如果CPU每次都要从内存读取数据，会造成大量的等待时间，降低整体性能。</p> 
<p>通过引入多级缓存，可以在CPU和内存之间建立数据缓存层，将最常用的数据暂时保存在靠近CPU的高速缓存（CPU Cache）中，以供CPU快速访问。不同级别的缓存容量和访问速度各不相同，一般来说，L1缓存最小、速度最快，L2缓存次之，L3缓存最大但速度相对较慢。并且 L1和L2 是 CPU 私有，L3 是所有 CPU 共享。<br> <img src="https://images2.imgbox.com/28/d8/LxFA7fuw_o.png" alt="在这里插入图片描述"></p> 
<p>多级缓存的设计可以实现更高的命中率，即CPU能够更频繁地从高速缓存中获取需要的数据，减少对内存的访问次数，从而提高整体性能。</p> 
<h2>
<a id="12_Cache_Line_10"></a>1.2 Cache Line</h2> 
<p>CPU 从内存中读取数据到 CPU Cache 的过程中，是一小块一小块来读取数据的。这样一小块一小块的数据，在 CPU Cache 里面，我们把它叫作缓存行(Cache Line)。即，Cache Line是CPU缓存中的最小可读写单元，用于存储从主存中读取的数据块。日常使用的 Intel 服务器或者 PC 里，Cache Line 的大小通常是 64 字节。</p> 
<p>当CPU访问内存时，如果所需数据在缓存中已经存在于一个Cache Line中，那么CPU可以直接从缓存中读取数据，而无需访问主存，从而提高了数据传输的速度。<br> <img src="https://images2.imgbox.com/22/7f/bcni1vxI_o.png" alt="在这里插入图片描述"></p> 
<ul>
<li>标志位（flag）：用于指示Cache Line当前是否有效。当一个Cache Line中存储的数据被更新或替换时，标志位会被清除，表示该Cache Line不再有效。（存MESI 的状态）</li>
<li>标记（tag）：用于标识数据区域中存储的数据块是来自哪个主存地址。当CPU需要读取或写入特定地址的数据时，它会将该地址的一部分作为标记，并与Cache Line中存储的标记进行比较，以确定是否命中缓存。</li>
<li>数据区域（data）：用于存储从主存中读取的数据块。</li>
</ul> 
<h1>
<a id="_18"></a>二、写回策略</h1> 
<p>写回策略（Write Back）是一种用于缓存管理的写入更新方式。当数据被修改时，写回策略将更新后的数据首先写入缓存，而不立即写入主内存。</p> 
<p>具体来说，当缓存中的某个数据被修改时，写回策略将在修改时更新缓存中的对应数据，并将其标记为脏数据，表示该数据已经被修改过。然后，当需要替换这个被修改的数据时，才将更新后的数据写回主内存。</p> 
<ul>
<li> <p>当请求是写请求时<br> 1）若命中，直接将新数据写入缓存，并且标记为脏数据dirty（缓存中修改过但尚未写回到更高级别缓存或主内存中的数据）。注意此时不会写入内存。<br> 2）若未命中，分配一个缓存块Cache Line，判断当前缓存块是不是脏数据。如果是，先将缓存块的数据写回内存中，再将新数据写入缓存块。如果不是脏数据，直接从内存中读到缓存块中（建立内存块与缓存块的索引关系），再将新数据写入缓存块，并标记为dirty。</p> </li>
<li> <p>当请求是读请求时<br> 1）若命中，直接返回其数据；<br> 2）若未命中时，分配一个缓存块，判断当前缓存块是不是脏数据。如果是，先将缓存块的数据写回下一级存储中，再从内存读取新数据到缓存块中。如果不是脏数据，直接从内存中读到缓存块中，修改dirty位为clean（未被修改）。最后返回数据。<br> <img src="https://images2.imgbox.com/87/59/5BwgFCCH_o.png" alt="在这里插入图片描述"></p> </li>
</ul> 
<p>这种策略的主要优势在于减少了向主内存写入数据的次数。相比于每次数据修改都直接写入主内存（写直达，Write Through），写回策略可以将多次对同一块数据的修改累积起来，一次性地写回主内存，减少了对主内存的访问，提高了效率。</p> 
<h1>
<a id="_34"></a>三、缓存一致性问题及解决方案</h1> 
<h2>
<a id="31__35"></a>3.1 缓存一致性问题</h2> 
<p>上面介绍的写回策略，延迟数据写入主内存的时机，可能会带来数据一致性的问题。因为CPU是多核的，在数据被修改后，尚未写回主内存之前，如果发生了缓存替换或其他操作，主内存上的数据可能是过期的。</p> 
<p>比如在多线程的情况下，每个线程都有自己的缓存。假如线程 1 从主存中读取到 x，并对其加 1 ，此时还没有写回主存。与此同时，线程 2 也从主存中读取 x ，并加 1 。但是它们都不知道对方的存在，也不可以读取对方的缓存。若这时都将 x 写回主存，那此时 x 的值就少了 1 ，出现了数据不一致的问题。</p> 
<h2>
<a id="32__40"></a>3.2 解决方案</h2> 
<h3>
<a id="321__41"></a>3.2.1 总线嗅探</h3> 
<p>当一个处理器执行一个写操作时，它会在总线上广播一个写请求，并在总线上传输要写入的数据。其他处理器的总线嗅探器会监听到该写请求，并检查请求中的地址。如果某个处理器的缓存中包含了该地址的数据块，总线嗅探器就会将该缓存块标记为“无效”，表示该数据已经过期，需要从主内存或其他缓存中重新获取最新的数据。</p> 
<p>同样地，当一个处理器执行一个读操作时，总线嗅探器也会监听到该读请求，并检查请求中的地址。如果某个处理器的缓存中包含了该地址的数据块，总线嗅探器会检查该数据块是否为“脏”，即是否被修改过。如果是脏数据，则总线嗅探器负责将该数据写回到主内存或其他缓存中，以保证数据的一致性。</p> 
<p>通过总线嗅探技术，处理器能够感知其他处理器对共享数据的读写操作，并及时更新自己的缓存，以确保所有处理器都能访问到最新的共享数据。</p> 
<h3>
<a id="322__48"></a>3.2.2 事务的串行化</h3> 
<p>举个例子，假设有两个事务 T1 和 T2，我们希望它们并发执行的过程如下：<br> T1：读取数据 A，修改数据 A（A = 10 ~&gt; A = 20）<br> T2：读取数据 A，修改数据 A（A = 20 ~&gt; A = 30）</p> 
<p>但是如果这两个事务并发执行，并未经过任何的串行化控制，可能出现以下情况：<br> T1 先执行读取操作，读取到 A 的值为 10；<br> T2 在 T1 执行读取操作后执行读取操作，读取到 A 的值也为 10；<br> T1 执行修改操作，将 A 的值修改为 20；<br> T2 也执行修改操作，将 A 的值修改为 30；<br> 在这种情况下，最终 A 的值是 30，而不是按照顺序执行时的 20。</p> 
<p>然而，如果采用串行化控制，将 T1 和 T2 串行化执行，保证它们不会交叉执行，那么最终的结果将与串行执行的结果一致。具体的串行化执行过程如下：<br> T1 先执行读取操作，读取到 A 的值为 10；<br> T1 执行修改操作，将 A 的值修改为 20；<br> T2 在 T1 执行完毕后执行读取操作，读取到 A 的值为 20；<br> T2 执行修改操作，将 A 的值修改为 30；<br> 采用串行化控制后，最终 A 的值为 30，与串行执行的结果一致。</p> 
<p>可以通过对线程T1加锁，保证T1执行时候，T2不会产生干扰，达到串行效果。</p> 
<h3>
<a id="323_MESI_70"></a>3.2.3 MESI</h3> 
<p>通过事务的串行化，每当有核心修改数据，都需要广播给其他的核心。但是，并不是所有的核心都与这个数据相关。这样就会浪费带宽，代价比较大。接下来引入MESI来解决这个问题。</p> 
<p>MESI是一种缓存一致性协议，用于解决多核处理器中的缓存一致性问题。CPU 中每个缓存行（caceh line）都使用MESI进行标记，MESI是四种状态的缩写，分别代表了缓存行的不同状态：修改（Modified）、独占（Exclusive）、共享（Shared）和无效（Invalid）。</p> 
<p>1）修改（Modified）：当某个核心独占地拥有一块缓存行的数据时，如果该核心对缓存行进行了修改，那么该缓存行的状态为修改状态。同时，该核心对缓存行所做的修改还没有写回到主存中。</p> 
<p>2）独占（Exclusive）：如果某个核心独占地拥有一块缓存行的数据，并且该数据未被修改，那么该缓存行的状态为独占状态。此时，其他核心不能缓存该缓存行中的数据。</p> 
<p>3）共享（Shared）：当多个核心同时缓存同一块缓存行的数据时，该缓存行的状态为共享状态。多个核心可以同时读取该数据，但不能进行写操作。</p> 
<p>4）无效（Invalid）：如果某个核心的缓存中的数据与主存中的数据不一致，或者某个核心将共享缓存行标记为无效状态，那么该缓存行的状态就会变为无效状态。此时，其他核心不能使用该缓存行中的数据，必须从主存中获取最新的数据。</p> 
<h1>
<a id="_83"></a>四、原子操作</h1> 
<h2>
<a id="41__84"></a>4.1 什么是原子操作</h2> 
<p>原子操作是指在执行过程中不会被中断的操作，要么全部执行成功，要么全部不执行，不会出现部分执行的情况。原子操作可以看作是不可分割的单元， 运行期间不会有任何的上下文切换。</p> 
<p>1）在单核处理器上，原子操作可以通过禁止中断的方式来保证不被中断。当一个线程或进程执行原子操作时，可以通过禁用中断来确保原子性。在禁用中断期间，其他线程或进程无法打断当前线程或进程的执行，从而保证原子操作的完整性。</p> 
<p>2）在多核处理器上，原子操作的实现需要使用一些特殊的硬件机制或同步原语来保证原子性。以下是两种常见的方法：<br> 1、使用硬件原子指令：现代多核处理器通常支持硬件原子指令，例如CAS（Compare-And-Swap）指令。这样的指令允许对共享内存进行原子读取和写入操作。CAS指令会比较内存中的值与期望值，如果相等则执行写入操作，否则不执行。通过使用这样的原子指令，可以在多核处理器上实现原子操作。</p> 
<p>2、使用锁和同步原语：多核处理器上的原子操作可以通过锁来实现互斥访问。以往0x86，是直接锁总线，避免所有内存的访问。现在是只需要锁住相关的内存，比较其他核心对这块内存的访问。</p> 
<h2>
<a id="42_c__94"></a>4.2 c++ 标准库的原子类型</h2> 
<h3>
<a id="421_atomicT_95"></a>4.2.1 atomic&lt;T&gt;</h3> 
<p>atomic&lt;T&gt; 是 C++ 中的原子类型模板，用于实现原子操作。它提供了一种线程安全的方式来对特定类型的数据进行读取和写入，以及执行其他常见的原子操作，如增加（增量）和交换等。</p> 
<p>atomic&lt;T&gt; 提供了以下常用的成员函数和操作符：<br> 1）加载和存储操作：通过 load() 和 store() 方法可以实现从原子对象中加载值或将值存储到原子对象中。</p> 
<p>2）交换和比较交换操作：使用 exchange() 可以原子地将新值存储到原子对象中，并返回之前的值；使用 compare_exchange_strong() 或 compare_exchange_weak() 可以原子地比较并交换值。</p> 
<p>3）增减操作：使用 fetch_add() 和 fetch_sub() 可以原子地增加或减少原子对象的值，并返回之前的值。</p> 
<p>4）访问操作：除了上述操作，还可以使用 operator++、operator–、operator+=、operator-= 等操作符进行原子操作。</p> 
<h3>
<a id="422_is_lock_free_107"></a>4.2.2 is_lock_free()</h3> 
<p>用于检查原子类型是否是无锁（lock-free）的。它返回一个布尔值，指示原子类型是否可以在特定硬件平台上以无锁方式进行操作。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">is_lock_free</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果 is_lock_free() 返回 true，表示该原子类型可以在特定硬件平台上以无锁方式进行操作；如果返回 false，则表示该原子类型无法以无锁方式进行操作，需要使用锁或其他同步机制。</p> 
<h3>
<a id="423_load_117"></a>4.2.3 load()</h3> 
<p>获取原子对象中的当前值，并返回该值。它会保证在多线程环境下对数据的读取是原子的，即不会受到其他线程同时修改的干扰，保证了数据的一致性。</p> 
<pre><code class="prism language-cpp"><span class="token function">load</span><span class="token punctuation">(</span>memory_order order <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数 order 是一个可选参数，用于指定内存序（memory order）的类型，默认为 memory_order_seq_cst。内存序定义了原子操作的时序关系，决定了在多线程环境下对数据访问的可见性和有序性。</p> 
<h3>
<a id="424_store_124"></a>4.2.4 store()</h3> 
<p>用于原子地存储（写入）值到原子对象中。它可以将给定的值存储到原子对象中，并保证在多线程环境下的可见性和原子性。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">store</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> memory_order order <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数 value 是要存储到原子对象中的值，参数 order 是一个可选参数，用于指定内存序（memory order）的类型，默认为 memory_order_seq_cst。</p> 
<h3>
<a id="425_exchange_132"></a>4.2.5 exchange()</h3> 
<p>用于原子地交换原子对象中的值，并返回先前的值。它可以将给定的值与原子对象的当前值进行交换，并保证在多线程环境下的可见性和原子性。</p> 
<pre><code class="prism language-cpp"><span class="token function">exchange</span><span class="token punctuation">(</span>T desired<span class="token punctuation">,</span> memory_order order <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数 desired 是要与原子对象进行交换的值，参数 order 是一个可选参数，用于指定内存序（memory order）的类型，默认为 memory_order_seq_cst。</p> 
<h3>
<a id="426_compare_exchange_weak_140"></a>4.2.6 compare_exchange_weak()</h3> 
<p>用于原子地比较并交换原子对象的值。它可以比较原子对象的当前值与期望值，并在匹配时将新值存储到原子对象中。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> expected<span class="token punctuation">,</span> T desired<span class="token punctuation">,</span>
                           memory_order success<span class="token punctuation">,</span> memory_order failure<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数 expected 是对原子对象进行比较的期望值，并且在返回时被更新为原子对象的当前值。参数 desired 是要存储到原子对象中的新值。参数 success 和 failure 分别指定了成功和失败情况下的内存序（memory order）类型，默认为 memory_order_seq_cst。</p> 
<p>返回值是一个 bool 类型，表示是否成功执行了比较和交换操作。如果比较的值与期望值相等，则交换成功，返回 true，否则交换失败，返回 false。</p> 
<p>weak版本的CAS允许偶然出乎意料的返回（比如在字段值和期待值一样的时候却返回了false），不过在一些循环算法中，这是可以接受的。通常它比起strong有更高的性能。</p> 
<p>举个例子<br> a.compare_exchange_weak(b,c)其中a是当前值，b期望值，c新值<br> a==b时：函数返回真，并把c赋值给a<br> a!=b时：函数返回假，并把a复制给b</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span>       <span class="token comment">// std::cout</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span>         <span class="token comment">// std::atomic, std::atomic_flag, ATOMIC_FLAG_INIT</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//相等案例</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">//a==b</span>
    <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"a:"</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        b<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
        c<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"a true:"</span><span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"a:"</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" b:"</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span><span class="token string">" c:"</span><span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


a<span class="token operator">:</span><span class="token number">10</span>
a <span class="token boolean">true</span><span class="token operator">:</span><span class="token number">20</span>
a<span class="token operator">:</span><span class="token number">20</span> b<span class="token operator">:</span><span class="token number">10</span> c<span class="token operator">:</span><span class="token number">20</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//不等案例</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">//a!=b</span>
    <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"a:"</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token operator">!</span>a<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        b<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
        c<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"a true:"</span><span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"a:"</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" b:"</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span><span class="token string">" c:"</span><span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
a<span class="token operator">:</span><span class="token number">10</span>
a<span class="token operator">:</span><span class="token number">10</span> b<span class="token operator">:</span><span class="token number">10</span> c<span class="token operator">:</span><span class="token number">20</span>
</code></pre> 
<h3>
<a id="427_compare_exchange_strong_206"></a>4.2.7 compare_exchange_strong()</h3> 
<p>强化版的CAS，如果需要保证严格的原子性，则应该使用 compare_exchange_strong 函数。其他根weak版一样。</p> 
<p>compare_exchange_strong ------------ 会阻塞cpu, 会慢一些<br> compare_exchange_weak --------------- 有可能失败，性能高, 可以加while直到它成功</p> 
<h1>
<a id="_213"></a>五、内存序问题</h1> 
<h2>
<a id="51__214"></a>5.1 什么是内存序问题</h2> 
<p>内存序（memory order）问题是由于多线程的并行执行可能导致的对共享变量的读写操作无法按照程序员预期的顺序进行。<br> 简单来说，编译器为了提高运算速度，有时候会做出违背代码原有顺序的优化。虽然顺序改变了，但执行的结果不会变。比如下面一段代码</p> 
<pre><code class="prism language-cpp">    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
    i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">;</span>
    j<span class="token operator">+=</span><span class="token number">3</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们以为执行顺序是从上往下，但编译器任务i和j没有关联，可能会优化成</p> 
<pre><code class="prism language-cpp">    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
    j<span class="token operator">+=</span><span class="token number">3</span><span class="token punctuation">;</span>
</code></pre> 
<p>在单核处理器的情况下，这种优化没问题，因为执行的结果不会变。但是如果是多核处理器，多线程并行执行，就会出现一些难以预知的问题。比如编译器和处理器可能会重排共享变量的写操作，使得其中一个线程的写操作先于另一个线程的写操作执行。这样会导致增量值丢失或重复计算，最终的结果可能小于预期的值。</p> 
<p>总结来说，就是编译器和CPU会优化重排指令，改变原始程序中指令的执行顺序。这可能会导致多线程间的竞态条件和数据依赖关系出现问题，从而使得程序的行为产生难以预测的结果。</p> 
<p>需要使用适当的内存序来指定对共享变量的读写操作的顺序和同步行为。</p> 
<h2>
<a id="52__238"></a>5.2 内存序</h2> 
<p>内存徐规定了多个线程访问同一个内存地址的语义，即<br> 1）某个线程对内存地址的更新何时能被其他线程看见；<br> 2）某个线程对内存地址访问附近可以做怎么样的优化；</p> 
<h3>
<a id="521_memory_order_relaxed_242"></a>5.2.1. memory_order_relaxed</h3> 
<p>松散内存序，只用来保证对原子对象的操作是原子的，在不需要保证顺序时使用。（保证原子性，不保证顺序性和同步性）<br> <img src="https://images2.imgbox.com/d7/1f/w7BKMl1C_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="522_memory_order_release_245"></a>5.2.2. memory_order_release</h3> 
<p>释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见。（保证原子性和同步性，顺序是当前线程的前面不能写到后面；但当前线程的后面可以写到前面）</p> 
<p><img src="https://images2.imgbox.com/8e/11/OGyM76uL_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1f/1d/z2pd5LFt_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="523_memory_order_acquire_250"></a>5.2.3. memory_order_acquire</h3> 
<p>获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见。（保证原子性和同步性，顺序是当前线程的后面不能写到前面；但当前线程的前面可以写到后面）<br> <img src="https://images2.imgbox.com/8b/d4/8nxfZuIG_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/92/71/vRNXqkif_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="524_memory_order_acq_rel_255"></a>5.2.4. memory_order_acq_rel</h3> 
<p>获得释放操作，一个读‐修改‐写操作同时具有获得语义和释放语义，即它前后的任何读写操作都不允许重排，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见，当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见；</p> 
<h3>
<a id="525_memory_order_seq_cst_257"></a>5.2.5. memory_order_seq_cst</h3> 
<p>顺序一致性语义，对于读操作相当于获得，对于写操作相当于释放，对于读‐修改‐写操作相当于获得释放，是所有原子操作的默认内存序，并且会对所有使用此模型的原子操作建立一个全局顺序，保证了多个原子变量的操作在所有线程里观察到的操作顺序相同，当然它是最慢的同步模型。</p> 
<h2>
<a id="53__260"></a>5.3 内存屏障</h2> 
<p>内存屏障（Memory Barrier）是一种硬件或软件指令，用于控制处理器和内存系统中对内存操作的重新排序和优化。它们的作用是确保在屏障之前和之后的内存访问按照预期的顺序进行。</p> 
<p>内存屏障主要有两种类型：读屏障（Read Barrier）和写屏障（Write Barrier）。</p> 
<p>读屏障（也称为加载屏障）：确保在读取一个变量的值之前，所有之前的读取操作和加载操作都已经完成。这可以防止读取过期的或无效的数据。</p> 
<p>写屏障（也称为存储屏障）：确保在写入一个变量的值之前，所有之前的写入操作和存储操作都已经完成。这可以防止将新的值预先存储到缓存而不是实际写入到内存中。</p> 
<p>内存屏障的使用可以避免在多线程或并发环境下出现的一些问题，例如数据竞争、乱序执行和原子操作的正确性。通过插入内存屏障，可以使得代码在一个屏障之前或之后的内存访问按照预期的顺序执行，从而确保正确的内存可见性和一致性。</p> 
<h3>
<a id="531atomic_thread_fence_271"></a>5.3.1atomic_thread_fence()</h3> 
<p>创建一个内存屏障（memory barrier），用于限制内存访问的重新排序和优化。它可以保证在屏障之前的所有内存操作都在屏障完成之前完成。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">atomic_thread_fence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order order<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>常见的 memory_order 参数包括：<br> std::memory_order_relaxed：最轻量级的内存顺序，允许重排和优化。<br> std::memory_order_acquire：在屏障之前的内存读操作必须在屏障完成之前完成。<br> std::memory_order_release：在屏障之前的内存写操作必须在屏障完成之前完成。<br> std::memory_order_acq_rel：同时具有 acquire 和 release 语义，适用于同时进行读写操作的屏障。<br> std::memory_order_seq_cst：对于读操作相当于获得，对于写操作相当于释放。</p> 
<h1>
<a id="_283"></a>六、测试代码</h1> 
<h2>
<a id="61__284"></a>6.1 多线程加锁</h2> 
<p>四个线程，每个线程实现count++ 500次。最后结果应该是cout = 2000；<br> 在没有加锁的情况下，会出现cout ≠ 2000<br> <img src="https://images2.imgbox.com/14/6c/PXunjOvA_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">USE_ATOMIC</span> <span class="token expression"><span class="token number">1</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">USE_MUTEX</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
    std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">USE_SPINLOCK</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"spinlock.h"</span></span>
    <span class="token keyword">using</span> spinlock_t <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token class-name">spinlock</span><span class="token punctuation">;</span>
    spinlock_t spin<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">USE_ATOMIC</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> count<span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>


<span class="token keyword">void</span> <span class="token function">incrby</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">USE_MUTEX</span></span>
        mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>count<span class="token punctuation">;</span>
        mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">USE_SPINLOCK</span></span>
        <span class="token function">spinlock_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>count<span class="token punctuation">;</span>
        <span class="token function">spinlock_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spin<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">USE_ATOMIC</span></span>
        count<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
        <span class="token operator">++</span>count<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">USE_SPINLOCK</span></span>
        <span class="token function">spinlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spin<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">USE_ATOMIC</span></span>
        count<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
        count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        std<span class="token double-colon punctuation">::</span>thread <span class="token function">a</span><span class="token punctuation">(</span>incrby<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>thread <span class="token function">b</span><span class="token punctuation">(</span>incrby<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>thread <span class="token function">c</span><span class="token punctuation">(</span>incrby<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>thread <span class="token function">d</span><span class="token punctuation">(</span>incrby<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        d<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">USE_ATOMIC</span></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">2000</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">2000</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i:"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" count:"</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="62__364"></a>6.2 内存序问题</h2> 
<p>1）实现功能：<br> 初始x，y都为false；z为0；<br> 线程a：先将x写为true，再将y写为true<br> 线程b：自旋等待，知道读到的y为true，再判断达到x是否为true，若x为true，++z</p> 
<p>2）若函数<code>write_x_then_y()</code>和<code>read_y_then_x()</code>的内存序如下<br> <img src="https://images2.imgbox.com/5b/5c/ZTnvbquh_o.png" alt="在这里插入图片描述"></p> 
<p>则在极少数情况下，结果z不为1.<br> 这是因为<code>memory_order_relaxed</code>不保证执行顺序，因此编译器和处理器可能会优化重排。此时会出现一种执行顺序：4~&gt; 1 ~&gt; 2 ~&gt; 3 。</p> 
<p>这就是线程b中对共享变量y的读操作，先于线程a对y的写操作执行。这样会导致某个线程读取到较旧的值，而不是最新的值，影响最终结果的准确性。</p> 
<p>3）若函数<code>write_x_then_y()</code>和<code>read_y_then_x()</code>的内存序如下<br> <img src="https://images2.imgbox.com/7c/5a/VHAgcYoC_o.png" alt="在这里插入图片描述"><br> 这时结果z一定为1。<br> 这是因为内存序<code>memory_order_release</code>有顺序性，保守当前线程前面的操作不能优化到后面，即1一定在2前面。并且还有同步性，即2若执行了，1一定执行了。<br> 内存序<code>memory_order_acquire</code>有顺序性，保守当前线程后面的操作不能优化到前面，即3一定在4前面.</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> z<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">write_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1 </span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2   y = true x= true</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">read_y_then_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3 自旋，等待y被设置为true</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 4</span>
        <span class="token operator">++</span>z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    x<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    y<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    z<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">a</span><span class="token punctuation">(</span>write_x_then_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">b</span><span class="token punctuation">(</span>read_y_then_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="63__420"></a>6.3 多线程同步问题</h2> 
<p>实现功能：<br> 创建2个线程，线程t1执行i从0加到9999，结果按原子操作写入x；线程t2执行i从0减到-9999，结果按原子操作写入x；最后打印出x的值。</p> 
<h3>
<a id="631__424"></a>6.3.1 问题</h3> 
<p>代码1的执行结果如图，结果出现错乱。有时候是9999，有时候是-9999。这是因为两个线程将结果存入主存的顺序是不确定的。<br> <img src="https://images2.imgbox.com/68/05/8cCm6PJI_o.png" alt="在这里插入图片描述"><br> 代码1</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">thread_func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">thread_func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token operator">-</span>i<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>thread_func1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>thread_func2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Final value of x = "</span> <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3>
<a id="632__467"></a>6.3.2 解法一：标志位</h3> 
<p>代码2通过添加一个标志位来控制线程t1的执行<br> <img src="https://images2.imgbox.com/70/ab/HvQUhlc5_o.png" alt="在这里插入图片描述"><br> 代码2</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">t1_finished</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 标志位，表示线程t1是否已完成</span>

<span class="token keyword">void</span> <span class="token function">thread_func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    t1_finished<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在线程t1完成后设置标志位为true</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">thread_func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>t1_finished<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 检查标志位，如果线程t1未完成，则等待</span>
    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token operator">-</span>i<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>thread_func1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>thread_func2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Final value of x = "</span> <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3>
<a id="633__517"></a>6.3.3 解法二：互斥锁</h3> 
<p>代码3，在线程t2中，每次修改x之前使用了std::lock_guardstd::mutex来自动加锁，以确保线程t2的操作在同一时刻只有一个线程进行。这样就能够保证最后只输出线程t2的结果。<br> 代码3</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span> <span class="token comment">// 互斥锁</span>

<span class="token keyword">void</span> <span class="token function">thread_func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">thread_func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加锁</span>
        x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token operator">-</span>i<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>thread_func1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>thread_func2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Final value of x = "</span> <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3>
<a id="634__562"></a>6.3.4 解法三：内存屏障</h3> 
<p>在线程t2的循环中插入了std::atomic_thread_fence(std::memory_order_release)内存屏障指令。该指令用于确保在执行x.store(-i, std::memory_order_relaxed)之前的所有先行写操作对于其它线程的读操作都可见。这样我们就能够保证最终只输出线程t2的结果。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">thread_func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">thread_func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token operator">-</span>i<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">atomic_thread_fence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 插入内存屏障</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>thread_func1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>thread_func2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Final value of x = "</span> <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


</code></pre>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>