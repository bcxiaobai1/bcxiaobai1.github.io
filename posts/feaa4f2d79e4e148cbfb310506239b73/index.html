<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>以太坊NFT代码示例（合约地址0x6d2e83a559c1fbe0cc677d10a22f28f0f8b1f325） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">以太坊NFT代码示例（合约地址0x6d2e83a559c1fbe0cc677d10a22f28f0f8b1f325）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p>pragma solidity ^0.4.21;</p> 
<p>/**<br>  * @title Ownable<br>  * @dev The Ownable contract has an owner address, and provides basic authorization control<br>  * functions, this simplifies the implementation of "user permissions".<br>  */<br> contract Ownable {<!-- --><br>   address public owner;</p> 
<p><br>   /**<br>    * @dev The Ownable constructor sets the original `owner` of the contract to the sender<br>    * account.<br>    */<br>   function Ownable() {<!-- --><br>     owner = msg.sender;<br>   }</p> 
<p><br>   /**<br>    * @dev Throws if called by any account other than the owner.<br>    */<br>   modifier onlyOwner() {<!-- --><br>     require(msg.sender == owner);<br>     _;<br>   }</p> 
<p><br>   /**<br>    * @dev Allows the current owner to transfer control of the contract to a newOwner.<br>    * @param newOwner The address to transfer ownership to.<br>    */<br>   function transferOwnership(address newOwner) onlyOwner {<!-- --><br>     if (newOwner != address(0)) {<!-- --><br>       owner = newOwner;<br>     }<br>   }</p> 
<p>}</p> 
<p>/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens</p> 
<p>contract ERC721 {<!-- --><br>     // Required methods<br>     function totalSupply() public view returns (uint256 total);<br>     function balanceOf(address _owner) public view returns (uint256 balance);<br>     function ownerOf(uint256 _tokenId) external view returns (address owner);<br>     function approve(address _to, uint256 _tokenId) external;<br>     function transfer(address _to, uint256 _tokenId) external;<br>     function transferFrom(address _from, address _to, uint256 _tokenId) external;</p> 
<p>    // Events<br>     event Transfer(address from, address to, uint256 tokenId);<br>     event Approval(address owner, address approved, uint256 tokenId);</p> 
<p>    <br> }</p> 
<p>/// @title A facet of MyFishCore that manages special access privileges.</p> 
<p>/// @dev See the MyFishCore contract documentation to understand how the various contract facets are arranged.<br> contract MyFishAccessControl {<!-- --><br>     // This facet controls access control for CryptoMyFish. There are four roles managed here:<br>     //<br>     //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart<br>     //         contracts. It is also the only role that can unpause the smart contract. It is initially<br>     //         set to the address that created the smart contract in the MyFishCore constructor.<br>     //<br>     //     - The CFO: The CFO can withdraw funds from MyFishCore and its auction contracts.<br>     //<br>     //     - The COO: The COO can release genesis MyFish to auction.<br>     //<br>     // It should be noted that these roles are distinct without overlap in their access abilities, the<br>     // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any<br>     // address to any role, the CEO address itself doesn't have the ability to act in those roles. This<br>     // restriction is intentional so that we aren't tempted to use the CEO address frequently out of<br>     // convenience. The less we use an address, the less likely it is that we somehow compromise the<br>     // account.<br>     address newContractAddress;<br>     /// @dev Emited when contract is upgraded - See README.md for updgrade plan<br>     event ContractUpgrade(address newContract);</p> 
<p>    // The addresses of the accounts (or contracts) that can execute actions within each roles.<br>     address public ceoAddress;<br>     address public cfoAddress;<br>     address public cooAddress;</p> 
<p>    <br>     <br>   </p> 
<p>    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked<br>     bool public paused = false;</p> 
<p>    /// @dev Access modifier for CEO-only functionality<br>     modifier onlyCEO() {<!-- --><br>         require(msg.sender == ceoAddress);<br>         _;<br>     }</p> 
<p>    /// @dev Access modifier for CFO-only functionality<br>     modifier onlyCFO() {<!-- --><br>         require(msg.sender == cfoAddress);<br>         _;<br>     }</p> 
<p>    /// @dev Access modifier for COO-only functionality<br>     modifier onlyCOO() {<!-- --><br>         require(msg.sender == cooAddress);<br>         _;<br>     }</p> 
<p>    modifier onlyCLevel() {<!-- --><br>         require(<br>             msg.sender == cooAddress ||<br>             msg.sender == ceoAddress ||<br>             msg.sender == cfoAddress<br>         );<br>         _;<br>     }</p> 
<p>    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.<br>     /// @param _newCEO The address of the new CEO<br>     function setCEO(address _newCEO) external onlyCEO {<!-- --><br>         require(_newCEO != address(0));</p> 
<p>        ceoAddress = _newCEO;<br>     }</p> 
<p>    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.<br>     /// @param _newCFO The address of the new CFO<br>     function setCFO(address _newCFO) external onlyCEO {<!-- --><br>         require(_newCFO != address(0));</p> 
<p>        cfoAddress = _newCFO;<br>     }</p> 
<p>    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.<br>     /// @param _newCOO The address of the new COO<br>     function setCOO(address _newCOO) external onlyCEO {<!-- --><br>         require(_newCOO != address(0));</p> 
<p>        cooAddress = _newCOO;<br>     }</p> 
<p>    /*** Pausable functionality adapted from OpenZeppelin ***/</p> 
<p>    /// @dev Modifier to allow actions only when the contract IS NOT paused<br>     modifier whenNotPaused() {<!-- --><br>         require(!paused);<br>         _;<br>     }</p> 
<p>    /// @dev Modifier to allow actions only when the contract IS paused<br>     modifier whenPaused {<!-- --><br>         require(paused);<br>         _;<br>     }</p> 
<p>    /// @dev Called by any "C-level" role to pause the contract. Used only when<br>     ///  a bug or exploit is detected and we need to limit damage.<br>     function pause() public onlyCLevel whenNotPaused {<!-- --><br>         paused = true;<br>     }</p> 
<p>    /// @dev Unpauses the smart contract. Can only be called by the CEO, since<br>     ///  one reason we may pause the contract is when CFO or COO accounts are<br>     ///  compromised.<br>     /// @notice This is public rather than external so it can be called by<br>     ///  derived contracts.<br>     function unpause() public onlyCEO whenPaused {<!-- --><br>         // can't unpause if contract was upgraded<br>         paused = false;<br>     }<br> }</p> 
<p><br> /// @title Base contract for CryptoMyFish. Holds all common structs, events and base variables.</p> 
<p>/// @dev See the MyFishCore contract documentation to understand how the various contract facets are arranged.<br> contract MyFishBase is MyFishAccessControl {<!-- --><br>     /*** EVENTS ***/</p> 
<p>    /// @dev The Birth event is fired whenever a new MyFish comes into existence. This obviously<br>     ///  includes any time a MyFish is created through the giveBirth method, but it is also called<br>     ///  when a new MyFishis created.<br>     event Birth(address owner, uint256 myFishId, uint8 level,uint8 quality,uint8 starlevel,uint8 growup, uint8 skill,uint8 genius, uint16 strength, uint16 agility, uint16 power);</p> 
<p>    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a MyFish<br>     ///  ownership is assigned, including births.<br>     event Transfer(address from, address to, uint256 tokenId);</p> 
<p>    /*** DATA TYPES ***/</p> 
<p>    /// @dev The main MyFish struct. Every MyFish in CryptoMyFish is represented by a copy<br>     ///  of this structure, so great care was taken to ensure that it fits neatly into<br>     ///  exactly two 256-bit words. Note that the order of the members in this structure<br>     ///  is important because of the byte-packing rules used by Ethereum.<br>     ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html<br>     struct MyFish {<!-- --><br>         uint8 level;<br>     <br>     uint8 quality;<br>     uint8 starlevel;<br>     uint8 growup;<br>     <br>     uint8 skill;<br>     uint8 genius;</p> 
<p>    uint16 strength;<br>     uint16 agility;<br>     uint16 power;</p> 
<p>    bool eated; <br>     }</p> 
<p>    /*** CONSTANTS ***/</p> 
<p>    </p> 
<p>    /*** STORAGE ***/</p> 
<p>    /// @dev An array containing the MyFish struct for all MyFishes in existence. The ID<br>     ///  of each MyFish is actually an index into this array. <br>     MyFish[] myFishes;</p> 
<p>    /// @dev A mapping from MyFish IDs to the address that owns them. All MyFish have<br>     ///  some valid owner address<br>     mapping (uint256 =&gt; address) public myFishIndexToOwner;</p> 
<p>    // @dev A mapping from owner address to count of tokens that address owns.<br>     //  Used internally inside balanceOf() to resolve ownership count.<br>     mapping (address =&gt; uint256) ownershipTokenCount;</p> 
<p>    /// @dev A mapping from MyFishIDs to an address that has been approved to call<br>     ///  transferFrom(). Each MyFish can only have one approved address for transfer<br>     ///  at any time. A zero value means no approval is outstanding.<br>     mapping (uint256 =&gt; address) public myFishIndexToApproved;</p> 
<p>    <br>     /// @dev Assigns ownership of a specific MyFish to an address.<br>     function _transfer(address _from, address _to, uint256 _tokenId) internal {<!-- --><br>         // has been eated fish can not transfer<br>         MyFish memory fish = myFishes[_tokenId];<br>         require(fish.eated == false);<br>         // Since the number of MyFish is capped to 2^32 we can't overflow this<br>         ownershipTokenCount[_to]++;<br>         // transfer ownership<br>         myFishIndexToOwner[_tokenId] = _to;<br>         // When creating new MyFish _from is 0x0, but we can't account that address.<br>         if (_from != address(0)) {<!-- --><br>             ownershipTokenCount[_from]--;<br>             // clear any previously approved ownership exchange<br>             delete myFishIndexToApproved[_tokenId];<br>         }<br>         // Emit the transfer event.<br>         Transfer(_from, _to, _tokenId);<br>     }</p> 
<p>    /// @dev An internal method that creates a new MyFish and stores it. This<br>     ///  method doesn't do any checking and should only be called when the<br>     ///  input data is known to be valid. Will generate both a Birth event<br>     ///  and a Transfer event.<br>     /// @param _owner The inital owner of this MyFish, must be non-zero <br>     function _createMyFish(<br>         uint8 _level,uint8 _quality,uint8 _starlevel,uint8 _growup, uint8 _skill,uint8 _genius, uint16 _strength, uint16 _agility, uint16 _power,<br>         address _owner<br>     )<br>         internal<br>         onlyCLevel whenNotPaused<br>         returns (uint)<br>     {<!-- --><br>         require(_owner != address(0));<br>         // require(_level != 0);<br>         MyFish memory _myFish = MyFish({<!-- --><br>             level: _level,<br>             quality: _quality,<br>             starlevel: _starlevel,<br>             growup: _growup,<br>             skill: _skill,<br>             genius: _genius,<br>             strength: _strength,<br>             agility: _agility,<br>             power: _power,<br>             eated: false<br>         });<br>         uint256 newMyFishId = myFishes.push(_myFish) - 1;</p> 
<p>        </p> 
<p>        // emit the birth event<br>         <br>         Birth(<br>             _owner,<br>             newMyFishId,<br>             _myFish.level,<br>             _myFish.quality,<br>             _myFish.starlevel,<br>             _myFish.growup,<br>             _myFish.skill,<br>             _myFish.genius,<br>             _myFish.strength,<br>             _myFish.agility,<br>             _myFish.power<br>         );</p> 
<p>        // This will assign ownership, and also emit the Transfer event as<br>         // per ERC721 draft<br>         _transfer(0, _owner, newMyFishId);</p> 
<p>        return newMyFishId;<br>     }<br> }</p> 
<p>/// @title The facet of the CryptoMyFish core contract that manages ownership, ERC-721 (draft) compliant.</p> 
<p>/// @dev Ref: https://github.com/ethereum/EIPs/issues/721<br> ///  See the MyFishCore contract documentation to understand how the various contract facets are arranged.<br> contract MyFishOwnership is MyFishBase, ERC721 {<!-- --></p> 
<p>    /// @notice Name and symbol of the non fungible token, as defined in ERC721.<br>     string public constant name = "MyFish";<br>     string public constant symbol = "MF";</p> 
<p>    // Internal utility functions: These functions all assume that their input arguments<br>     // are valid. We leave it to public methods to sanitize their inputs and follow<br>     // the required logic.</p> 
<p>    /// @dev Checks if a given address is the current owner of a particular MyFish.<br>     /// @param _claimant the address we are validating against.<br>     /// @param _tokenId MyFish id, only valid when &gt; 0<br>     function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {<!-- --><br>         return myFishIndexToOwner[_tokenId] == _claimant;<br>     }</p> 
<p>    /// @dev Checks if a given address currently has transferApproval for a particular MyFish.<br>     /// @param _claimant the address we are confirming MyFish is approved for.<br>     /// @param _tokenId MyFish id, only valid when &gt; 0<br>     function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {<!-- --><br>         return myFishIndexToApproved[_tokenId] == _claimant;<br>     }</p> 
<p>    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous<br>     ///  approval. Setting _approved to address(0) clears all transfer approval.<br>     ///  NOTE: _approve() does NOT send the Approval event. This is intentional because<br>     ///  _approve() and transferFrom() are used together for putting MyFishes on auction, and<br>     ///  there is no value in spamming the log with Approval events in that case.<br>     function _approve(uint256 _tokenId, address _approved) internal {<!-- --><br>         myFishIndexToApproved[_tokenId] = _approved;<br>     }</p> 
<p>    /// @notice Returns the number of MyFishes owned by a specific address.<br>     /// @param _owner The owner address to check.<br>     /// @dev Required for ERC-721 compliance<br>     function balanceOf(address _owner) public view returns (uint256 count) {<!-- --><br>         return ownershipTokenCount[_owner];<br>     }</p> 
<p>    /// @notice Transfers a MyFish to another address. If transferring to a smart<br>     ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or<br>     ///  CryptoMyFish specifically) or your MyFish may be lost forever. Seriously.<br>     /// @param _to The address of the recipient, can be a user or contract.<br>     /// @param _tokenId The ID of the MyFish to transfer.<br>     /// @dev Required for ERC-721 compliance.<br>     function transfer(<br>         address _to,<br>         uint256 _tokenId<br>     )<br>         external<br>         whenNotPaused<br>     {<!-- --><br>         // Safety check to prevent against an unexpected 0x0 default.<br>         require(_to != address(0));<br>         // Disallow transfers to this contract to prevent accidental misuse.<br>         // The contract should never own any MyFish .<br>         require(_to != address(this));<br>         </p> 
<p>        // You can only send your own MyFish.<br>         require(_owns(msg.sender, _tokenId));</p> 
<p>        // Reassign ownership, clear pending approvals, emit Transfer event.<br>         _transfer(msg.sender, _to, _tokenId);<br>     }</p> 
<p>    /// @notice Grant another address the right to transfer a specific MyFish via<br>     ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.<br>     /// @param _to The address to be granted transfer approval. Pass address(0) to<br>     ///  clear all approvals.<br>     /// @param _tokenId The ID of the MyFish that can be transferred if this call succeeds.<br>     /// @dev Required for ERC-721 compliance.<br>     function approve(<br>         address _to,<br>         uint256 _tokenId<br>     )<br>         external<br>         whenNotPaused<br>     {<!-- --><br>         // Only an owner can grant transfer approval.<br>         require(_owns(msg.sender, _tokenId));</p> 
<p>        // Register the approval (replacing any previous approval).<br>         _approve(_tokenId, _to);</p> 
<p>        // Emit approval event.<br>         Approval(msg.sender, _to, _tokenId);<br>     }</p> 
<p>    /// @notice Transfer a MyFish owned by another address, for which the calling address<br>     ///  has previously been granted transfer approval by the owner.<br>     /// @param _from The address that owns the MyFish to be transfered.<br>     /// @param _to The address that should take ownership of the MyFish. Can be any address,<br>     ///  including the caller.<br>     /// @param _tokenId The ID of the MyFish to be transferred.<br>     /// @dev Required for ERC-721 compliance.<br>     function transferFrom(<br>         address _from,<br>         address _to,<br>         uint256 _tokenId<br>     )<br>         external<br>         whenNotPaused<br>     {<!-- --><br>         // Safety check to prevent against an unexpected 0x0 default.<br>         require(_to != address(0));<br>         // Disallow transfers to this contract to prevent accidental misuse.<br>         // The contract should never own any MyFish (except very briefly<br>         // after a MyFish is created and before it goes on auction).<br>         require(_to != address(this));<br>         // Check for approval and valid ownership<br>         require(_approvedFor(msg.sender, _tokenId));<br>         require(_owns(_from, _tokenId));</p> 
<p>        // Reassign ownership (also clears pending approvals and emits Transfer event).<br>         _transfer(_from, _to, _tokenId);<br>     }</p> 
<p>    /// @notice Returns the total number of MyFishes currently in existence.<br>     /// @dev Required for ERC-721 compliance.<br>     function totalSupply() public view returns (uint) {<!-- --><br>         return myFishes.length ;<br>     }</p> 
<p>    /// @notice Returns the address currently assigned ownership of a given MyFish.<br>     /// @dev Required for ERC-721 compliance.<br>     function ownerOf(uint256 _tokenId)<br>         external<br>         view<br>         returns (address owner)<br>     {<!-- --><br>         owner = myFishIndexToOwner[_tokenId];</p> 
<p>        require(owner != address(0));<br>     }</p> 
<p>    /// @notice Returns a list of all MyFish IDs assigned to an address.<br>     /// @param _owner The owner whose MyFishes we are interested in.<br>     /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly<br>     ///  expensive (it walks the entire MyFish array looking for MyFish belonging to owner),<br>     ///  but it also returns a dynamic array, which is only supported for web3 calls, and<br>     ///  not contract-to-contract calls.<br>     function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {<!-- --><br>         uint256 tokenCount = balanceOf(_owner);</p> 
<p>        if (tokenCount == 0) {<!-- --><br>             // Return an empty array<br>             return new uint256[](0);<br>         } else {<!-- --><br>             uint256[] memory result = new uint256[](tokenCount);<br>             uint256 totalMyFish = totalSupply();<br>             uint256 resultIndex = 0;</p> 
<p>            // We count on the fact that all MyFish have IDs starting at 1 and increasing<br>             // sequentially up to the totalMyFish count.<br>             uint256 myFishId;</p> 
<p>            for (myFishId = 0; myFishId &lt; totalMyFish; myFishId++) {<!-- --><br>                 if (myFishIndexToOwner[myFishId] == _owner) {<!-- --><br>                     result[resultIndex] = myFishId;<br>                     resultIndex++;<br>                 }<br>             }</p> 
<p>            return result;<br>         }<br>     }</p> 
<p>    <br> }</p> 
<p><br> /// @title all functions related to creating MyFish<br> contract MyFishMinting is MyFishOwnership  {<!-- --></p> 
<p>    // Limits the number of genesis MyFish .<br>     uint256 public constant GENESIS_CREATION_LIMIT = 100;</p> 
<p>    <br>     // Counts the number of genesis MyFish the contract owner has created.<br>     uint256 public genesisCreatedCount = 0;</p> 
<p>    /// @dev we can create genesis MyFish, up to a limit. Only callable by COO<br>     /// <br>     ///<br>     function createGenesisMyFish(uint myCount) public onlyCEO {<!-- --><br>         require(genesisCreatedCount &lt; GENESIS_CREATION_LIMIT);<br>         uint256 myFishId;</p> 
<p>        for (myFishId = 0; myFishId &lt; myCount; myFishId++) {<!-- --><br>             require(genesisCreatedCount &lt; GENESIS_CREATION_LIMIT);<br>             _createMyFish(<br>                 0,<br>                 0,<br>                 0,<br>                 0,<br>                 0,0,0,0,0,<br>                 ceoAddress<br>             );            <br>             genesisCreatedCount++;<br>         }<br>     }<br> }</p> 
<p><br> /// @title CryptoMyFishes on the Ethereum blockchain.</p> 
<p>/// @dev The main CryptoMyFishes contract, keeps track of MyFish so they don't wander around and get lost.<br> contract MyFishCore is MyFishMinting {<!-- --><br>     <br>     /// @notice Creates the main MyFishes smart contract instance.<br>     function MyFishCore() public {<!-- --><br>         // Starts paused.<br>         // paused = true;</p> 
<p>        // the creator of the contract is the initial CEO<br>         ceoAddress = msg.sender;</p> 
<p>        // the creator of the contract is also the initial COO<br>         cooAddress = msg.sender;<br>         cfoAddress = msg.sender;</p> 
<p>        <br>     }<br>     <br>     <br>     /// @dev Used to mark the smart contract as upgraded, in case there is a serious<br>     ///  breaking bug. This method does nothing but keep track of the new contract and<br>     ///  emit a message indicating that the new address is set. It's up to clients of this<br>     ///  contract to update to the new contract address in that case. (This contract will<br>     ///  be paused indefinitely if such an upgrade takes place.)<br>     /// @param _v2Address new address<br>     function setNewAddress(address _v2Address) external onlyCEO whenPaused {<!-- --><br>         // See README.md for updgrade plan<br>         newContractAddress = _v2Address;<br>         ContractUpgrade(_v2Address);<br>     }</p> 
<p>    <br>     /// @notice Returns all the relevant information about a specific MyFish.<br>     /// @param _id The ID of the MyFish of interest.<br>     function getMyFish(uint256 _id)<br>         external<br>         view<br>         returns (<br>         uint8 level,<br>         uint8 quality,<br>         uint8 starlevel,<br>         uint8 growup,<br>         uint8 skill,<br>         uint8 genius,<br>         uint16 strength,<br>         uint16 agility,<br>         uint16 power,<br>         bool eated<br>     ) {<!-- --><br>         MyFish storage fish = myFishes[_id];<br>         level = fish.level;<br>         quality = fish.quality;<br>         starlevel = fish.starlevel;<br>         growup = fish.growup;<br>         skill = fish.skill;<br>         genius = fish.genius;<br>         strength = fish.strength;<br>         agility = fish.agility;<br>         power = fish.power;<br>         eated = fish.eated;<br>         <br>     }</p> 
<p>    <br>     // @dev Allows the CFO to capture the balance available to the contract.<br>     function withdrawBalance() external onlyCFO {<!-- --><br>         uint256 balance = this.balance;<br>         cfoAddress.send(balance);<br>  <br>     }<br>     <br>     event UpdateMyFish(uint id,uint8 level,uint8 quality,uint8 starlevel,uint8 growup, uint8 skill,uint8 genius,uint16 strength, uint16 agility, uint16 power, bool eated);        <br>     <br>     //@dev if level==0 or fish.level==0, do not change level<br>     // if fish.level==0 ,do not eated<br>     function updateMyFish(uint _id,uint8 _level,uint8 _quality,uint8 _starlevel,uint8 _growup, uint8 _skill,uint8 _genius, uint16 _strength, uint16 _agility, uint16 _power, bool _eated) public onlyCLevel {<!-- --><br>          require(myFishIndexToOwner[_id] != address(0));<br>          MyFish storage fish = myFishes[_id];<br>          require(fish.eated != true);<br>          if( (fish.level !=0) &amp;&amp; (_level != 0) ) {<!-- --><br>             fish.level = _level;<br>          }<br>          fish.quality = _quality;<br>          fish.starlevel = _starlevel;<br>          fish.growup = _growup;<br>          fish.skill = _skill;<br>          fish.genius = _genius;<br>          fish.strength = _strength;<br>          fish.agility = _agility;<br>          fish.power = _power;<br>          if (fish.level != 0) {<!-- --><br>             fish.eated = _eated;<br>          }<br>          UpdateMyFish(_id,_level,_quality,_starlevel,_growup,_skill,_genius,_strength,_agility,_power,_eated);<br>     }<br>     <br>     event SetEated(uint id);<br>     //@dev if fish.level==0 ,do not set eated<br>     function setEated(uint _id) public onlyCLevel {<!-- --><br>         require(myFishIndexToOwner[_id] != address(0));<br>         MyFish storage fish = myFishes[_id];<br>         require( (fish.level != 0) &amp;&amp; (fish.eated != true) );<br>         fish.eated=true;<br>         // sub count of eatedFish owner<br>         address tmp = myFishIndexToOwner[_id];<br>         myFishIndexToOwner[_id] = address(0);<br>         ownershipTokenCount[tmp]--;<br>         SetEated(_id);<br>     }</p> 
<p>    function checkId(uint _id,uint _eatedId) internal {<!-- --><br>         require( (myFishIndexToOwner[_id] != address(0)) &amp;&amp; (myFishIndexToOwner[_eatedId] != address(0)) );<br>            MyFish storage fish = myFishes[_id];<br>         MyFish storage eatedFish = myFishes[_eatedId];<br>         require( (fish.level != 0) &amp;&amp; (eatedFish.level !=0) &amp;&amp; (fish.eated==false) &amp;&amp; (eatedFish.eated==false) );<br>     <br>     }<br>     function eat(uint _id,uint8 _level,uint8 _quality,uint8 _starlevel,uint8 _growup, uint8 _skill,uint8 _genius, uint16 _strength, uint16 _agility, uint16 _power,bool _eated, uint _eatedId)  public onlyCLevel  {<!-- --><br>         //address addr2=myFishIndexToOwner[_eatedId];<br>         //address addr1=myFishIndexToOwner[_id];<br>         //require((addr1 !=address(0))&amp;&amp;(addr2 != address(0)));<br>         checkId(_id,_eatedId);<br>         <br>         //require( (myFishIndexToOwner[_id] != address(0)) &amp;&amp; (myFishIndexToOwner[_eatedId] != address(0)) );<br>         updateMyFish(_id,_level,_quality,_starlevel,_growup,_skill,_genius,_strength,_agility,_power,_eated);<br>         setEated(_eatedId);<br>         <br>         <br>     }<br>     <br>     function createMyFish(<br>         uint8 _level,uint8 _quality,uint8 _starlevel,uint8 _growup, uint8 _skill,uint8 _genius, uint16 _strength, uint16 _agility, uint16 _power,<br>         address _owner<br>     )  external onlyCLevel whenNotPaused  returns (uint) {<!-- --><br>         require(_level != 0);<br>         return _createMyFish(_level,_quality,_starlevel,_growup,_skill,_genius,_strength,_agility,_power,_owner);<br>     }<br> }</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>