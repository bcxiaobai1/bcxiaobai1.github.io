<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>一文详解！appium自动化测试 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文详解！appium自动化测试</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:80px"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</a></p> 
<p id="Appinum%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-toc" style="margin-left:80px"><a href="#Appinum%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">Appinum前置知识</a></p> 
<p id="Andriod%20SDK-toc" style="margin-left:80px"><a href="#Andriod%20SDK">Andriod SDK</a></p> 
<p id="%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96%E2%80%94UI%20Automator-toc" style="margin-left:80px"><a href="#%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96%E2%80%94UI%20Automator">元素获取—UI Automator</a></p> 
<p id="adb%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5-toc" style="margin-left:80px"><a href="#adb%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5">adb命令实践</a></p> 
<p id="adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px"><a href="#adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">adb常用命令</a></p> 
<p id="%E5%B0%8F%E7%BB%93-toc" style="margin-left:80px"><a href="#%E5%B0%8F%E7%BB%93">小结</a></p> 
<p id="Package%E4%B8%8EActivity-toc" style="margin-left:80px"><a href="#Package%E4%B8%8EActivity">Package与Activity</a></p> 
<p id="Activity%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E5%85%83%E7%B4%A0-toc" style="margin-left:80px"><a href="#Activity%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E5%85%83%E7%B4%A0">Activity页面布局元素</a></p> 
<p id="monkey%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px"><a href="#monkey%E7%AE%80%E4%BB%8B">monkey简介</a></p> 
<p id="monkey%E4%BA%8B%E4%BB%B6-toc" style="margin-left:80px"><a href="#monkey%E4%BA%8B%E4%BB%B6">monkey事件</a></p> 
<p id="%E6%93%8D%E4%BD%9C%E4%BA%8B%E4%BB%B6%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px"><a href="#%E6%93%8D%E4%BD%9C%E4%BA%8B%E4%BB%B6%E7%AE%80%E4%BB%8B">操作事件简介</a></p> 
<p id="monkey%E5%8F%82%E6%95%B0-toc" style="margin-left:80px"><a href="#monkey%E5%8F%82%E6%95%B0">monkey参数</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%8F%82%E6%95%B0-toc" style="margin-left:80px"><a href="#%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%8F%82%E6%95%B0">事件类参数</a></p> 
<p id="%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%8F%82%E6%95%B0-toc" style="margin-left:80px"><a href="#%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%8F%82%E6%95%B0">约束类参数</a></p> 
<p id="%E8%B0%83%E8%AF%95%E7%B1%BB%E5%8F%82%E6%95%B0-toc" style="margin-left:80px"><a href="#%E8%B0%83%E8%AF%95%E7%B1%BB%E5%8F%82%E6%95%B0">调试类参数</a></p> 
<p id="Monkey%E5%8F%82%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px"><a href="#Monkey%E5%8F%82%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B">Monkey参数应用综合案例</a></p> 
<p id="Monkey%E8%84%9A%E6%9C%ACAPI%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px"><a href="#Monkey%E8%84%9A%E6%9C%ACAPI%E7%AE%80%E4%BB%8B">Monkey脚本API简介</a></p> 
<p id="monkey%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-toc" style="margin-left:80px"><a href="#monkey%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86">monkey日志管理</a></p> 
<p id="monkeyrunner-toc" style="margin-left:80px"><a href="#monkeyrunner">monkeyrunner</a></p> 
<p id="MonkeyRunner%20API-toc" style="margin-left:80px"><a href="#MonkeyRunner%20API">MonkeyRunner API</a></p> 
<p id="Appium-toc" style="margin-left:80px"><a href="#Appium">Appium</a></p> 
<p id="Appium%E7%BB%84%E4%BB%B6-toc" style="margin-left:80px"><a href="#Appium%E7%BB%84%E4%BB%B6">Appium组件</a></p> 
<p id="Capability-toc" style="margin-left:80px"><a href="#Capability">Capability</a></p> 
<p id="Capability%E5%90%AF%E5%8A%A8App%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px"><a href="#Capability%E5%90%AF%E5%8A%A8App%E6%BC%94%E7%A4%BA">Capability启动App演示</a></p> 
<p id="appium%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D-toc" style="margin-left:80px"><a href="#appium%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D">appium元素定位</a></p> 
<p id="UIAutomator-toc" style="margin-left:80px"><a href="#UIAutomator">UIAutomator</a></p> 
<p id="Toast-toc" style="margin-left:80px"><a href="#Toast">Toast</a></p> 
<p id="%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-toc" style="margin-left:80px"><a href="#%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">屏幕截图</a></p> 
<hr id="hr-toc"> 
<h4>前言：</h4> 
<p>Appium是一种用于自动化移动设备应用程序的开源工具，它具有跨平台的特性，能够在iOS和Android等多种移动设备上进行测试。Appium提供了一套API，开发人员可以使用多种编程语言来编写自动化脚本。</p> 
<h4 id="Appinum%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">Appinum前置知识</h4> 
<p><strong>app类型和区别</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fe/00/SVJBvdM5_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5b/05/2HxLO1IH_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3e/bd/jdhzt8xi_o.png"></p> 
<h4 id="Andriod%20SDK">Andriod SDK</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/34/a6/AXEvwVEZ_o.png"></p> 
<h4 id="%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96%E2%80%94UI%20Automator">元素获取—UI Automator</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d4/42/cM9bbBMM_o.png"></p> 
<h4 id="adb%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5">adb命令实践</h4> 
<p><strong>Android 调试桥</strong></p> 
<p>adb ( Android Debug Bridge)是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用。</p> 
<p>Tips： 在 android_sdk/platform-tools/ 中找到 adb 工具，然后根据其具体的路径配置好环境变量。然后启动cmd 输入‘adb’即可查看是否配置成功。</p> 
<p><strong>adb 的工作原理</strong></p> 
<p>启动一个 adb 客户端时，此客户端首先检查是否有已运行的 adb 服务器进程。如果没有，它将启动服务器进程。当服务器启动时，它与本地 TCP 端口 5037 绑定，并侦听从 adb 客户端发送的命令—所有 adb 客户端均使用端口 5037 与 adb 服务器通信。</p> 
<p><strong>启用 adb 调试</strong></p> 
<p>要在通过 USB 连接的设备上使用 adb，您必须在设备系统设置中启用 USB debugging（位于 Developer options 下）。</p> 
<p>在运行 Android 4.2 及更高版本的设备上，Developer options 屏幕默认情况下处于隐藏状态。如需将其显示出来，请转到 Settings &gt; About phone 并点按 Build number 七次。返回上一屏幕，在底部可以找到 Developer options。</p> 
<p>注：当您连接运行 Android 4.2.2 或更高版本的设备时，系统将显示一个对话框，询问您是否接受允许在这台计算机上调试的 RSA 密钥。这种安全机制可以保护用户设备，因为它可以确保只有在您能够解锁设备并确认对话框的情况下才能执行 USB 调试和其他 ADB 命令。</p> 
<h4 id="adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><strong>adb常用命令</strong></h4> 
<p><strong>查看adb版本</strong></p> 
<blockquote> 
 <pre>adb  version</pre> 
</blockquote> 
<p><strong>连接夜神模拟器（此处分别演示模拟器和真机连接）</strong></p> 
<blockquote> 
 <pre>adb connect 127.0.0.1:62001</pre> 
</blockquote> 
<p>Tips:</p> 
<p>夜神模拟器的端口是规律的，第一个模拟器端口是62001，第二个模拟器端口是62025，第三个是62025+1，依此类推。</p> 
<ul>
<li> <p>模拟器1：Android 4.4.2 地址：127.0.0.1:62001</p> </li>
<li> <p>模拟器2: Andriod 5.1.1 地址：127.0.0.1:62025</p> </li>
<li> <p>更多详情：夜神安卓模拟器adb命令详解</p> </li>
</ul> 
<p><strong>查看设备信息</strong></p> 
<blockquote> 
 <pre>adb devices</pre> 
</blockquote> 
<p>如果出现如下提示：</p> 
<blockquote> 
 <pre>adb server version (31) doesn't match this client (36); killing...</pre> 
</blockquote> 
<ul>
<li> <p>原因： adb版本不对 ,Androd SDK的版本和模拟器的adb版本不一致</p> </li>
<li> <p>解决方案：将Android SDK的 adb替换掉模拟器的adb即可。模拟器adb路径 ：{安装Path}Noxbin</p> </li>
</ul> 
<p><strong>adb shell</strong></p> 
<p>android 设备底层是 linux 系统。 shell 是 linux 系统的字符交互界面。</p> 
<blockquote> 
 <pre>adb shell
#进入指定设备shell
adb  -s 127.0.0.1:62001 shell
 
#退出adb shell
exit</pre> 
</blockquote> 
<p>进入adb shell后有两种状态显示：#代表有root权限，$代表没有root权限</p> 
<blockquote> 
 <pre>root@android:/ #
 
shell@mx4:/ $</pre> 
</blockquote> 
<p>root用户是系统中唯一的超级管理员，它具有等同于操作系统的权限。一些需要root权限的应用，譬如广告阻挡，卸载系统预装App是需要root权限的。可问题在于root比windows的系统管理员的能力更大，足以把整个系统的大部分文件删掉，导致系统完全毁坏，不能再次使用。所以，用root进行不当的操作是相当危险的，轻微的可以死机，严重的甚至不能开机。所以，在Unix、Linux及Android中，除非确实需要，一般情况下都不推荐使用root。</p> 
<p><strong>在设备安装apk</strong></p> 
<blockquote> 
 <pre>adb install | -r &lt;apkName&gt;  -r 覆盖原安装文件 -s 可以指定设备
eg:
 
#默认安装
adb install "C:UsersShuqingDesktopAppium 自动化测试教程wandoujia.apk"
 
#覆盖安装
adb install -r  "C:UsersShuqingDesktopAppium 自动化测试教程wandoujia.apk"
 
#指定设备安装
adb  -s 127.0.0.1:62001 install  C:UsersShuqingDesktopAppiumkaoyan3.1.0.apk 自动化测试教程wandoujia.apk"</pre> 
</blockquote> 
<p>如遇到报错：Failure [INSTALL_FAILED_INVALID_URI]</p> 
<p>解决方案： cmd命令行下执行以下命令：</p> 
<ul>
<li> <p>第一步、adb remount</p> </li>
<li> <p>第二步、adb shell</p> </li>
<li> <p>第三步、cd /data</p> </li>
<li> <p>第四步、chmod 777 local</p> </li>
<li> <p>重新安装apk，ok了。</p> </li>
</ul> 
<p><strong>卸载apk</strong></p> 
<p>1.首先进入设备的/data/app目录找到app包名</p> 
<blockquote> 
 <pre>adb shell
cd /data/app/</pre> 
</blockquote> 
<p>2.执行命令删除</p> 
<blockquote> 
 <pre>adb uninstall  | -k  &lt;apkName&gt;  卸载软件
 
adb uninstall  com.wandoujia.phoenix2</pre> 
</blockquote> 
<p>Tips：安装后的包名系统会在末尾加上-1之类的数字，要去掉才可以成功卸载。 软件名称为包名，不要包含.apk</p> 
<p>-k 加 -k 参数,为卸载软件但是保留配置和缓存文件.</p> 
<p><strong>查看设备上面安装的应用包名</strong></p> 
<blockquote> 
 <pre>adb shell pm list package</pre> 
</blockquote> 
<p><strong>文件读取写入</strong></p> 
<p>将文件从PC写入到设备</p> 
<blockquote> 
 <pre>adb push &lt;本地路径&gt; &lt;设备路径&gt;
eg：
adb push C:UsersShuqingDesktopkyb.txt /sdcard
C:UsersShuqingDesktopkyb.txt: 1 file pushed. 0.1 MB/s (462 bytes in 0.005s)</pre> 
</blockquote> 
<p>将文件从设备读取到PC</p> 
<blockquote> 
 <pre>adb pull &lt;remote&gt; &lt;local&gt;
eg:
adb pull /sdcard/server.log  C:UsersShuqingDesktop
/sdcard/server.log: 1 file pulled. 0.0 MB/s (196 bytes in 0.004s)</pre> 
</blockquote> 
<p>注意：由于权限问题，不能直接pull到电脑磁盘根目录，否则会报错：</p> 
<blockquote> 
 <pre>C:UsersShuqing&gt;adb pull /sdcard/server.log  D:\
adb: error: cannot create file/directory 'D:\': No such file or directory</pre> 
</blockquote> 
<p><strong>屏幕截图</strong></p> 
<blockquote> 
 <pre>$ adb shell screencap /sdcard/screen.png
adb pull /sdcard/screen.png  C:UsersShuqingDesktop</pre> 
</blockquote> 
<p><strong>adb服务启动和关闭</strong></p> 
<blockquote> 
 <pre>adb kill-server                        关闭adb服务
adb start-server                      开启adb服务</pre> 
</blockquote> 
<p>Tips：如果5037端口被占用可以使用如下命令释放端口</p> 
<blockquote> 
 <pre>C:UsersShuqing&gt; netstat -ano | findstr "5037"
  TCP    127.0.0.1:5037         0.0.0.0:0              LISTENING       11072
  TCP    127.0.0.1:5037         127.0.0.1:59519        TIME_WAIT       0
 
taskkill -f -pid XXX</pre> 
</blockquote> 
<h4 id="%E5%B0%8F%E7%BB%93">小结</h4> 
<ol>
<li> <p>adb是自动化非常重要的一个工具</p> </li>
<li> <p>目前很多PC客户端手机助手也是基于adb连接原理进行封装的。</p> </li>
<li> <p>可以将常用的adb命令封装成bat命令，随时可以运行。如：</p> </li>
</ol> 
<p>adbdevices.bat</p> 
<pre>adb devices
pause</pre> 
<p>AdbConnect.bat</p> 
<pre>adb connect 127.0.0.1:62025
adb devices
pause</pre> 
<h4 id="Package%E4%B8%8EActivity">Package与Activity</h4> 
<p>adb shell pm list package 查看所有的package包</p> 
<p><strong>Package</strong></p> 
<p>Package 包。只是在我们的app中这个Package是唯一的，就像你身份证号码一样。在我们做app自动化时，我们就需要知道他的Package，我们知道了Package那么也就知道我们需要对哪个app做自动化。 注意和.apk文件包名不同。</p> 
<p><strong>Activity</strong></p> 
<p>Android中，activity是所有程序的根本，所有程序的流程都运行在activity之中，activity可以算是开发者遇到的最频繁，也是android当中最基本的模块之一。在android的程序中，activity一般代表手机屏幕的一屏。如果把手机比作一个浏览器，那么activity就相当于一个网页。在activity当中可以添加一些Button、Checkbox等控件，可以看到activity概念和网页的概念相当类似。</p> 
<p>一般一个android应用是由多个activity组成的，这多个activity之间可以进行相互跳转。例如，按下一个Button按钮后，可能会跳转到其他的activity，与网页跳转稍微有点不一样的是，activity之间的跳转有可能返回值。</p> 
<p>Tips：activity的生命周期：即“产生、运行、销毁”，但是这其中会调用许多方法onCreate（创建） 、onStart（激活） 、onResume（恢复） 、onPause（暂停） 、onStop（停止） 、onDestroy（销毁） 、onRestart（重启）。</p> 
<p><strong>Activity获取</strong></p> 
<p>研发提供</p> 
<p><strong>aapt</strong></p> 
<p>aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成二进制文件。获取命令如下：</p> 
<pre>aapt dump badging xxxx.apk
aapt dump badging xxxx.apk | find "launchable-activity"</pre> 
<p>可以把appt配置到环境变量（系统变量中的Path），这样运行便捷一些，appt路径：Andriod_SDKbuild-tools{version}</p> 
<h4 id="Activity%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E5%85%83%E7%B4%A0">Activity页面布局元素</h4> 
<p><strong>FrameLayout</strong></p> 
<p>FrameLayout是最简单的布局了。所有放在布局里的控件，都按照层次堆叠在屏幕的左上角。后加进来的控件覆盖前面的控件。</p> 
<p><strong>LinearLayout</strong></p> 
<p>LinearLayout按照垂直或者水平的顺序依次排列子元素，每一个子元素都位于前一个元素之后。如果是垂直排列，那么将是一个N行单列的结构，每一行只会有一个元素，而不论这个元素的宽度为多少；如果是水平排列，那么将是一个单行N列的结构。如果搭建两行两列的结构，通常的方式是先垂直排列两个元素，每一个元素里再包含一个LinearLayout进行水平排列。</p> 
<p><strong>RelativeLayout</strong></p> 
<p>RelativeLayout相对布局允许子元素指定它们相对于其父元素或兄弟元素的位置，这是实际布局中最常用的布局方式之一。</p> 
<p><strong>AbsoluteLayout</strong></p> 
<p>AbsoluteLayout是绝对位置布局。在此布局中的子元素的android:layout_x和android:layout_y属性将生效，用于描述该子元素的坐标位置。屏幕左上角为坐标原点（0,0），第一个0代表横坐标，向右移动此值增大，第二个0代表纵坐标，向下移动，此值增大。在此布局中的子元素可以相互重叠。在实际开发中，通常不采用此布局格式，</p> 
<p><strong>TableLayout</strong></p> 
<p>TableLayout 为表格布局，适用于N行N列的布局格式。一个TableLayout由许多TableRow组成，一个TableRow就代表TableLayout中的一行。</p> 
<p><strong>TextView</strong></p> 
<p>通常用于显示文字用的。</p> 
<p><strong>ImageView</strong></p> 
<p>通常用于显示图片用的。</p> 
<h4 id="monkey%E7%AE%80%E4%BB%8B">monkey简介</h4> 
<p><strong>Monkey简介</strong></p> 
<p>在Android的官方自动化测试领域有一只非常著名的“猴子”叫Monkey，这只“猴子”一旦启动，就会让被测的Android应用程序像猴子一样活蹦乱跳，到处乱跑。人们常用这只“猴子”来对被测程序进行压力测试，检查和评估被测程序的稳定性。</p> 
<p><strong>Moneky 路径</strong></p> 
<p>Monkey程序是Android系统自带的，其启动脚本是位于Android系统的/system/bin目录的Monkey文件，其jar包是位于Android系统的/system/framework目录的Monkey.jar文件。用户主要是通过adb命令来启动Monkey的，Monkey在运行时，会根据命令行参数的配置，生成伪随机的事件流，并在Android设备上执行对应的测试事件。同时，Monkey还会对测试系统进行监测，当出现以下三种情况时会进行特殊处理：</p> 
<ul>
<li> <p>如限定了Monkey运行在特定包上，当监测到试图转到其他包的操作，将对其进行阻止。</p> </li>
<li> <p>如应用程序崩溃或接收到任何失控异常，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。</p> </li>
<li> <p>如果应用程序发生了程序无响应（application not responding）的错误，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。</p> </li>
<li> <p>按照选定的不同级别的反馈信息，在Monkey中还可以看到其执行过程报告和生成的事件。</p> </li>
</ul> 
<p><strong>Monkey启动步骤</strong></p> 
<ol>
<li> <p>连接移动设备</p> </li>
<li> <p>连接成功后输入命令</p> </li>
</ol> 
<blockquote> 
 <pre>adb shell</pre> 
</blockquote> 
<p>进入到指定目录</p> 
<blockquote> 
 <pre>cd /system/bin</pre> 
</blockquote> 
<p>4.输入 monkey命令看到如下提示则说明启动成功。</p> 
<p><strong>强制关闭monkey</strong></p> 
<ol>
<li> <p>adb shell ps 查看全部在运行的进程</p> </li>
<li> <p>查找出com.android.commands.monkey 进程PID</p> </li>
<li> <p>adb shell kill pid 杀掉monkey进程</p> </li>
</ol> 
<p><strong>monkey 命令</strong></p> 
<p>monkey命令格式如下：</p> 
<blockquote> 
 <pre>$ adb shell monkey [options] &lt;event-count&gt;</pre> 
</blockquote> 
<ul>
<li> <p>[options] 是指monkey可传入的参数，是可选项（如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包）</p> </li>
<li> <p>是指随机发送事件数。如：输入100就是执行100个伪随机事件，为必选项。</p> </li>
</ul> 
<h4 id="monkey%E4%BA%8B%E4%BB%B6">monkey事件</h4> 
<p>触摸事件、手势时间、二指缩放事件、轨迹事件、屏幕旋转事件、基本导航事件、主要导航事件、系统按键事件、启动Activity事件、键盘事件、其他类型事件</p> 
<h4 id="%E6%93%8D%E4%BD%9C%E4%BA%8B%E4%BB%B6%E7%AE%80%E4%BB%8B">操作事件简介</h4> 
<p>Monkey所执行的随机事件流中包含11大事件，分别是触摸事件、手势事件、二指缩放事件、轨迹事件、屏幕旋转事件、基本导航事件、主要导航事件、系统按键事件、启动Activity事件、键盘事件、其他类型事件。Monkey通过这11大事件来模拟用户的常规操作，对手机App进行稳定性测试。下面让我们来详细了解这11大事件。</p> 
<p><strong>1.触摸事件</strong></p> 
<p>触摸事件是指在屏幕某处按下并抬起的操作，可通过–pct-touch参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到。 该事件由一组Touch（ACTION_DOWN）和Touch（ACTION_UP）事件组成，在手机上看到实际操作类似于点击。</p> 
<p><strong>2.手势事件</strong></p> 
<p>手势事件是指在屏幕某处的按下、随机移动、抬起的操作，即直线滑动操作。可通过–pct-motion参数来配置其事件百分比。</p> 
<p>该事件是由一个ACTION_DOWN事件、一系列ACTION_MOVE事件和一个ACTION_UP事件组成的，在手机上看到的实际操作是一个没有拐弯的直线滑动操作。</p> 
<p><strong>3.二指缩放事件</strong></p> 
<p>二指缩放事件是指在屏幕上的两处同时按下，并同时移动，最后同时抬起的操作，即智能机上的放大缩小手势操作。可通过–pct-pinchzoom参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p> 
<p>该事件起始是一个ACTION_DOWN事件和一个ACTION_POINTER_DOWN事件，即模拟两个手指同时点下；中间是一系列的ACTION_MOVE事件，即两个手指同时在屏幕上直线滑动；结束是由一个ACTION_POINTER_UP事件和一个ACTION_UP事件组成的，即两个手指同时放开。</p> 
<p><strong>4.轨迹事件</strong></p> 
<p>轨迹事件是由一个或多个随机的移动组成的，有时会伴随着点击。很早之前的Android手机带有轨迹球，这个事件就是模拟的轨迹球的操作。现在的手机几乎都没有轨迹球，但轨迹球事件中包含曲线滑动操作，如果被测程序需要曲线滑动时可以选用此参数。可通过–pct-trackball参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p> 
<p>该事件是由一系列的Trackball（ACTION_MOVE）事件组成的，观察手机上的操作，即为一系列的曲线滑动操作。</p> 
<p><strong>5.屏幕旋转事件</strong></p> 
<p>屏幕旋转事件是一个隐藏事件，在Android官方文档中并没有记录这个事件。它其实是模拟的Android手机的横屏和竖屏切换。可通过–pct-rotation参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件由一个rotation事件组成，其中degree表示的是旋转方向，顺时针旋转，0表示旋转90度的方向，1表示旋转180度的方向，2表示旋转270度的方向，3表示旋转360度的方向。在执行过程中，可以看到手机屏幕在横竖屏之间不断地切换。</p> 
<p><strong>6.基本导航事件</strong></p> 
<p>基本导航事件是指点击方向输入设备的上、下、左、右按键的操作，现在手机上很少有上、下、左、右按键，这种事件一般用得比较少。可通过–pct-nav参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p> 
<p>该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的就是上、下、左、右四个方向按键。</p> 
<p><strong>7.主要导航事件</strong></p> 
<p>主要导航事件是指点击“主要导航”按键的操作，这些按键通常会导致UI界面中的动作，如键盘的中间键、回退按键、菜单按键。可通过–pct-majornav参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的按键就是中间键和菜单键。</p> 
<p><strong>8.系统按键事件</strong></p> 
<p>系统按键事件是指点击系统保留使用的按键的操作，如点击Home键、返回键、音量调节键等。可通过–pct-syskeys参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的就是上面说到的几个系统按键。</p> 
<p><strong>9.启动Activity事件</strong></p> 
<p>启动Activity事件是指在手机上启动一个Activity的操作。在随机的时间间隔中，Monkey将执行一个startActivity（）方法，作为最大限度上覆盖被测包中全部Activity的一种方法。可通过–pct-appswitch参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Switch操作组成的，从手机上看，上面的操作实际是打开了com.android.settings这个应用的一个com.android.settings.Settings的Activity界面。</p> 
<p><strong>10.键盘事件</strong></p> 
<p>键盘事件主要是一些与键盘相关的操作。比如点击输入框、键盘弹起、点击输入框以外区域、键盘收回等。可通过–pct-flip参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 如日志所示，这里主要是键盘的打开和关闭操作。</p> 
<p><strong>11.其他类型事件</strong></p> 
<p>其他类型事件包括了除前面提到的10种事件外其他所有的事件，如按键、其他不常用的设备上的按钮等。可通过–pct-anyevent参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的按键就是其他的一些系统按键，如字母按键、数字按键等。因为现在手机很少带字母按键或数字按键，所以这个事件一般使用得比较少。</p> 
<h4 id="monkey%E5%8F%82%E6%95%B0">monkey参数</h4> 
<p><strong>参数分类</strong></p> 
<ul>
<li> <p>常规类参数</p> </li>
<li> <p>事件类参数</p> </li>
<li> <p>约束类参数</p> </li>
<li> <p>调试类参数</p> </li>
</ul> 
<p><strong>常规类参数</strong></p> 
<p>常规类参数包括帮助参数和日志信息参数。帮助参数用于输出Monkey命令使用指导；日志信息参数将日志分为三个级别，级别越高，日志的信息越详细。</p> 
<p>1.帮助类参数</p> 
<blockquote> 
 <pre>monkey -h</pre> 
</blockquote> 
<p>2.日志级别</p> 
<blockquote> 
 <pre>$ adb shell monkey -v &lt;event-count&gt;</pre> 
</blockquote> 
<p>-v：打印出日志信息，每个-v将增加反馈信息的级别。-v越多日志信息越详细，不过目前最多支持3个-v，即：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e6/57/XmPf8ZFO_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d8/21/HAxYhSCx_o.png"></p> 
<h4 id="%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%8F%82%E6%95%B0">事件类参数</h4> 
<p>事件类参数的作用是对随机事件进行调控，从而使其遵照设定运行，如设置各种事件的百分比、设置事件生成所使用的种子值等。频率参数主要限制事件执行的时间间隔。</p> 
<p>1.执行指定脚本</p> 
<blockquote> 
 <pre>$ adb shell monkey -f &lt;scriptfile&gt; &lt;event-count&gt;
 
eg：
$ adb shell monkey -f /mnt/sdcard/test1</pre> 
</blockquote> 
<p>2.伪随机数生成种子值</p> 
<blockquote> 
 <pre>使用 -s命令可以重复执行之前的伪随机操作。本身每次执行伪随机事件操作也会默认生成一个seed值
$ adb shell monkey -s &lt;seed&gt; &lt;event-count&gt;
 
eg:
$ adb shell monkey -s 666 100</pre> 
</blockquote> 
<p>3.设置间隔 如果你希望在每一个指令之间加上固定的间隔时间，可以用–throttle（注意，前面是–）命令。</p> 
<blockquote> 
 <pre>$ adb shell monkey --throttle &lt;milliseconds&gt;
eg:
$ adb shell monkey --throttle 3000  5</pre> 
</blockquote> 
<p>–throttle：后面接时间，单位为ms（），表示事件之间的固定延迟（即执行每一个指令间隔的时间），若不接该选项，monkey将不会延迟。</p> 
<p>4.调整触摸事件百分比</p> 
<p>如果你希望调整触摸事件的百分比，记住使用–pct-touch。</p> 
<blockquote> 
 <pre>$ adb shell monkey --pct-touch
eg:
$ adb shell monkey -v -v --pct-touch 100 200</pre> 
</blockquote> 
<p>–pct-touch：后面接触摸事件百分比</p> 
<p>注意：触摸事件不单单是按键，它泛指发生在某一位置的一个down-up事件。</p> 
<p>5.调整手势事件百分比</p> 
<blockquote> 
 <pre>$ adb shell monkey --pct-motion
eg:
$ adb shell monkey -v -v --pct-motion 100 200</pre> 
</blockquote> 
<p>6.调整应用启动事件的百分比</p> 
<p>如果你希望调整应用启动事件的百分比，记住使用–pct-app-switch。</p> 
<blockquote> 
 <pre>$ adb shell monkey --pct-appswtich &lt;percent&gt;</pre> 
</blockquote> 
<p>–pct-appswitch：后面接应用启动事件百分比。</p> 
<p>应用启动事件（即activity launches）俗称打开应用，通过调用startActivity()方法最大限度地开启该package下的所有应用。</p> 
<p>7.调整屏幕旋转事件百分比</p> 
<blockquote> 
 <pre>$ adb shell monkey --pct-rotation &lt;percent&gt;</pre> 
</blockquote> 
<p>–pct-rotation 后面接屏幕旋转事件的比例值。</p> 
<p>8.其他参数</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/21/39/68EyUSTg_o.png"></p> 
<h4 id="%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%8F%82%E6%95%B0">约束类参数</h4> 
<p>**1.**包约束</p> 
<p>-p：后面接一个或多个包名（），如果应用需要访问其他包里的Activity，那相关的包也需要在此同时指定。如果不指定任何包，monkey将允许系统启动全部包里的Activity。</p> 
<pre><code class="hljs">$ adb shell monkey -p &lt;allowed-package-name&gt; &lt;event-count&gt;
eg：
$ adb shell monkey -p com.tal.kaoyan 500
 
$ adb shell monkey -p com.tal.kaoyan -p com.tencent.mm 500</code></pre> 
<p>2.activity****类约束</p> 
<p>如果你希望将monkey限制在一个或几个类别中，使用如下命令：</p> 
<pre><code class="hljs">adb shell monkey -c &lt;main-category&gt; &lt;event-count&gt;</code></pre> 
<p>以下命令表示运行Intent.CATEGORY_LAUNCHER类别的Activity并发送1000个随机事件。</p> 
<pre><code class="hljs">$ adb shell monkey -c Intent.CATEGORY_LAUNCHER  1000</code></pre> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/84/e9/wRb7SzKi_o.png"></p> 
<h4 id="%E8%B0%83%E8%AF%95%E7%B1%BB%E5%8F%82%E6%95%B0">调试类参数</h4> 
<p>**1.**应用程序崩溃后继续发送事件</p> 
<p>如果你希望monkey在应用程序崩溃后继续发送事件，则需要用到–ignore-crashes命令</p> 
<pre><code class="hljs">$ adb shell monkey --ignore-crashes &lt;event-count&gt;</code></pre> 
<p>在设置此选项后，当应用程序崩溃或发生失控异常时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到上述崩溃或异常将停止运行。</p> 
<p>**2.**超时错误继续发送事件</p> 
<p>如果你希望monkey在任何超时错误发生后继续发送事件，则需要用到–ignore-timeouts命令。</p> 
<pre><code class="hljs">$ adb shell monkey --ignore-timeouts</code></pre> 
<p>–ignore-timeouts：在设置此选项后，当应用程序发生任何超时错误（如ANR，即Application Not Responding）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类超时对话框将停止运行。</p> 
<p>**3.**应用程序权限错误发生后继续发送事件</p> 
<p>如果你希望monkey在应用程序权限错误发生后继续发送事件，则需要用到–ignore-security-exceptions命令。</p> 
<pre><code class="hljs">$ adb shell monkey --ignore-security-exceptions</code></pre> 
<p>–ignore-security-exceptions：在设置此选项后，当应用程序发生任何权限错误（如启动一个需要某些权限的Activity）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类权限错误将停止运行。</p> 
<p>4.其他</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c4/ba/MJGXsdmF_o.png"></p> 
<h4 id="Monkey%E5%8F%82%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B">Monkey参数应用综合案例</h4> 
<p><strong>测试场景</strong></p> 
<p>测试考研帮app Android版。测试希望通过Monkey来模拟用户的随机操作，检查被测应用是否会出现异常（应用崩溃或者无响应）。</p> 
<p><strong>需求分析</strong></p> 
<p>1、测试是指定应用，因此需要使用-p指定被测app包名：com.tal.kaoyan</p> 
<p>2、这个测试的目的是希望模拟用户操作，因此需要让Monkey执行的事件尽可能地接近用户的常规操作，这样才可以最大限度地发现用户使用过程中可能出现的问题。因此需要对Monkey执行的事件百分比做一些调整:</p> 
<p>触摸事件和手势事件是用户最常见的操作，所以通过–pct-touch和–pct-motion将这两个事件的占比调整到40%与25%；目标应用包含了多个Activity，为了能覆盖大部分的Activity，所以通过–pct-appswitch将Activity切换的事件占比调整到10%；被测应用在测试中出现过不少横竖屏之间切换的问题，这个场景也必须关注，因此通过–pct-rotation把横竖屏切换事件调整到10%。</p> 
<p>3、使用-s参数来指定命令执行的seed值 Monkey会根据seed值来生成对应事件流，同一个seed生成的事件流是完全相同的。这里指定了seed值，是为了测试发现问题时，便于进行问题复现。</p> 
<p>4、使用–throttle参数来控制Monkey每个操作之间的时间间隔 指定操作之间的时间间隔，一方面是希望能更接近用户的操作场景，正常用户操作都会有一定的时间间隔；另一方面也是不希望因为过于频繁的操作而导致系统崩溃，尤其是在比较低端的手机上执行测试时。因此通过–throttle设置Monkey每个操作固定延迟0.4秒。</p> 
<p>5、使用–ignore-crashs和–ignore-timeouts参数使Monkey遇到意外时能继续执行 在执行Monkey测试时，会因为应用的崩溃或没有响应而意外终止，所以需要在命令中增加限制参数–ignore-crash和–ignore-timeouts，让Monkey在遇到崩溃或没有响应的时候，能在日志中记录相关信息，并继续执行后续的测试。</p> 
<p>6、使用-v指定log的详细级别 Monkey的日志输出有3个级别：日志的级别越高，其详细程度也越高。为了方便问题的定位，这里将日志设为 -v -v.</p> 
<p><strong>测试命令</strong></p> 
<pre><code class="hljs">adb shell monkey -p com.tal.kaoyan
--pct-touch 40 --pct-motion 25 
--pct-appswitch 10
--pct-rotation 5
-s 1666 --throttle 400
--ignore-crashes
--ignore-timeouts
-v -v  200</code></pre> 
<h4 id="Monkey%E8%84%9A%E6%9C%ACAPI%E7%AE%80%E4%BB%8B">Monkey脚本API简介</h4> 
<p>LaunchActivity(pkg_name, cl_name)：启动应用的Activity。参数：包名和启动的Activity。</p> 
<p>Tap(x, y, tapDuration)： 模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。</p> 
<p>UserWait(sleepTime)： 休眠一段时间</p> 
<p>DispatchPress(keyName)： 按键。参数： keycode。 RotateScreen(rotationDegree, persist)： 旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。</p> 
<p>DispatchString(input)： 输入字符串。</p> 
<p>DispatchFlip(true/false)： 打开或者关闭软键盘。</p> 
<p>PressAndHold(x, y, pressDuration)： 模拟长按事件。</p> 
<p>Drag(xStart, yStart, xEnd, yEnd, stepCount)： 用于模拟一个拖拽操作。</p> 
<p>PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)： 模拟缩放手势。</p> 
<p>LongPress()： 长按2秒。</p> 
<p>DeviceWakeUp()： 唤醒屏幕。</p> 
<p>PowerLog(power_log_type, test_case_status)： 模拟电池电量信息。</p> 
<p>WriteLog()： 将电池信息写入sd卡。</p> 
<p>RunCmd(cmd)： 运行shell命令。</p> 
<p>DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFlags)： 向指定位置，发送单个手势。</p> 
<p>DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFilags)： 发送按键消息。</p> 
<p>LaunchInstrumentation(test_name,runner_name)： 运行一个instrumentation测试用例。</p> 
<p>DispatchTrackball： 模拟发送轨迹球事件。</p> 
<p>ProfileWait： 等待5秒。</p> 
<p>StartCaptureFramerate()： 获取帧率。</p> 
<p>EndCaptureFramerate(input)： 结束获取帧率。</p> 
<p><strong>Monkey脚本格式</strong></p> 
<p>脚本主要包含两部分，一部分是头文件信息，一部分是具体的monkey命令</p> 
<pre><code class="hljs">type = raw events  
count = 1  
speed = 1.0  
//下面为monkey命令  
start data &gt;&gt;   
具体的monkey脚本内容</code></pre> 
<p><strong>编写脚本</strong></p> 
<pre><code class="hljs">kyb.txt

#头文件信息
 
type = raw events 
 
count = 1
 
speed = 1.0
 
#启动测试
start data &gt;&gt;
 
LaunchActivity(com.tal.kaoyan,com.tal.kaoyan.ui.activity.SplashActivity)
UserWait(2000)
 
Tap(624,900,1000) #点击取消升级
UserWait(2000)
 
Tap(806,64,1000) #点击跳过
UserWait(2000)
 
Tap(217,378,1000) #点击用户名输入框
DispatchString(zxw1234)
UserWait(2000)
 
Tap(197,461,1000) #点击密码输入框
DispatchString(zxw123456)
UserWait(2000)
 
Tap(343,637,1000) #点击登录按钮</code></pre> 
<pre></pre> 
<p><strong>执行脚本</strong></p> 
<p>脚本编写完成后，传到手机设备上，然后执行。</p> 
<pre><code class="hljs">adb push C:UsersShuqingDesktopkyb1.txt /sdcard
 
adb shell monkey -f /sdcard/kyb1.txt -v 1</code></pre> 
<p><strong>执行结果</strong></p> 
<pre><code class="hljs">C:UsersShuqing&gt;adb shell monkey -f /sdcard/kyb.txt -v 1
:Monkey: seed=1524592021303 count=1
:IncludeCategory: android.intent.category.LAUNCHER
:IncludeCategory: android.intent.category.MONKEY
Replaying 0 events with speed 1.0
:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.tal.kaoyan/.ui.activity.SplashActivity;end
    // Allowing start of Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.tal.kaoyan/.ui.activity.SplashActivity } in package com.tal.kaoyan
:Sending Touch (ACTION_DOWN): 0:(267.0,1233.0)
    // Allowing start of Intent { act=com.android.systemui.recent.action.TOGGLE_RECENTS cmp=com.android.systemui/.recent.RecentsActivity } in package com.android.systemui
:Sending Touch (ACTION_UP): 0:(267.0,1233.0)
Events injected: 5
:Sending rotation degree=0, persist=false
:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0
## Network stats: elapsed time=7201ms (0ms mobile, 0ms wifi, 7201ms not connected)
// Monkey finished</code></pre> 
<p><strong>注意事项</strong></p> 
<p>头文件代码书写注意“=”两边预留空格，否则会出现如下报错。</p> 
<pre><code class="hljs">java.lang.NumberFormatException: Invalid int: ""</code></pre> 
<h4 id="monkey%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86">monkey日志管理</h4> 
<p><strong>日志管理作用</strong></p> 
<p>Monkey日志管理是Monkey测试中非常重要的一个环节，通过日志管理分析，可以获取当前测试对象在测试过程中是否会发生异常，以及发生的概率，同时还可以获取对应的错误信息，帮助开发定位和解决问题。</p> 
<p><strong>monkey日志保存方法</strong></p> 
<ol>
<li> <p>保存在PC中</p> </li>
<li> <p>保存在手机上</p> </li>
<li> <p>标准流和错误流分开保存</p> </li>
</ol> 
<p><strong>保存在PC中</strong></p> 
<pre><code class="hljs">&gt;adb shell monkey [option] &lt;count&gt; &gt;d:monkey.txt
 
eg：
C:UsersShuqing&gt;adb shell monkey -v -v 100 &gt;d:monkeylog.txt</code></pre> 
<p><strong>保存在手机上</strong></p> 
<pre><code class="hljs">C:UsersShuqing&gt;adb shell
monkey -v 100 &gt;/sdcard/monkeylog.log</code></pre> 
<p>注意：不能写成C:UsersShuqing&gt;adb shell monkey -f /sdcard/kyb.txt -v 1 &gt; /mnt/sdcard/monkey.log 否则会报错“系统找不到指定的路径”。</p> 
<p><strong>标准流和错误流分开保存</strong></p> 
<ul><li> <p>标准流与错误流分开保存，代码如下：</p> </li></ul> 
<pre><code class="hljs">Monkey [option] &lt;count&gt; 1&gt;/sdcard/monkey.txt 2&gt;/sdcard/error.txt
 
C:UsersShuqing&gt;adb shell monkey -v 100 1&gt;d:monkey.log  2&gt;d:error.log</code></pre> 
<p>执行以上命令，Monkey的运行日志和异常日志将被分开保存。此时Monkey的运行日志将被保存在monkey.txt文件中，而异常日志将被保存在D盘下的error.txt中。</p> 
<p><strong>日志内容分析</strong></p> 
<p>运行命令：</p> 
<pre>adb shell monkey -v 100</pre> 
<h4 id="monkeyrunner">monkeyrunner</h4> 
<p><strong>monkeyrunner简介</strong></p> 
<p>MonkeyRunner工具是使用Jython(使用Java编程语言实现的Python)写出来的，它提供了多个API，通过monkeyrunner API 可以写一个Python的程序来模拟操作控制Android设备app,测试其稳定性并通过截屏可以方便地记录出现的问题。</p> 
<p>monkeyrunner 路径：Andriod_SDKtools</p> 
<p><strong>MonkeyRunner功能</strong></p> 
<ol>
<li> <p>多设备控制：API可以跨多个设备，一次启动全部模拟器来实施测试套件;</p> </li>
<li> <p>功能测试：为应用自动执行一次功能测试，然后观察输出结果的截屏。</p> </li>
<li> <p>可扩展自动化：因为monkeyrunner是一个API工具包，你可以开发基于Python模块的整个系统来控制Android设备;</p> </li>
</ol> 
<p><strong>Monkeyrunner与Monkey区别</strong></p> 
<p>monkeyrunner和money没有什么直接的关系，monkey是在设备直接运行adb shell命令生成随机事件来进行测试的。相比较而言，monkeyrunner则是通过API发送特定的命令和事件来控制设备。</p> 
<p><strong>monkeyrunner环境搭建</strong></p> 
<ul>
<li> <p>安装并配置好jdk环境</p> </li>
<li> <p>安装android sdk</p> </li>
<li> <p>安装python 安装配置教程</p> </li>
<li> <p>monkeyrunner环境变量配置： {Path}Andriod_SDKtools</p> </li>
</ul> 
<p><strong>安装结果检测</strong></p> 
<p>在控制台输入命令：monkeyrunner出现如下显示内容则说明安装成功</p> 
<pre><code class="hljs">C:UsersShuqing&gt;monkeyrunner
Jython 2.5.3 (2.5:c56500f08d34+, Aug 13 2012, 14:54:35)
[Java HotSpot(TM) 64-Bit Server VM (Oracle Corporation)] on java1.8.0_05
&gt;&gt;&gt;</code></pre> 
<p>Tips：退出monkeyrunner命令行模式可以 使用快捷键 ctrl+D退出。</p> 
<h4 id="MonkeyRunner%20API">MonkeyRunner API</h4> 
<p>MonkeyRunner工具主要有三个类：</p> 
<ol>
<li> <p>MonkeyRunner</p> </li>
<li> <p>MonkeyDevice</p> </li>
<li> <p>MonkeyImage</p> </li>
</ol> 
<p><strong>1.MonkeyRunner类：</strong></p> 
<p>MonkeyRunner提供连接真机和模拟器、输入、暂停、警告框等方法。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/91/86/U6lQ2RO5_o.png"></p> 
<p><strong>常用方法</strong></p> 
<pre><code class="hljs">waitForConnection(float timeout,string deviceid)，
from com.android.monkeyrunner import MonkeyRunner as mr
print("connect devices...")
 
device=mr.waitForConnection()
# device=mr.waitForConnection(5,'127.0.0.1:62001')</code></pre> 
<p><strong>2.MonkeyDevice类</strong></p> 
<p>MonkeyDevice类提供了安装和卸载程序包、开启Activity、发送按键和点击事件、运行测试包等方法。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/be/91/GQk4mlHu_o.png"></p> 
<p><strong>常用方法</strong></p> 
<ul>
<li> <p>installPackage (string path) 安装包</p> </li>
<li> <p>removePackage (string package) 卸载包</p> </li>
<li> <p>startActivity (string uri, string action, string data, string mimetype, iterable categories dictionary extras, component component, flags) 启动</p> </li>
<li> <p>touch (integer x, integer y, integer type) 点击</p> </li>
</ul> 
<p><strong>touch****参数说明</strong></p> 
<p>integer x，x坐标值。</p> 
<p>integer y，y坐标值。</p> 
<p>integer type，key event类型（如DOWN、UP、DOWN_AND_UP）。</p> 
<p>DOWN为按下事件 UP为弹起事件 DOWN_AND_UP为按下弹起事件。</p> 
<p>drag (tuple start, tuple end, float duration, integer steps)</p> 
<p><strong>drag****参数详细说明如下：</strong></p> 
<p>tuple start，拖拽起始位置，为tuple类型的(x,y)坐标点。</p> 
<p>tuple end，拖拽终点位置，为tuple类型的(x,y)坐标点。</p> 
<p>float duration，拖拽手势持续时间，默认为1.0s。</p> 
<p>-integer steps，插值点的步数，默认值为10。</p> 
<p><strong>代码实现</strong></p> 
<pre><code class="hljs">kyb_start.py

from com.android.monkeyrunner import MonkeyRunner as mr
from com.android.monkeyrunner import MonkeyDevice as md 
print("connect devices...")
device=mr.waitForConnection()
print("install app...")
device.installPackage(r'C:UsersShuqingDesktopkaoyan3.1.0.apk')
package = 'com.tal.kaoyan'
activity = 'com.tal.kaoyan.ui.activity.SplashActivity'
runComponent = package + '/' + activity 
print("launch App...")
device.startActivity(component=runComponent)</code></pre> 
<pre></pre> 
<p>代码执行方式</p> 
<pre><code class="hljs">monkeyrunner scripfile
 
C:UsersShuqing&gt;monkeyrunner E:monkeyrunner_scriptkyb.py</code></pre> 
<p><strong>3.MonkeyImage类</strong></p> 
<p>MonkeyImage类在测试过程中用来保存各种格式的测试截图，并可以进行图像对比。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/99/9c/dXCkfXtz_o.png"></p> 
<p><strong>常用方法</strong></p> 
<ul>
<li> <p>takeSnapshot() 进行屏幕截图</p> </li>
<li> <p>writeToFile() 保存图像文件到指定的文件路径</p> </li>
</ul> 
<p><strong>用法示例</strong></p> 
<pre><code class="hljs">from com.android.monkeyrunner import MonkeyImage as mi  
print("takeSnapshot")
screenshot=device.takeSnapshot()  
screenshot.writeToFile(r'E:monkeyrunner_scripttest.png','png')</code></pre> 
<p><strong>综合实践</strong></p> 
<p><strong>测试场景</strong></p> 
<ul>
<li> <p>连接设备，自动安装并启动考研帮app</p> </li>
<li> <p>启动后登录账号（账号zxw1234 密码：zxw123456），然后截图并保存到指定文件位置。</p> </li>
</ul> 
<p><strong>思路分析</strong></p> 
<ul>
<li> <p>连接设备</p> </li>
<li> <p>安装app</p> </li>
<li> <p>启动app</p> </li>
<li> <p>输入用户名密码点击登录按钮</p> </li>
<li> <p>截图</p> </li>
</ul> 
<p><strong>脚本实现</strong></p> 
<pre><code class="hljs">kyb_login.py

from com.android.monkeyrunner import MonkeyRunner as mr
from com.android.monkeyrunner import MonkeyDevice as md
from com.android.monkeyrunner import MonkeyImage as mi
 
print("connect devices...")
 
device=mr.waitForConnection()
 
print(" install app")
device.installPackage(r'C:UsersShuqingDesktopkaoyan3.1.0.apk')
 
print("launch app...")
package='com.tal.kaoyan'
activity='com.tal.kaoyan.ui.activity.SplashActivity'
runComponent=package+'/'+activity
 
device.startActivity(component=runComponent)
mr.sleep(3)
 
print("touch cancel button")
device.touch(618,895,'DOWN_AND_UP')
mr.sleep(1)
 
print("touch skip button")
device.touch(804,67,'DOWN_AND_UP')
mr.sleep(1)
 
print("input username and password")
device.touch(57,373,'DOWN_AND_UP')
mr.sleep(2)
device.type('zxw1234')
 
device.touch(152,480,'DOWN_AND_UP')
mr.sleep(2)
device.type('zxw123456')
mr.sleep(2)
 
print("touch login button")
device.touch(331,634,'DOWN_AND_UP')
 
print("takeSnapshot")
screenshot=device.takeSnapshot()
screenshot.writeToFile(r'D:monkeyrunnerkyb.png','png')</code></pre> 
<pre></pre> 
<p><strong>注意事项</strong></p> 
<p>方法调用错误</p> 
<pre><code class="hljs">AttributeError: type object 'com.android.monkeyrunner.XXXXX' has no attribute XXXXXX</code></pre> 
<p>检查调用的方法名是否写错，特别是注意区分大小写。</p> 
<p>字符编码错误</p> 
<pre><code class="hljs">SyntaxError: Non-ASCII character in file 'E:monkeyrunner_scriptkyb.py', but no encoding declared;</code></pre> 
<p>需要在代码顶部补充 # -- coding: utf-8 -- 或者去掉代码中的中文字符</p> 
<h4 id="Appium">Appium</h4> 
<p><strong>Appium简介</strong></p> 
<p>Appium是一个开源测试自动化框架，可用于原生，混合和移动Web应用程序测试。 它使用WebDriver协议驱动iOS，Android和Windows应用程序。</p> 
<ul>
<li> <p>Appium官网</p> </li>
<li> <p>Appium github主页</p> </li>
<li> <p>官方中文文档</p> </li>
<li> <p>Appium官方论坛</p> </li>
<li> <p>Testerhome中文社区</p> </li>
</ul> 
<p><strong>Appium优势</strong></p> 
<ul>
<li> <p>可以跨平台同时支持android、ios</p> </li>
<li> <p>支持多种语言，java、python、php、Ruby等等</p> </li>
<li> <p>不用为复杂的环境发愁</p> </li>
<li> <p>如果你有selenium经验，直接上手。</p> </li>
</ul> 
<p><strong>Appium架构原理</strong></p> 
<ul>
<li> <p>Android（版本&gt;4.3）：UIAutomator，Android 4.3之后系统自带的UI自动化测试工具。</p> </li>
<li> <p>Android（版本≤4.3）：Selendroid，基于Android Instrumentation框架实现的自动化测试工具。</p> </li>
<li> <p>iOS：UIAutomation（instruments框架里面的一个模板），iOS系统自带的UI自动化测试工具。</p> </li>
</ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/23/62/NmTbIHfJ_o.jpg"></p> 
<p><strong>运行原理</strong></p> 
<p>我们的电脑（client）上运行自动化测试脚本，调用的是webdriver的接口，appium server接收到我们client上发送过来的命令后他会将这些命令转换为UIautomator认识的命令，然后由UIautomator来在设备上执行自动化。</p> 
<p>Appium的架构原理如上图所示，由客户端（Appium Client）和服务器（Appium Server）两部分组成，客户端与服务器端通过JSON Wire Protocol进行通信。</p> 
<p><strong>Appium服务器</strong></p> 
<p>Appium服务器是Appium框架的核心。它是一个基于Node.js实现的HTTP服务器。Appium服务器的主要功能是接受从Appium客户端发起的连接，监听从客户端发送来的命令，将命令发送给bootstrap.jar（iOS手机为bootstrap.js）执行，并将命令的执行结果通过HTTP应答反馈给Appium客户端。</p> 
<p><strong>Bootstrap.jar。</strong></p> 
<p>Bootstrap.jar是在Android手机上运行的一个应用程序，它在手机上扮演TCP服务器的角色。当Appium服务器需要运行命令时，Appium服务器会与Bootstrap.jar建立TCP通信，并把命令发送给Bootstrap.jar；Bootstrap.jar负责运行测试命令。</p> 
<p><strong>Appium客户端。</strong></p> 
<p>它主要是指实现了Appium功能的WebDriver协议的客户端Library，它负责与Appium服务器建立连接，并将测试脚本的指令发送到Appium服务器。现有的客户端Library有多种语言的实现，包括Ruby、Python、Java、JavaScript（Node.js）、Object C、PHP和C#。Appium的测试是在这些Library的基础上进行开发的。</p> 
<h4 id="Appium%E7%BB%84%E4%BB%B6"><strong>Appium组件</strong></h4> 
<p><strong>Appium Server</strong></p> 
<p>Appium Server就是Appium的服务端——一个web接口服务，使用Node.js实现。引用官网解释说明。</p> 
<p><strong>Appium Desktop</strong></p> 
<p>Appium Desktop是一款适用于Mac，Windows和Linux的开源应用程序，它以美观而灵活的用户界面为您提供Appium自动化服务器的强大功能。 它是几个Appium相关工具的组合：</p> 
<ol>
<li> <p>Appium Server的图形界面。 您可以设置选项，启动/停止服务器，查看日志等…您也不需要使用Node 的NPM来安装Appium，因为Node运行时与Appium Desktop捆绑在一起。</p> </li>
<li> <p>您可以使用Inspector查看应用程序的元素，获取有关它们的基本信息，并与它们进行基本的交互。</p> </li>
</ol> 
<p><strong>Appium GUI</strong></p> 
<p>Appium GUI是Appium desktop的前身。 这个也是把Appium server封装成了一个图形界面，降低使用门槛，如同最初的操作系统Dos都是敲命令，后面都是图形界面操作系统，如Windows系统。很多初学者对下面这个界面应该不陌生吧，这个就是Windows版本的Appium GUI界面。测试人员可以手动启动，配置相关server 服务，如果不用这个启动的话，需要命令启动服务。因为大部分教程都是基于这个GUI来讲解的，所以很多人一说Appium就认为是这个。</p> 
<p><strong>Appium Clients</strong></p> 
<p>因为Appium是一个C/S结构，有了服务端的肯定还有客户端，Appium Clients就是客户端，它会给服务端Appium Server发送请求会话来执行自动化任务。就像我们浏览器访问网页，浏览器是客户端，通过操作发送请求服务器来获取数据。我们可以使用不同的客户端浏览器（IE，Firefox,Chrome）访问一个网站。 Appium客户端可以使用不同的语言来实现，如Python，java等。具体详见下表：</p> 
<table><tbody>
<tr>
<td style="vertical-align:top">Language/Framework</td>
<td style="vertical-align:top">Github Repo and Installation Instructions</td>
</tr>
<tr>
<td style="vertical-align:top">Ruby</td>
<td style="vertical-align:top">https://github.com/appium/ruby_lib</td>
</tr>
<tr>
<td style="vertical-align:top">Python</td>
<td style="vertical-align:top">https://github.com/appium/python-client</td>
</tr>
<tr>
<td style="vertical-align:top">Java</td>
<td style="vertical-align:top">https://github.com/appium/java-client</td>
</tr>
<tr>
<td style="vertical-align:top">JavaScript (Node.js)</td>
<td style="vertical-align:top">https://github.com/admc/wd</td>
</tr>
<tr>
<td style="vertical-align:top">Objective C</td>
<td style="vertical-align:top">https://github.com/appium/selenium-objective-c</td>
</tr>
<tr>
<td style="vertical-align:top">PHP</td>
<td style="vertical-align:top">https://github.com/appium/php-client</td>
</tr>
<tr>
<td style="vertical-align:top">C# (.NET)</td>
<td style="vertical-align:top">https://github.com/appium/appium-dotnet-driver</td>
</tr>
<tr>
<td style="vertical-align:top">RobotFramework</td>
<td style="vertical-align:top">https://github.com/jollychang/robotframework-appiumlibrary</td>
</tr>
</tbody></table> 
<p><strong>Appium-desktop</strong></p> 
<p>Appium-desktop主界面包含三个菜单Simple,Advanced、Presets</p> 
<h4 id="Capability">Capability</h4> 
<p><strong>什么是Capability</strong></p> 
<p>desired capability的功能是配置Appium会话。他们告诉Appium服务器您想要自动化的平台和应用程序。</p> 
<p>Desired Capabilities是一组设置的键值对的集合，其中键对应设置的名称，而值对应设置的值。（如：“platformName”: “Android”）Desired Capabilities主要用于通知Appium服务器建立需要的Session。</p> 
<p><strong>Session</strong></p> 
<p>Appium的客户端和服务端之间进行通信都必须在一个Session的上下文中进行。客户端在发起通信的时候首先会发送一个叫作“Desired Capabilities”的JSON对象给服务器。服务器收到该数据后，会创建一个session并将session的ID返回到客户端。之后客户端可以用该session的ID发送后续的命令。</p> 
<p><strong>常用Capability配置讲解</strong></p> 
<p>Capability官方完整文档</p> 
<p>如果有了解过Capability的人会发现一个问题，其实他主要分成了三部分：公共部分、ios部分、android部分，如果你android想用ios的那是不可能的，so，老老实实去了解每个平台有哪些，他们的作用是什么。下面我们介绍一些公用常用的,红色标记的为常用的选项。</p> 
<p><strong>公用Capability</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7c/27/29jMRGZg_o.png"></p> 
<p><strong>Android独有Capability</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/52/85/5wvJwYyB_o.png"></p> 
<p><strong>ios独有Capability</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f8/d0/HqmlLcPU_o.png"></p> 
<h4 id="Capability%E5%90%AF%E5%8A%A8App%E6%BC%94%E7%A4%BA">Capability启动App演示</h4> 
<p><strong>New Session Window 会话建立</strong></p> 
<ul>
<li> <p>Automatic Server 本地AppiumServer服务</p> </li>
<li> <p>Custom Server：例如，如果要针对运行在网络中另一台计算机上的Appium服务器启动Inspector会话，这很有用。</p> </li>
<li> <p>Sauce Labs：如果您无法访问机器上的iOS模拟器，则可以利用Sauce Labs帐户在云中启动Appium会话。</p> </li>
<li> <p>TestObject：您还可以利用TestObject的真实设备云来进行真机测试。</p> </li>
<li> <p>headspin:使用远程设备来创建会话。</p> </li>
</ul> 
<p>desired capability参数Josin</p> 
<pre><code class="hljs">{
  "platformName": "Android",
  "platformVersion": "5.1.1",
  "deviceName": "127.0.0.1:62025",
  "appPackage": "com.tal.kaoyan",
  "appActivity": "com.tal.kaoyan.ui.activity.SplashActivity",
  "noReset": true
}</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9f/4b/R7MLAQ0F_o.png"></p> 
<p>新的会话窗口允许您构造一组desired capabilities，用于启动Appium会话。您可以针对当前运行的Appium Desktop服务器(默认的)启动一个会话，或者您可以针对各种其他端点启动一个会话。</p> 
<p>因为不需要使用Appium Desktop自己的服务器，您可以在不启动Appium Desktop服务器的情况下进入新的会话窗口。只需点击“File”(Windows / Linux)或“Appium”(Mac)，然后选择“New Session…”，它将打开新的会话窗口，而不必启动本地服务器。在这种情况下，将禁用附加到本地服务器。</p> 
<p><strong>Inspector元素获取</strong></p> 
<p>启动成功之后就可以使用 Inspector来进行元素空间获取了。 注意：默认的元素定位有一些不准，需要切换到第二个坐标点定位选项后再切换回来才能准确定位。 在这里插入图片描述</p> 
<h4 id="appium%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D">appium元素定位</h4> 
<p><strong>元素定位</strong></p> 
<p>与Web自动化测试一样，app自动化测试过程中最重要一个环节就是元素定位，只有准确定位到了元素才能进行相关元素的操作，如输入、点击、拖拽、滑动等。appium提供了许多元素定位的方法，如id定位、name定位、class定位、层级定位等等… 接下来将会给大家来实践运用这些定位技巧。</p> 
<p><strong>元素定位方式</strong></p> 
<ul>
<li> <p>id</p> </li>
<li> <p>name</p> </li>
<li> <p>class name</p> </li>
<li> <p>List定位</p> </li>
<li> <p>相对定位</p> </li>
<li> <p>Xpath定位</p> </li>
<li> <p>H5页面元素定位</p> </li>
<li> <p>Uiautomator定位</p> </li>
</ul> 
<h4 id="UIAutomator">UIAutomator</h4> 
<p><strong>UIAutomator定位简介</strong></p> 
<p>UIAutomator元素定位是 Android 系统原生支持的定位方式，虽然与 xpath 类似，但比它更加好用，且支持元素全部属性定位.定位原理是通过android 自带的android uiautomator的类库去查找元素。 Appium元素定位方法其实也是基于Uiautomator来进行封装的。</p> 
<p>使用方法 find_element_by_android_uiautomator() 可以运用UiAutomator元素定位。</p> 
<p><strong>定位方法</strong></p> 
<ul>
<li> <p>id定位</p> </li>
<li> <p>text定位</p> </li>
<li> <p>class name定位</p> </li>
</ul> 
<p><strong>id定位</strong></p> 
<p>id定位是根据元素的resource-id属性来进行定位，使用 UiSelector().resourceId()方法即可。</p> 
<p><strong>text定位</strong></p> 
<p>text定位就是根据元素的text属性值来进行定位，new UiSelector()</p> 
<p><strong>class name定位</strong></p> 
<p>与Appium class定位方式一样，也是根据元素的class属性来进行定位。</p> 
<p><strong>元素等待</strong></p> 
<p><strong>思考</strong></p> 
<p>在自动化过程中，元素出现受网络环境，设备性能等多种因素影响。因此元素加载的时间可能不一致，从而会导致元素无法定位超时报错，但是实际上元素是正常加载了的，只是出现时间晚一点而已。那么如何解决这个问题呢？</p> 
<p><strong>元素等待作用</strong></p> 
<p>设置元素等待可以更加灵活的制定等待定位元素的时间，从而增强脚本的健壮性，提高执行效率。</p> 
<p><strong>元素等待类型</strong></p> 
<p><strong>强制等待</strong></p> 
<p>设置固定的等待时间，使用sleep()方法即可实现</p> 
<pre>from time import sleep
#强制等待5秒
sleep(5)</pre> 
<p><strong>隐式等待</strong></p> 
<p>隐式等待是针对全部元素设置的等待时间</p> 
<pre><code class="hljs">driver.implicitly_wait(20)</code></pre> 
<p><strong>显式等待</strong></p> 
<p>显式等待是针对某个元素来设置的等待时间。</p> 
<p>方法WebDriverWait格式参数如下：</p> 
<pre><code class="hljs">from selenium.webdriver.support.ui import WebDriverWait
 
WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)
driver : WebDriver
timeout : 最长超时时间，默认以秒为单位
poll_frequency : 休眠时间的间隔时间，默认为0.5秒
ignored_exceptions : 超时后的异常信息，默认情况下抛NoSuchElementException异常。</code></pre> 
<p>WebDriverWait()一般和until()或until_not()方法配合使用，另外，lambda提供了一个运行时动态创建函数的方法。</p> 
<pre><code class="hljs">from selenium.webdriver.support.ui import WebDriverWait
WebDriverWait(driver,10).until(lambda x:x.find_element_by_id("elementID"))</code></pre> 
<h4 id="Toast">Toast</h4> 
<p><strong>Toast简介</strong></p> 
<p>Android中的Toast是一种简易的消息提示框。 当视图显示给用户，在应用程序中显示为浮动。和Dialog不一样的是，它永远不会获得焦点，无法被点击。</p> 
<p>Toast</p> 
<p>类的思想就是尽可能不引人注意，同时还向用户显示信息，希望他们看到。而且Toast显示的时间有限，一般3秒左右就消失了。因此使用传统的元素定位工具，我们是无法定位到Toast元素的（传说中低调奢华有内涵）。</p> 
<p><strong>Appium Toast内容获取</strong></p> 
<p>Appium 1.6.3开始支持识别Toast内容，主要是基于UiAutomator2，因此需要在Capablity配置如下参数：</p> 
<pre><code class="hljs">desired_caps['automationName']='uiautomator2'</code></pre> 
<p>安装appium-uiautomator2-driver: 安装命令如下：</p> 
<pre><code class="hljs">cnpm install appium-uiautomator2-driver</code></pre> 
<p>注意：Toast内容为中文时，顶部必须注释#</p> 
<p>coding=utf-8 否则会因为编解码导致文字识别失败。</p> 
<h4 id="%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">屏幕截图</h4> 
<p><strong>应用背景</strong></p> 
<p>在实际自动化项目运行过程中，很多时候App可以会出现各种异常，为了更好的定位问题，除了捕捉日志我们还需要对运行时的设备状态来进行截屏。从而达到一种“有图有真相”的效果。</p> 
<p><strong>截图方法</strong></p> 
<p><strong>方法1</strong></p> 
<pre><code class="hljs">save_screenshot() 该方法直接保存当前屏幕截图到当前脚本所在文件位置。
driver.save_screenshot('login.png')</code></pre> 
<p><strong>方法2</strong></p> 
<pre><code class="hljs">get_screenshot_as_file(self, filename)</code></pre> 
<p>将截图保留到指定</p> 
<p class="img-center"><img alt="" height="43" src="https://images2.imgbox.com/39/a5/DpyXCBZh_o.gif" width="134"></p> 
<p> 作为一位过来人也是希望大家少走一些弯路，希望能对你带来帮助。（WEB自动化测试、app自动化测试、接口自动化测试、持续集成、自动化测试开发、大厂面试真题、简历模板等等），相信能使你更好的进步！ </p> 
<p>留【自动化测试】即可<a class="link-info has-card" href="http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&amp;k=8hUKwUHn9HhVpR8qWhqfT2u-kU-3hpsF&amp;authKey=47BBG1nwHVOka38EQeJevQFCP%2BeVEf%2Bpd8QqotS1%2FqyJdrGAo1A6%2BfS9ef3wJij2&amp;noverify=0&amp;group_code=574737577" title="【自动化测试交流】：574737577（备注ccc）"><span class="link-card-box"><span class="link-title">【自动化测试交流】：574737577（备注ccc）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/13/43/bwgk5Io7_o.png" alt="icon-default.png?t=N4P3">http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&amp;k=8hUKwUHn9HhVpR8qWhqfT2u-kU-3hpsF&amp;authKey=47BBG1nwHVOka38EQeJevQFCP%2BeVEf%2Bpd8QqotS1%2FqyJdrGAo1A6%2BfS9ef3wJij2&amp;noverify=0&amp;group_code=574737577</span></span></a></p> 
<p class="img-center"><img alt="" height="751" src="https://images2.imgbox.com/da/de/8myIDjUx_o.png" width="800"></p> 
<p> </p> 
<p> </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>