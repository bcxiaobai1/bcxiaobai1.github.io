<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>密码学与网络安全—知识点总结 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">密码学与网络安全—知识点总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="_1"></a>前言</h1> 
<p>本文为期末考试后结合一些资料整理完成的，涵盖山东大学软件学院信息安全导论的课程主要内容，参考书为《密码编码学与网络安全》。我列居了81个名词概念，31道经典问答题。<br> 先附上所有知识点的word版与pdf版，并添加了目录，方便复习。</p> 
<p><a href="https://download.csdn.net/download/qq_50860232/69653804">电子版下载地址</a></p> 
<p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#_1">前言</a></li>
<li><a href="#_16">一、概念（名词解释）</a></li>
<li>
<ul>
<li><a href="#1_17">1、对称加密</a></li>
<li><a href="#2_21">2、会话密钥</a></li>
<li><a href="#3_25">3、混合密码体制:</a></li>
<li><a href="#4_29">4、非对称加密/公钥/私钥:</a></li>
<li><a href="#5digital_certificate_33">5、数字证书（digital certificate）</a></li>
<li><a href="#6CA_37">6、CA机构</a></li>
<li><a href="#7Block_Cipher_42">7、分组算法Block Cipher：</a></li>
<li><a href="#8_Stream_Cipher_46">8、流算法 Stream Cipher:</a></li>
<li><a href="#9LFSRlinear_feedback_shift_register_50">9、LFSR（linear feedback shift register）</a></li>
<li><a href="#10DES_Data_Encryption_Standard_56">10、DES （Data Encryption Standard）</a></li>
<li><a href="#113DES_64">11、3DES</a></li>
<li><a href="#12AESAdvanced_Encryption_Standard_68">12、AES（Advanced Encryption Standard）</a></li>
<li><a href="#13SBoxsubstitution_box_72">13、S-Box（substitution box）</a></li>
<li><a href="#14ECBElectronic_Codebook_76">14、ECB（Electronic Codebook）</a></li>
<li><a href="#15CBCCipherblock_chaining_81">15、CBC（Cipher-block chaining）</a></li>
<li><a href="#16CFB_86">16、CFB</a></li>
<li><a href="#17OFB_93">17、OFB</a></li>
<li><a href="#18CTR_100">18、CTR</a></li>
<li><a href="#16IVInitialization_Vector_107">16、IV（Initialization Vector）:</a></li>
<li><a href="#17XTS_113">17、XTS</a></li>
<li><a href="#18Salt_118">18、Salt:</a></li>
<li><a href="#19RC4_122">19、RC4</a></li>
<li><a href="#20MD5_126">20、MD5</a></li>
<li><a href="#21SHA1_130">21、SHA1</a></li>
<li><a href="#22SHA2_135">22、SHA2</a></li>
<li><a href="#23MAC_139">23、MAC</a></li>
<li><a href="#24HMAC_142">24、HMAC</a></li>
<li><a href="#25DiffieHellman_key_agreement_protocol_146">25、Diffie-Hellman key agreement protocol</a></li>
<li><a href="#26DLP_150">26、离散对数问题DLP</a></li>
<li><a href="#27ElGamal_152">27、ElGamal加密算法</a></li>
<li><a href="#28IPSecInternetProtocolSecurity_156">28、IPSec（InternetProtocolSecurity）</a></li>
<li><a href="#29SSLHTTPS_163">29、SSL/HTTPS</a></li>
<li><a href="#30OpenSSl_172">30、OpenSSl</a></li>
<li><a href="#31HTTPS_176">31、HTTPS</a></li>
<li><a href="#32VPNVirtual_Private_Network_179">32、VPN（Virtual Private Network）</a></li>
<li><a href="#33OpenVPN_185">33、OpenVPN</a></li>
<li><a href="#34PGPPretty_Good_Privacy_191">34、PGP(Pretty Good Privacy)</a></li>
<li><a href="#35GPG_198">35、GPG</a></li>
<li><a href="#36DDoSDistributed_Denial_of_Service_203">36、DDoS（Distributed Denial of Service）</a></li>
<li><a href="#37rootkit_208">37、rootkit</a></li>
<li><a href="#38PKCS5PKCS1PKCS3_214">38、PKCS#5、PKCS#1、PKCS#3</a></li>
<li><a href="#39nonce_220">39、nonce</a></li>
<li><a href="#40_223">40、一次一密</a></li>
<li><a href="#41_226">41、无条件安全性</a></li>
<li><a href="#42_229">42、计算安全性</a></li>
<li><a href="#43_232">43、可证明安全性</a></li>
<li><a href="#44_235">44、应用安全性</a></li>
<li><a href="#45_242">45、雪崩效应</a></li>
<li><a href="#46Feistel_245">46、Feistel密码结构</a></li>
<li><a href="#47DH_256">47、DH加密算法</a></li>
<li><a href="#48_263">48、计算机安全</a></li>
<li><a href="#49CIA_267">49、安全需求三元组——CIA</a></li>
<li><a href="#50OSI_273">50、OSI安全框架</a></li>
<li><a href="#51_277">51、安全攻击</a></li>
<li><a href="#52_282">52、安全机制：</a></li>
<li><a href="#53_288">53、安全服务</a></li>
<li><a href="#54_293">54、网络安全模型</a></li>
<li><a href="#55_298">55、攻击密码系统的两种通用方法</a></li>
<li><a href="#56_303">56、代替技术和置换技术</a></li>
<li><a href="#57Caesar_307">57、Caesar密码</a></li>
<li><a href="#58_314">58、单表代替密码</a></li>
<li><a href="#59Playfair_318">59、Playfair密码</a></li>
<li><a href="#60_323">60、多表代替密码</a></li>
<li><a href="#61_327">61、乘积密码</a></li>
<li><a href="#62_330">62、两种对付传统分析的方法：</a></li>
<li><a href="#63_335">63、差分分析和线性分析的区别</a></li>
<li><a href="#64_339">64、多重加密：</a></li>
<li><a href="#65_343">65、中间相遇攻击</a></li>
<li><a href="#66_348">66、费马定理</a></li>
<li><a href="#67_354">67、欧拉函数</a></li>
<li><a href="#68_362">68、欧拉定理</a></li>
<li><a href="#69CRT_369">69、中国剩余定理CRT</a></li>
<li><a href="#70_375">70、本原根</a></li>
<li><a href="#71_379">71、离散对数</a></li>
<li><a href="#72_384">72、单向函数</a></li>
<li><a href="#73_388">73、单向陷门函数：</a></li>
<li><a href="#74MITM_391">74、中间人攻击MITM</a></li>
<li><a href="#75_393">75、时间戳</a></li>
<li><a href="#76_397">76、动态口令牌</a></li>
<li><a href="#77_400">77、端到端加密</a></li>
<li><a href="#78_402">78、密钥分发和密钥管理</a></li>
<li><a href="#79_407">79、双向认证/相互认证</a></li>
<li><a href="#80_410">80、重放攻击</a></li>
<li><a href="#81Kerberos_412">81、Kerberos</a></li>
</ul>
  </li>
<li><a href="#_417">二、问答题</a></li>
</ul>
</div>
<p></p> 
<hr size='1"'> 
<h1>
<a id="_16"></a>一、概念（名词解释）</h1> 
<h2>
<a id="1_17"></a>1、对称加密</h2> 
<p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。也称为单密钥加密或传统加密。加密解密使用相同密钥，解密算法是加密算法的逆过程。使用代替和置换技术。<br> 其安全性依赖于所持有密钥的安全性。<br> 对称密钥五要素：明文、密文、加密算法、解密算法、密钥。</p> 
<h2>
<a id="2_21"></a>2、会话密钥</h2> 
<p>是保证用户跟其它计算机或者两台计算机之间安全通信会话而随机产生的加密和解密密钥。会话密钥从密钥分发中心得到。<br> 会话密钥有时称作对称密钥，因为同一密钥用于加密和解密。<br> 由于其大部分安全性依赖于其使用时间的短暂性，会话密钥常常频繁更改。各个消息可能使用不同的会话密钥。</p> 
<h2>
<a id="3_25"></a>3、混合密码体制:</h2> 
<p>在对称加密算法中会产生密钥在传输过程中的不安全，所以用公钥密码加密一个用于对称加密的短期密码，再由这个短期密码在对称加密体制下加密实际需要安全传输的数据。在另一方用对称密钥进行解密<br> 对称算法与公钥算法的结合，利用公钥算法进行签名和认证，用公钥算法传输会话密钥，用会话密钥/对称算法加密批量数据</p> 
<h2>
<a id="4_29"></a>4、非对称加密/公钥/私钥:</h2> 
<p>使用两个密钥来进行加密和解密，这两个密钥分别是公钥和私钥。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。非对称加密使用一对密钥，一个用来加密，一个用来解密，公开的一个为公钥，自己保存的一个为私钥。<br> 公钥/密钥对中公开的部分<br> 私钥/密钥对中非公开的部分</p> 
<h2>
<a id="5digital_certificate_33"></a>5、数字证书（digital certificate）</h2> 
<p>指的是利用数字签名技术将用户的真实身份和用户的公开密钥进行有效绑定而形成的数字身份证明。X509标准是数字证书规范的标准。就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。数字证书是一种权威性的电子文档，它是由CA机构发行的，人们可以在网上用它来识别对方的身份。<br> 证书主要内容：用户公钥，持有人和签发人的信息，用途，有效期限，签名等。<br> 证书在需要通信时临时交换，并用CA的公钥验证。有了经CA签名保证的用户公钥，则可进行下一步的身份验证和交换会话密钥等。</p> 
<h2>
<a id="6CA_37"></a>6、CA机构</h2> 
<p>又称为证书授证（Certificate Authority）中心，作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。（证书管理机构）<br> 每个用户自己产生一对公钥和私钥，并把公钥提交给CA申请证书。CA以某种可靠的方法核对申请人的身份及其公钥，并用自己的私钥签发证书。<br> CA中心为每个使用公开密钥的用户发放一个数字证书，数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公开密钥。<br> CA机构的数字签名使得攻击者不能伪造和篡改证书。它负责产生、分配并管理所有参与网上交易的个体所需的数字证书，因此是安全电子交易的核心环节。</p> 
<h2>
<a id="7Block_Cipher_42"></a>7、分组算法Block Cipher：</h2> 
<p>一种加/解密算法，其将输入的明文划分为固定长度的块（即分组），对每个分组做相同的加/解密处理，输出一个等长的密文分组，Feistel结构是其主要使用的结构。典型的分组大小为64位和128位。<br> 分组密码算法实际上就是密钥控制下，通过某个置换来实现对明文分组的加密变换。<br> 为了保证密码算法的安全强度，分组密码算法必须满足一下要求：分组长度足够大、密钥量足够大、密码变换足够复杂。</p> 
<h2>
<a id="8_Stream_Cipher_46"></a>8、流算法 Stream Cipher:</h2> 
<p>又称序列密码算法，一种加/解密算法，每次加密数据流的一位或者一个字节。用密钥生成伪随机数，并将伪随机数的每一位与明文做异或。<br> 可用伪随机数发生器实现，密钥作为随机数种子，产生密钥流keystream(不重复，或极大周期)，然后把明文和该序列异或产生密文，两次异或即解密。<br> 相比于分组密码速度更快、代码量更低。但密码复用会导致易被破解。适合用于远程终端输入等应用。</p> 
<h2>
<a id="9LFSRlinear_feedback_shift_register_50"></a>9、LFSR（linear feedback shift register）</h2> 
<p>线性反馈移位寄存器是流密码中常用技术之一。线性反馈移位寄存器(LFSR)是内测试电路中最基本的标准模块结构，既用作伪随机测试码产生器，也作为压缩测试结果数据的特征分析器。由一系列D触发器及少量异或元件组成。一个N位的LFSR能够在重复之前产生2^N－1位长的伪随机序列。<br> （线性反馈移位寄存器（linear feedback shift register, LFSR）是指：给定前一状态的输出，将该输出的线性函数再用作输入的移位寄存器。异或运算是最常见的单比特线性函数：对寄存器的某些位进行异或操作后作为输入，再对寄存器中的各比特进行整体移位。<br> <img src="https://images2.imgbox.com/dd/58/0kdaB3vA_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="10DES_Data_Encryption_Standard_56"></a>10、DES （Data Encryption Standard）</h2> 
<p>即数据加密标准，是使用最广泛的对称加密算法，速度较快，适用于加密大量数据的场合。是一种使用密钥加密的块算法。使用Feistel结构。<br> DES算法的入口参数有三个:Key、Data、Mode。其中Key为8个字节共64位,是DES算法的工作密钥.在实际使用中，实际上只使用了密钥中的56位，这样才更具有安全性；Data为8个字节64位,是要被加密或被解密的数据；Mode为DES的工作方式,有两种:加密或解密。<br> 先将输入明文分为两组，密钥也分为两组，每组经过表置换后与密钥的一组做异或，将之后的结果输入S盒，与另一组明文做异或后为第一组加密的结果。<br> 密钥长度为56位，分组长度64位。依赖密钥易受穷举搜索法攻击。<br> 加密时明文经过初始置换、16轮相同函数作用、32位互换和逆初始置换三个阶段，其密钥则经过循环左移和第二次置换选择生成子密钥参与到加密中。解密过程与加密过程使用相同算法，但子密钥使用次序相反。<br> <img src="https://images2.imgbox.com/9c/86/oqxDseHU_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="113DES_64"></a>11、3DES</h2> 
<p>（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。<br> 由于DES在穷举攻击下较弱，故使用三重DES增加复杂性（3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。），其中可以用三个（56bit）密钥进行三重加密，也可以用两个密钥进行三重加密。<br> 加密定义：C=E(K1,D(K2,E(K1,P)))或者C=E(K3,D(K2,E(K1,P)))。能有效提升密码破解难度。应用于PGP。比DES算法密钥长，更安全可靠。优点是能继续使用原有的DES软硬件模块，保护了投资；缺点是速度慢，而且64位分组显得太小是DES向AES过渡的加密算法.</p> 
<h2>
<a id="12AESAdvanced_Encryption_Standard_68"></a>12、AES（Advanced Encryption Standard）</h2> 
<p>高级加密标准，是一种对称、分组密码算法，用以取代DES的商业应用。分组长度为128位，被分为4*4字节矩阵处理（这个矩阵又称为“体（state）”，其初值就是一个明文区块），密钥长度为128、192、256位，未使用Feistel结构，每轮由四个单独的运算，字节替代、置换、有限域上的算数、与密钥的异或。<br> AES的所有运算都是在8为位的字节上进行的。加密和解密算法的输入是一个128为分组。AES加密过程是在一个4×4的字节矩阵上运作。<br> 是下一代的加密算法标准，速度快，安全级别高，可抗已知攻击代码紧凑，速度够快，适合软硬件实现，结构简单。</p> 
<h2>
<a id="13SBoxsubstitution_box_72"></a>13、S-Box（substitution box）</h2> 
<p>直译为“密码置换盒”,是种二级加密装置 .你把二进制数输入S-box,它们就会转化为既定的数字,相当于给密码加了密码一样,从而提高了安全系数。<br> 对称密钥算法执行置换计算的基本结构，S盒的每行都定义了一个普通的可逆代替。在块密码中，它们通常用于模糊密钥和密文之间的关系。输入N输出M，是非线性的。</p> 
<h2>
<a id="14ECBElectronic_Codebook_76"></a>14、ECB（Electronic Codebook）</h2> 
<p>DES和AES五种工作模式之一，电码本模式，是分组密码的一种最基本的工作模式。<br> 直接利用加密算法分别对分组数据组加密。它一次处理一组明文分块，每次使用相同的密钥加密。适合于数据较少的情况，最重要的特征是一段消息中若有几个相同的明文组，那么密文也将出现几个相同的密文组。<br> 优点：并行加密，随机存取。缺点：相同明文分组对应相同密文分组，暴露统计规律。<br> 应用于单个数据的安全传输（比如一个加密密钥）。</p> 
<h2>
<a id="15CBCCipherblock_chaining_81"></a>15、CBC（Cipher-block chaining）</h2> 
<p>DES和AES五种工作模式之一，密文分组链接模式，这种模式下加密算法的输入是当前的明文组和上一个密文组的异或，而使用的密钥是相同的，这就相当于将所有的明文组链接起来了，加密算法的每次输入与本明文组没有固定的关系，因此，若有重复的明文组，加密后就看不出来了。并且，CBC模式如果最后的分组不是完整的分组，则需要填充至b位的满分组。解密时，每个密文分组分别进行解密，再与上一块密文异或就可以恢复成明文。<br> 优点：避免明密对应，可用作认证。缺点：不能并行加密随机存取。等待缓冲区满8bit，否则需要做padding。<br> 典型应用于普通目的的面向分组的传输和认证。</p> 
<h2>
<a id="16CFB_86"></a>16、CFB</h2> 
<p>DES和AES五种工作模式之一，密文反馈模式。一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出与明文异或作为下一单元的密文。<br> 优点：可以使用不同的初始化变量使相同的明文产生不同的密文，防止字典攻击；无填充<br> 缺点：一旦某位数据出错,会影响目前和其后8个块的数据<br> 应用：面向数据流的通用传输；认证</p> 
<h2>
<a id="17OFB_93"></a>17、OFB</h2> 
<p>DES和AES五种工作模式之一，输出反馈模式。一次处理一个分组，加密算法的输入是上一次加密的输出，<br> 优点：传输过程中在某位上发生的错误不会影响其他位；无填充<br> 缺点：抗消息流篡改攻击的能力较弱<br> 应用：噪声信道上的数据流的传输</p> 
<h2>
<a id="18CTR_100"></a>18、CTR</h2> 
<p>DES和AES五种工作模式之一，计数器模式。每一个明文分组都与一个经过加密的计数器异或。对每个后续的分组，计数器递增。<br> 优点：硬件效率；软件效率；预处理；随机访问；可证明安全性；简单性；无填充<br> 缺点：<br> 应用：面向分组的通用传输；用于高速需求</p> 
<h2>
<a id="16IVInitialization_Vector_107"></a>16、IV（Initialization Vector）:</h2> 
<p>初始向量，是和密文具有相同长度的数据分组。<br> IV必须为收发双方共享，但第三方不能预测，可以先用ECB加密IV然后在发送。<br> 在有线等效保密（WEP）协议中，IV是用来和密钥组合成密钥种子，作为RC4算法的输入，来产生加密字节流对数据进行加密的。标准的64比特WEP使用40比特的钥匙接上24比特的初向量(Initialization Vector，IV) 成为 RC4 用的钥匙。<br> 特别地，对于任意的给定明文，在IV产生之前，不能预测和本明文相关联的IV。为了最大程度的安全，IV不能不经授权而修改。</p> 
<h2>
<a id="17XTS_113"></a>17、XTS</h2> 
<p>五种工作模式之一，是一种针对磁盘的加密模式，满足七个定理，是最新的分组密码模式。它被指定为 CBC 等其他可用分组密码模式的更为强大的备选方案。<br> XTS 使用两个 AES 密钥，其中一个用于执行 AES 分组加密；另一个用于加密“调整值”。逆向执行此流程即可实现数据解密。<br> 因为各个分组相互独立且没有链接，因此如果存储的密码数据受损并崩溃，则只有特定分组的数据不可恢复。（老师：XTS在ECB和CBC基础之上的折中。对一个需要随机访问的大文件、大分区、大磁盘，对ECB、CBC的缺点都不能忍受，折中的做法是对每个扇区512字节，或者比如每4k字节，使用类似CBC的加密方法，也有IV。这个IV通常就采用扇区序列号。<br> XTS-AES模式适合并行执行，因为没有链接，多个分组可以同时加密或解密且可以随机访问的</p> 
<h2>
<a id="18Salt_118"></a>18、Salt:</h2> 
<p>“盐值，在这个值是由系统随机生成的，并且只有系统知道。是用来修改口令散列的随机数据串。<br> 所谓加Salt，就是加点“佐料”。当用户首次提供密码时（通常是注册时），由系统自动往这个密码里加一些“Salt值”，这个值是由系统随机生成的，并且只有系统知道。然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“Salt值”，然后散列，再比较散列值，已确定密码是否正确。 　Salt值增加了字典攻击的复杂性，防止攻击者使用字典单词来检验整个系统。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。</p> 
<h2>
<a id="19RC4_122"></a>19、RC4</h2> 
<p>一种流加密算法，每次加密一字节的明文，用K生成随机数与明文做异或；通过设计合适的伪随机数发生器，当密钥长度相当时，流密码可以与分组密码一样安全。<br> 密钥长度可变（核心S盒长度任意，但一般为256字节。）该算法的速度可以达到DES加密的10倍左右，且具有很高级别的非线性。<br> 被用于SSL/TLS（安全套接字协议/传输层安全协议）标准。也应用于作为IEEE802.11标准一部分的WEP（Wired Equivalent Privacy）协议。算法包括初始化算法（KSA）和伪随机子密码生成算法（PRGA）。</p> 
<h2>
<a id="20MD5_126"></a>20、MD5</h2> 
<p>Message Digest Algorithm 5 （消息摘要算法第五版）为计算机安全领域广泛使用的一种散列（hash)函数，用于确保信息传输完整一致。MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被"压缩"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）<br> 常用的一种hash函数之一，输出128bit，内部处理以512bit为单位，另一个常用的hash算法是SHA1.<br> MD5算法具有以下特点：1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。2、容易计算：从原数据计算出MD5值很容易。3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。4、强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据是非常困难的。（5、输入任意长度输出128比特。）</p> 
<h2>
<a id="21SHA1_130"></a>21、SHA1</h2> 
<p>（Secure Hash Algorithm 1）是使用最广泛的hash算法的一种，建立在MD4只上，输出为160位hash值。安全哈希算法主要适用于数字签名标准里面定义的数字签名算法。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。<br> 特性：1不可以从消息摘要中复原信息；2两个不同的消息不会产生同样的消息摘要(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。</p> 
<h2>
<a id="22SHA2_135"></a>22、SHA2</h2> 
<p>sha的第二个版本，SHA-224、SHA-256、SHA-384，和SHA-512并称为SHA-2。它的算法跟SHA-1基本上相似。<br> <img src="https://images2.imgbox.com/63/8f/knU76M5O_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="23MAC_139"></a>23、MAC</h2> 
<p>消息鉴别（验证）码（带密钥的Hash函数），是用来验证消息完整性的校验码，确保收到的数据确实和发送的数据一样，且发送方的身份是真实有效的。MAC是消息和密钥的函数，它产生定长的值，该值作为认证符。一方用密钥与明文产生mac，接收方收到后用相同的密钥产生mac，与附带的mac值作比对来确保数据完整性。</p> 
<h2>
<a id="24HMAC_142"></a>24、HMAC</h2> 
<p>利用现有的hash函数，加入密钥作为输入，用作mac的生成，就是HMAC。<br> HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。把HASH值和一个Key结合起来既能用当前的HASH函数，又易升级为新的HASH函数，并能保持和散列函数一样安全性。简单，并易进行密码学分析。利用hash函数从报文和密钥产生MAC码，先计算特征，再把特征加密，或直接把散列函数和key结合得MAC。</p> 
<h2>
<a id="25DiffieHellman_key_agreement_protocol_146"></a>25、Diffie-Hellman key agreement protocol</h2> 
<p>Diffie-Hellman密钥交换协议/算法是一种安全协议。是一种确保共享KEY安全穿越不安全网络的方法。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。<br> 但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。</p> 
<h2>
<a id="26DLP_150"></a>26、离散对数问题DLP</h2> 
<p>与RSA算法类似，离散对数加密算法也属于公钥加密算法，RSA依赖大数因数分解的困难性，而离散对数则依赖有限域上的离散指数的难计算性保障其安全。（Diffie-Hellman密钥交换和ElGamal加密算法是基于离散对数的。离散对数形式相对比较灵活，每个发送端可以在发送每条消息时指定自己的公钥，但接收端回复的消息也只有发送端才能解密。）</p> 
<h2>
<a id="27ElGamal_152"></a>27、ElGamal加密算法</h2> 
<p>ElGamal算法，是一种较为常见的加密算法，它是基于1984年提出的公钥密码体制和椭圆曲线加密体系。既能用于数据加密也能用于数字签名，其安全性依赖于计算有限域上离散对数这一难题。在加密过程中，生成的密文长度是明文的两倍，且每次加密后都会在密文中生成一个随机数K，在密码中主要应用离散对数问题的几个性质：求解离散对数（可能）是困难的，而其逆运算指数运算可以应用平方-乘的方法有效地计算。也就是说，在适当的群G中，指数函数是单向函数。<br> 缺点是需要随机数，密文长度加倍。</p> 
<h2>
<a id="28IPSecInternetProtocolSecurity_156"></a>28、IPSec（InternetProtocolSecurity）</h2> 
<p>“Internet 协议安全性 (IPSec)”是一种开放标准的框架结构，通过使用加密的安全服务以确保在 Internet 协议 (IP) 网络上进行保密而安全的通讯。是安全联网的长期方向。它通过端对端的安全性来提供主动的保护以防止专用网络与 Internet 的攻击。在通信中，只有发送方和接收方才是唯一必须了解 IPSec 保护的计算机。<br> IPSec是一组IP安全协议集。IPSec定义了在网际层使用的安全服务，其功能包括数据加密、对网络单元的访问控制、数据源地址验证、数据完整性检查和防止重放攻击。<br> IPSec的安全服务要求支持共享密钥完成认证和/或保密，并且手工输入密钥的方式是必须要支持的，其目的是要保证IPSec协议的互操作性。当然，手工输入密钥方式的扩展能力很差，因此在IPSec协议中引入了一个密钥管理协议，称Internet密钥交换协议——IKE，该协议可以动态认证IPSec对等体，协商安全服务，并自动生成共享密钥。<br> 能够实现ip分组的完整性，加密和认证服务。</p> 
<h2>
<a id="29SSLHTTPS_163"></a>29、SSL/HTTPS</h2> 
<p>SSL（安全套接层）Secure Socket Layer：定义了一组多个连接共享的密码安全参数。用以保障在Internet上数据传输安全，利用数据加密(Encryption)技术，可确保数据在网络上的传输过程中不会被截取及窃听。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。<br> SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。<br> 提供服务<br> 1）认证用户和服务器，确保数据发送到正确的客户机和服务器；<br> 2）加密数据以防止数据中途被窃取；<br> 3）维护数据的完整性，确保数据在传输过程中不被改变。(机密性：SSL协议使用密钥加密通信数据。可靠性：服务器和客户都会被认证，客户的认证是可选的。完整性：SSL协议会对传送的数据进行完整性检查。)</p> 
<h2>
<a id="30OpenSSl_172"></a>30、OpenSSl</h2> 
<p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p> 
<h2>
<a id="31HTTPS_176"></a>31、HTTPS</h2> 
<p>（Hyper Text Transfer Protocol over Secure Socket Layer）安全套接字层超文本传输协议，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。。HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。HTTPS非常的安全，现在的支付页面都使用HTTPS。</p> 
<h2>
<a id="32VPNVirtual_Private_Network_179"></a>32、VPN（Virtual Private Network）</h2> 
<p>虚拟专用网络：用户连接一台VPN服务器，服务器再访问用户想要访问的节点或局域网，其中的传输都是加密的，因此这样级就可以认为数据是在一条专用的数据链路上进行安全传输。<br> VPN的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。<br> （为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。）</p> 
<h2>
<a id="33OpenVPN_185"></a>33、OpenVPN</h2> 
<p>是一个基于 OpenSSL 库的应用层 VPN 实现。<br> 是Linux下开源VPN的先锋，提供了良好的性能和友好的用户GUI。<br> 它并不是一个基于Web的VPN软件，也不与IPsec及其他VPN软件包兼容。<br> OpenVPN和传统 VPN 相比，它的优点是简单易用。OpenVPN允许参与建立VPN的单点使用共享金钥，电子证书，或者用户名/密码来进行身份验证。它大量使用了OpenSSL加密库中的SSLv3/TLSv1 协议函式库。OpenVPN在用户空间运行，无须对内核及网络协议栈作修改；初始完毕后以chroot方式运行，放弃root权限；使用mlockall以防止敏感数据交换到磁盘。</p> 
<h2>
<a id="34PGPPretty_Good_Privacy_191"></a>34、PGP(Pretty Good Privacy)</h2> 
<p>是一个基于RSA公钥加密体系的邮件加密软件。可以用它对邮件保密以防止非授权者阅读，它还能对邮件加上数字签名从而使收信人可以确认邮件的发送者，并能确信邮件没有被篡改。<br> 它可以提供一种安全的通讯方式，而事先并不需要任何保密的渠道用来传递密匙。<br> 它采用了一种RSA和传统加密的杂合算法，用于数字签名的邮件文摘算法，加密前压缩等，还有一个良好的人机工程设计。<br> 它的功能强大，有很快的速度。而且它的源代码是免费的。</p> 
<h2>
<a id="35GPG_198"></a>35、GPG</h2> 
<p>GPG是PGP的开源实现，在理论上能够替代PGP，而且PGP和GPG之间是互通的，PGP加密的文件可以用GPG解密，反之亦然。<br> 大多用于加密信息的传递。除了仅用密码加密外,GPG最大的不同是提供了“公钥/私钥”对。</p> 
<h2>
<a id="36DDoSDistributed_Denial_of_Service_203"></a>36、DDoS（Distributed Denial of Service）</h2> 
<p>分布式拒绝服务攻击，通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力. 最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应.<br> 通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。<br> 在信息安全的三要素——“保密性”、“完整性”和“可用性”中，DoS（Denial of Service），即拒绝服务攻击，针对的目标正是“可用性”。该攻击方式利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务。<br> 随着计算机与网络技术的发展，计算机的处理能力迅速增长，内存大大增加，同时也出现了千兆级别的网络，这使得DoS攻击的困难程度加大了-目标对恶意攻击包的"消化能力"加强了不少。这时候分布式的拒绝服务攻击手段（DDoS）就应运而生了。DDoS就是利用更多的傀儡机（肉鸡）来发起进攻，以比从前更大的规模来进攻受害者。</p> 
<h2>
<a id="37rootkit_208"></a>37、rootkit</h2> 
<p>(木马病毒等程序先把自己藏起来，rootkit是一种隐藏的高级程序，根本不能看到EXE文件等，甚至可能藏在OS之外，比如负责计算机休眠和唤醒的模块就是在OS之外的。是最高的极端境界。一般都是藏在内核比较深)。<br> Rootkit是一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络链接等信息，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。<br> 它可以持久并毫无察觉地驻留在目标计算机中，对系统进行操纵、并通过隐秘渠道收集数据的程序。Rootkit的三要素就是：隐藏、操纵、收集数据。<br> rootkit并不一定是用作获得系统root访问权限的工具。实际上，rootkit是攻击者用来隐藏自己的踪迹和保留root访问权限的工具。通常，攻击者通过远程攻击获得root访问权限，或者首先密码猜测或者密码强制破译的方式获得系统的访问权限。进入系统后，如果他还没有获得root权限，再通过某些安全漏洞获得系统的root权限。接着，攻击者会在侵入的主机中安装rootkit，然后他将经常通过rootkit的后门检查系统是否有其他的用户登录，如果只有自己，攻击者就开始着手清理日志中的有关信息。通过rootkit的嗅探器获得其它系统的用户和密码之后，攻击者就会利用这些信息侵入其它的系统。</p> 
<h2>
<a id="38PKCS5PKCS1PKCS3_214"></a>38、PKCS#5、PKCS#1、PKCS#3</h2> 
<p>PSCS（The Public-Key Cryptography Standards）基于口令的加密标准，描述了由口令生成的密钥来加密位串的方法。(PKCS)是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。<br> PKCS#5：描述一种利用从口令派生出来的安全密钥加密字符串的方法。使用MD2或MD5 从口令中派生密钥，并采用DES-CBC模式加密。主要用于加密从一个计算机传送到另一个计算机的私人密钥，不能用于加密消息。<br> PKCS#1：定义RSA公开密钥算法加密和签名机制，主要用于组织PKCS#7中所描述的数字签名和数字信封。<br> PKCS#3：定义Diffie-Hellman密钥交换协议。</p> 
<h2>
<a id="39nonce_220"></a>39、nonce</h2> 
<p>在密码学中Nonce是一个只被使用一次的任意或非重复的随机数值，在加密技术中的初始向量和加密散列函数都发挥着重要作用，在各类验证协议的通信应用中确保验证信息不被重复使用以对抗重放攻击(Replay Attack)。</p> 
<h2>
<a id="40_223"></a>40、一次一密</h2> 
<p>其安全原理是基于信息传递，双方的密钥是随机变化的，每次通讯双方传递的明文都使用同一条临时随机密钥和对称算法进行加密后方可在线路上传递。因为密钥一次一变，且无法猜测，这就保证了线路传递数据的绝对安全。</p> 
<h2>
<a id="41_226"></a>41、无条件安全性</h2> 
<p>这种评价方法考虑的是假定攻击者拥有无限的计算资源，但仍然无法破译该密码系统。</p> 
<h2>
<a id="42_229"></a>42、计算安全性</h2> 
<p>这种方法是指使用目前最好的方法攻破它所需要的计算远远超出攻击者的计算资源水平，则可以定义这个密码体制是安全的。</p> 
<h2>
<a id="43_232"></a>43、可证明安全性</h2> 
<p>这种方法是将密码系统的安全性归结为某个经过深入研究的数学难题（如大整数素因子分解、计算离散对数等），数学难题被证明求解困难。这种评估方法存在的问题是它只说明了这个密码方法的安全性与某个困难问题相关，没有完全证明问题本身的安全性，并给出它们的等价性证明。</p> 
<h2>
<a id="44_235"></a>44、应用安全性</h2> 
<p>对于实际应用中的密码系统而言，由于至少存在一种破译方法，即强力攻击法，因此都不能满足无条件安全性，只提供计算安全性。密码系统要达到实际安全性，就要满足以下准则：<br> （1）破译该密码系统的实际计算量（包括计算时间或费用）十分巨大，以致于在实际上是无法实现的。<br> （2）破译该密码系统所需要的计算时间超过被加密信息有用的生命周期。例如，战争中发起战斗攻击的作战命令只需要在战斗打响前需要保密；重要新闻消息在公开报道前需要保密的时间往往也只有几个小时。<br> （3）破译该密码系统的费用超过被加密信息本身的价值。<br> 如果一个密码系统能够满足以上准则之一，就可以认为是满足实际安全性的。</p> 
<h2>
<a id="45_242"></a>45、雪崩效应</h2> 
<p>雪崩效应就是一种不稳定的平衡状态也是加密算法的一种特征，它指明文或密钥的少量变化会引起密文的很大变化，就像雪崩前，山上看上去很平静，但是只要有一点问题，就会造成一片大崩溃。 可以用在很多场合。例如对于Hash，雪崩效应是指少量消息位的变化会引起信息摘要的许多位变化。</p> 
<h2>
<a id="46Feistel_245"></a>46、Feistel密码结构</h2> 
<p>Feistel建议使用乘积密码的概念来逼近理想分组密码。Feistel密码交替使用代替和置换来进行加密解密。<br> 加密算法的输入是最长为2w位的明文分组和密钥k。明文分组被分为等长的两部分：和。这两半数据经过n轮迭代后组合成密文分组。第i轮迭代的输入和来自上轮迭代的输出；而输入的子密钥是由整个密钥K推导出的。<br> 每轮迭代都有相同的结构：代替作用在数据的左半部分，这种代替是通过轮函数F作用于数据右半部分后，与左半部分进行异或来完成的。代替之后，交换数据的左右两半完成置换。<br> 它的具体实现依赖于以下参数和特征：<br> 分组长度：分组长度越长意味着安全性越高，但是会降低加、解密的速度。这种安全性的增加来自更好的扩散性。传统上，64位的分组长度比较合理，在分组密码设计里很常用。<br> 密钥长度：密钥较长同样意味着安全性较高，但会降低加、解密的速度。这种安全性的增加来自更好的抗穷尽攻击能力和更好的混淆性。现在一般认为64位的密钥还不够。通常使用的密钥长度是128位。<br> 迭代轮数：Feistel密码的本质在于单轮不能提供足够的安全性而多轮加密可取得很高的安全性。迭代轮数的典型值是16。<br> 子密钥产生算法：子密钥产生越复杂，密码分析就越困难。<br> 轮函数F：同样，轮函数越复杂，抗攻击的能力就越强。</p> 
<h2>
<a id="47DH_256"></a>47、DH加密算法</h2> 
<p>对称加密速度较快，所以一般加解密数据都用对称算法。而其密钥的分发管理通过非对称加密来保证。因为非对称加密（公钥）算法无需对密钥进行管理。<br> DH（Diffie-Hellman ）密钥协商算法属于公钥加密算法,为了解决密钥配送的问题，双方就某次通信达成密钥的统一。</p> 
<p><img src="https://images2.imgbox.com/2f/64/PHVZhxpz_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="48_263"></a>48、计算机安全</h2> 
<p>对于一个自动化的信息系统，采取保护措施保证系统资源的完整性、可用性。</p> 
<h2>
<a id="49CIA_267"></a>49、安全需求三元组——CIA</h2> 
<p>保密性C：对信息的访问和公开进行授权限制，包括保护个人隐私和秘密消息。<br> 完整性I：防止信息被不恰当的修改或破坏，包括信息的不可否认性和真实性。<br> 可用性A：保证对信息的及时和可靠的访问和使用。</p> 
<h2>
<a id="50OSI_273"></a>50、OSI安全框架</h2> 
<p>OSI安全体系结构中定义了鉴别、访问控制、数据机密性、数据完整性和抗抵赖五种网络安全服务，以及加密机制、数字签名机制、访问控制机制、数据完整性机制、鉴别交换机制、通信业务流填充机制、路由控制和公证机制八种基本的安全机制。OSI从三个方面研究安全问题。安全攻击 安全机制 安全服务</p> 
<h2>
<a id="51_277"></a>51、安全攻击</h2> 
<p>指任何危及信息系统安全的行为<br> 被动攻击：试图了解和利用系统信息但不破坏系统资源。（容易预防） 包括信息内容的泄漏和流量分析两种。<br> 主动攻击：试图改变系统资源或影响系统的运作。（容易检测）包括伪装、重播、消息修改、拒绝服务</p> 
<h2>
<a id="52_282"></a>52、安全机制：</h2> 
<p>指用来检测、阻止攻击，或从攻击状态恢复到安全状态的过程<br> 特定安全机制：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证；<br> 普通安全机制：可信功能、安全标签、事件检测、安全审计跟踪、安全恢复。*5</p> 
<h2>
<a id="53_288"></a>53、安全服务</h2> 
<p>加强数据处理系统和信息传输的安全性的一种处理过程或通信服务。<br> 五类：认证、访问控制、数据保密性、数据完整性、不可否认性</p> 
<h2>
<a id="54_293"></a>54、网络安全模型</h2> 
<p><img src="https://images2.imgbox.com/c5/22/u2mO6Tv5_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="55_298"></a>55、攻击密码系统的两种通用方法</h2> 
<p>①基于密码算法性质的密码分析<br> ②基于穷举密钥的穷举攻击</p> 
<h2>
<a id="56_303"></a>56、代替技术和置换技术</h2> 
<p>代替：将明文字母替换成其他字母、数字或符号的方法。<br> 置换：有限元素的集合S的置换是S中所有元素的有序排列，且每个元素只出现一次。</p> 
<h2>
<a id="57Caesar_307"></a>57、Caesar密码</h2> 
<p>凯撒密码是一种代替密码，就是将字母表中的每个字母，用它之后的第k个字母来代替。<br> 加密：C=(k,M)=(M+k) mod 26<br> 解密：M=D(k,C)=(C-k) mod 26<br> 3个特征：①加解密算法已知；②只有25个密钥；③明文所用的语言是已知的，且其意义易于识别。</p> 
<h2>
<a id="58_314"></a>58、单表代替密码</h2> 
<p>每条消息用一个字母表（给出明文字母到密文字母之间的映射）来加密。</p> 
<h2>
<a id="59Playfair_318"></a>59、Playfair密码</h2> 
<p>一种多字母代替密码体制。其密钥是基于一个密钥词构成的5*5字母矩阵。一次加密两个字母，加密规则如下：<br> ①两个相同连续字母需填充；②同行（右）/同列（左）；③一般字母对</p> 
<h2>
<a id="60_323"></a>60、多表代替密码</h2> 
<p>明文消息中采用不同的单表代替。</p> 
<h2>
<a id="61_327"></a>61、乘积密码</h2> 
<p>是指依次使用两个或两个以上基本密码，所得结果的密码强度将强于所有单个密码的强度。</p> 
<h2>
<a id="62_330"></a>62、两种对付传统分析的方法：</h2> 
<p>扩散：尽可能使明文和密文之间的统计关系变的复杂，以挫败推导出密钥的企图；<br> 混淆：尽可能使密文和密钥之间的统计关系变的复杂，以阻止攻击者发现密钥。</p> 
<h2>
<a id="63_335"></a>63、差分分析和线性分析的区别</h2> 
<p>差分分析通过分析明文对的差值对密文对的差值的影响来恢复某些密钥比特。<br> 线性分析对迭代密码的一种已知明文攻击，它利用的是密码算法中的“不平衡的线性逼近”。</p> 
<h2>
<a id="64_339"></a>64、多重加密：</h2> 
<p>是将一个加密算法多次使用的技术。在第一次使用中，明文通过加密算法转换成密文，然后将该密文作为输入重新执行该加密算法，该过程可以重复任意多次。</p> 
<h2>
<a id="65_343"></a>65、中间相遇攻击</h2> 
<p>假设： C=E(K2,E(K1,P)) 则有：X=E(K1,P)=D(K2,C)<br> 给定明文对(P,C)，攻击如下：首先，将P按所有可能的密钥K1加密，得到个结果，按X的值排序放在一个表里。然后，将C按所有可能的密钥K2解密，每解密一次就将结果与表中的值比较，如果有相等的，就用刚才测试的两个密钥对一个新的明密文对进行验证。如果有两个密钥产生了正确的密文，就认定这两个密钥是正确的密钥。</p> 
<h2>
<a id="66_348"></a>66、费马定理</h2> 
<p>若p是素数，a是正整数且不能被p整除，则<img src="https://images2.imgbox.com/34/6d/DZ2v76al_o.png" alt="在这里插入图片描述"></p> 
<p>另一种表示：若p是素数且a是任意正整数(不要求互素），则<br> <img src="https://images2.imgbox.com/53/c4/qb8jRBd3_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="67_354"></a>67、欧拉函数</h2> 
<p>表示小于n且与n互素的正整数的个数。<br> 定义 对素数p，有<br> <img src="https://images2.imgbox.com/87/3b/TpfTiIHZ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d0/2c/t6LbUv2B_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="68_362"></a>68、欧拉定理</h2> 
<p>对任意互素的a和n，有<br> <img src="https://images2.imgbox.com/e1/19/dgvpojy1_o.png" alt="在这里插入图片描述"></p> 
<p>另一种表示（不要求互素）：<br> <img src="https://images2.imgbox.com/0d/7d/vdAaK5Ps_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="69CRT_369"></a>69、中国剩余定理CRT</h2> 
<p>说明某一范围内的整数可通过它的一组剩余类数来重构，这组剩余类数是对该整数用一组两两互素的整数取模得到的。<br> 具体解法分下面三步：<br> 1、找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。<br> 2、用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加15∗2+21∗3+70∗215∗2+21∗3+70∗2得到和233。<br> 3、用233除以3、5、7的最小公倍数105，得到余数23，这个余数23就是符合条件的最小数。</p> 
<h2>
<a id="70_375"></a>70、本原根</h2> 
<p>如果一个数的阶为，则称之为n的本原根。</p> 
<h2>
<a id="71_379"></a>71、离散对数</h2> 
<p><img src="https://images2.imgbox.com/a6/d0/3TewP96o_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="72_384"></a>72、单向函数</h2> 
<p>每个函数值都存在唯一的逆，并且计算函数值是容易的，但求逆却是不可行的。</p> 
<h2>
<a id="73_388"></a>73、单向陷门函数：</h2> 
<p>一个函数，若计算函数值很容易，并且在缺少一些附加信息时计算函数的逆不可行，但是已知这些附加信息时，可在多项式实践计算出函数的逆，称这样的函数为单向陷门函数。</p> 
<h2>
<a id="74MITM_391"></a>74、中间人攻击MITM</h2> 
<p>是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就被称为“中间人”。</p> 
<h2>
<a id="75_393"></a>75、时间戳</h2> 
<p>时间戳是一份能够表示一份数据在一个特定时间点已经存在的完整的可验证的数据。</p> 
<h2>
<a id="76_397"></a>76、动态口令牌</h2> 
<p>“中银e令”，即动态口令牌是一种内置电源、密码生成芯片和显示屏、根据专门的算法每隔一定时间自动更新动态口令的专用硬件。基于该动志密码技术的系统又称一次一密(OTP) 系统，即用户的身份验证密码是变化的，密码在使用过一次后就失效，下次登录时的密码是完全不同的新密码。作为一种重要的双因素认证工具，动态口令牌被广泛地运用于安全认证领域。动态口令牌可以大大提升网上银行的登录和交易安全。</p> 
<h2>
<a id="77_400"></a>77、端到端加密</h2> 
<p>存在于两个程序的进程之间，只是在源和目的两端架设保密设备，只能加密有效数据部分，适合公共商用网络。</p> 
<h2>
<a id="78_402"></a>78、密钥分发和密钥管理</h2> 
<p>密钥分发的功能是给想要交换安全加密数据的双方分发密钥,并提供密钥安全分发所需要的方法或者协议。<br> 密钥分发常包括双方之间的频繁使用且长期存在的主密钥以及临时使用的会话密钥。<br> 密钥管理包含密钥生成、装入、存储、备份、分配、更新、吊销、销毁等内容</p> 
<h2>
<a id="79_407"></a>79、双向认证/相互认证</h2> 
<p>相互认证协议可以使通信双方确信对方的身份并交换会话密钥。</p> 
<h2>
<a id="80_410"></a>80、重放攻击</h2> 
<p>又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的。主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。</p> 
<h2>
<a id="81Kerberos_412"></a>81、Kerberos</h2> 
<p>在一个分布式环境中，用于服务器与用户之间的相互认证的协议。<br> 解决方案：在一个分布式的Client/Server体系机构中，引入一个可信任的第三方（Kerberos服务器），让其提供认证服务；采用共享密钥加密技术。（与其他认证不同的是Kerberos仅仅依赖于对称加密体制而未使用公钥加密体制）</p> 
<h1>
<a id="_417"></a>二、问答题</h1> 
<p><strong>1、对称算法DES/AES/RC4/3DES特点、安全特性与适用场合；</strong><br> 特点：<br> DES：对称算法，分组加密，分组大小为64bit，密钥大小为56bit，Feistel结构密钥短，加密简单，速度快<br> AES：对称算法，分组加密，分组大小128bit，典型密钥128、192、256bit，非Feistel结构<br> RC4：对称算法，流加密，密钥长度可变，但需要安全传递密钥<br> 3DES：使用了DES原有模块，使用三个DES密钥，保护了投资，但是慢，64位分组也太小。根据密钥产生伪随机子密钥，明文与伪随机子密钥异或即加密，密文与伪随机子密钥异或即解密。<br> 安全性：<br> DES：密钥空间太小，不能经受蛮力攻击，在穷举攻击下较为脆弱；S盒设计很关键，DES的Sbox太小，是人工的<br> AES：抵抗已知的攻击方法，代码紧凑结构简单速度快，硬件实现简单，安全<br> RC4：需要安全传递密钥，安全性比较高，虽然没有严谨的论证，但看上去分组密码更加安全。<br> 3DES：使用了三个DES密钥，密码空间大大增大，避免被蛮力破解，是高强度加密算法。比des更安全<br> 应用场合：<br> DES：适用于大量加密数据，对一般个人用户仍然安全，但关键场合已经不再适用。<br> AES： 适用场合广泛（数字签名 文档加密 商业领域）应用空间还不及DES，需要时间发展。<br> RC4：是一种广泛应用的流密码应用于SSL WEP协议<br> 3DES：在DES基础上进行上层延伸，提高了安全性且保护了资本，应用于PGP、S/MIME、Molila</p> 
<p><strong>2、RSA原理与计算，给p、q、e、c求d和m；</strong><br> a)随意选择两个素数p和q，p不等于q，<br> b)计算n=pq。<br> c)根据欧拉函数，求得r= (p-1)(q-1) 欧拉函数<br> d)选择一个小于 r 的整数 e，求得 e 关于模 r 的模反元素，命名为d。（模反元素存在，当且仅当e与r互质）<br> e)(d,n)为公钥，(e,n)为私钥</p> 
<p><img src="https://images2.imgbox.com/7f/d7/I7IiOYMY_o.png" alt="在这里插入图片描述"></p> 
<p><strong>3、公钥算法的用途，从加密(传递会话密钥)到签名；</strong><br> 公钥算法采用公钥和私钥两个密钥，如果利用公钥进行加密，而用私钥解密，这种场景属于数据保护。<br> 而如果利用私钥加密，利用公钥解密，可以用作签名和验证。<br> 公钥加密算法又称为非对称算法，原因是需要用一个密钥加密数据，而用另一个密钥来解密数据。对于每个通信会话，这两个密钥应该都是唯一的。不过，尽管非对称算法具有此项要求，但在实践中，非对称密钥通常却有较长的生存期。<br> 再来看一个例子<br> 双方（小红和小明）可以按照下列方式使用公钥加密： 首先，小红生成一个公钥/私钥对。如果小明想要给小红发送一条加密的消息，他将向她索要她的公钥。小红通过非安全网络将她的公钥发送给小明，小明接着使用该密钥加密消息。小明将加密的消息发送给小红，而小红使用她的私钥解密该消息。如果小明通过非安全信道（例如公共网络）接收小红的密钥，则小明可能会受到“中间人”攻击。因此，小明必须与小红验证他收到的公钥副本是否正确。<br> 但是，在传输小红的公钥期间，未经授权的代理可能会截获该密钥。而且，同一代理可能截获来自小明的加密消息。但是，该代理无法用公钥解密该消息。该消息只能用小红的私钥解密，而该私钥并没有被传输。小红不使用她的私钥加密给小明的答复消息，原因是任何具有公钥的人都可以解密该消息。如果小红想要将消息发送回小明，她将向小明索要他的公钥并使用该公钥加密她的消息。然后，小明使用与他相关联的私钥来解密该消息。<br> 在此方案中，小红和小明使用公钥（非对称）加密来传输私钥（对称），并对其会话的其余部分使用私钥加密。<br> RSA 允许同时进行加密和签名，但 DSA 只能用于签名，Diffie-Hellman 只能用于生成密钥。通常情况下，公钥算法比私钥算法具有更多的使用限制。<br> 注意：证书从本质上说是一种特殊的公钥加密手段，特殊之处在于它可以存储在机器上，并且可以导出文件进行传递。</p> 
<p><strong>4、数字签名的用途</strong><br> 公钥算法还可用于构成数字签名。数字签名验证发送方的身份（如果您信任发送方的公钥）并帮助保护数据的完整性。<br> 为了使用公钥加密对消息进行数字签名，小红首先将哈希算法应用于该消息以创建消息摘要。该消息摘要是数据的紧凑且唯一的表示形式。然后，小红用她的私钥加密该消息摘要以创建她的个人签名。在收到消息和签名时，小明使用小红的公钥解密签名以恢复消息摘要，并使用与小红所使用的相同的哈希算法来散列消息。如果小明计算的消息摘要与从小红那里收到的消息摘要完全一致，小明就可以确定该消息来自私钥的持有人，并且数据未被修改过。如果小明相信小红是私钥的持有人，则他将知道该消息来自小红。<br> 由于发送方的公钥为大家所共知，并且它通常包含在数字签名格式中，因此任何人都可以验证签名。此方法不保守消息的机密；若要使消息保密，还必须对消息进行加密。</p> 
<p><strong>5、Hash函数的特性与用途；</strong><br> HASH主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码里，叫做HASH值. 也可以说，hash就是找到一种数据内容和数据存放地址之间的映射关系。Hash算法在信息安全方面的应用主要体现在以下的3个方面：<br> 1）文件校验<br> MD5 Hash算法的"数字指纹"特性，使它成为目前应用最广泛的一种文件完整性校验和（Checksum）算法，不少Unix系统有提供计算md5 checksum的命令。<br> 2）数字签名<br> Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。对 Hash 值，又称"数字摘要"进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。<br> 3）鉴权协议<br> 如下的鉴权协议又被称作"挑战–认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。<br> 4）.用于提供消息认证功能<br> 5）.用于产生单向口令文件<br> 6）.用于入侵检测和病毒检测<br> 7）.用于构建随机函数（PRF）或用做伪随机数发生器（PRNG）<br> 8）给明文增加结构特征以保护密文<br> 9）产生MAC(HMAC)<br> 10）从口令衍生密钥</p> 
<p>特性：<br> 单向性：对于给定h，找出x极其困难<br> 抗冲突性：<br> 弱抗碰撞特性：对于给定y，找出x满足H(x)=H(y)极其困难。<br> 强抗碰撞特性（生日攻击）：找出x、y满足H(x)=H(y)极其困难。</p> 
<blockquote> 
 <blockquote> 
  <p>若有碰撞，则意味着数字签名容易被伪造、欺骗</p> 
 </blockquote> 
</blockquote> 
<p><strong>6、随机数的特性与用途；</strong><br> 特性:均匀分布性，独立性，不可预测性，可伸缩性，一致性</p> 
<p>用途：<br> 1.在统计学的不同技术中需要使用随机数。<br> 2.实际生活中，这些随机数起着很大的作用。<br> 3.在密码学中，可以用于生成密钥。<br> 4.在RSA密码中关键是如何有效选取一个大素数，而在这个大素数的选取过程中，先必须产生一个大的随机的奇数，然后再来检验其是否为素数。。<br> 5.数字水印中的应用。<br> 6.一次性口令中的应用。</p> 
<p><strong>7、以PGP为代表的邮件/文件的加密交换/存储方案；</strong><br> <img src="https://images2.imgbox.com/8e/96/0jsg5Bwl_o.png" alt="在这里插入图片描述"></p> 
<p>PGP(pretty good privacy) 是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术。PGP 并没有使用什么新的概念，它只是将现有的一些算法如 MD5，RSA，以及 IDEA 等综合在一起而已。<br> 数字签名: PGP提供的数字签名服务包括哈希编码或 消息摘要的使用，签名算法以及公钥加密算法。它提供了对发送方的身份验证。<br> 保密性: PGP通过使用常规的加密算法，对将要传送的消 息或在本地存储的文件进行加密，在PGP中每个常规密钥只使用一次，会话密钥和消息绑定在一起进行传送，为了保护会话密钥，还要用接收方的公钥对其进行加密。<br> 压缩: 在默认情况下，PGP在数字签名服务和保密性服务之间提供压缩服务，首先对消息进行签名，然后进行压缩，最后再对压缩消息加密。<br> 基数64转换: 为了达到签名、加密及压缩的目的 ，PGP使用了称为基数64转换的方案。在该方案中，每3个二进制数据组被映射为4个ASCII字符，同时也使用了循环冗 余校验来检测传送中的错误，基数64转换作为对二进制PGP消息的包装，用于在一些非二进制通道。</p> 
<p><strong>8、破解口令的方法</strong><br> 1.键盘截获破解<br> 通常作为必备功能被包含在一些木马之中，原理是在操作系统应用层对用户的键盘输入消息进行截获。<br> 2.暴力攻击破解<br> 即所谓的穷举攻击，原理是按照字母与数字的顺序穷举所有可能的测试用口令，然后使用组合好的口令进行测试，失败则重新进行口令组合和测试。<br> 3.字典攻击破解<br> 引入了常用口令字典这一概念，事先将常用的口令构造成字典文件，然后用字典文件中的每一条口令去尝试匹配口令。<br> 4.网络嗅探截获<br> 由于诸如FTP、HTTP等协议在网络中使用明文传输，针对这些协议截获的数据包，可以从中直接提取出用于认证的用户名和口令。<br> 5. 利用操作系统的弱点和漏洞<br> 如Windows NT的UNICODE漏洞，用解密算法破解程序来破译系统口令文件，从而获得系统的全部口令。</p> 
<p><strong>9、口令破解的防范</strong><br> 为了提高口令的安全性，在设置口令时要让口令满足一些安全策略，具体包括：<br> 至少包含8个字符；大小写字母、数字和符号的组合；不包含姓名、用户名或常用单词；不与其他人共享；定期更换密码。</p> 
<p><strong>10、文件加密存储，360密盘、truecrypt、ntfs的文件夹绿色加密、bitlock等机制与原理；</strong><br> 文件加密存储是一种根据要求在操作系统层自动地对写入存储介质的数据进行加密的技术。按加密途径可分为两类: 一类是WINDOWS系统自带的文件加密功能,一类是采用加密算法实现的商业化加密软件。<br> 360密盘将计算机磁盘中的部分区域进行加密，并生成一张“360密盘”，存放在360密盘中的所有文件将自动加密，经过身份验证后才能打开360密盘。360密盘使用高强度加密128位AES高强度加密算法，破解密码需要10万年。<br> TrueCrypt不需要生成任何文件即可在硬盘上建立虚拟磁盘，用户可以按照盘符进行访问，所有虚拟磁盘上的文件都被自动加密，需要通过密码来进行访问。TrueCrypt 提供多种加密算法，包括：AES-256, Blowfish (448-bit key), CAST5, Serpent, Triple DES, and Twofish。<br> 加密文件系统 (EFS) 提供一种核心文件加密技术，正如设置其他任何属性（如只读、压缩或隐藏）一样，通过为文件夹和文件设置加密属性，可以对文件夹或文件进行加密和解密。加密后文件夹内的文件名字都是绿色的。<br> BitLocker驱动器加密通过加密Windows操作系统卷上存储的所有数据可以更好地保护计算机中的数据。BitLocker使用TPM帮助保护Windows操作系统和用户数据，并帮助确保计算机即使在无人参与、丢失或被盗的情况下也不会被篡改。</p> 
<p><strong>11、考虑这3个应用：电商及网银、无纸化办公、QQ。有哪些安全问题和需求、目前是怎么做得，该怎么注意安全，该怎么改进或解决。</strong><br> 电商及网银：交易过程的安全性。目前,除了加密技术以外,身份认证技术是保证电子商务安全不可缺少的又一重要技术手段。认证的实现包括数字签名技术、数字证书技术和数字时间戳技术等。<br> 无纸化办公：在很多单位，很多信息都通过明文的方式进行传输，非常容易被截获。加强数字身份认证，使用加密传输协议和权限控制，对接入系统用户进行严格的监控和管理。有重要和机密数据的存储设备要进行保密处理，如禁止拷贝等设置，每台操作机固定IP地址，严格控制管理员权限，对操作员和管理员的操作要留下清晰日志以备有问题时追查原因。<br> QQ：账号密码安全问题。用户可以将自己的常用手机号码设置成为安全手机。系统会在与该安全手机对应的帐号出现安全敏感操作如：修改密码、查询帐户、大量增删好友等的情况下，发送短信到用户的安全手机提示，让用户确认是否为本人操作。同时，安全手机也可以用来修改QQ密码。</p> 
<p><strong>12、网银u盾和动态口令牌，原理或机制上有啥区别？</strong><br> U盾：<br> ① 全称：USB-KEY数字证书；<br> ② USB-KEY 中内置了智能芯片；<br> ③ USB-key有专用安全区来保存证书私钥；<br> ④ USB-KEY证书私钥不能导出，因此备份的文件无法使用，其安全性高于浏览器证书；<br> ⑤ 客户使用时需要安装 USB-KEY 驱动程序，USB-KEY 证书需要高于证书的成本；<br> ⑥ USB-KEY 证书容易随身携带。<br> 网银动态口令：<br> ① 网银动态口令是由电子银行口令卡随机生成的一串数字；<br> ② 电子银行口令卡是工行最新推出的电子银行安全工具，是保护客户资金不受损失而设置的又一道防线；<br> ③ 也就是说客户只要保管好客户手中的口令卡，就不会有资金损失，即使客户不慎外泄了登录卡号和登录密码，只要保管好客户手中的口令卡，使登录卡号、登录密码、口令卡不被同一个人获取，就能够保证客户资金的安全，从而让客户更加安全、放心地使用电子银行。</p> 
<p><strong>13、那些泄漏案例引发的思考。素材：用户名、口令、邮箱、qq库、开房记录、云中照片、12306、CSDN、tianya、Ashley-Madison，以及传说但是后来未经证实的163的5亿邮箱等。对于这些泄漏案例，你可以猜测、分析其泄漏的途径和机制.</strong><br> 泄露途径有：<br> (1)黑客利用网站存在的安全漏洞入侵网站，盗取用户数据库。<br> 举例：由于携程用于处理用户支付的安全支付服务器接口存在调试功能，将用户支付的记录用文本保存了下来。同时因为保存支付日志的服务器未做校严格的基线安全配置，存在目录遍历漏洞，导致所有支付过程中的调试信息可被任意骇客读取。携程官方给出的评论是说在调试过程中间，有两小时左右用户的支付信息是被明文保存在服务器上的，这就为黑客攻击提供了机会。<br> (2)网站内部工作人员倒卖用户信息<br> (3)通过撞库攻击，窃取用户数据。<br> 当然，最关键的还是加强安全意识，建立并执行完善的安全策略，在系统建设过程中就充分考虑网络安全、应用系统自身的安全功能、应用系统开发过程安全、操作系统安全、数据库安全、管理制度等方面，建立一个可执行且完整的安全策略和安全体系。</p> 
<p><strong>14、网络信息安全面临的问题</strong><br> 1．网络协议和软件的安全存在缺陷<br> 2. 黑客攻击手段多样化<br> 3．计算机病毒的入侵</p> 
<p><strong>15、应对网络信息安全所存在的问题的措施</strong><br> 1、提高公司内部相关人员的安全意识，充分发挥已有安全设备的作用；<br> 2、要加强应用系统的安全<br> 3、加强服务器、数据库的安全，<br> 4、培养高水平的安全管理队伍<br> 5、对数据进行加密和备份处理<br> 6、加强防毒、防黑的安全措施<br> 7、完善信息安全政策与法规</p> 
<p><strong>16、对称密码算法的基本要素：substitution和transposition是什么；现代对称算法的基本特点和元素。</strong><br> 代换（替代）：明文元素映射为密文元素<br> 置换：把明文元素重排<br> 5个基本元素：明文、密文、密钥、加密算法、解密算法<br> 特征：运算类型：代换、置换<br> 密钥：对称密钥非对称密钥、密钥空间的大小<br> 处理明文的方法：分组算法、流算法<br> 基本原则：算法公开、密钥的随机性</p> 
<p><strong>17、如何达成对称密钥</strong><br> 1）通过安全的信道传输<br> 2）可信第三方分发<br> 3）分布式计算</p> 
<p><strong>18、设计流密码要考虑的因素：</strong><br> ①加密序列的周期要长<br> ②密钥流应尽可能接近真正随机数流的特征<br> ③伪随机数发生器的输出受输入密钥的调节</p> 
<p><strong>19、公钥密码体制的应用</strong><br> ①加密/解密：发送方用接收方的公钥对消息进行加密。<br> ②数字签名：发送方用其私钥对消息“签名”，签名可通过对整条消息加密或对消息的一个小的数据块加密来产生，其中该小数据块是整体整条消息的函数。<br> ③密钥交换：通信双方交换会话密钥。</p> 
<p><strong>20、为得到安全算法，公钥密码体制应满足那些要求</strong><br> ①公/密钥的产生在计算上是容易的 （密钥生成）<br> ②已知公钥和待加密信息，发送方产生相应密文在计算上是容易的（加密）<br> ③接收方使用其私钥对接收的密文解密以恢复明文在计算是容易的（解密）<br> ④已知公钥，攻击者要确定私钥在计算上是不可行的（公钥-&gt;私钥）<br> ⑤已知公钥和密文，攻击者要恢复明文在计算上是不可行的</p> 
<p><strong>21、构造MAC的方法：</strong><br> 第一种是将密码学hash函数以某种方式和密钥捆绑起来。<br> 第二种是使用对称分组密码，将可变长度的输入转为固定长度的输出。</p> 
<p><strong>22、网络通信可能受到的攻击:</strong><br> ①泄密: 将消息透漏给没有合法秘密钥的任何人或程序。<br> ②传输分析: 分析通信双方的通信模式<br> ③伪装: 欺诈源向网络中插入一条消息<br> ④内容修改: 对消息内容的修改，包括插入、删除、转换和修改。<br> ⑤顺序修改: 对通信双方消息顺序的修改，包括插入、删除和重<br> ⑥计时修改: 对消息的延时和重放。<br> ⑦发送方否认: 发送方否认发送过某消息<br> ⑧接收方否认: 接收方否认接收到某消息</p> 
<p><strong>23、扩展的Euclid算法</strong><br> 算法描述：给定整数a,b该法计算出gcd(a,b)以及x,y。满足：ax+by=d=gcd(a,b)，对于给定的整数a,b，ax+by的最小整数等于gcd(a,b)。<br> 算法过程：<br> <img src="https://images2.imgbox.com/52/c8/D3sqUzbt_o.png" alt="在这里插入图片描述"></p> 
<p><strong>24、在GF§中求乘法逆元：</strong><br> 如果gcd(a,b)=1，那么b有模a的乘法逆元。使用扩展的Euclid算法来计算，得出的y即为所求。<br> <img src="https://images2.imgbox.com/8d/22/N6DbXQRm_o.png" alt="在这里插入图片描述"></p> 
<p><strong>25、数字签名的特征：</strong><br> ①它必须能够验证签名者、签名日期和时间<br> ②它必须能够认证被签的消息内容<br> ③签名应能有第三方仲裁，以解决争议</p> 
<p><strong>26、数字证书和数字签名的差别：</strong><br> 数字证书是由权威机构－－CA证书授权（Certificate Authority）中心发行的，能提供在Internet上进行身份验证的一种权威性电子文档，人们可以在互联网交往中用它来证明自己的身份和识别对方的身份。<br> 数字签名是一种认证机制，它使得消息的发送方可以添加一个起签名作用的码字。通过计算消息的Hash值并用发送方的密钥加密Hash值来获得签名。消息保证了消息的来源和完整性。</p> 
<p><strong>27、https和http的区别：</strong><br> 一、https协议需要到CA申请证书，一般免费证书很少，需要交费。<br> 二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br> 三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br> 四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p> 
<p><strong>28、公钥体系、对称加密体系、MAC、HASH、数字签名在认证上的作用、特点。</strong><br> 认证可以分为身份认证和消息来源认证。<br> 身份认证一般使用使用CA(证书授权中心)，CA用到了数字签名，而数字签名一般使用公钥算法；<br> 消息认证则使用MAC，MAC在工业实现中一般先把消息hash到固定长度再计算认证码，而hash函数的实现中可能使用到了对称加密算法。另外Kerberos协议使用对称加密算法实现了消息来源认证。</p> 
<p><strong>29、对称密码和公钥密码的区别</strong><br> ①密钥上，对称密码加解密使用相同的密钥，而公钥密码则使用发送方产生的两个密钥分别加解密；<br> ②算法上，对称密码主要是使用代替和置换这两种加密技术；而公钥算法则是使用数学方法来进行加密。<br> ③安全性要求：<br> 对称密码：密钥必须保密；没有密钥，解密不可行；知道算法和若干密文不足以确定密钥<br> 公钥密码：两个密钥之一必须保密；无解密密钥，解密不可行；知道算法和其中一个密钥以及若干密文不能确定另一个密钥</p> 
<p><strong>30、防止重放攻击方法</strong><br> ①序列号：对于每一个用于认证交互的消息附上一个序列号，新的消息只有其序列号满足适当的顺序时才会被接收，但是这种方法要求每一方都跟踪记录与其交互的通信双方的最新序列号，开销很大。<br> ②时间戳：只有当消息包含一个时间戳时，接收方才接收消息。该时间戳有接收方进行判断，要接近于接收方所知的当前时间。该方法要求不同参与者之间的时钟是同步的，且不适合于面向连接。<br> ③挑战/应答：A想要一个来自B的新消息，首先发给B一个临时交互号（询问），并要求后面从B接收的消息（回复）包含正确的临时交互号。这种方法不适合于无连接。</p> 
<p><strong>31、Kerberos协议过程、安全行可行性分析。</strong><br> ①用户想要获取访问某一应用服务器的许可证时，先以明文方式向认证服务器AS发出请求，要求获得访问TGS的许可证。<br> ②AS以证书（credential）作为响应，证书包括访问TGS的许可证和用户与TGS间的会话密钥。会话密钥以用户的密钥加密后传输。<br> ③用户解密得到TGS的响应，然后利用TGS的许可证向TGS申请应用服务器的许可证，该申请包括TGS的许可证和一个带有时间戳的认证符（authenticator）。认证符以用户与TGS间的会话密钥加密。<br> ④TGS从许可证中取出会话密钥、解密认证符，验证认证符中时间戳的有效性，从而确定用户的请求是否合法。TGS确认用户的合法性后，生成所要求的应用服务器的许可证，许可证中含有新产生的用户与应用服务器之间的会话密钥。TGS将应用服务器的许可证和会话密钥传回到用户。<br> ⑤用户向应用服务器提交应用服务器的许可证和用户新产生的带时间戳的认证符（认证符以用户与应用服务器之间的会话密钥加密）。<br> ⑥应用服务器从许可证中取出会话密钥、解密认证符，取出时间戳并检验有效性。然后向用户返回一个带时间戳的认证符，该认证符以用户与应用服务器之间的会话密钥进行加密。据此，用户可以验证应用服务器的合法性。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>