<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>2022年第十三届蓝桥杯省赛C/C&#43;&#43;B组个人题解 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2022年第十三届蓝桥杯省赛C/C&#43;&#43;B组个人题解</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>2022年第十三届蓝桥杯省赛C/C++B组个人题解</h3>
 <ul>
<li><a href="#_A__1">试题 A: 九进制转十进制（数学）</a></li>
<li><a href="#_B__14">试题 B: 顺子日期（语文）</a></li>
<li><a href="#_C__63">试题 C: 刷题统计（模拟）</a></li>
<li>
<ul><li>
<ul>
<li><a href="#_65">【样例输入】</a></li>
<li><a href="#_69">【样例输出】</a></li>
</ul>
  </li></ul>
  </li>
<li><a href="#_D__126">试题 D: 修剪灌木（找规律）</a></li>
<li>
<ul>
<li><a href="#_128">【样例输入】</a></li>
<li><a href="#_132">【样例输出】</a></li>
</ul>
  </li>
<li><a href="#_E_X__226">试题 E: X 进制减法（数学）</a></li>
<li>
<ul>
<li><a href="#_228">【样例输入】</a></li>
<li><a href="#_236">【样例输出】</a></li>
</ul>
  </li>
<li><a href="#_F____293">试题 F: 统计子矩阵（前缀和 + 双指针）</a></li>
<li>
<ul>
<li><a href="#_295">【样例输入】</a></li>
<li><a href="#_302">【样例输出】</a></li>
</ul>
  </li>
<li><a href="#_G__398">试题 G: 积木画（动态规划）</a></li>
<li>
<ul>
<li><a href="#_400">【样例输入】</a></li>
<li><a href="#_404">【样例输出】</a></li>
</ul>
  </li>
<li><a href="#_H_BFS_448">试题 H: 扫雷（BFS）</a></li>
<li>
<ul>
<li><a href="#_450">【样例输入】</a></li>
<li><a href="#_457">【样例输出】</a></li>
</ul>
  </li>
<li><a href="#_I_DP___550">试题 I: 李白打酒加强版（三维DP / 回溯）</a></li>
<li>
<ul>
<li><a href="#_552">【样例输入】</a></li>
<li><a href="#_556">【样例输出】</a></li>
</ul>
  </li>
<li><a href="#_J__649">试题 J: 砍竹子</a></li>
<li>
<ul>
<li><a href="#_651">【样例输入】</a></li>
<li><a href="#_656">【样例输出】</a></li>
</ul>
  </li>
<li><a href="#_664">总结</a></li>
</ul>
</div>
<p></p> 
<h1>
<a id="_A__1"></a>试题 A: 九进制转十进制（数学）</h1> 
<p><img src="https://images2.imgbox.com/6a/21/zIgwRnG5_o.png" alt="A"></p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt; 
using namespace std;

int main() {
	cout &lt;&lt; 2 * pow(9, 0) + 2 * pow(9, 1) + 0 * pow(9, 2) + 2 * pow(9, 3) &lt;&lt; endl;
	return 0;
}
</code></pre> 
<p>答案：1478</p> 
<h1>
<a id="_B__14"></a>试题 B: 顺子日期（语文）</h1> 
<p><img src="https://images2.imgbox.com/44/4a/4PwEIJTN_o.png" alt="B"><br> 目前有很多争议，分为 3 种答案：4，5，14<br> 我考试时写的答案是 5<br> 不过我观察到网友更多的答案是 4<br> 而比赛后当天晚上的蓝桥云课说的是 14（非官方）</p> 
<p>我来总结一下：</p> 
<p>第一种答案：5<br> 看题，在说明 20220123时，说它出现了一个顺子：123。<br> 所以可以认为是只有 123 这一个顺子，而 012 是不算顺子的。<br> 然后在说明 20221023 时又涉及到了 210 这个逆着的顺子，但它说这不是一个顺子日期。因此认为这里更明确了 0 不可以被包括进去，而逆序的可以算是顺子。</p> 
<pre><code>20220123
20220321
20221123
20221230
20221231
</code></pre> 
<p>第二种答案：4<br> 即认为 012 和逆序的顺子（如 210）都不算是顺子，因此把上面的 20220321 去掉</p> 
<pre><code>20220123
20221123
20221230
20221231
</code></pre> 
<p>第三种答案：14<br> 题目说的顺子是：连续的三个数字，并不是三位数。所以 012 也算是顺子。再由第二个例子 20221023 得知：210 这种逆序的不算顺子。<br> <strong>如果要算上 012，那么第二个例子就把 210 这种逆序的给否掉啦</strong></p> 
<pre><code>20220120
20220121
20220122
20220123
20220124
20220125
20220126
20220127
20220128
20220129
20221012
20221123
20221230
20221231
</code></pre> 
<p>我目前也不知道正确答案，只能等官方解释吧<br> orz</p> 
<h1>
<a id="_C__63"></a>试题 C: 刷题统计（模拟）</h1> 
<p><img src="https://images2.imgbox.com/25/76/moNDHRqz_o.png" alt="C1"></p> 
<h3>
<a id="_65"></a>【样例输入】</h3> 
<pre><code>10 20 99
</code></pre> 
<h3>
<a id="_69"></a>【样例输出】</h3> 
<pre><code>8
</code></pre> 
<p><img src="https://images2.imgbox.com/94/f0/aw5ZhoFj_o.png" alt="在这里插入图片描述"></p> 
<p>陷阱：注意 a, b, n 要用 long long 存<br> 考试时写的代码：只考虑到了 n 要用 long long 存，竟然没用 long long 存 a, b，还没考虑到时间可能还会超限</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	int cnt = 1;
	long long n;
	int a, b;
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;
	long long sum = 0;
	while (sum &lt; n) {
		if (cnt % 7 == 0 || cnt % 7 == 6) {
			sum += b;
		}
		else {
			sum += a;
		}
		cnt++;
	}
	// 当超出时退出while循环，所以答案需要减一。
	cout &lt;&lt; cnt - 1 &lt;&lt; endl;
	return 0;
}
</code></pre> 
<p>赛后优化代码：先取余再暴力</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	long long a, b, n;
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;
	int week = 5 * a + 2 * b;
	long long ans = n / week * 7;
	n %= week;
	int sum = 0;
	for (int i = 1; i &lt;= 7 &amp;&amp; sum &lt; n; i++) {
		if (i % 7 == 6 || i % 7 == 0) {
			sum += b;
		}
		else {
			sum += a;
		}
		ans++;
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
} 
</code></pre> 
<h1>
<a id="_D__126"></a>试题 D: 修剪灌木（找规律）</h1> 
<p><img src="https://images2.imgbox.com/3a/71/5rKD3Z9Y_o.png" alt="D1"></p> 
<h2>
<a id="_128"></a>【样例输入】</h2> 
<pre><code>3
</code></pre> 
<h2>
<a id="_132"></a>【样例输出】</h2> 
<pre><code>4
2
4
</code></pre> 
<p><img src="https://images2.imgbox.com/2a/0a/QMU1Qo0R_o.png" alt="D2"><br> 首先用暴力找规律，然后再根据规律简化代码</p> 
<pre><code>// 暴力代码：来回走两次。注意回的时候要把两个边界去掉。

#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

const int maxn = 1e4 + 100;
int a[maxn];
int maxHeight[maxn];

int main() {
	int n;
	while (cin &gt;&gt; n) {
		memset(a, 0, sizeof(a));
		memset(maxHeight, 0, sizeof(maxHeight));
		
		// 来回走两次
		for (int today = 0; today &lt; n; today++) {
			for (int i = 0; i &lt; n; i++) {
				a[i]++;
				if (a[i] &gt; maxHeight[i]) {
					maxHeight[i] = a[i];
				}
				if (i == today) {
					a[i] = 0;
				}
			}
		}
		for (int today = n - 2; today &gt; 0; today--) {
			for (int i = 0; i &lt; n; i++) {
				a[i]++;
				if (a[i] &gt; maxHeight[i]) {
					maxHeight[i] = a[i];
				}
				if (i == today) {
					a[i] = 0;
				}
			}
		}
		for (int today = 0; today &lt; n; today++) {
			for (int i = 0; i &lt; n; i++) {
				a[i]++;
				if (a[i] &gt; maxHeight[i]) {
					maxHeight[i] = a[i];
				}
				if (i == today) {
					a[i] = 0;
				}
			}
		}
		for (int today = n - 2; today &gt; 0; today--) {
			for (int i = 0; i &lt; n; i++) {
				a[i]++;
				if (a[i] &gt; maxHeight[i]) {
					maxHeight[i] = a[i];
				}
				if (i == today) {
					a[i] = 0;
				}
			}
		}
		for (int i = 0; i &lt; n; i++) {
			cout &lt;&lt; maxHeight[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl &lt;&lt; endl;
	}
	return 0;
}
</code></pre> 
<p>结果如下：<br> <img src="https://images2.imgbox.com/0d/92/Aa03VI32_o.png" alt="D2"><br> 通过找规律可以简化代码：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	int n;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cout &lt;&lt; max(i, n - i - 1) * 2 &lt;&lt; endl; 
	}
	return 0;
}
</code></pre> 
<h1>
<a id="_E_X__226"></a>试题 E: X 进制减法（数学）</h1> 
<p><img src="https://images2.imgbox.com/ed/9c/XlVDjFOd_o.png" alt="E1"></p> 
<h2>
<a id="_228"></a>【样例输入】</h2> 
<pre><code>11
3
10 4 0
3
1 2 0
</code></pre> 
<h2>
<a id="_236"></a>【样例输出】</h2> 
<pre><code>94
</code></pre> 
<p><img src="https://images2.imgbox.com/18/ee/yuN6fony_o.png" alt="E2"><br> 比赛时看了一个小时，读不懂题 <strong>orz…</strong><br> 这题十分的抽象，很难理解</p> 
<p>这里先说明一下问题描述中的 321 是如何转换为 65 的<br> 由题：个位是 2 进制，十位是 10 进制，百位是 8 进制。<br> 题目第一行就说了：进制规定了数字在数位上逢几进一。意思是：<strong>个位每数 2 个，十位进 1，十位每数 10 个，百位进 1。</strong><br> 首先定义结果 sum = 0<br> ① 看个位：个位为 1，那么只需数一次即可到 1，然后让结果加上 1，即 <strong>sum += 1</strong><br> ② 看十位：十位为 2，因为个位是二进制，所以十位要到 2 的话，就需要经过这样的变换：00 -&gt; 01 -&gt; 10 -&gt; 11 -&gt; 20。可以看出：十位每加 1，个位就需要变换 2 次，所以要使十位变成 2，则一共<strong>需要变换 2（十位的值） * 2（个位的进制） 次</strong>。然后让结果再加上它，即 <strong>sum += 2 * 2</strong><br> ③ 看百位：百位为 3，根据十位的分析，同理得：要使百位变成 3，则<strong>需要变换 3（百位的值） * 10（十位的进制） * 2（个位的进制）次</strong>。然后让结果再加上它，即 <strong>sum += 3 * 10 * 2</strong><br> 综上：321 转换为了 <strong>sum = 1 + 2 * 2 + 3 * 10 * 2 = 65</strong></p> 
<p>公式：<br> A = ( a[n - 1] * X[n - 2] * X[n - 3] * … * X[0] ) + ( a[n - 2] * X[n - 3] * X[n - 4] * … * X[0] ) + … + a[0]<br> B = ( b[n - 1] * X[n - 2] * X[n - 3] * … * X[0] ) + ( b[n - 2] * X[n - 3] * X[n - 4] * … * X[0] ) + … + b[0]<br> A - B = (( a[n - 1] - b[n - 1] ) * X[n - 2] * X[n - 3] * … * X[0] ) + (( a[n - 2] - b[n - 2] ) * X[n - 3] * X[n - 4] * … * X[0] ) + ( a[0] - b[0] )<br> 优化：（秦九韶算法）<br> 设 d[n - 1] = a[n - 1] - b[n - 1]<br> A - B = ((( d[n - 1] * X[n - 2] + d[n - 2] ) * X[n - 3] + d[n - 3] ) * X[n - 4] + … d[0] ) …</p> 
<p>代码：</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MOD = 1e9 + 7;
const int maxn = 1e5 + 100;
int a[maxn];
int b[maxn];

int main() {
	int n, m1, m2, m;
	scanf("%d", &amp;n);
	scanf("%d", &amp;m1);
	// 逆序来存，确保让个位对齐，多余位置的值都是 0 
	for (int i = m1 - 1; i &gt;= 0; i--) {
		scanf("%d", &amp;a[i]);
	}
	scanf("%d", &amp;m2);
	for (int i = m2 - 1; i &gt;= 0; i--) {
		scanf("%d", &amp;b[i]);
	}
	m = max(m1, m2);
	int res = 0;
	for (int i = m - 1; i &gt;= 0; i--) {
		res = (res * max({ 2, a[i] + 1, b[i] + 1 }) % MOD + a[i] - b[i]) % MOD;
	}
	printf("%dn", res);
	return 0;
}
</code></pre> 
<h1>
<a id="_F____293"></a>试题 F: 统计子矩阵（前缀和 + 双指针）</h1> 
<p><img src="https://images2.imgbox.com/b5/32/SxXabwAM_o.png" alt="F1"></p> 
<h2>
<a id="_295"></a>【样例输入】</h2> 
<pre><code>3 4 10
1 2 3 4
5 6 7 8
9 10 11 12
</code></pre> 
<h2>
<a id="_302"></a>【样例输出】</h2> 
<pre><code>19
</code></pre> 
<p><img src="https://images2.imgbox.com/f3/e1/ldrP4Lwp_o.png" alt="F2"><br> <img src="https://images2.imgbox.com/3d/c5/Le8GidEt_o.png" alt="F3"><br> <s>注意 k 已经超了 int 范围（虽然我到不了那就已经超时了，但还是要注意的）</s> 看错了看错了，k 的值是 2.5 * 10 ^ 8，而 int 的范围是 -21 4748 3648 ～ 21 4748 3647 (21 * 10 ^ 8)</p> 
<p>方法①：前缀和 + 双指针<br> 首先求出每一列的前缀和，然后利用双指针将若干行切割开</p> 
<table>
<thead><tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="https://images2.imgbox.com/de/60/onXS7ekO_o.jpg" alt="F4"><br> <img src="https://images2.imgbox.com/7e/65/UrHFeAR0_o.jpg" alt="F5"></p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int maxn = 505;
int s[maxn][maxn];

int main() {
	memset(s, 0, sizeof(s));
	int n, m, k;
	scanf("%d %d %d", &amp;n, &amp;m, &amp;k);
	for (int i = 1; i &lt;= n; i++) {
		for (int j = 1; j &lt;= m; j++) {
			scanf("%d", &amp;s[i][j]);
			s[i][j] += s[i - 1][j];
		}
	}
	int res = 0;
	// 上下边界
	for (int up = 1; up &lt;= n; up++) {
		for (int down = up; down &lt;= n; down++) {
			int sum = 0;
			// 左右边界
			for (int left = 1, right = 1; right &lt;= m; right++) {
				sum += s[down][right] - s[up - 1][right];
				while (sum &gt; k) {
					sum -= s[down][left] - s[up - 1][left];
					left++;
				}
				res += right - left + 1;
			}
		}
	}
	printf("%dn", res);
	return 0;
}
</code></pre> 
<p>方法②：暴力（过30%数据，比赛时不会做直接暴力 6 个 for！随便看看就好啦）</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

int mat[550][550];

int main() {
	int n, m;
	long long k;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	for (int i = 1; i &lt;= n; i++) {
		for (int j = 1; j &lt;= m; j++) {
			cin &gt;&gt; mat[i][j];
		}
	}
	long long sum = 0;
	long long cnt = 0;
	for (int h1 = 1; h1 &lt;= n; h1++) {
		for (int h2 = h1; h2 &lt;= n; h2++) {
			for (int l1 = 1; l1 &lt;= m; l1++) {
				for (int l2 = l1; l2 &lt;= m; l2++) {
					sum = 0;
					for (int h = h1; h &lt;= h2; h++) {
						for (int l = l1; l &lt;= l2; l++) {
							sum += mat[h][l];
						}
					}
					if (sum &lt;= k) {
						cnt++;
					}
				}
			}
		}
	}
	cout &lt;&lt; cnt &lt;&lt; endl;
	return 0;
}
</code></pre> 
<h1>
<a id="_G__398"></a>试题 G: 积木画（动态规划）</h1> 
<p><img src="https://images2.imgbox.com/11/6d/T8kYsVRV_o.png" alt="G1"></p> 
<h2>
<a id="_400"></a>【样例输入】</h2> 
<pre><code>3
</code></pre> 
<h2>
<a id="_404"></a>【样例输出】</h2> 
<pre><code>5
</code></pre> 
<p><img src="https://images2.imgbox.com/fd/d8/Sbu50Akp_o.png" alt="G2"><br> 陷阱：注意要<strong>取模取模取模</strong>，经常有人忘记这回事！！！<br> （是的，比如说，我倒数第二题就忘记取模了。。。。。<br> 这道题足足用了我三张白纸，我从 n = 1 画到了 n = 6，写了一个小时。<br> 我认为 dp 就是找规律，可是，该死的是我 n = 6 的时候漏画了一种情况（三列横着的摆放），导致一直找不到规律。。。</p> 
<p>这道题的规律是，第 n 列可以通过前面的排列，再加上那几种基础的排列得到。<br> 第一种情况：<br> dp[n] 可以通过 dp[n - 1] 加上普通的一列得到<br> 第二种情况：<br> dp[n] 可以通过 dp[n - 2] 加上两块横的得到<br> 第三种情况：<br> dp[n] 可以通过 dp[n - 3] 加上两个三角形的堆起来得到，但要注意的是，<strong>这两个三角形的堆叠方式有两种</strong>，所以要加上两倍的 dp[n - 3]<br> <strong>第四种情况：</strong>（我考试的时候给漏掉了555，<strong>不过我现在还是没考虑完整，待完善…</strong><br> dp[n]可以通过 dp[n - 4] 加上由左右两个各一个三角形，中间若干个横块的组合得到，同第三种情况，这个组合可以倒过来，即有两种堆叠方式，因此要加上两倍的 dp[n - 4]<br> 综上：dp[n] = dp[n - 1] + dp[n - 2] + dp[n - 3] * 2 + dp[n - 4] * 2 <strong>（错解，待完善）</strong></p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

const long long MOD = 1e9 + 7;

const int maxn = 1e7 + 100;
long long dp[maxn];

int main() {
	int n;
	cin &gt;&gt; n;
	dp[0] = 1;
	dp[1] = 1;
	dp[2] = 2;
	dp[3] = 5;
	for (int i = 4; i &lt;= n; i++) {
		// 注意每次相加后都要取余
		dp[i] = (((((dp[i - 1] + dp[i - 2]) % MOD) + dp[i - 3] * 2) % MOD) + dp[i - 4] * 2) % MOD;
	}
	cout &lt;&lt; dp[n] &lt;&lt; endl;
	return 0;
}
</code></pre> 
<h1>
<a id="_H_BFS_448"></a>试题 H: 扫雷（BFS）</h1> 
<p><img src="https://images2.imgbox.com/fa/12/ZhnIaItR_o.png" alt="H1"></p> 
<h2>
<a id="_450"></a>【样例输入】</h2> 
<pre><code>2 1
2 2 4
4 4 2
0 0 5
</code></pre> 
<h2>
<a id="_457"></a>【样例输出】</h2> 
<pre><code>2
</code></pre> 
<p><img src="https://images2.imgbox.com/ef/ec/W0qD2NHj_o.png" alt="H2"><br> 赛前半小时又专门看了眼 BFS，用上了！<br> 陷阱①：一个点处可以存在多个炸雷和排雷火箭。当炸雷位于爆炸范围的边界上时也会被引爆。<br> 陷阱②：有 m 个排雷火箭，但只要求在最后输出一个整数表示答案（我比赛时就输出了 m 次答案…）</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;map&gt;
using namespace std;

const int maxn = 50100;
// 记录坐标和半径
int x_pos[maxn];
int y_pos[maxn];
int radius[maxn];
bool vis[maxn]; // 用来记录这个点爆炸了没有

// 用于 bfs 的 struct，更方便处理
struct point {
	int x, y, r;
	// 将结构体放入 map 中，需要自己写一个 operator 来排序，因为 map 本身是有序的
	bool operator &lt; (const point&amp; p) const {
		if (x == p.x) {
			if (y == p.y) {
				return r &lt; p.y;
			}
			return y &lt; p.y;
		}
		return x &lt; p.x;
	}
};

map&lt;point, int&gt; all;

double getDis(int x1, int y1, int x2, int y2) {
	return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

int bfs(point begin, int n) {
	int cnt = 0;
	queue&lt;point&gt; q;
	q.push(begin);
	while (!q.empty()) {
		point cur = q.front();
		q.pop();
		// 遍历以 2 倍半径为边长的正方形，找到其爆炸所涉及到的炸雷
		for (int i = cur.y - cur.r; i &lt;= cur.y + cur.r; i++) {
			for (int j = cur.x - cur.r; j &lt;= cur.x + cur.r; j++) {
				if (getDis(j, i, cur.x, cur.y) &gt; cur.r) {
					continue;
				}
				point temp;
				temp.y = i, temp.x = j;
				for (int k = 0; k &lt; n; k++) {
					if (!vis[k] &amp;&amp; x_pos[k] == temp.x &amp;&amp; y_pos[k] == temp.y) {
						temp.r = radius[k];
						q.push(temp);
						cnt++;
						all[temp]--;
						vis[k] = true; // 标记为已爆炸
					}
				}
			}
		}
	}
	return cnt;
}

int main() {
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; x_pos[i] &gt;&gt; y_pos[i] &gt;&gt; radius[i];
		vis[i] = false; // 初始化都还没有爆炸
	}
	int cnt = 0;
	for (int i = 0; i &lt; m; i++) {
		point p;
		cin &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.r;
		// 我比赛时输出了 m 次结果，裂开了
		// int cnt = 0;
		cnt += bfs(p, n);
		// cout &lt;&lt; cnt &lt;&lt; endl;
	}
	cout &lt;&lt; cnt &lt;&lt; endl;
	return 0;
}
</code></pre> 
<h1>
<a id="_I_DP___550"></a>试题 I: 李白打酒加强版（三维DP / 回溯）</h1> 
<p><img src="https://images2.imgbox.com/d2/9b/DQ9b4ibD_o.png" alt="I1"></p> 
<h2>
<a id="_552"></a>【样例输入】</h2> 
<pre><code>5 10
</code></pre> 
<h2>
<a id="_556"></a>【样例输出】</h2> 
<pre><code>14
</code></pre> 
<p><img src="https://images2.imgbox.com/c5/de/InKgNnqI_o.png" alt="I2"><br> <img src="https://images2.imgbox.com/dd/f7/s8CCBgLQ_o.png" alt="I3"><br> 泪目了，写题解发现 我 竟 然 <strong>忘记取模了忘记取模了忘记取模了</strong>5555555555<br> <strong>大家一定要记得取模！！！</strong></p> 
<p>做法一：三维dp（赛后学习的优化方法）</p> 
<p>三个维度分别对应：走了多少步、经过了多少家酒馆，酒壶中还剩多少酒<br> 在走到第 n 步时，他可能是从花走来的，也有可能是从酒馆走来的，所以要加上上一步遇到花的所有可能走法，再加上上一步遇到酒馆的所有可能走法。</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int MOD = 1e9 + 7;
const int maxn = 105; 
long long dp[maxn][maxn][maxn] = { 0 };

int main() {
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	// 初始化 dp
	dp[0][0][2] = 1;
	for (int i = 1; i &lt;= n + m; i++) {
		for (int j = 0; j &lt;= i; j++) {
			for (int k = 0; k &lt;= 100; k++) {
				// 遇到了花后抵达第 i 步
				dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k + 1]) % MOD;
				// 遇到了酒馆后抵达第 i 步
				// 当 k % 2 == 0 时才有可能是从酒馆走来的，因为经过酒馆后酒就加倍了
				if (j != 0 &amp;&amp; k % 2 == 0) {
					dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j - 1][k / 2]) % MOD;
				}
			}
		}
	}
	cout &lt;&lt; dp[n + m - 1][n][1] &lt;&lt; endl;
	return 0;
}
</code></pre> 
<p>做法二：回溯法（比赛时用的方法）</p> 
<p>年前和年后都练了一段时间的回溯，觉得特别有意思。<br> 赛前半小时还专门看了一眼！！然后考试最后半个小时花了 20min 就写出来了。<br> 本来一下子就写出框架了，不过太着急了，很多题目条件没看清楚，导致找了好久错误，不过还好，这题答案错了的话就是比正确答案大一些，很容易发现错误。</p> 
<p>主要错误如下：<br> ① 一共必须要且仅要经过 N 次店，M 次花<br> ② 最后一次遇到的必须是花<br> ③ 最后遇到花后，酒必须喝光<br> ④ 在中途遇到花时，酒不能为空</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

const int MOD = 1e9 + 7;

void backTrack(vector&lt;char&gt;&amp; temp, vector&lt;vector&lt;char&gt; &gt;&amp; ans, int n, int m, int nn, int mm, int jiu) {
	if (jiu &lt; 0) return; // 如果遇到花却没酒了，则不符合条件
	if (nn &gt; n || mm &gt; m) return; // 如果经过了多于 N 次店、M 次花，则不符合条件
	if (temp.size() == n + m) {
		if (jiu == 0 &amp;&amp; temp.back() == '0') { // 如果最后到达的是店也不符合条件
			ans.push_back(temp);
		}
		return;
	}
	
	temp.push_back('0');
	backTrack(temp, ans, n, m, nn, mm + 1, jiu - 1);
	temp.pop_back();
	temp.push_back('1');
	backTrack(temp, ans, n, m, nn + 1, mm, jiu * 2);
	temp.pop_back();
}

int main() {
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	int jiu = 2;
	vector&lt;char&gt; temp;
	vector&lt;vector&lt;char&gt; &gt; ans;
	backTrack(temp, ans, n, m, 0, 0, jiu);
	cout &lt;&lt; ans.size() % MOD &lt;&lt; endl;
	return 0;
}
</code></pre> 
<h1>
<a id="_J__649"></a>试题 J: 砍竹子</h1> 
<p><img src="https://images2.imgbox.com/18/19/JBFoyrYo_o.png" alt="J1"></p> 
<h2>
<a id="_651"></a>【样例输入】</h2> 
<pre><code>6
2 1 4 2 6 7
</code></pre> 
<h2>
<a id="_656"></a>【样例输出】</h2> 
<pre><code>5
</code></pre> 
<p><img src="https://images2.imgbox.com/bc/56/HBGrDAyR_o.png" alt="J2"><br> <img src="https://images2.imgbox.com/5d/86/TSsfCjh7_o.png" alt="J3"><br> 还剩最后十分钟，没时间做了，看了眼题也确实不会做。</p> 
<h1>
<a id="_664"></a>总结</h1> 
<p>① 注意题目要求，记得取模！<br> ② 注意范围，可能要用 long long<br> ③ 不要在一道题卡太长时间，比如我在 E 题卡了一个小时都没看懂题，就应该早早换题，最后换换思路再回来看或许反而能看懂了</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>