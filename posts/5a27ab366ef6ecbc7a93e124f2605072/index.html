<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>OpenGL---基于四元数的摄像机系统 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenGL---基于四元数的摄像机系统</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p>---------------------------------------------------------博主：mx</p> 
<h1 id="V9A2O">基础概念：</h1> 
<h2 id="bzxrY">摄象机：</h2> 
<p id="ud3d2a585">OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。</p> 
<p id="u07d3c3dc">当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右测的向量以及一个指向它上方的向量。细心的读者可能已经注意到我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/90/07/BNdKm3yB_o.png"></p> 
<p id="uef169170"></p> 
<h1 id="S8Hdm">摄像机坐标系：</h1> 
<p id="u56d3078c">我们只需要求出摄象机的前向(Front)向量，然后根据世界坐标系的y轴的向上的向量（0.0f,1.0f,0.0f），就可以通过叉乘求出与Front垂直的右向（Right）向量，知道Front向量和Right向量之后再根据叉乘就能够求出向上（Up）向量，由此摄像机的xyz三个轴都求出来了。</p> 
<p id="uac02f847"></p> 
<p id="u65397b22">由此我们再根据摄像机坐标和这三个轴，我们就能够求出来一个view矩阵，这个矩阵乘以任何向量都能够将这个向量变换到摄像机坐标系下。</p> 
<div style="text-align:center">
 <img alt="" src="https://images2.imgbox.com/ed/f2/TivsDLxy_o.png">
</div> 
<p id="u5ff06280">（其中R是右向量，U是上向量，D是方向向量PP是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。）</p> 
<p id="uc0662959"></p> 
<p id="u2df15690">对应opengl的api为</p> 
<p id="ufcaa5cee">glm::lookAt(glm::vec3 Position， glm::vec3 Target, glm::vec3 Up);</p> 
<p id="ub48416bd">glm::LookAt函数需要一个位置、目标和上向量。它会创建一个观察矩阵。</p> 
<h1 id="iGpro">相机移动</h1> 
<p id="u861b0eb0">只要改变相机的Position ，对应的view矩阵就会改变，物体和相机的相对距离也会改变。</p> 
<div style="text-align:center">
 <img alt="" src="https://images2.imgbox.com/f6/cd/pow7OMSI_o.png">
</div> 
<h1 id="KyBkR">相机缩放</h1> 
<p id="u8ae11054">视野(FOV)定义了我们可以看到场景中多大的范围。当视野变小时，场景投影出来的空间就会减小，产生放大(Zoom In)了的感觉。</p> 
<div style="text-align:center">
 <img alt="" src="https://images2.imgbox.com/b2/81/ZR0KGNi6_o.png">
</div> 
<h1 id="iQf1l">相机旋转</h1> 
<p id="u6b9f61ce">现在旋转常见的方法有：欧拉角（Euler angles）和四元数（Quaternion）</p> 
<p id="udecb9f4a"></p> 
<h2 id="iqBLd">欧拉角：</h2> 
<h3 id="ODNMa">基础概念：</h3> 
<p id="u1eb7fb2c">欧拉角是表示朝向的最简方法，只需存储绕X、Y、Z轴旋转的角度，分别叫PitchYawRoll（俯仰角偏航角滚转角）</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/ef/93/Fm9S7Qd9_o.png"></p> 
<p id="uf3cd2d57">俯仰角是描述我们如何往上或往下看的角，可以在第一张图中看到。第二张图展示了偏航角，偏航角表示我们往左和往右看的程度。滚转角代表我们如何翻滚摄像机，通常在太空飞船的摄像机中使用。</p> 
<p id="u8420711b"></p> 
<p id="u85d4b85d">这三个旋转是依次施加的，通常的顺序是：Y-Z-X（但并非一定要按照这种顺序）。顺序不同，产生的结果也不同。</p> 
<p id="u262ce48c"></p> 
<h3 id="hP7M8">欧拉角实现的摄象机旋转：</h3> 
<p id="u36dc521f">对于我们的摄像机系统来说，我们只关心俯仰角和偏航角，所以我们不会讨论滚转角。给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的3D向量。</p> 
<p>对于Pitch:</p> 
<div style="text-align:center">
 <img alt="" src="https://images2.imgbox.com/fd/d5/2a1S5nqf_o.png">
</div> 
<p id="u6f1a084a">direction.y = sin(glm::radians(pitch)); // 注意我们先把角度转为弧度</p> 
<p id="u0bfeac90">direction.x = cos(glm::radians(pitch));</p> 
<p id="u898952c8">direction.z = cos(glm::radians(pitch));</p> 
<p id="ucaac02c1"></p> 
<p>对于Yaw:</p> 
<div style="text-align:center">
 <img alt="" src="https://images2.imgbox.com/47/0f/px9tzczd_o.png">
</div> 
<p id="u07c24d81"></p> 
<p id="uee0e3830">direction.x = cos(glm::radians(yaw));</p> 
<p id="u6ec11d2f">direction.z = sin(glm::radians(yaw));</p> 
<p id="ufadf99f0"></p> 
<p>把这两个合起来：</p> 
<p id="ubd01f2f2"></p> 
<p id="u043a4e2a">direction.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));</p> 
<p id="u2789d0e3">direction.y = sin(glm::radians(pitch));</p> 
<p id="u17c386f2">direction.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));</p> 
<p id="u7b210179"></p> 
<p id="u80a1a3d3">得到基于欧拉角的旋转</p> 
<div style="text-align:center">
 <img alt="" src="https://images2.imgbox.com/57/fa/7WcEAEG3_o.png">
</div> 
<p id="u3cce80db"></p> 
<h3 id="cK0Qx">欧拉角的缺点：</h3> 
<ul>
<li id="ue5770149">对两个朝向进行插值比较困难。简单地对X、Y、Z角度进行插值得到的结果不太理想。</li>
<li id="ue737614c">实施多次旋转很复杂且不精确：必须计算出最终的旋转矩阵，然后据此推测书欧拉角。</li>
</ul>
<ul>
<li id="ucdb6ad01">“臭名昭著”的“万向节死锁”(Gimbal Lock)问题有时会让旋转“卡死”。（无论什么样的旋转顺序如xyz，在某个轴旋转之后有可能使得另两个轴的旋转等效）其他一些奇异状态还会导致模型方向翻转。</li>
<li id="u359a601e">不同的角度可产生同样的旋转（例如-180°和180°）</li>
</ul>
<ul>
<li id="ud68ec653">容易出错——如上所述，一般的旋转顺序是YZX，如果用了非YZX顺序的库，就有麻烦了。</li>
<li id="u66f94d19">某些操作很复杂：如绕指定的轴旋转N角度。</li>
</ul>
<p id="u8cb73843"></p> 
<h2 id="qkOPP">四元数：</h2> 
<p id="ua0a4be34">四元数能够轻松的解决上述欧拉角的问题</p> 
<h3 id="Jcq5T">基本概念：</h3> 
<p id="u9a00ccc2">四元数由4个数[x y z w]构成，表示了如下的旋转：</p> 
<p id="ub1ae5a2e">// RotationAxis，顾名思义即旋转轴。RotationAngle是旋转的角度。</p> 
<p id="u529e074d">x = RotationAxis.x * sin(RotationAngle / 2)</p> 
<p id="ue72156e2">y = RotationAxis.y * sin(RotationAngle / 2)</p> 
<p id="uffa64467">z = RotationAxis.z * sin(RotationAngle / 2)</p> 
<p id="u7d0cd49f">w = cos(RotationAngle / 2)</p> 
<p id="u4b001841">---------------------------------------------------------博主：mx</p> 
<div style="text-align:center">
 <img alt="" src="https://images2.imgbox.com/b2/cf/YvnsEsPO_o.png">
</div> 
<p id="u275fe181"></p> 
<p id="u7274552e">根据w分量我们可以清除的知道旋转的角度，然后再根据xyz可以推出旋转轴</p> 
<p id="u94f558ee"></p> 
<h3 id="Svd7D">四元数的使用：</h3> 
<p>四元数的创建：</p> 
<p id="u77247719">#include &lt;glm/gtc/quaternion.hpp&gt;</p> 
<p id="u9e134159">#include &lt;glm/gtx/quaternion.hpp&gt;</p> 
<p id="uea4528e3">// Creates an identity quaternion (no rotation) quat MyQuaternion;</p> 
<p id="u670a16cd">// Direct specification of the 4 components</p> 
<p id="u40e8f5e3">// You almost never use this directly MyQuaternion = quat(w,x,y,z);</p> 
<p id="u3694bce1"></p> 
<p id="u52180855">// Conversion from Euler angles (in radians) to Quaternion</p> 
<p id="u2de16c0d">vec3 EulerAngles(90, 45, 0);</p> 
<p id="u4eac741d">MyQuaternion = quat(EulerAngles);</p> 
<p id="u3b730c06"></p> 
<p id="u18237fa0">// Conversion from axis-angle</p> 
<p id="uf9df62d6">// In GLM the angle must be in degrees here, so convert it.</p> 
<p id="u09a9682a">MyQuaternion=gtx::quaternion::angleAxis(degrees(RotationAngle), RotationAxis);</p> 
<p id="u9eedc4d4"></p> 
<p id="u8706f313">注意如果是在shader中，应该把四元数转换成旋转矩阵，顶点会一如既往地随着MVP矩阵的变化而旋转。</p> 
<p id="u017b675f"></p> 
<p id="ucd452ded">mat4 RotationMatrix = quaternion::toMat4(quaternion);</p> 
<p id="u9bcdbf59">...</p> 
<p id="u35d914ad">mat4 ModelMatrix = TranslationMatrix * RotationMatrix * ScaleMatrix;</p> 
<p id="u311b0350">// You can now use ModelMatrix to build the MVP matrix</p> 
<p>旋转向量/点：</p> 
<p id="uaafccfa6">rotated_point = orientation_quaternion * point;</p> 
<p id="u978837b1">//向量也一样</p> 
<p>对两个四元数进行插值：</p> 
<p id="u1637ba52">SLERP意为球面线性插值（Spherical Linear intERPolation）、可以用GLM中的mix函数进行SLERP：</p> 
<p id="u73126e86">glm::quat interpolatedquat = quaternion::mix(quat1, quat2, 0.5f); // or whatever factor</p> 
<p>两个旋转的累计：</p> 
<p id="ud72e2952">只需将两个四元数相乘即可。顺序和矩阵乘法一致。亦即逆序相乘：</p> 
<p id="u3d8ae151">quat combined_rotation = second_rotation * first_rotation;</p> 
<p>两个向量之间的旋转：</p> 
<p id="u460bbfb4">基本思路很简单：</p> 
<ul>
<li id="u2c2c3789">两向量间的夹角很好找：由点积可知其cos值。</li>
<li id="ub8f413da">旋转轴很好找：两向量的叉乘积</li>
</ul>
<p id="u898127b9">---------------------------------------------------------博主：mx</p> 
<p id="u75aa99ef">quat RotationBetweenVectors(vec3 start, vec3 dest){<!-- --></p> 
<p id="ue87507b9">start = normalize(start);</p> 
<p id="u6f7d329f">dest = normalize(dest);</p> 
<p id="u4c756ce8"></p> 
<p id="u0a3fb76c">float cosTheta = dot(start, dest);</p> 
<p id="u40e235b8">vec3 rotationAxis;</p> 
<p id="u558c8382"></p> 
<p id="u9b6b3b6d">if (cosTheta &lt; -1 + 0.001f){<!-- --></p> 
<p id="u39260ff5">// special case when vectors in opposite directions:</p> 
<p id="u355cd118">// there is no "ideal" rotation axis</p> 
<p id="u26c83d8d">// So guess one; any will do as long as it's perpendicular to start</p> 
<p id="uc2bb3963">rotationAxis = cross(vec3(0.0f, 0.0f, 1.0f), start);</p> 
<p id="ub5cd8d22">if (gtx::norm::length2(rotationAxis) &lt; 0.01 ) // bad luck, they were parallel, try again!</p> 
<p id="uc8a99329">rotationAxis = cross(vec3(1.0f, 0.0f, 0.0f), start);</p> 
<p id="u718f30c3"></p> 
<p id="u8ffee552">rotationAxis = normalize(rotationAxis);</p> 
<p id="ua10c2659">return gtx::quaternion::angleAxis(180.0f, rotationAxis);</p> 
<p id="uc6545c7c">}</p> 
<p id="u45b04291"></p> 
<p id="u43571990">rotationAxis = cross(start, dest);</p> 
<p id="u8e57ce52"></p> 
<p id="ue45e7674">float s = sqrt( (1+cosTheta)*2 );</p> 
<p id="u74fbeabe">float invs = 1 / s;</p> 
<p id="ubf0a2d61"></p> 
<p id="u04c30a09">return quat(</p> 
<p id="ua9ea3664">s * 0.5f,</p> 
<p id="u47734ba6">rotationAxis.x * invs,</p> 
<p id="ufa3651d4">rotationAxis.y * invs,</p> 
<p id="ue4cc6fd7">rotationAxis.z * invs</p> 
<p id="uadfcb85c">);</p> 
<p id="uedf38f11"></p> 
<p id="u0018aa3e">}</p> 
<p id="ue8b760d5">---------------------------------------------------------博主：mx</p> 
<h3 id="Pue5E">四元数实现摄象机旋转：</h3> 
<p id="ua8aea560">正确的做法：</p> 
<p id="u71bb7cb3">先基于完整最开始的世界坐标系，我们假设屏幕空间是在上面，然后我们求出原生front向量，到我们鼠标点击的点到原点的向量，求出这两个向量需要的旋转四元数。然后将这个四元数应用于目前的front向量上。</p> 
<p id="u19fd52a1"></p> 
<div style="text-align:center">
 <img alt="" src="https://images2.imgbox.com/f9/0a/KcxXmSUh_o.png">
</div> 
<p id="u0631d942">求出两个向量之间的旋转</p> 
<p id="u8c3e33e0">glm::quat rot1 = RotationBetweenVectors(glm::vec3(0.0f, 0.0f, 1.0f),normalize(glm::vec3(0.008f * MouseSensitivity*xoffset, 0.008f * MouseSensitivity * yoffset, 1.0f)) );</p> 
<p id="u493d08f5"></p> 
<p id="u63f51da1">将这个旋转四元数应用于当前的Front</p> 
<p id="ue8f3fdaa"></p> 
<p id="u46b36f7a">Front = glm::normalize(glm::rotate(rot1, Front));</p> 
<p id="ub903cd20">Right = glm::normalize(glm::cross(Front, WorldUp)); // normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.</p> 
<p id="u12c81aa8">Up = glm::normalize(glm::cross(Right, Front));</p> 
<p id="u50171feb"></p> 
<div style="text-align:center">
 <img alt="" src="https://images2.imgbox.com/90/3a/zPtLVEky_o.png">
</div> 
<h1 id="Elk49">完整代码：</h1> 
<p id="u3318fcd2">因为我尝试过三个方案所以旋转的代码有点多，上面四元数实现的旋转的函数名为updateCameraVectorsByQuat2</p> 
<p id="uf78f17e0">---------------------------------------------------------博主：mx</p> 
<p id="u010bd968">Shader:</p> 
<p id="u3ed9d838">#version460</p> 
<p id="u96dc0f30">layout(location =0) in vec3 aPos;</p> 
<p id="u239f902f">layout(location =1) in vec2 aTexCoord;</p> 
<p id="ub854709e">uniformfloat offset1;</p> 
<p id="uc34e87e1">uniformmat4 model;</p> 
<p id="u722439d5">uniformmat4 view;</p> 
<p id="uc7c3e942">uniformmat4 projection;</p> 
<p id="udbc46d31">out vec2 TexCoord;</p> 
<p id="ue6721949">voidmain()</p> 
<p id="u8aef965c">{<!-- --></p> 
<p id="ubef98308">gl_Position =projection*view*model*vec4(aPos.x+offset1,-aPos.y,aPos.z,1.0f);</p> 
<p id="ue86f3852">TexCoord = aTexCoord;</p> 
<p id="u6d91cb48">}</p> 
<p id="ub459920b"></p> 
<p id="u65389f89">#version460</p> 
<p id="uc04dcf9d">in vec2 TexCoord;</p> 
<p id="u52bfe70c">out vec4 FragColor;</p> 
<p id="ub078ade2">uniformfloat offset2;</p> 
<p id="u17edbfc3">uniformsampler2D texture1;</p> 
<p id="ua33b086b">uniformsampler2D texture2;</p> 
<p id="u2e9689ef">voidmain()</p> 
<p id="ud3e69c05">{<!-- --></p> 
<p id="u0e9d6009">FragColor =mix(texture(texture1, TexCoord),texture(texture2,vec2(1-TexCoord.x,TexCoord.y)),0.8);</p> 
<p id="u3072f34e">}</p> 
<p id="uf14e24c3">头文件：</p> 
<p id="u8f3e531b">#pragma once</p> 
<p id="ufde277b8">#include &lt;glad/glad.h&gt;</p> 
<p id="ud776f40a">#include &lt;GLFW/glfw3.h&gt;</p> 
<p id="uc1740627">#include "glm/glm.hpp"</p> 
<p id="uade4972d">#include "glm/gtc/matrix_transform.hpp"</p> 
<p id="u51fc52be">#include "glm/gtc/type_ptr.hpp"</p> 
<p id="uc052bab3">#include "glm/gtc/quaternion.hpp"</p> 
<p id="u72eb3576">#include "glm/gtx/quaternion.hpp"</p> 
<p id="u80184c97"></p> 
<p id="u1f533dd1">#define STB_IMAGE_IMPLEMENTATION</p> 
<p id="u5f9fc094">#include "stb_image.h"</p> 
<p id="ued6d1248"></p> 
<p id="u9bfa8cdb">代码：</p> 
<p id="u42d0d3cf">#pragma once</p> 
<p id="u15a0d099"></p> 
<p id="u47d31e41">#ifndef CAMERA_H</p> 
<p id="u6dbdf4e2">#define CAMERA_H</p> 
<p id="u5814631c"></p> 
<p id="u9089d1bb">#include &lt;glad/glad.h&gt;</p> 
<p id="ub314473d">#include "glm/glm.hpp"</p> 
<p id="ufcd163a4">#include "glm/gtc/matrix_transform.hpp"</p> 
<p id="ube6b033c">#include "glm/gtc/quaternion.hpp"</p> 
<p id="u77b91062">#include "glm/gtx/quaternion.hpp"</p> 
<p id="uf63c36a6"></p> 
<p id="u06f4ce2a">#include &lt;vector&gt;</p> 
<p id="u37806329"></p> 
<p id="ua1b69a4a"></p> 
<p id="u23b7df81">enum class Camera_Movement {<!-- --></p> 
<p id="u768f0a7a">FORWARD,</p> 
<p id="uf03fd9ce">BACKWARD,</p> 
<p id="u126d5820">LEFT,</p> 
<p id="u53b98d21">RIGHT</p> 
<p id="u995317a8">};</p> 
<p id="u867e41c9"></p> 
<p id="uf7bc1b40">// Default camera values</p> 
<p id="u0334c952">const float YAW = -90.0f;</p> 
<p id="uf130f332">const float PITCH = 0.0f;</p> 
<p id="u4f0fdcec">const float SPEED = 2.5f;</p> 
<p id="u5cfb6379">const float SENSITIVITY = 0.1f;</p> 
<p id="u072acfb1">const float FOV = 45.0f;</p> 
<p id="u469ef3f6"></p> 
<p id="uf1a72baa">class Camera</p> 
<p id="uc0c22ae5">{<!-- --></p> 
<p id="u27ea38c1">public:</p> 
<p id="ud453aabc">// camera Attributes</p> 
<p id="u3d6e8514">glm::vec3 Position;</p> 
<p id="ude129fb9">glm::vec3 Front;</p> 
<p id="u36bf8905">glm::vec3 Up;</p> 
<p id="ud1d1eba1">glm::vec3 Right;</p> 
<p id="ue97582fa">glm::vec3 WorldUp;</p> 
<p id="u47f660d8">glm::quat FrontQuaternion;</p> 
<p id="u29635573">// euler Angles</p> 
<p id="uc384b5fb">float Yaw;</p> 
<p id="u1a203f57">float Pitch;</p> 
<p id="u357ece4d">// camera options</p> 
<p id="u4d7a7f3e">float MovementSpeed;</p> 
<p id="u680fca43">float MouseSensitivity;</p> 
<p id="ub5d765cc">float Fov;</p> 
<p id="ueec232da"></p> 
<p id="udf9d59bb">// constructor with vectors</p> 
<p id="u21971772">Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), float yaw = YAW, float pitch = PITCH);</p> 
<p id="u428fd3c1">// constructor with scalar values</p> 
<p id="ud8aa17db">Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch);</p> 
<p id="u0ea66448">// returns the view matrix calculated using Euler Angles and the LookAt Matrix</p> 
<p id="u09790c3a">glm::mat4 GetViewMatrix();</p> 
<p id="u8747b00a"></p> 
<p id="ua56cb53a">// processes input received from any keyboard-like input system. Accepts input parameter in the form of camera defined ENUM (to abstract it from windowing systems)</p> 
<p id="uddee9fee">void ProcessKeyboard(Camera_Movement direction, float deltaTime);</p> 
<p id="u3a2a6423"></p> 
<p id="ud244b763">// processes input received from a mouse input system. Expects the offset value in both the x and y direction.</p> 
<p id="uc86261fd">void ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch = true);</p> 
<p id="u798aafee"></p> 
<p id="u04bc9c4a">// processes input received from a mouse scroll-wheel event. Only requires input on the vertical wheel-axis</p> 
<p id="ud2f225aa">void ProcessMouseScroll(float yoffset);</p> 
<p id="u3d961a2c"></p> 
<p id="u59be06c0">void updateCameraVectorsByQuat1(float xoffset, float yoffset);</p> 
<p id="udb9cabc8"></p> 
<p id="uc616a213"></p> 
<p id="u51e03800">void updateCameraVectorsByQuat2(float xoffset, float yoffset);</p> 
<p id="uc6b1619c"></p> 
<p id="u4ffdab30">glm::quat RotationBetweenVectors(glm::vec3 start, glm::vec3 dest);</p> 
<p id="ub8036ac1">void ResetYawAndPitch();</p> 
<p id="ud04033b1"></p> 
<p id="u43c4af56">private:</p> 
<p id="uf8bfabd3">// calculates the front vector from the Camera's (updated) Euler Angles</p> 
<p id="ufefbd734">void updateCameraVectors();</p> 
<p id="u8a821749"></p> 
<p id="u1249f6ab"></p> 
<p id="u79b48f48">};</p> 
<p id="u946fef50">#endif</p> 
<p id="ud9ad902d">#include "Camera.h"</p> 
<p id="u8e12cf37"></p> 
<p id="u928a234b">Camera::Camera(glm::vec3 position, glm::vec3 up, float yaw, float pitch) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Fov(FOV)</p> 
<p id="u3e02781b">{<!-- --></p> 
<p id="uc62cceeb">Position = position;</p> 
<p id="uf7e18f6c">WorldUp = up;</p> 
<p id="ud97c2617">Yaw = yaw;</p> 
<p id="u6d06dc11">Pitch = pitch;</p> 
<p id="u720a6237">updateCameraVectors();</p> 
<p id="u081b8ce1">}</p> 
<p id="u83f95f31"></p> 
<p id="u7f50a19e">Camera::Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Fov(FOV)</p> 
<p id="uf786a90c">{<!-- --></p> 
<p id="u0456c343">Position = glm::vec3(posX, posY, posZ);</p> 
<p id="ue615cbab">WorldUp = glm::vec3(upX, upY, upZ);</p> 
<p id="ub0d85141">Yaw = yaw;</p> 
<p id="u9b0e3756">Pitch = pitch;</p> 
<p id="u09528545">updateCameraVectors();</p> 
<p id="u133995b3">}</p> 
<p id="ube4968fd"></p> 
<p id="u7904039e">glm::mat4 Camera::GetViewMatrix()</p> 
<p id="u341a621d">{<!-- --></p> 
<p id="u79ee35a6">return glm::lookAt(Position, Position + Front, Up);</p> 
<p id="uaf31f6d3"></p> 
<p id="u33d46f6e">}</p> 
<p id="uff1ff7d8"></p> 
<p id="u48bb4e77">void Camera::ProcessKeyboard(Camera_Movement direction, float deltaTime)</p> 
<p id="uc21a8a61">{<!-- --></p> 
<p id="uc9feb924">float velocity = MovementSpeed * deltaTime;</p> 
<p id="uc9c882a3">if (direction == Camera_Movement::FORWARD)</p> 
<p id="u2e75c838">Position += Front * velocity;</p> 
<p id="ua76db934">if (direction == Camera_Movement::BACKWARD)</p> 
<p id="ua710ef22">Position -= Front * velocity;</p> 
<p id="u24210c6d">if (direction == Camera_Movement::LEFT)</p> 
<p id="u59db4018">Position -= Right * velocity;</p> 
<p id="u47e132fb">if (direction == Camera_Movement::RIGHT)</p> 
<p id="uf621aafe">Position += Right * velocity;</p> 
<p id="ue9d4b2be">}</p> 
<p id="ud3dc42e5"></p> 
<p id="ue1faa58a">void Camera::ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch)</p> 
<p id="u546daeca">{<!-- --></p> 
<p id="uf66cf4ce">xoffset *= MouseSensitivity;</p> 
<p id="u18400346">yoffset *= MouseSensitivity;</p> 
<p id="u1c4c2ac1"></p> 
<p id="u54a9c9f0">Yaw += xoffset;</p> 
<p id="u9347e935">Pitch += yoffset;</p> 
<p id="uaa9127db"></p> 
<p id="u657cba37">// make sure that when pitch is out of bounds, screen doesn't get flipped</p> 
<p id="u79151f62">if (constrainPitch)</p> 
<p id="u18b2d2b8">{<!-- --></p> 
<p id="u5190fd99">if (Pitch &gt; 89.0f)</p> 
<p id="u4c1de7b2">Pitch = 89.0f;</p> 
<p id="ucdd16908">if (Pitch &lt; -89.0f)</p> 
<p id="u910abab9">Pitch = -89.0f;</p> 
<p id="u8db201e9">}</p> 
<p id="uaff90172"></p> 
<p id="u9f67f66f">// update Front, Right and Up Vectors using the updated Euler angles</p> 
<p id="u906f7baa">updateCameraVectors();</p> 
<p id="u5213140c">}</p> 
<p id="u14ed89f9"></p> 
<p id="uc42e55ad">void Camera::ProcessMouseScroll(float yoffset)</p> 
<p id="u18cb3837">{<!-- --></p> 
<p id="u75734931">Fov -= (float)yoffset;</p> 
<p id="ud4fe211e">if (Fov &lt; 1.0f)</p> 
<p id="u038ccdc1">Fov = 1.0f;</p> 
<p id="u604d1a51">if (Fov &gt; 45.0f)</p> 
<p id="ua56dbbf4">Fov = 45.0f;</p> 
<p id="ue91bacb2">}</p> 
<p id="u8ed9fd0c"></p> 
<p id="ub6b7e285">/// &lt;summary&gt;</p> 
<p id="u45a83907">/// upadate CameraVector by Euler</p> 
<p id="u39991c9f">/// &lt;/summary&gt;</p> 
<p id="u8e3dfc7e">void Camera::updateCameraVectors()</p> 
<p id="ub9365ab8">{<!-- --></p> 
<p id="u0824e3f0">// calculate the new Front vector</p> 
<p id="u1088a959">glm::vec3 front;</p> 
<p id="u9d0114b9">front.x = cos(glm::radians(Yaw))* cos(glm::radians(Pitch));</p> 
<p id="ua2adf7ef">front.y = sin(glm::radians(Pitch));</p> 
<p id="u30fa52ae">front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));</p> 
<p id="u1bb8f445">/*</p> 
<p id="u80589026">front.x = cos(glm::radians(Yaw));</p> 
<p id="uf758c495">front.y = sin(glm::radians(Pitch));</p> 
<p id="u38a382ef">front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));</p> 
<p id="u3e16de8d">*/</p> 
<p id="u83d6b044">Front = glm::normalize(front);</p> 
<p id="u05b6325a">// also re-calculate the Right and Up vector</p> 
<p id="uf50bfb52">Right = glm::normalize(glm::cross(Front, WorldUp)); // normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.</p> 
<p id="ud421f6a1">Up = glm::normalize(glm::cross(Right, Front));</p> 
<p id="ua47f6457">FrontQuaternion = glm::quat(Front);</p> 
<p id="u92122801">}</p> 
<p id="u79f355f7"></p> 
<p id="u84f7e075">/// &lt;summary&gt;</p> 
<p id="ufb2970e3">/// update CameraVector by Quat(Maybe have some question)</p> 
<p id="uda15aaa4">/// &lt;/summary&gt;</p> 
<p id="u6da388c2">/// &lt;param name="xoffset"&gt;&lt;/param&gt;</p> 
<p id="uf2a2bf6f">/// &lt;param name="yoffset"&gt;&lt;/param&gt;</p> 
<p id="u41a2e4ad">/// &lt;param name="constrainPitch"&gt;&lt;/param&gt;</p> 
<p id="u92ee2e5d">void Camera::updateCameraVectorsByQuat1( float xoffset, float yoffset)</p> 
<p id="ue9623646">{<!-- --></p> 
<p id="uc22f1482">Yaw += 90;</p> 
<p id="u05d3f1f4">xoffset *= 0.008f*MouseSensitivity;</p> 
<p id="u026c6c2d">yoffset *= 0.008f * MouseSensitivity;</p> 
<p id="u8ecaf8cf"></p> 
<p id="ua2544ce3">Yaw = xoffset;</p> 
<p id="ub8374f75">Pitch= yoffset;</p> 
<p id="u80fac168"></p> 
<p id="uc4af8ec9">// make sure that when pitch is out of bounds, screen doesn't get flipped</p> 
<p id="uc7b4fbed"></p> 
<p id="uc36b78c3">if (Pitch &gt; 90.0f)</p> 
<p id="ue63df893">Pitch -= 90.0f;</p> 
<p id="u40668a0d">if (Pitch &lt; -90.0f)</p> 
<p id="u42628ee6">Pitch += 90.0f;</p> 
<p id="u58f63b47"></p> 
<p id="uca1241d9">if (Yaw &gt; 90.0f)</p> 
<p id="u9b337883">Yaw -= 90.0f;</p> 
<p id="ufa365775">if (Yaw &lt; -90.0f)</p> 
<p id="u6afda936">Yaw += 90.0f;</p> 
<p id="ua63d2578"></p> 
<p id="ua4e0be68"></p> 
<p id="u9a61dece">glm::vec3 axis = glm::cross(Front, Up);</p> 
<p id="u55fb93f5">glm::quat pitchQuat = glm::angleAxis(Pitch, axis);</p> 
<p id="u3688273c">//determine heading quaternion from the camera up vector and the heading angle</p> 
<p id="u4e374a7a">axis = glm::cross(Front, axis);</p> 
<p id="u8d4da3d8">glm::quat yawQuat = glm::angleAxis(Yaw, Up);</p> 
<p id="u1dee083f">//add the two quaternions</p> 
<p id="uba0f52f8">glm::quat combinedRotation = pitchQuat*yawQuat;</p> 
<p id="u6586fa0b"></p> 
<p id="ubd7294c5">Front = glm::rotate(combinedRotation, Front);</p> 
<p id="uf23daf46"></p> 
<p id="ue5f67003"></p> 
<p id="u7d4fc824">Front = glm::normalize(Front);</p> 
<p id="u6cc00f6f">Right = glm::normalize(glm::cross(Front, WorldUp)); // normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.</p> 
<p id="uf64eb7fa">Up = glm::normalize(glm::cross(Right, Front));</p> 
<p id="u113b37f5"></p> 
<p id="uc9e8a9e8">Yaw -= 90;</p> 
<p id="uc1a4a426">}</p> 
<p id="uc4bee859"></p> 
<p id="u09e68ea8">/// &lt;summary&gt;</p> 
<p id="u748777ba">/// update CameraVector by Quat (right)</p> 
<p id="u2e24732c">/// &lt;/summary&gt;</p> 
<p id="ue9420b51">/// &lt;param name="xoffset"&gt;&lt;/param&gt;</p> 
<p id="u4c463525">/// &lt;param name="yoffset"&gt;&lt;/param&gt;</p> 
<p id="u96b8c8e3">void Camera::updateCameraVectorsByQuat2(float xoffset, float yoffset)</p> 
<p id="uaa1b68b7">{<!-- --></p> 
<p id="ub2ed9c3f">// Find the rotation between the front of the object (that we assume towards +Z,</p> 
<p id="ua0d4a05c">// but this depends on your model) and the desired direction</p> 
<p id="u8798bd1b">glm::quat rot1 = RotationBetweenVectors(glm::vec3(0.0f, 0.0f, 1.0f),normalize(glm::vec3(0.008f * MouseSensitivity*xoffset, 0.008f * MouseSensitivity * yoffset, 1.0f)) );</p> 
<p id="ub4e180d8"></p> 
<p id="u5c2d1c11">Front = glm::normalize(glm::rotate(rot1, Front));</p> 
<p id="ub1c193ca">Right = glm::normalize(glm::cross(Front, WorldUp)); // normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.</p> 
<p id="u1f30404b">Up = glm::normalize(glm::cross(Right, Front));</p> 
<p id="ubf329e3e"></p> 
<p id="ufe6ca315"></p> 
<p id="ub41174a5">}</p> 
<p id="ucd51009e"></p> 
<p id="u32b721a2">/// &lt;summary&gt;</p> 
<p id="u0bf61cbe">/// get rotation between two vectors</p> 
<p id="ud964c349">/// &lt;/summary&gt;</p> 
<p id="udf712e9c">/// &lt;param name="start"&gt;&lt;/param&gt;</p> 
<p id="u6c982c42">/// &lt;param name="dest"&gt;&lt;/param&gt;</p> 
<p id="uc2b90a29">/// &lt;returns&gt;&lt;/returns&gt;</p> 
<p id="ue59110c3">glm::quat Camera::RotationBetweenVectors(glm::vec3 start, glm::vec3 dest)</p> 
<p id="ub583e152">{<!-- --></p> 
<p id="u8b3018fc">start = normalize(start);</p> 
<p id="u4394daf9">dest = normalize(dest);</p> 
<p id="u1493a1e1"></p> 
<p id="u296505e8">float cosTheta = dot(start, dest);</p> 
<p id="u84e546c9">glm::vec3 rotationAxis;</p> 
<p id="u8c3be479"></p> 
<p id="uc6c4e131">if (cosTheta &lt; -1 + 0.001f) {<!-- --></p> 
<p id="u8e16b845">// special case when vectors in opposite directions:</p> 
<p id="u332dfb22">// there is no "ideal" rotation axis</p> 
<p id="u96f75a0f">// So guess one; any will do as long as it's perpendicular to start</p> 
<p id="uec6e903c">rotationAxis = glm::cross(glm::vec3(0.0f, 0.0f, 1.0f), start);</p> 
<p id="ub1fd2b09">if (glm::length2(rotationAxis) &lt; 0.01) // bad luck, they were parallel, try again!</p> 
<p id="u950c03a0">rotationAxis = glm::cross(glm::vec3(1.0f, 0.0f, 0.0f), start);</p> 
<p id="uf718c16e"></p> 
<p id="u1a9ead7f">rotationAxis = normalize(rotationAxis);</p> 
<p id="u9d294ffb">return glm::angleAxis(180.0f, rotationAxis);</p> 
<p id="uc99c5a56">}</p> 
<p id="ud6ac9f01"></p> 
<p id="u4d6081ee">rotationAxis = cross(start, dest);</p> 
<p id="u1d61ef2e"></p> 
<p id="ua396751b">float s = sqrt((1 + cosTheta) * 2);</p> 
<p id="u570ae6d2">float invs = 1 / s;</p> 
<p id="ub38814f1"></p> 
<p id="u81d08068">return glm::quat(</p> 
<p id="u3476ff63">s * 0.5f,</p> 
<p id="u10360bae">rotationAxis.x * invs,</p> 
<p id="u4af7570a">rotationAxis.y * invs,</p> 
<p id="u53382c70">rotationAxis.z * invs</p> 
<p id="u6e6ed8be">);</p> 
<p id="ub05ba249"></p> 
<p id="u424b739e">}</p> 
<p id="u393ebd4c"></p> 
<p id="u4d3590f2">void Camera::ResetYawAndPitch()</p> 
<p id="u5c1cdb3d">{<!-- --></p> 
<p id="u3ee6a078">Yaw = YAW;</p> 
<p id="u5bede480">Pitch = PITCH;</p> 
<p id="ua8e4bfd0">}</p> 
<p id="u48c7534d"></p> 
<p id="u26c4f420"></p> 
<p id="u298490a9">#pragma once</p> 
<p id="uf5f63178">#ifndef SHADER_H</p> 
<p id="ue0afa4ef">#define SHADER_H</p> 
<p id="u09783756">#include &lt;glad/glad.h&gt;; // 包含glad来获取所有的必须OpenGL头文件</p> 
<p id="uff3c750b">#include "glm/glm.hpp"</p> 
<p id="u951120c1">#include &lt;string&gt;</p> 
<p id="uaa4f6a72">#include &lt;fstream&gt;</p> 
<p id="uf78ad533">#include &lt;sstream&gt;</p> 
<p id="u3886ba43">#include &lt;iostream&gt;</p> 
<p id="u7ca19fa9">class Shader</p> 
<p id="u6fc81478">{<!-- --></p> 
<p id="u52d7d7e6">public:</p> 
<p id="u88b7da3a">// 程序ID</p> 
<p id="u7b526423">unsigned int ID;</p> 
<p id="ucf7e6083">// 构造器读取并构建着色器</p> 
<p id="u886bc385">Shader(const GLchar* vertexPath, const GLchar* fragmentPath, const char* geometryPath=nullptr);</p> 
<p id="uc2cd32d0">~Shader();</p> 
<p id="u32cf7731">// 使用/激活程序</p> 
<p id="uc9545df3">void use(); // uniform工具函数</p> 
<p id="u4b81d77c">void setBool(const std::string&amp; name, bool value)const;</p> 
<p id="ue0765bce">void setInt(const std::string&amp; name, int value)const;</p> 
<p id="u9905a23b">void setFloat(const std::string&amp; name, float value)const;</p> 
<p id="uabb7b0b7">void setVec2(const std::string&amp; name, const glm::vec2&amp; value) const;</p> 
<p id="u0c8f55dd">void setVec2(const std::string&amp; name, float x, float y) const;</p> 
<p id="u0cd85cd9">void setVec3(const std::string&amp; name, const glm::vec3&amp; value) const;</p> 
<p id="ud550c4aa">void setVec3(const std::string&amp; name, float x, float y, float z) const;</p> 
<p id="u5101a8a9">void setVec4(const std::string&amp; name, const glm::vec4&amp; value) const;</p> 
<p id="u435ba6af">void setVec4(const std::string&amp; name, float x, float y, float z, float w) const;</p> 
<p id="ua933b98f">void setMat2(const std::string&amp; name, const glm::mat2&amp; mat) const;</p> 
<p id="uc4e1286b">void setMat3(const std::string&amp; name, const glm::mat3&amp; mat) const;</p> 
<p id="u5248767b">void setMat4(const std::string&amp; name, const glm::mat4&amp; mat) const;</p> 
<p id="u2b99dd70"></p> 
<p id="u3ff7f003">};</p> 
<p id="u585c6152">#endif</p> 
<p id="ud92d0475"></p> 
<p id="u88d77df9">#include "Shader.h"</p> 
<p id="uebf4ba62"></p> 
<p id="u3a21181b">Shader::Shader(const GLchar* vertexPath, const GLchar* fragmentPath, const char* geometryPath)</p> 
<p id="u70d7e7bf">{<!-- --></p> 
<p id="u69887aa8">// 1. 从文件路径中获取顶点/片段着色器</p> 
<p id="ufcee01ee">std::string vertexCode;</p> 
<p id="u23f8ac5d">std::string fragmentCode;</p> 
<p id="u5ce42304">std::string geometryCode;</p> 
<p id="u995cdc3c">std::ifstream vShaderFile;</p> 
<p id="u126b4320">std::ifstream fShaderFile;</p> 
<p id="ud13d5d74">std::ifstream gShaderFile;</p> 
<p id="u8ffb79e3">// 保证ifstream对象可以抛出异常：</p> 
<p id="u20c53874">vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);</p> 
<p id="u6a004b96">fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);</p> 
<p id="uf73ce06a">gShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);</p> 
<p id="u0b0eec84">try {<!-- --></p> 
<p id="ub460bf00">// 打开文件</p> 
<p id="u81d489fd">vShaderFile.open(vertexPath);</p> 
<p id="u4a61efc7">fShaderFile.open(fragmentPath);</p> 
<p id="u7f8e09ba">std::stringstream vShaderStream, fShaderStream; // 读取文件的缓冲内容到数据流中</p> 
<p id="uac647561">vShaderStream &lt;&lt; vShaderFile.rdbuf();</p> 
<p id="u66c7086e">fShaderStream &lt;&lt; fShaderFile.rdbuf();</p> 
<p id="ubb0d1761">// 关闭文件处理器</p> 
<p id="udd7e97ed">vShaderFile.close();</p> 
<p id="u3da117bc">fShaderFile.close();</p> 
<p id="uf2a25355">// 转换数据流到string</p> 
<p id="u91b7a3b8">vertexCode = vShaderStream.str();</p> 
<p id="uc9f61a91">fragmentCode = fShaderStream.str();</p> 
<p id="uf829e54c">unsigned int geometry;</p> 
<p id="u18ab4523">if (geometryPath != nullptr)</p> 
<p id="u6439a2d1">{<!-- --></p> 
<p id="ub7a206b1">gShaderFile.open(geometryPath);</p> 
<p id="u4c3e5e09">std::stringstream gShaderStream;</p> 
<p id="u69605d52">gShaderStream &lt;&lt; gShaderFile.rdbuf();</p> 
<p id="u316ac951">gShaderFile.close();</p> 
<p id="u9bb61477">geometryCode = gShaderStream.str();</p> 
<p id="u7fc0c23b">}</p> 
<p id="u6dce944b">}</p> 
<p id="u1ee9ce9e">catch (std::ifstream::failure e)</p> 
<p id="uf466882e">{<!-- --></p> 
<p id="u43b1d9ea">std::cout &lt;&lt; "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ" &lt;&lt; std::endl;</p> 
<p id="u90cf62b8">}</p> 
<p id="u8339619f">const char* vShaderCode = vertexCode.c_str();</p> 
<p id="ubf905126">const char* fShaderCode = fragmentCode.c_str();</p> 
<p id="ua1a8c46c"></p> 
<p id="u8932a04f">// 2. 编译着色器</p> 
<p id="uadcf172f">unsigned int vertex, fragment;</p> 
<p id="u7a7cd9dd">int success;</p> 
<p id="ubeba0910">char infoLog[512];</p> 
<p id="ue2d3a3ef">// 顶点着色器</p> 
<p id="u97c97315">vertex = glCreateShader(GL_VERTEX_SHADER);</p> 
<p id="ucf8a2470">glShaderSource(vertex, 1, &amp;vShaderCode, NULL);</p> 
<p id="u5c1df68a">glCompileShader(vertex);</p> 
<p id="u5f7cdfc8">// 打印编译错误（如果有的话）</p> 
<p id="u7b0fdd15">glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success);</p> 
<p id="ud15d3add">if (!success)</p> 
<p id="u04f33856">{<!-- --></p> 
<p id="ubfd0943c">glGetShaderInfoLog(vertex, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::vertex::COMPILATION_FAILEDn" &lt;&lt; infoLog &lt;&lt; std::endl;</p> 
<p id="u505a8efd">};</p> 
<p id="uc38d8f35">// 片段着色器</p> 
<p id="u95b6f68b">fragment = glCreateShader(GL_FRAGMENT_SHADER);</p> 
<p id="uaf9e41c4">glShaderSource(fragment, 1, &amp;fShaderCode, NULL);</p> 
<p id="ucffa31c4">glCompileShader(fragment);</p> 
<p id="uef3da69d">// 打印编译错误（如果有的话）</p> 
<p id="u59ab3134">glGetShaderiv(fragment, GL_COMPILE_STATUS, &amp;success);</p> 
<p id="uf0870e73">if (!success)</p> 
<p id="uabae0d85">{<!-- --></p> 
<p id="uace1f926">glGetShaderInfoLog(fragment, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::fragment::COMPILATION_FAILEDn" &lt;&lt; infoLog &lt;&lt; std::endl;</p> 
<p id="ueec38bff">};</p> 
<p id="u084d8546">//几何着色器</p> 
<p id="u070b82b6">unsigned int geometry;</p> 
<p id="u4d7c8d82">if (geometryPath != nullptr)</p> 
<p id="u25da7482">{<!-- --></p> 
<p id="u901f3067">const char* gShaderCode = geometryCode.c_str();</p> 
<p id="uaf0402f3">geometry = glCreateShader(GL_GEOMETRY_SHADER);</p> 
<p id="u2a06dcfc">glShaderSource(geometry, 1, &amp;gShaderCode, NULL);</p> 
<p id="ubbe726f0">glCompileShader(geometry);</p> 
<p id="u327efdcb">glGetShaderiv(geometry, GL_COMPILE_STATUS, &amp;success);</p> 
<p id="u031795ec">if (!success)</p> 
<p id="u1b235243">{<!-- --></p> 
<p id="ud961622f">glGetShaderInfoLog(geometry, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::fragment::COMPILATION_FAILEDn" &lt;&lt; infoLog &lt;&lt; std::endl;</p> 
<p id="u4fcdb0f0">};</p> 
<p id="u53c7b1f3">}</p> 
<p id="uffd32fb6"></p> 
<p id="ud5de0b56">// 着色器程序</p> 
<p id="u22730e2e">ID = glCreateProgram();</p> 
<p id="u499afd64">glAttachShader(ID, vertex);</p> 
<p id="u1725748f">glAttachShader(ID, fragment);</p> 
<p id="u8e313a69">if (geometryPath != nullptr)</p> 
<p id="uec092728">glAttachShader(ID, geometry);</p> 
<p id="u704d1bae">glLinkProgram(ID);</p> 
<p id="uc2615907">// 打印连接错误（如果有的话）</p> 
<p id="u3f53db8c">glGetProgramiv(ID, GL_LINK_STATUS, &amp;success);</p> 
<p id="uc2e473e2">if(!success)</p> 
<p id="u7417d4ae">{<!-- --></p> 
<p id="ud16ce6c2">glGetProgramInfoLog(ID, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILEDn" &lt;&lt; infoLog &lt;&lt; std::endl;</p> 
<p id="u789ee28e">}</p> 
<p id="u269ea4d3">// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了</p> 
<p id="ubee6d3e3">glDeleteShader(vertex);</p> 
<p id="ubc1d3032">glDeleteShader(fragment);</p> 
<p id="u86823b80">if (geometryPath != nullptr)</p> 
<p id="ud7239ccc">glDeleteShader(geometry);</p> 
<p id="ud5cacd5e">}</p> 
<p id="u641762b7"></p> 
<p id="ub3d9c0ba">Shader::~Shader()</p> 
<p id="u4219e352">{<!-- --></p> 
<p id="u3317e3dd">glDeleteProgram(ID);</p> 
<p id="u512ade82">}</p> 
<p id="uba749a71"></p> 
<p id="u0451ab9a">void Shader::use()</p> 
<p id="ud9462e02">{<!-- --></p> 
<p id="u835b90dc">glUseProgram(ID);</p> 
<p id="ubf3dbcb0">}</p> 
<p id="u1d95b434"></p> 
<p id="u426862f3">void Shader::setBool(const std::string&amp; name, bool value) const</p> 
<p id="u3eab91c8">{<!-- --></p> 
<p id="u20924aac">glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);</p> 
<p id="udadfbcbe">}</p> 
<p id="uf7f7d965"></p> 
<p id="u5b803324">void Shader::setInt(const std::string&amp; name, int value) const</p> 
<p id="u6af3779f">{<!-- --></p> 
<p id="ua64f7db1">glUniform1i(glGetUniformLocation(ID, name.c_str()), value);</p> 
<p id="u94666533">}</p> 
<p id="u2d0000af"></p> 
<p id="u9e7ff84c">void Shader::setFloat(const std::string&amp; name, float value) const</p> 
<p id="u127bc02e">{<!-- --></p> 
<p id="ua76e39ad">glUniform1f(glGetUniformLocation(ID, name.c_str()), value);</p> 
<p id="u52655702">}</p> 
<p id="u2f5be197"></p> 
<p id="ub2ae1398">// ------------------------------------------------------------------------</p> 
<p id="u486f13d4">void Shader::setVec2(const std::string&amp; name, const glm::vec2&amp; value) const</p> 
<p id="u864b91f2">{<!-- --></p> 
<p id="u4cee725b">glUniform2fv(glGetUniformLocation(ID, name.c_str()), 1, &amp;value[0]);</p> 
<p id="u6de81ee3">}</p> 
<p id="u4eee3e76">void Shader::setVec2(const std::string&amp; name, float x, float y) const</p> 
<p id="u322f99e7">{<!-- --></p> 
<p id="ua4e7aec4">glUniform2f(glGetUniformLocation(ID, name.c_str()), x, y);</p> 
<p id="u53543895">}</p> 
<p id="u8abe4d56">// ------------------------------------------------------------------------</p> 
<p id="ua4770cdb">void Shader::setVec3(const std::string&amp; name, const glm::vec3&amp; value) const</p> 
<p id="uf00ee504">{<!-- --></p> 
<p id="ub97183d8">glUniform3fv(glGetUniformLocation(ID, name.c_str()), 1, &amp;value[0]);</p> 
<p id="u3dacae5c">}</p> 
<p id="ub58c340a">void Shader::setVec3(const std::string&amp; name, float x, float y, float z) const</p> 
<p id="u5d6ff536">{<!-- --></p> 
<p id="u197d46ce">glUniform3f(glGetUniformLocation(ID, name.c_str()), x, y, z);</p> 
<p id="ue607dcc4">}</p> 
<p id="ufa258f6f">// ------------------------------------------------------------------------</p> 
<p id="u481e41a3">void Shader::setVec4(const std::string&amp; name, const glm::vec4&amp; value) const</p> 
<p id="u86bd88c5">{<!-- --></p> 
<p id="u539e45f8">glUniform4fv(glGetUniformLocation(ID, name.c_str()), 1, &amp;value[0]);</p> 
<p id="u705ea9b6">}</p> 
<p id="ud46ee06d">void Shader::setVec4(const std::string&amp; name, float x, float y, float z, float w) const</p> 
<p id="ub7719a0a">{<!-- --></p> 
<p id="u9a092961">glUniform4f(glGetUniformLocation(ID, name.c_str()), x, y, z, w);</p> 
<p id="u600f126c">}</p> 
<p id="u68de5aaa">// ------------------------------------------------------------------------</p> 
<p id="u97600ed3">void Shader::setMat2(const std::string&amp; name, const glm::mat2&amp; mat) const</p> 
<p id="u1a2030cf">{<!-- --></p> 
<p id="u55d4a0e6">glUniformMatrix2fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]);</p> 
<p id="u014d1881">}</p> 
<p id="u4b16246d">// ------------------------------------------------------------------------</p> 
<p id="u092878d7">void Shader::setMat3(const std::string&amp; name, const glm::mat3&amp; mat) const</p> 
<p id="ue69aa7fd">{<!-- --></p> 
<p id="u4675032c">glUniformMatrix3fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]);</p> 
<p id="u920375e0">}</p> 
<p id="u4ae7be22">// ------------------------------------------------------------------------</p> 
<p id="u833e271f">void Shader::setMat4(const std::string&amp; name, const glm::mat4&amp; mat) const</p> 
<p id="u5ef9ff1e">{<!-- --></p> 
<p id="u4414e766">glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]);</p> 
<p id="ua3156661">}</p> 
<p id="u499fa0d7"></p> 
<p id="ud2ed0145">#pragma once</p> 
<p id="u168ff3fc">#include"header.h"</p> 
<p id="u3324b7d6">#include"Shader.h"</p> 
<p id="u45675112">#include"Camera.h"</p> 
<p id="u7dc3c27c">#include &lt;iostream&gt;</p> 
<p id="u62359b2a">using namespace std;</p> 
<p id="u71688de5">const unsigned int SCR_WIDTH = 1920;</p> 
<p id="ub0b9dac7">const unsigned int SCR_HEIGHT = 1080;</p> 
<p id="u08e8533d"></p> 
<p id="u738f8884"></p> 
<p id="ubbaf46c5"></p> 
<p id="u1792f1ba">void framebuffer_size_callback(GLFWwindow* window, int width, int height);</p> 
<p id="u85b2be23">void processInput(GLFWwindow* window);</p> 
<p id="ued5529a1">void mouse_callback(GLFWwindow* window, double xposIn, double yposIn);</p> 
<p id="udc7d8af6">void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);</p> 
<p id="u3ba1be7a"></p> 
<p id="u4bd24ffb"></p> 
<p id="u65c2134f">Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));</p> 
<p id="u296d1f80">float lastX = SCR_WIDTH / 2.0f;</p> 
<p id="u179e5bd5">float lastY = SCR_HEIGHT / 2.0f;</p> 
<p id="u5eb48b83"></p> 
<p id="u5c62886f">bool firstMouse = true;</p> 
<p id="u9986e3f4"></p> 
<p id="ue30f546a">// timing</p> 
<p id="u8035cbbb">float deltaTime = 0.0f; // time between current frame and last frame</p> 
<p id="u9335e89c">float lastFrame = 0.0f;</p> 
<p id="u5d90e5f5"></p> 
<p id="uf4943ba3">int main()</p> 
<p id="u6c94fa16">{<!-- --></p> 
<p id="u59d09c3d">glfwInit();</p> 
<p id="ufa502b25">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);</p> 
<p id="uf9a0bd7d">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);</p> 
<p id="u33acab9d">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</p> 
<p id="u5d73508d">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);//mac下使用</p> 
<p id="u8bd9f472">GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL);</p> 
<p id="u21330cf1">if (window == NULL)</p> 
<p id="u820aa7b3">{<!-- --></p> 
<p id="ufc4e90f7">cout &lt;&lt; " Failed to create GLFW window" &lt;&lt; endl;</p> 
<p id="u3a922717">glfwTerminate();</p> 
<p id="u3c91f896">return -1;</p> 
<p id="uea6bcdcc">}</p> 
<p id="ue9a8b214">glfwMakeContextCurrent(window);</p> 
<p id="u6d15b6d5">glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</p> 
<p id="u9e002fa6">glfwSetCursorPosCallback(window, mouse_callback);</p> 
<p id="u53f084f3">glfwSetScrollCallback(window, scroll_callback);</p> 
<p id="u7858b606"></p> 
<p id="uf4a03997">if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</p> 
<p id="u05402ced">{<!-- --></p> 
<p id="uc69d9747">std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;</p> 
<p id="u711efb5b">return -1;</p> 
<p id="uef760c7a">}</p> 
<p id="u13eceb7d">glViewport(0, 0, 1920, 1080);</p> 
<p id="u8a84dbb5"></p> 
<p id="u3d540a7a"></p> 
<p id="uc340e14f">glEnable(GL_DEPTH_TEST);</p> 
<p id="udd090739"></p> 
<p id="ub0a7ea79">Shader ourShader("D:\LearnOpenGL\OpenGLProject\Learning1\Shader\Vertex.txt", "D:\LearnOpenGL\OpenGLProject\Learning1\Shader\Fragment.txt");</p> 
<p id="uc0affe56"></p> 
<p id="u17b026e6">float vertices[] = {<!-- --></p> 
<p id="u2b1397c8">-0.5f, -0.5f, -0.5f, 0.0f, 0.0f,</p> 
<p id="ub7233239">0.5f, -0.5f, -0.5f, 1.0f, 0.0f,</p> 
<p id="uba646cb0">0.5f, 0.5f, -0.5f, 1.0f, 1.0f,</p> 
<p id="u54872b42">0.5f, 0.5f, -0.5f, 1.0f, 1.0f,</p> 
<p id="u568dd09e">-0.5f, 0.5f, -0.5f, 0.0f, 1.0f,</p> 
<p id="uac063473">-0.5f, -0.5f, -0.5f, 0.0f, 0.0f,</p> 
<p id="u7b0b0a44"></p> 
<p id="u4d96b1ed">-0.5f, -0.5f, 0.5f, 0.0f, 0.0f,</p> 
<p id="ufeff2560">0.5f, -0.5f, 0.5f, 1.0f, 0.0f,</p> 
<p id="u3c1dd455">0.5f, 0.5f, 0.5f, 1.0f, 1.0f,</p> 
<p id="u1963b28e">0.5f, 0.5f, 0.5f, 1.0f, 1.0f,</p> 
<p id="u51572e08">-0.5f, 0.5f, 0.5f, 0.0f, 1.0f,</p> 
<p id="u3cefd708">-0.5f, -0.5f, 0.5f, 0.0f, 0.0f,</p> 
<p id="u93c9b9e0"></p> 
<p id="uee1e24ff">-0.5f, 0.5f, 0.5f, 1.0f, 0.0f,</p> 
<p id="u6ab169e4">-0.5f, 0.5f, -0.5f, 1.0f, 1.0f,</p> 
<p id="u9104910e">-0.5f, -0.5f, -0.5f, 0.0f, 1.0f,</p> 
<p id="u1583df3c">-0.5f, -0.5f, -0.5f, 0.0f, 1.0f,</p> 
<p id="uddbfe7a3">-0.5f, -0.5f, 0.5f, 0.0f, 0.0f,</p> 
<p id="u2fc99803">-0.5f, 0.5f, 0.5f, 1.0f, 0.0f,</p> 
<p id="uf5c9ef3e"></p> 
<p id="ua376ea4b">0.5f, 0.5f, 0.5f, 1.0f, 0.0f,</p> 
<p id="uebb01a37">0.5f, 0.5f, -0.5f, 1.0f, 1.0f,</p> 
<p id="u5299f3f9">0.5f, -0.5f, -0.5f, 0.0f, 1.0f,</p> 
<p id="u44837dea">0.5f, -0.5f, -0.5f, 0.0f, 1.0f,</p> 
<p id="u7cadae6c">0.5f, -0.5f, 0.5f, 0.0f, 0.0f,</p> 
<p id="u507610b5">0.5f, 0.5f, 0.5f, 1.0f, 0.0f,</p> 
<p id="u9ca7b480"></p> 
<p id="u1a858016">-0.5f, -0.5f, -0.5f, 0.0f, 1.0f,</p> 
<p id="u5bf8a3b6">0.5f, -0.5f, -0.5f, 1.0f, 1.0f,</p> 
<p id="uac7e151a">0.5f, -0.5f, 0.5f, 1.0f, 0.0f,</p> 
<p id="u55bd9a6a">0.5f, -0.5f, 0.5f, 1.0f, 0.0f,</p> 
<p id="u6ad9e151">-0.5f, -0.5f, 0.5f, 0.0f, 0.0f,</p> 
<p id="u35f3fb0c">-0.5f, -0.5f, -0.5f, 0.0f, 1.0f,</p> 
<p id="u224f54b6"></p> 
<p id="ub41f608e">-0.5f, 0.5f, -0.5f, 0.0f, 1.0f,</p> 
<p id="u4460de53">0.5f, 0.5f, -0.5f, 1.0f, 1.0f,</p> 
<p id="ucd2170c0">0.5f, 0.5f, 0.5f, 1.0f, 0.0f,</p> 
<p id="u20eda66e">0.5f, 0.5f, 0.5f, 1.0f, 0.0f,</p> 
<p id="u42f6ed41">-0.5f, 0.5f, 0.5f, 0.0f, 0.0f,</p> 
<p id="u050442f4">-0.5f, 0.5f, -0.5f, 0.0f, 1.0f</p> 
<p id="u934d04cd">};</p> 
<p id="u2a4c6e3b"></p> 
<p id="u4a042148">unsigned int indices[] = {<!-- --></p> 
<p id="u03cbc297">0, 1, 3, // first triangle</p> 
<p id="u86ca4865">1, 2, 3 // second triangle</p> 
<p id="u79a0324d">};</p> 
<p id="ue67d4a4e">glm::vec3 cubePositions[] = {<!-- --></p> 
<p id="u6c861dc1">glm::vec3(0.0f, 0.0f, 0.0f),</p> 
<p id="u3f34409c">glm::vec3(2.0f, 5.0f, -15.0f),</p> 
<p id="u8c098555">glm::vec3(-1.5f, -2.2f, -2.5f),</p> 
<p id="uc83f0e16">glm::vec3(-3.8f, -2.0f, -12.3f),</p> 
<p id="u191f3a78">glm::vec3(2.4f, -0.4f, -3.5f),</p> 
<p id="ub1a590e6">glm::vec3(-1.7f, 3.0f, -7.5f),</p> 
<p id="u4fab4109">glm::vec3(1.3f, -2.0f, -2.5f),</p> 
<p id="u132bd836">glm::vec3(1.5f, 2.0f, -2.5f),</p> 
<p id="u5d5e2564">glm::vec3(1.5f, 0.2f, -1.5f),</p> 
<p id="u3adba424">glm::vec3(-1.3f, 1.0f, -1.5f)</p> 
<p id="u0ce8b553">};</p> 
<p id="u401ea804"></p> 
<p id="uae95553a">unsigned int VBO, EBO;</p> 
<p id="u18e9fcca">unsigned int VAO;</p> 
<p id="u40d98b58">glGenVertexArrays(1, &amp;VAO);</p> 
<p id="u4c100164">glBindVertexArray(VAO);</p> 
<p id="u8b2487db"></p> 
<p id="u45e91701">glGenBuffers(1, &amp;VBO);</p> 
<p id="u351b9592">glBindBuffer(GL_ARRAY_BUFFER, VBO);</p> 
<p id="u5ca1c042">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</p> 
<p id="ue29bb88f"></p> 
<p id="u8f0527bb"></p> 
<p id="u462683a6"></p> 
<p id="u8091db98"></p> 
<p id="ud2b90f68">//glGenBuffers(1, &amp;EBO);</p> 
<p id="u708ceefd">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</p> 
<p id="u45385a92">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</p> 
<p id="u9d1e6979"></p> 
<p id="u947846da">// 位置属性</p> 
<p id="u2e75b2a2">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);</p> 
<p id="u7c2ea1f1">glEnableVertexAttribArray(0);</p> 
<p id="u5f35272a"> 颜色属性</p> 
<p id="ucd9c10ae">//glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));</p> 
<p id="u4e3a34d1">//glEnableVertexAttribArray(1);</p> 
<p id="u8a5a0497">// texture coord attribute</p> 
<p id="ue2d92b65">glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));</p> 
<p id="ue45619f5">glEnableVertexAttribArray(1);</p> 
<p id="u07e367d0"></p> 
<p id="u9032bf99">glBindBuffer(GL_ARRAY_BUFFER, 0);</p> 
<p id="u009c15d8">glBindVertexArray(0);</p> 
<p id="u7a502075"></p> 
<p id="u5f1a3a9e">//生成纹理</p> 
<p id="ucec2c39d">unsigned int texture;</p> 
<p id="u04293ad2">glGenTextures(1, &amp;texture);</p> 
<p id="u0d00bf73">glBindTexture(GL_TEXTURE_2D, texture);</p> 
<p id="u44bd2cfe">// 为当前绑定的纹理对象设置环绕、过滤方式</p> 
<p id="u33b969cb">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</p> 
<p id="u209d3825">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</p> 
<p id="u402e12b6">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</p> 
<p id="uc819aa7f">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</p> 
<p id="ud6525288">// 加载并生成纹理</p> 
<p id="uf502088c">int width, height, nrChannels;</p> 
<p id="u395d9b71">unsigned char* data = stbi_load("D:\LearnOpenGL\Texture\wall.jpg", &amp;width, &amp;height, &amp;nrChannels, 0);</p> 
<p id="u65777601">if (data)</p> 
<p id="u987155dd">{<!-- --></p> 
<p id="udb13f0a1">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);</p> 
<p id="u60d14774">glGenerateMipmap(GL_TEXTURE_2D);</p> 
<p id="ube1c5bc4">}</p> 
<p id="udd6238d2">else</p> 
<p id="ufb47ebda">{<!-- --></p> 
<p id="u45e51a6f">std::cout &lt;&lt; "Failed to load texture" &lt;&lt; std::endl;</p> 
<p id="ub696206e">}</p> 
<p id="ua77fdfc3">stbi_image_free(data);</p> 
<p id="uc7e66cbf"></p> 
<p id="u2e315332">unsigned int texture2;</p> 
<p id="u43e5cffa">glGenTextures(1, &amp;texture2);</p> 
<p id="u933d42f6">glBindTexture(GL_TEXTURE_2D, texture2);</p> 
<p id="u4bd226f2">// 为当前绑定的纹理对象设置环绕、过滤方式</p> 
<p id="ufb7ff503">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</p> 
<p id="u6079723f">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</p> 
<p id="ue5de960c">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</p> 
<p id="ue14c3932">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</p> 
<p id="ud03c0cda">data = stbi_load("D:\LearnOpenGL\Texture\ganyu.jpg", &amp;width, &amp;height, &amp;nrChannels, 0);</p> 
<p id="uf18f6625">if (data)</p> 
<p id="ubebb3730">{<!-- --></p> 
<p id="u549ef45a">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);</p> 
<p id="u0f9cfc93">glGenerateMipmap(GL_TEXTURE_2D);</p> 
<p id="u4b055c7a">}</p> 
<p id="u8236b570">else</p> 
<p id="ub9bce0a2">{<!-- --></p> 
<p id="u6c609920">std::cout &lt;&lt; "Failed to load texture" &lt;&lt; std::endl;</p> 
<p id="u8164ff38">}</p> 
<p id="u1c8604e6">stbi_image_free(data);</p> 
<p id="ufb52e14d"></p> 
<p id="u4e630e0b">ourShader.use();</p> 
<p id="u61516d37">ourShader.setInt("texture1", 0);</p> 
<p id="uafb9baa7">ourShader.setInt("texture2", 1);</p> 
<p id="uc01ddfcf"></p> 
<p id="u5b04bbb1">float timeValue = 0;</p> 
<p id="uc5d92803">int UniformHandle1;</p> 
<p id="uf8abae9b">int UniformHandle2;</p> 
<p id="u03c65afe">// 渲染循环</p> 
<p id="u8adfccaf">while (!glfwWindowShouldClose(window))</p> 
<p id="ufba8b9b0">{<!-- --></p> 
<p id="u04accad6">float currentFrame = static_cast&lt;float&gt;(glfwGetTime());</p> 
<p id="u7e3d7490">deltaTime = currentFrame - lastFrame;</p> 
<p id="udbc9d263">lastFrame = currentFrame;</p> 
<p id="ud8dc3b23">// 输入</p> 
<p id="u1a947d79">processInput(window);</p> 
<p id="u7d17634a">// 渲染指令</p> 
<p id="u3b03ecc3">glClearColor(0.2f, 0.3f, 0.3f, 1.0f);</p> 
<p id="ub47350dd">glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);</p> 
<p id="ube77a508"></p> 
<p id="u1e964575">ourShader.use();</p> 
<p id="u0d9918bb"></p> 
<p id="u284fc5a7">ourShader.setFloat("offset2", abs(cos(glfwGetTime())));</p> 
<p id="ub7305337"></p> 
<p id="uc72b7de9">//glm::mat4 model = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first</p> 
<p id="u945b2fbe">glm::mat4 view = camera.GetViewMatrix();</p> 
<p id="ude9f75b2">//glm::mat4 view = glm::toMat4(camera.FrontQuaternion);</p> 
<p id="u502b9db5">glm::mat4 projection = glm::mat4(1.0f);</p> 
<p id="u7d76ce62">//model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(0.5f, 1.0f, 0.0f));</p> 
<p id="uf8adbb10">view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));</p> 
<p id="u7fdf7c4a">projection = glm::perspective(glm::radians(camera.Fov), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);</p> 
<p id="ua164146b"></p> 
<p id="ud2442270">//ourShader.setMat4("model", model);</p> 
<p id="uceae838e">ourShader.setMat4("view", view);</p> 
<p id="ue733ca69">ourShader.setMat4("projection", projection);</p> 
<p id="u0127a8ea"></p> 
<p id="u5aed9157">glActiveTexture(GL_TEXTURE0);</p> 
<p id="u71f4d91f">glBindTexture(GL_TEXTURE_2D, texture);</p> 
<p id="u6c19500a">glActiveTexture(GL_TEXTURE1);</p> 
<p id="ud31bfc27">glBindTexture(GL_TEXTURE_2D, texture2);</p> 
<p id="u41fc1471"></p> 
<p id="ub8a5ae0c">glBindVertexArray(VAO);</p> 
<p id="u905d401f">for (unsigned int i = 0; i &lt; 10; i++)</p> 
<p id="ucc7343d5">{<!-- --></p> 
<p id="ucd3c8dbb">// calculate the model matrix for each object and pass it to shader before drawing</p> 
<p id="ud7907c0c">glm::mat4 model = glm::mat4(1.0f);</p> 
<p id="u74a7da95">model = glm::translate(model, cubePositions[i]);</p> 
<p id="uf38a55f1">float angle = 20.0f * (i+1);</p> 
<p id="u3f4a6108">model = glm::rotate(model, glm::radians(angle*(float)glfwGetTime()), glm::vec3(1.0f, 0.3f, 0.5f));</p> 
<p id="u4b141838">ourShader.setMat4("model", model);</p> 
<p id="u238772e4"></p> 
<p id="u047171fb">glDrawArrays(GL_TRIANGLES, 0, 36);</p> 
<p id="u399e8638">}</p> 
<p id="ua5e38ba5"></p> 
<p id="u79224b13"></p> 
<p id="u416f7b21">// 检查并调用事件，交换缓冲</p> 
<p id="ucfd005f0">glfwSwapBuffers(window);</p> 
<p id="uf46338c3">glfwPollEvents();</p> 
<p id="uf23f3d64">}</p> 
<p id="u59417f99"></p> 
<p id="ud2e43909">glDeleteBuffers(1, &amp;VBO);</p> 
<p id="uf5c58755">glDeleteVertexArrays(1, &amp;VAO);</p> 
<p id="u391b3fea">//glDeleteBuffers(1, &amp;EBO);</p> 
<p id="u13e5e609"></p> 
<p id="u41b171cd">glfwTerminate();</p> 
<p id="u80a4ce10">return 0;</p> 
<p id="uc1988a18">}</p> 
<p id="u31755306"></p> 
<p id="u78998275">void framebuffer_size_callback(GLFWwindow* window, int width, int height)</p> 
<p id="u0efa8917">{<!-- --></p> 
<p id="u89b9426d">glViewport(0, 0, width, height);</p> 
<p id="u122d8aaf">}</p> 
<p id="ud56d4251"></p> 
<p id="u8f6307c5">void processInput(GLFWwindow* window)</p> 
<p id="u554253e6">{<!-- --></p> 
<p id="uf9568260">if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</p> 
<p id="ue9a18852">glfwSetWindowShouldClose(window, true);</p> 
<p id="udf8b72d3"></p> 
<p id="u7102c552">if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)</p> 
<p id="u01f39081">camera.ProcessKeyboard(Camera_Movement::FORWARD, deltaTime);</p> 
<p id="u9f3d6e90">if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)</p> 
<p id="u11403cef">camera.ProcessKeyboard(Camera_Movement::BACKWARD, deltaTime);</p> 
<p id="ubaedc077">if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)</p> 
<p id="uce896a92">camera.ProcessKeyboard(Camera_Movement::LEFT, deltaTime);</p> 
<p id="ue0107416">if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)</p> 
<p id="u120d62cc">camera.ProcessKeyboard(Camera_Movement::RIGHT, deltaTime);</p> 
<p id="u013bddfd">}</p> 
<p id="u25407452"></p> 
<p id="u481909fc">void mouse_callback(GLFWwindow* window, double xposIn, double yposIn)</p> 
<p id="ucd637dc1">{<!-- --></p> 
<p id="u0431096e">if (glfwGetMouseButton(window, 0))</p> 
<p id="u963e8546">{<!-- --></p> 
<p id="ua1e7e786">float xpos = static_cast&lt;float&gt;(xposIn);</p> 
<p id="u53c83a0c">float ypos = static_cast&lt;float&gt;(yposIn);</p> 
<p id="u9cd2aedb"></p> 
<p id="u136fba80">if (firstMouse)</p> 
<p id="u905b2a1e">{<!-- --></p> 
<p id="ude1d3648">lastX = xpos;</p> 
<p id="u3d2f2dec">lastY = ypos;</p> 
<p id="u1e432c5e">firstMouse = false;</p> 
<p id="uc58328fd">}</p> 
<p id="u2a63d108"></p> 
<p id="ubb94092e">float xoffset = lastX - xpos;</p> 
<p id="u63264759">float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top</p> 
<p id="uc8215099"></p> 
<p id="u6e7272bc">lastX = xpos;</p> 
<p id="uac682c19">lastY = ypos;</p> 
<p id="u876b9292"></p> 
<p id="u48b30224">// camera.updateCameraVectorsByQuat1(-xoffset, -yoffset);</p> 
<p id="u5fc50257">camera.updateCameraVectorsByQuat2(-xoffset, yoffset);</p> 
<p id="uc62edee2">}</p> 
<p id="ud59a9391">else</p> 
<p id="ua50240f0">{<!-- --></p> 
<p id="u0de3764b">lastX = SCR_WIDTH / 2.0f;</p> 
<p id="ud1bde942">lastY = SCR_HEIGHT / 2.0f;</p> 
<p id="u1f8795cf"></p> 
<p id="u3c8aafd7">}</p> 
<p id="ub2c539b7">}</p> 
<p id="u917dc25d"></p> 
<p id="u7933217d">void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)</p> 
<p id="u80bae8af">{<!-- --></p> 
<p id="u723c0a8d">camera.ProcessMouseScroll(static_cast&lt;float&gt;(yoffset));</p> 
<p id="ubba9a90d">}</p> 
<p id="ud286b78c"></p> 
<p id="u6dd552ba"></p> 
<h1 id="R6CtG">学习资料：</h1> 
<p id="u71b2dc72">1.<a href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/#_6" title="摄像机 - LearnOpenGL CN">摄像机 - LearnOpenGL CN</a></p> 
<p id="uff0c3212">2.<a href="https://github.com/cybercser/OpenGL_3_3_Tutorial_Translation/blob/master/Tutorial%2017%20Rotations.md" title="https://github.com/cybercser/OpenGL_3_3_Tutorial_Translation/blob/master/Tutorial%2017%20Rotations.md">https://github.com/cybercser/OpenGL_3_3_Tutorial_Translation/blob/master/Tutorial%2017%20Rotations.md</a></p> 
<p></p> 
<p></p> 
<p>---------------------------------------------------------博主：mx</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>