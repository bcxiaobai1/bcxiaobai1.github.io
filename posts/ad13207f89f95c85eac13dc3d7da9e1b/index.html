<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Java的多线程安全问题--API文档深入研究3.0 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java的多线程安全问题--API文档深入研究3.0</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="Thread-toc" style="margin-left:0px"><a href="#Thread">Thread</a></p> 
<p id="%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A8%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98-toc" style="margin-left:40px"><a href="#%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A8%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98">改进后的电影院售票出现问题</a></p> 
<p id="Thread(Runnable%20target%2C%20String%20name)-toc" style="margin-left:80px"><a href="#Thread%28Runnable%20target%2C%20String%20name%29">Thread(Runnable target, String name)</a></p> 
<p id="%E6%94%B9%E8%BF%9B%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A81-toc" style="margin-left:80px"><a href="#%E6%94%B9%E8%BF%9B%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A81">改进电影院售票1</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:40px"><a href="#%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">解决线程安全问题的基本思想</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95-toc" style="margin-left:40px"><a href="#%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95">解决线程同步安全问题的第一种方法</a></p> 
<p id="%E6%94%B9%E8%BF%9B%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A82-toc" style="margin-left:80px"><a href="#%E6%94%B9%E8%BF%9B%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A82">改进电影院售票2</a></p> 
<p id="-toc" style="margin-left:40px"></p> 
<p id="%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%8A%A0Lock%E9%94%81-toc" style="margin-left:40px"><a href="#%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%8A%A0Lock%E9%94%81">解决线程同步安全问题的第二种解法：加Lock锁</a></p> 
<p id="Class%20ReentrantLock-toc" style="margin-left:80px"><a href="#Class%20ReentrantLock">Class ReentrantLock</a></p> 
<p id="void%20lock()%20%E5%8A%A0%E9%94%81-toc" style="margin-left:80px"><a href="#void%20lock%28%29%20%E5%8A%A0%E9%94%81">void lock() 加锁</a></p> 
<p id="void%20unlock()%20%E9%87%8A%E6%94%BE%E9%94%81-toc" style="margin-left:80px"><a href="#void%20unlock%28%29%20%E9%87%8A%E6%94%BE%E9%94%81">void unlock() 释放锁</a></p> 
<p id="%E6%94%B9%E8%BF%9B%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A83-toc" style="margin-left:80px"><a href="#%E6%94%B9%E8%BF%9B%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A83">改进电影院售票3</a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%A1%88%E4%BE%8B%EF%BC%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%89-toc" style="margin-left:80px"><a href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%A1%88%E4%BE%8B%EF%BC%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%89">线程同步案例：共享数据案例（线程通信）</a></p> 
<p id="%E6%AD%BB%E9%94%81-toc" style="margin-left:40px"><a href="#%E6%AD%BB%E9%94%81">死锁</a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E7%BB%84-toc" style="margin-left:40px"><a href="#%E7%BA%BF%E7%A8%8B%E7%BB%84">线程组</a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E6%B1%A0Executors-toc" style="margin-left:40px"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0Executors">线程池Executors</a></p> 
<p id="newFixedThreadPool-toc" style="margin-left:80px"><a href="#newFixedThreadPool">newFixedThreadPool</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px"><a href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">创建线程的第三种方式</a></p> 
<p id="callable-toc" style="margin-left:80px"><a href="#callable">callable</a></p> 
<p id="%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px"><a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B">匿名内部类方式使用多线程</a></p> 
<p id="%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:40px"><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8">定时器</a></p> 
<p id="Timer-toc" style="margin-left:80px"><a href="#Timer">Timer</a></p> 
<hr id="hr-toc">
<h1 id="Thread">Thread</h1> 
<h2 id="%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A8%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98">改进后的电影院售票出现问题</h2> 
<blockquote> 
 <ul><li><strong>问题</strong></li></ul>
 <p><strong>相同的票出现多次</strong><br>   CPU的一次操作必须是原子性的<br><strong>还出现了负数的票</strong><br>    随机性和延迟导致的</p> 
 <ul><li><strong>注意</strong></li></ul>
 <p><strong>线程安全问题在理想状态下，不容易出现，但一旦出现对软件的影响是非常大的。</strong></p> 
</blockquote> 
<h3 id="Thread(Runnable%20target%2C%20String%20name)">Thread(Runnable target, String name)</h3> 
<p>查看API文档我们知道：</p> 
<blockquote> 
 <pre>public Thread(<a href="../../java/lang/Runnable.html">Runnable</a> target,<a href="../../java/lang/String.html">String</a> name)</pre> 
 <p>分配一个新的<code>Thread</code>对象。 此构造具有相同的效果<a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">Thread</a> <code>(null, target, name)</code> 。</p> 
 <p>参数</p> 
 <p><code>target</code> - 启动此线程时调用其<code>run</code>方法的对象。 如果<code>null</code> ，则调用此线程的run方法。</p> 
 <p><code>name</code> - 新线程的名称</p> 
</blockquote> 
<h3 id="%E6%94%B9%E8%BF%9B%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A81">改进电影院售票1</h3> 
<p>创建TicketWindow1类：</p> 
<pre><code class="language-java">public class TicketWindow1 implements Runnable{
    //定义100张票
    private int tickets = 100;

    private Object obj = new Object();

    @Override
    public void run() {
        while (true){
            synchronized (obj){
                if (tickets &gt; 0){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票");
                }
            }
        }
            }

}
</code></pre> 
<p>创建SellTicketDemo1实现类：</p> 
<pre><code class="language-java">public class SellTicketDemo1 {
    public static void main(String[] args) {

        TicketWindow1 ticketWindow1 = new TicketWindow1();

        //创建线程对象模拟3个窗口，并给线程起名字
        Thread t1 = new Thread(ticketWindow1, "窗口1");
        Thread t2 = new Thread(ticketWindow1, "窗口2");
        Thread t3 = new Thread(ticketWindow1, "窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center"><img alt="" height="1044" src="https://images2.imgbox.com/7e/8b/2pOp8r9K_o.png" width="776"></p> 
<p>由于博主的CPU太过强大，多次尝试后这里没有出现预想的结果。</p> 
<hr>
<h2 id="%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">解决线程安全问题的基本思想</h2> 
<p><strong>首先想为什么出现问题？（也是我们判断是否有问题的标准）</strong></p> 
<ul>
<li>是否是多线程环境</li>
<li>是否有共享数据</li>
<li>是否有多条语句操作共享数据</li>
</ul>
<p><strong>如何解决多线程安全问题呢?</strong></p> 
<ul>
<li>基本思想：让程序没有安全问题的环境</li>
<li>怎么实现呢?</li>
</ul>
<p>         把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。</p> 
<p><strong> 同步代码块</strong></p> 
<blockquote> 
 <p><strong>格式：</strong><br>         synchronized(对象){<!-- --></p> 
 <p>             需要同步的代码;</p> 
 <p>        }<br> 同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。</p> 
</blockquote> 
<p><strong> 同步代码块的锁对象是谁呢？</strong></p> 
<pre>任意对象，但是多个线程之间锁对象要一样</pre> 
<p><strong>同步方法的锁对象是谁呢？</strong></p> 
<pre>将synchronized关键字放到方法上
同步方法的锁对象是this</pre> 
<pre><strong>静态方法的锁对象是谁呢？</strong>

class文件，字节码文件对象也是属于一个Object类下面的对象，这个class文件不能是随便一个类的字节码文件应该是run方法所在类的字节码文件</pre> 
<hr>
<h2 id="%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95">解决线程同步安全问题的第一种方法</h2> 
<h3 id="%E6%94%B9%E8%BF%9B%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A82">改进电影院售票2</h3> 
<p>创建TicketWindow2类：</p> 
<pre><code class="language-java">public class TicketWindow2 implements Runnable {
    //定义1000张票
    private static  int tickets = 1000;
    int i = 1;
    @Override
    public void run() {
        while (true){
            if (i%2==0){
                synchronized (TicketWindow2.class){
                    if (tickets &gt; 0){
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票");
                    }
                }
            }else {
                sellTicket();
            }
        }
    }

    private synchronized static void sellTicket() {
        if (tickets &gt; 0){
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票");

        }
    }
}</code></pre> 
<p> 创建SellTicketDemo2实现类：</p> 
<pre><code class="language-java">public class SellTicketDemo2 {
    public static void main(String[] args) {

        TicketWindow2 ticketWindow2 = new TicketWindow2();

        Thread t1 = new Thread(ticketWindow2, "窗口1");
        Thread t2 = new Thread(ticketWindow2, "窗口2");
        Thread t3 = new Thread(ticketWindow2, "窗口3");

        t1.start();
        t2.start();
        t3.start();

    }
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center"><img alt="" height="984" src="https://images2.imgbox.com/74/0c/b7pE1UVT_o.png" width="782"></p> 
<p>从运行结果上来看我们实现了线程的安全。</p> 
<h2></h2> 
<hr>
<h2 id="%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%8A%A0Lock%E9%94%81">解决线程同步安全问题的第二种解法：加Lock锁</h2> 
<h3 id="Class%20ReentrantLock">Class ReentrantLock</h3> 
<p>查看API文档我们知道：</p> 
<blockquote> 
 <pre>public class ReentrantLock
extends <a href="../../../../java/lang/Object.html">Object</a>
implements <a href="../../../../java/util/concurrent/locks/Lock.html">Lock</a>, <a href="../../../../java/io/Serializable.html">Serializable</a></pre> 
 <p>一个可重入互斥<a href="../../../../java/util/concurrent/locks/Lock.html"><code>Lock</code></a>具有与使用<code>synchronized</code>方法和语句访问的隐式监视锁相同的基本行为和语义，但具有扩展功能。</p> 
 <p>A <code>ReentrantLock</code>由线程<em>拥有</em> ，最后成功锁定，但尚未解锁。 调用<code>lock</code>的线程将返回，成功获取锁，当锁不是由另一个线程拥有。 如果当前线程已经拥有该锁，该方法将立即返回。 这可以使用方法<a href="../../../../java/util/concurrent/locks/ReentrantLock.html#isHeldByCurrentThread--"><code>isHeldByCurrentThread()</code></a>和<a href="../../../../java/util/concurrent/locks/ReentrantLock.html#getHoldCount--"><code>getHoldCount()</code></a>进行检查。</p> 
 <p>该类的构造函数接受可选的<em>公平</em>参数。 当设置<code>true</code> ，在争用下，锁有利于授予访问最长等待的线程。 否则，该锁不保证任何特定的访问顺序。 使用许多线程访问的公平锁的程序可能会比使用默认设置的整体吞吐量（即，更慢，通常要慢得多），但是具有更小的差异来获得锁定并保证缺乏饥饿。 但是请注意，锁的公平性不能保证线程调度的公平性。 因此，使用公平锁的许多线程之一可以连续获得多次，而其他活动线程不进行而不是当前持有锁。 另请注意， <a href="../../../../java/util/concurrent/locks/ReentrantLock.html#tryLock--">未定义的<code>tryLock()</code></a>方法不符合公平性设置。 如果锁可用，即使其他线程正在等待，它也会成功。</p> 
 <p>建议的做法是<em>始终</em>立即跟随<code>lock</code>与<code>try</code>块的通话，最常见的是在之前/之后的建设，如：</p> 
 <pre>  <code> class X { private final ReentrantLock lock = new ReentrantLock(); // ... public void m() { lock.lock(); // block until condition holds try { // ... method body } finally { lock.unlock() } } }</code> </pre> 
 <p>除了实现<a href="../../../../java/util/concurrent/locks/Lock.html"><code>Lock</code></a>接口，这个类定义了许多<code>public</code>种<code>protected</code>方法用于检查锁的状态。 其中一些方法仅适用于仪器和监控。</p> 
 <p>此类的序列化与内置锁的操作方式相同：反序列化锁处于未锁定状态，无论其序列化时的状态如何。</p> 
 <p>此锁最多支持同一个线程的2147483647递归锁。 尝试超过此限制会导致<a href="../../../../java/lang/Error.html"><code>Error</code></a>从锁定方法中抛出。</p> 
</blockquote> 
<h3 id="void%20lock()%20%E5%8A%A0%E9%94%81">void lock() 加锁</h3> 
<p>查看API文档我们知道：</p> 
<blockquote> 
 <pre>public void lock()</pre> 
 <p>获得锁。</p> 
 <p>如果锁没有被另一个线程占用并且立即返回，则将锁定计数设置为1。</p> 
 <p>如果当前线程已经保持锁定，则保持计数增加1，该方法立即返回。</p> 
 <p>如果锁被另一个线程保持，则当前线程将被禁用以进行线程调度，并且在锁定已被获取之前处于休眠状态，此时锁定保持计数被设置为1。</p> 
 <p>Specified by:</p> 
 <p><code><a href="../../../../java/util/concurrent/locks/Lock.html#lock--">lock</a></code>在界面 <code><a href="../../../../java/util/concurrent/locks/Lock.html">Lock</a></code></p> 
</blockquote> 
<h3 id="void%20unlock()%20%E9%87%8A%E6%94%BE%E9%94%81">void unlock() 释放锁</h3> 
<p>查看API文档我们知道：</p> 
<blockquote> 
 <pre>public void unlock()</pre> 
 <p>尝试释放此锁。</p> 
 <p>如果当前线程是该锁的持有者，则保持计数递减。 如果保持计数现在为零，则锁定被释放。 如果当前线程不是该锁的持有者，则抛出<a href="../../../../java/lang/IllegalMonitorStateException.html"><code>IllegalMonitorStateException</code></a> 。</p> 
 <p>Specified by:</p> 
 <p><code><a href="../../../../java/util/concurrent/locks/Lock.html#unlock--">unlock</a></code>在界面 <code><a href="../../../../java/util/concurrent/locks/Lock.html">Lock</a></code></p> 
 <p>异常</p> 
 <p><code><a href="../../../../java/lang/IllegalMonitorStateException.html">IllegalMonitorStateException</a></code> - 如果当前线程不持有此锁</p> 
</blockquote> 
<p> 在此之前我们解决线程同步安全问题的时候，使用的是synchronized关键字，通过分析然后将哪些代码块给包起来，但是我们并没有直接看到在哪里上了锁，或者说在哪里释放了锁让其它线程获取到，为了更加清晰的表达如何加锁以及如何释放锁，JDK1.5之后提供了一个新的锁对象Lock。</p> 
<h3 id="%E6%94%B9%E8%BF%9B%E7%94%B5%E5%BD%B1%E9%99%A2%E5%94%AE%E7%A5%A83">改进电影院售票3</h3> 
<p>创建TicketWindow3类：</p> 
<pre><code class="language-java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class TicketWindow3 implements Runnable {
    //定义100张票
    private int tickets = 100;
    
    //创建锁对象
    Lock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true){
            lock.lock();
            if (tickets &gt; 0){
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在售出第" + (tickets--) + "张票");
            }
            lock.unlock();

        }
    }
}
</code></pre> 
<p>创建SellTicketDemo3实现类：</p> 
<pre><code class="language-java">public class SellTicketDemo3 {
    public static void main(String[] args) {
        TicketWindow3 ticketWindow3 = new TicketWindow3();
        Thread t1 = new Thread(ticketWindow3, "窗口1");
        Thread t2 = new Thread(ticketWindow3, "窗口2");
        Thread t3 = new Thread(ticketWindow3, "窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center"><img alt="" height="1055" src="https://images2.imgbox.com/28/10/yrc7jwDC_o.png" width="924"></p> 
<hr>
<h3 id="%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%A1%88%E4%BE%8B%EF%BC%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%89">线程同步案例：共享数据案例（线程通信）</h3> 
<p>创建Student类：</p> 
<pre><code class="language-java">public class Student {
    String name;
    int age;
    boolean flag;
}</code></pre> 
<p> 创建自定义类GetThread：</p> 
<pre><code class="language-java">import java.util.concurrent.locks.Lock;

public class GetThread implements Runnable {
    private Student s;
    private Lock lock;


    public GetThread(Student student) {
        this.s = student;
    }

    public GetThread(Student student, Lock lock) {
        this.s = student;
        this.lock = lock;
    }

    @Override
    public void run() {
        while (true){
            synchronized (s){
                //判断学生对象有没有值
                //如果flag的值是false，说明没有数据，消费者进if判断等待
                if(!s.flag){
                    try {
                        s.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                System.out.println(s.name + "---" + s.age);

                //消费者消费完数据后通知生产者生产数据
                s.notify();
                s.flag = false;
            }
        }
    }


}
</code></pre> 
<p>创建自定义类SetThread类：</p> 
<pre><code class="language-java">import java.util.concurrent.locks.Lock;

public class SetThread implements Runnable{
    private Student s;
    private int i = 0;
    private Lock lock;


    public SetThread(Student student) {
        this.s = student;
    }

    public SetThread(Student student, Lock lock) {
        this.s = student;
        this.lock = lock;
    }

    @Override
    public void run() {
        while (true){
            synchronized (s){
                //判断学生对象有没有值
                //flag初始的时候是flase，表示没有值，如果是true表示学生对象有值
                //有值对于生产者来说，等待消费者消费
                if(s.flag){
                    try {
                        s.wait();  //调用wait()，线程阻塞
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                if(i%2==0){
                    s.name = "刘德华";
                    s.age = 65;
                }else {
                    s.name = "张学友";
                    s.age = 73;
                }
                i++;

                //生产者生产完数据之后通知消费者消费数据
                s.notify();
                s.flag = true;

            }

        }
    }
}
</code></pre> 
<p> 创建实现类：StudentDemo</p> 
<pre><code class="language-java">public class StudentDemo {
    public static void main(String[] args) {
        //创建共享的学生对象
        Student student = new Student();

        //创建自定义类对象
        SetThread setThread = new SetThread(student);
        GetThread getThread = new GetThread(student);

        //根据Runnable的对象创建生产者和消费者的线程对象
        Thread proThread = new Thread(setThread);
        Thread cusThread = new Thread(getThread);

        cusThread.start();
        proThread.start();
    }
}</code></pre> 
<p> 运行结果：</p> 
<p style="text-align:center"><img alt="" height="1118" src="https://images2.imgbox.com/e0/dd/TYQ0oKz7_o.png" width="1047"></p> 
<blockquote> 
 <p> 分析：</p> 
 <pre>    共享数据：Student
    生产者：SetThread 给学生的成员变量进行赋值操作
    消费者：GetThread 获取学生的成员变量的信息
    测试类：StudentDemo 创建线程并测试</pre> 
 <p>在写这个案例之前我们将会遇到一些问题可能是以下原因导致的</p> 
 <p>CPU一点点的时间片就足矣执行很多次</p> 
 <p>线程执行的时候具有随机性导致的</p> 
 <pre>注意事项：
    1、不同种类的线程类都要加锁
    2、不用种类的线程类中的锁对象要一样

问题3：虽然我们解决线程安全问题，但是经过分析，程序还存在着等待唤醒机制的问题。
    加入等待唤醒机制。

    如何添加等待唤醒机制呢？
        Object类中有三个方法：
            void wait() 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法。
            void notify() 唤醒正在等待对象监视器的单个线程。
            void notifyAll() 唤醒正在等待对象监视器的所有线程。
    这三个方法为什么不定义再Thread类中呢？
        这些方法想要调用，必须通过锁的对象调用，而我们直到同步代码块的锁对象可以是任意对象
        所以这些方法都在Object类中，因为java中所有类的父类都是Object</pre> 
</blockquote> 
<hr>
<p> 既然实现了线程的共享，那么如果出现了同步嵌套，就容易产生死锁问题</p> 
<h2 id="%E6%AD%BB%E9%94%81">死锁</h2> 
<p> 死锁是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象</p> 
<p>参考代码：</p> 
<p>创建DieLock类：</p> 
<pre><code class="language-java">public class DieLock extends Thread {
    private boolean flag;

    public DieLock(boolean flag){
        this.flag = flag;
    }

    /*  现象1：
            if lock1
            else lock2

        现象2：
            else lock2
            if lock1
     */
    @Override
    public void run() {
        if(flag){
            //d1
            synchronized (MyLock.lock1){
                System.out.println("if lock1");
                //d1
                synchronized (MyLock.lock2){
                    System.out.println("if lock2");
                }
            }
        }else {
            //d2
            synchronized (MyLock.lock2){
                System.out.println("else lock2");
                //d2
                synchronized (MyLock.lock1){
                    System.out.println("else lock1");
                }
            }
        }

    }
}</code></pre> 
<p> 创建实现类DieLockDemo：</p> 
<pre><code class="language-java">public class DieLockDemo {
    public static void main(String[] args) {
        DieLock d1 = new DieLock(true);
        DieLock d2 = new DieLock(false);

        d1.start();
        d2.start();
    }
}
</code></pre> 
<p> 运行结果：</p> 
<blockquote> 
 <p>if lock1<br> else lock2</p> 
</blockquote> 
<blockquote> 
 <p>else lock2<br> if lock1</p> 
</blockquote> 
<p><strong>在我们今后的开发中要避免锁的同步嵌套使用，不然就很容易产生死锁问题</strong></p> 
<hr>
<h2 id="%E7%BA%BF%E7%A8%8B%E7%BB%84">线程组</h2> 
<p>查看API文档我们知道：</p> 
<blockquote> 
 <pre>public Thread(<a href="../../java/lang/ThreadGroup.html">ThreadGroup</a> group,<a href="../../java/lang/Runnable.html">Runnable</a> target,<a href="../../java/lang/String.html">String</a> name)</pre> 
 <p>分配一个新的<code>Thread</code>对象，使其具有<code>target</code>作为其运行对象，具有指定的<code>name</code>作为其名称，属于<code>group</code>引用的线程组。</p> 
 <p>如果有安全管理器，则使用ThreadGroup作为参数调用其<a href="../../java/lang/SecurityManager.html#checkAccess-java.lang.ThreadGroup-"><code>checkAccess</code></a>方法。</p> 
 <p>此外，它的<code>checkPermission</code>方法由<code>RuntimePermission("enableContextClassLoaderOverride")</code>权限调用，直接或间接地由覆盖<code>getContextClassLoader</code>或<code>setContextClassLoader</code>方法的子类的<code>getContextClassLoader</code> <code>setContextClassLoader</code>调用。</p> 
 <p>新创建的线程的优先级设置为等于创建线程的优先级，即当前正在运行的线程。 可以使用方法<a href="../../java/lang/Thread.html#setPriority-int-">setPriority</a>将优先级改变为新值。</p> 
 <p>当且仅当创建它的线程当前被标记为守护线程时，新创建的线程才被初始化为守护线程。 方法<a href="../../java/lang/Thread.html#setDaemon-boolean-">setDaemon</a>可以用于改变线程是否是守护进程。</p> 
 <p>参数</p> 
 <p><code>group</code> - 线程组。 如果是<code>null</code>并且有一个安全管理器，则该组由<a href="../../java/lang/SecurityManager.html#getThreadGroup--">SecurityManager.getThreadGroup()决定</a> 。 如果没有安全管理员或<code>SecurityManager.getThreadGroup()</code>返回<code>null</code> ，该组将设置为当前线程的线程组。</p> 
 <p><code>target</code> - 启动此线程时调用其<code>run</code>方法的对象。 如果<code>null</code> ，则调用此线程的run方法。</p> 
 <p><code>name</code> - 新线程的名称</p> 
 <p>异常</p> 
 <p><code><a href="../../java/lang/SecurityException.html">SecurityException</a></code> - 如果当前线程不能在指定的线程组中创建线程，或者不能覆盖上下文类加载器方法。</p> 
</blockquote> 
<p>  Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理， Java允许程序直接对线程组进行控制。</p> 
<hr>
<p> 参考代码：</p> 
<p>创建MyRunnable类：</p> 
<pre><code class="language-java">public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}
</code></pre> 
<p>创建实现类ThreadGroupDemo：</p> 
<pre><code class="language-java">public class ThreadGroupDemo {
    public static void main(String[] args) {
        //创建自定义类对象
        MyRunnable myRunnable = new MyRunnable();

        //创建线程对象
        Thread t1 = new Thread(myRunnable, "刘德华");
        Thread t2 = new Thread(myRunnable, "张学友");

        //我们之前都没有提过线程组，以及分组的概念，想着应该有一个默认的分组
        //获取分组
        //ThreadGroup getThreadGroup()
        //返回此线程所属的线程组。
        ThreadGroup tg1 = t1.getThreadGroup();
        System.out.println(tg1);
        ThreadGroup tg2 = t2.getThreadGroup();
        System.out.println(tg2);

        //获取线程组的名字
        //String getName()
        //返回此线程组的名称。
        System.out.println(tg1.getName());
        System.out.println(tg2.getName());
        System.out.println(Thread.currentThread().getName());


        //需求：给线程分组
        //Thread(ThreadGroup group, Runnable target, String name)
        //分配一个新的 Thread对象，使其具有 target作为其运行对象，
        // 具有指定的 name作为其名称，属于 group引用的线程组。
        //创建一个新的线程组
        //ThreadGroup(String name)
        //构造一个新的线程组。
        ThreadGroup tg3 = new ThreadGroup("下路三人组");

        //创建线程对象
        Thread t3 = new Thread(tg3, myRunnable, "荣耀行刑官");
        Thread t4 = new Thread(tg3, myRunnable, "魂锁典狱长");
        Thread t5 = new Thread(tg3, myRunnable, "蒸汽机器人");

        System.out.println(t3.getThreadGroup().getName());
        System.out.println(t4.getThreadGroup().getName());

        //Java允许程序直接对线程组进行控制
        //直接通过组名设置这一组都是守护线程，组里面的线程都是守护线程
        tg3.setDaemon(true);


    }
}</code></pre> 
<p>运行结果：</p> 
<blockquote> 
 <p>java.lang.ThreadGroup[name=main,maxpri=10]<br> java.lang.ThreadGroup[name=main,maxpri=10]<br> main<br> main<br> main<br> 下路三人组<br> 下路三人组</p> 
</blockquote> 
<hr>
<h2 id="%E7%BA%BF%E7%A8%8B%E6%B1%A0Executors">线程池Executors</h2> 
<h3 id="newFixedThreadPool">newFixedThreadPool</h3> 
<p>查看API文档我们知道：</p> 
<blockquote> 
 <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html">ExecutorService</a> newFixedThreadPool(int nThreads)</pre> 
 <p>创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。 在任何时候，最多<code>nThreads</code>线程将处于主动处理任务。 如果所有线程处于活动状态时都会提交其他任务，则它们将等待队列中直到线程可用。 如果任何线程由于在关闭之前的执行期间发生故障而终止，则如果需要执行后续任务，则新线程将占用它。 池中的线程将存在，直到它明确地为<a href="../../../java/util/concurrent/ExecutorService.html#shutdown--"><code>shutdown</code></a> 。</p> 
 <p>参数</p> 
 <p><code>nThreads</code> - 池中的线程数</p> 
 <p>结果</p> 
 <p>新创建的线程池</p> 
 <p>异常</p> 
 <p><code><a href="../../../java/lang/IllegalArgumentException.html">IllegalArgumentException</a></code> - 如果是 <code>nThreads &lt;= 0</code></p> 
</blockquote> 
<blockquote> 
 <p> 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。</p> 
 <pre>而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，
更应该考虑使用线程池。
线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，
等待下一个对象来使用。
在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池

如何实现线程池的代码呢？
    1、创建线程池对象，Executors工厂类下的静态方法
        newFixedThreadPool是其中一种线程池
        public static ExecutorService newFixedThreadPool(int nThreads)
    2、如何往线程池中存放线程？（可以存放哪些线程呢？）
    3、在线程池中的线程如何运行呢？
    4、我想结束线程的运行，可不可以手动结束呢？如果可以，怎么结束？</pre> 
</blockquote> 
<p> 参考代码1：</p> 
<pre><code class="language-java">public class ThreadPoolDemo {
    public static void main(String[] args) {
        //创建线程池
        ExecutorService pool = Executors.newFixedThreadPool(2);

        //Future&lt;?&gt; submit(Runnable task)
        //提交一个可运行的任务执行，并返回一个表示该任务的未来。
        MyRunnable myRunnable = new MyRunnable();
        pool.submit(myRunnable);
        pool.submit(myRunnable);
        //提交数超过线程池的数量的时候也会执行，只不过是当有空闲线程位置的时候再去执行
        //newFixedThreadPool最大一次性可执行线程数量为初始设置的数量
        pool.submit(myRunnable);

        //我想结束线程的运行，可不可以手动结束呢？如果可以，怎么结束？
        //void shutdown()
        //启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。
        pool.shutdown();

        System.out.println("======================================");
        //RejectedExecutionException
        //线程池已经被关闭了，不能再提交任务执行
        pool.submit(myRunnable);

    }
}</code></pre> 
<p> 运行结果：</p> 
<p style="text-align:center"><img alt="" height="1192" src="https://images2.imgbox.com/0a/cb/6mQ5rHgR_o.png" width="1200"></p> 
<pre>提交数超过线程池的数量的时候也会执行，只不过是当有空闲线程位置的时候再去执行newFixedThreadPool最大一次性可执行线程数量为初始设置的数量</pre> 
<hr>
<h2 id="%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">创建线程的第三种方式</h2> 
<h3 id="callable">callable</h3> 
<p>查看API文档我们知道<strong>：</strong></p> 
<blockquote> 
 <pre>public static <a href="../../../java/util/concurrent/Callable.html">Callable</a>&lt;<a href="../../../java/lang/Object.html">Object</a>&gt; callable(<a href="../../../java/security/PrivilegedExceptionAction.html">PrivilegedExceptionAction</a>&lt;?&gt; action)</pre> 
 <p>返回一个<a href="../../../java/util/concurrent/Callable.html"><code>Callable</code></a>对象，该对象在被调用时运行给定的特权异常操作并返回其结果。</p> 
 <p>参数</p> 
 <p><code>action</code> - 运行的特权异常操作</p> 
 <p>结果</p> 
 <p>可调用对象</p> 
 <p>异常</p> 
 <p><code><a href="../../../java/lang/NullPointerException.html">NullPointerException</a></code> - 如果动作为空</p> 
</blockquote> 
<p>参考代码2：<br> 创建自定义类MyCallable：</p> 
<pre><code class="language-java">import java.util.concurrent.Callable;

public class MyCallable implements Callable {
    @Override
    public Object call() throws Exception {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(Thread.currentThread().getName() + "---" + i);
        }
        return null;
    }
}</code></pre> 
<p>创建实现类ThreadPoolDemo2：</p> 
<pre><code class="language-java">public class ThreadPoolDemo2 {
    public static void main(String[] args) {
        //创建线程池对象
        ExecutorService pool = Executors.newFixedThreadPool(2);

        MyRunnable myRunnable = new MyRunnable();
        MyCallable myCallable = new MyCallable();

        //可以执行Runnable对象或者Callable对象代表的线程池
        pool.submit(myRunnable);
        pool.submit(myCallable);

        pool.shutdown();


    }
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center"><img alt="" height="926" src="https://images2.imgbox.com/f2/bf/y0Igrmmk_o.png" width="969"></p> 
<hr>
<h2 id="%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B">匿名内部类方式使用多线程</h2> 
<p>参考代码：</p> 
<pre><code class="language-java">public class ThreadDemo2 {
    public static void main(String[] args) {
        Thread t1 = new Thread("靓仔"){
            @Override
            public void run() {
                for (int i = 0;i &lt; 100;i++){
                    System.out.println(Thread.currentThread().getName() + ":" + i);
                }
            }
        };
        t1.start();

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0;i &lt; 100;i++){
                    System.out.println(Thread.currentThread().getName() + ":" + i);
                }
            }
        },"刘德华");
        t2.start();
    }
}
</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center"><img alt="" height="1087" src="https://images2.imgbox.com/96/a7/ZJ0t2Pb8_o.png" width="1000"></p> 
<hr>
<h2 id="%E5%AE%9A%E6%97%B6%E5%99%A8">定时器</h2> 
<p>  定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行。在Java中，可以通过Timer和TimerTask类来实现定义调度的功能。</p> 
<h3 id="Timer">Timer</h3> 
<p>查看API文档我们知道：</p> 
<blockquote> 
 <pre>public class Timer extends <a href="../../java/lang/Object.html">Object</a></pre> 
 <p>线程调度任务以供将来在后台线程中执行的功能。 任务可以安排一次执行，或定期重复执行。</p> 
 <p>对应于每个Timer对象是单个后台线程，用于依次执行所有定时器的所有任务。 计时器任务应该快速完成。 如果一个定时器任务需要花费很多时间来完成，它会“计时”计时器的任务执行线程。 这可能会延迟随后的任务的执行，这些任务在（和）如果违规任务最后完成时，可能会“束起来”并快速执行。</p> 
 <p>在最后一次对Timer对象的引用后<em>，</em>所有未完成的任务已完成执行，定时器的任务执行线程正常终止（并被收集到垃圾回收）。 但是，这可能需要任意长时间的发生。 默认情况下，任务执行线程不作为<em>守护程序线程</em>运行，因此它能够使应用程序终止。 如果主叫方想要快速终止定时器的任务执行线程，则调用者应该调用定时器的cancel方法。</p> 
 <p>如果定时器的任务执行线程意外终止，例如，因为它调用了stop方法，那么在计时器上安排任务的任何进一步的尝试将会产生一个IllegalStateException ，就像定时器的cancel方法被调用一样。</p> 
 <p>这个类是线程安全的：多个线程可以共享一个单独的Timer对象，而不需要外部同步。</p> 
 <p>此类<em>不</em>提供实时保证：使用Object.wait(long)方法是调度任务。</p> 
 <p>Java 5.0引入了<code>java.util.concurrent</code>软件包，其中一个<code>java.util.concurrent</code>程序是<a href="../../java/util/concurrent/ScheduledThreadPoolExecutor.html"><code>ScheduledThreadPoolExecutor</code></a> ，它是用于以给定速率或延迟重复执行任务的线程池。 这实际上是对一个更灵活的替代<code>Timer</code> / <code>TimerTask</code>组合，因为它允许多个服务线程，接受各种时间单位，并且不需要子类<code>TimerTask</code> （只实现<code>Runnable</code> ）。 使用一个线程配置<code>ScheduledThreadPoolExecutor</code>使其等同于<code>Timer</code> 。</p> 
 <p>实现注意事项：这个类可以扩展到大量并发计划任务（千应该没有问题）。 在内部，它使用二进制堆表示其任务队列，因此计划任务的成本为O（log n），其中n为并发计划任务的数量。</p> 
 <p>实现注意事项：所有构造函数启动计时器线程。</p> 
</blockquote> 
<p> 参考代码1：</p> 
<pre><code class="language-java">public class TimerDemo {
    public static void main(String[] args) {
        //创建定时器对象
        //Timer()
        //创建一个新的计时器。
        Timer timer = new Timer();

        //调度任务执行
        //在指定的延迟之后安排指定的任务执行。 定时在未来的某一时刻执行任务
        //public void schedule(TimerTask task, long delay)
        //自定义子类的形式创建任务
        //delay这个类型是毫秒
        timer.schedule(new MyTask(timer), 3000);
        //public void cancel()终止此计时器，丢弃任何当前计划的任务
        //timer.cancel();
//        timer.schedule(new MyTask(timer), 3000);
    }
}

class MyTask extends TimerTask{
    private Timer timer;

    public MyTask(Timer timer){
        this.timer = timer;
    }


    @Override
    public void run() {
        System.out.println("靓仔真帅");
        timer.cancel();
    }
}
</code></pre> 
<p>运行结果：</p> 
<blockquote> 
 <p>靓仔真帅</p> 
 <p></p> 
</blockquote> 
<p>参考代码2：</p> 
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Timer;
import java.util.TimerTask;

public class TimerDemo2 {
    public static void main(String[] args) {
        //创建定时器对象
        Timer timer = new Timer();

        //void schedule(TimerTask task, long delay, long period)
        //在指定的延迟之后开始 ，重新执行 固定延迟执行的指定任务。
        //3秒后执行任务，并且每个2秒执行一次任务
        timer.schedule(new MyTask2(),3000,2000);
    }
}

class MyTask2 extends TimerTask{

    @Override
    public void run() {
        try {
            FileReader fr = new FileReader("src\liangzai.txt");
            BufferedReader br = new BufferedReader(fr);
            System.out.println(br.readLine());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center"><img alt="" height="1079" src="https://images2.imgbox.com/76/87/DzRU4Hzi_o.png" width="1200"></p> 
<p>通过观察运行结果发现，3秒后输出靓仔真帅！，之后每两秒输出一次靓仔真帅！</p> 
<hr>
<p style="text-align:center">到底啦！给靓仔一个关注吧！༼ つ ◕_◕ ༽つ</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>