<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Slurm.conf配置文件 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Slurm.conf配置文件</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="Slurm_0"></a>Slurm配置文件</h1> 
<h2>
<a id="_2"></a>配置文件示例</h2> 
<p><strong>slurm.conf</strong>是<strong>Slurm</strong>的核心配置文件，它描述了一般的Slurm 配置信息、要管理的节点、有关 如何将这些节点分组到分区中，以及各种调度 与这些分区关联的参数。<strong>该配置文件在群集中的所有节点上保持一致。<strong>如果修改了slurm.conf相关配置文件，诸如</strong>slurmctld</strong>端口等，需要使用<code>scontrol reconfigure</code>重新配置。（注意：<strong>slurm.conf</strong>是不区分大小写的，但是节点和分区名称除外。）常见的配置文件实例如下：</p> 
<pre><code class="prism language-shell"><span class="token comment">##</span>
<span class="token comment">## This file is maintained by Ansible - ALL MODIFICATIONS WILL BE REVERTED</span>
<span class="token comment">##</span>

<span class="token comment"># Configuration options</span>
<span class="token assign-left variable">AccountingStorageHost</span><span class="token operator">=</span><span class="token number">192.168</span>.29.136
<span class="token assign-left variable">AccountingStoragePass</span><span class="token operator">=</span>/var/run/munge/munge.socket.2
<span class="token assign-left variable">AccountingStorageType</span><span class="token operator">=</span>accounting_storage/slurmdbd
<span class="token assign-left variable">AccountingStorageUser</span><span class="token operator">=</span>slurm
<span class="token assign-left variable">AuthAltParameters</span><span class="token operator">=</span>jwt_key<span class="token operator">=</span>/etc/slurm/jwt_hs256.key
<span class="token assign-left variable">AuthAltTypes</span><span class="token operator">=</span>auth/jwt
<span class="token assign-left variable">AuthInfo</span><span class="token operator">=</span>/var/run/munge/munge.socket.2
<span class="token assign-left variable">AuthType</span><span class="token operator">=</span>auth/munge
<span class="token assign-left variable">ClusterName</span><span class="token operator">=</span>cluster
<span class="token assign-left variable">ControlMachine</span><span class="token operator">=</span>master
<span class="token assign-left variable">CryptoType</span><span class="token operator">=</span>crypto/munge
<span class="token assign-left variable">FastSchedule</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">JobCompType</span><span class="token operator">=</span>jobcomp/none
<span class="token assign-left variable">ProctrackType</span><span class="token operator">=</span>proctrack/pgid
<span class="token assign-left variable">SchedulerType</span><span class="token operator">=</span>sched/backfill
<span class="token assign-left variable">SelectType</span><span class="token operator">=</span>select/cons_tres
<span class="token assign-left variable">SelectTypeParameters</span><span class="token operator">=</span>CR_Core_Memory
<span class="token assign-left variable">SlurmctldDebug</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token assign-left variable">SlurmctldLogFile</span><span class="token operator">=</span>/var/log/slurm/slurmctld.log
<span class="token assign-left variable">SlurmctldPort</span><span class="token operator">=</span><span class="token number">6817</span>
<span class="token assign-left variable">SlurmdDebug</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token assign-left variable">SlurmdLogFile</span><span class="token operator">=</span>/var/log/slurm/slurmd.log
<span class="token assign-left variable">SlurmdPort</span><span class="token operator">=</span><span class="token number">6818</span>
<span class="token assign-left variable">SlurmdSpoolDir</span><span class="token operator">=</span>/var/spool/slurm/slurmd
<span class="token assign-left variable">SlurmdUser</span><span class="token operator">=</span>root
<span class="token assign-left variable">SlurmUser</span><span class="token operator">=</span>slurm
<span class="token assign-left variable">StateSaveLocation</span><span class="token operator">=</span>/var/lib/slurm/slurmctld

<span class="token comment"># Nodes</span>
<span class="token assign-left variable">NodeName</span><span class="token operator">=</span>node1 <span class="token assign-left variable">CPUs</span><span class="token operator">=</span><span class="token number">4</span> <span class="token assign-left variable">RealMemory</span><span class="token operator">=</span><span class="token number">1819</span> <span class="token assign-left variable">State</span><span class="token operator">=</span>UNKNOWN
<span class="token assign-left variable">NodeName</span><span class="token operator">=</span>node2 <span class="token assign-left variable">CPUs</span><span class="token operator">=</span><span class="token number">4</span> <span class="token assign-left variable">RealMemory</span><span class="token operator">=</span><span class="token number">1819</span> <span class="token assign-left variable">State</span><span class="token operator">=</span>UNKNOWN

<span class="token comment"># Partitions</span>
<span class="token assign-left variable">PartitionName</span><span class="token operator">=</span>debug <span class="token assign-left variable">Default</span><span class="token operator">=</span>YES <span class="token assign-left variable">MaxTime</span><span class="token operator">=</span>INFINITE <span class="token assign-left variable">Nodes</span><span class="token operator">=</span>node1,node2 <span class="token assign-left variable">State</span><span class="token operator">=</span>UP
</code></pre> 
<h2>
<a id="_48"></a>常规参数</h2> 
<ul><li><strong>AccountingStorageBackupHost</strong></li></ul> 
<p>​ 保存存储数据库的备份主机的名称。 如果与account _ storage/slurmdbd 插件一起使用，备份 slurmdbd 将在备份主机中运行。</p> 
<ul><li><strong>AccountingStorageExternalHost</strong></li></ul> 
<p>​ 表示需要注册的外部<strong>slurmdbd</strong>(&lt;host/ip&gt;[:port][,…])，通过 <em>–cluster/-M</em>来跟另外集群相互调用。</p> 
<ul><li><strong>AccountingStorageHost</strong></li></ul> 
<p>​ 存储数据库的主机，当且尽在使用slurmdbd的机器上存在</p> 
<ul>
<li> <p><strong>AccountingStorageParameters</strong></p> 
  <ul>
<li>
<strong>SSL_CERT</strong>：客户端公钥证书文件的路径名</li>
<li>
<strong>SSL_CA</strong>：证书颁发机构 （CA） 证书文件的路径名</li>
<li>
<strong>SSL_CAPATH</strong>：包含受信任的 SSL CA 证书文件的目录的路径名。</li>
<li>
<strong>SSL_KEY</strong>：客户端私钥文件的路径名。</li>
<li>
<strong>SSL_CIPHER</strong>：SSL 加密允许的密码列表。</li>
</ul> </li>
<li> <p><strong>AccountingStoragePass</strong></p> </li>
</ul> 
<p>​ 用于访问数据库以存储密码，对于具有 Munge 身份验证的 Slurmdbd ，可以将其配置为使用专门的Munge守护进程来提供集群之间的身份验证，而默认的 MUNGE 守护进程提供集群内的身份验证。在这种情况下，<strong>AccountingStoragePass</strong> 应该指定用于与备用 Munge守护进程通信的命名端口(例如**“/var/run/MUNGE/global.socket. 2”**)，默认是NULL。</p> 
<ul><li><strong>AccountingStoragePort</strong></li></ul> 
<p>​ 记账存储数据库服务器的侦听端口。</p> 
<ul><li><strong>AccountingStorageTRES</strong></li></ul> 
<p>​ 表示可追踪的资源列表，包括CPU，GPU，内存等。也可以设置只追踪特定类型的资源列表，如<code>AccountingStorageTRES = gres/GPU，gres/GPU: tesla，gres/GPU: volta</code>，那么只会追踪<strong>Tesla</strong>和<strong>Volta</strong>架构的GPU资源。</p> 
<ul><li><strong>AccountingStorageType</strong></li></ul> 
<p>​ 记账存储机制类型。目前可接受的值包括**“account _ Storage/none”<strong>和</strong>“account _ Storage/slurmdbd”<strong>。</strong>“ account _ Storage/slurmdbd”**值表示会计记录将写入 Slurmdbd。</p> 
<ul><li><strong>AccountingStorageUser</strong></li></ul> 
<p>​ 用于访问记帐存储数据库的用户帐户。</p> 
<ul><li><strong>AcctGatherInterconnectType</strong></li></ul> 
<p>​ 标识用于互连网络流量计算的插件。<strong>Jobacct _ together</strong> 插件和 <strong>slurmd</strong> 守护进程调用这个插件来收集作业和节点的网络流量数据。</p> 
<ul><li><strong>AcctGatherFilesystemType</strong></li></ul> 
<p>​ 标识用于文件系统流量计算的插件。Jobacct _ together 插件和 slurmd 守护进程调用这个插件来收集作业和节点的文件系统流量数据。</p> 
<ul><li><strong>AcctGatherProfileType</strong></li></ul> 
<p>​ 标识用于详细作业分析的插件。Jobacct _ together 插件和 slurmd 守护进程调用这个插件来收集详细的数据，比如作业和节点的 I/O 计数、内存使用或能量消耗。(注意：只有在独占作业分配的情况下，在节点级别收集的数据才与作业相关。)</p> 
<ul><li><strong>AuthAltTypes</strong></li></ul> 
<p>​ <strong>Slurmctld</strong> 允许通信的替代身份验证插件的以逗号分隔列表。目前可接受的值包括 auth/jwt。Auth/jwt 可以通过 SLURM_ JWT 环境变量激活。激活后，它将重写默认的 AuthType。Auth/jwt 需要一个 <strong>jwt _ hs256</strong>。只能在 <strong>slurmctld</strong> 的 StateSaveLocation 目录中填充。Jwt _ hs256.键应该只对 SlurmUser 和 root 可见。</p> 
<ul>
<li> <p><strong>AuthAltParameters</strong>:用于定义可选的身份验证插件选项。</p> 
  <ul>
<li>
<strong>disable_token_creation</strong>:禁止非 SlurmUser 帐户使用“ scontrol token”。</li>
<li>
<strong>max_token_lifespan=xxx(seconds)</strong>:设置最大生命周期</li>
<li>
<strong>jwt_key=</strong>：JWT 密钥文件的绝对路径。密钥必须是 HS256，并且只能由 SlurmUser 访问。</li>
</ul> </li>
<li> <p><strong>AuthInfo</strong></p> <p>用于认证 Slurm 守护进程(slurmctld 和 slurmd)和 Slurm 客户端之间的通信的附加信息。此选项的解释特定于配置的 AuthType。</p> 
  <ul>
<li>
<strong>cred_expire</strong>：默认的作业步骤凭据生命周期，单位是秒。</li>
<li>
<strong>socket</strong>：要使用的 MUNGE 守护套接字的路径名(例如**“socket =/var/run/MUNGE/MUNGE.socket. 2”**)。</li>
<li>
<strong>ttl</strong>：凭证生存期，以秒为单位。</li>
</ul> </li>
<li> <p><strong>AuthType</strong></p> </li>
</ul> 
<p>​ Slurm 组件间通信的认证方法。目前可接受的值包括“ auth/munge”，表示将使用 Munge。</p> 
<ul><li><strong>BatchStartTimeout</strong></li></ul> 
<p>​ 批作业在被认为丢失并释放分配之前允许启动的最长时间(以秒为单位)。如果执行<strong>Prolog</strong>、加载用户环境变量或者 <strong>slurmd</strong> 守护进程从内存中分页，则可能需要更大的值。</p> 
<ul>
<li> <p><strong>BcastParameters</strong>：控制 sbcast 和 srun的 ——bcast 行为。</p> 
  <ul>
<li>
<strong>DestDir=</strong>：将文件广播到分配的计算节点的目标目录，默认当前目录</li>
<li>
<strong>Compression=</strong>：指定要使用的默认文件压缩库。支持的值是“ lz4”和“ none”。</li>
<li>
<strong>send_libs</strong>：尝试自动检测并将可执行文件的共享对象依赖关系广播到分配的计算节点。</li>
</ul> </li>
<li> <p><strong>CliFilterPlugins</strong>：以逗号分隔的命令行界面选项展示插件列表，指定的插件将按照列出的顺序执行。</p> 
  <ul>
<li>
<strong>cli_filter/lua</strong>：这个插件允许使用 lua 编写自己的 cli_filter 实现。</li>
<li>
<strong>cli_filter/syslog</strong>：这个插件支持记录所执行的作业提交活动。所有 salloc/sbatch/srun 选项都以 JSON 格式与环境变量一起记录到 syslog 中。</li>
<li>
<strong>cli_filter/user_defaults</strong>：这个插件查找文件 $HOME/.slurm/default 并将其中的每一行读取为 key = value 对，其中 key 是 salloc/sbatch/srun 可用的任何作业提交选项，value 是用户定义的默认值。</li>
</ul> </li>
<li> <p><strong>ClusterName</strong></p> </li>
</ul> 
<p>​ Slurm 管理集群在数据库中的名称。</p> 
<ul>
<li> <p><strong>CommunicationParameters</strong>：通信选项列表</p> 
  <ul>
<li>
<strong>block_null_hash</strong>：要求所有 Slurm 身份验证令牌都包含一个更新的(20.11.9和21.08.8版本)有效负载。</li>
<li>
<strong>DisableIPv4</strong>：禁用所有 slurmdbd 守护进程的 IPv4操作(slurmdbd 除外)</li>
<li>
<strong>EnableIPv6</strong>：允许对所有 slurmdbd 守护进程使用 IPv6地址(slurmdbd 除外)。同时使用 IPv4和 IPv6时，地址族首选项将基于您的/etc/gai.conf 文件。</li>
<li>
<strong>keepaliveinterval=#</strong>：指定 srun 与其 slurmstep 进程之间套接字通信上的 keepalive 探测之间的间隔。</li>
<li>
<strong>keepaliveprobes=#</strong>：指定在认为连接中断之前，在 srun 命令与其 slurmstep 进程之间的套接字通信上发送的 keepalive 探测的数量。</li>
<li>
<strong>keepalivetime=#</strong>：指定断开连接后，srun 命令与其 slurmstep 进程之间使用的套接字通信保持活动的时间长度。</li>
</ul> </li>
<li> <p><strong>CompleteWait</strong></p> </li>
</ul> 
<p>​ 在计划任何其他作业之前，任何作业处于 COMPLEING 状态时等待的时间(以秒为单位)。这是为了尝试将作业保留在最近使用的节点上，目标是防止碎片。如果设置为零，挂起的作业将尽快启动。</p> 
<ul><li><strong>ControlMachine</strong></li></ul> 
<p>​ 控制节点名称。</p> 
<ul>
<li> <p><strong>CoreSpecPlugin</strong>：标识用于实施核心专业化的插件。要使对此参数的更改生效，需要重新启动 slurmd 守护进程。</p> 
  <ul>
<li>
<strong>core_spec/cray_aries</strong>：只用于 Cray 系统</li>
<li>
<strong>core_spec/none</strong>：适用于所有系统</li>
</ul> </li>
<li> <p><strong>CpuFreqDef</strong>：如果没有使用—— CPU-freq 选项显式设置作业步骤，则运行作业步骤时使用的默认 CPU 频率值或频率调控器。</p> 
  <ul>
<li>
<strong>Conservative</strong>：试图使用保守的 CPU 调控器</li>
<li>
<strong>OnDemand</strong>：尝试使用 OnDemand CPU 调控器</li>
</ul> </li>
<li> <p><strong>CredType</strong></p> <p>用于创建作业步骤凭据的加密签名工具。要使对此参数的更改生效，需要重新启动 slurmctld。</p> </li>
<li> <p><strong>DebugFlags</strong>：定义应该提供更详细事件日志记录的特定子系统。</p> 
  <ul>
<li>
<strong>Accrue</strong>：应计帐款会计详情</li>
<li>
<strong>Agent</strong>：RPC 代理(从 Slurm 守护进程发出的 RPC)</li>
<li>
<strong>BackFill</strong>：作业回填计划程序详细信息</li>
<li>
<strong>CPU_Bind</strong>：作业和作业步的 CPU 绑定详细信息</li>
<li>
<strong>Dependency</strong>：工作依赖调试信息</li>
<li>
<strong>Elasticsearch</strong>：Elasticsearch debug info</li>
<li>
<strong>Gres</strong>：通用资源详细信息</li>
<li>
<strong>JobAccountGather</strong>：常见的工作帐户收集详细信息</li>
<li>
<strong>Priority</strong>：作业优先级信息</li>
<li>
<strong>Route</strong>：消息转发调试信息</li>
<li>
<strong>Steps</strong>：Slurmctld资源分配的工作步骤</li>
</ul> </li>
<li> <p><strong>DefCpuPerGPU</strong></p> </li>
</ul> 
<p>​ 每个分配的 GPU 所分配的 CPU 的默认计数。仅当作业没有指定 ——cpus-per-task 和——cpus-per-gpu 时才使用此值。</p> 
<ul><li><strong>DefMemPerCPU</strong></li></ul> 
<p>​ 每个可用分配 CPU 可用的默认实际内存大小(MB)。用于避免过度订阅内存并导致内存分页。如果将单个处理器分配给作业，则通常使用 DefMemPerCPU。其他的诸如<strong>DefMemPerGPU</strong>（每个GPU多少内存），<strong>DefMemPerNode</strong>（每个节点多少内存）。</p> 
<ul>
<li>
<strong>DependencyParameters</strong> 
  <ul>
<li>
<strong>disable_remote_singleton</strong>：默认情况下，当联合作业具有单独依赖项时，联合中的每个集群必须清除单独依赖项，才能认为满足作业的单独依赖项。</li>
<li>
<strong>kill_invalid_depend</strong>：如果一个作业有一个无效的依赖项，它永远不能运行终止它，并将其状态设置为 JOB _ CANCELLED。默认情况下，作业保持挂起状态。</li>
</ul> </li>
<li><strong>DisableRootJobs</strong></li>
</ul> 
<p>​ 如果设置为“ YES”，那么用户 root 将被禁止运行任何作业。默认值是“ NO”，这意味着用户 root 将能够执行作业。DisableRootJobs 也可以通过分区设置。</p> 
<ul><li>
<strong>EnforcePartLimits</strong>—解决作业大小限制</li></ul> 
<p>​ 如果设置为“ ALL”，那么超过分区大小和/或时间限制的作业将在提交时被拒绝。如果作业提交给多个分区，则作业必须满足所有请求分区的限制。如果设置为“ NO”，那么作业将被接受并保持排队状态，直到分区限制改变(时间和节点限制)。</p> 
<ul><li><strong>Epilog</strong></li></ul> 
<p>​ 当用户的作业完成时，作为用户根在每个节点上执行的脚本的完全限定路径名(例如“/usr/local/slurm/pilog”)。</p> 
<ul><li><strong>EpilogMsgTime</strong></li></ul> 
<p>​ Slurmctld 守护进程处理来自 slurmd 守护进程的 Epilog 完成消息所需的微秒数。此参数可用于防止同时发送一连串 Epilog 完成消息，这应有助于防止丢失消息并提高大型作业的吞吐量。</p> 
<ul><li><strong>FairShareDampeningFactor</strong></li></ul> 
<p>​ 抑制超过用户或组所分配资源的公平份额的影响。较高的价值将提供更大的能力，以区分超过公平份额的高水平。</p> 
<ul><li><strong>FirstJobId</strong></li></ul> 
<p>​ 将用于提交给 Slurm 的第一个作业的作业 ID。生成的作业 ID 值对于后续的每个作业将递增1。</p> 
<ul><li><strong>GetEnvTimeout</strong></li></ul> 
<p>​ 控制作业在尝试从缓存文件加载用户环境之前应该等待多长时间。</p> 
<ul><li><strong>GresTypes</strong></li></ul> 
<p>​ 要管理的通用资源列表(例如，GresTypes = gpu)，需要重新启动 slurmctld 和 slurmd 守护进程才能生效。</p> 
<ul><li><strong>GroupUpdateForce</strong></li></ul> 
<p>​ 如果设置为非零值，那么关于哪些用户是允许使用分区的组的成员的信息将定期更新，即使在没有更改/etc/group 文件的情况下也是如此。如果设置为零，那么只有在更新/etc/group 文件之后才会更新组成员信息。默认值为1。</p> 
<ul><li><strong>GroupUpdateTime</strong></li></ul> 
<p>​ 控制有关哪些用户是允许使用分区的组的成员的信息更新的频率，以及缓存用户组成员列表的时间，单位秒。</p> 
<ul>
<li>
<strong>HealthCheckNodeState</strong>：确定应该执行 HealthCheckProgram 的节点状态，默认是ANY 
  <ul>
<li>
<strong>ALLOC</strong>：在 ALLOC 状态的节点上运行(分配的所有 CPU)。</li>
<li>
<strong>ANY</strong>：在任何状态的节点上运行。</li>
<li>
<strong>CYCLE</strong>：在所有计算节点上循环运行。</li>
<li>
<strong>IDLE</strong>：在 IDLE 状态的节点上运行。</li>
<li>
<strong>MIXED</strong>：在 MIXED 状态的节点上运行(一些 CPU 空闲，其他 CPU 分配)。</li>
</ul> </li>
<li><strong>InactiveLimit</strong></li>
</ul> 
<p>​ 以秒为单位的时间间隔，在此之后，无响应的作业分配命令(例如 srun 或 salloc，对批处理作业无影响)将导致作业终止。如果执行命令的节点失败或命令异常终止，将终止其作业分配。</p> 
<ul><li><strong>JobCompLoc</strong></li></ul> 
<p>​ 当 JobCompType 为“ jobcomp/filetxt”时写入作业完成记录的完全限定文件名，例如当 JobCompType 为数据库时，存储作业放在数据库中。</p> 
<ul>
<li> <p><strong>JobCompType</strong>：作业完成的日志记录机制</p> 
  <ul>
<li>
<strong>jobcomp/none</strong>：作业完成后，作业的记录将从系统中清除。</li>
<li>
<strong>jobcomp/elasticsearch</strong>：作业完成后，作业的记录应该写入到由 JobCompLoc 参数指定的 Elasticsearch 服务器。</li>
<li>
<strong>jobcomp/mysql</strong>：作业完成后，作业的记录应该写入到由 JobCompLoc 参数指定的 MySQL 或 MariaDB 数据库中。</li>
</ul> </li>
<li> <p><strong>JobCompUser</strong>：用于访问作业完成数据库的用户帐户。</p> </li>
<li> <p><strong>JobRequeue</strong></p> </li>
</ul> 
<p>​ 此选项控制要重新排队的批作业的默认能力。作业可能会被系统管理员、节点故障后或被更高优先级的作业抢占后显式地重新排队。如果 JobRequeue 设置为1，则可以重新排队批作业，除非用户显式禁用该作业。如果 JobRequeue 设置为0，那么除非用户显式启用，否则不会对批作业进行重新排队。例如，<code>sbatch --no-requeue / sbatch --requeue</code></p> 
<ul><li><strong>KillOnBadExit</strong></li></ul> 
<p>​ 如果设置为1，则如果任何任务崩溃或中止，步骤将立即终止，如非零退出代码所示。使用默认值0，如果其中一个进程崩溃或中止，则在崩溃或中止的进程等待期间，其他进程将继续运行。</p> 
<ul><li><strong>KillWait</strong></li></ul> 
<p>​ SIGTERM 和 SIGKILL 信号之间的作业进程在达到其时间限制时的间隔，以秒为单位。如果作业未能在指定的时间间隔内终止，它将被强制终止</p> 
<ul><li><strong>LogTimeFormat</strong></li></ul> 
<p>​ Slurmctld 和 slurmd 日志文件中的时间戳格式。</p> 
<ul><li><strong>Max/Min家族</strong></li></ul> 
<table>
<thead><tr>
<th align="center">名称</th>
<th align="center">含义</th>
</tr></thead>
<tbody>
<tr>
<td align="center"><strong>MaxJobCount</strong></td>
<td align="center">Slurmctld 一次可以在内存中拥有的最大作业数。</td>
</tr>
<tr>
<td align="center"><strong>MaxJobId</strong></td>
<td align="center">提交给 Slurm 作业所使用的最大作业 ID。作业 id 是无符号的32位整数，前26位给本地作业 id，其余6位给集群 id</td>
</tr>
<tr>
<td align="center"><strong>MaxMemPerCPU</strong></td>
<td align="center">每个分配的 CPU 可用的最大实际内存大小(MB)。避免过度使用导致内存分页</td>
</tr>
<tr>
<td align="center"><strong>MaxNodeCount</strong></td>
<td align="center">slurmctld中可能存在的节点的最大计数</td>
</tr>
<tr>
<td align="center"><strong>MaxStepCount</strong></td>
<td align="center">任何作业可以启动的最大步骤数。默认值为40000步。</td>
</tr>
<tr>
<td align="center"><strong>MaxTasksPerNode</strong></td>
<td align="center">Slurm 将允许一个作业步骤在单个节点上产生最大任务数(0-65533)。</td>
</tr>
<tr>
<td align="center"><strong>MinJobAge</strong></td>
<td align="center">在 slurmctld 保存在内存中的作业列表中清除其记录之前，已完成作业的最小存在时间，默认值为300秒。</td>
</tr>
</tbody>
</table> 
<ul>
<li> <p><strong>PluginDir</strong>：标识 Slurm 插件的位置。</p> </li>
<li> <p><strong>PreemptMode</strong>：用于抢占作业或启用帮派Gang调度的机制。当 PreemptType 参数设置为启用抢占时，PreemptMode 选择用于抢占集群的合格作业的默认机制。</p> 
  <ul>
<li>
<strong>OFF</strong>：禁止抢占，与<code>PreemptType = preempt/none </code>功能相同</li>
<li>
<strong>CANCEL</strong>：被抢占的作业将被取消。</li>
<li>
<strong>GANG</strong>：启用同一分区中作业的成组调度(时间切片) ，并允许恢复挂起的作业。</li>
<li>
<strong>REQUEUE</strong>：通过重新排队(如果可能)或取消作业来抢占作业。</li>
<li>
<strong>SUSPEND</strong>：抢占作业将被暂停，稍后 Gang 调度程序将恢复。</li>
<li>
<strong>WITHIN</strong>：对于 PreemptType = preempt/qos，允许相同 qos 中的作业相互抢占。</li>
</ul> </li>
<li> <p><strong>PreemptType</strong></p> 
  <ul>
<li>
<strong>preempt/none</strong>：默认作业抢占被禁用。</li>
<li>
<strong>preempt/partition_prio</strong>：作业抢占基于分区优先级层。高优先级分区中的作业可能会抢占低优先级分区中的作业。</li>
<li>
<strong>preempt/qos</strong>：作业抢占规则由 Slurm 数据库中的服务质量QoS规范指定。</li>
</ul> </li>
<li> <p><strong>PreemptExemptTime</strong>：全局选项，用于所有作业在被考虑抢占之前的最短运行时间</p> </li>
<li> <p><strong>PriorityCalcPeriod</strong></p> </li>
</ul> 
<p>​ 半衰期以分钟为单位重新计算半衰期的时间。只有当 PriorityType = PriorityType/multifactor 时才适用。默认值为5(分钟)。</p> 
<ul><li><strong>PriorityFavorSmall</strong></li></ul> 
<p>​ 指定应给予小作业优先调度权。只有当 PriorityType = PriorityType/multifactor 时才适用。支持的值是“ YES”和“ NO”。默认值是“ NO”。</p> 
<ul>
<li> <p><strong>PriorityFlags</strong>：修改作业优先级</p> 
  <ul>
<li>
<strong>CALCULATE_RUNNING</strong>：不仅会重新计算挂起作业的优先级，还会重新计算正在运行和挂起的作业的优先级。</li>
<li>
<strong>DEPTH_OBLIVIOUS</strong>：优先级将基于类似于正常的多因素计算，但是树中关联的深度不会对它们的优先级产生不利影响。但是默认不启动FairTree算法，即NO_FAIR_TREE。</li>
<li>
<strong>NO_FAIR_TREE</strong>:禁用“公平树”算法，恢复为“经典”公平共享优先级调度。</li>
<li>
<strong>INCR_ONLY</strong>:表示优先级只会增加，作业优先级永远不会减少。</li>
<li>
<strong>SMALL_RELATIVE_TO_TIME</strong>：作业的大小组件将不仅基于作业的大小，而且基于作业的大小除以其时间来计算。</li>
</ul> </li>
<li> <p><strong>PriorityMaxAge</strong></p> </li>
</ul> 
<p>​ 在基于时长的因子中，超过最大时长的作业将获得相同的时长优先级因素值。</p> 
<ul>
<li>
<strong>PriorityType</strong>：指定用于建立作业调度优先级的插件。 
  <ul>
<li>
<strong>priority/basic</strong>：默认的FIFO调度</li>
<li>
<strong>priority/multifactor</strong>：工作的优先级取决于各种因素，包括大小、作业时长、 份额。</li>
</ul> </li>
<li>
<strong>PriorityUsageResetPeriod</strong>：在这个时间间隔内，关联的使用将被重置为0。 
  <ul>
<li>
<strong>NONE</strong>：从不清理历史使用（默认）</li>
<li>
<strong>NOW</strong>：现在就清除历史使用情况。</li>
<li>
<strong>DAILY</strong>：每天清楚一次历史使用情况。</li>
<li>
<strong>WEEKLY</strong>：每周；<strong>MONTHLY</strong>：每月；<strong>QUARTERLY</strong>：每季度；<strong>YEARLY</strong>：每年</li>
</ul> </li>
<li><strong>优先级权重设置</strong></li>
</ul> 
<table>
<thead><tr>
<th align="center">名称</th>
<th align="center">含义（默认：0）</th>
</tr></thead>
<tbody>
<tr>
<td align="center"><strong>PriorityWeightAge</strong></td>
<td align="center">用于设置队列等待时间组件对作业优先级的贡献程度。</td>
</tr>
<tr>
<td align="center"><strong>PriorityWeightAssoc</strong></td>
<td align="center">用于设置关联组件对作业优先级的贡献程度。</td>
</tr>
<tr>
<td align="center"><strong>PriorityWeightFairshare</strong></td>
<td align="center">用于设置公平分享组件对作业优先级的贡献程度</td>
</tr>
<tr>
<td align="center"><strong>PriorityWeightJobSize</strong></td>
<td align="center">用于设置作业大小组件对作业优先级的贡献程度。</td>
</tr>
<tr>
<td align="center"><strong>PriorityWeightPartition</strong></td>
<td align="center">用于设置在计算作业优先级时使用的分区因子</td>
</tr>
<tr>
<td align="center"><strong>PriorityWeightQOS</strong></td>
<td align="center">用于设置服务质量组件对作业优先级的贡献程度。</td>
</tr>
<tr>
<td align="center"><strong>PriorityWeightTRES</strong></td>
<td align="center">用于设置每个 TRES 类型对作业优先级的贡献程度。</td>
</tr>
</tbody>
</table> 
<ul>
<li> <p><strong>PrivateData</strong>：设置常规用户可见/不可见的信息范围</p> 
  <ul>
<li>
<strong>accounts</strong>：防止用户查看任何帐户。</li>
<li>
<strong>jobs</strong>：防止用户查看属于其他用户的作业或作业步骤。</li>
<li>
<strong>nodes</strong>：防止用户查看节点状态信息。</li>
<li>
<strong>partitions</strong>：防止用户查看分区状态信息。</li>
<li>
<strong>reservations</strong>：防止用户查看无法使用的预订。</li>
<li>
<strong>usage</strong>：防止用户查看任何其他用户的使用情况。</li>
<li>
<strong>users</strong>：防止用户查看除了他们自己以外的任何用户的信息。</li>
</ul> </li>
<li> <p><strong>ProctrackType</strong>：进程追踪插件</p> 
  <ul>
<li>
<strong>proctrack/cgroup</strong>：使用Linux中的cgroup 来约束和跟踪进程。</li>
<li>
<strong>proctrack/linuxproc</strong>：使用Linux 进程树的父进程 ID 。</li>
<li>
<strong>proctrack/pgid</strong>：使用进程组 ID。</li>
</ul> </li>
<li> <p><strong>ReconfigFlags</strong>：使用“ scontrol reconfig”命令时可能采取的操作。</p> 
  <ul>
<li>
<strong>KeepPartInfo</strong>：保持分区原有的信息，包括内存节点等参数。</li>
<li>
<strong>KeepPartState</strong>：只保持分区中内存相关参数。</li>
</ul> </li>
<li> <p><strong>ResumeProgram</strong></p> </li>
</ul> 
<p>​ Slurm 支持一种机制，可以降低长时间空闲节点的功耗，这通常是通过降低电压和频率或关闭节点电源来实现的。</p> 
<ul><li><strong>ResumeRate</strong></li></ul> 
<p>​ 重新启动时，为每分钟启动多个节点，可用于防止节能模式下大量节点同时分配工作(如大量工作启动)时出现问题。</p> 
<ul><li><strong>ResumeTimeout</strong></li></ul> 
<p>​ 发出节点恢复请求到该节点实际可用之间允许的最长时间(以秒为单位)。在此时间框架内无法响应的节点将被标记为 DOWN，并且在节点上安排的作业将被重新排队。</p> 
<ul>
<li> <p><strong>RoutePlugin</strong></p> 
  <ul>
<li>
<strong>route/default</strong>：默认网状结构。</li>
<li>
<strong>route/topology</strong>：使用 toplogy.conf 文件中定义的交换机层次网络结构。</li>
</ul> </li>
<li> <p><strong>SchedulerType</strong>：标识使用调度程序的类型。</p> 
  <ul>
<li>
<strong>sched/backfill</strong>：使用回填调度机制来支持默认的 FIFO 调度。回填调度将启动低优先级作业，这样做不延迟任何高优先级作业的预期启动时间。</li>
<li>
<strong>sched/builtin</strong>：这是 FIFO 调度程序，它按优先级顺序启动作业，如果无法启动作业，那么低优先级也不会被启动。</li>
</ul> </li>
<li> <p><strong>SlurmctldDebug</strong>：提供 slurmctld 守护进程日志的详细级别。</p> 
  <ul>
<li>
<strong>quiet</strong>：什么都不记录</li>
<li>
<strong>fatal</strong>：只记录严重错误</li>
<li>
<strong>error</strong>：只记录error</li>
<li>
<strong>info</strong>：记录错误和一般消息</li>
<li>
<strong>verbose</strong>：记录错误和详细的消息</li>
<li>
<strong>debug</strong>、<strong>debug1</strong>、<strong>debug2</strong>
</li>
</ul> </li>
<li> <p><strong>SlurmctldLogFile</strong>：Slurmctld 守护进程的日志写入的文件的绝对路径名。</p> </li>
<li> <p><strong>SlurmctldPidFile</strong></p> </li>
</ul> 
<p>​ Slurmctld 守护进程可以将其进程 ID 写入其中的文件的绝对路径，默认是“/var/run/slurmctld.pid”。</p> 
<ul>
<li>
<strong>SlurmctldSyslogDebug</strong>：Slurmctld 守护进程将以指定的详细级别将事件记录到 syslog 文件。 
  <ul>
<li>
<strong>quiet</strong>：什么都不记录</li>
<li>
<strong>fatal</strong>：只记录严重错误，默认</li>
<li>
<strong>error</strong>：只记录error</li>
<li>
<strong>info</strong>：记录错误和一般消息</li>
<li>
<strong>verbose</strong>：记录错误和详细的消息</li>
<li>
<strong>debug</strong>、<strong>debug1</strong>、<strong>debug2</strong>
</li>
</ul> </li>
<li><strong>SlurmctldTimeout</strong></li>
</ul> 
<p>​ 备份控制器在获得控制权之前等待主控制器响应的时间间隔，默认120秒，最大65533秒。</p> 
<ul><li><strong>SlurmdSpoolDir</strong></li></ul> 
<p>​ 将 slurmd 守护进程的状态信息和批处理作业脚本信息写入的目录的绝对路径。这必须是所有节点的公共路径名，默认路径值是“/var/spool/slurmd”。</p> 
<ul><li><strong>SlurmdUser</strong></li></ul> 
<p>​ Slurmd 守护进程作为其执行的用户的名称。该用户必须存在于集群的所有节点上，以便对 Slurm 组件之间的通信进行身份验证。默认值是“ root”。</p> 
<ul><li><strong>SlurmUser</strong></li></ul> 
<p>​ Slurmctld 守护进程作为其执行的用户的名称。该用户必须存在于集群的所有节点上，以便对 Slurm 组件之间的通信进行身份验证。默认值是“ root”。</p> 
<ul><li><strong>StateSaveLocation</strong></li></ul> 
<p>​ slurmctld 将其状态保存到的目录的绝对路径名(例如“/usr/local/Slurm/check”)。Slurm 状态将保存在这里，以便从系统故障中恢复。</p> 
<ul><li><strong>SuspendExcNodes</strong></li></ul> 
<p>​ 指定不处于节能模式的节点，即使节点在较长时间内保持空闲状态。比如node[10-20]:4，则表示在10-20这个节点范围内，至少有四个节点保持IDLE状态，而不是DOWN，或者DRAINING。</p> 
<ul><li><strong>TCPTimeout</strong></li></ul> 
<p>​ 允许建立 TCP 连接的时间。默认值为2秒。</p> 
<h2>
<a id="_425"></a>节点管理</h2> 
<p>​ Slurm 要管理的节点的配置也在/etc/slurm/slurm.conf 中指定。更改节点配置(例如添加节点、更改处理器数量等)需要重新启动 slurmctld 守护进程和 slurmd 守护进程。所有 slurmd 守护进程都必须知道系统中的每个节点，以便转发消息以支持分层通信。</p> 
<ul><li><strong>NodeName</strong></li></ul> 
<p>​ Slurm 用来引用节点的名称。通常这是“/bin/hostname-s”返回的字符串。</p> 
<ul><li><strong>NodeHostname</strong></li></ul> 
<p>​ 通常这是“/bin/hostname-s”返回的字符串。与<strong>NodeName</strong>默认情况下是相同的。</p> 
<ul><li><strong>NodeAddr</strong></li></ul> 
<p>​ 在建立通信路径时应引用的节点的名称。这个名称将用作 getaddrinfo ()函数的参数，默认情况下与<strong>NodeHostName</strong>相同。</p> 
<ul><li><strong>CoreSpecCount</strong></li></ul> 
<p>​ 保留给系统使用的核心数量。这些核心将不可用于分配给用户作业。默认情况下，Slurm 守护进程 slurmd 可能被限制在这些资源中，或者被禁止使用这些资源。</p> 
<ul><li><strong>CPUs</strong></li></ul> 
<p>​ 节点上逻辑处理器的数量。可以设置为套接字的总数，核心或线程。</p> 
<ul><li><strong>Features</strong></li></ul> 
<p>​ 表示与节点关联的某些特征，例如指示处理器速度。一个节点要么有一个特性，要么没有。</p> 
<ul><li><strong>Gres</strong></li></ul> 
<p>​ 表示节点通用资源规范列表，第一个字段是资源名称，它与 GresType 配置参数名称匹配，后一个字段必须指定资源计数，表示该类型资源有多少个。</p> 
<ul><li><strong>MemSpecLimit</strong></li></ul> 
<p>​ 保留给系统使用且不可用于用户分配的内存量（MB）。</p> 
<ul><li><strong>RealMemory</strong></li></ul> 
<p>​ 节点上实际内存的大小(MB)。默认值为1。降低 RealMemory 的目标是为操作系统预留一定数量的内存。</p> 
<ul><li><strong>Reason</strong></li></ul> 
<p>​ 标识一个节点所在状态的原因。</p> 
<ul><li><strong>Sockets</strong></li></ul> 
<p>​ 节点上的物理处理器套接字/核心数。如果忽略 Sockets，则将从 CPUs、 CoresPerSocket 和 ThreadsPerCore 推断。</p> 
<ul><li><strong>State</strong></li></ul> 
<table>
<thead><tr>
<th align="center">关键字</th>
<th align="center">含义</th>
</tr></thead>
<tbody>
<tr>
<td align="center"><strong>DOWN</strong></td>
<td align="center">表示节点失败，不可用。</td>
</tr>
<tr>
<td align="center"><strong>DRAIN</strong></td>
<td align="center">表示节点不可用于分配工作。</td>
</tr>
<tr>
<td align="center"><strong>FAIL</strong></td>
<td align="center">表示节点预计将很快失败，没有分配给它的作业，也不会分配任何新作业。</td>
</tr>
<tr>
<td align="center"><strong>FAILING</strong></td>
<td align="center">表示节点预计将很快失败，已分配了一个或多个作业，但不会分配任何新作业。</td>
</tr>
<tr>
<td align="center"><strong>UNKNOWN</strong></td>
<td align="center">表示节点的状态未定义，UNKNOWN 是默认状态。</td>
</tr>
</tbody>
</table> 
<p>注意：这里没有<strong>IDLE</strong>、<strong>BUSY</strong>状态，因为这不用在配置文件中设置，因为默认状态是<strong>UNKONWN</strong>，根据恢复的系统状态信息将节点状态设置为 BUSY、 IDLE 或其他适当的状态。</p> 
<ul><li><strong>TmpDisk</strong></li></ul> 
<p>​ TmpFS 中临时磁盘存储的总大小(MB)。临时文件系统用来标识作业应该用于临时存储的位置。</p> 
<ul><li><strong>Weight</strong></li></ul> 
<p>​ 用于调度目的的节点的优先级。在所有条件相同的情况下，将任务分配到满足其需求的权重最低的节点。如果任何一个节点都能满足作业的需求，那么分配较小的内存节点比分配较大的内存节点更好。具有更多处理器、内存、磁盘空间、更高处理器速度等的节点将分配更大的权重。而且节点权重只在当前可用节点中考虑，即节点状态为<strong>IDLE</strong>或者<strong>BUSY</strong>。</p> 
<h2>
<a id="_495"></a>分区管理</h2> 
<p>​ 分区配置允许为不同的节点组(或分区)建立不同的作业限制或访问控制。节点组可能位于多个分区中，使分区成为通用队列。例如，可以将同一组节点放到两个不同的分区中，每个分区都有不同的约束(时间限制、作业大小、允许使用分区的组等等)。作业在单个分区内分配资源。在<strong>slurm.conf</strong>中每个分区的所有参数放在一行中。每一行分区配置信息应该代表一个不同的分区。</p> 
<ul><li><strong>AllocNodes</strong></li></ul> 
<p>​ 用逗号分隔表示分区的节点列表，用户可以在分区中提交作业。默认值是“ ALL”。</p> 
<ul><li><strong>AllowAccounts</strong></li></ul> 
<p>​ 表示可以在分区中执行作业的帐户列表。默认值是“ ALL”。</p> 
<ul><li><strong>AllowGroups</strong></li></ul> 
<p>​ 表示可以在分区使用的组名列表，这些组名可以在这个分区中执行作业。如果 AllowGroup 至少有一个与用户关联的组，则允许用户向此分区提交作业。作为用户 root 或用户 SlurmUser 执行的作业将被允许使用任何分区，而与 AllowGroup 的值无关。默认情况下，AllowGroups 是未设置的，这意味着<strong>所有组都可以使用此分区。</strong></p> 
<ul><li><strong>AllowQos</strong></li></ul> 
<p>​ 可以使用分区的QoS 列表，这些 QoS 可以执行分区中的作业。作为Root用户执行的作业可以使用任何分区，而不必考虑 AllowQos 的值。默认值是“ ALL”。</p> 
<ul><li><strong>Alternate</strong></li></ul> 
<p>​ 如果该分区的状态为“ DRAIN”或“ INACTIVE”，则使用的备用分区的分区名称。</p> 
<ul><li><strong>Default</strong></li></ul> 
<p>​ 如果一个分区设置了该关键字，没有分区规范提交的作业将利用这个分区。可能的值是“ YES”和“ NO”。默认值是“ NO”。</p> 
<ul><li><strong>DefaultTime</strong></li></ul> 
<p>​ 用于未指定值的作业的运行时间限制。如果未设置，则将使用 MaxTime。</p> 
<ul><li><strong>DefCpuPerGPU</strong></li></ul> 
<p>​ 每个GPU 所分配的 CPU 的默认数量。仅当作业没有指定——cpus-per-task 和—— cpus-per-gpu 时才使用这个值。</p> 
<ul><li><strong>DefMemPerCPU</strong></li></ul> 
<p>​ 每个 CPU分配可用的默认实际内存大小(MB)。用于避免过度订阅内存并导致分页。如果未设置，则将使用整个群集的 DefMemPerCPU 值。</p> 
<ul><li><strong>DefMemPerGPU</strong></li></ul> 
<p>​ 每个GPU 分配可用的默认实际内存大小(MB)。</p> 
<ul><li><strong>DefMemPerNode</strong></li></ul> 
<p>​ 每个已分配节点可用的默认实际内存大小(MB)，避免过度使用内存并导致分页。如果将整个节点分配给作业并且资源超订(OverSubscribe = yes 或 OverSubscribe = force) ，则通常使用 DefMemPerNode。如果未设置，则将使用整个群集的 DefMemPerNode 值。</p> 
<ul><li><strong>黑名单限制</strong></li></ul> 
<table>
<thead><tr>
<th align="center">关键字</th>
<th align="center">含义</th>
</tr></thead>
<tbody>
<tr>
<td align="center"><strong>DenyAccounts</strong></td>
<td align="center">表示不执行分区中作业的帐户列表。默认情况下，所有账户都可访问: 如果使用 AllowAccount，那么 DenyAccount 将不会被强制执行，他俩是互斥的。</td>
</tr>
<tr>
<td align="center"><strong>DenyQos</strong></td>
<td align="center">表示QoS 不会执行分区的作业。默认情况下，所有QoS都可访问: 如果使用 AllowQos，那么 DenyQos 将不会被强制执行，也是互斥的。</td>
</tr>
<tr>
<td align="center"><strong>DisableRootJobs</strong></td>
<td align="center">如果设置为“ YES”，那么用户 root 将被阻止在这个分区上运行任何作业。默认是“ NO”，允许用户 root 执行作业)。</td>
</tr>
</tbody>
</table> 
<ul><li><strong>ExclusiveUser</strong></li></ul> 
<p>​ 如果设置为“ YES”，那么节点将专门分配给用户。可以为同一个用户运行多个作业，</p> 
<ul><li><strong>Hidden</strong></li></ul> 
<p>​ 指定默认情况下是否隐藏分区及其作业。Slurm API 或命令默认情况下不会报告隐藏分区。可能的值是“ YES”和“ NO”。默认值是“ NO”。</p> 
<ul><li><strong>Min/Max家族</strong></li></ul> 
<table>
<thead><tr>
<th align="center">关键字</th>
<th align="center">含义</th>
</tr></thead>
<tbody>
<tr>
<td align="center"><strong>MaxCPUsPerNode</strong></td>
<td align="center">此分区中所有作业可用的任何节点上的最大 CPU 数。一个节点可以与两个 Slurm 分区(例如“ cpu”和“ gpu”)相关联，而“ cpu”分区可以仅限于节点 CPU 的一个子集。</td>
</tr>
<tr>
<td align="center"><strong>MaxMemPerCPU</strong></td>
<td align="center">每个 CPU 可用的最大实际内存大小(MB)，用于避免过度订阅内存并导致分页。如果未设置，则将使用整个群集的 MaxMemPerCPU 值。</td>
</tr>
<tr>
<td align="center"><strong>MaxMemPerNode</strong></td>
<td align="center">个分配节点可用的最大实际内存大小(MB)，用于避免过度订阅内存并导致分页。如果未设置，则将使用整个群集的 MaxMemPerNode 值。</td>
</tr>
<tr>
<td align="center"><strong>MaxNodes</strong></td>
<td align="center">可以分配给任何单个作业的节点的最大数目，默认没有限制</td>
</tr>
<tr>
<td align="center"><strong>MaxTime</strong></td>
<td align="center">作业的最大运行时间限制。</td>
</tr>
<tr>
<td align="center"><strong>MinNodes</strong></td>
<td align="center">可以分配给单个作业的最小节点数。默认值为0。</td>
</tr>
</tbody>
</table> 
<ul><li>
<strong>OverSubscribe</strong>：控制分区在每个资源(节点、CPU)上一次执行多个作业的能力。默认状态是”NO“即不允许共享资源。 
  <ul>
<li>
<strong>EXCLUSIVE</strong>：可以将整个节点分配给作业。在 OverSubscribe = EXCLUSIVE 的分区中运行的作业将具有对所有分配节点的独占访问权限。比如CPU和GPU，但是内存却是按照分配所需的内存，因为有的作业挂起在内存中，内存不可以独占。</li>
<li>
<strong>FORCE</strong>：使分区中的所有资源(GRES 除外)都可以超额使用，而用户无法禁用它。可以后跟冒号和处于运行状态或挂起状态的最大作业数。例如FORCE：2表示每个资源最大可以有两个作业同时运行（如果资源分配合适的情况下）。</li>
<li>
<strong>YES</strong>：使分区中的所有资源(GRES 除外)可以根据作业的请求共享。只有当用户使用作业提交上的“–oversubscribe”选项显式请求时，资源才会超额申请使用。可以后跟冒号和处于运行状态或挂起状态的最大作业数。例如OverSubscribe = YES: 4表示每个节点可以运行四个作业。</li>
<li>
<strong>NO</strong>：选定的资源分配给一个作业。不会将任何资源分配给多个作业，同时禁止该作业被抢占。</li>
</ul> </li></ul> 
<p><strong>示例：</strong></p> 
<p>1、独占模式</p> 
<p><img src="https://images2.imgbox.com/73/9d/XCajJKpe_o.png" alt="独占模式"></p> 
<p>2、共享模式</p> 
<p><img src="https://images2.imgbox.com/48/7d/KpJSTGSC_o.png" alt="独占模式"></p> 
<ul><li><strong>OverTimeLimit</strong></li></ul> 
<p>​ 作业在被取消之前可以超过其时间限制的分钟数。通常情况下，一个工作的时间限制被视为一个硬限制，当达到这个限制时，该工作将被终止。配置 OverTimelimit 将导致作业的时间限制被视为软限制，给一个弹性的作业超额时间。</p> 
<ul><li><strong>PriorityJobFactor</strong></li></ul> 
<p>​ priority/multifactor插件在计算作业优先级时使用的分区因子。该值不能超过65533。</p> 
<ul><li><strong>ReqResv</strong></li></ul> 
<p>​ 指定此分区的用户在提交作业时必须指定预订。此选项可用于限制只允许在预订中使用优先级较高或额外资源的分区使用。可能的值是“ YES”和“ NO”。默认值是“ NO”。</p> 
<ul><li><strong>ResumeTimeout</strong></li></ul> 
<p>​ 从发出节点恢复请求到该节点实际可用之间允许的最长时间(以秒为单位)。在此时间框架内无法响应的节点将被标记为 DOWN，并且在该节点上安排的作业将被重新排队。</p> 
<ul><li><strong>RootOnly</strong></li></ul> 
<p>​ 指定此分区中是否只有用户root可以分配资源。root用户可以为任何其他用户分配资源，但请求必须由root用户发起。可以防止用户直接使用这些资源。可能的值是“ YES”和“ NO”。默认值是“ NO”。</p> 
<ul><li><strong>Shared</strong></li></ul> 
<p>​ <em>Shared 配置参数已被 OverSubscribe 参数替换。</em></p> 
<ul>
<li> <p><strong>State</strong>:分区状态</p> 
  <ul>
<li>
<strong>UP</strong>：指示新作业可以在分区上排队，作业可以分配节点并从分区运行。</li>
<li>
<strong>DOWN</strong>：示新作业可以在分区上排队，但排队的作业不能分配节点并从分区运行。已经在分区上运行的作业将继续运行。必须显式取消作业以强制终止作业。</li>
<li>
<strong>DRAIN</strong>：指示不能在分区上排队新作业，作业提交请求将被拒绝 ，但是已经在分区上排队的作业可以被分配节点并运行。</li>
<li>
<strong>INACTIVE</strong>：指示不能在分区上排队新作业，已经排队的作业可能不会被分配节点并运行。</li>
</ul> </li>
<li> <p><strong>SuspendTime</strong></p> </li>
</ul> 
<p>​ 在此数秒内保持空闲或停机的节点将被暂停程序置于省电模式（降低频率或者关闭节点）。对于设置了此选项的多个分区中的节点，<strong>SuspendTime</strong>将取最长时间。如果未在任何分区上设置，则该节点将使用为整个群集设置的 SuspendTime 值。</p> 
<ul><li><strong>SuspendTimeout</strong></li></ul> 
<p>​ 从发出节点挂起请求到关闭节点之间允许的最长时间(秒)。此时，节点必须准备好根据新工作的需要发出恢复请求（手动）。如果未在分区上设置<strong>SuspendTimeout</strong>，则该节点将使用为整个群集设置的 <strong>SuspendTimeout</strong> 值。</p> 
<ul><li><strong>TRESBillingWeights</strong></li></ul> 
<p>​ 用于定义每种 TRES 类型的计费权重，这些权重将用于计算作业的使用情况。计费权重指定为 &lt; TRES type &gt; = &lt; TRES 计费权重 &gt; 。当一个任务在配置为 TRESBillingWeights = “ CPU = 1.0，Mem = 0.25 G，GRES/gpu = 2.0”的分区上分配了1个 CPU 和8 GB 内存时，计费的 TRES 将是: (1 * 1.0) + (8 * 0.25) + (0.* 2.0) = 3.0。</p> 
<p>被分配节点并运行。</p> 
<ul>
<li> <p><strong>INACTIVE</strong>：指示不能在分区上排队新作业，已经排队的作业可能不会被分配节点并运行。</p> </li>
<li> <p><strong>SuspendTime</strong></p> </li>
</ul> 
<p>​ 在此数秒内保持空闲或停机的节点将被暂停程序置于省电模式（降低频率或者关闭节点）。对于设置了此选项的多个分区中的节点，<strong>SuspendTime</strong>将取最长时间。如果未在任何分区上设置，则该节点将使用为整个群集设置的 SuspendTime 值。</p> 
<ul><li><strong>SuspendTimeout</strong></li></ul> 
<p>​ 从发出节点挂起请求到关闭节点之间允许的最长时间(秒)。此时，节点必须准备好根据新工作的需要发出恢复请求（手动）。如果未在分区上设置<strong>SuspendTimeout</strong>，则该节点将使用为整个群集设置的 <strong>SuspendTimeout</strong> 值。</p> 
<ul><li><strong>TRESBillingWeights</strong></li></ul> 
<p>​ 用于定义每种 TRES 类型的计费权重，这些权重将用于计算作业的使用情况。计费权重指定为 &lt; TRES type &gt; = &lt; TRES 计费权重 &gt; 。当一个任务在配置为 TRESBillingWeights = “ CPU = 1.0，Mem = 0.25 G，GRES/gpu = 2.0”的分区上分配了1个 CPU 和8 GB 内存时，计费的 TRES 将是: (1 * 1.0) + (8 * 0.25) + (0.* 2.0) = 3.0。</p> 
<p>​ 如果没有定义 TRESBillingWeights，则根据分配的 CPU 总数对作业进行计费。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>