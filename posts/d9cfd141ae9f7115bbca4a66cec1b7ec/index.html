<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C&#43;&#43;】哈希表的实现 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】哈希表的实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3> </h3> 
 <ul><li>
<ul><li>
<ul>
<li><a href="#_1">哈希是什么</a></li>
<li><a href="#_16">理解哈希</a></li>
<li><a href="#_19">哈希所用的容器</a></li>
<li><a href="#key_37">计算key值方法</a></li>
<li><a href="#_60">哈希的插入和查找</a></li>
<li><a href="#_145">解决哈希冲突</a></li>
<li>
<ul>
<li><a href="#_155">闭散列也叫开放寻址法</a></li>
<li><a href="#_182">开散列</a></li>
</ul> 
    </li>
<li><a href="#_204">哈希闭散列实现</a></li>
<li>
<ul><li>
<ul>
<li><a href="#_205">闭散列结构</a></li>
<li><a href="#_252">闭散列结构插入</a></li>
<li><a href="#_301">闭散列查找</a></li>
<li><a href="#_341">闭散列删除</a></li>
</ul> 
    </li></ul> 
    </li>
<li><a href="#_370">哈希开散列实现（链表式）</a></li>
<li>
<ul><li>
<ul>
<li><a href="#_371">开散列结构</a></li>
<li><a href="#_407">开散列结构插入</a></li>
<li><a href="#_460">开散列结构查找</a></li>
<li><a href="#_490">开散列结构删除</a></li>
</ul> 
    </li></ul> 
   </li>
</ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3>
<a id="_1"></a>哈希是什么</h3> 
<p><strong>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</strong></p> 
<p><strong>哈希表的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</strong></p> 
<p><strong>而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位</strong></p> 
<blockquote> 
 <p>搜索的效率取决于搜索过程中元素的比较次数，因此顺序结构中查找的时间复杂度为O ( N ) O(N)O(N)，平衡树中查找的时间复杂度为树的高度O ( l o g N ) O(logN)O(logN)。</p> 
</blockquote> 
<blockquote> 
 <p>而最理想的搜索方法是，可以不经过任何比较，一次直接从表中得到要搜索的元素，即查找的时间复杂度为O ( 1 ) O(1)O(1)。</p> 
</blockquote> 
<blockquote> 
 <p>如果构造一种存储结构，该结构能够通过某种函数使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时就能通过该函数很快找到该元素。</p> 
</blockquote> 
<h3>
<a id="_16"></a>理解哈希</h3> 
<blockquote> 
 <p>哈希函数是一将输入（通常是一个大的数据集）映射到固定大小的输出的函数。哈希函数的一个重要特性是，无论输入数据的大小如何，其输出长度都是固定的（如果哈希函数输出长度不固定，将会导致数据分布不均匀或桶的大小不明确，影响哈希表的性能），这使得哈希函数非常有用，因为它可以将大量的数据快速映射到一个较小的范围内。</p> 
</blockquote> 
<h3>
<a id="_19"></a>哈希所用的容器</h3> 
<blockquote> 
 <p>unordered_map和unordered_set都是C++标准库中的容器，用于存储一组元素。它们的底层实现都是基于哈希表。</p> 
</blockquote> 
<blockquote> 
 <p>unordered_map是一种关联容器，它存储一组键值对（key-value pairs）。每个键都唯一且与一个值相关联。unordered_map使用哈希函数将键映射到特定的存储桶（bucket），并且在桶中存储值。由于使用哈希表实现，unordered_map的插入、查找和删除操作都具有常数平均时间复杂度。</p> 
</blockquote> 
<blockquote> 
 <p>unordered_set是一种集合容器，它存储一组唯一的元素。unordered_set使用哈希函数将元素映射到特定的存储桶，并在桶中存储元素。与unordered_map类似，unordered_set的插入、查找和删除操作也具有常数平均时间复杂度。</p> 
</blockquote> 
<blockquote> 
 <p>unordered_map和unordered_set的区别在于unordered_map存储的是键值对，而unordered_set只存储值。因此，unordered_map可以用来解决需要根据键快速查找对应值的问题，而unordered_set则可以用来快速判断一个值是否存在于集合中。</p> 
</blockquote> 
<blockquote> 
 <p>优点：</p> 
</blockquote> 
<ul>
<li>查询速度快：由于使用哈希表实现，unordered_map和unordered_set的查询操作具有常数平均时间复杂度。</li>
<li>高效的插入和删除：插入和删除元素的操作也具有常数平均时间复杂度。</li>
<li>灵活性：可以存储不同类型的键和值。</li>
</ul> 
<blockquote> 
 <p>缺点：</p> 
</blockquote> 
<ul>
<li>内存消耗较大：由于需要维护哈希表，unordered_map和unordered_set通常会消耗比较多的内存空间。</li>
<li>无序性：元素在容器中的存储位置是无序的，无法保证元素的顺序。</li>
</ul> 
<h3>
<a id="key_37"></a>计算key值方法</h3> 
<blockquote> 
 <p>哈希计算存储关键码的方法有以下几种：</p> 
 <ol><li>直接定址法（<strong>常用</strong>）：<br> 取关键字的某个线性函数为哈希地址：H a s h ( K e y ) = A ∗ K e y + B</li></ol> 
 <ul>
<li>思路：将关键码直接作为地址来存储，即 H(key) = key。适用于关键码分布比较均匀的情况。</li>
<li>区别：直接定址法不需要计算哈希值，直接使用关键码本身作为地址，因此查找效率很高。</li>
<li>优点：查找操作的平均时间复杂度为O(1)，即常数时间复杂度。</li>
<li>缺点：当关键码的分布不均匀时，会导致冲突（多个关键码映射到同一个地址），需要解决冲突的方法。</li>
</ul> 
 <ol start="2"><li>数字分析法：</li></ol> 
 <ul>
<li>思路：通过对关键码进行分析，选取其中具有代表性的数字作为哈希地址。例如，对身份证号码进行哈希存储时，可以选取其中的年份作为地址。</li>
<li>区别：数字分析法需要对关键码进行分析，并根据分析结果选择适合的数字作为地址，适用于某些特定的数据集。</li>
<li>优点：对于符合特定规律的数据集，数字分析法可以获得较好的哈希效果。</li>
<li>缺点：对于没有明显规律的数据集，数字分析法可能无法获得较好的哈希效果。</li>
</ul> 
 <ol start="3"><li>平方取中法：</li></ol> 
 <ul>
<li>思路：将关键码平方后，取中间的几位作为哈希地址。例如，对关键码 key 进行平方后，取中间的 m 位作为地址 H(key)。</li>
<li>区别：平方取中法通过平方运算对关键码进行转换，然后取中间的几位作为哈希地址。</li>
<li>优点：相对于直接定址法和数字分析法，平方取中法能够更加均匀地分布关键码，减少冲突的概率。</li>
<li>缺点：平方取中法需要进行额外的平方运算和位数操作，相比直接定址法和数字分析法，会增加一定的计算成本。</li>
</ul> 
 <ol start="4"><li>除留余数法（常用）：</li></ol> 
 <ul>
<li>思路：将关键码除以某个不大于哈希表大小的数，再取余数作为哈希地址。即 H(key) = key%p，其中 p 是一个不大于哈希表大小的素数。</li>
<li>区别：除留余数法通过除法和取余操作来计算哈希地址。</li>
<li>优点：除留余数法相对简单，计算速度快。</li>
<li>缺点：如果选取的素数 p 与关键码的特征相关，则可能导致冲突较多。</li>
</ul> 
</blockquote> 
<h3>
<a id="_60"></a>哈希的插入和查找</h3> 
<blockquote> 
 <p>数据集合{1，7，6，4，5，9}；</p> 
</blockquote> 
<blockquote> 
 <p>哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e4/53/70HncBFT_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>当我们在再次插入一个数值位<code>11</code>的时候，这时发现，如果我们已同样的方法进行插入的时候，就会与 1 下标位置的元素起到冲突。这时我们就要解决冲突问题，冲突问题在下方解决</p> 
</blockquote> 
<blockquote> 
 <ul><li>插入元素<br> 根据待插入元的关键码（在下边将介绍），以此函数计算出该元素的存储位置并按此位置进行存放</li></ul> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">//插入两种方法</span>
		<span class="token comment">//bool Insert(const T&amp; data)</span>
		pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			KeyOfT kot<span class="token punctuation">;</span><span class="token comment">//将不同对象进行提取</span>
			iterator it <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			Hash hash<span class="token punctuation">;</span>
			<span class="token comment">//进行扩容</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_n <span class="token operator">==</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//不调用自定义析构的方法</span>
				size_t newsize <span class="token operator">=</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">10</span> <span class="token operator">:</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
				vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">newtables</span><span class="token punctuation">(</span>newsize<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//for (Node*&amp; cur : _tables)</span>
				<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> cur <span class="token operator">:</span> _tables<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						Node<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
						size_t hashi <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> newtables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

						<span class="token comment">//头插到新列表</span>
						cur<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newtables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
						newtables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>
						cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				_tables<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>newtables<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			size_t hashi <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//头插</span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
			_tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
			_n<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span>newnode<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <ul><li>查找元素<br> 对元素的关键码进行同样的计算，把求得的函数值当作元素的存储位置，在结构中按此位置去元素比较，若关键码相等，则搜索成功</li></ul> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">//查找</span>
		iterator <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			Hash hash<span class="token punctuation">;</span><span class="token comment">//根据类型不同来计算他的整体key值</span>
			KeyOfT kot<span class="token punctuation">;</span><span class="token comment">//将不同对象进行提取查找对应值</span>
			size_t hashi <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> _tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_data<span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="_145"></a>解决哈希冲突</h3> 
<blockquote> 
 <p>数据集合{1，7，6，4，5，9}；</p> 
</blockquote> 
<blockquote> 
 <p>哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e4/53/70HncBFT_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>当我们在再次插入一个数值位<code>11</code>的时候，这时发现，如果我们已同样的方法进行插入的时候，就会与 1 下标位置的元素起到冲突。这时我们就要解决冲突问题</p> 
</blockquote> 
<blockquote> 
 <p><strong>解决哈希冲突</strong>两种常见的方法是：<strong>闭散列</strong>和<strong>开散列</strong></p> 
</blockquote> 
<h4>
<a id="_155"></a>闭散列也叫开放寻址法</h4> 
<p>开放寻址法（Open Addressing）：在每个哈希桶中直接存储键值对，当发生冲突时，通过一定的探索规则找到下一个可用的桶。<strong>常见的探索规则有线性探测、二次探测</strong>。</p> 
<p><strong>当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有<br> 空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。</strong></p> 
<p>开放寻址法不需要额外的内存来存储指针，且具有较好的缓存友好性，但当负载因子较高时，可能会导致连续冲突的概率增加，进而影响到性能。<br> <mark>线性探测</mark></p> 
<p><img src="https://images2.imgbox.com/9b/fe/LD3WRcMU_o.png" alt="在这里插入图片描述"><br> <strong>删除元素问题</strong><br> 采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索。比如删除元素4，如果直接删除掉，44查找起来可能会受影响。因此线性探测采用标记的伪删除法来删除一个元素。</p> 
<p><mark>二次探测</mark><br> 线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题，找下一个空位置的方法为：</p> 
<blockquote> 
 <p>Hi=(H0+i ^2)%m ( i = 1 , 2 , 3 , . . . )<br> H0：通过哈希函数对元素的关键码进行计算得到的位置。<br> H i：冲突元素通过二次探测后得到的存放位置。<br> m：表的大小。<br> <img src="https://images2.imgbox.com/7a/8c/mNFZ5kCY_o.gif" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>采用二次探测为产生哈希冲突的数据寻找下一个位置，相比线性探测而言，采用二次探测的哈希表中元素的分布会相对稀疏一些，不容易导致数据堆积。</p> 
<p>和线性探测一样，采用二次探测也需要关注哈希表的负载因子，例如，采用二次探测将上述数据插入到表长为20的哈希表，产生冲突的次数也会有所减少：<br> <img src="https://images2.imgbox.com/6d/34/cr57szcC_o.gif" alt="在这里插入图片描述"></p> 
<h4>
<a id="_182"></a>开散列</h4> 
<blockquote> 
 <p>在每个哈希桶中使用链表或其他数据结构存储冲突的键值对。当发生冲突时，新的键值对可以简单地添加到链表的末尾。这种方法简单易行，适用于频繁发生冲突的情况。链地址法的缺点是需要额外的内存来存储链表的指针，同时在处理大量冲突时，链表的遍历效率可能较低。</p> 
</blockquote> 
<p>例如，我们用除留余数法将序列{1, 6, 15, 60, 88, 7, 40, 5, 10}插入到表长为10的哈希表中，当发生哈希冲突时我们采用开散列的形式，将哈希地址相同的元素都链接到同一个哈希桶下，插入过程如下：<br> <img src="https://images2.imgbox.com/ce/fb/hwcRbRKG_o.gif" alt="在这里插入图片描述"><br> 闭散列解决哈希冲突，采用的是一种报复的方式，“我的位置被占用了我就去占用其他位置”。而开散列解决哈希冲突，采用的是一种乐观的方式，“虽然我的位置被占用了，但是没关系，我可以‘挂’在这个位置下面”。</p> 
<p>与闭散列不同的是，这种将相同哈希地址的元素通过单链表链接起来，然后将链表的头结点存储在哈希表中的方式，不会影响与自己哈希地址不同的元素的增删查改的效率，因此开散列的负载因子相比闭散列而言，可以稍微大一点。</p> 
<ul>
<li>闭散列的开放定址法，负载因子不能超过1，一般建议控制在[0.0, 0.7]之间。</li>
<li>开散列的哈希桶，负载因子可以超过1，一般建议控制在[0.0, 1.0]之间。</li>
</ul> 
<blockquote> 
 <p>在实际中，开散列的哈希桶结构比闭散列更实用，主要原因有两点</p> 
</blockquote> 
<ul>
<li>哈希桶的负载因子可以更大，空间利用率高。</li>
<li>哈希桶在极端情况下还有可用的解决方案。</li>
</ul> 
<p>哈希桶的极端情况就是，所有元素全部产生冲突，最终都放到了同一个哈希桶中，此时该哈希表增删查改的效率就退化成了O ( N )</p> 
<p><img src="https://images2.imgbox.com/61/b1/VNgyZRs6_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="_204"></a>哈希闭散列实现</h3> 
<h5>
<a id="_205"></a>闭散列结构</h5> 
<p>我们用枚举来表示它当前的状态</p> 
<pre><code class="prism language-cpp"><span class="token comment">//枚举：标识每个位置的状态</span>
<span class="token keyword">enum</span> <span class="token class-name">State</span>
<span class="token punctuation">{<!-- --></span>
	EMPTY<span class="token punctuation">,</span><span class="token comment">//为空</span>
	EXIST<span class="token punctuation">,</span><span class="token comment">//存在</span>
	DELETE<span class="token comment">//删除</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>设置当前状态的原因：</p> 
 <ul><li>当我们进行插入、查找、删除的时候，能够跟有效快捷的得到当前位置的状态。 
   <ul>
<li>当进行插入的时候，我们会时刻进行判断，判断此时的位置是否有值，直到遇到空或者删除状态的位置才会停下来进行存储。</li>
<li>当进行查找的时候，我们会时刻进行判断，当遇到状态为空的时候，我们就会直接退出，因为遇到空后就说明此时的范围已经没有我们要查值了。反过来如果我们要查找一个值<br> <img src="https://images2.imgbox.com/1c/44/0DNFe0HT_o.png" alt="在这里插入图片描述"><br> -当删除数据后，我们要将此时的位置设置为删除状态，这样在查找和插入的时候就不会出现错</li>
</ul> </li></ul> 
</blockquote> 
<blockquote> 
 <p>所以，我们在设置它结构的时候，我们要将它的每一个位置初始化为空状态，且还要加一个表的长度，防止表的负载过大。</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">//哈希表每个位置存储的结构</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">HashData</span>
<span class="token punctuation">{<!-- --></span>
	pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _kv<span class="token punctuation">;</span>
	State _state <span class="token operator">=</span> EMPTY<span class="token punctuation">;</span> <span class="token comment">//状态</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>创建一个类专门进行插入各种操作功能</p> 
<pre><code class="prism language-cpp"><span class="token comment">//哈希表</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">HashTable</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>HashData<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;&gt;</span> _table<span class="token punctuation">;</span> <span class="token comment">//哈希表</span>
	size_t _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//哈希表中的有效元素个数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5>
<a id="_252"></a>闭散列结构插入</h5> 
<blockquote> 
 <p>当进行插入的时候，我们需要注意它的扩容问题，在这里我们的负载因子一般控制在 0 ~ 0.7 之间，如果超过了这个范围，就需要扩容。<br> 当扩容时，我们不是原地扩，而是先设置一个新的容器，然后放大原先的两倍，再将所有数据挪过去，最后交换数组就可以了</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Find</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

			<span class="token comment">// 负载因子超过0.7就扩容</span>
			<span class="token comment">//if ((double)_n / (double)_tables.size() &gt;= 0.7)</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> _n <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">/</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">7</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				size_t newsize <span class="token operator">=</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">10</span> <span class="token operator">:</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
				HashTable<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> newht<span class="token punctuation">;</span>
				newht<span class="token punctuation">.</span>_tables<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// 遍历旧表，重新映射到新表</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> data <span class="token operator">:</span> _tables<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>_state <span class="token operator">==</span> EXIST<span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						newht<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>_kv<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>

				_tables<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>newht<span class="token punctuation">.</span>_tables<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			size_t hashi <span class="token operator">=</span> kv<span class="token punctuation">.</span>first <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// 线性探测</span>
			size_t i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			size_t index <span class="token operator">=</span> hashi<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>_tables<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">==</span> EXIST<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				index <span class="token operator">=</span> hashi <span class="token operator">+</span> i<span class="token punctuation">;</span>
				index <span class="token operator">%=</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token operator">++</span>i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			_tables<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_kv <span class="token operator">=</span> kv<span class="token punctuation">;</span>
			_tables<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">=</span> EXIST<span class="token punctuation">;</span>
			_n<span class="token operator">++</span><span class="token punctuation">;</span>

			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="_301"></a>闭散列查找</h5> 
<blockquote> 
 <p>在进行查找时，首先需要用哈希函数算出对应key值，然后剩下我们的工作只是遍历元素，查找对应的元素值。<br> 只需要看当前状态是否为存在或者删除，当遇到空时，说明所找元素不存在</p> 
</blockquote> 
<pre><code class="prism language-cpp">HashData<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			size_t hashi <span class="token operator">=</span> key <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// 线性探测</span>
			size_t i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			size_t index <span class="token operator">=</span> hashi<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>_tables<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">!=</span> EMPTY<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_tables<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">==</span> EXIST
					<span class="token operator">&amp;&amp;</span> _tables<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_kv<span class="token punctuation">.</span>first <span class="token operator">==</span> key<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> <span class="token operator">&amp;</span>_tables<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>

				index <span class="token operator">=</span> hashi <span class="token operator">+</span> i<span class="token punctuation">;</span>
				index <span class="token operator">%=</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token operator">++</span>i<span class="token punctuation">;</span>

				<span class="token comment">// 如果已经查找一圈，那么说明全是存在+删除</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> hashi<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="_341"></a>闭散列删除</h5> 
<p>删除哈希表中的元素非常简单，我们只需要进行伪删除即可，也就是将待删除元素所在位置的状态设置为DELETE。</p> 
<p>在哈希表中删除数据的步骤如下：</p> 
<ul>
<li>查看哈希表中是否存在该键值的键值对，若不存在则删除失败。</li>
<li>若存在，则将该键值对所在位置的状态改为DELETE即可。</li>
<li>哈希表中的有效元素个数减一。</li>
</ul> 
<p><strong>注意： 虽然删除元素时没有将该位置的数据清0，只是将该元素所在状态设为了DELETE，但是并不会造成空间的浪费，因为我们在插入数据时是可以将数据插入到状态为DELETE的位置的，此时插入的数据就会把该数据覆盖。</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			HashData<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				ret<span class="token operator">-&gt;</span>_state <span class="token operator">=</span> DELETE<span class="token punctuation">;</span>
				<span class="token operator">--</span>_n<span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="_370"></a>哈希开散列实现（链表式）</h3> 
<h5>
<a id="_371"></a>开散列结构</h5> 
<p>在开散列的哈希表中，哈希表的每个位置存储的实际上是某个单链表的头结点，即每个哈希桶中存储的数据实际上是一个结点类型，该结点类型除了存储所给数据之外，还需要存储一个结点指针用于指向下一个结点。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//每个哈希桶中存储数据的结构</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">HashNode</span>
<span class="token punctuation">{<!-- --></span>
	pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _kv<span class="token punctuation">;</span>
	HashNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span>

	<span class="token comment">//构造函数</span>
	<span class="token function">HashNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_kv</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>与闭散列的哈希表不同的是，在实现开散列的哈希表时，我们不用为哈希表中的每个位置设置一个状态字段，因为在开散列的哈希表中，我们将哈希地址相同的元素都放到了同一个哈希桶中，并不需要经过探测寻找所谓的“下一个位置”。</p> 
<p>哈希表的开散列实现方式，在插入数据时也需要根据负载因子判断是否需要增容，所以我们也应该时刻存储整个哈希表中的有效元素个数，当负载因子过大时就应该进行哈希表的增容。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//哈希表</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">HashTable</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">//typedef HashNode&lt;K, V&gt; Node;</span>
	vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> _table<span class="token punctuation">;</span> <span class="token comment">//哈希表</span>
	size_t _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//哈希表中的有效元素个数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5>
<a id="_407"></a>开散列结构插入</h5> 
<ul>
<li>若哈希表的负载因子已经等于1了，则先创建一个新的哈希表，该哈希表的大小为原哈希表的两倍，之后遍历原哈希表，将原哈希表中的数据插入到新哈希表，最后将原哈希表与新哈希表交换即可。</li>
<li><strong>重点： 在将原哈希表的数据插入到新哈希表的过程中，不要通过复用插入函数将原哈希表中的数据插入到新哈希表，因为在这个过程中我们需要创建相同数据的结点插入到新哈希表，在插入完毕后还需要将原哈希表中的结点进行释放，多此一举。</strong></li>
</ul> 
<blockquote> 
 <p>实际上，我们只需要遍历原哈希表的每个哈希桶，通过哈希函数将每个哈希桶中的结点重新找到对应位置插入到新哈希表即可，不用进行结点的创建与释放。<br> <img src="https://images2.imgbox.com/d0/ad/MX7Tn6oj_o.gif" alt="在这里插入图片描述"></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Find</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			Hash hash<span class="token punctuation">;</span>

			<span class="token comment">// 负载因因子==1时扩容</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_n <span class="token operator">==</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				size_t newsize <span class="token operator">=</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">10</span> <span class="token operator">:</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
				vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">newtables</span><span class="token punctuation">(</span>newsize<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//for (Node*&amp; cur : _tables)</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> cur <span class="token operator">:</span> _tables<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						Node<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>

						size_t hashi <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token operator">%</span> newtables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

						<span class="token comment">// 头插到新表</span>
						cur<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newtables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
						newtables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>

						cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>

				_tables<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>newtables<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			size_t hashi <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 头插</span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
			_tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

			<span class="token operator">++</span>_n<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="_460"></a>开散列结构查找</h5> 
<p>在哈希表中查找数据的步骤如下：</p> 
<ul>
<li>先判断哈希表的大小是否为0，若为0则查找失败。</li>
<li>通过哈希函数计算出对应的哈希地址。</li>
<li>通过哈希地址找到对应的哈希桶中的单链表，遍历单链表进行查找即可。</li>
</ul> 
<pre><code class="prism language-cpp">		Node<span class="token operator">*</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

			Hash hash<span class="token punctuation">;</span>
			size_t hashi <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> _tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">==</span> key<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> cur<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>

				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="_490"></a>开散列结构删除</h5> 
<p>在哈希表中删除数据的步骤如下：</p> 
<ul>
<li>通过哈希函数计算出对应的哈希桶编号。</li>
<li>遍历对应的哈希桶，寻找待删除结点。</li>
<li>若找到了待删除结点，则将该结点从单链表中移除并释放。</li>
<li>删除结点后，将哈希表中的有效元素个数减一。</li>
</ul> 
<pre><code class="prism language-cpp">		<span class="token keyword">bool</span> <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Hash hash<span class="token punctuation">;</span>
			size_t hashi <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			Node<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> _tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">==</span> key<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						_tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">else</span>
					<span class="token punctuation">{<!-- --></span>
						prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>

					<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>
					cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>