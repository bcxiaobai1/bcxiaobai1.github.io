<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C基础知识总结（全） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C基础知识总结（全）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8Fhello%20world%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px"><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8Fhello%20world%E8%AF%B4%E6%98%8E">第一个程序hello world说明</a></p> 
<p id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-toc" style="margin-left:0px"><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">计算机中的数据存储</a></p> 
<p id="%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8-toc" style="margin-left:40px"><a href="#%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8">数值型数据的存储</a></p> 
<p id="%E9%9D%9E%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8-toc" style="margin-left:40px"><a href="#%E9%9D%9E%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8">非数值型数据的存储</a></p> 
<p id="%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7-toc" style="margin-left:0px"><a href="#%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7">词法符号</a></p> 
<p id="%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px"><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a></p> 
<p id="%E6%A0%87%E8%AF%86%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px"><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB">数据类型的分类</a></p> 
<p id="%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px"><a href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B">整数类型</a></p> 
<p id="%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B(%E5%AE%9E%E5%9E%8B%20%E5%B0%8F%E6%95%B0)-toc" style="margin-left:80px"><a href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%28%E5%AE%9E%E5%9E%8B%20%E5%B0%8F%E6%95%B0%29">浮点类型(实型 小数)</a></p> 
<p id="%E7%A9%BA%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px"><a href="#%E7%A9%BA%E7%B1%BB%E5%9E%8B">空类型</a></p> 
<p id="%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81-toc" style="margin-left:0px"><a href="#%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81">原码、反码、补码</a></p> 
<p id="%E5%B8%B8%E9%87%8F-toc" style="margin-left:0px"><a href="#%E5%B8%B8%E9%87%8F">常量</a></p> 
<p id="%E5%AE%9E%E5%9E%8B%E5%B8%B8%E9%87%8F-toc" style="margin-left:40px"><a href="#%E5%AE%9E%E5%9E%8B%E5%B8%B8%E9%87%8F">实型常量</a></p> 
<p id="%C2%A0%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F-toc" style="margin-left:40px"><a href="#%C2%A0%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F"> 字符常量</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F-toc" style="margin-left:40px"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F">字符串常量</a></p> 
<p id="%E6%A0%87%E8%AF%86%E5%B8%B8%E9%87%8F(%E5%AE%8F%E5%AE%9A%E4%B9%89)-toc" style="margin-left:40px"><a href="#%E6%A0%87%E8%AF%86%E5%B8%B8%E9%87%8F%28%E5%AE%8F%E5%AE%9A%E4%B9%89%29">标识常量(宏定义)</a></p> 
<p id="%E5%8F%98%E9%87%8F-toc" style="margin-left:0px"><a href="#%E5%8F%98%E9%87%8F">变量</a></p> 
<p id="%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC-toc" style="margin-left:40px"><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC">变量的初始化和赋值</a></p> 
<p id="%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:40px"><a href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</a></p> 
<p id="%E6%98%BE%E5%BC%8F%E7%9A%84%E5%BC%BA%E8%BD%AC-toc" style="margin-left:80px"><a href="#%E6%98%BE%E5%BC%8F%E7%9A%84%E5%BC%BA%E8%BD%AC">显式的强转</a></p> 
<p id="%E9%9A%90%E5%BC%8F%E5%BC%BA%E8%BD%AC-toc" style="margin-left:80px"><a href="#%E9%9A%90%E5%BC%8F%E5%BC%BA%E8%BD%AC">隐式强转</a></p> 
<p id="%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:0px"><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></p> 
<p id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%3E%20%3C%20%3E%3D%C2%A0%20%3C%3D%20%3D%3D%C2%A0%20!%3D-toc" style="margin-left:40px"><a href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%3E%20%3C%20%3E%3D%C2%A0%20%3C%3D%20%3D%3D%C2%A0%20!%3D">关系运算符&gt; &lt; &gt;=  &lt;= ==  !=</a></p> 
<p id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></p> 
<p id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></p> 
<p id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%20%3D-toc" style="margin-left:40px"><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%20%3D">赋值运算符 =</a></p> 
<p id="%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%C2%A0%3F%3A-toc" style="margin-left:40px"><a href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%C2%A0%3F%3A">条件运算符 ?:</a></p> 
<p id="sizeof%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px"><a href="#sizeof%E8%BF%90%E7%AE%97%E7%AC%A6">sizeof运算符</a></p> 
<p id="%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7-toc" style="margin-left:40px"><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">运算符的优先级</a></p> 
<p id="%C2%A0%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84-toc" style="margin-left:0px"><a href="#%C2%A0%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"> 程序结构</a></p> 
<p id="%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-toc" style="margin-left:40px"><a href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">分支结构</a></p> 
<p id="if...else%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px"><a href="#if...else%E8%AF%AD%E5%8F%A5">if...else语句</a></p> 
<p id="switch..case%20%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px"><a href="#switch..case%20%E8%AF%AD%E5%8F%A5">switch..case 语句</a></p> 
<p id="%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-toc" style="margin-left:40px"><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">循环控制语句</a></p> 
<p id="%E4%BD%BF%E7%94%A8goto%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px"><a href="#%E4%BD%BF%E7%94%A8goto%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF">使用goto实现循环</a></p> 
<p id="while%20%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px"><a href="#while%20%E5%BE%AA%E7%8E%AF">while 循环</a></p> 
<p id="do..while%20%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px"><a href="#do..while%20%E5%BE%AA%E7%8E%AF">do..while 循环</a></p> 
<p id="for%20%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px"><a href="#for%20%E5%BE%AA%E7%8E%AF">for 循环</a></p> 
<p id="%E6%AD%BB%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px"><a href="#%E6%AD%BB%E5%BE%AA%E7%8E%AF">死循环</a></p> 
<p id="C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%B1%82n%E6%AC%A1%E6%96%B9%E5%92%8C%E5%BC%80%E6%96%B9%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%B1%82n%E6%AC%A1%E6%96%B9%E5%92%8C%E5%BC%80%E6%96%B9%E7%9A%84%E5%87%BD%E6%95%B0">C语言中求n次方和开方的函数</a></p> 
<p id="pow%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#pow%E5%87%BD%E6%95%B0">pow函数</a></p> 
<p id="sqrt%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#sqrt%E5%87%BD%E6%95%B0">sqrt函数</a></p> 
<p id="%E8%BE%85%E5%8A%A9%E6%8E%A7%E5%88%B6%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px"><a href="#%E8%BE%85%E5%8A%A9%E6%8E%A7%E5%88%B6%E5%85%B3%E9%94%AE%E5%AD%97">辅助控制关键字</a></p> 
<p id="break-toc" style="margin-left:80px"><a href="#break">break</a></p> 
<p id="continue-toc" style="margin-left:80px"><a href="#continue">continue</a></p> 
<p id="return-toc" style="margin-left:80px"><a href="#return">return</a></p> 
<p id="%E6%95%B0%E7%BB%84-toc" style="margin-left:0px"><a href="#%E6%95%B0%E7%BB%84">数组</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:80px"><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%A7%E8%B4%A8">一维数组的性质</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px"><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">一维数组的初始化</a></p> 
<p id="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px"><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></p> 
<p id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</a></p> 
<p id="%C2%A0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:40px"><a href="#%C2%A0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%A7%E8%B4%A8"> 二维数组的性质</a></p> 
<p id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px"><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">二维数组的初始化</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:0px"><a href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符数组和字符串</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">字符串处理函数</a></p> 
<p id="strlen()-toc" style="margin-left:80px"><a href="#strlen%28%29">strlen()</a></p> 
<p id="strcpy()-toc" style="margin-left:80px"><a href="#strcpy%28%29">strcpy()</a></p> 
<p id="strcat()-toc" style="margin-left:80px"><a href="#strcat%28%29">strcat()</a></p> 
<p id="strcmp()-toc" style="margin-left:80px"><a href="#strcmp%28%29">strcmp()</a></p> 
<p id="%E6%8C%87%E9%92%88-toc" style="margin-left:0px"><a href="#%E6%8C%87%E9%92%88">指针</a></p> 
<p id="%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97-toc" style="margin-left:40px"><a href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97">指针的运算</a></p> 
<p id="%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">指针和一维数组</a></p> 
<p id="%E6%8C%87%E9%92%88%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">指针和二维数组</a></p> 
<p id="%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-toc" style="margin-left:40px"><a href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88">数组指针</a></p> 
<p id="%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">指针数组</a></p> 
<p id="%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9Amain%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82-toc" style="margin-left:40px"><a href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9Amain%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82">指针数组的应用：main函数传参</a></p> 
<p id="%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px"><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">指针和字符串</a></p> 
<p id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88-toc" style="margin-left:40px"><a href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88">二级指针</a></p> 
<p id="const%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px"><a href="#const%E5%85%B3%E9%94%AE%E5%AD%97">const关键字</a></p> 
<p id="%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#%E5%87%BD%E6%95%B0">函数</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E-toc" style="margin-left:40px"><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E">函数的声明</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0-toc" style="margin-left:40px"><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0">函数的参数</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:40px"><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">函数的返回值</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px"><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F">函数的传参方式</a></p> 
<p id="%E5%85%A8%E5%B1%80%E4%BC%A0%E5%8F%82%C2%A0%20--%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%9F%BA%E6%9C%AC%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px"><a href="#%E5%85%A8%E5%B1%80%E4%BC%A0%E5%8F%82%C2%A0%20--%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%9F%BA%E6%9C%AC%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F">全局传参  --了解即可，实际开发过程中基本不使用这种方式</a></p> 
<p id="%E5%80%BC%E4%BC%A0%E9%80%92(%E5%A4%8D%E5%88%B6%E4%BC%A0%E5%8F%82)-toc" style="margin-left:80px"><a href="#%E5%80%BC%E4%BC%A0%E9%80%92%28%E5%A4%8D%E5%88%B6%E4%BC%A0%E5%8F%82%29">值传递(复制传参)</a></p> 
<p id="%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92(%E5%9C%B0%E5%9D%80%E4%BC%A0%E5%8F%82)-toc" style="margin-left:80px"><a href="#%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92%28%E5%9C%B0%E5%9D%80%E4%BC%A0%E5%8F%82%29">地址传递(地址传参)</a></p> 
<p id="%C2%A0%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px"><a href="#%C2%A0%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F">数组的传参方式</a></p> 
<p id="%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0">指针函数</a></p> 
<p id="%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-toc" style="margin-left:80px"><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">函数指针</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8Fhello%20world%E8%AF%B4%E6%98%8E">第一个程序hello world说明</h2> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
//#include 表示要包含的头文件
//头文件中一般存的都是函数的声明、类型的定义等
// stdio.h 是标准输入输出的头文件   printf函数的声明就在其中

// int 是函数的返回值类型
// main 是主函数 是程序的入口，每个程序有且仅有一个main函数
// ()里面是main函数的参数列表，可以空着，但()需要写
// {}里面是函数体，也是实际要执行的代码
// int main(){}
int main(int argc, const char *argv[])
{
    // printf 是一个输出函数 功能：将内容输出(打印)到终端
    // "" 里面的就是要打印的内容 n 表示换行 相当于回车
    //注意：c语言中 每条指令结束 都要一个 分号;
    printf("hello worldn");

    //函数的返回值
    return 0;
}

//单行注释

/*
多行
注释
*/</code></pre> 
<h2 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">计算机中的数据存储</h2> 
<p>        计算机中数据的存储分为两大块：数值型数据的存储 非数值型数据的存储</p> 
<h3 id="%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8">数值型数据的存储</h3> 
<blockquote> 
 <p>二进制(方便计算机处理的)</p> 
 <p>        逢2进1 每一位上的数字只能是 0 或者 1</p> 
 <p>        前导符：0b        如 0b10100011         0b11001010</p> 
 <p>十进制</p> 
 <p>        逢10进1 每一位上的数字是 0~9</p> 
 <p>        例如：520 1314</p> 
 <p>二进制转十进制</p> 
 <p>        从右向左</p> 
 <p>        101011 --&gt; 1*2^0 + 1*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 1*2^5 == 43</p> 
 <p>        其他进制转十进制都可以使用这种方式，只不过把底数的2 换成 对应进制的数即可。</p> 
 <p>二进制转十进制（用熟练了也可以使用8421方式转）：</p> 
 <p>        1000 8</p> 
 <p>        0100 4</p> 
 <p>        0010 2</p> 
 <p>        0001 1</p> 
 <p>        1100 1000+0100 = 8 + 4 = 12</p> 
 <p>十进制转二进制：</p> 
 <p>        除2取余法</p> 
 <p>        用十进制数除2，保存商和余数</p> 
 <p>        在用上继续除2，再保存商和余数</p> 
 <p>        直到商为0结束</p> 
 <p>        最后，将得到的余数倒着取，就得了对应的二进制</p> 
 <p>八进制</p> 
 <p>        逢8进1 每一位上的数字 0~7</p> 
 <p>        前导符 0        如 0567         0123</p> 
 <p>八进制转二进制：</p> 
 <p>        方法1：先将八进制转成十进制，然后十进制再转二进制</p> 
 <p>        方法2：每1位八进制数，对应3位二进制数</p> 
 <p>                <span style="color:#38d8f0">0</span><span style="color:#fe2c24">3</span><span style="color:#38d8f0">5</span>7 --&gt; <span style="color:#38d8f0">0</span><span style="color:#fe2c24">11</span><span style="color:#38d8f0">101</span><span style="color:#0d0016">111</span> --&gt; <span style="color:#fe2c24">11</span><span style="color:#38d8f0">101</span>111</p> 
 <p>同理 二进制 转八进制</p> 
 <p>        从右向左，每3位二进制数，对应1位八进制数，高位不足就补0</p> 
 <p>                <span style="color:#38d8f0">0b</span><span style="color:#fe2c24">011</span>011 --&gt; <span style="color:#fe2c24">3</span>3</p> 
 <p>十六进制</p> 
 <p>        逢16进1         a 10 b 11 c 12 d 13 e 14 f 15</p> 
 <p>        每一位上的数据 0~9 a~f</p> 
 <p>        前导符 0x        如：0x34 0x7f 0xcb</p> 
 <p>十六进制转二进制：</p> 
 <p>        方法1：先将十六进制转成十进制，然后十进制再转二进制</p> 
 <p>        方法2：每1位十六进制数，对应4位二进制数</p> 
 <p>                <span style="color:#38d8f0">0x</span><span style="color:#fe2c24">7</span>d ---&gt; <span style="color:#fe2c24">0111</span>1101</p> 
 <p>同理 二进制 转十六进制</p> 
 <p>        从右向左，每4位二进制数，对应1位十六进制数，高位不足就补0</p> 
 <p>                0b<span style="color:#fe2c24">0101</span>1011 --&gt; 0x<span style="color:#fe2c24">5</span>b</p> 
 <p>注意：不管几进制的数，在计算机中，最终都会转变成二进制处理。</p> 
</blockquote> 
<h3 id="%E9%9D%9E%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8">非数值型数据的存储</h3> 
<blockquote> 
 <p>因为计算机只能处理二进制的数值型数据，但是在实际的开发过程中，</p> 
 <p>经常会出现一些非数值型的数据，比如人名、地名、企业名。。。</p> 
 <p>我们需要让计算机能识别这些数据，于是科学家们就发明一种叫做 ascii 码的东西，</p> 
 <p>在linux系统中 使用命令 man ascii 就可以查ascii码表，</p> 
 <p>如果说代码中出现了 使用 单引号 或者双引号引住的数据，都是非数值型数据</p> 
 <p>"hqyj" 'm' '7'</p> 
 <p>常见的ascii码</p> 
 <p>        '' ---&gt; 0</p> 
 <p>        'n' ---&gt; 10</p> 
 <p>        '0'~'9' ---&gt; 48~57</p> 
 <p>        'A'~'Z' ---&gt; 65~90</p> 
 <p>        'a'~'z' ---&gt; 97~122</p> 
 <p>转义字符：</p> 
 <p>        所有的ascii码都可以使用 ''+一个八进制数来表示</p> 
 <p>        c语言中定义了一些字母前面加上 '' 来表示一些不能显示的 ascii 码</p> 
 <p>        如 'n' 't' '' 这些就称之为转义字符，因为后面的字母已经不是本身的含义了</p> 
</blockquote> 
<h2 id="%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7">词法符号</h2> 
<h3 id="%E5%85%B3%E9%94%AE%E5%AD%97">关键字</h3> 
<p>        关键字是系统中已经定义好的一些词汇，直接使用即可。</p> 
<pre><code class="language-cs">char short int long float double enum struct union signed unsigned void  --12个
auto  const  static  volatile register  extern  --6个
typedef
sizeof
if else switch case default break do while for return continue goto --12个</code></pre> 
<p>        注意：C语言是严格区分大小写的，关键字都是小写的。</p> 
<h3 id="%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</h3> 
<blockquote> 
 <p>所谓的标识符，就是自己在代码中起的名字，函数名、变量名、结构体名。。。等</p> 
 <p>自己起名时要符合标识符的命名规范：（起的名字尽量做到望文知义）</p> 
 <p>        1.由数字、字母、下划线组成</p> 
 <p>        2.不能以数字开头</p> 
 <p>        3.不能和关键字冲突</p> 
</blockquote> 
<h2 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</h2> 
<blockquote> 
 <p>C语言的本质是 <span style="color:#fe2c24">操作内存</span></p> 
 <p>内存和硬盘的区别：</p> 
 <p>        内存：数据掉电丢失</p> 
 <p>        硬盘：数据掉电不丢失</p> 
 <p><span style="color:#fe2c24">内存分配的最小单位 字节</span></p> 
 <p>        1bit 一个比特位 只能存储一个1或者0</p> 
 <p>        1Byte 一个字节 1Byte = 8bit</p> 
 <p>        1KB 1024B</p> 
 <p>        1MB 1024KB</p> 
 <p>        1GB 1024MB</p> 
 <p>        1TB 1024GB</p> 
 <p>数据类型的作用：<span style="color:#fe2c24">相当于一个模子，规定了由他定义的变量占用的内存空间的大小。</span></p> 
</blockquote> 
<h3 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB">数据类型的分类</h3> 
<blockquote> 
 <p>基本类型：</p> 
 <p>        整数类型、浮点类型(实型 小数)、枚举</p> 
 <p>构造类型：</p> 
 <p>        数组、结构体、共用体</p> 
 <p>指针类型：</p> 
 <p>空类型</p> 
</blockquote> 
<h4 id="%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B">整数类型</h4> 
<blockquote> 
 <p>        整数类型由分为 char 、short 、int 、long 、 long long</p> 
 <p>        其中，char 也叫字符类型：字符就是整型，整型就是字符，具体看我们怎么用。</p> 
 <p>        每种类型有分为 有符号的(signed) 和 无符号的(unsigned)</p> 
 <p>        <span style="color:#fe2c24">默认的就是有符号的</span>，对于有符号的数据 最高位 0 正数 1 负数</p> 
 <p>char 字符类型</p> 
 <p>        char 类型定义的变量在内存中占用 1字节 8bit</p> 
 <p>        存储的数据范围：</p> 
 <p>                无符号的：0 ~ 255</p> 
 <p>                有符号的：-128 ~ 127</p> 
 <p>        注意：为了防止正负0的问题，计算机中存储的是数据的补码，</p> 
 <p>                <span style="color:#fe2c24">规定 10000000 是 -128 的补码</span></p> 
 <p>        char类型多用于存储字符的ascii码，ascii码最大值是 127</p> 
 <p>short 短整型</p> 
 <p>        short 类型定义的变量在内存中占用 2字节 16bit</p> 
 <p>        存储的数据范围：</p> 
 <p>                无符号的：0 ~ 2^16-1</p> 
 <p>                有符号的：-2^15 ~ 2^15-1</p> 
 <p>int 整型</p> 
 <p>        int 类型定义的变量在内存中占用 4字节 32bit</p> 
 <p>        存储的数据范围：</p> 
 <p>                无符号的：0 ~ 2^32-1</p> 
 <p>                有符号的：-2^31 ~ 2^31-1</p> 
 <p>long 长整型 （也可以写成 long int）</p> 
 <p>        在32位系统中 和 int 一样</p> 
 <p>        在64位系统中 和 long long 一样</p> 
 <p>long long 长长整型（也可以写成 long long int）</p> 
 <p>        long long 类型定义的变量在内存中占用 8字节 64bit</p> 
 <p>        存储的数据范围：</p> 
 <p>                无符号的：0 ~ 2^64-1</p> 
 <p>                有符号的：-2^63 ~ 2^63-1</p> 
</blockquote> 
<h4 id="%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B(%E5%AE%9E%E5%9E%8B%20%E5%B0%8F%E6%95%B0)">浮点类型(实型 小数)</h4> 
<blockquote> 
 <p>float 类型</p> 
 <p>        单精度浮点型，占用4字节</p> 
 <p>double 类型</p> 
 <p>        双精度浮点型，占用8字节</p> 
 <p>long double 类型--了解就行</p> 
 <p>        多精度浮点型，32位系统 12字节 64位系统 16字节</p> 
</blockquote> 
<h4 id="%E7%A9%BA%E7%B1%BB%E5%9E%8B">空类型</h4> 
<blockquote> 
 <p>void 类型 是空类型 一般不单独使用 一般在指针中会用到</p> 
 <p>默认是不占用字节数的，具体和编译器有关</p> 
</blockquote> 
<h2 id="%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81">原码、反码、补码</h2> 
<blockquote> 
 <p>数据在存储的时候，涉及 原码 反码 补码 转换的问题。</p> 
 <p>        原码：方便人类识别的</p> 
 <p>        反码：用来做原码和补码转换的</p> 
 <p>        补码：是计算机中存放数据的形式</p> 
 <p>无符号数：不涉及负值，所以 原码 反码 补码 都是一样的</p> 
 <p>有符号正数：原码 反码 补码 都是一样的</p> 
 <p>有符号负数：</p> 
 <p>        反码 = 原码中符号位不变，数据位按位取反(1变0 0变0)</p> 
 <p>        补码 = 反码+1</p> 
 <p>方法：存储时看正负，取出时看类型(有无符号)</p> 
</blockquote> 
<h2 id="%E5%B8%B8%E9%87%8F">常量</h2> 
<blockquote> 
 <p>概念</p> 
 <p>        所谓的常量，就是在整个程序运行的过程中，值不会发生变化的量。</p> 
 <p>        一般多用于给变量赋值。</p> 
 <p>分类</p> 
 <p>                前导符         例如         输出占位符</p> 
 <p>整型常量</p> 
 <p>二进制         0b         0b1010         无</p> 
 <p>八进制         0           0567             %o</p> 
 <p>十进制         无         1314              %d</p> 
 <p>十六进制     0x          0x34cd          %x</p> 
 <p>实型常量</p> 
 <p>float                           3.14               %f</p> 
 <p>double                       5.28               %lf</p> 
 <p>字符常量                    'H'                  %c</p> 
 <p>字符串常量                "HQYJ"           %s</p> 
 <p>指数常量(类似于科学计数法）         %e</p> 
 <p>标识常量(宏定义)    --define</p> 
</blockquote> 
<h3 id="%E5%AE%9E%E5%9E%8B%E5%B8%B8%E9%87%8F">实型常量</h3> 
<blockquote> 
 <p>实型又称为浮点型，一般都是含有小数部分的。</p> 
 <p>在C语言中，只有十进制的实数，又分为单精度的(float) 和 双精度的(double)</p> 
 <p>浮点型存储涉及到小数的二进制，<span style="color:#fe2c24">实际存储的是一个拼凑的近似值。</span></p> 
 <p>表示方式有两种：</p> 
 <p>        一般形式： 3.14   5.28   7.89</p> 
 <p>                float %f         double %lf</p> 
 <p>        指数形式：</p> 
 <p>                [+/-]M.Ne[+/-]T 例如 -3.14e2 相当于 -3.14*10^2 == -314</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//printf函数默认会显示小数点后6位
	//超过的部分会 四舍五入
	//不足6位小数 会用0 补满6位显示
	float f1 = 3.141592653;
	printf("f1 = %fn", f1);
	printf("f1 = %.3fn", f1);//可以使用 %.nf 来指定显示 n 位小数

	float f2 = 3.14;
	printf("f2 = %fn", f2);

	//double 类型要用 %lf 输出
	double d1 = 3.141592653;
	printf("d1 = %lfn", d1);

	//也可以使用 %e 按指数形式输出
	double d2 = -31459;
	printf("d2 = %en", d2);

	float f3 = -3.1459e+4;//指数常量
	printf("f3 = %fn", f3);

	return 0;
}</code></pre> 
<p>代码结果：</p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/e9/17/BtTeAxN8_o.png" width="742"></p> 
<h3 id="%C2%A0%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F"> 字符常量</h3> 
<blockquote> 
 <p>字符：就是我们前面说的 一个 非数值型数据</p> 
 <p>格式：字符常量 必须使用 单引号 '' 引起来 且一个单引号里只能引一个字符</p> 
 <p>        'm' 'q' '8' 'n'</p> 
 <p><span style="color:#fe2c24">字符就是整型，整型就是字符，具体看我们怎么用。</span></p> 
 <p>        想输出字符---%c</p> 
 <p>        想输出ascii码---%d</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//定义了一个char 类型的变量 名字叫c1 存储的字符 是  'H'
	char c1 = 'H';
	printf("c1 = [%d] [%c]n", c1, c1);//[72] [H]

	char c2 = c1+2;
	printf("c2 = [%d] [%c]n", c2, c2);//[74] [J]

	char c3 = 10;
	printf("c3 = [%d] [%c]n", c3, c3);//[10] [
									   //]

	//如何将 字符的 '8' 转换成 整数的 8
	//'8'  8
	char num = '8';
	//num = num-48;
	num = num-'0';
	printf("num = %dn", num);

	//如何将 字符 'h' 转换成 'H'
	char num2 = 'h';
	//num2 = num2 - 32;
	num2 = num2 - ('a'-'A');
	printf("num2 = %cn", num2);//H

	return 0;
}</code></pre> 
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F">字符串常量</h3> 
<blockquote> 
 <p>字符串是由一个或多个组成</p> 
 <p>        格式：字符串常量需要用 双引号 "" 引起来</p> 
 <p>        如 "www.baidu.com"</p> 
 <p>在C语言中，<span style="color:#fe2c24">每个字符串结尾都会有一个隐藏的 '' 来标识字符串结束</span></p> 
 <p>注意：</p> 
 <p>        a 变量</p> 
 <p>        'a' 字符常量</p> 
 <p>        "a" 字符串常量</p> 
 <p>输出字符串，使用 %s 作为占位符</p> 
</blockquote> 
<h3 id="%E6%A0%87%E8%AF%86%E5%B8%B8%E9%87%8F(%E5%AE%8F%E5%AE%9A%E4%B9%89)">标识常量(宏定义)</h3> 
<blockquote> 
 <p>宏定义，就给表达式指定一个名字，使用这个名字，就是使用这表达式</p> 
 <p>是防止<span style="color:#fe2c24">魔鬼数字</span>的一种方式。</p> 
 <p>宏定义是在<span style="color:#fe2c24">预处理阶段</span>完成替换的，会将代码中所有使用宏名的地方，都用宏值替换。</p> 
 <p>也就是说，一旦宏定义的值变了，代码中所有使用他的位置都会变。</p> 
 <p>        格式： #define 宏名 宏值</p> 
 <p>其中 宏名 是一个标识符，要符和标识符的命名规范，一般情况下，宏名都大写。</p> 
 <p>        <span style="color:#fe2c24">注意：宏定义是一个简单的 无脑的替换。</span></p> 
</blockquote> 
<h2 id="%E5%8F%98%E9%87%8F">变量</h2> 
<blockquote> 
 <p>概念</p> 
 <p>        程序运行的过程中，值允许发生变化的量。</p> 
 <p>        变量一般多用于存储数据。</p> 
 <p>变量的大小：只取决于定义变量时的类型</p> 
 <p>变量名也是一个标识符，要符合命名规范</p> 
 <p>        定义变量的格式：</p> 
 <p>                存储类型 数据类型 变量名;</p> 
 <p>                存储类型：const static extern volatile register auto</p> 
 <p>                局部变量不写存储类型默认的都是 auto</p> 
</blockquote> 
<h3 id="%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC">变量的初始化和赋值</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//在定义变量的同时 给他一个初始值
	//这种方式就叫做变量的初始化
	int value1 = 100;
	printf("value1 = %dn", value1);//100


	//先定义变量，然后使用时再给他一个值
	//这种方式叫做变量的赋值
	int value2;
	printf("value2 = %dn", value2);//随机值
	value2 = 520;
	printf("value2 = %dn", value2);//520

	//变量如果没有初始化，里面存的就是随机值
	//有些时候随机值 会影响到我们，所以一般，不知道用什么值
	//给变量初始化时 可以用0初始化
	int value3 = 0;

	
	//可以使用常量给变量赋值
	//也可以使用变量给变量赋值
	value3 = value2;
	printf("value3 = %dn", value3);//520

	//变量也可以参与运算
	int result = value1 + value2;//只要不给变量赋值，运算就不会影响到变量原来的值
								//此处 value1 和 value2 的值不会变
	printf("result = %d  value1 = %d  value2 = %dn", result, value1, value2);// 620 100 520

	//同一个作用域(同一个{})内部，不允许定义重名的变量
	//int value3 = 123;
	
	//可以在一行里定义多个变量 中间用逗号分隔
	int a = 10, b = 10, c = 20, d = 30;
	printf("a = %d, b = %d, c = %d, d = %dn", a, b, c, d);// 10 10 20 30

	return 0;
}</code></pre> 
<h3 id="%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</h3> 
<blockquote> 
 <p>        强制类型转换(简称 强转)，就是通过某种方式，将表达式的值在某次运算的过程中，</p> 
 <p>转换成其他类型来参与运算</p> 
</blockquote> 
<h4 id="%E6%98%BE%E5%BC%8F%E7%9A%84%E5%BC%BA%E8%BD%AC">显式的强转</h4> 
<p>        格式 ： (新的类型名)表达式；</p> 
<p><span style="color:#fe2c24">强制类型转换是不安全的，要谨慎使用。</span></p> 
<p><span style="color:#fe2c24">如果是小的类型转换成大的类型，一般没什么问题，</span></p> 
<p><span style="color:#fe2c24">但是大的类型转换成小的类型，就有可能出现数据的丢失。</span></p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int a = 5;
	int b = 2;
	int c = a/b;
	printf("c = %dn", c);//结果是2
	//因为a和b是int 类型 计算的结果会舍弃小数位
	
     //注意：只是在本次运算中，a和b的值转换成float参与运算
     //a和b本身还是 int 类型
	float d = (float)a/(float)b;
	printf("d = %fn", d);//2.500000
	
	return 0;
}</code></pre> 
<h4 id="%E9%9A%90%E5%BC%8F%E5%BC%BA%E8%BD%AC">隐式强转</h4> 
<blockquote> 
 <p>由编译器根据上下文自动推导，隐式的做强制类型转换。</p> 
 <p>对于不安全的强转，编译器可能会报出一个警告，</p> 
 <p>有些编译器不报警告，具体取决于编译器的严谨程度。</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main()
{
	float f = 3.14;
	int value = f;//相当于取整操作 会舍弃小数位
					//int 存 float的整数位一定存的下  是安全的
	printf("f = %f   value = %dn", f, value);//3.14   3

	return 0;
}</code></pre> 
<p>注意：</p> 
<p><strong><span style="color:#fe2c24">        有符号数和无符号数运算时，会将有符号数强转成无符号数参与运算</span></strong></p> 
<p><strong><span style="color:#fe2c24">        运算的结果是一个无符号数。</span></strong></p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	unsigned char a = 6;
	signed char b = -20;
	if(a+b &gt; (unsigned)0){
		printf("yesn");//此处代码会执行，因为 a+b 表达式的结果是大于0的
	}
	return 0;
}</code></pre> 
<h2 id="%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</h2> 
<blockquote> 
 <p>概念</p> 
 <p>        运算符就是一个符号，用于多个值之间做运算</p> 
 <p>        运算符是用来连接表达式的</p> 
 <p>所谓的表达式：就是由运算量、运算符和标点符号等组成的一个有效序列，</p> 
 <p>能用来描述一个运算的过程。</p> 
 <p>分类</p> 
 <p>        按照类型区分：</p> 
 <p>        算数运算符： + - * / %(模除 取余数) ++ -- (<span style="color:#fe2c24">模除运算要求，左右操作数必须是整数。</span>)</p> 
 <p>        关系运算符： &gt; &lt; &gt;=</p> 
 <p>        逻辑运算符： &amp;&amp; || !</p> 
 <p>        位运算符： &amp; | ^ ~ &gt;</p> 
 <p>        赋值运算符： = += -= ...复合赋值运算符</p> 
 <p>        条件运算符： ?:</p> 
 <p>        sizeof运算符 ：计算变量或者类型占用的内存空间的大小的</p> 
 <p>        逗号运算符： (表达式1,表达式2,...,表达式n) (一般不用)</p> 
</blockquote> 
<blockquote> 
 <p>        <span style="color:#fe2c24">++ -- 运算符</span></p> 
 <p>        a++ &lt;==&gt;a = a+1</p> 
 <p>        ++a &lt;==&gt;a = a+1</p> 
 <p>        a--   &lt;==&gt;a = a-1</p> 
 <p>        --a   &lt;==&gt;a = a-1</p> 
 <p>以a++和++a为例：</p> 
 <p>        两种操作 a 的值都 +1 了，但是表达式的结果是不一样的</p> 
 <p>        a = 10;</p> 
 <p>        b = ++a;</p> 
 <p>上述两步操作之后 a = 11 b = 11</p> 
 <p>        a = 10;</p> 
 <p>        b = a++;</p> 
 <p>上述两步操作之后 a = 11 b = 10</p> 
 <p>a--和 --a 同理。</p> 
</blockquote> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/bf/1e/Gl7rnhZj_o.png"></p> 
<h3 id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%3E%20%3C%20%3E%3D%C2%A0%20%3C%3D%20%3D%3D%C2%A0%20!%3D">关系运算符&gt; &lt; &gt;=  &lt;= ==  !=</h3> 
<blockquote> 
 <p>关系运算符就是用来判断多个表达式之间的关系的，</p> 
 <p>关系运算符的表达式的结果是一个 布尔类型</p> 
 <p>布尔类型： 0 假 非0 真</p> 
 <p>一定要注意： == 和 = 的区别</p> 
 <p>        == 是关系运算符的判断相等</p> 
 <p>        = 是赋值运算符</p> 
</blockquote> 
<h3 id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</h3> 
<blockquote> 
 <p>逻辑运算符一般多用于连接多个由关系运算符组成的表达式</p> 
 <p>所以逻辑运算符的表达式的结果也是一个布尔类型。</p> 
 <p>&amp;&amp; 逻辑与 表示并且的意思</p> 
 <p>        逻辑与连接的多个表达式全为真，整个表达式的结果才为真</p> 
 <p>        有一个表达式为假，则整个表达式的结果就为假</p> 
 <p>|| 逻辑或 表示或者的意思</p> 
 <p>        逻辑或连接的多个表达式，有一个为真，则整个表达式就为真</p> 
 <p>        所有的表达式都为假，整个表达式才为假</p> 
 <p>! 逻辑非 表示逻辑取反的意思</p> 
 <p>        真变假 假变真</p> 
 <p>注意：下面的用法C语言不支持</p> 
 <p>                10 &lt; x &lt; 20</p> 
 <p>C语言需要写成 (x&gt;10 &amp;&amp; x &lt; 20)</p> 
 <p><span style="color:#fe2c24">逻辑运算符的短路原则：</span></p> 
 <p>逻辑与连接的多个表达式，如果有一个为假，则后面的表达式就都不执行了</p> 
 <p>逻辑或连接的多个表达式，如果有一个为真，则后面的表达式就都不执行了</p> 
</blockquote> 
<h3 id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</h3> 
<blockquote> 
 <p>位运算符是相对于二进制而言的，所以但凡涉及到位运算，计算机都会先将数据转换成</p> 
 <p>二进制，再参与运算，且一般位运算使用的都是无符号的数据，如果用有符号的可能会</p> 
 <p>设计原码、反码、补码相互转换的问题。</p> 
 <p>位运算一般多用于硬件设备的控制，及对标志位等的控制。</p> 
 <p>        &amp; 按位与 按位运算 全1为1 有0为0</p> 
 <p>        | 按位或 按位运算 有1为1 全0为0</p> 
 <p>        ~ 按位取反 按位运算 1变0 0变1</p> 
 <p>        ^ 按位异或 <span style="color:#fe2c24">不同为1 相同为0</span></p> 
 <p>        &lt;&lt; 左移运算 按位左移 低位补0 舍弃高位</p> 
 <p>        &gt;&gt; 右移运算 按位右移 高位补0 舍弃低位</p> 
 <p>位运算操作小技巧：</p> 
 <p>        1或任何数 都是1</p> 
 <p>        1与任何数 还是任何数</p> 
 <p>        0或任何数 还是任何数</p> 
 <p>        0与任何数 都是0</p> 
</blockquote> 
<h3 id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%20%3D">赋值运算符 =</h3> 
<blockquote> 
 <p>一般形式</p> 
 <p>左边 = 右边；</p> 
 <p>注意</p> 
 <p>        是将右边的值赋给左边</p> 
 <p>        左边一定是一个变量，不能是常量</p> 
 <p>注意</p> 
 <p>        = 和 == 区别</p> 
 <p>                = 赋值</p> 
 <p>                == 关系运算符 判断相等</p> 
 <p>复合赋值运算符</p> 
 <p>        += -= *= /= 等</p> 
 <p>        a+=b &lt;==&gt; a = a+b;</p> 
 <p>        a-=b  &lt;==&gt; a = a-b;</p> 
</blockquote> 
<p>详细的参考下图：</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/4d/41/2l3SRY7y_o.png"></p> 
<h3 id="%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%C2%A0%3F%3A">条件运算符 ?:</h3> 
<blockquote> 
 <p>也是C语言中唯一一个三目运算符。 有三个操作</p> 
 <p>        表达式1 ? 表达式2 : 表达式3;</p> 
 <p>执行逻辑：</p> 
 <p>        如果表达式1为真，则执行表达式2，否则执行表达式3</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int a = 10;
	int b = 20;
	int c = 0;

	c = (a&gt;b ? ++a : ++b);
	printf("a = %d  b = %d  c = %dn", a, b, c);//10 21 21 

	return 0;
}</code></pre> 
<h3 id="sizeof%E8%BF%90%E7%AE%97%E7%AC%A6">sizeof运算符</h3> 
<blockquote> 
 <p>sizeof运算符是用来计算变量或者类型的大小的。</p> 
 <p>单位是 字节。</p> 
 <p><span style="color:#fe2c24">注意sizeof的用法和函数调用很像，但是他是一个运算符 而不是函数</span></p> 
 <p>格式：</p> 
 <p>        sizeof(变量名或者类型名)</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	char a;
	short b;
	int c;
	long d;
	long long e;
	float f;
	double g;
	
	//sizeof的结果可以用变量保存
	int ret = sizeof(int);

	//也可以直接输出  64位系统 用 %ld 输出  32位系统用%d输出
	printf("sizeof(char) = %ld   sizeof(a) = %ldn", sizeof(char), sizeof(a));//1
	printf("sizeof(short) = %ld   sizeof(b) = %ldn", sizeof(short), sizeof(b));//2
	printf("sizeof(int) = %ld   sizeof(c) = %ldn", sizeof(int), sizeof(c));//4
	printf("sizeof(long) = %ld   sizeof(d) = %ldn", sizeof(long), sizeof(d));//8
	printf("sizeof(long long) = %ld   sizeof(e) = %ldn", sizeof(long long), sizeof(e));//8
	printf("sizeof(float) = %ld   sizeof(f) = %ldn", sizeof(float), sizeof(f));//4
	printf("sizeof(double) = %ld   sizeof(g) = %ldn", sizeof(double), sizeof(g));//8

	return 0;
}</code></pre> 
<h3 id="%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">运算符的优先级</h3> 
<blockquote> 
 <p>如果搞不清楚优先级，最好的方法是加括号 () 只要加的位置合理，加多了不算错</p> 
 <p>优先级顺口溜：</p> 
 <p>        <span style="color:#fe2c24">单算移关与，异或逻条赋。</span></p> 
</blockquote> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/70/5a/UswxEmqb_o.png"></p> 
<h2 id="%C2%A0%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"> 程序结构</h2> 
<blockquote> 
 <p>C语言的程序结构只有三种</p> 
 <p>        顺序结构</p> 
 <p>        分支结构(选择结构)</p> 
 <p>        循环结构</p> 
</blockquote> 
<h3 id="%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">分支结构</h3> 
<h4 id="if...else%E8%AF%AD%E5%8F%A5">if...else语句</h4> 
<pre><code class="language-cs">1.简化格式
if(表达式){
    代码块;//代码块允许有多行
}
执行逻辑：如果表达式为真 则执行代码块，如果为假，就不执行代码块

if(表达式){
    代码块1;
}else{
    代码块2;
}
执行逻辑：如果表达式为真 则执行代码块1，
        如果为假，则执行代码块2

2.阶梯格式
if(表达式1){
    代码块1;
}else if(表达式2){
    代码块2;
}else if(表达式n){
    代码块n;
}else{
    其他分支;
}
执行逻辑：
    如果表达式1为真，则执行代码块1，
    否则继续判断表达式2，如果为真，则执行代码块2
    否则继续向下判断，如果给的条件都不满足
    就走其他分支
    其中整个else模块可以没有，表示不关系其他分支的情况

3.嵌套格式
    执行逻辑和前面的一样，只不过是if..else 的嵌套使用
if(表达式1){
    if(表达式11){
        代码块11;
    }else if(表达式12){
        代码块12;
    }else{
        其他分支;
    }
}else if(表达式2){
    if(表达式21){
        代码块21;
    }else if(表达式22){
        代码块22;
    }else{
        其他分支;
    }
}else{
    其他分支
}</code></pre> 
<p>例如：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	printf("----start----n");
	int num = 0;
	scanf("%d", &amp;num);
	//简化格式
	#if 0
	if(num&gt;0){
		printf("yesn");
	}
	#endif
	#if 0
	if(num&gt;0){
		printf("yesn");
	}else{
		printf("non");
	}
	#endif

	//阶梯格式
	#if 0
	if(num&gt;0 &amp;&amp; num &lt;=10){
		printf("0&lt;num&lt;=10n");
	}else if(num &gt; 10 &amp;&amp; num&lt;=20){
		printf("10&lt;num&lt;=20n");
	}else{
		printf("othern");
	}
	#endif

	//嵌套格式
	if(0&lt;=num &amp;&amp; num&lt;=100){
		if(0&lt;=num &amp;&amp; num&lt;=50){
			printf("0~50n");
		}else{
			printf("51~100n");
		}
	}else if(100&lt;num &amp;&amp; num&lt;=200){
		printf("100~200n");
	}else{
		printf("othern");
	}

	printf("----end----n");
	return 0;
}</code></pre> 
<blockquote> 
 <p>注意事项：</p> 
 <p>1.if或者else if或者else后面的语句<span style="color:#fe2c24">只有一行时，{}可以不写</span></p> 
 <p>        但是注意，只要超过一行 就必须要加{}了</p> 
 <p>2.else不能独立出现，前面必须有if与之对应，否则报错</p> 
 <p>3.else和同一层次的前面与之最近的if结合</p> 
 <p>4.表达式一般是一个由关系运算符和逻辑运算符组成的表达式，用来判断真假的</p> 
 <p>        bool 类型 0假 非0真</p> 
 <p>如果表达式不是一个正常的，要注意下面的用法：</p> 
 <p>        if(a=b) //表达式的结果和b有关 b为0 假 b为非0 真</p> 
 <p>        if(a) //表达式的结果和a有关 a为0 假 a为非0 真 等价于 if(a!=0)</p> 
 <p>        if(!a) //表达式的结果和a有关 a为0 真 a为非0 假 等价于 if(a==0)</p> 
 <p>5.当同一层次中出现两个if与时</p> 
 <p>        if(xx){<!-- --></p> 
 <p>                xxx</p> 
 <p>        }</p> 
 <p>        if(xx){<!-- --></p> 
 <p>                xxx</p> 
 <p>        }</p> 
 <p>上面两个if语句 <span style="color:#fe2c24">相互之间是独立的 互不影响</span></p> 
 <p>6.分支控制语句，只会选择一条分支执行或者每条分支都不选。</p> 
</blockquote> 
<h4 id="switch..case%20%E8%AF%AD%E5%8F%A5">switch..case 语句</h4> 
<pre><code class="language-cs">switch(表达式){
    case 常量表达式1:
        代码块1;
        break;
    case 常量表达式2:
        代码块2;
        break;
    case 常量表达式n:
        代码块n;
        break;
    default:
        其他分支;
        break;
}</code></pre> 
<p>例如：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int num = 0;
	scanf("%d", &amp;num);

	switch(num){
		case 10://如果是字符类型  需要加 单引号
			printf("1111111111n");
			//break;//如果没有break 程序会继续执行下面分支的代码块
		case 20:
			printf("222222222222n");
			break;
		case 30:
			printf("3333333333n");
			break;
		default://如果不关心其他分支  整个default 分支可以不要
			printf("othern");
			break;
	}

	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24">注意事项</span></p> 
 <p>1.switch后面()里的表达式一般是一个变量，或者变量表达式</p> 
 <p>        case 后面的常量表达式就是这个变量的可能的结果</p> 
 <p>2.case后面的常量表达式一般是一个整型或者字符型，不能是浮点型</p> 
 <p>3.关于default分支，如果前面的所有case都不满足，就会统一交给default分支处理</p> 
 <p>        相当于if..else语句中的 else分支，如果不需要，可以不写。</p> 
 <p>4.每个分支结束，后面都要加上break，表示执行完该分支后结束整个switch..case 语句</p> 
 <p>如果不加break，程序会继续执行下面分支的语句，直到遇到break或switch..case语句结束</p> 
 <p>这种现象称之为：case击穿</p> 
</blockquote> 
<h3 id="%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">循环控制语句</h3> 
<h4 id="%E4%BD%BF%E7%94%A8goto%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF">使用goto实现循环</h4> 
<blockquote> 
 <p>说明</p> 
 <p>goto本来是用来做跳转的，只能在同一个函数中进行跳转。</p> 
 <p><span style="color:#fe2c24">goto的强制跳转对代码的可读性和逻辑性会有一定的影响，所以要慎用goto。</span></p> 
</blockquote> 
<pre><code class="language-cs">基本用法
代码块1;
    goto NEXT;
代码块2;
NEXT:
代码块3;

执行逻辑，先执行代码块1，然后遇到goto 直接跳转到对应的标签
    然后运行代码块3，   代码块2就被跳过了
NEXT： 就是标签名，是一个标识符，符合命名规范即可，一般使用大写居多

循环语句
代码块1;
HQYJ：
代码块2;
if(!结束条件){
    goto HYQJ;
}
代码块3;</code></pre> 
<p>例如：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	printf("1111n");
	goto NEXT;
	printf("2222n");//就不执行了
NEXT:
	printf("3333n");
	return 0;
}</code></pre> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int count = 0;
	printf("1111n");
NEXT:
	printf("2222n");
	count++;
	if(count &lt; 5){
		goto NEXT;
	}
	printf("3333n");
	return 0;
}</code></pre> 
<blockquote> 
 <p>注意：除了特殊场景需要用到死循环，绝大部分情况下使用的循环都是有结束条件的。</p> 
 <p>例如：</p> 
 <p>自己测试时，防止写出死循环刷屏 可以在循环中适当的加 sleep(1) 让进程休眠1秒</p> 
 <p>需要加头文件 #include &lt;unistd.h&gt;</p> 
</blockquote> 
<h4 id="while%20%E5%BE%AA%E7%8E%AF">while 循环</h4> 
<pre><code class="language-cs">while(表达式){
    循环体;//就是要循环执行的代码
}

执行逻辑：
 先执行表达式,如果表达式为真，则执行循环体，
 然后在执行表达式，如果还为真，则继续执行循环体
 直到表达式为假 循环立即结束 ， 继续执行循环后面的代码
 表达式的用法和 if 语句的表达式用法一样
 注意：循环体中一般都有能改变表达式结果的语句
     否则就是死循环了。</code></pre> 
<p>例如：使用while循环打印 5 行 hello world</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	printf("--start--n");
	int i = 0;//一般用来控制循环结束的变量我们称之为 循环变量
			//循环变量 的名字一般使用 i j k 即可
	while(i&lt;5){
		printf("hello worldn");
		i++;//用来改变表达式的结果 从而控制循环的结束的条件
	}
	printf("--end--n");//没有被循环的 {} 包住的部分  不受循环的控制

	return 0;
}</code></pre> 
<h4 id="do..while%20%E5%BE%AA%E7%8E%AF">do..while 循环</h4> 
<pre><code class="language-cs">do{
    代码块;
}while(表达式);
注意：do..while后面要有一个分号

执行逻辑：
和while是类似的，只不过while是先判断后执行
而do..while是不管条件为真还是为假，代码块都先执行一次</code></pre> 
<p>例如：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int i = 0;
	do{
		//不管while后面的条件为真还是为假
		//代码块都会先执行一次
		printf("hello worldn");
		i++;
	}while(i&lt;5);


	return 0;
}</code></pre> 
<h4 id="for%20%E5%BE%AA%E7%8E%AF">for 循环</h4> 
<pre><code class="language-cs">for(表达式1;表达式2;表达式3){
    循环体;
}

执行逻辑：
先执行表达式1，然后执行表达式2，如果表达式2为真
则执行循环体，然后执行表达式3，然后再执行表达式2，
如果还为真，则继续执行代码块和表达式3
直到表达式2为假 循环立即结束   继续执行循环后面的代码

表达式1：只执行一次  一般是用来给变量赋初值的
表达式2：和if  while的表达式是一样的，是用来判断真假的
表达式3：一般是用来修改表达式1中的变量的值，从而控制循环结束的</code></pre> 
<pre><code class="language-cs">// for 与 while 对比
//打印5行hello world
//while
int i = 0;
while(i&lt;5){
    printf("hello wroldn");
    i++;
}

//for
int i = 0;
for(i = 0; i &lt; 5; i++){
    printf("hello wroldn");
}</code></pre> 
<h4 id="%E6%AD%BB%E5%BE%AA%E7%8E%AF">死循环</h4> 
<blockquote> 
 <p>有些场景我们需要让程序一直运行，如后台的服务器程序等</p> 
 <p>就需要用到死循环 ---无限制的一直执行 直到我们手动让他退出</p> 
</blockquote> 
<pre><code class="language-cs">while(1){         //一般使用这种用法的居多
    //代码块
}

for(;;){  //表达式可以不写  但是两个分号必须写
    //代码块
}

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, const char *argv[])
{
	#if 0
	while(1){
		printf("hello worldn");
		sleep(1);
	}
	#endif
	for(;;){
		printf("hello worldn");
		sleep(1);
	}
	return 0;
}</code></pre> 
<h2 id="C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%B1%82n%E6%AC%A1%E6%96%B9%E5%92%8C%E5%BC%80%E6%96%B9%E7%9A%84%E5%87%BD%E6%95%B0">C语言中求n次方和开方的函数</h2> 
<blockquote> 
 <p>注意：math是三方库，不是系统提供的，所以编译时要链接库</p> 
 <p>需要加编译选项 -lm</p> 
</blockquote> 
<h4 id="pow%E5%87%BD%E6%95%B0">pow函数</h4> 
<blockquote> 
 <p>#include &lt;math.h&gt;</p> 
 <p>double pow(double x, double y);</p> 
 <p>功能：计算x的y次幂</p> 
 <p>返回值就是计算的结果</p> 
</blockquote> 
<h4 id="sqrt%E5%87%BD%E6%95%B0">sqrt函数</h4> 
<blockquote> 
 <p>#include &lt;math.h&gt;</p> 
 <p>double sqrt(double x);</p> 
 <p>功能： 计算x的非负平方根</p> 
 <p>返回值就是计算的结果</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(int argc, const char *argv[])
{
	int a = 2;
	int b = 3;
	float ret = pow(a, b);
	printf("ret = %fn", ret);//8

	ret = sqrt(16);
	printf("ret = %fn", ret);//4

	return 0;
}</code></pre> 
<h2 id="%E8%BE%85%E5%8A%A9%E6%8E%A7%E5%88%B6%E5%85%B3%E9%94%AE%E5%AD%97">辅助控制关键字</h2> 
<h4 id="break">break</h4> 
<blockquote> 
 <p>break关键字可以用在 switch..case 语句中，表示执行完某一分支就结束整个switch..case语句</p> 
 <p>break也可以用在循环中，表示立即结束本层循环</p> 
 <p>注意：break只能用在这两处，用在其他位置会报错。</p> 
</blockquote> 
<h4 id="continue">continue</h4> 
<blockquote> 
 <p>continue只能用在循环中，表示结束本层的本次循环。</p> 
</blockquote> 
<h4 id="return">return</h4> 
<blockquote> 
 <p>return 一般是用在子函数中，表示结束函数调用并返回函数运算的结果。</p> 
 <p>如果return用在主函数中，表示结束整个程序，后面的代码都不执行了。</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int i = 0;
	int j = 0;
	for(i = 0; i &lt; 5; i++){
		for(j = 0; j &lt; 5; j++){
			if(j==2){
				//break;
				//continue;
				return 0;
			}
			printf("%d--%dn", i, j);
		}
	}
	return 0;
}</code></pre> 
<h2 id="%E6%95%B0%E7%BB%84">数组</h2> 
<blockquote> 
 <p>概念</p> 
 <p>数组是用来管理一组相同数据类型的数据的</p> 
 <p>数组是一个构造类型</p> 
 <p>数组中保存的每个数据称为数组的元素或者数组的成员</p> 
 <p>数组在内存中需要分配一块连续的空间，<span style="color:#fe2c24">不管几维数组，在内存上都是连续的</span></p> 
</blockquote> 
<h3 id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</h3> 
<blockquote> 
 <p>概念</p> 
 <p>所谓的一维数组，就是下标只有一个的数组。一维数组的成员在内存上是连续的。</p> 
 <p>定义一维数组</p> 
 <p>        存储类型 数据类型 数组名[下标];</p> 
 <p>        存储类型：不写默认的就是 auto</p> 
 <p>        数据类型：数组中每个元素的类型，可以是基本类型、也可以数构造类型(数组除外)</p> 
 <p>        数组名： 是一个标识符，要符合标识符的命名规范</p> 
 <p>        下标： 在定义数组的时候，下标表示要定义的数组的长度，一般都是用常量</p> 
 <p>                在其他场景下，下标都表示访问数组中的第几个元素，</p> 
 <p>                可以是常量、也可以是变量、也可以是表达式</p> 
 <p>如： int s[10];</p> 
 <p>表示定义了一个数组，数组名为s 数组中的每个元素都是一个int ，数组中共有10个元素。</p> 
</blockquote> 
<h4 id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%A7%E8%B4%A8">一维数组的性质</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int s[5];
	//定义一个一维数组 数组名叫s 
	//数组中有5个元素 每个元素都是一个int类型
	
	//一维数组成员的访问
	//访问方式  数组名[下标]  下标是从0开始的
	//当取出一个成员后 使用方法 和一个int类型的变量的使用方法是一样的
	s[0] = 10;
	s[1] = 20;
	s[2] = 30;

	printf("s[0] = %dn", s[0]);//10
	printf("s[1] = %dn", s[1]);//20
	printf("s[2] = %dn", s[2]);//30
	printf("s[3] = %dn", s[3]);//随机值
	printf("s[4] = %dn", s[4]);//随机值

	//数组的成员在内存上是连续的
	//printf %p  打印变量的地址
	//  &amp;  取变量的地址	
	//printf("%p", &amp;变量);
	printf("&amp;s[0] = %pn", &amp;s[0]);//依次相差一个int
	printf("&amp;s[1] = %pn", &amp;s[1]);
	printf("&amp;s[2] = %pn", &amp;s[2]);
	printf("&amp;s[3] = %pn", &amp;s[3]);
	printf("&amp;s[4] = %pn", &amp;s[4]);

	//一维数组的数组名是一个常量
	//不能被赋值 也不能执行  ++ 等操作
	//s = 10;//错误的
	//s++;//错误的
	
	//一维数组的大小 = 数组中一个元素的大小  *  元素的个数
	printf("sizeof(s) = %ldn", sizeof(s));//20

	//当数组定义完成后，就不能整体赋值了
	//只能一个元素一个元素的赋值
	s[0] = 520;
	s[1] = 1314;
	//s = {520, 1314};//错误的
	
	//一维数组成员的遍历
	int i = 0;
	//for(i = 0; i &lt; 5; i++){
	for(i = 0; i &lt; sizeof(s)/sizeof(s[0]); i++){
		printf("%d  ", s[i]);
	}
	printf("n");

	return 0;
}</code></pre> 
<h4 id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">一维数组的初始化</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//一维数组如果没有初始化  那么成员都是随机值
	//int s[5];
	
	//一维数组的初始化
	//方式1：完全初始化
	//int s[5] = {10, 20, 30, 40, 50};

	//方式2：不完全初始化
	//注意：这种方式 是下标从小到大依次初始化 没有初始化的位 默认用0初始化
	//int s[5] = {10, 20, 30};
	
	//方式3：全都初始化成0 --常用
	//int s[5] = {0};
	
	//方式3：省略下标的初始化 这种方式 操作系统会根据
	//给定的元素的个数自动计算需要的空间的大小
	int s[] = {10, 20, 30, 40, 50};

	//数组一旦初始化了，就不能再整体赋值了
	//s = {1,2,3,4,5,};//错误的

	//一维数组的遍历
	int i = 0;
	for(i = 0; i &lt; 5; i++){
		printf("%d  ", s[i]);
	}
	putchar(10);

	//注意！！！！！！！！！
	//访问数组时，编译器不会检查数组越界的错误，数组越界需要
	//程序员自己控制，切记，不能越界访问
	//s[5] = 1314;//就已经是非法访问了  编译不报错  运行时错误不可预知

	return 0;
}</code></pre> 
<h3 id="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</h3> 
<blockquote> 
 <p>升序：从小到大</p> 
 <p>降序：从大到小</p> 
 <p>基本思想</p> 
 <p>        相邻的两个元素之间进行比较，按照要求(升序还是降序)进行交换。</p> 
 <p>        时间复杂度 是 O(n^2)</p> 
 <p>实现流程</p> 
 <p>以升序为例：</p> 
 <p>先进行第一趟排序，将第一个元素和第二个元素进行比较，将较大的放在第二个位置上，然后</p> 
 <p>第二个元素和第三个元素做比较，将较大的放在第三个位置上，依此类推，第一趟排序结束时，</p> 
 <p>最大的元素就在最后一个位置上了。</p> 
 <p>然后进行第二趟排序，将第一个元素和第二个元素进行比较，将较大的放在第二个位置上，然后</p> 
 <p>第二个元素和第三个元素做比较，将较大的放在第三个位置上，依此类推，第二趟排序结束时，</p> 
 <p>第二大的元素就在倒数第二个位置上了。</p> 
 <p>整个过程依此类推，直到最后一趟排序结束，整个数据就是有序的了。</p> 
</blockquote> 
<p>冒泡排序动图：</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/f1/c3/Amzisd0R_o.gif"></p> 
<p> 代码实现：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(){
    int s[10] = {1, 5, 3, 67, 53, 78, 900, 520, 1314, 666};
    //排序前
    int i = 0;
    for(i = 0; i &lt; 10; i++){
        printf("%d  ", s[i]);
    }
    printf("n");
    
    #if 0
    //先完成一趟排序
    int temp = 0;
    int len = sizeof(s)/sizeof(s[0]);
    for(i = 0; i &lt; len-1; i++){
        if(s[i] &gt; s[i+1]){
            //交换
            temp = s[i];
            s[i] = s[i+1];
            s[i+1] = temp;
        }
    }
    #endif
    
    //整个排序的流程
    int temp = 0;
    int len = sizeof(s)/sizeof(s[0]);
    int j = 0;
    //外层循环控制比较的趟数
    // len-1 是因为  最后一趟只剩一个元素了就不用排序了
    for(j = 0; j &lt; len-1; j++){
        //内层循环控制一趟排序比较的次数
        //因为每趟都能确定一个最值，最值在下一趟中就不用
        //再参与比较了，所以此处  len-1-j
        for(i = 0; i &lt; len-1-j; i++){
            if(s[i] &gt; s[i+1]){//如果是降序，只需要将此处的 &gt; 改成 &lt; 即可
                //交换
                temp = s[i];
                s[i] = s[i+1];
                s[i+1] = temp;
            }
        }
    }
    
    //排序后
    for(i = 0; i &lt; 10; i++){
        printf("%d  ", s[i]);
    }
    printf("n");
    
    return 0;
}</code></pre> 
<h2 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</h2> 
<blockquote> 
 <p>概念</p> 
 <p>        所谓的二维数组，就是有两个下标的数组。</p> 
 <p>定义二维数组的格式</p> 
 <p>        存储类型 数据类型 数组名[行数][列数];</p> 
 <p>        如：</p> 
 <p>                int s[3][4];</p> 
 <p>表示定义了一个二维数组，数组名叫s 数组元素都是int 类型</p> 
 <p>数组有3行4列 共计 12 个元素</p> 
 <p>注意：</p> 
 <p>虽然二维数组有行号和列号，但是本质都是一维数组(在内存上还是连续的)</p> 
 <p>其中列宽，决定了数组按行偏移时的跨度，也就是说列宽决定了二维数组的操作空间</p> 
</blockquote> 
<p>示意图：</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/41/ff/k5ko1HG5_o.png"></p> 
<h3 id="%C2%A0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%A7%E8%B4%A8"> 二维数组的性质</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int s[2][4];
	//定义了一个二维数组，数组名叫s  数组元素都是int 类型
	//数组有2行4列 共计 8 个元素
	
	//二维数组访问成员
	//数组名[行号][列号]   注意 行号和列号都是从0开始的
	s[0][0] = 520;
	s[0][1] = 1314;
	printf("s[0][0] = %dn", s[0][0]);//520
	printf("s[0][1] = %dn", s[0][1]);//1314
	printf("s[1][1] = %dn", s[1][1]);//随机值

	//二维数组的数组名也是一个常量
	//不能被赋值 也不能++
	//s = 123; //错误的
	//s++;		//错误的
	
	//二维数组的成员在内存上也是连续的
	printf("&amp;s[0][0] = %pn", &amp;s[0][0]);//依次相差4字节
	printf("&amp;s[0][1] = %pn", &amp;s[0][1]);
	printf("&amp;s[0][2] = %pn", &amp;s[0][2]);
	printf("&amp;s[0][3] = %pn", &amp;s[0][3]);
	printf("&amp;s[1][0] = %pn", &amp;s[1][0]);
	printf("&amp;s[1][1] = %pn", &amp;s[1][1]);
	printf("&amp;s[1][2] = %pn", &amp;s[1][2]);
	printf("&amp;s[1][3] = %pn", &amp;s[1][3]);

	//二维数组大小  =  行数  *  列数   * 一个元素的大小
	printf("sizeof(s) = %ldn", sizeof(s));//32

	//二维数组的遍历
     int i = 0;
     int j = 0;
     //外层循环控制行数
     for(i = 0; i &lt; 3; i++){
         //内层循环控制列数
         for(j = 0; j &lt; 4; j++){
             printf("%d  ", s[i][j]);
         }
         printf("n");
     }

	return 0;
}</code></pre> 
<h3 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">二维数组的初始化</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//二维数组如果没有初始化，成员也都是随机值
	//int s[3][4];
	
	//二维数组初始化的方式
	//以行为单位：
	//完全初始化
	//int s[3][4] = {<!-- -->{1,2,3,4},{5,6,7,8},{9,10,11,12}};
	//不完全初始化 没有初始化的位 默认用0初始化
	//int s[3][4] = {<!-- -->{1,2},{5},{9,10,11}};
	
	//不以行为单位：
	//完全初始化
	//int s[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
	//不完全初始化 没有初始化的位 默认用0初始化
	//int s[3][4] = {1,2,3,4,5};

	//全部初始化成0  --常用
	//int s[3][4] = {0};

	//省略行数的初始化
	//不够一行时，也会分配一整行的空间
	//列数一定不能省略 因为列宽决定了数组按行偏移时的跨度
	int s[][4] = {1,2,3,4,5,6,7,8,9};
	printf("sizeof(s) = %ldn", sizeof(s));//48

	//二维数组的遍历
	int i = 0;
	int j = 0;
	for(i = 0; i &lt; 3; i++){
		for(j = 0; j &lt; 4; j++){
			printf("%d  ",s[i][j]);
		}
		putchar(10);
	}

	return 0;
}</code></pre> 
<h2 id="%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符数组和字符串</h2> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//字符数组就是 char 类型的数组，每个元素都是一个char类型的变量
	char s1[5] = {'a','b','c','d','e'};
	s1[0] = 'A';
	s1[2] = 66;
	int i = 0;
	for(i = 0; i &lt; 5; i++){
		printf("%c", s1[i]);
	}
	putchar(10);

	//可以将字符串存在字符数组中
	//注意:使用字符数组存储字符串时，要多给 '' 留处一个字节的空间
	char s2[5] = {"QWER"};
	char s3[5] = "hqyj";

	//这种用法也可以，操作系统分配空间时会将 ''算进去 
	char s5[] = "www.hqyj.com";
	printf("sizeof(s5) = %ldn", sizeof(s5));//13

	//这种用法是错误的  因为 '' 会越界  错误就不可预知
	//char s4[4] = "hqyj";

	printf("%sn", s2);
	printf("%sn", s3);
	printf("%sn", s5);
	//注意：printf使用 %s 输出字符串时，本质是从指定的首地址开始
	//一直往后找  找到 '' 才结束 ，所以，如果不是字符串就不要使用 %s 输出
	//C语言中对字符串的处理基本上都是 找首地址和 ''
	printf("%sn", s1);//结果不可预知

	return 0;
}</code></pre> 
<h2 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">字符串处理函数</h2> 
<blockquote> 
 <p>字符串处理函数有很多个，都在 string.h 中声明的</p> 
 <p>使用时都需要加上头文件 #include &lt;string.h&gt;</p> 
 <p>strlen()   strcpy()   strcat()   strcmp()</p> 
</blockquote> 
<h4 id="strlen()">strlen()</h4> 
<blockquote> 
 <p>功能：</p> 
 <p>        计算字符串的长度(不包括 '')</p> 
 <p>函数原型：</p> 
 <p>        size_t strlen(const char *s);</p> 
 <p>参数：</p> 
 <p>        s：要计算长度的字符串</p> 
 <p>返回值：</p> 
 <p>        计算的结果</p> 
</blockquote> 
<h4 id="strcpy()">strcpy()</h4> 
<blockquote> 
 <p>功能：</p> 
 <p>        字符串的复制，将src复制到dest里面。</p> 
 <p>        注意，要保证dest足够大，否则可能出现数组越界访问。</p> 
 <p>函数原型：</p> 
 <p>        char *strcpy(char *dest, const char *src);</p> 
 <p>参数：</p> 
 <p>        src：源字符串</p> 
 <p>        dest: 目的字符串</p> 
 <p>返回值：</p> 
 <p>        dest</p> 
</blockquote> 
<h4 id="strcat()">strcat()</h4> 
<blockquote> 
 <p>功能：</p> 
 <p>        字符串的追加，将src追加到dest后面。dest的'' 会被覆盖</p> 
 <p>        注意，要保证dest足够大，否则可能出现数组越界访问。</p> 
 <p>函数原型：</p> 
 <p>        char *strcat(char *dest, const char *src);</p> 
 <p>参数：</p> 
 <p>        src：源字符串</p> 
 <p>        dest: 目的字符串</p> 
 <p>返回值：</p> 
 <p>        dest</p> 
</blockquote> 
<h4 id="strcmp()">strcmp()</h4> 
<blockquote> 
 <p>功能：</p> 
 <p>        比较两个字符串</p> 
 <p>        逐个比较两个字符串对应字符的ascii码</p> 
 <p>        只要出现大小关系就立即返回，</p> 
 <p>如果，直到两个字符串都到第一个''了，前面的都相等 才认为两个字符串相等</p> 
 <p>函数原型：</p> 
 <p>        int strcmp(const char *s1, const char *s2);</p> 
 <p>参数：</p> 
 <p>        s1 和 s2 就是参与比较的两个字符串</p> 
 <p>返回值：</p> 
 <p>        &gt;0         s1&gt;s2</p> 
 <p>        ==0       s1==s2</p> 
 <p>        &lt;0          s1&lt;s2</p> 
</blockquote> 
<h2 id="%E6%8C%87%E9%92%88">指针</h2> 
<blockquote> 
 <p>概念</p> 
 <p>        内存中每个字节的空间都会有一个编号，这个编号就是指针</p> 
 <p>        也叫作地址，保存指针的变量叫做指针变量。</p> 
 <p>只不过通常的情况下，我们常说的：</p> 
 <p>        地址：说的是内存地址</p> 
 <p>        指针：说的是指针变量</p> 
 <p>指针的相关操作</p> 
 <p>        &amp; : 获取变量的地址</p> 
 <p>        * : 在定义变量时，*只起到一个标识作用，标识定义的是一个指针变量</p> 
 <p>        其他场景下，取*操作都表示通过指针访问对应的地址上的数据</p> 
</blockquote> 
<p>指针和变量的关系</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/a6/34/slDP8znL_o.png"></p> 
<p> 指针的基本性质</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//内存中每个字节的空间都有一个编号，这个编号就是指针，也叫地址
	//当程序执行到定义变量的语句时 操作系统会根据类型给变量分配空间
	int a = 10;

	//通过变量名可以获取到变量的地址
	//  &amp; : 获取变量的地址  &amp;a  取到的是变量的首地址  编号最小的那个
	//  %p 输出地址
	printf("&amp;a = %pn", &amp;a);

	//常量没有地址可言
	//printf("&amp;100 = %pn", &amp;100);//错误的
	
	//普通变量是可以 存储 变量的地址的
	//但是一般 不会这么做
	//因为 没法通过保存地址的变量取访问对应的内存空间
	//下面例子 temp可以保存 a的地址  但是没法通过 temp 改变a的值
	//long temp = &amp;a;
	//printf("temp = %pn", temp);
	//*temp = 1314;//错误的 普通变量不允许做 * 操作

	//定义一个指针变量p 保存 变量a的地址的
	//也称为 指针p 指向 a
	//格式  数据类型  *指针变量名;
	int *p = &amp;a;
	printf("p = %pn", p);

	//通过p是可以操作 a所在的内存空间的
	*p = 1314;//*p 表示访问 p保存的地址中的数据
	printf("a = %dn", a);

	//指针保存了变量的地址后  有下面的关系
	//p &lt;==&gt; &amp;a
	//a &lt;==&gt; *p
	printf("p = %p  &amp;a = %pn", p, &amp;a);
	printf("*p = %d  a = %dn", *p, a);

	//指针变量也是一个变量 也需要操作系统分配空间
	printf("&amp;p = %pn", &amp;p);

	//指针只能保存已经分配给你的空间的地址
	int *p2 = 0x123456;
	//printf("p2 = %pn", p2);  //可以保存  但是不能操作
	//*p2 = 520;//错误的
	
	//指针如果没有初始化 指向是不确定的 因为存的是随机值
	//这种指针叫做  野指针
	//野指针是有害的  错误不可预知
	//int *p3;//注意：代码中不要出现野指针
	
	//指针变量的初始化
	// NULL 空地址  0地址   NULL 本质   (void *)0
	int *p4 = NULL; //不确定要指向谁的指针先让他指向NULL
				//这种指针叫空指针
				//对空指针的操作  一定会段错误
	//*p4 = 1314;//段错误

	return 0;
}</code></pre> 
<h3 id="%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97">指针的运算</h3> 
<blockquote> 
 <p>指针的运算，本质就是，指针变量里面存的地址之间的运算。</p> 
 <p>所以，运算的操作就是有限的了</p> 
 <p>指针之间可以做</p> 
 <p>        算数运算 + - ++ --</p> 
 <p>        关系运算 &gt; &lt; &gt;=  &lt;= !=  ==</p> 
 <p>        赋值运算 =</p> 
 <p><span style="color:#fe2c24">同种类型的指针之间做运算才有意义，不同类型的指针做运算是没有意义的。</span></p> 
 <p></p> 
 <p>指针变量的大小</p> 
 <p>        32位系统 指针都是<span style="color:#fe2c24">4字节</span></p> 
 <p>        64位系统 指针都是<span style="color:#fe2c24">8字节</span></p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//指针类型 的作用
	//决定了从指针指向的编号开始，可以操作几个字节的空间
	//一般为了让指针操作的范围和指向的变量操作的范围一致
	//都使用和变量类型一致的指针
	int num = 1314;
	int *ppp = &amp;num;

	//对于两个变量而言 地址运算没有意义 因为地址都是有操作系统分的 是随机的
	//对数组来说  指针的运算是有意义的 因为数组成员在内存上是连续的
	int s[5] = {10,20,30,40,50};
	int *p2 = &amp;s[0];
	int *p3 = &amp;s[2];
	//两个指针做减法 差值 是相差的 指针的 数据类型的个数
	//而不是相差的字节数
	printf("p3 - p2 = %ldn", p3 - p2);//2 相差两个 int

	//指针的强制类型转换是 安全的
	char *q1 = (char *)p2;
	char *q2 = (char *)p3;
	printf("q2 - q1 = %ldn", q2 - q1);//8

	//一个指针+ 或着 - 一个整数n
	//表示： +  或者  -    n*sizeof(指针的类型) 个字节
	int *p4 = p2+4;//相当于 加了4 个int
	printf("*p4 = %dn", *p4);//50

	//两个指针是可以做关系运算的 但是一般也是在数组成员的地址中
	//比较大小才有意义  以大于为例 其他同理
	if(p3 &gt; p2){
		printf("yesn");
	}else{
		printf("non");
	}

	printf("--------------------n");
	int a = 10;
	int b = 10;
	int *hqyj1 = &amp;a;
	int *hqyj2 = &amp;b;
	if(hqyj1 == hqyj2){//比较的是 a和b的地址
		printf("yes1n");
	}
	if(*hqyj1 == *hqyj2){//比较的是  a和b的值
		printf("yes2n");
	}
	printf("--------------------n");

	//指针变量也是变量  变量之间是可以相互赋值的
	int *p5 = NULL;
	p5 = p2;//正确的
	p5 = p3;//正确的

	//注意下面的用法
	int s2[5] = {10,20,30,40,50};
	int *p = &amp;s2[0];
	int ret1 = *++p;
	printf("ret1 = %dn", ret1);//20 先算 ++p 然后对 ++p表达式的结果取 *操作
								// ++p 表达式的结果 是+之后的值
	printf("p = %p  &amp;s[1] = %pn", p, &amp;s2[1]);//相等
	p = &amp;s2[0];
	int ret2 = *p++;
	printf("ret2 = %dn", ret2);//10 先算 p++ 然后对 p++ 表达式的结果取 *操作
								// p++ 表达式的结果 是+之前的值
	printf("p = %p  &amp;s[1] = %pn", p, &amp;s2[1]);//相等

	return 0;
}</code></pre> 
<h3 id="%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">指针和一维数组</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int s[6] = {10,20,30,40,50,60};
	
	//分析 数组名[下标] 的方式访问成员  本质是
	//以数组第0个元素为参考 向后偏移 取 *操作 取出的元素
	//数组名是一个地址  只不过是一个地址常量
	printf("s[0] = %dn", s[0]);//10
	printf("*s = %dn", *s);//10
	printf("*(s+0) = %dn", *(s+0));//10
	printf("*(s+1) = %dn", *(s+1));//20

	//下面两种写法是等价的
	//*(s+i)  &lt;==&gt;  s[i]
	
	*(s+3) = 520;
	printf("s[3] = %dn", s[3]);

	//定义一个指针 指向一维数组首地址 数组名就是首地址
	//下面两种写法都可以
	int *p = s; //----常用
	//int *p = &amp;s[0];
	
	//注意:单独从数值来看  s  &amp;s[0]  &amp;s 是一样的
	//但是 记住任何时候不要对数组名取地址 相当于给数组升维了

	//指针指向一维数组后 有如下的等价关系
	//*(s+i)  &lt;==&gt;  s[i] &lt;==&gt; *(p+i)  &lt;==&gt; p[i]
	
	//通过指针也可以修改数组的成员
	*(p+4) = 1314;
	printf("%d  %d  %dn", s[4], *(s+4), p[4]);

	//p 和 s 的区别
	//s是数组名 是常量  不改变指向 也不能 ++
	//p是变量 可以改变指向 也可以进行 ++ 操作
	
	p = &amp;s[0];
	printf("p = %p   &amp;s[0] = %pn", p, &amp;s[0]);
	p++;
	printf("p = %p   &amp;s[1] = %pn", p, &amp;s[1]);

	//一维数组的遍历
	int i = 0;
	for(i = 0; i &lt; 6; i++){
		//printf("%d  ", s[i]);
		//printf("%d  ", *(s+i));
		//printf("%d  ", p[i]);
		printf("%d  ", *(p+i));
	}
	putchar(10);

	return 0;
}</code></pre> 
<h3 id="%E6%8C%87%E9%92%88%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">指针和二维数组</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int s[3][4] = {<!-- -->{1,2,3,4},
					{5,6,7,8},
					{9,10,11,12}};
	//分析一下二维数组数组名操作的空间
	//s : 二维数组数组名 他是一个行指针 操作的空间是一行元素
	printf("s = %pn", s);
	printf("s+1 = %pn", s+1);

	//*s : 对二维数组数组名 取 *操作 相当于对指针的降维
	//将行指针降维成列指针
	//*s 就是一个列指针了
	//s+i 表示偏移几行
	//(s+i) 和 *(s+i) 的值是一样的都是 地址
	//只不过类型不样  (s+i) 表示第i行的首地址  *(s+i) 第i行第0个元素的地址
	//也就是说  得取两次 * 才能取道 元素的值
	//s[i][j]  &lt;==&gt; *(s[i]+j)  &lt;==&gt; *(*(s+i)+j)
	
	//过程
	//s+i 是 第i行的地址
	//*(s+i) 是第i行第0个元素的地址
	//*(s+i)+j 是第i行第j个元素的地址
	//*(*(s+i)+j) 第i行第j个元素
	printf("s = %pn", s);
	printf("*s = %pn", *s);
	printf("*(s+0) = %pn", *(s+0));
	printf("*(s+1) = %pn", *(s+1));
	printf("**s = %dn", **s);
	printf("**(s+1) = %dn", **(s+1));
	printf("*(*(s+1)+0) = %dn", *(*(s+1)+0));
	printf("*(*(s+1)+0) = %dn", *(*(s+1)+1));

	//s[i] &lt;==&gt; *(s+i)
	printf("s[0] = %p  *(s+0) = %pn", s[0], *(s+0));
	printf("s[1] = %p  *(s+1) = %pn", s[1], *(s+1));
	printf("s[2] = %p  *(s+2) = %pn", s[2], *(s+2));

	
	//由于二维数组的数组名是一个行指针 操作的空间大于基本类型了
	//所以无法定义一个普通的指针保存二维数组的地址用来操作二维数组
	int *p = s;
	//(s+1) 偏移一行 4个int
	//(p+1) 偏移一个int  无法按行操作
	printf("*(p+1) = %dn", *(p+1));
	**s = 520;
	//**p = 1314;  普通的一级指针无法 取**操作


	//二维数组的遍历
	int i = 0;
	int j = 0;
	for(i = 0; i &lt; 3; i++){
		for(j = 0; j &lt; 4;j++){
			//printf("%d  ", s[i][j]);
			//printf("%d  ", *(s[i]+j));
			printf("%d  ", *(*(s+i)+j));
		}
		printf("n");
	}

	return 0;
}</code></pre> 
<h3 id="%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88">数组指针</h3> 
<blockquote> 
 <p>本质是一个指针，指向一个二维数组，数组指针也叫行指针。</p> 
 <p>数组指针多用于 函数中 二维数组传参。</p> 
</blockquote> 
<pre><code>#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int s[3][4] = {<!-- -->{1,2,3,4},
					{5,6,7,8},
					{9,10,11,12}};
	//定义数组指针的格式
	//数据类型  (*指针名)[列数];
	int (*p)[4] = s;

	//p+1操作的就是一行了

	//数组指针指向二维数组后 有如下等价关系
	//s[i][j] &lt;==&gt; *(s[i]+j) &lt;==&gt; *(*(s+i)+j)
	//p[i][j] &lt;==&gt; *(p[i]+j) &lt;==&gt; *(*(p+i)+j)
	
	//二维数组的遍历
	int i = 0;
	int j = 0;
	for(i = 0; i &lt; 3; i++){
		for(j = 0; j &lt; 4; j++){
			//printf("%d  ", s[i][j]);
			//printf("%d  ", *(s[i]+j));
			//printf("%d  ", *(*(s+i)+j));
			//printf("%d  ", p[i][j]);
			//printf("%d  ", *(p[i]+j));
			printf("%d  ", *(*(p+i)+j));
		}
		printf("n");
	}


	return 0;
}</code></pre> 
<h3 id="%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">指针数组</h3> 
<blockquote> 
 <p>本质是一个数组，数组中每个元素都是一个指针。</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//可以使用二维数组来保存多个字符串
	char name1[4][64] = {"zhangsan",
						"lisi",
						"xiaohong",
						"fulajimier.fulajimiluoweiqi.pujing"};
	printf("%sn", name1[0]);
	printf("%sn", name1[1]);
	printf("%sn", name1[2]);
	printf("%sn", name1[3]);
	//但是这种用法，会造成内存空间的严重浪费，因为二维数组每行的列数必须得一样
	//并且得以最长的为准

	//可以使用指针数组来处理这种情况
	//定义指针数组的格式
	//数据类型 *数组名[下标];
	//所为的指针数组 本质就是数组 只不过每个元素 都是一个指针
	//char *name2[4]; //定义了一个指针数组 数组名为 name 
	char *name2[4] = {NULL}; //定义了一个指针数组 数组名为 name 
					//数组中有4个元素 每个元素都是一个 char *指针
	//注意要和数组指针区分开：char (*name2)[4] = NULL;  这种写法就是数组指针了
	//数组中的一个元素的操作就和 一个 char * 类型的指针操作是一样的
	name2[0] = "zhangsan";
	name2[1] = "lisi";
	name2[2] = "xiaohong";
	name2[3] = "fulajimier.fulajimiluoweiqi.pujing";

	printf("name2[0] = %sn", name2[0]);
	printf("name2[1] = %sn", name2[1]);
	printf("name2[2] = %sn", name2[2]);
	printf("name2[3] = %sn", name2[3]);

	printf("sizeof(name2) = %ldn", sizeof(name2));//==sizeof(char *) * 4 = 32

	return 0;
}</code></pre> 
<h3 id="%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9Amain%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82">指针数组的应用：main函数传参</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//argc 是执行程序时  命令行的参数的个数
	//包括可执行文件名(a.out)在内
	printf("%dn", argc);

	//argv 是一个指针数组 数组中的指针分别执行
	//执行程序时 命令行传的参数
	//如 ./a.out aa bb cc dd
	printf("%dn", argc);//5
	printf("%sn", argv[0]);// ./a.out
	printf("%sn", argv[1]);// aa
	printf("%sn", argv[2]);// bb
	printf("%sn", argv[3]);// cc
	printf("%sn", argv[4]);// dd

	return 0;
}</code></pre> 
<h3 id="%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">指针和字符串</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	//可以定义一个字符数组保存字符串
	//s1是数组  定义在栈区
	//栈区的数据是允许修改的
	char s1[12] = "hello world";
	s1[0] = 'H';
	printf("s1 = %sn", s1);
	//栈区定义多个数组 即使存储了相同的字符串  他们也都时在不同空间的
	char s2[12] = "hello world";
	printf("s1 = %p   s2 = %pn", s1, s2);//不一样


	//也可以定义个指针 指向字符串
	//指针直接指向字符串  指向的字符串常量
	//字符串常量是不允许修改的
	char *p1 = "hello world";
	//p1[0] = 'H';//错误的 常量区的内容不能修改 一修改就会段错误
	printf("p1 = %sn", p1);
	//不管定义多少个指针  只要指向相同的字符串 那么地址都是一样的
	char *p2 = "hello world";
	char *p3 = "hello world";
	printf("p1 = %p   p2 = %p   p3 = %pn", p1, p2, p3);//一样的

	return 0;
}</code></pre> 
<h3 id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88">二级指针</h3> 
<blockquote> 
 <p>二级指针是用来保存一级指针的地址的。</p> 
 <p>一般多用于函数中 一级指针的地址作为参数传递时。</p> 
 <p>        int a = 10; //变量a</p> 
 <p>        int *p = &amp;a; //一级指针 p 保存变量的地址</p> 
 <p>        int **q = &amp;p; //二级指针 q 保存一级指针的地址</p> 
 <p>上面操作之后，有如下的等价关系：</p> 
 <p>        a  &lt;==&gt; *p &lt;==&gt; **q</p> 
 <p>        &amp;a &lt;==&gt; p &lt;==&gt; *q</p> 
 <p>        &amp;p &lt;==&gt; q</p> 
</blockquote> 
<p>变量 一级指针 二级指针 的关系示意图</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/5b/c0/juGFf9QZ_o.png"></p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	int a = 10;
	int *p = &amp;a;
	int **q = &amp;p;

	printf("a = %d    *p = %d   **q = %dn", a, *p, **q);
	printf("&amp;a = %p    p = %p    *q = %pn", &amp;a, p, *q);
	printf("&amp;p = %p    q = %pn", &amp;p, q);
	**q = 520;//通过二级指针 修改变量的值
	printf("a = %d    *p = %d   **q = %dn", a, *p, **q);


	//一级指针能保存一级指针的地址
	//但是只能保存 一级指针没法做 ** 操作
	int *temp = &amp;p;//能保存
	printf("temp = %pn", temp);
	//**temp = 1314;//但是不能取 **操作
	//所以 一般不这样使用
	
	return 0;
}</code></pre> 
<h3 id="const%E5%85%B3%E9%94%AE%E5%AD%97">const关键字</h3> 
<blockquote> 
 <p>const关键字 如果用来修饰变量，表示通过变量名不能修改变量的值。</p> 
 <p>        const int a = 10;</p> 
 <p>        a = 20;//错误的 const 修饰的变量 值不能修改</p> 
 <p><span style="color:#fe2c24">const 修饰指针：注意下面的用法</span></p> 
 <p><span style="color:#fe2c24">        const int *p;</span></p> 
 <p><span style="color:#fe2c24">        int const *p;</span></p> 
 <p><span style="color:#fe2c24">        int * const p;</span></p> 
 <p><span style="color:#fe2c24">        const int * const p;</span></p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int main(int argc, const char *argv[])
{
	const int a = 520;
	printf("a = %dn", a);//520  读a的值
	int b = a;//没问题  读取a的值 赋给b一份儿
	//a = 1314;//错误的 不能通过 a 修改他的值

	//const  int  *p;
	//int  const  *p;
	//int  *  const  p;
	//const  int  *  const  p;
	//const 修饰指针时 要看 const 和 * 的相对位置
	//如果 const 在 * 的左边  表示修饰的是  *p : 
	//		*p 不能改变  不能通过指针 修改指向的内容的值
	//		p  可以变 指针的指向能修改
	//如果 const 在 * 的右边  表示修饰的是  p : 
	//		p 不能改变  指针的指向不能修改
	//		*p 可以变 可以通过指针 修改指向的内容的值
	
	//const int *p;
	int m = 10;
	int n = 20;
	const int *p1 = &amp;m;
	//*p1 = 520;//错误的 不能通过指针 修改指向的内容的值
	m = 520;//通过m自己 是可以修改的
	p1 = &amp;n;//正确的 指针的指向能修改

	//int const *p;
	//和上面的用法一样 一般上面的用法比较常用
	
	//int * const p;
	int *const p2 = &amp;m;
	*p2 = 1314;//正确的  可以通过指针修改指向的内容的值
	printf("*p2 = %d   m = %dn", *p2, m);
	//p2 = &amp;n;//错误的 指针的指向不能修改
	

	//const int * const p;
	//指针的指向不能修改
	//也不能通过指针 修改指向的内容的值
	const int * const p = &amp;m;
	//*p = 123;//错误的
	//p = &amp;n;//错误的

	return 0;
}</code></pre> 
<h2 id="%E5%87%BD%E6%95%B0">函数</h2> 
<blockquote> 
 <p>概念</p> 
 <p>将实现某些功能的代码封装成代码块，当想使用这个功能时，只直接通过代码块的名字</p> 
 <p>就可以调用该部分的代码，无需每次重复写该代码，这个代码块就叫函数，代码块的名字</p> 
 <p>就叫函数名。如：strcpy printf 我们使用时，直接通过名字就能调到对应的功能。</p> 
 <p>函数的定义和调用</p> 
 <p>定义的格式</p> 
 <p>        返回值类型 函数名(形参列表){<!-- --></p> 
 <p>                函数体，也就是实现功能的代码块</p> 
 <p>                return 函数的返回值;</p> 
 <p>        }</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

//全局函数一旦定义好之后  就可以在其他函数中调用了
void my_hello(void){
	printf("function my_hellon");
}

//函数的定义一般定义在 main 函数外面 也就是全局处
//C语言的的语法是支持局部定义函数的 但是局部定义的函数 只在局部可用
//我们一般使用的时候 都是将函数定义在全局处  方便其他函数调用

//第一个int 是函数的返回值类型,如果函数没有返回值 可以写成 void
//my_add 是函数名 是一个标识符  要符合标识符的命名规范
//(int x, int y) 是函数的形式参数列表，简称形参表 作用是告诉调用者
//		如果使用该函数需要传递几个什么类型的参数
//		如果函数没有参数 ()里面可以空着 也可以写成 void 但是注意 () 必须要写
//{} 里面就是函数体 也就是 函数实现功能的代码块
int my_add(int x, int y){
	printf("%dn", x+y);
	my_hello();//没有参数的函数调用  () 必须要写
	
	return 0;//这是函数的返回值 返回的值要和 函数名前面的类型 一致
			//如果没有返回值  可以不写  或者 写  return;
	printf("hello world");//函数中遇到 return 就立即返回 后面的代码都不执行了
}

int main(int argc, const char *argv[])
{
	printf("-----start-----n");
	//通过函数名 就可以调用函数了
	//调用的时候，() 里面是函数的 实际参数列表 简称 实参表
	//  实参的作用是用来 初始化 形参   注意类型和个数要和形参表一致
	//  注意 是从左到右依次初始化
	my_add(10, 20);//遇到函数调用时 就跳转到对应的代码执行
					//执行完函数后 会返回到调用处 继续向下执行
         //函数如果不被调用，函数体是不会执行的
	printf("-----end-----n");
	return 0;
}</code></pre> 
<h3 id="%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E">函数的声明</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

//在一个代码中编写函数时，如果只是简单的将所有的函数都定义在
//main函数的上面，在main函数中是都可以调用的，但是函数之间互相调用的
//时候，就可能出现不认识的情况，为了避免这种情况 就需要用到函数的声明
//函数声明写在代码的最上面 能保证函数调用是不会出现不认识的情况

//函数声明的格式 用 分号 ; 替换 {函数体}
void my_function1();
void my_function2();

int main(int argc, const char *argv[])
{
	my_function1();
	return 0;
}

void my_function1(){
	printf("hellon");
	my_function2();
}

void my_function2(){
	printf("hqyjn");
}</code></pre> 
<h3 id="%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0">函数的参数</h3> 
<blockquote> 
 <p>函数为什么要有参数？</p> 
 <p>当函数实现功能的过程中，需要执行代码块，代码块需要用到某些值，</p> 
 <p>但是在函数内部又没有这些值，所以就需要调用函数时，将这些值以参数的形式传过来</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

//函数功能:计算两个整数的和
void my_add(int x, int y){
	//函数的形参也需要 操作系统分配空间 在栈区
	//函数形参的作用主用是用于将实参的值保存一份儿
	//在函数内部进行使用
	//函数内部如何修改 形参 都不会影响到实参 因为
	//形参和实参是在两块不同的内存空间上的
	printf("x = %d  y = %dn", x, y);//10 20
	x = 100;
	y = 200;
	printf("x = %d  y = %dn", x, y);//100 200
	int ret = x+y;
	printf("ret = %dn", ret);//300
}

int main(int argc, const char *argv[])
{
	int a = 10;
	int b = 20;
	my_add(a, b);//函数调用的时候 实参的类型和个数
                 //要和定义函数时形参的类型和个数保持一致
	printf("a = %d  b = %dn", a, b);//10  20
	printf("---end--n");
	return 0;
}</code></pre> 
<h3 id="%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">函数的返回值</h3> 
<blockquote> 
 <p>函数为什么要有返回值？</p> 
 <p>当函数执行完毕后，有些场景需要用到函数执行的结果，</p> 
 <p>这是就需要将结果返回给函数调用处。</p> 
 <p>一般情况下，自己封装的函数，都是有返回值的，因为可以通过返回值来判断函数的执行情况。</p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//函数声明时  可以只写类型 不写形参名
int my_sum(int);

int main(int argc, const char *argv[])
{
	int num = atoi(argv[1]);
	//ret中保存的就是函数的返回值
	int ret = my_sum(num);
	//后面的代码中 使用 ret 就相当于 使用了 函数的返回值
	int i = 0;
	for(i = 0; i &lt; ret; i++){
		printf("hello worldn");
	}

	//如果调用处不关心 函数的返回值  也可以不接他
	//不接受返回值  并不会影响 函数中的代码运行
	my_sum(100);

	return 0;
}

//定义时 必须要写 形参名 因为函数内部要使用这个名字
int my_sum(int n){
	int sum = 0;
	int i = 0;
	for(i = 1; i &lt;= n; i++){
		sum += i;
	}
	return sum;//如果有需要 可以将函数运算的结果 返回给调用处
				//注意 return 后面的表达式 的类型 要和 函数名前的类型一致
}</code></pre> 
<h3 id="%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F">函数的传参方式</h3> 
<h4 id="%E5%85%A8%E5%B1%80%E4%BC%A0%E5%8F%82%C2%A0%20--%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%9F%BA%E6%9C%AC%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F">全局传参  --了解即可，实际开发过程中基本不使用这种方式</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

//没有被任何{}扩住的变量 称之为 全局变量
//全局变量如果不初始化 默认是 0
//全局变量的生命周期是整个程序结束  生命周期:何时被回收
//全局变量的作用域是整个文件       作用域:在哪个范围可以访问他
int num = 100;

//函数功能 值自增
void my_func(){
	//这种被 {} 扩住的叫局部变量 生命周期和作用域都是最近的{}
	int num2 = 100;
	num++;
	num2++;
}

int main(int argc, const char *argv[])
{
	//如果局部变量和全局变量重名 采用局部优先原则
	//int num = 1314;
	printf("main:num = %dn", num);//100
	num = 520;
	printf("main:num = %dn", num);//520
	my_func();	
	printf("main:num = %dn", num);//521

	//printf("num2 = %dn", num2);//错误的 已经出了 num2 的作用域了

	return 0;
}</code></pre> 
<h4 id="%E5%80%BC%E4%BC%A0%E9%80%92(%E5%A4%8D%E5%88%B6%E4%BC%A0%E5%8F%82)">值传递(复制传参)</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

//形参只是将实参的值保存了一份
//不管函数中如何修改 形参  实参都不会发生变化
//原因是 他们根本就不在同一块内容空间 互不影响
int my_add(int x, int y){
	printf("&amp;x = %p  &amp;y = %pn", &amp;x, &amp;y);
	printf("x = %d   y = %dn", x, y);
	x = 100;
	y = 200;
	return x+y;
}

int main(int argc, const char *argv[])
{
	int a = 10;
	int b = 20;
	printf("&amp;a = %p  &amp;b = %pn", &amp;a, &amp;b);
	printf("a = %d   b = %dn", a, b);
	int ret = my_add(a, b);
	printf("ret = %dn", ret);
	printf("&amp;a = %p  &amp;b = %pn", &amp;a, &amp;b);
	printf("a = %d   b = %dn", a, b);

	return 0;
}
</code></pre> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center"><img alt="" src="https://images2.imgbox.com/46/a1/bGRmukTv_o.png"></h4> 
<h4 id="%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92(%E5%9C%B0%E5%9D%80%E4%BC%A0%E5%8F%82)">地址传递(地址传参)</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

//如果想在函数中改变 实参的值
//需要将实参的地址传给函数
//下面的函数中  x 和 y 相当于 值传递   z 相当于地址传递
int my_add(int x, int y, int *z){
	printf("&amp;x = %p  &amp;y = %p  z = %pn", &amp;x, &amp;y, z);
	printf("x = %d   y = %dn", x, y);
	*z = x+y;
}

int main(int argc, const char *argv[])
{
	int a = 10;
	int b = 20;
	int c = 0;//用来存储计算的结果
	printf("&amp;a = %p  &amp;b = %p  &amp;c = %pn", &amp;a, &amp;b, &amp;c);
	printf("a = %d   b = %d  c = %dn", a, b, c);
	int ret = my_add(a, b, &amp;c);
	//printf("ret = %dn", ret);//ret一般用来判断函数执行成功与失败 
							
	printf("&amp;a = %p  &amp;b = %p  &amp;c = %pn", &amp;a, &amp;b, &amp;c);
	printf("a = %d   b = %d  c = %dn", a, b, c);

	return 0;
}</code></pre> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/4b/ca/KzTkjUEW_o.png"></p> 
<h4 id="%C2%A0%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F"> 数组的传参方式</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

//打印字符串的函数
//因为字符串有明显的结束标志  '' 所以只需要传首地址就行
void my_printf_char(char *p){
	printf("%sn", p);
}

//遍历整形一维数组的函数
//整形数组是没有 '' 来标志结束的 所以需要首地址 和 长度 才能访问 !!!
void my_printf_int1(int *p, int len){// 比较常用的用法
	int i = 0;
	for(i = 0; i &lt; len; i++){
		printf("%d  ", p[i]);
	}
	//p[0] = 1314;//函数中通过指针修改数组成员  实参会发生变化
					//因为本身传递的就是数组的首地址
					//通过p是直接修改了数组的元素
	printf("n");
}
//一维数组传参时 这种用法也可以
//注意这种用法 p的本质也是一个指针  [6] 叫代码自注释 
void my_printf_int11(int p[6], int len){// 不常用
	printf("sizeof(p) = %ldn", sizeof(p));//8
	int i = 0;
	for(i = 0; i &lt; len; i++){
		printf("%d  ", p[i]);
	}
	printf("n");
}

//遍历二维数组的函数
//需要使用数组指针
void my_printf_int2(int (*p)[4], int hang){
	int i = 0;
	int j = 0;
	for(i = 0; i &lt; hang; i++){
		for(j = 0; j &lt; 4; j++){
			printf("%d  ", p[i][j]);
		}
		printf("n");
	}
}

int main(int argc, const char *argv[])
{
	char buff[32] = "hello";
	my_printf_char(buff);

	int s1[6] = {10,20,30,40,50,60};
	my_printf_int1(s1, 6);
	my_printf_int11(s1, 6);
	
	int s2[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
	my_printf_int2(s2, 3);

	return 0;
}</code></pre> 
<h4 id="%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0">指针函数</h4> 
<p>本质是一个函数，返回值是一个指针类型。</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

//返回值是一个指针类型的函数  就叫做指针函数
char *my_strcpy(char *dest, const char *src){
	char *temp = dest;
	while(*src != ''){
		*dest = *src;
		dest++;
		src++;
	}
	*dest = '';
	//指针函数可以返回由参数传递过来的地址
	return temp;
}

char value2 = 'M';

char *func(){
	char value = 'H';
	//注意 指针函数不能返回 局部变量的地址
	//因为局部变量占用的空间在函数结束时就被系统回收了
	//return &amp;value;//错误的
	
	//可以返回全局变量的地址
	//或者  static 修饰的局部变量的地址
	return &amp;value2;
}

int main(int argc, const char *argv[])
{
	char s1[32] = "beijing";
	char s2[32] = "hello world";
	char *ret = my_strcpy(s1, s2);
	printf("s1 = %sn", s1);
	printf("s2 = %sn", s2);
	printf("ret = %sn", ret);

	char *p = func();
	printf("%cn", *p);//'M'

	return 0;
}</code></pre> 
<h4 id="%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">函数指针</h4> 
<p>本质是一个指针，指向一个函数。</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int my_add(int x, int y){
	return x+y;
}

int main(int argc, const char *argv[])
{
	int a = 10;
	int b = 20;
	printf("%d + %d = %dn", a, b, my_add(a, b));

	//定义一个函数指针 指向一个函数
	//格式
	// 返回值类型 (*函数指针名)(函数的形参表);
	int (*p)(int, int) = NULL;
	//定义了一个函数指针 名字叫p  可以指向一个 
	//返回值为int 形参类表为 (int, int) 的函数
	
	//让指针指向函数 函数名就是函数的首地址
	p = my_add;

	//指向函数后 通过函数指针 也可以调用函数
	printf("%d + %d = %dn", a, b, p(a, b));

	return 0;
}</code></pre> 
<blockquote> 
 <p>函数指针经常使用的场景：<span style="color:#fe2c24">回调函数。</span></p> 
</blockquote> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

int my_add(int x, int y){
	return x+y;
}

int my_sub(int x, int y){
	return x-y;
}

//该函数只知道要对两个数做运算 但是具体做什么运算 它不知道
//所以预留了一个函数指针做位形参，具体的运算由 
//jisuan函数的调用者传递的第三个参数决定
int jisuan(int x, int y, int (*p)(int, int)){
	//也就是说 在函数里面通过函数指针调用函数 具体调用哪个函数
	//取决于 jisuan函数的调用者传递的第三个参数
	//相当于 你传什么 我就回头去调用什么 所以 叫做回调函数
	return p(x,y);
}

int main(int argc, const char *argv[])
{
	int a = 10;
	int b = 20;
	printf("%dn", jisuan(a, b, my_add));//30
	printf("%dn", jisuan(a, b, my_sub));//-10

	return 0;
}</code></pre> 
<p></p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>