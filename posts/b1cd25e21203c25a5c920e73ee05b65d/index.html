<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>csapp 2bomblab 《深入理解计算机系统》实验2拆炸弹 0基础超详细解析 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">csapp 2bomblab 《深入理解计算机系统》实验2拆炸弹 0基础超详细解析</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p>​</p> 
<h2>
<a id="csapp_lab2_bomb_0_2"></a>csapp lab2 bomb 《深入理解计算机系统》0基础超详细解析</h2> 
<h3>
<a id="_3"></a>总览</h3> 
<p>总共有六个炸弹，需要我们一一拆除。题目提供了可执行文件bomb与bomb.c，.c文件中只提供了主函数。我们需要反汇编bomb，从而推算出每一个phase的破解密码。<br> <br><br> <a href="#1">phase_1</a><br> <br><br> <a href="#2">phase_2</a><br> <br><br> <a href="#3">phase_3</a><br> <br><br> <a href="#4">phase_4</a><br> <br><br> <a href="#5">phase_5</a><br> <br><br> <a href="#6">phase_6</a><br> <br><br> <a href="#7">phase_secret</a><br> <a id="1"></a></p> 
<h2>
<a id="phase_1_20"></a>phase_1</h2> 
<pre><code class="prism language-markdown">/* Hmm...  Six phases must be more secure than one phase! */
    input = read_line();             /* Get input                   */
    phase_1(input);                  /* Run the phase               */
    phase_defused();                 /* Drat!  They figured it out!
                      * Let me know how they did it. */
printf("Phase 1 defused. How about the next one?n");
</code></pre> 
<p>接受输入后进行判断，判断通过会输出“Phase 1 defused. How about the next one?n”。为了拆除炸弹，我们需要推理出input是什么。<br> 命令详见书3.10.2<br> 现在终端输入gdb bomb进行gdb调试</p> 
<pre><code class="prism language-markdown">root@cc661f098d2e:/csapp/2bomb# gdb bomb
(gdb) disas phase_1
Dump of assembler code for function phase_1:
   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp
   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi
   0x0000000000400ee9 &lt;+9&gt;:     call   0x401338 &lt;strings_not_equal&gt;
   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax
   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;
   0x0000000000400ef2 &lt;+18&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp
   0x0000000000400efb &lt;+27&gt;:    ret    
End of assembler dump.
</code></pre> 
<p>根据注释&lt;string_not_equal&gt;易猜测：该函数为字符输入检测，在调用该函数前，给esi赋值，随后根据该函数的返回值判断是否执行explode_bomb爆炸，因此正确字符有可能存在于地址0x402400中。</p> 
<pre><code class="prism language-markdown">(gdb) x /s 0x402400
0x402400:       "Border relations with Canada have never been better."
</code></pre> 
<p>发现“Border relations with Canada have never been better.”<br> 接下来验证猜想</p> 
<pre><code class="prism language-markdown">Starting program: /csapp/2bomb/bomb 
warning: Error disabling address space randomization: Operation not permitted
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
</code></pre> 
<p>正确！<br> <a id="2"></a></p> 
<h2>
<a id="phase_2_65"></a>phase_2</h2> 
<p>反汇编phase_2得：</p> 
<pre><code class="prism language-markdown">(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc &lt;+0&gt;:     push   %rbp
   0x0000000000400efd &lt;+1&gt;:     push   %rbx
   0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp
   0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi
   0x0000000000400f05 &lt;+9&gt;:     call   0x40145c &lt;read_six_numbers&gt;
   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;
   0x0000000000400f10 &lt;+20&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;
   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax
   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)
   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;
   0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx
   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx
   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;
   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;
   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--disas 0x40145c
   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;
   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp
   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx
   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp
   0x0000000000400f42 &lt;+70&gt;:    ret    
End of assembler dump.

</code></pre> 
<p>发现首次调用了：0x0000000000400f05 &lt;+9&gt;: call 0x40145c &lt;read_six_numbers&gt;<br> 反汇编该函数，得：</p> 
<pre><code class="prism language-markdown">(gdb) disas 0x40145c
Dump of assembler code for function read_six_numbers:
   0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp
   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx
   0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx
   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax
   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)
   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax
   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)
   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9
   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8
   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi
   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax
   0x000000000040148a &lt;+46&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;
   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax
   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;
   0x0000000000401494 &lt;+56&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp
   0x000000000040149d &lt;+65&gt;:    ret    
End of assembler dump.

</code></pre> 
<p>发现固定地址0x0000000000401480 &lt;+36&gt;: mov $0x4025c3,%esi<br> 查看</p> 
<pre><code class="prism language-markdown">(gdb) x /s 0x4025c3
0x4025c3:       "%d %d %d %d %d %d"
</code></pre> 
<p>发现格式化字符放在此，且类型为int<br> 结合函数名称&lt;read_six_numbers&gt;，可以猜出，该函数的作用为读入输入的前六个字符。<br> 根据猜测进行验证。<br> 首先看phase_2的反汇编代码，</p> 
<pre><code class="prism language-markdown">0x0000000000400efc &lt;+0&gt;:     push   %rbp
0x0000000000400efd &lt;+1&gt;:     push   %rbx
0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp
</code></pre> 
<p>该函数开始时，&lt;+0&gt;&lt; +1&gt;将rbp rbx的值放入栈，&lt;+2&gt;为该函数开辟空间</p> 
<pre><code class="prism language-markdown">0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp
   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx
   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp

</code></pre> 
<p>结束时，&lt;+64&gt;回收栈空间,&lt;+68&gt;&lt;+69&gt;取回rbx，rbp的值。</p> 
<pre><code class="prism language-markdown">0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi
   0x0000000000400f05 &lt;+9&gt;:     call   0x40145c &lt;read_six_numbers&gt;

</code></pre> 
<p>接着，将rsi指向栈rsp，调用函数&lt;read_six_numbers&gt;</p> 
<pre><code class="prism language-markdown">0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp
   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx
</code></pre> 
<p>&lt;+0&gt;为该函数开辟空间，&lt;+4&gt;将rdx指向rsi。<br> 此得，该函数传入了一个指针地址。</p> 
<pre><code class="prism language-markdown">0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx
   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax
   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)
   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax
   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)
   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9
   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8

</code></pre> 
<p>&lt;+7&gt;为rsi+4。<br> &lt;+11&gt;rsi+0x14。<br> &lt;+20&gt;rsi+0x10。<br> &lt;+28&gt;rsi+0xc。<br> &lt;+32&gt;rsi+0x8。<br> 设rsi对应得的时num[0]，结合0x4025c3: “%d %d %d %d %d %d”。则以上分别对应的是：num[1],num[5],num[4],num[3],num[2]。并且&lt;+15&gt;num[5]，&lt;+24&gt;num[4]放入栈。类型为int，int占4字节。</p> 
<pre><code class="prism language-markdown">0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax
0x000000000040148a &lt;+46&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;
   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax
   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;
   0x0000000000401494 &lt;+56&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp
   0x000000000040149d &lt;+65&gt;:    ret    

</code></pre> 
<p>接下来，&lt;+41&gt;将rax置0，&lt;+46&gt;调用<a href="mailto:__isoc99_sscanf@plt">__isoc99_sscanf@plt</a>,&lt;+54&gt;判断eax是否大于5。&lt;+56&gt;若大于，&lt;+61&gt;则释放空间,返回&lt;+65&gt;;否则，&lt;+56&gt;调用&lt;explode_bomb&gt;，爆炸。由此，sscanf函数返回了输入字符串的个数，因此推断出，我们输入的数（因为类型为int）必须大于等于6个。<br> 因此可以大致推出read_six_number函数的原型等价为</p> 
<pre><code class="prism language-markdown">Void read_six_number(char *receive,int *num){
Char *style=“%d %d %d %d %d %d”
     int re=sscanf（receive,style,&amp;num[0] ,&amp;num[1] ,&amp;num[2] ,&amp;num[3] ,&amp;num[4] ,&amp;num[5] ,&amp;num[6]）;
if （re&lt;5）
    explode_bomb（）；
}
```返回phase_2
```markdown
0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;
   0x0000000000400f10 &lt;+20&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;
   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax
   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)
   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;
   0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx
   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx
   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;
   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;
   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--disas 0x40145c
   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;
</code></pre> 
<p>此时rsp的栈为<img src="https://images2.imgbox.com/5b/75/vdSFyVmC_o.jpg" alt="在这里插入图片描述"></p> 
<p>&lt;+14&gt;若rsp指向的内存值为1，&lt;+52&gt;则跳转，否则，&lt;+20&gt;爆炸。</p> 
<pre><code class="prism language-markdown">0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp

</code></pre> 
<p>此时，指向为<img src="https://images2.imgbox.com/3c/49/d9rOc8Xu_o.jpg" alt="在这里插入图片描述"></p> 
<p>注：c中不检查数组下标越界，因此rbp可以指向num[6]。</p> 
<pre><code class="prism language-markdown">0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax
   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)
   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;
   0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;
</code></pre> 
<p>&lt;+27&gt;Eax=num[0]<br> &lt;+30&gt;Eax=2<em>num[0]<br> &lt;+32&gt;if（eax==(rbx)  2</em>num[0]==num[1]）<br> &lt;+34&gt;相同，goto&lt;+41&gt;<br> Else<br> &lt;+36&gt;不同，爆炸</p> 
<pre><code class="prism language-markdown">0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx
   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx
   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;
   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;

</code></pre> 
<p>&lt;+41&gt;rbx指向下一个num[2]<br> &lt;+45&gt;if（rbp==rbx  当前rbp是否指向末尾num[6]？）<br> &lt;+50&gt;Goto &lt;+64&gt;结束判断，跳出循环<br> Else<br> &lt;+48&gt;Goto &lt;+27&gt;·<br> 依次循环，综上可逆向出phase_2源码等价为：</p> 
<pre><code class="prism language-markdown">Void phase_2(char* receive) {
    Int num[6]=receive;
    Read_six_number(receive,num);
I    nt *start=&amp;num[0];
    Int *end=&amp;num[6]
    If(num[0]!=1)
        explode_bomb();
    While(start&lt;end){
        If ((*start)*2!=*(start+1))
            Explode_bomb();
        else
            Start++;
    }
}
</code></pre> 
<p>以上跟符合反汇编的思路，可简化为：</p> 
<pre><code class="prism language-markdown">Void phase_2(char* receive) {
    Int num[6]=receive;
    Read_six_number(receive,num);
    For(int i=0;i&lt;6;i++)
        If(num[i+1]!=num[i]*2)
            explode_bomb();
}
</code></pre> 
<p>num[0]=1,后面是前面的2倍，因此答案为1 2 4 8 16 32。<br> <a id="3"></a></p> 
<h2>
<a id="phase_3_291"></a>phase_3</h2> 
<pre><code class="prism language-markdown">Dump of assembler code for function phase_3:
   0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp
   0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi
   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax
   0x0000000000400f5b &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;
   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax
   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;
   0x0000000000400f65 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;
   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax
   0x0000000000400f75 &lt;+50&gt;:    jmp    *0x402470(,%rax,8)
   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax
   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax
   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax
   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--  
   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax
   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax
   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax
   0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400fad &lt;+106&gt;:   call   0x40143a &lt;explode_bomb&gt;
   0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax
   0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax
   0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;
   0x0000000000400fc4 &lt;+129&gt;:   call   0x40143a &lt;explode_bomb&gt;
   0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp
   0x0000000000400fcd &lt;+138&gt;:   ret    
End of assembler dump.

</code></pre> 
<p>此题与phase_2类似，&lt;+0&gt;开辟空间，传进来的两个值存放在栈中，用&lt;+4&gt;rcx，&lt;+9&gt;rdx指向这两个值。&lt;+14&gt;发现常地址，查看</p> 
<pre><code class="prism language-markdown">(gdb) x /s 0x4025cf
0x4025cf:       "%d %d"

0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax
   0x0000000000400f5b &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;
   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax
   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;
   0x0000000000400f65 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;


</code></pre> 
<p>结合&lt;+19&gt;给eax置0，调用&lt;+24&gt;sscanf函数，&lt;+29&gt;sscanf函数返回的值存储在eax中，与1比较。&lt;+34&gt;若小于1爆炸，否则继续。发现与phase_2套路一致，取传入的数需要大于两个，且只取前两个int类型数。</p> 
<pre><code class="prism language-markdown">0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;
   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax
   0x0000000000400f75 &lt;+50&gt;:    jmp    *0x402470(,%rax,8)
0x0000000000400fad &lt;+106&gt;:   call   0x40143a &lt;explode_bomb&gt;

</code></pre> 
<p>&lt;+39&gt;将第一个数的值与7比，&lt;+106&gt;若大于爆炸，&lt;+46&gt;否则继续，将第一个数的值放入eax。因此第一个数值的范围为0-7。若小于0就往回跳了<br> &lt;+50&gt;跳转到将eax的值*8加上地址0x402470后得到的新地址所对应的内存值。例若eax=1，则新地址为0x402478.查看其对应的内存值：</p> 
<pre><code class="prism language-markdown">(gdb) x /a 0x402478
0x402478:       0x400fb9 &lt;phase_3+118&gt;

</code></pre> 
<p>即跳转到0x400fb9</p> 
<pre><code class="prism language-markdown">0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax
   0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;
   0x0000000000400fc4 &lt;+129&gt;:   call   0x40143a &lt;explode_bomb&gt;
   0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp
   0x0000000000400fcd &lt;+138&gt;:   ret    

</code></pre> 
<p>&lt;+118&gt;将0x137赋值给eax，&lt;+123&gt;比较传入的第二个数是否与其相等,若相等，&lt;+134&gt;则释放函数空间，&lt;+138&gt;返回；&lt;+129&gt;否则爆炸。因此，其中一组答案为：<br> 1 311<br> 如法炮制，所有答案有：0 207；1 311；2 707；3 256；4 389；5 206；6 682；7 327；<br> <a id="4"></a></p> 
<h2>
<a id="phase_4_378"></a>phase_4</h2> 
<pre><code class="prism language-markdown">(gdb) disas phase_4
Dump of assembler code for function phase_4:
   0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp
   0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx
   0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx
   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi
   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax
   0x0000000000401024 &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;
   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax
   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;

   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)
   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;
   0x0000000000401035 &lt;+41&gt;:    call   0x40143a &lt;explode_bomb&gt;

   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx
   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi
   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi
   0x0000000000401048 &lt;+60&gt;:    call   0x400fce &lt;func4&gt;

   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax
   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;
   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;
   0x0000000000401058 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp
   0x0000000000401061 &lt;+85&gt;:    ret    
End of assembler dump.

</code></pre> 
<p>基本套路与phase_2一致。<br> &lt;+0&gt;~&lt;+32&gt;易知（详见phase_2），传入两个int数。<br> &lt;+34&gt;~&lt;+41&gt;易知，第一个参数的值&lt;15<br> &lt;+46&gt;~&lt;+60&gt;得，edx=15，esi=0；edi存储传入的第一个数，也就是需要我们求的数。随后调用函数<br> 反汇编</p> 
<pre><code class="prism language-markdown">(gdb) disas func4  

Dump of assembler code for function func4:
   0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp
   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax
   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax
   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx

   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx
   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax
   0x0000000000400fdd &lt;+15&gt;:    sar    %eax

   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx
   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx
   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;
   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx
   0x0000000000400fe9 &lt;+27&gt;:    call   0x400fce &lt;func4&gt;
   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax
   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;
   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax

   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx
   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;
   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi
   0x0000000000400ffe &lt;+48&gt;:    call   0x400fce &lt;func4&gt;

   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp
   0x000000000040100b &lt;+61&gt;:    ret    
End of assembler dump.
    
</code></pre> 
<p>&lt;+4&gt;Eax=edx=15,<br> &lt;+6&gt;eax=eax-esi=15-0=15;<br> &lt;+8&gt;ecx=eax=15<br> &lt;+10&gt;ecx=ecx&gt;&gt;31；<br> &lt;+13&gt;eax=eax+ecx=15+0=15；<br> &lt;+15&gt;eax=eax&gt;&gt;1=7<br> &lt;+10&gt;~&lt;+15&gt;等价为 eax=15，ecx=15的初值下，执行：eax=((ecx&gt;&gt;31)+eax)&gt;&gt;1，eax=7<br> &lt;+17&gt;ecx=1*rsi+rax=0+7=7<br> &lt;+20&gt;将传入的edi与ecx比较，若大于，则执行&lt;+24&gt;后执行&lt;+27&gt;func4函数，此处应该是个递归调用，具体含义不明，但是可以确定的是若想继续执行完成该函数，调用一定次数后们一定有edi&lt;=ecx，于是跳转到&lt;+36&gt;。<br> &lt;+41&gt;~&lt;+48&gt;同上述原理，一定有ecx&gt;=edi时，跳转到&lt;+57&gt;结束函数。<br> 综合上述，当edi=ecx时，func4函数调用结束。因此edi为7；<br> 此后返回函数phase_4<br> &lt;+65&gt;~&lt;+85&gt;易知：第二个参数为0。<br> 故本题答案为7 0。<br> <a id="5"></a></p> 
<h2>
<a id="phase_5_465"></a>phase_5</h2> 
<pre><code class="prism language-markdown">(gdb) disas phase_5
Dump of assembler code for function phase_5:
   0x0000000000401062 &lt;+0&gt;:     push   %rbx
   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp
   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx
   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax
   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)
   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax
   0x000000000040107a &lt;+24&gt;:    call   0x40131b &lt;string_length&gt;
   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax
   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;
   0x0000000000401084 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;
   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)

   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx
   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx

   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax
   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax
   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi
   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi
   0x00000000004010bd &lt;+91&gt;:    call   0x401338 &lt;strings_not_equal&gt;
   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax
   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;
   0x00000000004010c6 &lt;+100&gt;:   call   0x40143a &lt;explode_bomb&gt;
   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;
   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax
   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;
   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax
   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax
   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;
   0x00000000004010e9 &lt;+135&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;
   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp
   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx
   0x00000000004010f3 &lt;+145&gt;:   ret    
End of assembler dump.

</code></pre> 
<p>开头与前几题一样，在&lt;+8&gt;设置了堆栈金丝雀保护。<br> &lt;+24&gt;调用了&lt; string_length &gt;函数，根据函数名，与&lt;+29&gt;得：输入的是6个字符。&lt;+34&gt;否则爆炸。接下来来到了&lt;+112&gt;将eax置零后来到了&lt;+41&gt;。<br> 根据&lt;+5&gt;得rdi接受传入的第一个字符的地址，且rbx指向其。&lt;+41&gt;在此条开始之前，eax被置零了（+112），mov指令因此ecx=（rbx）。&lt;+45&gt;将ecx的低8位保存在rsp所指向的栈中。&lt;+48&gt;将该值(ecx的低8位)赋给rdx。&lt;+52&gt;获得rdx的低4位赋给edx。&lt;+55&gt;查看地址常量0x4024b0，发现如下：</p> 
<pre><code class="prism language-markdown">(gdb) x /s 0x4024b0
0x4024b0 &lt;array.3449&gt;:  "maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"

</code></pre> 
<p>经历了&lt;+52&gt;的操作后，rdx∈【0，15】，因此&lt;+55&gt;中，地址范围在0x4024b0~0x4024bf， 对应的edx值为“maduiersnfotvbyl“中的一个，取决于rdx的值。分析&lt;+62&gt;~&lt;+74&gt;发现这是一个循环，计数器为rax，总共执行六次。&lt;+62&gt;把edx的低8位存入栈，构建为一个数组。&lt;+76&gt;执行六次后在字符串末尾填“0”。&lt;+81&gt;查看常地址0x40245e，</p> 
<pre><code class="prism language-markdown">(gdb) x /s 0x40245e
0x40245e:       "flyers"

</code></pre> 
<p>发现esi存储flyers<br> &lt;+86&gt;将栈中首字母的地址赋给rdi<br> &lt;+91&gt;随后调用函数&lt;strings_not_equal&gt;,结合&lt;+96&gt;~&lt;+100&gt;与函数名和前几题得经验分析得，该函数将判定栈中存储得值是否为esi中的flyers，返回一个值，若是则继续，否则爆炸。<br> 因此，结合上述所有分析，phase_5的整个过程为输入6个字符，取每个字符的低8位与0xf位与后，得到一个0-15的范围，将地址0x4024b0加上该值索引得到的值为flyers。而地址0x4024b0~0x4024bf对应的字符为“ maduiersnfotvbyl”，要从中取出flyers，那么传入的原始数据的低8位分别为102，108，121，101，114，115，即可。若只讨论输入的是英文，根据ascii码查表得，答案只需要满足以下条件，：<br> 第一个字符：I Y i y<br> 第二个字符：O o<br> 第三个字符：N n<br> 第四个字符：E U e u<br> 第五个字符：F V f v<br> 第六个字：G W g w<br> 只需将上述每个字符中任选一个，拼合即为正确答案。如：ionefg为一个答案。</p> 
<p><a id="6"></a></p> 
<h2>
<a id="phase_6_541"></a>phase_6</h2> 
<pre><code class="prism language-markdown">(gdb) disas phase_6 
Dump of assembler code for function phase_6:
   0x00000000004010f4 &lt;+0&gt;:     push   %r14
   0x00000000004010f6 &lt;+2&gt;:     push   %r13
   0x00000000004010f8 &lt;+4&gt;:     push   %r12
   0x00000000004010fa &lt;+6&gt;:     push   %rbp
   0x00000000004010fb &lt;+7&gt;:     push   %rbx
   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp

   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13
   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi
   0x0000000000401106 &lt;+18&gt;:    call   0x40145c &lt;read_six_numbers&gt;
   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14

   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d
   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp
   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax
   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax
   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax
   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;
   0x0000000000401123 &lt;+47&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d
   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d
   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx
   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax
   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax
   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)
   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;
   0x0000000000401140 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx
   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx
   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;
   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13
   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;
   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi
   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax
   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx
   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx
   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx
   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)
   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax
   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax
   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;

   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;
   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx
   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax
   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax
   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;
   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;
   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx
   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)
   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi
   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi
   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;
   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx
   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx
   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;
   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax
   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx
   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;
   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx
   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax
   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi
   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx
   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)
   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax
   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax
   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;
   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx
   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;
   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)
   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp
   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax
   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax
   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)
   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;
   0x00000000004011e9 &lt;+245&gt;:   call   0x40143a &lt;explode_bomb&gt;
   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx
   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp
   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;
   0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp
   0x00000000004011fb &lt;+263&gt;:   pop    %rbx
   0x00000000004011fc &lt;+264&gt;:   pop    %rbp
   0x00000000004011fd &lt;+265&gt;:   pop    %r12
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x00000000004011ff &lt;+267&gt;:   pop    %r13
   0x0000000000401201 &lt;+269&gt;:   pop    %r14
   0x0000000000401203 &lt;+271&gt;:   ret    
End of assembler dump.
</code></pre> 
<p>第一部分&lt;+0&gt;~&lt;+95&gt;</p> 
<pre><code class="prism language-markdown">    (gdb) disas phase_6 
Dump of assembler code for function phase_6:
   0x00000000004010f4 &lt;+0&gt;:     push   %r14
   0x00000000004010f6 &lt;+2&gt;:     push   %r13
   0x00000000004010f8 &lt;+4&gt;:     push   %r12
   0x00000000004010fa &lt;+6&gt;:     push   %rbp
   0x00000000004010fb &lt;+7&gt;:     push   %rbx
   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp

   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13
   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi
   0x0000000000401106 &lt;+18&gt;:    call   0x40145c &lt;read_six_numbers&gt;
   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14

   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d
   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp
   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax
   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax
   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax
   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;
   0x0000000000401123 &lt;+47&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d
   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d
   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx
   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax
   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax
   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)
   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;
   0x0000000000401140 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx
   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx
   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;
   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13
   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;
   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi

</code></pre> 
<p>②根据前面的经验，易知&lt;+18&gt;本题输入6个int数，假设存储的数组名为num<br> &lt;+12&gt;~&lt;+23&gt;:将r13,rsi,r14,rbp都指向了初始位置，即num[0]的地址。<br> ① 根据&lt;+26&gt;&lt;+52&gt;&lt;+56&gt;易知：r12是一个循环的计数器，且循环总共执行6次。<br> 接下来观察，这个循环做了什么。&lt;+35&gt;~&lt;+45&gt;判断当前值（num[r12]）的大小是满足num[0]-1&lt;=5，即num[0]是否&lt;=6,&gt;=1（jbe为无符号数的比较，因此初值不能为负，比较前有减一操作，因此最小为1，不可为0；若为0，减1后会是tmax，不满足条件）。<br> 若该循环次数小于6次，就来到了&lt;+62&gt;处。（①）<br> &lt;+62&gt;~&lt;+65&gt;ebx=r12,rax=ebx。<br> ③ &lt;+68&gt;eax=<em>(rsp+rax</em>4)。rsp为数组首地址，rax为偏移数，int类型空间为4字节，因此索引时需rax<em>4，因此eax=num[ebx]此处为什么不直接用与之等价的num[r12]?我们接着往下看<br> &lt;+71&gt;与eax与（rbp）比较，num[r12]与</em>rbp进行比较（②），如果相等就爆炸。④此处为什么不用与rbp等价的rsp？我们接着看。代码来到了&lt;+81&gt;ebx++,<br> &lt;+84&gt;<sub>&lt;+87&gt;可知，ebx作为这一小循环（&lt;+65&gt;</sub>&lt;+84&gt;）的计数器，而每做一次，ebx的值就加一，rax作为索引的偏移数也跟着加一，因此与eax比较的值一直在发生变化。在本小循环中eax的值为num[r12]，而与之比较的值为num[rax]，一直在变，循环每做一次都往后比一个，直到数组末尾num<a href="c%E4%B8%8D%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8F%AF%E4%BB%A5%E7%B4%A2%E5%BC%95%E5%88%B06">6</a>跳出。所以该小循环的作用是确保num[r12]（当前值）后的值不与其相等（num[r12]!=num[r12~5]）。因此③处不能用num[r12]。<br> 接下来，到了&lt;+89&gt;r13+=4，goto&lt;+32&gt;rbp=r13,因此rbp指向下一个，解释了④。<br> 随后重复上述循环。<br> 综上，此处代码等价为以下c语言。其中i=r12；j=ebx。⑤处的num[i]用num[r13]索引，⑥处的num[i]用rsp+rax*4索引，num[j]用rbp索引。</p> 
<pre><code class="prism language-markdown">for(int i=0;i&lt;6;i++){
if(0&lt;num[i] &amp;&amp; num[i]&lt;6){⑤
    for(int j=i;j&lt;6;j++)
        if(num[i]==num[j])⑥
            explode_bomb();
}
else
explode_bomb();
}
</code></pre> 
<p>第二部分<br> &lt;+95&gt;~&lt;+121&gt;</p> 
<pre><code class="prism language-markdown"> 0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi
   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax
   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx
   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx
   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx
   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)
   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax
   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax
   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;    
</code></pre> 
<p>这一部分比较容易，不赘述。过程等价为：</p> 
<pre><code class="prism language-markdown">for(int i=0;i&lt;6;i++)
    num[i]=7-num[i];
</code></pre> 
<p>接下来到了第三部分，比较繁琐，也是本题的核心，有一定的理解难度（不知道结果的情况下）。<br> &lt;+123&gt;~&lt;+181&gt;</p> 
<pre><code class="prism language-markdown"> 0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;
   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx
   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax
   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax
   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;
   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;
   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx
   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)
   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi
   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi
   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;
   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx
   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx
   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;
   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax
   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx
   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;    
</code></pre> 
<p>&lt;+123&gt;:将esi置0后来到了&lt;+163&gt;ecx=<em>(rsi</em>1+rsp)，因为rsp为num的首地址，第一趟时rsi被置为0，所以等价于ecx=num[0]，&lt;+166&gt;ecx==1？假设num[0]==1，则来到了&lt;+143&gt;edx=0x6032d0。此值类似一个地址。<br> &lt;+148&gt;<em>（0x20+rsp+rsi</em>2）=rdx根据上一部分的经验，rsp是基地址，rsi是偏移量，又添加了0x20的常偏移量，因此这是一个新的数组，我们假设数组名为dizhi，我们查看该地址。&lt;+153&gt;~&lt;+157&gt;是否到达dizhi末，即num是否被遍历完。若遍历完该部分结束。<br> 随后来到了&lt;+163&gt;ecx=rsp+rsi<em>1，此处更新了ecx的值，即ecx=num[rsi]，&lt;+166&gt;与1比较，现在我们讨论当num[rsi]不等于1时发生了什么。&lt;+171&gt;eax=1，&lt;+176&gt;edx=0x6032d0设置完两个初值后，来到了&lt;+130&gt;此处rdx=</em>（rdx+8）<br> 我们查看地址rdx+8，即0x6032d0+8=0x6032d8</p> 
<pre><code class="prism language-markdown">    (gdb) x/a 0x6032d8
0x6032d8 &lt;node1+8&gt;:     0x6032e0 &lt;node2&gt;
</code></pre> 
<p>发现他的值为0x6032e0，似乎也是一个地址，也就是说此时的rdx=0x6032e0。<br> &lt;+134&gt;~&lt;+139&gt;分析得，每循环一次eax的值就+1，rdx再次重复上述操作，即新的rdx=将原rdx的值+8后作为地址去解引。直到ecx=eax，跳转到&lt;+148&gt;将dizhi[rsi]=rdx。在第二轮时，</p> 
<pre><code class="prism language-markdown">    (gdb) x/a 0x6032e8
0x6032e8 &lt;node2+8&gt;:     0x6032f0 &lt;node3&gt;

</code></pre> 
<p>我们发现，rdx+8再索引总是对应了一个新的地址值，因此我们试着尝试查看最初0x6032d0附近的值</p> 
<pre><code class="prism language-markdown">    ⑥(gdb) x /25w 0x6032d0
0x6032d0 &lt;node1&gt;:       0x14c   0x1     0x6032e0 &lt;node2&gt;        0x0
0x6032e0 &lt;node2&gt;:       0xa8    0x2     0x6032f0 &lt;node3&gt;        0x0
0x6032f0 &lt;node3&gt;:       0x39c   0x3     0x603300 &lt;node4&gt;        0x0
0x603300 &lt;node4&gt;:       0x2b3   0x4     0x603310 &lt;node5&gt;        0x0
0x603310 &lt;node5&gt;:       0x1dd   0x5     0x603320 &lt;node6&gt;        0x0
0x603320 &lt;node6&gt;:       0x1bb   0x6     0x0     0x0
0x603330:       0x0

</code></pre> 
<p>我们以一字的间隔去解释存储值时发现，该结构存储了2个int和一个地址，而存储的地址又恰好指向下一个节点的地址。该结构为链表。<br> 数据结构为</p> 
<pre><code class="prism language-markdown">typedef struct Link{
Int val；
Int num；
struct Link* next；
}；
Link node[5];
</code></pre> 
<p>node[1].val=0x14c；node[1].num=1；node[1].next=0x6032e0。<br> Node[2].val=0xa8;node[2].num=2;node[2].next=0x6032f0<br> 其中node[2].val的地址为：0x6032e0<br> node[2].next的地址为：0x6032e8<br> 依次类推<br> 发现，rdx存储的是指向某个节点的地址。<br> 因此与该部分作用等价的伪代码为</p> 
<pre><code class="prism language-markdown">Node[]={0x6032d0,0x6032e0,0x6032f0,0x603300,0x603310,0x603320};
for(int i=0;i&lt;6;i++)
    if(num[i]==1)
        dizhi[i]==0x6032d0;
    else
        dizhi[i]=node[num[i]-1]
</code></pre> 
<p>因此num[i]的值为x，则dizhi[i]的值为第x个节点的地址。<br> 该部分结束。</p> 
<p>来到了第四部分,该部分比较考察基本功且较抽象，但是一步步画出栈即可轻松理解。<br> &lt;+183&gt;~&lt;+220&gt;</p> 
<pre><code class="prism language-markdown">    0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx
   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax
   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi
   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx
   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)
   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax
   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax
   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;
   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx
   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;
</code></pre> 
<p>dizhi数组的值分别指向一个节点的地址，而节点的地址+8就是存储该节点next指针的地址。该部分的作用是，将dizhi[i]所对应的节点的next指针，指向dizhi[i+]<br> 等价伪代码为：</p> 
<pre><code class="prism language-markdown">For(int i=0;i&lt;6;i++)
    *(dizhi[i]+8)=dizhi[i+1]
</code></pre> 
<p>一直到此，输入的值究竟是什么仍未有头绪。<br> 第五部分&lt;+222&gt;~&lt; +257&gt;</p> 
<pre><code class="prism language-markdown">    0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)
   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp
   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax
   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax
   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)
   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;
   0x00000000004011e9 &lt;+245&gt;:   call   0x40143a &lt;explode_bomb&gt;
   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx
   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp
   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;
</code></pre> 
<p>这一部分比较简单。简述<br> &lt;+222&gt;末尾节点的next设为NULL（0）<br> 而rbx一直是dizhi[0]的值未改变，该部分的作用就是从索引节点地址=dizhi[0]的节点，将该节点的val与下一节点的val比较，若大于则继续，否则爆炸。<br> 因此等价该部分的伪代码为</p> 
<pre><code class="prism language-markdown">For(Link* now=dizhi[0]；now；now=now-&gt;next)
If (now.val &gt; now.next.val)
    Continue;
else
    explode_bomb();
}
</code></pre> 
<p>到此，该题结束。<br> 综上，输入可以逆推。要想不触发爆炸函数，第五部分的节点指向必须为节点值从大到小排列，根据⑥</p> 
<pre><code class="prism language-markdown">&lt;node1&gt;0x6032d0 =0x14c
&lt;node2&gt;0x6032e0 =0xa8    
&lt;node3&gt;0x6032f0 =0x39c   
&lt;node4&gt;0x603300=0x2b3   
&lt;node5&gt;0x603310 =0x1dd   
&lt;node6&gt;0x603320 =0x1bb
</code></pre> 
<p>因为0x39c&gt;0x2b3&gt;0x1dd&gt;0x1bb&gt;0x14c&gt;0xa8。因此节点指向为：dizhi[0]=0x6032f0，0x6032f0=&amp;node[3]，*（0x6032f8）=0x603300依次类推等价伪代码为：dizhi[0]=0x6032f0，&amp;（node[3].next）=0x6032f8，node[3].next=&amp;node[4]，node[4].next=&amp;node[5] ，node[5].next=&amp;node[6] ，node[6].next=&amp;node[1] ，node[1].next=&amp;node[2]。<br> 因此dizhi[0]=&amp;node[3]，dizhi[1]=&amp;node[4] ，dizhi[2]=&amp;node[5] ，dizhi[3]=&amp;node[6] ，dizhi[4]=&amp;node[1] ，dizhi[5]=&amp;node[2]。<br> 根据第三部分知道，dizhi数组的值是通过以num数组的值做偏移量，在0x6032d0为基址不断解引得来的。因此num[i]的值决定了dizhi[i]存储的是第几个node。因此num[0]=3，num[1]=4，num[2]=5，num[3]=6，num[4]=1，num[5]=2。到此为止，仍不是最初答案，该部分是经历了第二部分后的值，所以要还原最初的值，还需要用7减。因此最开始的值为num[6]={4,3,2,1,6,5}。<br> 故最终答案为4 3 2 1 6 5。<br> <a id="7"></a></p> 
<h2>
<a id="secret_phase_886"></a>secret_phase</h2> 
<p>在bomb.c中我们发现，每一个phase完成后都调用了phase_defused函数。我们反汇编它。</p> 
<pre><code class="prism language-markdown">(gdb) disas phase_defused
Dump of assembler code for function phase_defused:
   0x00000000004015c4 &lt;+0&gt;:     sub    $0x78,%rsp
   0x00000000004015c8 &lt;+4&gt;:     mov    %fs:0x28,%rax
   0x00000000004015d1 &lt;+13&gt;:    mov    %rax,0x68(%rsp)
   0x00000000004015d6 &lt;+18&gt;:    xor    %eax,%eax
   0x00000000004015d8 &lt;+20&gt;:    cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;
   0x00000000004015df &lt;+27&gt;:    jne    0x40163f &lt;phase_defused+123&gt;
   0x00000000004015e1 &lt;+29&gt;:    lea    0x10(%rsp),%r8
   0x00000000004015e6 &lt;+34&gt;:    lea    0xc(%rsp),%rcx
   0x00000000004015eb &lt;+39&gt;:    lea    0x8(%rsp),%rdx
   0x00000000004015f0 &lt;+44&gt;:    mov    $0x402619,%esi

   0x00000000004015f5 &lt;+49&gt;:    mov    $0x603870,%edi
   0x00000000004015fa &lt;+54&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;
   0x00000000004015ff &lt;+59&gt;:    cmp    $0x3,%eax
   0x0000000000401602 &lt;+62&gt;:    jne    0x401635 &lt;phase_defused+113&gt;
   0x0000000000401604 &lt;+64&gt;:    mov    $0x402622,%esi
   0x0000000000401609 &lt;+69&gt;:    lea    0x10(%rsp),%rdi
   0x000000000040160e &lt;+74&gt;:    call   0x401338 &lt;strings_not_equal&gt;
   0x0000000000401613 &lt;+79&gt;:    test   %eax,%eax
   0x0000000000401615 &lt;+81&gt;:    jne    0x401635 &lt;phase_defused+113&gt;
   0x0000000000401617 &lt;+83&gt;:    mov    $0x4024f8,%edi
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x000000000040161c &lt;+88&gt;:    call   0x400b10 &lt;puts@plt&gt;
   0x0000000000401621 &lt;+93&gt;:    mov    $0x402520,%edi
   0x0000000000401626 &lt;+98&gt;:    call   0x400b10 &lt;puts@plt&gt;
   0x000000000040162b &lt;+103&gt;:   mov    $0x0,%eax
   0x0000000000401630 &lt;+108&gt;:   call   0x401242 &lt;secret_phase&gt;
   0x0000000000401635 &lt;+113&gt;:   mov    $0x402558,%edi
   0x000000000040163a &lt;+118&gt;:   call   0x400b10 &lt;puts@plt&gt;
   0x000000000040163f &lt;+123&gt;:   mov    0x68(%rsp),%rax
   0x0000000000401644 &lt;+128&gt;:   xor    %fs:0x28,%rax
   0x000000000040164d &lt;+137&gt;:   je     0x401654 &lt;phase_defused+144&gt;
   0x000000000040164f &lt;+139&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;
   0x0000000000401654 &lt;+144&gt;:   add    $0x78,%rsp
   0x0000000000401658 &lt;+148&gt;:   ret    
End of assembler dump.
</code></pre> 
<p>① &lt;+20&gt;判断6个phase是否都被拆除。<br> 查看第一个出现的常地址②</p> 
<pre><code class="prism language-markdown">(gdb) x /s 0x402619
0x402619:       "%d %d %s"
</code></pre> 
<p>为传入数据的格式。</p> 
<p>&lt;+54&gt;根据前题可知，<a href="mailto:__isoc99_sscanf@plt">__isoc99_sscanf@plt</a>函数会返回输入数据的个数（空格为界），&lt;+59若不为3，跳转到&lt;+113&gt;，若为3，到&lt;+64&gt;。查看<br> &lt;+113&gt;</p> 
<pre><code class="prism language-markdown">(gdb) x /s 0x402558
0x402558:       "Congratulations! You've defused the bomb!"
</code></pre> 
<p>发现，为通关后的提示符。<br> &lt;+64&gt;</p> 
<pre><code class="prism language-markdown">(gdb) x /s 0x402622
0x402622:       "DrEvil"
</code></pre> 
<p>&lt;+74&gt;~&lt;+81&gt;判断传入的%s是否等于“DrEvil”③<br> &lt;+83&gt;</p> 
<pre><code class="prism language-markdown">(gdb) x /s 0x4024f8
0x4024f8:       "Curses, you've found the secret phase!"
</code></pre> 
<p>&lt;+88&gt;输出</p> 
<pre><code class="prism language-markdown">x /s 0x402520
0x402520:       "But finding it and solving it are quite different..."
</code></pre> 
<p>&lt;+98&gt;输出<br> &lt;+108&gt;调用secret_phase<br> 综上发现，&lt;+88&gt;&lt;+98&gt;为成功进入secret phase的提示，这就说明，进入secret phase需要完成6个phase后（①），且输入格式为%d %d %s（②），当%s==DrEvil时（③）方可进入。<br> 因此，进入的密匙需要在解除前面6个phase时输入。我们发现，phase_3和phase_4都有类似%d %d的输入，因此经过尝试后发现，当我们在phase_4后加入DrEvil，（不知道为什么在phase_3后加不行）完成所有phase后即可进入secret phase。<br> 查看secret_phase。</p> 
<pre><code class="prism language-markdown">(gdb) disas secret_phase
Dump of assembler code for function secret_phase:
   0x0000000000401242 &lt;+0&gt;:     push   %rbx
   0x0000000000401243 &lt;+1&gt;:     call   0x40149e &lt;read_line&gt;
   0x0000000000401248 &lt;+6&gt;:     mov    $0xa,%edx
   0x000000000040124d &lt;+11&gt;:    mov    $0x0,%esi
   0x0000000000401252 &lt;+16&gt;:    mov    %rax,%rdi
   0x0000000000401255 &lt;+19&gt;:    call   0x400bd0 &lt;strtol@plt&gt;
   0x000000000040125a &lt;+24&gt;:    mov    %rax,%rbx
   0x000000000040125d &lt;+27&gt;:    lea    -0x1(%rax),%eax
   0x0000000000401260 &lt;+30&gt;:    cmp    $0x3e8,%eax
   0x0000000000401265 &lt;+35&gt;:    jbe    0x40126c &lt;secret_phase+42&gt;
   0x0000000000401267 &lt;+37&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x000000000040126c &lt;+42&gt;:    mov    %ebx,%esi
   0x000000000040126e &lt;+44&gt;:    mov    $0x6030f0,%edi
   0x0000000000401273 &lt;+49&gt;:    call   0x401204 &lt;fun7&gt;
   0x0000000000401278 &lt;+54&gt;:    cmp    $0x2,%eax
   0x000000000040127b &lt;+57&gt;:    je     0x401282 &lt;secret_phase+64&gt;
   0x000000000040127d &lt;+59&gt;:    call   0x40143a &lt;explode_bomb&gt;
   0x0000000000401282 &lt;+64&gt;:    mov    $0x402438,%edi
   0x0000000000401287 &lt;+69&gt;:    call   0x400b10 &lt;puts@plt&gt;
   0x000000000040128c &lt;+74&gt;:    call   0x4015c4 &lt;phase_defused&gt;
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x0000000000401291 &lt;+79&gt;:    pop    %rbx
   0x0000000000401292 &lt;+80&gt;:    ret    
End of assembler dump.
</code></pre> 
<p>&lt;+1&gt;读入<br> &lt;+19&gt;不知道干啥<br> &lt;+27&gt;~&lt;+37&gt;输入的数据经<a href="mailto:strtol@plt">strtol@plt</a>转换后不能大于0x3e9<br> &lt;+44&gt;查看</p> 
<pre><code class="prism language-markdown">0x6030f0 &lt;n1&gt;:  0x00000024      0x00000000      0x00603110      0x00000000
0x603100 &lt;n1+16&gt;:       0x00603130      0x00000000      0x00000000      0x00000000
0x603110 &lt;n21&gt;: 0x00000008      0x00000000      0x00603190      0x00000000
0x603120 &lt;n21+16&gt;:      0x00603150      0x00000000      0x00000000      0x00000000
0x603130 &lt;n22&gt;: 0x00000032      0x00000000      0x00603170      0x00000000
0x603140 &lt;n22+16&gt;:      0x006031b0      0x00000000      0x00000000      0x00000000
0x603150 &lt;n32&gt;: 0x00000016      0x00000000      0x00603270      0x00000000
0x603160 &lt;n32+16&gt;:      0x00603230      0x00000000      0x00000000      0x00000000
0x603170 &lt;n33&gt;: 0x0000002d      0x00000000      0x006031d0      0x00000000
0x603180 &lt;n33+16&gt;:      0x00603290      0x00000000      0x00000000      0x00000000
0x603190 &lt;n31&gt;: 0x00000006      0x00000000      0x006031f0      0x00000000
0x6031a0 &lt;n31+16&gt;:      0x00603250      0x00000000      0x00000000      0x00000000
0x6031b0 &lt;n34&gt;: 0x0000006b      0x00000000      0x00603210      0x00000000
0x6031c0 &lt;n34+16&gt;:      0x006032b0      0x00000000      0x00000000      0x00000000
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
0x6031d0 &lt;n45&gt;: 0x00000028      0x00000000      0x00000000      0x00000000
0x6031e0 &lt;n45+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000
0x6031f0 &lt;n41&gt;: 0x00000001      0x00000000      0x00000000      0x00000000
0x603200 &lt;n41+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000
0x603210 &lt;n47&gt;: 0x00000063      0x00000000      0x00000000      0x00000000
0x603220 &lt;n47+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000
0x603230 &lt;n44&gt;: 0x00000023      0x00000000      0x00000000      0x00000000
0x603240 &lt;n44+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000
0x603250 &lt;n42&gt;: 0x00000007      0x00000000      0x00000000      0x00000000
0x603260 &lt;n42+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000
0x603270 &lt;n43&gt;: 0x00000014      0x00000000      0x00000000      0x00000000
0x603280 &lt;n43+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000
0x603290 &lt;n46&gt;: 0x0000002f      0x00000000      0x00000000      0x00000000
0x6032a0 &lt;n46+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
0x6032b0 &lt;n48&gt;: 0x000003e9      0x00000000      0x00000000      0x00000000
0x6032c0 &lt;n48+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000
</code></pre> 
<p>发现，为一颗搜索树（下图值以16进制表示），<br> <img src="https://images2.imgbox.com/64/38/qhXnI0Ok_o.jpg" alt="在这里插入图片描述"></p> 
<p>结构为</p> 
<pre><code class="prism language-markdown">struct _node{
    int val;
    struct _node* left;
struct _node* right;   
}
</code></pre> 
<p>&lt;+49&gt;~&lt;+57&gt;发现，经过fun7函数后，该返回值为2时，成功破解。<br> 接下来反汇编fun7</p> 
<pre><code class="prism language-markdown">gdb) disas fun7
Dump of assembler code for function fun7:
   0x0000000000401204 &lt;+0&gt;:     sub    $0x8,%rsp
   0x0000000000401208 &lt;+4&gt;:     test   %rdi,%rdi
   0x000000000040120b &lt;+7&gt;:     je     0x401238 &lt;fun7+52&gt;
   0x000000000040120d &lt;+9&gt;:     mov    (%rdi),%edx
   0x000000000040120f &lt;+11&gt;:    cmp    %esi,%edx
   0x0000000000401211 &lt;+13&gt;:    jle    0x401220 &lt;fun7+28&gt;
   0x0000000000401213 &lt;+15&gt;:    mov    0x8(%rdi),%rdi
   0x0000000000401217 &lt;+19&gt;:    call   0x401204 &lt;fun7&gt;
   0x000000000040121c &lt;+24&gt;:    add    %eax,%eax
   0x000000000040121e &lt;+26&gt;:    jmp    0x40123d &lt;fun7+57&gt;
   0x0000000000401220 &lt;+28&gt;:    mov    $0x0,%eax
   0x0000000000401225 &lt;+33&gt;:    cmp    %esi,%edx
   0x0000000000401227 &lt;+35&gt;:    je     0x40123d &lt;fun7+57&gt;
   0x0000000000401229 &lt;+37&gt;:    mov    0x10(%rdi),%rdi
   0x000000000040122d &lt;+41&gt;:    call   0x401204 &lt;fun7&gt;
   0x0000000000401232 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax
   0x0000000000401236 &lt;+50&gt;:    jmp    0x40123d &lt;fun7+57&gt;
   0x0000000000401238 &lt;+52&gt;:    mov    $0xffffffff,%eax
   0x000000000040123d &lt;+57&gt;:    add    $0x8,%rsp
   0x0000000000401241 &lt;+61&gt;:    ret    
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
End of assembler dump.
</code></pre> 
<p>此部分雷同phase_6，此处不赘述，功能等价为以下</p> 
<pre><code class="prism language-markdown">#include&lt;stdio.h&gt;
typedef struct _node{
    int val;
    struct _node* left;
    struct _node* right;   
}Node;
int fun7(Node* p,int t);
int main(){
    Node a[15];
    for (int i=0;i&lt;=6;i++){
        a[i].left=&amp;a[i*2+1];
        a[i].right=&amp;a[i*2+2];
    };
    for (int i=7;i&lt;=14;i++){
        a[i].left=NULL;
        a[i].right=NULL;
    };
    a[0].val=0x24;
    a[1].val=0x8;
    a[2].val=0x32;
    a[3].val=0x6;
    a[4].val=0x16;
    a[5].val=0x2d;
    a[6].val=0x6b;
    a[7].val=0x1;
    a[8].val=0x7;
    a[9].val=0x14;
    a[10].val=0x23;
    a[11].val=0x28;
    a[12].val=0x2f;
    a[13].val=0x63;
    a[14].val=0x3e9;
    int t=;
    int re;
    Node* p=&amp;a[0];
    re=fun7(p,t);
    printf("%d",re);
    return 0;
}

  int fun7(Node* p,int t){
    if(!p)
        return -1;
    if(p-&gt;val&lt;=t){
        if(p-&gt;val==t)
            return 0;
         p=p-&gt;right;
        return 2*fun7(p,t)+1;
    }
    else{
        p=p-&gt;left;
        return 2*fun7(p,t);
    }
    
}
</code></pre> 
<p>其中，t为我们需要传入的值。我们发现，fun7为递归函数，作用是在平衡二叉搜索树(right节点的值大于self，left节点小于self)中查找我们的输入值t，返回的是它查找的过程(向左向右的次数与顺序)。当t大于等于当前节点时，向右查找，小于时向左查找。向右时<em>2+1，向左时</em>2。&lt;+11&gt;查找的值一定比0x24小。函数栈调用图如下，<br> <img src="https://images2.imgbox.com/08/b8/0IeNUxCs_o.jpg" alt="在这里插入图片描述"></p> 
<p>因此答案一：向左一次，向右一次找到了，答案为0x16=22。因此答案二：向左一次，向右一次，向左一次找到了，答案为0x14=20。<br> 或者根据伪代码暴力循环破解（&lt;1001），只有值为20或22时，返回值为2。<br> 综上答案为20或22。</p> 
<p>​</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>