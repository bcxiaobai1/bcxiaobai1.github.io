<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【云原生 | 初识篇】带你走进Docker的未知宇宙 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【云原生 | 初识篇】带你走进Docker的未知宇宙</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-github-gist">
                    
                        
                    
                    <p>? 前言</p> 
<p><em>大家好，我是<strong>Edison</strong></em>?</p> 
<p>今天是我们「云原生」系列的第一篇：「走进Docker的世界」；</p> 
<p><em><strong>Let’s get it！</strong></em></p> 
<p><img src="https://images2.imgbox.com/c0/b8/piyUHnct_o.gif" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/42/f2/ttL0SdqM_o.gif" alt="在这里插入图片描述"></p> 
<p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#_29">序言</a></li>
<li><a href="#1_docker_33">1. 认识docker</a></li>
<li>
<ul>
<li><a href="#_Docker_40">? 为什么出现Docker</a></li>
<li><a href="#_Docker_49">? 什么是Docker</a></li>
<li><a href="#_Docker_55">? Docker能做什么</a></li>
<li><a href="#__64">? 版本管理</a></li>
<li><a href="#__74">? 发展史</a></li>
</ul>
  </li>
<li><a href="#2_Docker_103">2. 安装Docker</a></li>
<li><a href="#3_Docker_166">3. Docker核心操作详解</a></li>
<li>
<ul>
<li><a href="#_Image_169">? 镜像（Image）</a></li>
<li><a href="#_Container_172">? 容器（Container）</a></li>
<li><a href="#_Registry_175">? 仓库（Registry）</a></li>
<li><a href="#_Docker_198">? Docker常用命令</a></li>
<li><a href="#__298">? 操作流程图</a></li>
</ul>
  </li>
<li><a href="#4_Dockerfile_480">4. Dockerfile使用</a></li>
<li>
<ul><li><a href="#_1_654">? 通过1号进程理解容器的本质</a></li></ul>
  </li>
<li><a href="#5_Docker_682">5. Docker网络</a></li>
<li>
<ul>
<li><a href="#__693">? 网络模式</a></li>
<li><a href="#_bridge_704">? bridge模式</a></li>
<li><a href="#_Host_717">? Host模式</a></li>
<li><a href="#_Conatiner_728">? Conatiner模式</a></li>
<li><a href="#_None_745">? None模式</a></li>
</ul>
  </li>
<li><a href="#6__779">6. 总结</a></li>
</ul>
</div>
<p></p> 
<p><img src="https://images2.imgbox.com/8d/42/S2UhZfGt_o.gif" alt="在这里插入图片描述"></p> 
<h1>
<a id="_29"></a>序言</h1> 
<p>对于Docker，相信大家并不陌生，本文将介绍docker的前世今生，了解docker的实现与原理?‍?</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/df/ef/TItwdByp_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h1>
<a id="1_docker_33"></a>1. 认识docker</h1> 
<blockquote> 
 <p>什么是 Docker？<br>  <br> 为什么会出现Docker？<br>  <br> Docker能用来做什么？</p> 
</blockquote> 
<h2>
<a id="_Docker_40"></a>? 为什么出现Docker</h2> 
<blockquote> 
 <p>需要一种轻量、高效的虚拟化能力<br> <img src="https://images2.imgbox.com/26/a5/vcaudWOK_o.png" alt="image-20210929010008192"><br> Docker 公司位于旧金山，原名 dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为 “Docker”，Docker就是这样诞生的。<br>  <br> <strong>Hypervisor：</strong> 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V 或者 思杰的XenServer。<br>  <br> <strong>Container Runtime：</strong> 通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。</p> 
</blockquote> 
<h2>
<a id="_Docker_49"></a>? 什么是Docker</h2> 
<blockquote> 
 <p>基于操作系统内核，提供轻量级虚拟化功能的CS架构的软件产品。<br> <img src="https://images2.imgbox.com/de/fb/YLPNTMcG_o.png" alt="docker-engine"><br> 基于轻量的特性，解决软件交付过程中的环境依赖<br> <img src="https://images2.imgbox.com/87/f2/ZiR7qxc8_o.png" alt="why1"></p> 
</blockquote> 
<h2>
<a id="_Docker_55"></a>? Docker能做什么</h2> 
<blockquote> 
 <p>1、可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署；<br>  <br> 2、可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删）；<br>  <br> 3、container 容器之间相互隔离，且每个容器可以设置资源限额；<br>  <br> 4、提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立；</p> 
</blockquote> 
<h2>
<a id="__64"></a>? 版本管理</h2> 
<blockquote> 
 <p>Docker 引擎主要有两个版本：<strong>企业版（EE）</strong> 和 <strong>社区版（CE）</strong>；<br>  <br> 每个季度(1-3，4-6，7-9，10-12)，企业版和社区版都会发布一个稳定版本(Stable)。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持；<br>  <br> 每个月社区版还会通过 Edge 方式发布月度版；<br>  <br> 从 2017 年第一季度开始，Docker 版本号遵循 YY.MM-xx 格式，类似于 Ubuntu 等项目。例如，2018 年 6 月第一次发布的社区版本为 18.06.0-ce<br> <img src="https://images2.imgbox.com/de/1b/sTCLTGJ5_o.png" alt="docker-version"></p> 
</blockquote> 
<h2>
<a id="__74"></a>? 发展史</h2> 
<blockquote> 
 <p>13年成立，15年开始，迎来了飞速发展。<br>  <br> <img src="https://images2.imgbox.com/46/b8/S0PWY5bi_o.png" alt="deplpment"><br> Docker 1.8之前，使用<a href="https://linuxcontainers.org/fr/lxc/introduction/">LXC</a>，Docker在上层做了封装， 把 LXC 复杂的容器创建与使用方式简化为自己的一套命令体系。<br>  <br> 之后，为了实现跨平台等复杂的场景，Docker抽出了 libcontainer 项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。<br>  <br> 2015年6月，Docker牵头成立了 <strong>OCI</strong>（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。<br>  <br> OCI成立后，libcontainer 交给OCI组织来维护，但是 libcontainer 中只包含了与kernel交互的库，因此基于 libcontainer 项目，后面又加入了一个 CLI 工具，并且项目改名为 <strong>runC</strong> (<a href="https://github.com/opencontainers/runc">runC的主页</a>)， 目前runC已经成为一个功能强大的runtime工具。<br>  <br> Docker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了<strong>containerd</strong>。<br>  <br> containerd向上为Docker Daemon提供了<code>gRPC接口</code>，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过<code>containerd-shim</code>结合<code>runC</code>，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。<br>  <br> <img src="https://images2.imgbox.com/18/06/Rs8xGD0Z_o.png" alt="containerd"></p> 
</blockquote> 
<p>也就是说?</p> 
<blockquote> 
 <p>runC（libcontainer）是符合OCI标准的一个实现，与底层系统交互。<br>  <br> containerd 是实现了OCI之上的容器的高级功能，比如镜像管理、容器执行的调用等。<br>  <br> Docker 目前是最上层与CLI交互的进程，接收cli的请求并与containerd协作。</p> 
</blockquote> 
<h1>
<a id="2_Docker_103"></a>2. 安装Docker</h1> 
<p><strong>配置宿主机网卡转发</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">## 若未配置，需要执行如下</span>

$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>  /etc/sysctl.d/docker.conf</span>
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward=1
EOF</span>

$ sysctl -p /etc/sysctl.d/docker.conf
</code></pre> 
<p><strong>Yum安装配置docker</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">## 下载阿里源repo文件</span>
$ <span class="token function">curl</span> -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo
$ <span class="token function">curl</span> -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

$ yum clean all <span class="token operator">&amp;&amp;</span> yum makecache

<span class="token comment">## yum安装</span>
$ yum <span class="token function">install</span> docker-ce-20.10.12 -y

<span class="token comment">## 查看源中可用版本</span>
$ yum list docker-ce --showduplicates <span class="token operator">|</span> <span class="token function">sort</span> -r

<span class="token comment">## 安装旧版本</span>
<span class="token comment">##yum install -y docker-ce-18.09.9</span>

<span class="token comment">## 配置源加速</span>
<span class="token comment">## https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</span>
<span class="token function">mkdir</span> -p /etc/docker
<span class="token function">vi</span> /etc/docker/daemon.json
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"registry-mirrors"</span> <span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://8xpk5wnt.mirror.aliyuncs.com"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">## 设置开机自启</span>
systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>  
systemctl daemon-reload

<span class="token comment">## 启动docker</span>
systemctl start <span class="token function">docker</span> 

<span class="token comment">## 查看docker信息</span>
<span class="token function">docker</span> info

<span class="token comment">## docker-client</span>
<span class="token function">which</span> <span class="token function">docker</span>

<span class="token comment">## docker daemon</span>
<span class="token function">ps</span> aux <span class="token operator">|</span><span class="token function">grep</span> <span class="token function">docker</span>

<span class="token comment">## containerd</span>
<span class="token function">ps</span> aux<span class="token operator">|</span><span class="token function">grep</span> containerd
systemctl status containerd
</code></pre> 
<p>到这里就安装好我们的Docker啦！</p> 
<h1>
<a id="3_Docker_166"></a>3. Docker核心操作详解</h1> 
<blockquote> 
 <p>Docker的三大核心要素：镜像(Image)、容器(Container)、仓库(Registry)<br> <img src="https://images2.imgbox.com/17/b2/NBzD9UWL_o.png" alt="docker架构"></p> 
</blockquote> 
<h2>
<a id="_Image_169"></a>? 镜像（Image）</h2> 
<blockquote> 
 <p>打包了业务代码及运行环境的包，是静态的文件，不能直接对外提供服务。</p> 
</blockquote> 
<h2>
<a id="_Container_172"></a>? 容器（Container）</h2> 
<blockquote> 
 <p>镜像的运行时，可以对外提供服务。</p> 
</blockquote> 
<h2>
<a id="_Registry_175"></a>? 仓库（Registry）</h2> 
<blockquote> 
 <p>存放镜像的地方</p> 
</blockquote> 
<p><strong>仓库分类</strong></p> 
<blockquote> 
 <p>公有仓库：Docker Hub，阿里，网易…<br>  <br> 私有仓库：企业内部搭建；<br>  <br> Docker Registry：Docker官方提供的镜像仓库存储服务；<br>  <br> Harbor：是Docker Registry的更高级封装，它除了提供友好的Web UI界面，角色和用户权限管理，用户操作审计等功能；</p> 
</blockquote> 
<p><strong>公有的仓库中，一般存在这么几类镜像</strong></p> 
<blockquote> 
 <p>操作系统基础镜像（centos，ubuntu，suse，alpine）<br>  <br> 中间件（nginx，redis，mysql，tomcat）<br>  <br> 语言编译环境（python，java，golang）<br>  <br> 业务镜像（django-demo…）</p> 
</blockquote> 
<p>容器和仓库不会直接交互，都是以镜像为载体来操作。</p> 
<h2>
<a id="_Docker_198"></a>? Docker常用命令</h2> 
<p><strong>1、查看镜像列表</strong></p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> images
</code></pre> 
<p><strong>2、如何获取镜像</strong></p> 
<p>①从远程仓库拉取</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> pull nginx:alpine
$ <span class="token function">docker</span> images
</code></pre> 
<p>②使用tag命令</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> tag nginx:alpine <span class="token number">172.21</span>.51.143:5000/nginx:alpine
$ <span class="token function">docker</span> images
</code></pre> 
<p>③本地构建</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> build <span class="token builtin class-name">.</span> -t my-nginx:ubuntu -f Dockerfile
</code></pre> 
<p><strong>3、如何通过镜像启动容器</strong></p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run --name my-nginx-alpine -d nginx:alpine
</code></pre> 
<p><strong>4、如何知道容器内部运行了什么程序？</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># 进入容器内部,分配一个tty终端</span>
$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti my-nginx-alpine /bin/sh
<span class="token comment"># ps aux</span>
</code></pre> 
<p><strong>5、docker怎么知道容器启动后该执行什么命令？</strong></p> 
<p>通过docker build来模拟构建一个nginx的镜像?</p> 
<p>①创建Dockerfile</p> 
<pre><code class="prism language-bash"><span class="token comment"># 告诉docker使用哪个基础镜像作为模板，后续命令都以这个镜像为基础 </span>
FROM ubuntu

<span class="token comment"># RUN命令会在上面指定的镜像里执行命令 </span>
RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt</span> <span class="token function">install</span> -y nginx

<span class="token comment">#告诉docker，启动容器时执行如下命令</span>
CMD <span class="token punctuation">[</span><span class="token string">"/usr/sbin/nginx"</span>, <span class="token string">"-g"</span>,<span class="token string">"daemon off;"</span><span class="token punctuation">]</span>
</code></pre> 
<p>②构建本地镜像</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> build <span class="token builtin class-name">.</span> -t my-nginx:ubuntu -f Dockerfile
</code></pre> 
<p>③使用新镜像启动容器</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run --name my-nginx-ubuntu -d my-nginx:ubuntu
</code></pre> 
<p>④进入容器查看进程</p> 
<pre><code class="prism language-bash">   $ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti my-nginx-ubuntu /bin/sh
   <span class="token comment"># ps aux</span>
</code></pre> 
<p><strong>6、如何访问容器内服务</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># 进入容器内部</span>

$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti my-nginx-alpine /bin/sh
<span class="token comment"># ps aux|grep nginx</span>
<span class="token comment"># curl localhost:80</span>
</code></pre> 
<p><strong>7、宿主机中如何访问容器服务</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># 删掉旧服务,重新启动</span>
$ <span class="token function">docker</span> <span class="token function">rm</span> -f my-nginx-alpine
$ <span class="token function">docker</span> run --name my-nginx-alpine -d -p <span class="token number">8080</span>:80 nginx:alpine
$ <span class="token function">curl</span> <span class="token number">172.21</span>.51.143:8080
</code></pre> 
<p><strong>8、docker client如何与daemon通信</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># /var/run/docker.sock</span>
$ <span class="token function">docker</span> run --name portainer -d -p <span class="token number">9001</span>:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
</code></pre> 
<p>如图</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/ca/1d/UYI4tqro_o.png" alt="image-20210927231202100"></p> 
</blockquote> 
<h2>
<a id="__298"></a>? 操作流程图</h2> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/fa/33/d6HsVw2S_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p><strong>1、查看所有镜像</strong></p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> images
</code></pre> 
<p><strong>2、拉取镜像</strong></p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> pull nginx:alpine
</code></pre> 
<p><strong>3、如何唯一确定镜像</strong></p> 
<p>①<code>image_id</code></p> 
<p>②<code>repository:tag</code></p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> images
REPOSITORY    TAG                 IMAGE ID            CREATED             SIZE
nginx         alpine              377c0837328f        <span class="token number">2</span> weeks ago         <span class="token number">19</span>.7MB
</code></pre> 
<p><strong>4、导出镜像到文件中</strong></p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> save -o nginx-alpine.tar nginx:alpine
</code></pre> 
<p><strong>5、从文件中加载镜像</strong></p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> load -i nginx-alpine.tar
</code></pre> 
<p><strong>6、部署镜像仓库</strong></p> 
<p><a href="https://docs.docker.com/registry/">Docker仓库</a></p> 
<pre><code class="prism language-bash"><span class="token comment">## 使用docker镜像启动镜像仓库服务</span>
$ <span class="token function">docker</span> run -d -p <span class="token number">5000</span>:5000 --restart always --name registry registry:2

<span class="token comment">## 默认仓库不带认证，若需要认证，参考https://docs.docker.com/registry/deploying/#restricting-access</span>
</code></pre> 
<p><strong>7、推送本地镜像到镜像仓库中</strong></p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> tag nginx:alpine localhost:5000/nginx:alpine
$ <span class="token function">docker</span> push localhost:5000/nginx:alpine

<span class="token comment">## 查看仓库内元数据</span>
$ <span class="token function">curl</span> -X GET http://172.21.51.143:5000/v2/_catalog
$ <span class="token function">curl</span> -X GET http://172.21.51.143:5000/v2/nginx/tags/list

<span class="token comment">## 镜像仓库给外部访问，不能通过localhost，尝试使用内网地址172.21.51.143:5000/nginx:alpine</span>
$ <span class="token function">docker</span> tag nginx:alpine <span class="token number">172.21</span>.51.143:5000/nginx:alpine
$ <span class="token function">docker</span> push <span class="token number">172.21</span>.51.143:5000/nginx:alpine
The push refers to repository <span class="token punctuation">[</span><span class="token number">172.21</span>.51.143:5000/nginx<span class="token punctuation">]</span>
Get https://172.21.51.143:5000/v2/: http: server gave HTTP response to HTTPS client

<span class="token comment">## docker默认不允许向http的仓库地址推送，如何做成https的，参考：https://docs.docker.com/registry/deploying/#run-an-externally-accessible-registry</span>
<span class="token comment">## 我们没有可信证书机构颁发的证书和域名，自签名证书需要在每个节点中拷贝证书文件，比较麻烦，因此我们通过配置daemon的方式，来跳过证书的验证：</span>
$ <span class="token function">cat</span> /etc/docker/daemon.json
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://8xpk5wnt.mirror.aliyuncs.com"</span>
  <span class="token punctuation">]</span>,
  <span class="token string">"insecure-registries"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
     <span class="token string">"172.21.51.143:5000"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

$ systemctl restart <span class="token function">docker</span>

$ <span class="token function">docker</span> push <span class="token number">172.21</span>.51.143:5000/nginx:alpine

$ <span class="token function">docker</span> images    <span class="token comment"># IMAGE ID相同，等于起别名或者加快捷方式</span>
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
<span class="token number">172.21</span>.51.143:5000/nginx   alpine              377c0837328f        <span class="token number">4</span> weeks ago         
nginx                    alpine              377c0837328f        <span class="token number">4</span> weeks ago         
localhost:5000/nginx     alpine              377c0837328f        <span class="token number">4</span> weeks ago         
registry                 <span class="token number">2</span>                   708bc6af7e5e        <span class="token number">2</span> months ago       
</code></pre> 
<p><strong>8、删除镜像</strong></p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> rmi nginx:alpine
</code></pre> 
<p><strong>9、查看容器列表</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">## 查看运行状态的容器列表</span>
$ <span class="token function">docker</span> <span class="token function">ps</span>

<span class="token comment">## 查看全部状态的容器列表</span>
$ <span class="token function">docker</span> <span class="token function">ps</span> -a
</code></pre> 
<p><strong>10、启动容器</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">## 后台启动</span>
$ <span class="token function">docker</span> run --name nginx -d nginx:alpine

<span class="token comment">## 映射端口,把容器的端口映射到宿主机中,-p &lt;host_port&gt;:&lt;container_port&gt;</span>
$ <span class="token function">docker</span> run --name nginx -d -p <span class="token number">8080</span>:80 nginx:alpine

<span class="token comment">## 资源限制,最大可用内存500M</span>
$ <span class="token function">docker</span> run --memory<span class="token operator">=</span>500m nginx:alpine
</code></pre> 
<p><strong>11、容器数据持久化</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">## 挂载主机目录</span>
$ <span class="token function">docker</span> run --name nginx -d  -v /opt:/opt  nginx:alpine
$ <span class="token function">docker</span> run --name mysql -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span>  -d -v /opt/mysql/:/var/lib/mysql mysql:5.7
</code></pre> 
<p><strong>12、进入容器或者执行容器内的命令</strong></p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti <span class="token operator">&lt;</span>container_id_or_name<span class="token operator">&gt;</span> /bin/sh
$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token operator">&lt;</span>container_id_or_name<span class="token operator">&gt;</span> <span class="token function">hostname</span>
</code></pre> 
<p><strong>13、主机与容器之间拷贝数据</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">## 主机拷贝到容器</span>
$ <span class="token builtin class-name">echo</span> <span class="token string">'123'</span><span class="token operator">&gt;</span>/tmp/test.txt
$ <span class="token function">docker</span> <span class="token function">cp</span> /tmp/test.txt nginx:/tmp
$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti nginx <span class="token function">cat</span> /tmp/test.txt
<span class="token number">123</span>

<span class="token comment">## 容器拷贝到主机</span>
$ <span class="token function">docker</span> <span class="token function">cp</span> nginx:/tmp/test.txt ./
</code></pre> 
<p><strong>14、查看容器日志</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">## 查看全部日志</span>
$ <span class="token function">docker</span> logs nginx

<span class="token comment">## 实时查看最新日志</span>
$ <span class="token function">docker</span> logs -f nginx

<span class="token comment">## 从最新的100条开始查看</span>
$ <span class="token function">docker</span> logs --tail<span class="token operator">=</span><span class="token number">100</span> -f nginx
</code></pre> 
<p><strong>15、停止或者删除容器</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">## 停止运行中的容器</span>
$ <span class="token function">docker</span> stop nginx

<span class="token comment">## 启动退出容器</span>
$ <span class="token function">docker</span> start nginx

<span class="token comment">## 删除非运行中状态的容器</span>
$ <span class="token function">docker</span> <span class="token function">rm</span> nginx

<span class="token comment">## 删除运行中的容器</span>
$ <span class="token function">docker</span> <span class="token function">rm</span> -f nginx
</code></pre> 
<p><strong>16、查看容器或者镜像的明细</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">## 查看容器详细信息，包括容器IP地址等</span>
$ <span class="token function">docker</span> inspect nginx

<span class="token comment">## 查看镜像的明细信息</span>
$ <span class="token function">docker</span> inspect nginx:alpine
</code></pre> 
<h1>
<a id="4_Dockerfile_480"></a>4. Dockerfile使用</h1> 
<p><strong>Dockerfile</strong> 是一堆指令，在 <code>docker build</code> 的时候，按照该指令进行操作，最终生成我们期望的镜像</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> build <span class="token builtin class-name">.</span> -t ImageName:ImageTag -f Dockerfile
</code></pre> 
<p><strong>FROM</strong> 指定基础镜像，必须为第一个命令</p> 
<pre><code class="prism language-bash">格式：
    FROM <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span>
    FROM <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>tag<span class="token operator">&gt;</span>
示例：
    FROM mysql:5.7
注意：
    tag是可选的，如果不使用tag时，会使用latest版本的基础镜像
</code></pre> 
<p><strong>MAINTAINER</strong> 镜像维护者的信息</p> 
<pre><code class="prism language-bash">格式：
    MAINTAINER <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>
示例：
    MAINTAINER Edison
    MAINTAINER Edison@gmail.com
    MAINTAINER Edison <span class="token operator">&lt;</span>Edison@gmail.com<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>COPY|ADD</strong> 添加本地文件到镜像中</p> 
<pre><code class="prism language-bash">格式：
    COPY <span class="token operator">&lt;</span>src<span class="token operator">&gt;</span><span class="token punctuation">..</span>. <span class="token operator">&lt;</span>dest<span class="token operator">&gt;</span>
示例：
    ADD hom* /mydir/          <span class="token comment"># 添加所有以"hom"开头的文件</span>
    ADD <span class="token builtin class-name">test</span> relativeDir/     <span class="token comment"># 添加 "test" 到 `WORKDIR`/relativeDir/</span>
    ADD <span class="token builtin class-name">test</span> /absoluteDir/    <span class="token comment"># 添加 "test" 到 /absoluteDir/</span>
</code></pre> 
<p><strong>WORKDIR</strong> 工作目录</p> 
<pre><code class="prism language-bash">格式：
    WORKDIR /path/to/workdir
示例：
    WORKDIR /a  <span class="token punctuation">(</span>这时工作目录为/a<span class="token punctuation">)</span>
注意：
    通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行
</code></pre> 
<p><strong>RUN</strong> 构建镜像过程中执行命令</p> 
<pre><code class="prism language-bash">格式：
    RUN <span class="token operator">&lt;</span>command<span class="token operator">&gt;</span>
示例：
    RUN yum <span class="token function">install</span> nginx
    RUN pip <span class="token function">install</span> django
    RUN <span class="token function">mkdir</span> <span class="token builtin class-name">test</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf /var/lib/unusedfiles
注意：
    RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache
</code></pre> 
<p><strong>CMD</strong> 构建容器后调用，也就是在容器启动时才进行调用</p> 
<pre><code class="prism language-bash">格式：
    CMD <span class="token punctuation">[</span><span class="token string">"executable"</span>,<span class="token string">"param1"</span>,<span class="token string">"param2"</span><span class="token punctuation">]</span> <span class="token punctuation">(</span>执行可执行文件，优先<span class="token punctuation">)</span>
    CMD <span class="token punctuation">[</span><span class="token string">"param1"</span>,<span class="token string">"param2"</span><span class="token punctuation">]</span> <span class="token punctuation">(</span>设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数<span class="token punctuation">)</span>
    CMD <span class="token builtin class-name">command</span> param1 param2 <span class="token punctuation">(</span>执行shell内部命令<span class="token punctuation">)</span>
示例：
    CMD <span class="token punctuation">[</span><span class="token string">"/usr/bin/wc"</span>,<span class="token string">"--help"</span><span class="token punctuation">]</span>
    CMD <span class="token function">ping</span> www.baidu.com
注意：
    CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。
</code></pre> 
<p><strong>ENTRYPOINT</strong> 设置容器初始化命令，使其可执行化</p> 
<pre><code class="prism language-bash">格式：
    ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"executable"</span>, <span class="token string">"param1"</span>, <span class="token string">"param2"</span><span class="token punctuation">]</span> <span class="token punctuation">(</span>可执行文件, 优先<span class="token punctuation">)</span>
    ENTRYPOINT <span class="token builtin class-name">command</span> param1 param2 <span class="token punctuation">(</span>shell内部命令<span class="token punctuation">)</span>
示例：
    ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"/usr/bin/wc"</span>,<span class="token string">"--help"</span><span class="token punctuation">]</span>
注意：
    ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令
</code></pre> 
<p><strong>ENV</strong></p> 
<pre><code class="prism language-bash">格式：
    ENV <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>
    ENV <span class="token operator">&lt;</span>key<span class="token operator">&gt;=</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>
示例：
    ENV myName John
    ENV <span class="token assign-left variable">myCat</span><span class="token operator">=</span>fluffy
</code></pre> 
<p><strong>EXPOSE</strong></p> 
<pre><code class="prism language-bash">格式：
    EXPOSE <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
示例：
    EXPOSE <span class="token number">80</span> <span class="token number">443</span>
    EXPOSE <span class="token number">8080</span>
    EXPOSE <span class="token number">11211</span>/tcp <span class="token number">11211</span>/udp
注意：
    EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口
</code></pre> 
<p>以上很多名词相信大家一头雾水，来看这张图?</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/7d/84/o8nlkVR4_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p><strong>基础环境镜像</strong></p> 
<pre><code class="prism language-dockerfile">FROM java:8-alpine

RUN apk add --update ca-certificates &amp;&amp; rm -rf /var/cache/apk/* &amp;&amp; 
  find /usr/share/ca-certificates/mozilla/ -name "*.crt" -exec keytool -import -trustcacerts 
  -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts -storepass changeit -noprompt 
  -file {} -alias {} ; &amp;&amp; 
  keytool -list -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts --storepass changeit

ENV MAVEN_VERSION 3.5.4
ENV MAVEN_HOME /usr/lib/mvn
ENV PATH $MAVEN_HOME/bin:$PATH

RUN wget http://archive.apache.org/dist/maven/maven-3/$MAVEN_VERSION/binaries/apache-maven-$MAVEN_VERSION-bin.tar.gz &amp;&amp; 
  tar -zxvf apache-maven-$MAVEN_VERSION-bin.tar.gz &amp;&amp; 
  rm apache-maven-$MAVEN_VERSION-bin.tar.gz &amp;&amp; 
  mv apache-maven-$MAVEN_VERSION /usr/lib/mvn

RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app
</code></pre> 
<p><strong>前端镜像</strong></p> 
<pre><code class="prism language-dockerfile">FROM nginx:1.19.0-alpine

LABEL maintainer="mritd &lt;mritd@linux.com&gt;"

ARG TZ='Asia/Shanghai'
ENV TZ ${TZ}

RUN apk upgrade --update 
    &amp;&amp; apk add bash tzdata curl wget ca-certificates 
    &amp;&amp; ln -sf /usr/share/zoneinfo/${TZ} /etc/localtime 
    &amp;&amp; echo ${TZ} &gt; /etc/timezone 
    &amp;&amp; rm -rf /usr/share/nginx/html /var/cache/apk/*

COPY dist /usr/share/nginx/html

EXPOSE 80 443

CMD ["nginx", "-g", "daemon off;"]
</code></pre> 
<p><strong>java镜像</strong></p> 
<pre><code class="prism language-dockerfile">FROM java:8u111

ENV JAVA_OPTS "
-Xmx4096m 
-XX:MetaspaceSize=256m 
-XX:MaxMetaspaceSize=256m"
ENV JAVA_HOME /usr/java/jdk
ENV PATH ${PATH}:${JAVA_HOME}/bin

COPY target/myapp.jar myapp.jar

RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
RUN echo 'Asia/Shanghai' &gt;/etc/timezone

EXPOSE 9000
CMD java ${JAVA_OPTS} -jar myapp.jar
</code></pre> 
<h2>
<a id="_1_654"></a>? 通过1号进程理解容器的本质</h2> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti my-nginx-alpine /bin/sh
<span class="token comment">#/ ps aux</span>
</code></pre> 
<p>容器启动的时候可以通过命令去覆盖默认的CMD</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run -d --name xxx nginx:alpine <span class="token operator">&lt;</span>自定义命令<span class="token operator">&gt;</span>
<span class="token comment"># &lt;自定义命令&gt;会覆盖镜像中指定的CMD指令，作为容器的1号进程启动。</span>

$ <span class="token function">docker</span> run -d --name test-3 nginx:alpine <span class="token builtin class-name">echo</span> <span class="token number">123</span>

$ <span class="token function">docker</span> run -d --name test-4 nginx:alpine <span class="token function">ping</span> www.baidu.com
</code></pre> 
<p>本质上讲容器是利用 <strong>namespace</strong> 和 <strong>cgroup</strong> 等技术在宿主机中创建的独立的虚拟空间，这个空间内的网络、进程、挂载等资源都是隔离的。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti my-nginx /bin/sh
<span class="token comment">#/ ip addr</span>
<span class="token comment">#/ ls -l /</span>
<span class="token comment">#/ apt install xxx</span>
<span class="token comment">#/ #安装的软件对宿主机和其他容器没有任何影响，和虚拟机不同的是，容器间共享一个内核，所以容器内没法升级内核</span>
</code></pre> 
<h1>
<a id="5_Docker_682"></a>5. Docker网络</h1> 
<blockquote> 
 <p>docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间；<br>  <br> 多个容器之间是如何实现通信的呢？<br>  <br> 容器和宿主机之间又是如何实现的通信呢？<br>  <br> 使用-p参数是怎么实现的端口映射?<br>  <br> 带着这些问题，我们来学习一下docker的网络模型！</p> 
</blockquote> 
<h2>
<a id="__693"></a>? 网络模式</h2> 
<blockquote> 
 <p>我们在使用docker run创建Docker容器时，可以用–net选项指定容器的网络模式，Docker有以下4种网络模式：<br>  <br> 1、<strong>bridge模式</strong>，使用 <code>--net=bridge</code> 指定，默认设置；<br>  <br> 2、<strong>host模式</strong>，使用 <code>--net=host</code> 指定，容器内部网络空间共享宿主机的空间，效果类似直接在宿主机上启动一个进程，端口信息和宿主机共用；<br>  <br> 3、<strong>container模式</strong>，使用 <code>--net=container:NAME_or_ID</code> 指定；<br>  <br> 4、<strong>none模式</strong>，使用 <code>--net=none</code> 指定；</p> 
</blockquote> 
<h2>
<a id="_bridge_704"></a>? bridge模式</h2> 
<blockquote> 
 <p>之前在演示创建docker容器的时候其实是没有指定的网络模式的，如果不指定的话默认就会使用bridge模式，bridge本意是桥的意思，其实就是网桥模式。<br>  <br> 怎么理解网桥，如果需要做类比的话，我们可以把网桥看成一个二层的交换机设备，我们来看下面的图片<br>  <br> 交换机通信简图?<br> <img src="https://images2.imgbox.com/ff/bf/8uMmElpl_o.png" alt="在这里插入图片描述"><br> 交换机网络通信流程?<br> <img src="https://images2.imgbox.com/04/22/d7rCBKDe_o.png" alt="在这里插入图片描述"><br> 网桥模式示意图?<br> <img src="https://images2.imgbox.com/70/b2/o6RKtAyr_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2>
<a id="_Host_717"></a>? Host模式</h2> 
<p>容器内部不会创建网络空间，共享宿主机的网络空间。比如直接通过host模式创建 mysql 容器?</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run --net <span class="token function">host</span> -d --name mysql -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> mysql:5.7
</code></pre> 
<blockquote> 
 <p>容器启动后，会默认监听3306端口；<br>  <br> 由于网络模式是host，因为可以直接通过宿主机的 3306 端口进行访问服务，<br>  <br> 效果等同于在宿主机中直接启动 mysqld 的进程。</p> 
</blockquote> 
<h2>
<a id="_Conatiner_728"></a>? Conatiner模式</h2> 
<blockquote> 
 <p>这个模式指定新创建的容器和已经存在的一个容器共享一个 <strong>Network Namespace</strong>，而不是和宿主机共享。<br>  <br> 新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。<br> <img src="https://images2.imgbox.com/10/c2/syjAWnCc_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<pre><code class="prism language-bash"><span class="token comment">## 启动测试容器，共享mysql的网络空间</span>
$ <span class="token function">docker</span> run -ti --rm --net<span class="token operator">=</span>container:mysql busybox <span class="token function">sh</span>
/ <span class="token comment"># ip a</span>
/ <span class="token comment"># netstat -tlp|grep 3306</span>
/ <span class="token comment"># telnet localhost 3306</span>
</code></pre> 
<blockquote> 
 <p>在一些特殊的场景中非常有用，例如，<strong>kubernetes</strong> 的 <code>pod</code>；<br>  <br> <strong>kubernetes</strong> 为 <code>pod</code> 创建一个基础设施容器，同一 <code>pod</code> 下的其他容器都以 container模式 共享这个基础设施容器的网络命名空间，相互之间以 localhost 访问，构成一个统一的整体。</p> 
</blockquote> 
<h2>
<a id="_None_745"></a>? None模式</h2> 
<p>只会创建对应的网络空间，不会配置网络堆栈（网卡、路由等）。</p> 
<pre><code class="prism language-bash"><span class="token comment"># 创建none的容器</span>
$ <span class="token function">docker</span> run -it  --name<span class="token operator">=</span>network-none --net<span class="token operator">=</span>none nginx:alpine <span class="token function">sh</span>
<span class="token comment"># ifconfig</span>
</code></pre> 
<p>在宿主机中操作：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 创建虚拟网卡对</span>
$ <span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> A <span class="token builtin class-name">type</span> veth peer name B
<span class="token comment"># A端插入到docker0网桥</span>
$ brctl addif docker0 A
$ <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> A up

<span class="token comment"># B端插入到network-none容器中，需要借助ip netns,因此需要显示的创建命名network namespace</span>
$ <span class="token assign-left variable">PID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> inspect -f <span class="token string">'{<!-- -->{.State.Pid}}'</span> network-none<span class="token variable">)</span></span>
$ <span class="token function">mkdir</span> -p /var/run/netns
$ <span class="token function">ln</span> -s /proc/<span class="token variable">$PID</span>/ns/net /var/run/netns/<span class="token variable">$PID</span>

<span class="token comment"># B端放到容器的命名空间</span>
$ <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> B netns <span class="token variable">$PID</span>
$ <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$PID</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev B name eth0  <span class="token comment"># 修改设备名称为eth0，和docker默认行为一致</span>
$ <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$PID</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> eth0 up

<span class="token comment"># 设置ip</span>
$ <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$PID</span> <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.17</span>.0.100/16 dev eth0
<span class="token comment"># 添加默认路由，指定给docker0网桥</span>
$ <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$PID</span> <span class="token function">ip</span> route <span class="token function">add</span> default via <span class="token number">172.17</span>.0.1

<span class="token comment"># 测试容器间通信</span>
</code></pre> 
<h1>
<a id="6__779"></a>6. 总结</h1> 
<blockquote> 
 <p>1、为了解决软件交付过程中的环境依赖，同时提供一种更加轻量的虚拟化技术，Docker出现了。<br>  <br> 2、2013年诞生，15年开始迅速发展，从17.03月开始，使用时间日期管理版本，稳定版以每季度为准。<br>  <br> 3、Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理。<br>  <br> 4、使用 yum 部署 docker，启动后通过操作 docker 这个命令行，自动调用 docker daemon 完成容器相关操作。<br>  <br> 5、常用操作，围绕 <code>镜像|容器|仓库</code> 三大核心要素；<br>  <br> 6、通过 dockerfile 构建业务镜像，先使用基础镜像，然后通过一系列的指令把我们的业务应用所需要的运行环境和依赖都打包到镜像中，然后通过 CMD 或者 ENTRYPOINT 指令把镜像启动时的入口制定好，完成封装即可。<br>  <br> 有点类似于，先找来一个集装箱模板(基础镜像)，然后把项目依赖的服务都扔到集装箱中，然后设置好服务的启动入口，关闭箱门，即完成了业务镜像的制作。<br>  <br> 7、docker的网络模式分为4种，<strong>最常用的为bridge和host模式</strong>。bridge模式通过<code>docker0网桥</code>，启动容器的时候通过创建一对虚拟网卡，将容器连接在桥上，同时维护了虚拟网卡与网桥端口的关系，实现容器间的通信。<br>  <br> 容器与宿主机之间的通信通过iptables端口映射的方式，docker利用 <strong>iptables</strong> 的 <strong>PREROUTING</strong> 和 <strong>POSTROUTING</strong> 的 <strong>nat</strong> 功能，实现了SNAT与DNAT，使得容器内部的服务被完美的保护起来。<br>  <br> <img src="https://images2.imgbox.com/ba/ae/tEeDgvBN_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>以上就是Docker的全部内容，但个别繁琐的点我都给去掉了，比如Docker网络中的bridge模式，本来是有一个抓包演示的，但是会涉及到iptables链表、wireshark合并包进行分析等…我觉得这东西过于深入了，就给去掉了。</p> 
<p>其实这篇文章主要是为后续的 <strong>Kubernetes</strong> 作铺垫（<em>毕竟我的CKA证书不能白拿</em>?）</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>