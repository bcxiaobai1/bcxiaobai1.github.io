<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【两万字精编~建议抱走】蓝桥杯算法竞赛系列第0章——蓝桥必考点及标准模板库STL（下） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【两万字精编~建议抱走】蓝桥杯算法竞赛系列第0章——蓝桥必考点及标准模板库STL（下）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>欢迎回到：<span style="color:#956fe7">遇见蓝桥遇见你，不负代码不负卿！</span></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8A%E5%BA%93%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8A%E5%BA%93%E5%87%BD%E6%95%B0" title="【补充】：常用头文件及库函数">【补充】：常用头文件及库函数</a></p> 
<p id="1.%23include%3Cstdio.h%3E-toc" style="margin-left:40px"><a href="#1.%23include%3Cstdio.h%3E" title="1.#include">1.#include</a></p> 
<p id="sscanf()%20%E5%92%8C%20sprintf()-toc" style="margin-left:80px"><a href="#sscanf%28%29%20%E5%92%8C%20sprintf%28%29" title="sscanf() 和 sprintf()">sscanf() 和 sprintf()</a></p> 
<p id="2.%23include%3Cstdlib.h%3E-toc" style="margin-left:40px"><a href="#2.%23include%3Cstdlib.h%3E" title="2.#include">2.#include</a></p> 
<p id="3.%23include%3Ctime.h%3E-toc" style="margin-left:40px"><a href="#3.%23include%3Ctime.h%3E" title="3.#include">3.#include</a></p> 
<p id="4.%23include%3Cmath.h%3E-toc" style="margin-left:40px"><a href="#4.%23include%3Cmath.h%3E" title="4.#include">4.#include</a></p> 
<p id="(1).fabs(double%20x)-toc" style="margin-left:80px"><a href="#%281%29.fabs%28double%20x%29" title="(1).fabs(double x)">(1).fabs(double x)</a></p> 
<p id="(2).pow(double%20r%2C%20double%20p)-toc" style="margin-left:80px"><a href="#%282%29.pow%28double%20r%2C%20double%20p%29" title="(2).pow(double r, double p)">(2).pow(double r, double p)</a></p> 
<p id="(3).sqrt(double%20x)-toc" style="margin-left:80px"><a href="#%283%29.sqrt%28double%20x%29" title="(3).sqrt(double x)">(3).sqrt(double x)</a></p> 
<p id="5.%23include%3Cstring.h%3E-toc" style="margin-left:40px"><a href="#5.%23include%3Cstring.h%3E" title="5.#include">5.#include</a></p> 
<p id="(1).strlen()-toc" style="margin-left:80px"><a href="#%281%29.strlen%28%29" title="(1).strlen()">(1).strlen()</a></p> 
<p id="(2).strcmp()-toc" style="margin-left:80px"><a href="#%282%29.strcmp%28%29" title="(2).strcmp()">(2).strcmp()</a></p> 
<p id="(3).strcpy()-toc" style="margin-left:80px"><a href="#%283%29.strcpy%28%29" title="(3).strcpy()">(3).strcpy()</a></p> 
<p id="(4).strcat()-toc" style="margin-left:80px"><a href="#%284%29.strcat%28%29" title="(4).strcat()">(4).strcat()</a></p> 
<p id="6.%23include%3Cvector%3E%C2%A0-toc" style="margin-left:40px"><a href="#6.%23include%3Cvector%3E%C2%A0" title="6.#include ">6.#include </a></p> 
<p id="7.%23include%3Cqueue%3E-toc" style="margin-left:40px"><a href="#7.%23include%3Cqueue%3E" title="7.#include">7.#include</a></p> 
<p id="8.%23include%3Cstack%3E-toc" style="margin-left:40px"><a href="#8.%23include%3Cstack%3E" title="8.#include">8.#include</a></p> 
<p id="9.%23include%3Calgorithm%3E-toc" style="margin-left:40px"><a href="#9.%23include%3Calgorithm%3E" title="9.#include">9.#include</a></p> 
<p id="%E4%B8%80%E3%80%81string%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81string%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3" title="一、string的常见用法详解">一、string的常见用法详解</a></p> 
<p id="1.string%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px"><a href="#1.string%E7%9A%84%E5%AE%9A%E4%B9%89" title="1.string的定义">1.string的定义</a></p> 
<p id="2.string%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px"><a href="#2.string%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE" title="2.string中内容的访问">2.string中内容的访问</a></p> 
<p id="(1).%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px"><a href="#%281%29.%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE" title="(1).通过下标访问">(1).通过下标访问</a></p> 
<p id="(3).%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px"><a href="#%283%29.%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE" title="(3).通过迭代器访问">(3).通过迭代器访问</a></p> 
<p id="3.string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px"><a href="#3.string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90" title="3.string常用函数实例解析">3.string常用函数实例解析</a></p> 
<p id="(1).operator%2B%3D-toc" style="margin-left:80px"><a href="#%281%29.operator%2B%3D" title="(1).operator+=">(1).operator+=</a></p> 
<p id="(2).compare%20operator-toc" style="margin-left:80px"><a href="#%282%29.compare%20operator" title="(2).compare operator">(2).compare operator</a></p> 
<p id="(3).length()%20%2F%20size()-toc" style="margin-left:80px"><a href="#%283%29.length%28%29%20%2F%20size%28%29" title="(3).length() / size()">(3).length() / size()</a></p> 
<p id="(4).insert()-toc" style="margin-left:80px"><a href="#%284%29.insert%28%29" title="(4).insert()">(4).insert()</a></p> 
<p id="(5).erase()-toc" style="margin-left:80px"><a href="#%285%29.erase%28%29" title="(5).erase()">(5).erase()</a></p> 
<p id="(6).clear()-toc" style="margin-left:80px"><a href="#%286%29.clear%28%29" title="(6).clear()">(6).clear()</a></p> 
<p id="(7).substr()-toc" style="margin-left:80px"><a href="#%287%29.substr%28%29" title="(7).substr()">(7).substr()</a></p> 
<p id="(8).string%3A%3Anpos-toc" style="margin-left:80px"><a href="#%288%29.string%3A%3Anpos" title="(8).string::npos">(8).string::npos</a></p> 
<p id="(9).find()-toc" style="margin-left:80px"><a href="#%289%29.find%28%29" title="(9).find()">(9).find()</a></p> 
<p id="(10).replace()-toc" style="margin-left:80px"><a href="#%2810%29.replace%28%29" title="(10).replace()">(10).replace()</a></p> 
<p id="%E4%BA%8C%E3%80%81queue%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81queue%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3" title="二、queue的常见用法详解">二、queue的常见用法详解</a></p> 
<p id="1.queue%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px"><a href="#1.queue%E7%9A%84%E5%AE%9A%E4%B9%89" title="1.queue的定义">1.queue的定义</a></p> 
<p id="2.queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px"><a href="#2.queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE" title="2.queue容器内元素的访问">2.queue容器内元素的访问</a></p> 
<p id="3.queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px"><a href="#3.queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90" title="3.queue常用函数实例解析">3.queue常用函数实例解析</a></p> 
<p id="(1).push()-toc" style="margin-left:80px"><a href="#%281%29.push%28%29" title="(1).push()">(1).push()</a></p> 
<p id="(2).front()%2C%20back()-toc" style="margin-left:80px"><a href="#%282%29.front%28%29%2C%20back%28%29" title="(2).front(), back()">(2).front(), back()</a></p> 
<p id="(3).pop()-toc" style="margin-left:80px"><a href="#%283%29.pop%28%29" title="(3).pop()">(3).pop()</a></p> 
<p id="(4).empty()-toc" style="margin-left:80px"><a href="#%284%29.empty%28%29" title="(4).empty()">(4).empty()</a></p> 
<p id="(5).size()-toc" style="margin-left:80px"><a href="#%285%29.size%28%29" title="(5).size()">(5).size()</a></p> 
<p id="%E4%B8%89%E3%80%81stack%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81stack%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3" title="三、stack的常见用法详解">三、stack的常见用法详解</a></p> 
<p id="1.stack%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px"><a href="#1.stack%E7%9A%84%E5%AE%9A%E4%B9%89" title="1.stack的定义">1.stack的定义</a></p> 
<p id="2.stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px"><a href="#2.stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE" title="2.stack容器内元素的访问">2.stack容器内元素的访问</a></p> 
<p id="3.stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px"><a href="#3.stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90" title="3.stack常用函数实例解析">3.stack常用函数实例解析</a></p> 
<p id="(1).push()-toc" style="margin-left:80px"><a href="#%281%29.push%28%29" title="(1).push()">(1).push()</a></p> 
<p id="(2).top()-toc" style="margin-left:80px"><a href="#%282%29.top%28%29" title="(2).top()">(2).top()</a></p> 
<p id="(3).pop()-toc" style="margin-left:80px"><a href="#%283%29.pop%28%29" title="(3).pop()">(3).pop()</a></p> 
<p id="(4).empty()-toc" style="margin-left:80px"><a href="#%284%29.empty%28%29" title="(4).empty()">(4).empty()</a></p> 
<p id="(5).size()-toc" style="margin-left:80px"><a href="#%285%29.size%28%29" title="(5).size()">(5).size()</a></p> 
<p id="%E5%9B%9B%E3%80%81algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0" title="四、algorithm头文件下的常用函数">四、algorithm头文件下的常用函数</a></p> 
<p id="1.max()%E3%80%81min()%E5%92%8Cabs()-toc" style="margin-left:40px"><a href="#1.max%28%29%E3%80%81min%28%29%E5%92%8Cabs%28%29" title="1.max()、min()和abs()">1.max()、min()和abs()</a></p> 
<p id="(2).swap()-toc" style="margin-left:40px"><a href="#%282%29.swap%28%29" title="2.swap()">2.swap()</a></p> 
<p id="(3).reverse()-toc" style="margin-left:40px"><a href="#%283%29.reverse%28%29" title="3.reverse()">3.reverse()</a></p> 
<p id="(4).next_permutation()-toc" style="margin-left:40px"><a href="#%284%29.next_permutation%28%29" title="4.next_permutation()">4.next_permutation()</a></p> 
<p id="(5).fill()-toc" style="margin-left:40px"><a href="#%285%29.fill%28%29" title="5.fill()">5.fill()</a></p> 
<p id="(6).sort()-toc" style="margin-left:40px"><a href="#%286%29.sort%28%29" title="6.sort()">6.sort()</a></p> 
<p id="%3C1%3E.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px"><a href="#%3C1%3E.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F" title="&lt;1&gt;.基本数据类型数组的排序">&lt;1&gt;.基本数据类型数组的排序</a></p> 
<p id="%3C2%3E.%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px"><a href="#%3C2%3E.%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F" title="&lt;2&gt;.结构体数组的排序">&lt;2&gt;.结构体数组的排序</a></p> 
<p id="%3C3%3E.%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px"><a href="#%3C3%3E.%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8E%92%E5%BA%8F" title="&lt;3&gt;.容器的排序">&lt;3&gt;.容器的排序</a></p> 
<p id="(7).lower_bound()%E5%92%8Cupper_bound()-toc" style="margin-left:40px"><a href="#%287%29.lower_bound%28%29%E5%92%8Cupper_bound%28%29" title="7.lower_bound()和upper_bound()">7.lower_bound()和upper_bound()</a></p> 
<p id="%E4%BA%94%E3%80%81%E8%93%9D%E6%A1%A5%E7%BB%93%E8%AF%AD%EF%BC%9A%E9%81%87%E8%A7%81%E8%93%9D%E6%A1%A5%E9%81%87%E8%A7%81%E4%BD%A0%EF%BC%8C%E4%B8%8D%E8%B4%9F%E4%BB%A3%E7%A0%81%E4%B8%8D%E8%B4%9F%E5%8D%BF%EF%BC%81-toc" style="margin-left:0px"><a href="#%E4%BA%94%E3%80%81%E8%93%9D%E6%A1%A5%E7%BB%93%E8%AF%AD%EF%BC%9A%E9%81%87%E8%A7%81%E8%93%9D%E6%A1%A5%E9%81%87%E8%A7%81%E4%BD%A0%EF%BC%8C%E4%B8%8D%E8%B4%9F%E4%BB%A3%E7%A0%81%E4%B8%8D%E8%B4%9F%E5%8D%BF%EF%BC%81" title="五、蓝桥结语：遇见蓝桥遇见你，不负代码不负卿！">五、蓝桥结语：遇见蓝桥遇见你，不负代码不负卿！</a></p> 
<hr id="hr-toc">
<p>【前言】</p> 
<blockquote> 
 <p>这篇是上次文章的后续哦，铁汁们可以先回顾一下上篇的内容。</p> 
</blockquote> 
<p><a class="link-info" href="https://blog.csdn.net/weixin_57544072/article/details/121311117" title="蓝桥杯算法竞赛系列第0章——蓝桥必考点及标准模板库STL（上）（万字博文，建议抱走）_安然无虞的博客-CSDN博客">蓝桥杯算法竞赛系列第0章——蓝桥必考点及标准模板库STL（上）（万字博文，建议抱走）_安然无虞的博客-CSDN博客</a></p> 
<blockquote> 
 <p>上次有好几位铁汁建议我多换点图片，表示看腻了，也有不少热心小友私发给了我一些，但是由于格式大小的问题，能用的不多，不过在这里还是要特别感谢一下哈，抱拳啦。</p> 
</blockquote> 
<p style="text-align:center"><img alt="" height="385" src="https://images2.imgbox.com/9e/5c/em7M5IT4_o.jpg" width="570"></p> 
<h1 id="%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8A%E5%BA%93%E5%87%BD%E6%95%B0">【补充】：常用头文件及库函数</h1> 
<blockquote> 
 <ul>
<li>#include&lt;stdio.h&gt;</li>
<li>#include&lt;stdlib.h&gt;</li>
<li>#include&lt;time.h&gt;</li>
<li>#include&lt;math.h&gt;</li>
<li>#include&lt;string.h&gt;</li>
<li>#include&lt;vector&gt;</li>
<li>#include&lt;string&gt;</li>
<li>#include&lt;queue&gt;</li>
<li>#include&lt;stack&gt;</li>
<li>#include&lt;algorithm&gt;</li>
</ul>
</blockquote> 
<h2 id="1.%23include%3Cstdio.h%3E">1.#include&lt;stdio.h&gt;</h2> 
<blockquote> 
 <ul>
<li>scanf()</li>
<li>printf()</li>
<li>getchar()</li>
<li>putchar()</li>
<li>gets()</li>
<li>puts()</li>
<li>sscanf()</li>
<li>sprintf()</li>
</ul>
</blockquote> 
<blockquote> 
 <p><span style="color:#4da8ee">标准输入输出头文件，当然除了scanf() 和 printf() 很重要外，sscanf() 和 sprintf()也是非常重要的，</span>对于这两个库函数，老师从未讲过，但是看题解时经常出现，它们是用来处理字符串的利器。待会再谈它们，<span style="color:#956fe7">先讲一下scanf() 的弊端，对于scanf() 函数，不能读入空格，遇到空格就结束了</span>，所以处理起字符串就很不方便。所以这里还有两个库函数用来处理字符串：gets() 和 puts() ,<span style="color:#956fe7"> gets() 用来输入一行字符串，识别'n' 结束，遇到空格不会结束哦，puts() 用来输出一行字符串，并且紧跟一个换行,</span>对于putchar()和getchar() 用得不多，有兴趣可自行了解哦。</p> 
</blockquote> 
<h3 id="sscanf()%20%E5%92%8C%20sprintf()">sscanf() 和 sprintf()</h3> 
<blockquote> 
 <p><span style="color:#4da8ee">sscanf() 与 sprintf() 是处理字符串问题的利器，我们很有必要学会它们(sscanf() 从单词上可理解为 string + scanf , sprintf 则可理解为 string + printf, 均在stdio.h 头文件下) 。</span>先来回顾一下scanf() 和 printf(), 如果想要从屏幕上输入int 型变量n 并将int 型变量 n 输出到屏幕上，则可以写成下面这样：</p> 
</blockquote> 
<pre><code class="language-cpp">scanf("%d", &amp;n);
printf("%d", n);</code></pre> 
<p>事实上，上面的写法其实可以表示成下面的样子，其中screen 表示屏幕：</p> 
<pre><code class="language-cpp">scanf(screen, "%d", &amp;n);
printf(screen, "%d", n);</code></pre> 
<p>可以发现，scanf() 的输入其实是把screen 的内容以"%d" 的格式传输到n 中（即从左至右），而printf() 的输出则是把n 以“%d” 的格式传输到screen 上（即从右至左）</p> 
<p>sscanf() 和 sprintf() 与上面的格式是相同的，只不过把screen 换成了字符数组（假设定义了一个char 数组 str[100]）,如下所示：</p> 
<pre><code class="language-cpp">sscanf(str, "%d", &amp;n);
sprintf(str, "%d", n);</code></pre> 
<p><span style="color:#956fe7">上面的sscanf() 写法的作用是把字符数组str 中的内容以"%d" 的格式写到n 中（还是从左至右）</span></p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int n = 0;
	char str[100] = "123";
	sscanf(str, "%d", &amp;n);

	printf("%dn", n);//输出123

	return 0;
}</code></pre> 
<p><span style="color:#956fe7">而sprintf() 写法的作用是把n 以"%d" 的格式写到str 字符数组中（还是从右至左）</span></p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int n = 233;
	char str[100];
	sprintf(str, "%d", n);
	printf("%sn", str);//输出233
	return 0;
}</code></pre> 
<p>上面只是一些简单的应用，事实上，可以像使用scanf() 和 printf() 那样进行复杂的格式的输入和输出。例如下面的代码使用sscanf() 将字符数组str 中的内容按"%d:%lf,%s"的格式写到int 型变量n、double 型变量db、char型数组str2中</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int n;
	double db;
	char str[100] = "2048:3.14,hello", str2[100];
	sscanf(str, "%d:%lf,%s", &amp;n, &amp;db, str2);
	printf("n = %d, db = %lf, str2 = %sn", n, db, str2);
	return 0;
}</code></pre> 
<p>类似的，下面的代码使用sprintf() 将int 型变量n 、double 型变量db、char 型数组str2 按"%d:%lf,%s" 的格式写到字符数组str 中</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int n = 12;
	double db = 3.1415;
	char str[100], str2[100] = "good";
	sprintf(str, "%d:%.2lf,%s", n, db, str2);
	printf("str = %sn", str);
	return 0;
}</code></pre> 
<h2 id="2.%23include%3Cstdlib.h%3E">2.#include&lt;stdlib.h&gt;</h2> 
<blockquote> 
 <p><span style="color:#4da8ee">主要用于生成随机数以及动态内存开辟，常用的库函数有srand((unsigned int) time(NULL)),rand() 和动态内存开辟用的malloc(),用new会更简单一些</span></p> 
</blockquote> 
<h2 id="3.%23include%3Ctime.h%3E">3.#include&lt;time.h&gt;</h2> 
<blockquote> 
 <p><span style="color:#4da8ee">上面生成随机数的时候，常用time()函数用于生成时间戳，作为随机数种子</span></p> 
</blockquote> 
<h2 id="4.%23include%3Cmath.h%3E">4.#include&lt;math.h&gt;</h2> 
<blockquote> 
 <ul>
<li>fabs()</li>
<li>sqrt()</li>
<li>pow()</li>
<li>floor()</li>
<li>ceil()</li>
<li>round()</li>
</ul>
</blockquote> 
<blockquote> 
 <p><span style="color:#4da8ee">用数学函数可以节省大量的时间，所以一定要记住，对于很常用的其实也就是fabs()、sqrt()和pow()</span></p> 
</blockquote> 
<h3 id="(1).fabs(double%20x)">(1).fabs(double x)</h3> 
<blockquote> 
 <p><span style="color:#956fe7">该函数用于对double 型变量取绝对值。</span></p> 
</blockquote> 
<h3 id="(2).pow(double%20r%2C%20double%20p)">(2).pow(double r, double p)</h3> 
<blockquote> 
 <p><span style="color:#956fe7">该函数用于返回 r ^ p ，要求r 和 p 都是double类型的</span></p> 
</blockquote> 
<h3 id="(3).sqrt(double%20x)">(3).sqrt(double x)</h3> 
<blockquote> 
 <p><span style="color:#956fe7">该函数用于返回double型变量的算数平方根</span></p> 
 <p>在这里就只简单介绍这三个最常用的。</p> 
</blockquote> 
<h2 id="5.%23include%3Cstring.h%3E">5.#include&lt;string.h&gt;</h2> 
<blockquote> 
 <ul>
<li>strlen()</li>
<li>strcmp()</li>
<li>strcpy()</li>
<li>strcat()</li>
</ul>
</blockquote> 
<h3 id="(1).strlen()">(1).strlen()</h3> 
<blockquote> 
 <p><span style="color:#956fe7">strlen()函数可以得到字符数组中第一个之前的字符的个数</span></p> 
</blockquote> 
<h3 id="(2).strcmp()">(2).strcmp()</h3> 
<blockquote> 
 <p>strcmp()函数返回两个字符串大小的比较结果，比较原则是按字典序，所谓字典序就是字符串在字典中的顺序，因此如果有两个字符数组str 1 和 str 2, 且满足str 1[0...k - 1] == str 2[0...k - 1]、str1[k] &lt; str2[k], 那么就说str 1的字典序小于str2。例如"a" 的字典序小于"b"、"aaaa" 的字典序小于"aab"</p> 
</blockquote> 
<blockquote> 
 <p>strcmp()函数的返回值：</p> 
 <ul>
<li><span style="color:#4da8ee">如果字符数组1 &lt; 字符数组2，则返回一个负整数（不一定是-1，由编译器决定）</span></li>
<li><span style="color:#4da8ee">如果字符数组1 == 字符数组2，则返回0</span></li>
<li><span style="color:#4da8ee">如果字符数组1 &gt; 字符数组2，则返回一个正整数（不一定是1，由编译器决定）</span></li>
</ul>
</blockquote> 
<h3 id="(3).strcpy()">(3).strcpy()</h3> 
<blockquote> 
 <p><span style="color:#4da8ee">strcpy()函数可以把一个字符串复制给另一个字符串</span>，格式如下：</p> 
</blockquote> 
<pre><code class="language-cpp">strcpy(字符数组1，字符数组2);</code></pre> 
<blockquote> 
 <p><span style="color:#956fe7">注意哦，是把字符数组2复制给字符数组1，</span>这里的“复制” 包括了结束标志  </p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
	char str1[50] = "Thank";
	char str2[50] = "you for your smile.";
	strcpy(str1, str2);
	puts(str1);//输出you for your smile.
	//printf("%sn", str1);
	return 0;

}</code></pre> 
<h3 id="(4).strcat()">(4).strcat()</h3> 
<blockquote> 
 <p><span style="color:#956fe7">strcat()可以把一个字符串拼接到另一个字符串的后面</span></p> 
</blockquote> 
<pre><code class="language-cpp">strcat(字符数组1， 字符数组2)；</code></pre> 
<blockquote> 
 <p><span style="color:#956fe7">注意哦，是把字符数组2拼接到字符数组1的后面 </span></p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
	char str1[50] = "Thank";
	char str2[50] = "you for your smile.";
	strcat(str1, str2);
	puts(str1);//输出 Thankyou for your smile.
	//printf("%sn", str1);
	return 0;
	return 0;
}</code></pre> 
<h2 id="6.%23include%3Cvector%3E%C2%A0">6.#include&lt;vector&gt; </h2> 
<blockquote> 
 <p>常用函数：</p> 
 <ul>
<li>push_back()</li>
<li>pop_back()</li>
<li>size()</li>
<li>clear()</li>
</ul>
</blockquote> 
<h2 id="7.%23include%3Cqueue%3E">7.#include&lt;queue&gt;</h2> 
<blockquote> 
 <p>常用函数</p> 
 <ul>
<li>push()</li>
<li>pop()</li>
<li>front()</li>
<li>back()</li>
<li>empty()</li>
<li>size()</li>
</ul>
</blockquote> 
<h2 id="8.%23include%3Cstack%3E">8.#include&lt;stack&gt;</h2> 
<blockquote> 
 <p>常用函数：</p> 
 <ul>
<li>push()</li>
<li>pop()</li>
<li>top()</li>
<li>empty()</li>
<li>size()</li>
</ul>
</blockquote> 
<h2 id="9.%23include%3Calgorithm%3E">9.#include&lt;algorithm&gt;</h2> 
<blockquote> 
 <p>常用函数：</p> 
 <ul>
<li>max()</li>
<li>min()</li>
<li>swap()</li>
<li>fill()</li>
<li>sort()</li>
</ul>
</blockquote> 
<p style="text-align:center"><img alt="" height="271" src="https://images2.imgbox.com/90/26/c4ox66u6_o.jpg" width="178"></p> 
<blockquote> 
 <p>下面在介绍一些常见的容器： </p> 
</blockquote> 
<h1 id="%E4%B8%80%E3%80%81string%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3">一、string的常见用法详解</h1> 
<blockquote> 
 <p>在C语言中，一般使用字符数组char str[ ] 来存放字符串，但是使用字符数组有时会显得操作麻烦，而且容易因经验不足产生错误，得不偿失。为了使编程者可以更方便的对字符串进行操作，C++在STL中加入了string类型，对字符串常用的需求功能进行了封装，使得操作起来更方便，且不易出错。</p> 
</blockquote> 
<blockquote> 
 <p>如果要使用string，需要添加string头文件，即#include&lt;string&gt;（注意string.h 和 string 是不一样的头文件）。除此之外，还需要在头文件下面加上一句："using namespace std;", 这样就可以在代码中使用string了。下面来看string的一些常见用法。</p> 
</blockquote> 
<h2 id="1.string%E7%9A%84%E5%AE%9A%E4%B9%89">1.string的定义</h2> 
<p>定义string的方式跟基本数据类型相同，只需要在string后面跟上变量名即可：</p> 
<pre><code class="language-cpp">string str;</code></pre> 
<p>如果要初始化，可以直接给string类型的变量进行赋值：</p> 
<pre><code class="language-cpp">string str = "abcd"</code></pre> 
<h2 id="2.string%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE">2.string中内容的访问</h2> 
<h3 id="(1).%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE">(1).通过下标访问</h3> 
<p>一般来说，可以直接像字符数组那样去访问string：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;

int main()
{
	string str = "abcd";
	for (int i = 0; i &lt; str.length(); i++)
	{
		printf("%c ", str[i]);//输出a b c d
	}
	return 0;
}</code></pre> 
<p><span style="color:#4da8ee">注意哦，如果要读入和输出整个字符串，则只能用cin 和  cout:</span></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;//cin和cout在iostream头文件中，而不是stdio.h
#include&lt;string&gt;

using namespace std;
int main()
{
	string str;
	cin &gt;&gt; str;
	cout &lt;&lt; str;

	return 0;
}</code></pre> 
<p>上面的代码对任意的字符串输入，都会输出同样的字符串。</p> 
<p>那么，真的没有办法用printf来输出string吗？其实是有的，即用c_str()将string类型转换为字符数组进行输出，示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str = "abcd";
	printf("%sn", str.c_str());//将string型str使用c_str()变成字符数组
	return 0;
}</code></pre> 
<h3 id="(3).%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE">(3).通过迭代器访问</h3> 
<p>一般仅通过（1）即可满足访问的要求，但是有些函数比如insert()与erase()则要求以迭代器为参数，因此还是需要学习一下string迭代器的用法。</p> 
<p>由于string不像其他STL容器那样需要参数，因此可以直接入下定义：</p> 
<pre><code class="language-cpp">string::iterator it;</code></pre> 
<p>这样就得到了迭代器it, 并且可以通过*it 来访问string里的每一位：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str = "abcd";
	for (string::iterator it = str.begin(); it != str.end(); it++)
	{
		printf("%c ", *it);//输出a b c d
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p>最后指出，string和vector一样，支持直接对迭代器进行加减某个数字，如str.begin() + 3的写法是可行的</p> 
</blockquote> 
<h2 id="3.string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90">3.string常用函数实例解析</h2> 
<blockquote> 
 <ul>
<li>operator+=</li>
<li>compare operator</li>
<li>length() / size()</li>
<li>insert()</li>
<li>erase()</li>
<li>clear()</li>
<li>substr()</li>
<li>string::nops</li>
<li>find()</li>
<li>replace()</li>
</ul>
</blockquote> 
<h3 id="(1).operator%2B%3D">(1).operator+=</h3> 
<blockquote> 
 <p>这是string的加法，可以将两个string<span style="color:#956fe7">直接拼接</span>起来</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str1 = "abc", str2 = "xyz", str3;
	str3 = str1 + str2;//将str1和str2拼接，赋值给str3
	str1 = str1 + str2;//将str2直接拼接到str1上

	cout &lt;&lt; str1 &lt;&lt; endl;//输出abcxyz
	cout &lt;&lt; str3 &lt;&lt; endl;//输出abcxyz

	return 0;
}</code></pre> 
<h3 id="(2).compare%20operator">(2).compare operator</h3> 
<blockquote> 
 <p>两个string类型可以直接使用==、!=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则是字典序。</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str1 = "aa", str2 = "aaa", str3 = "abc", str4 = "xyz";
	if (str1 &lt; str2)//如果str1字典序小于str2，输出ok1
	{
		printf("ok1n");//输出ok1
	}

	if (str1 != str3)//如果str1和str3字典序不等，输出ok2
	{
		printf("ok2n");//输出ok2
	}

	if (str4 &gt;= str3)//如果str4字典序大于等于str3，输出ok3
	{
		printf("ok3n");//输出ok3
	}
	return 0;
}</code></pre> 
<h3 id="(3).length()%20%2F%20size()">(3).length() / size()</h3> 
<blockquote> 
 <p>length()返回string的长度，即存放的字符数。时间复杂度为O(1)。size()与length()基本相同</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">string str = "abcdef";
printf("%d %dn", str.length(), str.size());//输出6 6</code></pre> 
<h3 id="(4).insert()">(4).insert()</h3> 
<blockquote> 
 <p>string的insert()函数有很多种写法，这里给出几种常用的写法。时间复杂度为O(N)</p> 
</blockquote> 
<blockquote> 
 <p>1.insert(pos, string), 在pos号位置插入一个字符串string</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">string str = "abcxyz", str2 = "opq";
str.insert(3, str2);//往str[3]处插入opq，将括号里的str2直接写成"opq"也是可以的
cout&lt;&lt;str&lt;&lt;endl;//输出abcopqxyz</code></pre> 
<blockquote> 
 <p>2.insert(it, it2, it3), it 为原字符串的欲插入位置，it2 和 it3 为待插字符串的首尾迭代器，用来表示串[it2, it3)将被插在it 的位置上</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str = "abcxyz", str2 = "opq";//str为原字符串，str2为待插字符串
	//在str的3号位（即c和x之间）插入str2
	str.insert(str.begin() + 3, str2.begin(), str2.end());
	cout &lt;&lt; str &lt;&lt; endl;//输出abcopqxyz
	return 0;
}</code></pre> 
<h3 id="(5).erase()">(5).erase()</h3> 
<blockquote> 
 <p>erase()有两种用法：删除单个元素、删除一个区间内的所有元素。时间复杂度均为O(N)</p> 
</blockquote> 
<blockquote> 
 <p>1.删除单个元素：str.erase(it) 用于删除单个元素，it为需要删除的元素的迭代器</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;

using namespace std;
int main()
{
	string str = "abcdefg";
	str.erase(str.begin() + 4);//删除4号位（即e）
	cout &lt;&lt; str &lt;&lt; endl;//输出abcdfg
	return 0;
}</code></pre> 
<blockquote> 
 <p>2.删除一个区间内的所有元素：有两种方法：</p> 
</blockquote> 
<ul><li>str.erase(first, last), 其中first为需要删除的区间的起始迭代器，而last为需要删除的区间的末尾迭代器的下一个地址，即为删除[first, last)</li></ul>
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str = "abcdefg";
	//删除在[str.begin() + 2, str.end() - 1)内的元素，即cdef
	str.erase(str.begin() + 2, str.end() - 1);
	cout &lt;&lt; str &lt;&lt; endl;//输出abg
	return 0;
}</code></pre> 
<ul><li>str.erase(pos, length), 其中pos为需要开始删除的起始位置，length为删除的字符个数。</li></ul>
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str = "abcdefg";
	str.erase(3, 2);//删除de
	cout &lt;&lt; str &lt;&lt; endl;//输出abcfg
	return 0;
}</code></pre> 
<h3 id="(6).clear()">(6).clear()</h3> 
<blockquote> 
 <p>clear()可以清空string中的数据，时间复杂度一般为O(1)</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str = "abcd";
	str.clear();//清空字符串
	cout &lt;&lt; str.length() &lt;&lt; endl;//输出0
	return 0;
}</code></pre> 
<h3 id="(7).substr()">(7).substr()</h3> 
<blockquote> 
 <p>substr(pos, len) 返回从pos号位开始、长度为len的子串，时间复杂度为O(len)</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str = "Thank you for your smile.";
	cout &lt;&lt; str.substr(0, 5) &lt;&lt; endl;//输出Thank
	cout &lt;&lt; str.substr(14, 4) &lt;&lt; endl;//输出your
	cout &lt;&lt; str.substr(19, 5) &lt;&lt; endl;//输出smile
	return 0;
}</code></pre> 
<h3 id="(8).string%3A%3Anpos">(8).string::npos</h3> 
<blockquote> 
 <p>string::npos是一个常数，其本身的值为-1 ，但由于是unsigned int 类型，因此实际上也可以认为是unsigned int 类型的最大值，可认为是4,294,967,295。string::npos 用以作为 find 函数失配时的返回值。</p> 
</blockquote> 
<h3 id="(9).find()">(9).find()</h3> 
<blockquote> 
 <p>str.find(str) 当str2 是str 的子串时，返回其在str 中第一次出现的位置，如果str2 不是str 的子串，那么返回string::npos</p> 
 <p>str.find(str2, pos), 从str 的pos 号位开始匹配str2，返回值与上相同。时间复杂度为O(M*N)，M和N 分别是str2 和str的长度</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str = "Thank you for your smile";
	string str2 = "you";
	string str3 = "me";
	if (str.find(str2) != string::npos)
	{
		cout &lt;&lt; str.find(str2) &lt;&lt; endl;//输出6
	}
	if (str.find(str2, 7) != string::npos)
	{
		cout &lt;&lt; str.find(str2, 7) &lt;&lt; endl;//输出14
	}
	if (str.find(str3) != string::npos)
	{
		cout &lt;&lt; str.find(str3) &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "I know there is no position for me." &lt;&lt; endl;
	}
	return 0;
}</code></pre> 
<h3 id="(10).replace()">(10).replace()</h3> 
<blockquote> 
 <p>str.replace(pos,len,str2) 把str 从pos 号位开始、长度为len 的子串替换为上str2</p> 
 <p>str.replace(it1,it2,str2) 把str 的迭代器[it1, it2)范围的子串替换为str2</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
	string str = "Maybe you will turn around.";
	string str2 = "will not";
	string str3 = "surely";
	cout &lt;&lt; str.replace(10, 4, str2) &lt;&lt; endl;
	cout &lt;&lt; str.replace(str.begin(), str.begin() + 5, str3) &lt;&lt; endl;
	return 0;
}</code></pre> 
<h1 id="%E4%BA%8C%E3%80%81queue%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3">二、queue的常见用法详解</h1> 
<blockquote> 
 <p>queue翻译为队列，在STL中主要则是实现一个<span style="color:#956fe7">先进先出</span>的容器，<span style="color:#956fe7">当需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用queue代替，以提高程序的准确性。</span></p> 
</blockquote> 
<h2 id="1.queue%E7%9A%84%E5%AE%9A%E4%B9%89">1.queue的定义</h2> 
<p>要使用queue， 需要先添加头文件#include&lt;queue&gt;, 并在头文件下面加上"using namespace std;" ，然后就可以使用了。</p> 
<p>其定义的写法和其他STL容器相同，typename 可以是任意基本数据类型和容器：</p> 
<pre><code class="language-cpp">queue&lt;typename&gt; name;</code></pre> 
<h2 id="2.queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE">2.queue容器内元素的访问</h2> 
<p>由于队列（queue）本身就是一种先进先出的限制性数据结构，因此在STL中只能通过front() 来访问队首元素，或是通过back() 来访问队尾元素。</p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;queue&gt;

using namespace std;

int main()
{
	queue&lt;int&gt; q;
	for (int i = 1; i &lt;= 5; i++)
	{
		q.push(i);//push(i)用以将i压入队列，因此依次入队1 2 3 4 5 
	}
	printf("%d %dn", q.front(), q.back());//输出结果为1 5
	return 0;
}</code></pre> 
<h2 id="3.queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90">3.queue常用函数实例解析</h2> 
<blockquote> 
 <ul>
<li>push()</li>
<li>front()</li>
<li>back()</li>
<li>pop()</li>
<li>empty()</li>
<li>size()</li>
</ul>
</blockquote> 
<h3 id="(1).push()">(1).push()</h3> 
<blockquote> 
 <p>push(x) 将x 进行入队，时间复杂度为O(1)</p> 
</blockquote> 
<h3 id="(2).front()%2C%20back()">(2).front(), back()</h3> 
<blockquote> 
 <p>front(), back()可以分别获得队首元素和队尾元素，时间复杂度为O(1)</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7">注意哦，使用front() 和 pop() 函数之前，必须用empty() 判断队列是否为空，否则可能会因为队列空导致错误</span></p> 
</blockquote> 
<h3 id="(3).pop()">(3).pop()</h3> 
<blockquote> 
 <p>pop()令队首元素出队，时间复杂度为O(1)</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;queue&gt;

using namespace std;

int main()
{
	queue&lt;int&gt; q;
	for (int i = 1; i &lt;= 5; i++)
	{
		q.push(i);
	}
	for (int i = 0; i &lt; 3; i++)
	{
		q.pop();//出队列元素3次，依次出队1 2 3
	}
	printf("%dn", q.front());//输出4
	return 0;
}</code></pre> 
<h3 id="(4).empty()">(4).empty()</h3> 
<blockquote> 
 <p>empty()检测queue是否为空，返回true则为空，返回false则非空，时间复杂度为O(1)</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;queue&gt;

using namespace std;

int main()
{
	queue&lt;int&gt; q;
	if (q.empty() == true)//一开始队列里没有元素，所以是空
	{
		printf("Emptyn");
	}
	else
	{
		printf("Not Emptyn");
	}
	q.push(1);
	if (q.empty() == true)
	{
		printf("Emptyn");
	}
	else
	{
		printf("Not Emptyn");
	}
	return 0;
}</code></pre> 
<h3 id="(5).size()">(5).size()</h3> 
<blockquote> 
 <p>size()返回queue内元素的个数，时间复杂度为O(1)</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;queue&gt;

using namespace std;

int main()
{
	queue&lt;int&gt; q;
	for (int i = 1; i &lt;= 5; i++)
	{
		q.push(i);
	}
	printf("%dn", q.size());//输出5
	return 0;
}</code></pre> 
<blockquote> 
 <p>【延伸】：STL容器中还有两种容器跟队列有关，分别是双端队列(deque) 和优先队列(priority_queue) ，前者是首尾皆可插入和删除的队列，后者是使用堆实现的默许将当前队列最大元素置于队首的容器，这里暂时先不介绍，后期如果需要再进行补充。</p> 
</blockquote> 
<h1 id="%E4%B8%89%E3%80%81stack%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3">三、stack的常见用法详解</h1> 
<blockquote> 
 <p>stack 翻译为栈，是STL中实现的一个先进后出的容器，stack 用来模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错。</p> 
</blockquote> 
<h2 id="1.stack%E7%9A%84%E5%AE%9A%E4%B9%89">1.stack的定义</h2> 
<p>要使用stack，应先添加头文件#include&lt;stack&gt;, 并在头文件下面加上" using namespace std;"，然后就可以使用了。</p> 
<p>其定义的写法和其他STL容器相同，typename可以是任意基本数据类型或容器：</p> 
<pre><code class="language-cpp">stack&lt;typename&gt; name;</code></pre> 
<h2 id="2.stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE">2.stack容器内元素的访问</h2> 
<p>由于栈(stack) 本身就是一种先进后出的数据结构，<span style="color:#956fe7">在STL的stack 中只能通过top() 来访问栈顶元素</span></p> 
<p><span style="color:#0d0016">示例如下：</span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stack&gt;

using namespace std;

int main()
{
	stack&lt;int&gt; st;
	for (int i = 1; i &lt;= 5; i++)
	{
		st.push(i);//依次入栈1 2 3 4 5
	}
	printf("%dn", st.top());//输出5
	return 0;
}</code></pre> 
<h2 id="3.stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90">3.stack常用函数实例解析</h2> 
<blockquote> 
 <ul>
<li>push()</li>
<li>top()</li>
<li>pop()</li>
<li>empty()</li>
<li>size()</li>
</ul>
</blockquote> 
<h3>(1).push()</h3> 
<blockquote> 
 <p>push(x) 将x 入栈，时间复杂度为O(1)，</p> 
</blockquote> 
<h3 id="(2).top()">(2).top()</h3> 
<blockquote> 
 <p>top()获得栈顶元素，时间复杂度为O(1)</p> 
</blockquote> 
<h3>(3).pop()</h3> 
<blockquote> 
 <p>pop()用以弹出栈顶元素，时间复杂度为O(1)</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stack&gt;

using namespace std;

int main()
{
	stack&lt;int&gt; st;
	for (int i = 1; i &lt;= 5; i++)
	{
		st.push(i);
	}
	for (int i = 0; i &lt; 3; i++)
	{
		st.pop();
	}
	printf("%dn", st.top());//输出2
	return 0;
}</code></pre> 
<h3>(4).empty()</h3> 
<blockquote> 
 <p>empty()可以检测stack 内是否为空，返回true 为空，返回false 为非空，时间复杂度为O(1)</p> 
</blockquote> 
<h3>(5).size()</h3> 
<blockquote> 
 <p>size()返回stack 内元素的个数，时间复杂度为O(1)</p> 
</blockquote> 
<h1 id="%E5%9B%9B%E3%80%81algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">四、algorithm头文件下的常用函数</h1> 
<blockquote> 
 <p>使用algorithm 头文件，需要在头文件下面加上一行"using namespace std;"，才能正常使用</p> 
</blockquote> 
<blockquote> 
 <ul>
<li>max()、min()、abs()</li>
<li>swap()</li>
<li>reverse()</li>
<li>next_permutation()</li>
<li>fill()</li>
<li>sort()</li>
<li>lower_bound() 和 upper_bound()</li>
</ul>
</blockquote> 
<h2 id="1.max()%E3%80%81min()%E5%92%8Cabs()">1.max()、min()和abs()</h2> 
<blockquote> 
 <p>max(x,y)和min(x,y) 分别返回x, y中的最大值和最小值，且参数必须是两个，可以是浮点数，如果想返回三个数x,y,z的最大值，可以使用max(x, max(y, z)) 的写法；abs(x) 返回x的绝对值。注意：此时的x 必须是整数，浮点数的绝对值请用math 头文件下的fabs</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int x = -1;
	int y = -2;
	printf("%d %dn", max(x, y), min(x, y));//输出-1 -2
	printf("%d %dn", abs(x), abs(y));//输出1 2
	return 0;
}</code></pre> 
<h2 id="(2).swap()">2.swap()</h2> 
<blockquote> 
 <p>swap(x, y) 用来交换x 和 y 的值</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int x = 10;
	int y = 20;
	swap(x, y);
	printf("%d %dn", x, y);//输出20 10
	return 0;
}</code></pre> 
<h2 id="(3).reverse()">3.reverse()</h2> 
<blockquote> 
 <p>reverse(it, it2) 可以将数组指针在[it, it2) 之间的元素或容器的迭代器在[it, it2) 范围内的元素进行反转</p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int arr[10] = { 10,11,12,13,14,15 };
	reverse(arr, arr + 4);//将arr[0]~arr[3]反转
	for (int i = 0; i &lt; 6; i++)
	{
		printf("%d ", arr[i]);//输出13,12,11,10,14,15
	}

	return 0;
}</code></pre> 
<p>如果要是对容器中的元素（例如string 字符串）进行反转，结果也是一样</p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	string str = "abcdefghi";
	reverse(str.begin() + 2, str.begin() + 6);//对str[0]~str[5]反转
	for (int i = 0; i &lt; str.length(); i++)
	{
		printf("%c", str[i]);//输出abfedcghi
	}
	return 0;
}</code></pre> 
<h2 id="(4).next_permutation()">4.next_permutation()</h2> 
<blockquote> 
 <p>next_permutation() 给出一个序列在全排列中得下一个序列</p> 
</blockquote> 
<p>例如，当n == 3 时的全排列为：</p> 
<blockquote> 
 <p>123</p> 
 <p>132</p> 
 <p>213</p> 
 <p>231</p> 
 <p>312</p> 
 <p>321</p> 
</blockquote> 
<p>这样231的下一个序列就是312</p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int a[10] = { 1,2,3 };
	//a[0]~a[2]之间的序列需要求解next_permutation
	do
	{
		printf("%d%d%dn", a[0], a[1], a[2]);
	} while (next_permutation(a, a + 3));
	return 0;
}</code></pre> 
<blockquote> 
 <p>在上述的代码中，使用循环是因为next_permutation在已经到达全排列的最后一个时会返回false, 这样会方便退出循环。而使用do...while语句而不使用while语句是因为序列1 2 3本身也需要输出，如果使用while会直接跳到下一个序列再输出，这样的话结果会少一个123</p> 
</blockquote> 
<h2 id="(5).fill()">5.fill()</h2> 
<blockquote> 
 <p>fill()可以把数组或容器中的某一段区间赋为某个相同的值。<span style="color:#4da8ee">和memset 不同，这里的赋值可以是数组类型对应范围中的任意值</span></p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int a[5] = { 1,2,3,4,5 };
	fill(a, a + 5, 133);//将a[0]~a[4]均赋值为133
	for (int i = 0; i &lt; 5; i++)
	{
		printf("%d ", a[i]);//输出133 133 133 133 133
	}
	return 0;
}</code></pre> 
<h2 id="(6).sort()">6.sort()</h2> 
<blockquote> 
 <p><span style="color:#4da8ee">顾名思义，sort()就是用来排序的函数，它根据具体情形使用不同的排序方法，效率较高。一般来说，不推荐使用C语言中的qsort函数，原因是qsort 用起来比较繁琐，涉及很多指针的操作。</span></p> 
</blockquote> 
<ul><li>如何使用sort排序？</li></ul>
<p>sort函数的使用必须加上头文件"#include&lt;algorithm&gt;" 和 "using namespace std;"，其使用的方式如下：</p> 
<blockquote> 
 <p>sort(首元素地址（必填），尾元素地址的下一个地址（必填），比较函数（非必填）);</p> 
</blockquote> 
<p><span style="color:#4da8ee">可以看到，sort的参数有三个，其中前两个是必填的，而比较函数则可以根据需要填写，如果不写比较函数，则默认对前面给出的区间进行递增排序。</span></p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int a[6] = { 9,4,2,5,6,-1 };
	//将a[0]~a[3]进行从小到大排序
	sort(a, a + 4);
	for (int i = 0; i &lt; 6; i++)
	{
		printf("%d ", a[i]);//输出2 4 5 9 6 -1
	}
	putchar('n');
	//将a[0]~a[5]进行从小到大排序
	sort(a, a + 6);
	for (int i = 0; i &lt; 6; i++)
	{
		printf("%d ", a[i]);//输出-1 2 4 5 6 9
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p>【敲黑板】：特别需要注意理解的是尾元素地址的下一个地址！</p> 
</blockquote> 
<p>对double数组进行排序：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	double a[] = { 1.4,-2.1,9 };
	sort(a, a + 3);
	for (int i = 0; i &lt; 3; i++)
	{
		printf("%.1lf ", a[i]);
	}
	return 0;
}</code></pre> 
<p>对char型数组进行排序（默认是字典序）</p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	char c[] = { 'T', 'W','A', 'K' };
	sort(c, c + 4);
	for (int i = 0; i &lt; 4; i++)
	{
		printf("%c", c[i]);//输出AKTW
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p>我们需要知道的是，如果对序列进行排序，那么序列中的元素一定要有可比性，因此需要制定排序规则来建立这种可比性。特别是像结构体，本身并没有大小关系，需要认为制定比较的规则。sort 的第三个可选参数就是cmp函数，用来实现这个规则。</p> 
</blockquote> 
<ul><li>如何实现比较函数cmp</li></ul>
<p>下面介绍对基本数据类型、结构体类型、STL容器进行自定义规则排序时cmp的写法。</p> 
<h3 id="%3C1%3E.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F">&lt;1&gt;.基本数据类型数组的排序</h3> 
<p>若比较函数不填，则默认按照从小到大的顺序排序。</p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int a[] = { 3,1,4,2 };
	sort(a, a + 4);
	for (int i = 0; i &lt; 4; i++)
	{
		printf("%d ", a[i]);//输出1 2 3 4
	}
	return 0;
}</code></pre> 
<p>如果想要从大到小来排序，则要使用比较函数cmp 来“告诉”sort 何时要交换元素（让元素的大小比较关系反过来）</p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

bool cmp(int a, int b)
{
	return a &gt; b;//可以理解为当a&gt;b时把a放在b前面
}

int main()
{
	int a[] = { 3,1,4,2 };
	sort(a, a + 4, cmp);
	for (int i = 0; i &lt; 4; i++)
	{
		printf("%d ", a[i]);//输出4 3 2 1
	}

	return 0;
}</code></pre> 
<p>这样就可以让数值较大的元素放在前面，也就达到了从大到小排序的要求。</p> 
<p>同样的，对double型数组从大到小排序的代码如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

bool cmp(double a, double b)
{
	return a &gt; b;//同样是a&gt;b
}

int main()
{
	double a[] = { 1.4,-2.1,9 };
	sort(a, a + 3, cmp);
	for (int i = 0; i &lt; 3; i++)
	{
		printf("%.1lf ", a[i]);//输出9.0 1.4 -2.1
	}
	return 0;
}</code></pre> 
<p>对char型数组从大到小排序如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

bool cmp(char a, char b)
{
	return a &gt; b;//可以理解为当a&gt;b时把a放在b之前
}

int main()
{
	char c[] = { 'T','W','A','K' };
	sort(c, c + 4, cmp);
	for (int i = 0; i &lt; 4; i++)
	{
		printf("%c", c[i]);//输出WTKA
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p>【记忆方法】：</p> 
 <p>如果要把数据从小到大排列，那么就用'&lt;', 因为"a&lt;b" 就是左小右大；如果要把数据从大到小排列，那么就用'&gt;', 因为"a&gt;b" 就是左大右小。而当不确定或者忘记的时候，不妨两种都试一下，就会知道该用哪种了。</p> 
</blockquote> 
<h3 id="%3C2%3E.%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F">&lt;2&gt;.结构体数组的排序</h3> 
<p>现在定义了如下结构体：</p> 
<pre><code class="language-cpp">struct node{
    int x, y;
}ssd[10];</code></pre> 
<p>如果想将ssd数组按照 x 从大到小排序（即进行一级排序），那么可以这样写cmp函数：</p> 
<pre><code class="language-cpp">bool cmp(node a, node b){
    return a.x &gt; b.x;
}</code></pre> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

struct node
{
	int x;
	int y;
}ssd[10];

bool cmp(node a, node b)
{
	return a.x &gt; b.x;//按x值从大到小对结构体数组进行排序
}

int main()
{
	ssd[0].x = 2;
	ssd[0].y = 2;
	ssd[1].x = 1;
	ssd[1].y = 3;
	ssd[2].x = 3;
	ssd[2].y = 1;
	sort(ssd, ssd + 3, cmp);
	for (int i = 0; i &lt; 3; i++)
	{
		printf("%d %dn", ssd[i].x, ssd[i].y);
	}
	return 0;
}</code></pre> 
<p>而如果想先按x 从大到小排序，但当x相等的情况下，按照y的大小从小到大来排序（即进行二级排序），那么cmp的写法是：</p> 
<pre><code class="language-cpp">bool cmp(node a, node b)
{
    if(a.x != b.x)
    {
        return a.x &gt; b.x;
    }
    else
    {
        return a.y &lt; b.y;
    }
}</code></pre> 
<p>这里的cmp函数首先判断结构体内的x 元素是否相等，如果不相等则直接按照x 的大小来排序，否则，按照y 的大小来排序。</p> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

struct node
{
	int x;
	int y;
}ssd[10];

bool cmp(node a, node b)
{
	if (a.x != b.x)
	{
		return a.x &gt; b.x;//x 不等时按x 从大到小排序
	}
	else
	{
		return a.y &lt; b.y;//x 相等时按y 从小到大排序
	}
}
int main()
{
	ssd[0].x = 2;
	ssd[0].y = 2;
	ssd[1].x = 1;
	ssd[1].y = 3;
	ssd[2].x = 3;
	ssd[2].y = 1;
	sort(ssd, ssd + 3, cmp);//排序

	for (int i = 0; i &lt; 3; i++)
	{
		printf("%d %dn", ssd[i].x, ssd[i].y);
	}
	return 0;
}</code></pre> 
<h3 id="%3C3%3E.%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8E%92%E5%BA%8F">&lt;3&gt;.容器的排序</h3> 
<blockquote> 
 <p>在STL标准容器中，只有vector、string、deque是可以使用sort的。这是因为像set、map这种容器是用红黑树实现的（了解即可），元素本身有序，故不允许使用sort排序</p> 
</blockquote> 
<p>vector示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

using namespace std;

bool cmp(int a, int b)//因为vector中的元素为int型，因此仍然是int的比较
{
	return a &gt; b;
}


int main()
{
	vector&lt;int&gt; vi;
	vi.push_back(3);
	vi.push_back(1);
	vi.push_back(2);
	sort(vi.begin(), vi.end(), cmp);
	for (vector&lt;int&gt;::iterator it = vi.begin(); it != vi.end(); it++)
	{
		printf("%d ", *it);//输出3 2 1
	}
	return 0;
}</code></pre> 
<p>再来看string 的排序，示例如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	string str[3] = { "bbbb", "cc", "aaa" };
	sort(str, str + 3);//将string数组按字典树从小到大输出
	for (int i = 0; i &lt; 3; i++)
	{
		cout &lt;&lt; str[i] &lt;&lt; endl;
	}

	return 0;
}</code></pre> 
<p>如果上面这个例子中，需要按照字符串长度从小到大排序，那么可以这样写：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;

bool cmp(string str1, string str2)
{
	return str1.length() &lt; str2.length();//按照string 的长度从小到大排序
}

int main()
{
	string str[3] = { "bbbb", "cc", "aaa" };
	sort(str, str + 3, cmp);
	for (int i = 0; i &lt; 3; i++)
	{
		cout &lt;&lt; str[i] &lt;&lt; endl;
	}

	return 0;
}</code></pre> 
<h2 id="(7).lower_bound()%E5%92%8Cupper_bound()">7.lower_bound()和upper_bound()</h2> 
<blockquote> 
 <p>lower_bound() 和 upper_bound() 需要用在一个有序数组或容器中</p> 
 <p><span style="color:#4da8ee">lower_bound(first, last, val) 用来寻找在数组或容器的[first, last) 范围内</span><span style="color:#956fe7">第一个值大于等于val元素的位置</span><span style="color:#4da8ee">，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。</span></p> 
 <p><span style="color:#4da8ee">upper_bound(first, last, val) 用来寻找在数组或容器的[first, last) 范围内</span><span style="color:#956fe7">第一个值大于val 的元素的位置</span><span style="color:#4da8ee">，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。</span></p> 
 <p>显然，如果数组或容器中没有需要寻找的元素，则lower_bound() 和 upper_bound() 均返回可以插入该元素的位置的指针或迭代器（即假设存在该元素时，该元素应当在的位置）。</p> 
</blockquote> 
<p>示例如下： </p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int a[10] = { 1,2,2,3,3,3,5,5,5,5 };
	//寻找-1
	int* lowerPos = lower_bound(a, a + 10, -1);
	int* upperPos = upper_bound(a, a + 10, -1);
	printf("%d %dn", lowerPos - a, upperPos - a);//输出0 0

	//寻找1
	lowerPos = lower_bound(a, a + 10, 1);
	upperPos = upper_bound(a, a + 10, 1);
	printf("%d %dn", lowerPos - a, upperPos - a);//输出0 1

	//寻找3
	lowerPos = lower_bound(a, a + 10, 3);
	upperPos = upper_bound(a, a + 10, 3);
	printf("%d %dn", lowerPos - a, upperPos - a);//输出3 6

	//寻找4
	lowerPos = lower_bound(a, a + 10, 4);
	upperPos = upper_bound(a, a + 10, 4);
	printf("%d %dn", lowerPos - a, upperPos - a);//输出6 6

	//寻找6
	lowerPos = lower_bound(a, a + 10, 6);
	upperPos = upper_bound(a, a + 10, 6);
	printf("%d %dn", lowerPos - a, upperPos - a);//输出10 10
	return 0;
}</code></pre> 
<p>显然，如果只想获得欲查元素的下标，就可以不使用临时指针，而直接令返回值减去数组首地址即可。</p> 
<blockquote> 
 <p>【敲黑板】：<span style="color:#956fe7">这里补充一条知识点，指针 - 指针  = 两指针之间的元素个数</span></p> 
</blockquote> 
<p>示例如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int a[10] = { 1,2,2,3,3,3,5,5,5,5 };
	//寻找3
	printf("%d %dn", lower_bound(a, a + 10, 3) - a, upper_bound(a, a + 10, 3) - a);//输出3 6
	return 0;
}</code></pre> 
<h1 id="%E4%BA%94%E3%80%81%E8%93%9D%E6%A1%A5%E7%BB%93%E8%AF%AD%EF%BC%9A%E9%81%87%E8%A7%81%E8%93%9D%E6%A1%A5%E9%81%87%E8%A7%81%E4%BD%A0%EF%BC%8C%E4%B8%8D%E8%B4%9F%E4%BB%A3%E7%A0%81%E4%B8%8D%E8%B4%9F%E5%8D%BF%EF%BC%81">五、蓝桥结语：遇见蓝桥遇见你，不负代码不负卿！</h1> 
<blockquote> 
 <p><span style="color:#956fe7">希望能给大家带来帮助，码字不易，如果可以动动小手来个三连那就更好啦，hh，咱们下次再见。</span></p> 
</blockquote> 
<p style="text-align:center">·<img alt="" src="https://images2.imgbox.com/44/f9/bj3gl5De_o.jpg"></p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>