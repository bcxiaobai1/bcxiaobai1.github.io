<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>俄罗斯方块的实现—C语言 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">俄罗斯方块的实现—C语言</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E5%87%A0%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:0px"><a href="#%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E5%87%A0%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9A">简单解释几个函数：</a></p> 
<p id="1%E3%80%81%E5%88%B6%E4%BD%9C%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%EF%BC%9A-toc" style="margin-left:40px"><a href="#1%E3%80%81%E5%88%B6%E4%BD%9C%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%EF%BC%9A">1、制作俄罗斯方块：</a></p> 
<p id="2%E3%80%81%20%E5%88%A4%E6%96%AD%E6%96%B9%E5%9D%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%A7%BB%E5%8A%A8-toc" style="margin-left:40px"><a href="#2%E3%80%81%20%E5%88%A4%E6%96%AD%E6%96%B9%E5%9D%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%A7%BB%E5%8A%A8">2、 判断方块是否可以移动</a></p> 
<p id="3%E3%80%81%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%BB%A1%E8%A1%8C-toc" style="margin-left:40px"><a href="#3%E3%80%81%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%BB%A1%E8%A1%8C">3、 判断是否满行</a></p> 
<p id="%C2%A0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:0px"><a href="#%C2%A0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"> 完整代码如下：</a></p> 
<p id="%C2%A0%E8%BF%90%E8%A1%8C%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%9A-toc" style="margin-left:0px"><a href="#%C2%A0%E8%BF%90%E8%A1%8C%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%9A"> 运行界面展示：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>█ 开发工具：Dev  C++</p> 
<p></p> 
<h2 id="%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E5%87%A0%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9A">简单解释几个函数：</h2> 
<p> </p> 
<h3 id="1%E3%80%81%E5%88%B6%E4%BD%9C%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%EF%BC%9A">1、制作俄罗斯方块：</h3> 
<pre><code class="language-cpp">/*
  *制作俄罗斯方块
  */
  void MakeTetris(struct Tetris *tetris)
  {
  	a[tetris-&gt;x][tetris-&gt;y ]=b[0];
  	switch(tetris-&gt;flag)
  	{
  		case 1:
  		{
  			color(2);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
		case 2:
  		{
  			color(3);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x+4][tetris-&gt;y]=b[3];
  			break;
			  }
			  
		case 3:
  		{
  			color(3);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y-2]=b[2];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
		 case 4:
  		{
  			color(11);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
			  
		case 5:
  		{
  			color(11);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 6:
  		{
  			color(11);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 7:
  		{
  			color(11);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 8:
  		{
  			color(6);
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
			  
		case 9:
  		{
  			color(6);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
			  
		case 10:
  		{
  			color(6);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 11:
  		{
  			color(6);
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 12:
  		{
  			color(7);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y-1]=b[3];
  			break;
			  }
			  
			  
	    case 13:
  		{
  			color(7);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
		case 14:
  		{
  			color(7);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
			  
		case 15:
  		{
  			color(7);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
			  
		case 16:
  		{
  			color(7);
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y-1]=b[3];
  			break;
			  }
			  
			  
		case 17:
  		{
  			color(7);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
		case 18:
  		{
  			color(7);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
		case 19:
  		{
  			color(7);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
	  }
   } 
   </code></pre> 
<p><strong>✔在本游戏中，使用“■”来填充各种方块，在横向上，它占两个字符；在纵向上，它占一个字符。俄罗斯方块的7种基本图形旋转后共有19种旋转图形。而此段代码就是制作出这19种俄罗斯形状。</strong></p> 
<p> </p> 
<h3 id="2%E3%80%81%20%E5%88%A4%E6%96%AD%E6%96%B9%E5%9D%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%A7%BB%E5%8A%A8">2、 判断方块是否可以移动</h3> 
<pre><code class="language-cpp">/*
  *判断是否可移动
  */
  int ifMove(struct Tetris *tetris)   //判断该点是否可以移动
{
 	if(a[tetris-&gt;x][tetris-&gt;y]!=0)//当中心方块位置上有图案时，返回值为0，即不可移动
 	{
  		return 0;
 	}
 	else
 	{
  		if( 
   		( tetris-&gt;flag==1  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x+2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==2  &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp; 
    	a[tetris-&gt;x+2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x+4][tetris-&gt;y]==0 ) )   ||
   		( tetris-&gt;flag==3  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y-2]==0 &amp;&amp; a[tetris-&gt;x][tetris-&gt;y+1]==0 ) )   ||
   		( tetris-&gt;flag==4  &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x+2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x][tetris-&gt;y+1]==0 ) )   ||
   		( tetris-&gt;flag==5  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
   		 a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y]==0 ) )   ||
   		( tetris-&gt;flag==6  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) )   ||
   		( tetris-&gt;flag==7  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) )   ||
   		( tetris-&gt;flag==8  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y+1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y+1]==0 ) ) ||
   		( tetris-&gt;flag==9  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y+1]==0 ) ) ||
   		( tetris-&gt;flag==10 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==11 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y+1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==12 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y-1]==0 ) ) ||
   		( tetris-&gt;flag==15 &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==14 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y+1]==0 ) ) ||
   		( tetris-&gt;flag==13 &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x+2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==16 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y+1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y-1]==0 ) ) ||
   		( tetris-&gt;flag==19 &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==18 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y+1]==0 ) ) ||
   		( tetris-&gt;flag==17 &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x+2][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) )
   		{
    		return 1;
   		}
	}
 	return 0;
}</code></pre> 
<p><strong>✔要判断移动到的位置是不是空位置，首先判断此位置中心方块是否是方块或墙壁，如果是方块或者墙壁，则不可移动；如果不是，则继续判断，如果19种形状的俄罗斯方块的各自的“■” 位置上都是空，那么表示可以移动。</strong></p> 
<p> </p> 
<h3 id="3%E3%80%81%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%BB%A1%E8%A1%8C">3、 判断是否满行</h3> 
<pre><code class="language-cpp">/*
 *判断是否满行，并删除满行的俄罗斯方块
 */
 void Del_Fullline(struct Tetris *tetris)
{
		int k, del_rows = 0;  //分别用于记录某行方块的个数和删除方块的行数的变量
	for (j = FrameY + Frame_height - 1; j &gt;= FrameY + 1; j--)
	{
		k = 0;
		for (i = FrameX + 2; i&lt;FrameX + 2 * Frame_width - 2; i += 2)
		{
			if (a[i][j] == 1) //竖坐标依次从下往上，横坐标依次由左至右判断是否满行
			{
				k++;  //记录此行方块的个数
				if (k == Frame_width - 2)  //如果满行 
				{
					for (k = FrameX + 2; k&lt;FrameX + 2 * Frame_width - 2; k += 2)//删除满行的方块
					{
						a[k][j] = 0;
						gotoxy(k, j);
						printf("  ");
						//      					Sleep(1);
					}
					for (k = j - 1; k&gt;FrameY; k--) //如果删除行以上的位置有方块，则先清除，再将方块下移一个位置
					{
						for (i = FrameX + 2; i&lt;FrameX + 2 * Frame_width - 2; i += 2)
						{
							if (a[i][k] == 1)
							{
								a[i][k] = 0;
								gotoxy(i, k);
								printf("  ");
								a[i][k + 1] = 1;
								gotoxy(i, k + 1);
								printf("■");
							}
						}
					}
					j++;   //方块下移后，重新判断删除行是否满行
					del_rows++; //记录删除方块的行数
				}
			}
		}
	}
	tetris-&gt;score += 10* del_rows; //每删除一行，得10分
	tetris-&gt;speed -= 20*del_rows; //速度加快20ms
	if (del_rows&gt;0 &amp;&amp; (tetris-&gt;score % 20 == 0 || tetris-&gt;score / 20&gt;tetris-&gt;rank - 1))
	{        //如果得20分即累计删除2行.进一级 
		tetris-&gt;rank++;
	}
}</code></pre> 
<p> </p> 
<p> </p> 
<h2 id="%C2%A0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"> 完整代码如下：</h2> 
<pre><code class="language-cpp">/*******头 文 件*******/ 
#include &lt;stdio.h&gt;  //标准输入输出函数库 
#include &lt;windows.h&gt;  //控制 DOS界面（获取控制台上坐标位置、设置字体颜色） 
#include&lt;conio.h&gt;	//接受键盘输入输出 
#include&lt;time.h&gt;	//用于获得随机数
 


/******* 宏 定 义 *******/ 
#define FrameX 4	//游戏窗口左上角的X轴坐标为13 
#define FrameY 4	// 游戏窗口左上角的Y轴坐标为3 
#define Frame_height 20	//游戏窗口的高度为20 
#define Frame_width  18	// 游戏窗口的宽度为18

/******* 定 义 全 局 变 量********/ 
int i,j,Temp,Temp1,Temp2,speed;
int score=0;
int rank=0;
int a[80][80]={0};
int b[4];
int HighScore=0; 
struct Tetris{
	int x;
	int y;
	int flag;
	int next;
	int speed;
	int number;
	int score;
	int rank; 
};
HANDLE hOut;

/********函 数 声 明********/
int color(int c);
void gotoxy(int x,int y);
void gameTime(clock_t star_time);
void DrawGameframe();
void Flag(struct Tetris*);
void MaKeTetris(struct Tetris*);
void PrintTetris(struct Tetris*);
void CleanTetris(struct Tetris*);
int ifMove(struct Tetris*);
void Del_Fullline(struct Tetris*);
void updateGrade() ;
void Gameplay();
void regulation();
void explation();
void welcom();
void Replay(struct Tetris*tetris);
void title();
void rabbit();
void HideCursor();
void close();
void File_in();
void File_out();


int main() 
{	
	HideCursor();
	title();
	rabbit();
	welcom();
	File_out();
	return 0;

}
 
/**
 *文字颜色函数
 */ 
int color(int c)
{
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),c);
	return 0;
}


/**
 *获取屏幕光标位置 
 */ 
void gotoxy(int x,int y)
{
	COORD pos;
	pos.X=x;
	pos.Y=y;
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),pos);

}
//隐藏光标
void HideCursor()
{
 CONSOLE_CURSOR_INFO curInfo; //定义光标信息的结构体变量
 curInfo.dwSize = 1;  //如果没赋值的话，隐藏光标无效
 curInfo.bVisible = FALSE; //将光标设置为不可见
 HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); //获取控制台句柄
 SetConsoleCursorInfo(handle, &amp;curInfo); //设置光标信息
}


/**
 *欢迎界面上方的标题 
 */ 

void title(){
	color(9);//深蓝色 
	gotoxy(24,3);
	printf("趣 味 俄 罗 斯 方 块n");
	color(11);
	gotoxy(18,5);
	printf("■");
	gotoxy(18,6);
	printf("■■");
	gotoxy(18,7);
	printf("■");
	
	color(6);
	gotoxy(26,6);
	printf("■■");
	gotoxy(28,7);
	printf("■■");
	 
	color(2);
	gotoxy(36,6);
	printf("■■");
	gotoxy(36,7);
	printf("■■");
	
	color(3);
	gotoxy(45,5);
	printf("■");
	gotoxy(45,6);
	printf("■");
	gotoxy(45,7);
	printf("■");
	gotoxy(45,8);
	printf("■");
	
	color(7);
	gotoxy(56,6);
	printf("■");
	gotoxy(52,7);
	printf("■■■");
}
  
 /**
  *绘制兔子 
  */ 
 void rabbit(){
 	gotoxy(64,7);
 	color(3);
 	printf(" │￣│ │￣│");
 	
 	gotoxy(64,8);
 	printf(" │  │ │  │");
 	
 	gotoxy(64,9);
 	printf(" │  │ │  │");
 	
    gotoxy(64,10);
 	printf("_│");
 	
 	gotoxy(73,10);
 	printf("│_");
 	
 	gotoxy(62,11);
 	printf("│");
 	
 	gotoxy(76,11);
 	printf("│");
 	
 	gotoxy(62,12);
 	printf("│             │");
 	
 	gotoxy(62,13);
 	printf("│             │");
 	
 	gotoxy(62,14);
 	printf("│             │");
 	
 	gotoxy(62,15);
 	printf("┗━━┯━━━┛━━━┱━━┛");
 	
 	gotoxy(64,16);
 	printf("┏┫       ┣┓");
 	
 	gotoxy(62,17);
 	printf("━━┸━━━━┷━━━━┷━━");
 	
 	gotoxy(67,11);	
    color(5);
    printf("`~'~`'");
 	color(12); 
 	gotoxy(67,12);
 	printf("○   ○");
 	
 	
 	gotoxy(65,13);
 	color(13);
 	printf("//");
 	
 	gotoxy(74,13);
 	printf("//");
 	
 	gotoxy(69,14);
 	color(2);
 	printf("┻");
 	
	
	gotoxy(65,19);
	color(4) ;
	printf("   光宗耀组"); 
	
	
 } 
 /*
  *菜单选项边框 
  */
void welcom()
{
	int n;
	int i,j=1;
	color(14);
	for (i=9;i&lt;=20;i++)
	{
		for (j=15;j&lt;=60;j++)
		{
			gotoxy(j,i);
			if (i==9||i==20) printf("=");
			else if (j==15||j==59) printf("||");
		}
	}
	//---desige menu option text 
	color(12);
	gotoxy(25,12);
	printf("1.开始游戏");
	 
	gotoxy(40,12);
	printf("2.按键说明");
	
	gotoxy(25,17);
	printf("3.游戏规则");
	
	gotoxy(40,17);
	printf("4.退出");
	
	gotoxy(21,22);
	color(3); 
	printf("请选择[1 2 3 4]:[ ]bb");
	color(14);
	scanf("%d",&amp;n);
	switch(n)
	{
		case 1:
		       system("cls");
		       DrawGameframe();
		       Gameplay();
		    
		       break;
		case 2:
			   explation();
		       break;
		case 3:
		       regulation(); 
			   break;
		case 4:
		       close();
			   break;
	}
 } 
 /*
  *制作游戏窗口
  */
 void DrawGameframe()
{
	gotoxy(FrameX+Frame_width-7,FrameY-2);
	color(15);
	printf("趣味俄罗斯方块");
	gotoxy(FrameX+2*Frame_width+3,FrameY+7);
	color(7);
	printf("︻︻︻︻︻");
	gotoxy(FrameX+2*Frame_width+13,FrameY+7);
	color(15);
	printf("下一个出现方块:");
	gotoxy(FrameX+2*Frame_width+3,FrameY+13); 
	color(7);
	printf("︼︼︼︼︼");
	gotoxy(FrameX+2*Frame_width+3,FrameY+17); 
	color(8);
	printf("↑键：旋转");
	gotoxy(FrameX+2*Frame_width+3,FrameY+19);
	printf("空格：暂停游戏"); 
	gotoxy(FrameX+2*Frame_width+3,FrameY+15);
	printf("Esc：退出游戏"); 
	gotoxy(FrameX,FrameY);
	color(15);
	printf("〇");
	gotoxy(FrameX+2*Frame_width-2,FrameY);
	printf("〇");
	gotoxy(FrameX,FrameY+Frame_height);
	printf("〇");
	gotoxy(FrameX+2*Frame_width-2,FrameY+Frame_height);
	printf("〇");
	a[FrameX][FrameY+Frame_height]=2;                  //边框左下角的 a[13][23]=2,  防止方块出边框 
    a[FrameX+2*Frame_width-2][FrameY+Frame_height]=2;  //边框右下角的 a[47][23]=2,  防止方块出边框 
	for(i=2;i&lt;2*Frame_width-2;i+=2)
	{
		gotoxy(FrameX+i,FrameY);
		printf("▃");
	}
	for(i=2;i&lt;2*Frame_width-2;i+=2)
	{
		gotoxy(FrameX+i,FrameY+Frame_height);
		printf("▃");
		a[FrameX+i][FrameY+Frame_height]=2;
	}
	for(i=1;i&lt;Frame_height;i++)
	{
		gotoxy(FrameX,FrameY+i);
		printf("▍");
		a[FrameX][FrameY+i]=2;
	}
	for(i=1;i&lt;Frame_height;i++)
	{
		gotoxy(FrameX+2*Frame_width-1,FrameY+i);
		printf("▍");
		a[FrameX+2*Frame_width-2][FrameY+i]=2;
	}
}
   
 /*
  *制作俄罗斯方块
  */
  void MakeTetris(struct Tetris *tetris)
  {
  	a[tetris-&gt;x][tetris-&gt;y ]=b[0];
  	switch(tetris-&gt;flag)
  	{
  		case 1:
  		{
  			color(2);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
		case 2:
  		{
  			color(3);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x+4][tetris-&gt;y]=b[3];
  			break;
			  }
			  
		case 3:
  		{
  			color(3);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y-2]=b[2];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
		 case 4:
  		{
  			color(11);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
			  
		case 5:
  		{
  			color(11);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 6:
  		{
  			color(11);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 7:
  		{
  			color(11);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 8:
  		{
  			color(6);
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
			  
		case 9:
  		{
  			color(6);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
			  
		case 10:
  		{
  			color(6);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 11:
  		{
  			color(6);
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
		case 12:
  		{
  			color(7);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y-1]=b[3];
  			break;
			  }
			  
			  
	    case 13:
  		{
  			color(7);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
		case 14:
  		{
  			color(7);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
			  
		case 15:
  		{
  			color(7);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
			  
			  
		case 16:
  		{
  			color(7);
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y-1]=b[3];
  			break;
			  }
			  
			  
		case 17:
  		{
  			color(7);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x+2][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
			  
		case 18:
  		{
  			color(7);
  			a[tetris-&gt;x][tetris-&gt;y-1]=b[1];
  			a[tetris-&gt;x][tetris-&gt;y+1]=b[2];
  			a[tetris-&gt;x-2][tetris-&gt;y+1]=b[3];
  			break;
			  }
			  
		case 19:
  		{
  			color(7);
  			a[tetris-&gt;x-2][tetris-&gt;y]=b[1];
  			a[tetris-&gt;x-2][tetris-&gt;y-1]=b[2];
  			a[tetris-&gt;x+2][tetris-&gt;y]=b[3];
  			break;
			  }
	  }
   } 
   
   
   /*
    *打印俄罗斯方块
	*/
void PrintTetris(struct Tetris *tetris) 
{
	for(i=0;i&lt;4;i++)
	{
		b[i]=1;
	}
		
	MakeTetris(tetris);
	                 
	for( i=tetris-&gt;x-2; i&lt;=tetris-&gt;x+4;i+=2)
	{
		for(j=tetris-&gt;y-2;j&lt;=tetris-&gt;y+1;j++)
		{
			if( a[i][j]==1 &amp;&amp; j&gt;FrameY)
			{
				gotoxy(i,j);
				printf("■") ;	
			}
		}	
	}
	----print menu message
	
	gotoxy(FrameX+2*Frame_width+3,FrameY-1);
	File_out();
	color(8);
	printf("最高记录：%d",HighScore); 
	gotoxy(FrameX+2*Frame_width+3,FrameY+1);
	color(8);
	printf("rank:  ");
	color(8);
	printf("%d",tetris-&gt;rank);
	
	gotoxy(FrameX+2*Frame_width+3,FrameY+3);
	color(8);
	printf("score:  ");
	color(8);
	printf("%d",tetris-&gt;score);
	
	gotoxy(FrameX+2*Frame_width+3,FrameY+5);
	color(8);
	printf("speed:  ");
	color(8);
	printf("%dms",tetris-&gt;speed);	 
}
 /*
  *判断是否可移动
  */
  int ifMove(struct Tetris *tetris)   //判断该点是否可以移动
{
 	if(a[tetris-&gt;x][tetris-&gt;y]!=0)//当中心方块位置上有图案时，返回值为0，即不可移动
 	{
  		return 0;
 	}
 	else
 	{
  		if( 
   		( tetris-&gt;flag==1  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x+2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==2  &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp; 
    	a[tetris-&gt;x+2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x+4][tetris-&gt;y]==0 ) )   ||
   		( tetris-&gt;flag==3  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y-2]==0 &amp;&amp; a[tetris-&gt;x][tetris-&gt;y+1]==0 ) )   ||
   		( tetris-&gt;flag==4  &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x+2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x][tetris-&gt;y+1]==0 ) )   ||
   		( tetris-&gt;flag==5  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
   		 a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y]==0 ) )   ||
   		( tetris-&gt;flag==6  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) )   ||
   		( tetris-&gt;flag==7  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) )   ||
   		( tetris-&gt;flag==8  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y+1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y+1]==0 ) ) ||
   		( tetris-&gt;flag==9  &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y+1]==0 ) ) ||
   		( tetris-&gt;flag==10 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==11 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y+1]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==12 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y-1]==0 ) ) ||
   		( tetris-&gt;flag==15 &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==14 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y+1]==0 ) ) ||
   		( tetris-&gt;flag==13 &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x+2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==16 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y+1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y-1]==0 ) ) ||
   		( tetris-&gt;flag==19 &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x-2][tetris-&gt;y-1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) ||
   		( tetris-&gt;flag==18 &amp;&amp; ( a[tetris-&gt;x][tetris-&gt;y-1]==0   &amp;&amp;
    	a[tetris-&gt;x][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x-2][tetris-&gt;y+1]==0 ) ) ||
   		( tetris-&gt;flag==17 &amp;&amp; ( a[tetris-&gt;x-2][tetris-&gt;y]==0   &amp;&amp;
    	a[tetris-&gt;x+2][tetris-&gt;y+1]==0 &amp;&amp; a[tetris-&gt;x+2][tetris-&gt;y]==0 ) ) )
   		{
    		return 1;
   		}
	}
 	return 0;
}

/*
 *在文件中读取最高分
 */
 void File_out()
 {
 	FILE *fp;
 	fp =fopen("save.txt","r+");
	fscanf(fp,"%d",&amp;HighScore);
	fclose(fp);
 }
 
 /*
  *将最高分存储与文件中
  */
  void File_in()
  {
  	FILE *fp ;
	fp =fopen("save.txt","w+");
	fprintf(fp,"%d",HighScore);
	fclose(fp); 
   } 
 
 
 
  
/*
 *清除俄罗斯方块的痕迹 
 */ 
void CleanTetris(struct Tetris *tetris)
{
	for(i=0;i&lt;4;i++)
	{
		b[i]=0;
	}
	MakeTetris(tetris);
	for(i=tetris-&gt;x-2;i&lt;=tetris-&gt;x+4;i+=2)
	{
		for(j=tetris-&gt;y-2;j&lt;=tetris-&gt;y+1;j++)
		{
			if(a[i][j]==0 &amp;&amp; j&gt;FrameY)
			{
				gotoxy(i,j);
				printf("  ");
			}
		}
	}
}


/*
 *判断是否满行，并删除满行的俄罗斯方块
 */
 void Del_Fullline(struct Tetris *tetris)
{
		int k, del_rows = 0;  //分别用于记录某行方块的个数和删除方块的行数的变量
	for (j = FrameY + Frame_height - 1; j &gt;= FrameY + 1; j--)
	{
		k = 0;
		for (i = FrameX + 2; i&lt;FrameX + 2 * Frame_width - 2; i += 2)
		{
			if (a[i][j] == 1) //竖坐标依次从下往上，横坐标依次由左至右判断是否满行
			{
				k++;  //记录此行方块的个数
				if (k == Frame_width - 2)  //如果满行 
				{
					for (k = FrameX + 2; k&lt;FrameX + 2 * Frame_width - 2; k += 2)//删除满行的方块
					{
						a[k][j] = 0;
						gotoxy(k, j);
						printf("  ");
						//      					Sleep(1);
					}
					for (k = j - 1; k&gt;FrameY; k--) //如果删除行以上的位置有方块，则先清除，再将方块下移一个位置
					{
						for (i = FrameX + 2; i&lt;FrameX + 2 * Frame_width - 2; i += 2)
						{
							if (a[i][k] == 1)
							{
								a[i][k] = 0;
								gotoxy(i, k);
								printf("  ");
								a[i][k + 1] = 1;
								gotoxy(i, k + 1);
								printf("■");
							}
						}
					}
					j++;   //方块下移后，重新判断删除行是否满行
					del_rows++; //记录删除方块的行数
				}
			}
		}
	}
	tetris-&gt;score += 10* del_rows; //每删除一行，得10分
	tetris-&gt;speed -= 20*del_rows; //速度加快20ms
	if (del_rows&gt;0 &amp;&amp; (tetris-&gt;score % 20 == 0 || tetris-&gt;score / 20&gt;tetris-&gt;rank - 1))
	{        //如果得20分即累计删除2行.进一级 
		tetris-&gt;rank++;
	}
}


/*
 *随机产生俄罗斯方块类型的序号
 */
 void Flag(struct Tetris*tetris)
 {
 	tetris-&gt;number++;
 	srand(time(NULL));
 	if(tetris-&gt;number==1)
	 {
 		tetris-&gt;flag=rand()%19+1;
	 }
	 tetris-&gt;next=rand()%19+1;
  } 
  
  /*
   *开始游戏
   */
 void Gameplay()
{
	int n;
	struct Tetris t,*tetris=&amp;t;
	char ch;
	tetris-&gt;number=0;
	tetris-&gt;speed=300;
	tetris-&gt;score=0;
	tetris-&gt;rank=1;
	
	while(1)
	{
		Flag(tetris);                          //随机产生方块当前序号 和下一个序号 
		Temp=tetris-&gt;flag;                     //当前方块序号暂时保存 
		tetris-&gt;x=FrameX+2*Frame_width+6;      //右边预览界面方块坐标x=55 
		tetris-&gt;y=FrameY+10;                   //右边预览界面方块坐标y=13 
		tetris-&gt;flag = tetris-&gt;next;           //下一个方块序号暂给flag ,准备在预览窗口打印 
	
		PrintTetris(tetris);                    //在预览窗口打印下一个方块 
		
		tetris-&gt;x=FrameX+Frame_width;           //游戏窗口出现方块的中心方块坐标x=31 
		//tetris-&gt;x=FrameX+10;                         //改变游戏窗口出现方块的中心方块坐标x=13 
		tetris-&gt;y=FrameY-1;                      //游戏窗口出现方块的中心方块坐标y=2 
		tetris-&gt;flag=Temp;                       //找回当前方块序号 
	
		//--keys options按键操作 
		while(1)
		{
			label: PrintTetris(tetris);
			Sleep(tetris-&gt;speed);
			CleanTetris(tetris);
			Temp1=tetris-&gt;x;
			Temp2=tetris-&gt;flag;
			if(kbhit())         //   有键盘输入？ 
			{
				ch=getch();    //  有，接受 输入 
				if(ch==75)     //   75 对应方向键 ←
				{
					tetris-&gt;x-=2;
				}
				if(ch==77)     //    77 对应方向键 → 
				{
					tetris-&gt;x+=2;
				}
				if(ch==80)     //     80 对应方向键 ↓----加速下落 
				{
					if(ifMove(tetris)!=0)  //判断可以移动吗？ 
					{
				 		tetris-&gt;y+=2;	  //    可以，一次下落两行 
				 
					}
					if(ifMove(tetris)==0)  //如果不能移动 
						{
				 			tetris-&gt;y=FrameY+Frame_height-2;  //确定Y	
						}
				}
				if(ch==72)
				{
					if(tetris-&gt;flag&gt;=2 &amp;&amp; tetris-&gt;flag&lt;=3)//  2/3 是直线方块 ,
						{
							tetris-&gt;flag++;    //if 2，then get 3   if 3, then get 4
							tetris-&gt;flag%=2;   //3%2=1              4%2=0
							tetris-&gt;flag+=2;   //1+2=3	            0+2=2
						}
					if(tetris-&gt;flag&gt;=4 &amp;&amp; tetris-&gt;flag&lt;=7)  //      4/5/6/7  是T字方块 
						{
							tetris-&gt;flag++;    //if4 ，then get 5    if7，  then get 8 
							tetris-&gt;flag%=4;   //5%4=1                8%4=0
							tetris-&gt;flag+=4;   //1+4=5	              0+4=4
						}
					if(tetris-&gt;flag&gt;=8 &amp;&amp; tetris-&gt;flag&lt;=11)
						{
							tetris-&gt;flag++;
							tetris-&gt;flag%=4;
							tetris-&gt;flag+=8;		
						}
					if(tetris-&gt;flag&gt;=12 &amp;&amp; tetris-&gt;flag&lt;=15)
						{
							tetris-&gt;flag++;
							tetris-&gt;flag%=4;
							tetris-&gt;flag+=12;		
						}
					if(tetris-&gt;flag&gt;=16 &amp;&amp; tetris-&gt;flag&lt;=19)
						{
							tetris-&gt;flag++;
							tetris-&gt;flag%=4;
							tetris-&gt;flag+=16;		
						}
					
				}
				if(ch == 32)   //空格键  暂停 
				{
					PrintTetris(tetris);
					while(1)   //循环等待，再次按下空格键 
					{
						if(kbhit())
						{
							ch=getch();
							if(ch == 32)
							{
								goto label;   // 
							}
						}
					}
				}
				if(ch == 27)    //   ESC键 ----返回 欢迎界面 
				{
					system("cls");
					memset(a,0,6400*sizeof(int));
					welcom();
				}
				if(ifMove(tetris)==0)  //如果不可以动 ----上面的操作无效 
				{
					tetris-&gt;x=Temp1;
					tetris-&gt;flag=Temp2;
				}
				else         //如果可移动，返回label 
				{
					goto label;
				}
			}
			tetris-&gt;y++;    //没有操作，方块向下移动，每次一行 
			
			if(ifMove(tetris)==0)   //向下移动，又判断不能移动，方块放在此处 
			{
				tetris-&gt;y--;
				PrintTetris(tetris);
				Del_Fullline(tetris);
				break;
			}
		}
		
	//--game over: blocks get the top of frame
		for (i=tetris-&gt;y-2;i&lt;tetris-&gt;y+2;i++) //方块接触到框顶位置 
		{
			if(i==FrameY)
			{
				system("cls");
				gotoxy(29,7);
				printf("  n");
				color(15);
				printf("ttt■■■■     ■    ■     ■■          n");
				printf("ttt■           ■■  ■     ■   ■       n");
				printf("ttt■■■       ■ ■ ■     ■     ■     n");
				printf("ttt■■■       ■ ■ ■     ■     ■     n");
				printf("ttt■           ■  ■■     ■   ■       n");
				printf("ttt■■■■     ■    ■     ■■          n");
			
				
				
				
				
				
				
				gotoxy(29,18);
				color(6);
				printf("再玩一局--------1");
				gotoxy(29,19);
				printf("不玩了--------2");
				gotoxy(29,20);
				printf("choose[1/2]");
				color(15);
				scanf("%d",&amp;n);
				switch(n)
				{
					case 1:
						system("cls");
						Replay(tetris);
						break;
					case 2:
						system("cls");
						gotoxy(29,7);
						printf("您的得分是: %d",tetris-&gt;score);
						if(tetris-&gt;score &gt;= HighScore)
						{
							color(6);
							gotoxy(29,8);
							printf("创记录啦！最高记录被你刷新啦~");
							HighScore=tetris-&gt;score;
							File_in(); 	
						}else{
							color(6);
							gotoxy(29,8);
							printf("继续努力吧~ 你离最高分还差：%d",HighScore-tetris-&gt;score);
						}
						exit(0);
						break;
				}
			 
			}
		}
		tetris-&gt;flag = tetris-&gt;next;  //清除右边窗口方块的图形 
		tetris-&gt;x=FrameX+2*Frame_width+6;
		tetris-&gt;y=FrameY+10;
		CleanTetris(tetris);
	}
	
}
/*
 *重新开始游戏
 */
 void Replay(struct Tetris *tetris)
 {
 	system("cls");
 	memset(a,0,6400*sizeof(int));
 	DrawGameframe();
 	Gameplay();
  } 
  
  
/*
 *按键说明
 */
   void explation(){
   	int i,j=1;
   	system("cls");
   	color(15);
   	gotoxy(32,3);
   	printf("按键说明");
	color(8);
	for(i=6;i&lt;=16;i++)
	{
		for(j=15;j&lt;=60;j++)
		{
			gotoxy(j,i);
			if(i==6||i==16) printf("=");
			else if(j==15||j==59) printf("||");
		}
	}
	color(6);
	gotoxy(18,7);
	printf("tip1:玩家可以通过←→方向键来移动方块");
	color(2);
	gotoxy(18,9);
	printf("tip2:通过↑使方块旋转");
	color(3);
	gotoxy(18,11);
	printf("tip3:通过↓加速方块下落");
	color(7);
	gotoxy(18,13);
	printf("tip4:按空格键暂停游戏，再按空格键继续游戏");
	color(11);
	gotoxy(18,15);
	printf("tip5:按 Esc退出游戏");
	getch();
	system("cls");
	main(); 
   } 
   
/*
 *游戏规则
 */
void regulation()
 {
 	int i,j=1;
 	system("cls");
 	color(15);
 	gotoxy(56,3);
 	printf("游戏规则");
	color(8);
	for(i=6;i&lt;=18;i++)
	{
		for(j=30;j &lt;=88;j++ )
		{		
		 	gotoxy(j,i);
		 	if(i==6||i==18) printf("=");
		 	else if(j==30||j==87)  printf("||");
		}
	}
	color(7);
	gotoxy(34,7);
	printf("tip1：不同形状的小方块从屏幕上方落下，玩家通过调整");
	gotoxy(42,9);
	printf("方块的位置和方向，使它们在屏幕底部拼出完整的"); 
	gotoxy(42,11);
	printf("一行或几行");
	color(6);
	gotoxy(34,13);
	printf("tip2:每消除一行，积分增加100");
	color(2);
	gotoxy(34,15);
	printf("tip3:每累计1000分，会提升一个等级");
	color(3);
	gotoxy(34,17);
	printf("tip4:提升等级会使方块下落速度加快，游戏难度加大");
	getch();
	system("cls");
	welcom(); 
	
  } 
  
  /*
   *退出游戏
   */
   void close()
   {
   	exit (0);
	} 
 

</code></pre> 
<p> </p> 
<p> </p> 
<h2 id="%C2%A0%E8%BF%90%E8%A1%8C%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%9A"> 运行界面展示：</h2> 
<p><img alt="" height="860" src="https://images2.imgbox.com/c9/df/mJpF3Djb_o.png" width="1200"></p> 
<p> <img alt="" height="963" src="https://images2.imgbox.com/e3/dd/2Yw9nhcz_o.png" width="1200"></p> 
<p> </p> 
<p></p> 
<p> </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>