<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>「MySQL」- 复杂的SQL查询语句 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">「MySQL」- 复杂的SQL查询语句</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p></p> 
<p id="main-toc" style="text-align:center"><strong>任意门</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px"><a href="#%E5%89%8D%E8%A8%80" title="前言">前言</a></p> 
<p id="%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2-toc" style="margin-left:0px"><a href="#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2" title="聚合查询">聚合查询</a></p> 
<p id="1.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#1.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0" title="1.聚合函数">1.聚合函数</a></p> 
<p id="count%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#count%E5%87%BD%E6%95%B0" title="count函数">count函数</a></p> 
<p id="sum%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#sum%E5%87%BD%E6%95%B0" title="sum函数">sum函数</a></p> 
<p id="avg%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#avg%E5%87%BD%E6%95%B0" title="avg函数">avg函数</a></p> 
<p id="max%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#max%E5%87%BD%E6%95%B0" title="max函数">max函数</a></p> 
<p id="min%E5%87%BD%E6%95%B0-toc" style="margin-left:80px"><a href="#min%E5%87%BD%E6%95%B0" title="min函数">min函数</a></p> 
<p id="2.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px"><a href="#2.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2" title="2.分组查询">2.分组查询</a></p> 
<p id="having%E5%AD%90%E5%8F%A5-toc" style="margin-left:80px"><a href="#having%E5%AD%90%E5%8F%A5" title="having子句">having子句</a></p> 
<p id="%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2-toc" style="margin-left:0px"><a href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2" title="多表查询">多表查询</a></p> 
<p id="1.%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF-toc" style="margin-left:40px"><a href="#1.%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF" title="1.笛卡尔积">1.笛卡尔积</a></p> 
<p id="2.%E5%86%85%E8%BF%9E%E6%8E%A5-toc" style="margin-left:40px"><a href="#2.%E5%86%85%E8%BF%9E%E6%8E%A5" title="2.内连接">2.内连接</a></p> 
<p id="3.%E5%A4%96%E8%BF%9E%E6%8E%A5-toc" style="margin-left:40px"><a href="#3.%E5%A4%96%E8%BF%9E%E6%8E%A5" title="3.外连接">3.外连接</a></p> 
<p id="%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5-toc" style="margin-left:80px"><a href="#%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5" title="左外连接">左外连接</a></p> 
<p id="%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5-toc" style="margin-left:80px"><a href="#%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5" title="右外连接">右外连接</a></p> 
<p id="%E8%87%AA%E9%93%BE%E6%8E%A5-toc" style="margin-left:0px"><a href="#%E8%87%AA%E9%93%BE%E6%8E%A5" title="自链接">自链接</a></p> 
<p id="%E5%AD%90%E6%9F%A5%E8%AF%A2-toc" style="margin-left:0px"><a href="#%E5%AD%90%E6%9F%A5%E8%AF%A2" title="子查询">子查询</a></p> 
<p id="%E5%90%88%E5%B9%B6%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px"><a href="#%E5%90%88%E5%B9%B6%E6%9F%A5%E8%AF%A2" title="合并查询">合并查询</a></p> 
<p id="%E2%80%8B%C2%A0%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-toc" style="margin-left:0px"><a href="#%E2%80%8B%C2%A0%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" title="​ 关键字执行顺序">​ 关键字执行顺序</a></p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h1 id="%E5%89%8D%E8%A8%80" style="text-align:center"><strong><span style="color:#333333">前言</span></strong></h1> 
<p style="margin-left:.8em"><span style="color:#333333"><strong>MySQL</strong> 除了基础的 <strong>CRUD</strong> 操作之外 , 还涉及了更多更复杂的查询操作 , 不仅支持一张表进行查询 , 也支持多张表进行查询 ,本章是针对 <strong>MySQL</strong> 中的 <strong>select</strong> 查询操作更复杂的一些用法 , 在本章你将会学习进阶的 <strong>select</strong> 操作 , 随着作者一起往下看看吧<strong>(本章书写风格会在单行与多行之间切换)</strong> ! ! !</span></p> 
<h1 id="%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2" style="text-align:center"><strong><span style="color:#333333">聚合查询</span></strong></h1> 
<p style="margin-left:.8em"><span style="color:#333333"><span style="color:#008000"><strong><span style="color:inherit">聚合查询是指对一个数据表中某个字段的数据进行部分或者全部统计查询的一种方式，比如所有全部书的平均价格或者是书籍的总数量等等 ，在这些时候就会使用到聚合查询这种方法。</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">在开始学习聚合查询之前 , 我们需要先在选中数据库中准备一张测试表 , 创建一张成绩表并添加测试记录</span></p> 
<pre><code class="language-sql">-- 创建成绩表
drop table if exists exam_result;
create table exam_result (
id int,
name varchar(20),
chinese decimal(3,1),
math decimal(3,1),
english decimal(3,1)
);
-- 插入测试数据
insert into exam_result (id,name, chinese, math, english) values
(1,'唐三藏', 67, 98, 56),
(2,'孙悟空', 87.5, 78, 77),
(3,'猪悟能', 88, 98.5, 90),
(4,'曹孟德', 82, 84, 67),
(5,'刘玄德', 55.5, 85, 45),
(6,'孙权', 70, 73, 78.5),
(7,'宋公明', 75, 65, 30),
(null,null,null,null,null);</code></pre> 
<p><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">接下来我们就可以开始学习聚合查询了 ! ! !</span></span></span></p> 
<h2 id="1.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0" style="text-align:center"><strong><span style="color:#333333">1.聚合函数 </span></strong></h2> 
<p style="margin-left:.8em"><span style="color:#333333">对于一张表中 , 万一有需求需要我们去计算整张表有多少条记录 , 或者指定一张表计算平均值/求和等操作 , 我们总不可能拿着个计算器在那边看表便计算吧 , 虽然可以但是个笨方法, 所以这时候就可以使用聚合函数来实现统计总数、计算平局值等操作 , 常见的聚合函数如下</span></p> 
<table border="1" cellspacing="0" style="width:576.023px">
<thead><tr>
<th style="text-align:center;width:226px"><strong>函数</strong></th>
<th style="text-align:center;width:348px"><strong>说明</strong></th>
</tr></thead>
<tbody>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:226px"><strong>count</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:348px"><strong>返回查询到的数据的数量</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:226px"><strong>sum</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:348px"><strong>返回查询到的数据的总和，不是数字没有意义</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:226px"><strong>avg</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:348px"><strong>返回查询到的数据的平均值，不是数字没有意义</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:226px"><strong>max</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:348px"><strong>返回查询到的数据的最大值，不是数字没有意义</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:226px"><strong>min</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:348px"><strong>返回查询到的数据的最小值，不是数字没有意义</strong></td>
</tr>
</tbody>
</table>
<ul style="margin-left:.8em"><li> <p><span style="color:#ff0000"><strong><span style="color:inherit">每个聚合函数参数都可以为表达式或者列名</span></strong></span></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">接下来 , 我们来看一下每一个聚合函数的用法</span></p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h3 id="count%E5%87%BD%E6%95%B0" style="text-align:center"><strong><span style="color:#333333"><span style="color:#ffa500"><strong><span style="color:inherit">count函数</span></strong></span></span></strong></h3> 
<p style="margin-left:.8em"><span style="color:#333333"><strong>count</strong> 函数可以计算一张表中一共有多少条记录 , 并返回查询到的记录总数 , <strong>count</strong> 参数是什么类型都行</span></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">语法</span></strong></span></span></p> 
<pre><code class="language-sql">select count(&lt;表达式 / 列名&gt;) from &lt;数据表名&gt;;</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">说明</span></strong></span></span></p> 
<ul style="margin-left:.8em">
<li> <p><strong>count</strong> ( ) 中的参数可以是 <code>*</code> , 为 <code>*</code> 代表数据表中所有的记录</p> </li>
<li> <p><strong>count</strong> ( ) 中的参数如果不是 <code>*</code> 的话 , 如果查询中没有格外的条件 , 那么记录值为 <strong>null</strong> 的将不计入查询结果</p> </li>
</ul>
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例1</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">统计成绩表中一共有几条记录 , 参数为 <code>*</code> 的话 , 值为 <strong>null</strong> 的记录也会被计入到结果中</span></p> 
<pre><code class="language-sql">select count(*) from exam_result;

-- 查询结果
+----------+
| count(*) |
+----------+
|        8 |
+----------+
1 row in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">代码示例2</span></span></strong></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">由于使用 <code>*</code> 参数会将值为 <strong>null</strong> 的记录也会被计入到结果 , 所以为了更精确的知道某一列中有多少条记录 , 我们就可以对 <strong>count</strong> 传入指定列来进行聚合查询 , 例如查询 <strong>name</strong> 列有几条记录 , 在使用指定列进行聚合查询的时候 , 会将该列值为 <strong>null</strong> 的值给忽略 , 不计入最终查询结果中</span></p> 
<pre><code class="language-sql">select count(name) from exam_result;

-- 查询结果
+-------------+
| count(name) |
+-------------+
|           7 |
+-------------+
1 row in set (0.00 sec)</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h3 id="sum%E5%87%BD%E6%95%B0" style="text-align:center"><strong><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">sum函数</span></span></span></strong></h3> 
<p style="margin-left:.8em"><span style="color:#333333"><strong>sum</strong> 函数可以对表中的指定列或者表达式进行一个求和 , 前提要求传入的参数列 / 表达式是数值类型</span></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">语法</span></strong></span></span></p> 
<pre><code class="language-sql">select sum(表达式/列名) from &lt;数据表名&gt; [where];</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">说明</span></strong></span></span></p> 
<ul style="margin-left:.8em">
<li> <p>要求传入的参数列 / 表达式是数值类型 , 否则没有意义</p> </li>
<li> <p>[ ]表示可选项 , 在使用 <strong>sum</strong> 函数时可以使用 <strong>where</strong> 子句</p> </li>
</ul>
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例1</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">统计成绩表中的数学成绩总分</span></p> 
<pre><code class="language-sql">select sum(math) from exam_result;

-- 查询结果
+-----------+
| sum(math) |
+-----------+
|     581.5 |
+-----------+
1 row in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例2</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">统计成绩表中的数学成绩总分 , 要求对数学成绩大于 <strong>70</strong> 的分数进行求和 , 如果没有就返回 <strong>NULL</strong> , 这个时候我们就可以使用 <strong>where</strong> 子句进行条件筛选 , 增加条件 <strong>math &gt; 70</strong> , 这时候计算的就是大于 <strong>70</strong> 分以上的总分</span></p> 
<pre><code class="language-sql">select sum(math) from exam_result where math &gt; 70;

-- 查询结果
+-----------+
| sum(math) |
+-----------+
|     516.5 |
+-----------+
1 row in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">如果对于筛选条件没有对应的结果的话 , 就会返回 <strong>NULL</strong> , 例如要求对数学成绩小于 <strong>60</strong> 的分数进行求和 , 从上面的总表就能看出 , 在数学成绩那一列是没有小于 60 分的 , 记录为 <strong>NULL</strong> 的也不会计算到结果当中 , 所以本次查询返回值就是 <strong>NULL</strong></span></p> 
<pre><code class="language-sql">select sum(math) from exam_result where math &lt; 60;

-- 查询结果
+-----------+
| sum(math) |
+-----------+
|      NULL |
+-----------+
1 row in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例3</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">参数不仅可以是指定列 , 还能指定表达式 , 前提是表达式的列都是数值类型 , 例如对 语文、数学、英语 全部成绩进行求和计算总分</span></p> 
<pre><code class="language-sql">select sum(chinese + math + english) from exam_result;

-- 查询结果
+-------------------------------+
| sum(chinese + math + english) |
+-------------------------------+
|                        1550.0 |
+-------------------------------+
1 row in set (0.00 sec)</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h3 id="avg%E5%87%BD%E6%95%B0" style="text-align:center"><strong><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">avg函数</span></span></span></strong></h3> 
<p style="margin-left:.8em"><span style="color:#333333"><strong>avg</strong> 函数可以对表中的指定列或表达式进行一个求平均值的操作 , 前提要求参数是数值类型</span></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">语法</span></strong></span></span></p> 
<pre><code class="language-sql">select avg(表达式/列名) from &lt;数据表名&gt; [where];</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">说明</span></strong></span></span></p> 
<ul style="margin-left:.8em">
<li> <p>要求传入的参数列 / 表达式是数值类型 , 否则没有意义</p> </li>
<li> <p>[ ]表示可选项 , 在使用 <strong>avg</strong> 函数时可以使用 <strong>where</strong> 子句</p> </li>
</ul>
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例1</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">对成绩表中的数学成绩计算平均分</span></p> 
<pre><code class="language-sql">select avg(math) from exam_result;

-- 查询结果
+-----------+
| avg(math) |
+-----------+
|  83.07143 |
+-----------+
1 row in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例2</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">使用 <strong>where</strong> 子句对数学成绩大于 80 分的记录进行求平均分</span></p> 
<pre><code class="language-sql">select avg(math) from exam_result where math &gt; 80;

-- 查询结果
+-----------+
| avg(math) |
+-----------+
|  91.37500 |
+-----------+
1 row in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例3</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">传入参数是一个表达式 , 对三门课程总分统计平均分</span></p> 
<pre><code class="language-sql">select avg(chinese + math + english) from exam_result;

-- 查询结果
+-------------------------------+
| avg(chinese + math + english) |
+-------------------------------+
|                     221.42857 |
+-------------------------------+
1 row in set (0.00 sec)</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h3 id="max%E5%87%BD%E6%95%B0" style="text-align:center"><strong><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">max函数</span></span></span></strong></h3> 
<p style="margin-left:.8em"><span style="color:#333333"><strong>max</strong> 函数是返回表中的指定列中的最大值 , 前提要求该列为数值类型</span></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">语法</span></strong></span></span></p> 
<pre><code class="language-sql">select max(列名) from &lt;数据表名&gt; [where];</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">说明</span></strong></span></span></p> 
<ul style="margin-left:.8em">
<li> <p>要求传入的参数列是数值类型 , 否则没有意义</p> </li>
<li> <p>[ ]表示可选项 , 在使用 <strong>max</strong> 函数时可以使用 <strong>where</strong> 子句</p> </li>
</ul>
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例1</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">查询数学成绩最高分</span></p> 
<pre><code class="language-sql">select max(math) from exam_result;

-- 查询结果
+-----------+
| max(math) |
+-----------+
|      98.5 |
+-----------+
1 row in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例2</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">查询数学成绩小于 80 分的记录中的最高分</span></p> 
<pre><code class="language-sql">select max(math) from exam_result where math &lt; 80;

-- 查询结果
+-----------+
| max(math) |
+-----------+
|      78.0 |
+-----------+
1 row in set (0.00 sec)</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h3 id="min%E5%87%BD%E6%95%B0" style="text-align:center"><strong><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">min函数</span></span></span></strong></h3> 
<p style="margin-left:.8em"><span style="color:#333333"><strong>min</strong> 函数是返回表中的指定列中的最大值 , 前提要求该列为数值类型</span></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">语法</span></strong></span></span></p> 
<pre><code class="language-sql">select min(列名) from &lt;数据表名&gt; [where];</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">说明</span></strong></span></span></p> 
<ul style="margin-left:.8em">
<li> <p>要求传入的参数列是数值类型 , 否则没有意义</p> </li>
<li> <p>[ ]表示可选项 , 在使用 <strong>min</strong> 函数时可以使用 <strong>where</strong> 子句</p> </li>
</ul>
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例1</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">查询成绩表中 数学成绩 的最低分</span></p> 
<pre><code class="language-sql">select min(math) from exam_result;

-- 查询结果
+-----------+
| min(math) |
+-----------+
|      65.0 |
+-----------+
1 row in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例2</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">查询成绩表中 数学成绩大于 80 分的最低分</span></p> 
<pre><code class="language-sql">select min(math) from exam_result where math &gt; 80;
  
-- 查询结果
+-----------+
| min(math) |
+-----------+
|      84.0 |
+-----------+
1 row in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><strong><span style="color:#ff0000"><span style="color:inherit">聚合函数注意事项</span></span></strong></span></p> 
<ul style="margin-left:.8em">
<li> <p>以上介绍的聚合函数中除了 <strong>count</strong> 函数 , 其它 <strong>sum / avg / max / min</strong> 函数都要求参数列是数值类型</p> </li>
<li> <p>聚合函数是可以一起使用的</p> </li>
<li> <p><strong>where</strong> 子句不能对聚合查询后的数据进行筛选 , 这个下文 <strong>having</strong> 子句会讲到</p> </li>
</ul>
<h2 id="2.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2" style="text-align:center"><strong><span style="color:#333333">2.分组查询</span></strong></h2> 
<p style="margin-left:.8em"><span style="color:#333333"><span style="color:#008000"><strong><span style="color:inherit">分组查询属于是聚合查询中的一个重要用法 , 直接使用聚合函数相当于是把所有的数据都聚合在一起 , 但是一般来讲 , 有些场景下我们是需要将一张表进行分组后在使用聚合函数对分组后的数据进行查询 , 所以就会涉及到 "分组聚合" , 分组聚合的含义,就是根据某个列的值进行分组,把值相同的行分到一组去.然后再针对每个组分别执行聚合函数</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">在了解分组查询之前 , 我们需要准备另一张员工表作为测试表 , 并给这张员工表进行添加测试数据</span></p> 
<pre><code class="language-sql">create table emp(
	id int primary key auto_increment,
	name varchar(20) not null,
	role varchar(20) not null,
	salary numeric(11,2)
);
-- 添加测试数据
insert into emp(name, role, salary) values
('马云','服务员', 1000.20),
('马化腾','游戏陪玩', 2000.99),
('孙悟空','游戏角色', 999.11),
('猪无能','游戏角色', 333.5),
('沙和尚','游戏角色', 700.33),
('隔壁老王','董事长', 12000.66);</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<p style="text-align:center"><strong><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">group by子句</span></span></span></strong></p> 
<p style="margin-left:.8em"><span style="color:#333333"><strong>group by</strong> 是分组查询的关键字 , 使用 <strong>group by</strong> 可以对指定列进行分组查询 , 一般要搭配聚合函数使用</span></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">语法</span></strong></span></span></p> 
<pre><code class="language-sql">select &lt;聚合函数()&gt; from &lt;数据表&gt; group by &lt;分组条件&gt;;</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例1</span></strong></span></span></p> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ffa500"><strong><span style="color:inherit">题目 : 对员工表查询每个岗位的最高工资</span></strong></span></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">针对每个岗位 , 我们可以将 <strong>group by</strong> 的条件设置为员工表的岗位类型字段进行分组 ,对于查询这种最高或者最大的值 , 一般用 <strong>max</strong> 聚合函数 , ,为了数据表更详细 , 我们可以在指定列中添加岗位表一起展示</span></p> 
<pre><code class="language-sql">select role , max(salary) from emp group by role;

-- 查询结果
+--------------+-------------+
| role         | max(salary) |
+--------------+-------------+
| 服务员       |     1000.20 |
| 游戏角色     |      999.11 |
| 游戏陪玩     |     2000.99 |
| 董事长       |    12000.66 |
+--------------+-------------+
4 rows in set (0.00 sec</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">可以看到 , <strong>select</strong> 语句对我们使用 <strong>role</strong> 列作为 <strong>group by</strong> 条件 , 会自动按照条件 , 对于相同的岗位会分到一组 , 然后再对每一组进行聚合查询 , 得到最终分组聚合查询的结果</span></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例2</span></strong></span></span></p> 
<ul style="margin-left:.8em"><li> <p><strong><span style="color:#ffa500"><span style="color:inherit">题目 : 查询每个岗位的最高工资、最低工资和平均工资</span></span></strong></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">我们依旧可以根据 <strong>role</strong> 列来作为 <strong>group by</strong> 子句的条件进行分组 , 然后在针对工资分别使用 <strong>max min avg</strong> 聚合函数来进行计算</span></p> 
<pre><code class="language-sql">select role,max(salary),min(salary),avg(salary) from emp group by role;

-- 查询结果
+--------------+-------------+-------------+--------------+
| role         | max(salary) | min(salary) | avg(salary) |
+--------------+-------------+-------------+--------------+
| 服务员       |     1000.20 |     1000.20 |  1000.200000 |
| 游戏角色     |      999.11 |      333.50 |   677.646667 |
| 游戏陪玩     |     2000.99 |     2000.99 |  2000.990000 |
| 董事长       |    12000.66 |    12000.66 | 12000.660000 |
+--------------+-------------+-------------+--------------+
4 rows in set (0.00 sec)</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h3 id="having%E5%AD%90%E5%8F%A5" style="text-align:center"><strong><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">having子句</span></span></span></strong></h3> 
<p style="margin-left:.8em"><span style="color:#333333">在使用 <strong>group by</strong> 子句进行分组后 , 如果想对聚合分组后的条件进行筛选时 , 由于在前面我们学习了 <strong>where</strong> 子句 , 此时我们第一个想法肯定是使用 <strong>where</strong> 子句来进行条件筛选 , 但是在 <strong>where</strong> 子句中的条件是针对当前表中的原始数据来进行筛选的 , 我们期望的是针对聚合后的数据进行筛选 , 那么就需要用 <strong>having</strong> 子句 , <strong>having</strong> 子句的使用跟 <strong>where</strong> 子句使用一样 , 如果条件不是聚合函数或者聚合后的数据 , 那么 <strong>having</strong> 和 <strong>where</strong> 没区别</span></p> 
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">语法</span></span></strong></span></p> 
<pre><code class="language-sql">select &lt;聚合函数()&gt; from &lt;数据表名&gt; group by &lt;分组条件&gt; having &lt;条件&gt;;</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例1</span></strong></span></span></p> 
<ul style="margin-left:.8em"><li> <p><strong><span style="color:#ffa500"><span style="color:inherit">题目 : 对各岗位计算平均工资 , 过滤平均工资小于 1500 的岗位</span></span></strong></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">我们先看看过滤前的分组聚合查询的记录</span></p> 
<pre><code class="language-sql">select role,avg(salary) from emp group by role;

-- 查询结果
+--------------+--------------+
| role         | avg(salary)  |
+--------------+--------------+
| 服务员       |  1000.200000 |
| 游戏角色     |   677.646667 |
| 游戏陪玩     |  2000.990000 |
| 董事长       | 12000.660000 |
+--------------+--------------+
4 rows in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">对于这种需要过滤聚合函数计算后的记录 , 就可以使用 <strong>having</strong> 来进行过滤 , 将平均工资大于 1500 作为条件 , 过滤掉平均工资小于 1500 的岗位</span></p> 
<pre><code class="language-sql">select role,avg(salary) from emp group by role having avg(salary) &gt; 1500;

-- 查询结果
+--------------+--------------+
| role         | avg(salary)  |
+--------------+--------------+
| 游戏陪玩     |  2000.990000 |
| 董事长       | 12000.660000 |
+--------------+--------------+
2 rows in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">代码示例2</span></span></strong></span></p> 
<p style="margin-left:.8em"><span style="color:#333333"><strong>where</strong> 也能和 <strong>group by</strong> 搭配使用 , <strong>where</strong> 是针对聚合前的数据进行筛选 , <strong>having</strong> 是针对聚合后的数据进行筛选 , 两个子句可以搭配使用 , 例如</span></p> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ffa500"><strong><span style="color:inherit">题目 : 找到所有平均薪资大于 1500 的岗位 , 过滤掉董事长岗位</span></strong></span></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">对于这种题目 , 我们就可以使用 <strong>where</strong> 子句过滤掉 "董事长" 然后使用 <strong>group by</strong> 先对岗位进行一个聚合分组 , 最后在对聚合分组的平均工资使用 <strong>having</strong> 进行过滤掉小于 1500 的岗位</span></p> 
<pre><code class="language-sql">select role,avg(salary)
from emp
where role != '董事长'
group by role
having avg(salary) &gt; 1500;

-- 查询结果
+--------------+-------------+
| role         | avg(salary) |
+--------------+-------------+
| 游戏陪玩     | 2000.990000 |
+--------------+-------------+
1 row in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333"><span style="color:#ffa500"><strong><span style="color:inherit">group by </span></strong><span style="color:inherit">分组的过程 , 本质上还是需要针对表进行遍历.根据指定列 </span><strong><span style="color:inherit">role</span></strong><span style="color:inherit"> 的值,来把当前记录归到某个组中了.如果搭配了</span><strong><span style="color:inherit">where role != '董事长'</span></strong><span style="color:inherit">，意味着当遇到 董事长 这条记录的时候这条记录就不会被归入任何分组 , 满足 </span><strong><span style="color:inherit">where</span></strong><span style="color:inherit"> 条件的记录，才会进入分组</span></span></span></p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h1 id="%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2" style="text-align:center"><strong><span style="color:#333333">多表查询</span></strong></h1> 
<p style="margin-left:.8em"><span style="color:#333333"><span style="color:#008000"><strong><span style="color:inherit">在原先我们学习的都是针对一张表进行查询 , 实际开发中往往数据来自不同的表，所以需要多表联合查询。</span></strong></span></span></p> 
<h2 id="1.%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF" style="text-align:center"><strong><span style="color:#333333">1.笛卡尔积</span></strong></h2> 
<p style="margin-left:.8em"><span style="color:#333333">多表查询是对多张表的数据取笛卡尔积 , 所谓的笛卡尔积就是将多张表中的记录全部组合可能性枚举到一张临时表当中 , 如果没有任何条件限制 , 那么在这张临时表中的记录总数 = (表A * 表B)的记录</span><img alt="" height="531" src="https://images2.imgbox.com/5b/29/tsCit1su_o.png" width="966"></p> 
<ul style="margin-left:.8em">
<li> <p><span style="color:#ff0000"><strong><span style="color:inherit">新表的列数,相当于原来两张表的列数之和.</span></strong></span></p> </li>
<li> <p><strong><span style="color:#ff0000"><span style="color:inherit">新表的行数,相当于原来两张表的行数之积.</span></span></strong></p> </li>
</ul>
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">语法</span></span></strong></span></p> 
<pre><code class="language-sql">select &lt;列名&gt; from 数据表1 , 数据表2,....; </code></pre> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ff0000"><strong><span style="color:inherit">多张表使用 逗号 分割</span></strong></span></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">用代码来简单了解一下 笛卡尔积 的操作 , 先创建三张测试表 </span></p> 
<ul style="margin-left:.8em">
<li> <p><strong>student</strong> 学生表 , 表中字段有 : <strong>id(自增主键)</strong> 序号 , <strong>name</strong> 学生名</p> <pre><code class="language-sql">create table student(
    id int primary key auto_increment,
    name varchar(20)
);</code></pre> </li>
<li> <p><strong>course</strong> 课程表 , 表中字段有 : <strong>id(自增主键)</strong> 课程序号 , <strong>name</strong> 课程名</p> <pre><code class="language-sql">create table course(
	id int primary key auto_increment,
    name varchar(20)
);</code></pre> </li>
<li> <p><strong>scores</strong> 成绩表 , 表中字段有 : <strong>score</strong> 分数 , <strong>student_id</strong> 对应学生表 <strong>id</strong> , <strong>course_id</strong> 对应课程表 <strong>id</strong></p> <pre><code class="language-sql">create table scores(
	score decimal(3,1),
	student_id int,
	course_id int
);</code></pre> </li>
<li> <p>对三张表添加测试记录</p> <pre><code class="language-sql">-- 对 student 表添加记录
insert into student(name) values
('张三'),
('李四'),
('王五'),
('赵六'),
('孙七');

-- 对 course 表添加记录
insert into course(name) values
('语文'),
('数学'),
('英语');

-- 对 scores 表添加记录
insert into scores values
(70.5,1,1),(80.5,1,2),(95,1,3),-- 张三
(98.5,2,1),(86,2,2),(64,2,3),-- 李四
(81.0,3,1),(95.0,3,2),(86.0,3,3),-- 王五
(79.0,4,1),(73.5,4,2),(88,4,3),-- 赵六
(76.5,5,1),(91,5,2),(79,5,3);-- 孙七</code></pre> </li>
</ul>
<p style="margin-left:.8em"><span style="color:#333333">接下来我们来对学生表和分数表进行一个笛卡尔积的操作 , 由于笛卡尔积的操作会返回大量的数据 , 所以这里采用 <strong>limit</strong> 关键字限制一下查询的记录 , 看一下笛卡尔积会发生什么</span></p> 
<pre><code class="language-sql">select * from student,scores limit 10;

-- 查询结果
+----+--------+-------+------------+-----------+
| id | name   | score | student_id | course_id |
+----+--------+-------+------------+-----------+
|  1 | 张三   |  70.5 |          1 |         1 |
|  2 | 李四   |  70.5 |          1 |         1 |
|  3 | 王五   |  70.5 |          1 |         1 |
|  4 | 赵六   |  70.5 |          1 |         1 |
|  5 | 孙七   |  70.5 |          1 |         1 |
|  1 | 张三   |  80.5 |          1 |         2 |
|  2 | 李四   |  80.5 |          1 |         2 |
|  3 | 王五   |  80.5 |          1 |         2 |
|  4 | 赵六   |  80.5 |          1 |         2 |
|  5 | 孙七   |  80.5 |          1 |         2 |
+----+--------+-------+------------+-----------+
10 rows in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">从笛卡尔积得到的临时表10条记录当中可以看到 , 对两张表进行笛卡尔积 , 是将两张表中的记录进行枚举组合一遍 , 在进行笛卡尔后也会得到很多无效记录 , 虽然才显示 10 条记录 , 无效记录就有 8 条 , 比如临时表中的 </span><strong><span style="color:inherit">张三</span></strong><span style="color:inherit"> 同学对应的 </span><strong><span style="color:inherit">student_id</span></strong><span style="color:inherit"> 应该是 </span><strong><span style="color:inherit">1</span></strong><span style="color:inherit"> , 在经过笛卡尔积后 , 临时表中又多出来多条同学对应的 </span><strong><span style="color:inherit">studentId</span></strong><span style="color:inherit"> 不为 </span><strong><span style="color:inherit">1</span></strong><span style="color:inherit">  的记录 , 所以在进行笛卡尔积操作时一般都会加上条件筛选。</span></span></span></p> 
<p><span style="color:#333333">笛卡尔积对两张表的链接操作又可以细分为 <strong>内连接 左外连接 右外连接</strong> , 一起往下看看叭</span></p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h2 id="2.%E5%86%85%E8%BF%9E%E6%8E%A5" style="text-align:center"><strong><span style="color:#333333">2.内连接</span></strong></h2> 
<p style="margin-left:.8em"><span style="color:#333333">对于上面的笛卡尔积 , 会出现大量的无效记录 , 针对无效记录进行筛选就是设置连接条件 , 而笛卡尔积中的内连接是通过在查询中设置连接条件的方式<strong>来移除查询结果集中某些数据行后的交叉连接</strong> , 通俗点来说就是将两张表使用条件筛选出对应的记录 , 一般都是找两张表中的 <strong>对应列</strong> 作为等值条件 , 如下图所示 , 将两张表中的对应的数据给展现出来</span><img alt="" height="861" src="https://images2.imgbox.com/24/71/oVP4io40_o.png" width="1200"></p> 
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">语法</span></span></strong></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">对于内连接 , 一共有两种方式</span></p> 
<pre><code class="language-sql">select &lt;列名&gt; from &lt;数据表名1&gt;,&lt;数据表名2&gt;,... where &lt;链接条件&gt;;
select &lt;列名&gt; from &lt;数据表1&gt; [inner] join &lt;数据表2&gt; on &lt;链接条件&gt;;</code></pre> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ff0000"><strong><span style="color:inherit">inner</span></strong><span style="color:inherit"> 是内连接的关键字 , 默认就是内连接 , 可以省略 , 但是链接条件不写的话就是笛卡尔积了</span></span></p> </li></ul>
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">代码示例1</span></span></strong></span></p> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ffa500"><strong><span style="color:inherit">题目 : 查看所有学生的分数</span></strong></span></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">需要用到学生表和分数表 , 对于两张表我们可以看到 <strong>student</strong> 表中的 <strong>id</strong> 字段是可以对应上 <strong>scores</strong> 表的 <strong>studentId</strong> 的 , 所以我们可以将 <strong>id = studentId</strong> 作为连接条件 , 为了区分是哪张表的字段 , 我们可以在字段前面加上 <strong>表名.</strong> , 例如 <strong>id可以写成 student.id</strong></span></p> 
<pre><code class="language-sql">select name,score
from student,scores
where student.id = scores.student_id;

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 张三   |  70.5 |
| 张三   |  80.5 |
| 张三   |  95.0 |
| 李四   |  98.5 |
| 李四   |  86.0 |
| 李四   |  64.0 |
| 王五   |  81.0 |
| 王五   |  95.0 |
| 王五   |  86.0 |
| 赵六   |  79.0 |
| 赵六   |  73.5 |
| 赵六   |  88.0 |
| 孙七   |  76.5 |
| 孙七   |  91.0 |
| 孙七   |  79.0 |
+--------+-------+
15 rows in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">对于第二种写法也是一样的</span></p> 
<pre><code class="language-sql">select name,score
from student
join scores on student.id = scores.student_id;

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 张三   |  70.5 |
| 张三   |  80.5 |
| 张三   |  95.0 |
| 李四   |  98.5 |
| 李四   |  86.0 |
| 李四   |  64.0 |
| 王五   |  81.0 |
| 王五   |  95.0 |
| 王五   |  86.0 |
| 赵六   |  79.0 |
| 赵六   |  73.5 |
| 赵六   |  88.0 |
| 孙七   |  76.5 |
| 孙七   |  91.0 |
| 孙七   |  79.0 |
+--------+-------+
15 rows in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">可以看到通过设置链接条件 , 可以将两张表中的对应的记录一起展示出来 , 并且没有多余的无效记录</span></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例2</span></strong></span></span></p> 
<ul style="margin-left:.8em"><li> <p><strong><span style="color:#ffa500"><span style="color:inherit">题目 : 查询 "张三" 同学的分数</span></span></strong></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">对于这种题目 , 我们不仅要设置链接条件 , 这里的链接条件也是 <strong>id=studentId</strong> , 还需要添加其它条件 , 对于链接条件和其他条件要同时筛选 , 我们可以使用 <strong>and</strong> 逻辑运算符 , 在 <strong>and</strong> 后面加个 <strong>name="张三"</strong> 的条件进行筛选</span></p> 
<pre><code class="language-sql">select name,score
from student
join scores on student.id = scores.student_id and student.name = '张三';

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 张三   |  70.5 |
| 张三   |  80.5 |
| 张三   |  95.0 |
+--------+-------+
3 rows in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">当然也可以将 <strong>join on</strong> 作为链接条件 , 使用 <strong>where</strong> 作为其它条件 , 这样代码会更易读</span></p> 
<pre><code class="language-sql">select name,score
from student
join scores on student.id = scores.student_id 
where student.name = '张三';

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 张三   |  70.5 |
| 张三   |  80.5 |
| 张三   |  95.0 |
+--------+-------+
3 rows in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">代码示例3</span></span></strong></span></p> 
<ul style="margin-left:.8em"><li> <p><strong><span style="color:#ffa500"><span style="color:inherit">查看所有同学对应的课程成绩 , 并展示课程信息</span></span></strong></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">由于学生 , 课程 , 成绩都在不同的表中 , 所以这道题目要涉及到三张表进行笛卡尔积内连接查询 , 所以我们要先找到三张表之间的关联 , 而在 <strong>scores</strong> 表当中有两个字段 <strong>student_id 和 course_id</strong> 对应的就是 <strong>student</strong> 表中的<strong>id</strong> 和 <strong>course</strong> 表中的 <strong>id</strong> , 所以我们将链接条件设置为 <strong>scores.student_id = student.id and scorese.course_id = course.id</strong> , 对于 <strong>course</strong> 表中的 <strong>name</strong> 字段和 <strong>student</strong> 表中的 <strong>name</strong> 字段冲突了 , 我们也可以使用 <strong>数据表名.字段</strong> 来区分</span></p> 
<pre><code class="language-sql">select student.name,course.name,scores.score
from student,course,scores
where scores.student_id = student.id and scores.course_id = course.id;
	
-- 查询结果
+--------+--------+-------+
| name   | name   | score |
+--------+--------+-------+
| 张三   | 语文   |  70.5 |
| 张三   | 数学   |  80.5 |
| 张三   | 英语   |  95.0 |
| 李四   | 语文   |  98.5 |
| 李四   | 数学   |  86.0 |
| 李四   | 英语   |  64.0 |
| 王五   | 语文   |  81.0 |
| 王五   | 数学   |  95.0 |
| 王五   | 英语   |  86.0 |
| 赵六   | 语文   |  79.0 |
| 赵六   | 数学   |  73.5 |
| 赵六   | 英语   |  88.0 |
| 孙七   | 语文   |  76.5 |
| 孙七   | 数学   |  91.0 |
| 孙七   | 英语   |  79.0 |
+--------+--------+-------+
15 rows in set (0.00 sec)</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h2 id="3.%E5%A4%96%E8%BF%9E%E6%8E%A5" style="text-align:center"><strong><span style="color:#333333">3.外连接</span></strong></h2> 
<p style="margin-left:.8em"><span style="color:#333333"><strong><span style="color:#008000"><span style="color:inherit">外连接分为左外连接和右外连接 , 如果多表查询 , 左侧的表完全显示我们就说是左外连接 , 右侧的表完全显示我们就说是右外连接。</span></span></strong></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">为了更好的了解外连接 , 我们在这还需要先插入两条测试记录</span></p> 
<ul style="margin-left:.8em">
<li> <p>给 <strong>student</strong> 表添加一条记录 , 不对 <strong>name</strong> 添加数据</p> <pre><code class="language-sql">insert into student values(6,'周八');</code></pre> </li>
<li> <p>给 <strong>scores</strong> 添加一条记录</p> <pre><code class="language-sql">insert into scores(score) values(88.0);</code></pre> </li>
</ul>
<p style="margin-left:.8em"><span style="color:#333333">这样这两张表就有一条记录对应不上了 , 我们先对两张表进行内连接查看一下</span></p> 
<pre><code class="language-sql">select name,score 
from student
join scores on student.id = scores.student_id;

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 张三   |  70.5 |
| 张三   |  80.5 |
| 张三   |  95.0 |
| 李四   |  98.5 |
| 李四   |  86.0 |
| 李四   |  64.0 |
| 王五   |  81.0 |
| 王五   |  95.0 |
| 王五   |  86.0 |
| 赵六   |  79.0 |
| 赵六   |  73.5 |
| 赵六   |  88.0 |
| 孙七   |  76.5 |
| 孙七   |  91.0 |
| 孙七   |  79.0 |
+--------+-------+
15 rows in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">可以看到 , 进行内连接查询时 , 刚才插入的两条记录没对应上 , 所以在内连接查询结果当中并不包含刚刚插入的记录 , 所以想将不对应的数据也展现出来的话 , 就要使用外连接 , 接下来看一下外连接是怎么操作的</span></p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h3 id="%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5" style="text-align:center"><strong><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">左外连接</span></span></span></strong></h3> 
<p style="margin-left:.8em"><span style="color:#333333">左外连接又称为左连接 , 在 左外链接 得到的临时表当中 , 除了匹配对应的行之外 , 还会尽可能的将左边的表中与右边的表中不匹配的信息给展现出来 , 如下图所示 , 将两张表中除了对应的数据给展现出来之外 , 还将左边表中的数据一起展现出来</span><img alt="" height="861" src="https://images2.imgbox.com/d5/dc/CNsqEoOt_o.png" width="1200"></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">语法</span></strong></span></span></p> 
<pre><code class="language-sql">select &lt;列名&gt; from &lt;数据表1&gt; left join &lt;数据表2&gt; on &lt;连接条件&gt;;</code></pre> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ff0000"><strong><span style="color:inherit">left</span></strong><span style="color:inherit">是左外连接关键字 , 最终查询结果,是以 </span><strong><span style="color:inherit">join</span></strong><span style="color:inherit"> 左侧的表为主，会尽可能的把左侧的表的所有信息都体现出来 </span></span></p> </li></ul>
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">代码示例</span></strong></span></span></p> 
<ul style="margin-left:.8em"><li> <p><strong><span style="color:#ffa500"><span style="color:inherit">题目 : 查看所有同学的成绩 , 如果该同学没有成绩也需要显示</span></span></strong></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">将 <strong>student</strong> 表作为左表 , <strong>scores</strong> 表作为右表 , 这样进行左外连接笛卡尔积的时候就会将 <strong>student</strong> 表中的信息全部展现出来 , 即使有记录不对应 <strong>scores</strong> 表中的记录 , 对应的列就会默认填 <strong>NULL</strong></span></p> 
<pre><code class="language-sql">select name,score
from student
left join scores on student.id = scores.student_id;

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 张三   |  70.5 |
| 张三   |  80.5 |
| 张三   |  95.0 |
| 李四   |  98.5 |
| 李四   |  86.0 |
| 李四   |  64.0 |
| 王五   |  81.0 |
| 王五   |  95.0 |
| 王五   |  86.0 |
| 赵六   |  79.0 |
| 赵六   |  73.5 |
| 赵六   |  88.0 |
| 孙七   |  76.5 |
| 孙七   |  91.0 |
| 孙七   |  79.0 |
| 周八   |  NULL |
+--------+-------+
16 rows in set (0.00 sec)</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h3 id="%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5" style="text-align:center"><strong><span style="color:#333333"><span style="color:#ffa500"><span style="color:inherit">右外连接</span></span></span></strong></h3> 
<p style="margin-left:.8em"><span style="color:#333333">右外连接又称为右连接 , 除了展示匹配对应的记录之外 , 还会尽可能的将右边的表中与左边边的表中不匹配的信息给展现出来 , 跟左外连接差不多 , 不过一个是展示左表的全部信息 , 一个是展示右表的所有信息 , 如下图所示</span><img alt="" height="861" src="https://images2.imgbox.com/d9/28/SVXvrROF_o.png" width="1200"></p> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">语法</span></strong></span></span></p> 
<pre><code class="language-sql">select &lt;列名&gt; from &lt;数据表1&gt; right join &lt;数据表2&gt; on &lt;链接条件&gt;;</code></pre> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ff0000"><strong><span style="color:inherit">right</span></strong><span style="color:inherit"> 是右链接查询的关键字 , 和左外连接类似,是以 </span><strong><span style="color:inherit">join</span></strong><span style="color:inherit">右侧的表为主,尽可能把右侧表的每个信息都体现出来.</span></span></p> </li></ul>
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">代码示例</span></span></strong></span></p> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ffa500"><strong><span style="color:inherit">题目 : 查看所有的分数及对应的同学 , 如果分数没有对应的学生也需要显示</span></strong></span></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">将 <strong>student</strong> 表作为左表 , <strong>scores</strong> 表作为右表 , 使用右外连接查询就可以就将 <strong>scores</strong> 表中所有的记录给展示出来</span></p> 
<pre><code class="language-sql">select name,score 
from student 
right join scores on student.id = scores.student_id;

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 张三   |  70.5 |
| 张三   |  80.5 |
| 张三   |  95.0 |
| 李四   |  98.5 |
| 李四   |  86.0 |
| 李四   |  64.0 |
| 王五   |  81.0 |
| 王五   |  95.0 |
| 王五   |  86.0 |
| 赵六   |  79.0 |
| 赵六   |  73.5 |
| 赵六   |  88.0 |
| 孙七   |  76.5 |
| 孙七   |  91.0 |
| 孙七   |  79.0 |
| NULL   |  88.0 |
+--------+-------+
16 rows in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333"><span style="color:#ff0000"><strong><span style="color:inherit">ps : 左外链接能做到的查询 , 右外连接也能对应查询 , 相反右外链接能做到的查询 , 左外连接也能对应查询 , 只需要将两张表的顺序交换即可 , 得到的结果是一样的</span></strong></span></span></p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h1 id="%E8%87%AA%E9%93%BE%E6%8E%A5" style="text-align:center"><strong><span style="color:#333333">自链接</span></strong></h1> 
<p style="margin-left:.8em"><span style="color:#333333"><span style="color:#008000"><strong><span style="color:inherit">自链接属于 SQL中的"奇淫巧计" , 本质是把一张表当作两张来使用 , 也就是自己和自己做笛卡尔积 , 在进行自链接时需要给表设置别名</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333"><strong>在 MySQL 中比较方便的是字段与字段中进行比较 , 也就是列与列之间进行比较 , 但要想行与行之间进行并比较是比较困难的 , 比如上面创建的成绩表 , 对于不同的课程 , 成绩是行与行之间进行展示的 , 如果想进行课程成绩比较是比较困难的 , 比如以下题目</strong></span></p> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ffa500"><strong><span style="color:inherit">查询出所有语文成绩小于数学成绩的记录 , 语文课程id为1 , 数学课程id为2</span></strong></span></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">我们可以使用自链接将行与行之间的比较转换成列于列之间的比较 , 对于这种复杂的 SQL 语句我们可以分步骤执行 SQL 语句 , 我们可以先使用内连接查询 , 建立两张表的链接 , 不要忘了给表名取别名 , 我们可以使用 <strong>limit</strong> 限制查询记录 , 然后再从结果中找到出筛选条件在进行下一步的 SQL</span></p> 
<pre><code class="language-sql">select * 
from scores as s1 
join scores as s2 on s1.student_id = s2.student_id limit 15;</code></pre> 
<p><span style="color:#333333"><strong>查询结果</strong></span></p> 
<p style="margin-left:.8em"><img alt="" height="562" src="https://images2.imgbox.com/0f/da/olalEBVB_o.png" width="935"></p> 
<p style="margin-left:.8em"><span style="color:#333333">可以看到 , 在内连接查询表中课程 <strong>id</strong> 为 <strong>1</strong> 和 课程 <strong>id</strong> 为 <strong>2</strong> 的有同一行的记录的 , 所以我们下一步 SQL 语句只需要将课程 <strong>id</strong> 为 <strong>1</strong> 和 课程 <strong>id</strong> 为 <strong>2</strong> 的记录筛选出来进行分数比较即可得到最终结果</span></p> 
<pre><code class="language-sql">select * 
from scores as s1 
join scores as s2 on s1.student_id = s2.student_id
where s1.course_id = 1 and s2.course_id = 2 and s1.score &lt; s2.score;

-- 查询结果
+-------+------------+-----------+-------+------------+-----------+
| score | student_id | course_id | score | student_id | course_id |
+-------+------------+-----------+-------+------------+-----------+
|  70.5 |          1 |         1 |  80.5 |          1 |         2 |
|  81.0 |          3 |         1 |  95.0 |          3 |         2 |
|  76.5 |          5 |         1 |  91.0 |          5 |         2 |
+-------+------------+-----------+-------+------------+-----------+
3 rows in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><span style="color:#ff0000"><strong><span style="color:inherit">注意 : 在进行自链接时 , 需要给数据表设置别名 , 否则会报错</span></strong></span></span></p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h1 id="%E5%AD%90%E6%9F%A5%E8%AF%A2" style="text-align:center"><strong><span style="color:#333333">子查询</span></strong></h1> 
<p style="margin-left:.8em"><span style="color:#333333"><strong><span style="color:#008000"><span style="color:inherit">子查询是嵌套在另一个SQL语句中的查询 , 也可以称为嵌套查询 , 将内部查询的结果返回给外部的SQL语句 , 一般用内部查询的结果作为外部查询的条件 , where 型子查询把内层查询结果当作外层查询的比较条件,简单来说就是套娃</span></span></strong></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">先插入两条重复数据 , 方便下面的代码示例</span></p> 
<pre><code class="language-sql">insert into scores values
(70.5,1,1),(80.5,1,2),(95,1,3),-- 张三
(98.5,2,1),(86,2,2),(64,2,3);-- 李四</code></pre> 
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">代码示例1</span></span></strong></span></p> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ffa500"><strong><span style="color:inherit">题目 : 查询王五同学的语文成绩</span></strong></span></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">前面我们知道 <strong>语文</strong> 课程的 <strong>id</strong> 是 <strong>1</strong> , 所以我们查询的时候可以直接对分数表中的 <strong>course_id</strong> 字段进行筛选条件内连接查询 , 就很容易得到结果</span></p> 
<pre><code class="language-sql">select student.name,scores.score 
from student
join scores on student.id = scores.student_id
where name = '王五' and scores.course_id = 1;

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 王五   |  81.0 |
+--------+-------+
1 row in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">那么 , 假设我们不知道 <strong>语文</strong> 课程 <strong>id</strong> 的情况下 , 该怎么去查询 ? 按照正常的想法就是要进行分批查询 , 首先我们先在课程表通过课程名查询出课程 <strong>id</strong></span></p> 
<pre><code class="language-sql">select id from course where name = '语文';

-- 查询结果
+----+
| id |
+----+
|  1 |
+----+
1 row in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">知道课程 <strong>id</strong> 后 , 然后我们再去进行查成绩的 SQL 语句</span></p> 
<pre><code class="language-sql">select student.name,scores.score 
from student
join scores on student.id = scores.student_id
where name = '王五' and scores.course_id = 1;

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 王五   |  81.0 |
+--------+-------+
1 row in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">但是 , <strong>MySQL</strong> 中的子查询就可以将以上分批查询的两条语句合并成一条语句 , 子查询的功能就是将一条 <strong>SQL</strong> 语句的结果返回给另一条 <strong>SQL</strong> 语句 , 所以我们可以将查询课程 <strong>id</strong> 的 <strong>SQL</strong> 语句的结果 作为 查询成绩的 <strong>SQL</strong> 语句条件中的值 , 一样可以得到正确查询结果</span></p> 
<pre><code class="language-sql">select student.name,scores.score 
from student
join scores on student.id = scores.student_id
where name = '王五' and scores.course_id = (select id from course where name = '语文' );

-- 查询结果
+--------+-------+
| name   | score |
+--------+-------+
| 王五   |  81.0 |
+--------+-------+
1 row in set (0.00 sec)</code></pre> 
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">代码示例2</span></span></strong></span></p> 
<ul style="margin-left:.8em"><li> <p><span style="color:#ffa500"><strong><span style="color:inherit">题目 : 查询重复的成绩</span></strong></span></p> </li></ul>
<p style="margin-left:.8em"><span style="color:#333333">这道题我们需要去针对成绩表中的所有记录进行一个分组计数 , 可以使用聚合函数 <strong>count</strong> 配合分组 <strong>group by</strong> 实现 , 对于重复记录可以在分组聚合查询后增加对 聚合函数 的筛选条件 , 将总数大于 <strong>1</strong> 的记录给展示出来 , 再将记录返回给查询重复成绩的 <strong>SQL</strong> 语句。</span></p> 
<p style="margin-left:.8em"><span style="color:#333333">在查询重复记录 <strong>SQL</strong> 语句中 , 我们需要对 <strong>score,student_id,course_id</strong> 来对返回结果进行等值判断 , 由于返回回结果可能有多个 , 所以我们使用 <strong>in</strong> 运算符来进行条件筛选</span></p> 
<pre><code class="language-sql">select * 
from scores
where (score,student_id,course_id) in (
	select *
	from scores
	group by student_id,course_id having count(*) &gt; 1
);

-- 查询结果
+-------+------------+-----------+
| score | student_id | course_id |
+-------+------------+-----------+
|  70.5 |          1 |         1 |
|  80.5 |          1 |         2 |
|  95.0 |          1 |         3 |
|  98.5 |          2 |         1 |
|  86.0 |          2 |         2 |
|  64.0 |          2 |         3 |
|  70.5 |          1 |         1 |
|  80.5 |          1 |         2 |
|  95.0 |          1 |         3 |
|  98.5 |          2 |         1 |
|  86.0 |          2 |         2 |
|  64.0 |          2 |         3 |
+-------+------------+-----------+
12 rows in set (0.00 sec)</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<h2 id="%E5%90%88%E5%B9%B6%E6%9F%A5%E8%AF%A2" style="text-align:center"><strong><span style="color:#333333">合并查询</span></strong></h2> 
<p style="margin-left:.8em"><span style="color:#333333"><span style="color:#008000"><span style="color:inherit">MySQL中可以使用使用集合操作符 </span><strong><span style="color:inherit">union，union all</span></strong><span style="color:inherit">合并多个 </span><strong><span style="color:inherit">select</span></strong><span style="color:inherit"> 的执行结果 ，</span><strong><span style="color:inherit">union</span></strong><span style="color:inherit"> 和 </span><strong><span style="color:inherit">union all</span></strong><span style="color:inherit"> 时，前后查询的结果集中，字段需要一致</span></span></span></p> 
<p><span style="color:#333333"><strong><span style="color:#4da8ee"><span style="color:inherit">语法</span></span></strong></span></p> 
<pre><code class="language-sql">select &lt;列名&gt; from 数据表名 [where] &lt;条件&gt;
union/union all
select &lt;列名&gt; from 数据表名 [where] &lt;条件&gt;;</code></pre> 
<p><span style="color:#333333"><span style="color:#4da8ee"><strong><span style="color:inherit">示例</span></strong></span></span></p> 
<p style="margin-left:.8em"><span style="color:#333333">第一个查询语句查询 <strong>student</strong> 表中 <strong>id</strong> 字段小于 <strong>3</strong> 的记录 , 第二个查询语句查询 <strong>student</strong> 表中 <strong>id</strong> 字段小于 <strong>5</strong> 的记录 , 使用合并查询将两张表进行合并</span></p> 
<pre><code class="language-sql">select * from student where id &lt; 3
union all
select * from student where id &lt; 5;

-- 查询结果
+----+--------+
| id | name   |
+----+--------+
|  1 | 张三   |
|  2 | 李四   |
|  1 | 张三   |
|  2 | 李四   |
|  3 | 王五   |
|  4 | 赵六   |
+----+--------+
6 rows in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">以上是集合操作符 <strong>union all</strong> 的使用 , 我们使用 <strong>union</strong> 看看有什么区别</span></p> 
<pre><code class="language-sql">select * from student where id &lt; 3
union
select * from student where id &lt; 5;

-- 查询结果
+----+--------+
| id | name   |
+----+--------+
|  1 | 张三   |
|  2 | 李四   |
|  3 | 王五   |
|  4 | 赵六   |
+----+--------+
4 rows in set (0.00 sec)</code></pre> 
<p style="margin-left:.8em"><span style="color:#333333">可以看到 , 使用 <strong>union all</strong> 的时候会将两张表中的重复记录一起展示出来 , 而使用 <strong>union</strong> 的时候会去掉重复行可达到去重效果</span></p> 
<h1 id="%E2%80%8B%C2%A0%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" style="text-align:center">
<img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"> <strong><span style="color:#333333">关键字执行顺序</span></strong>
</h1> 
<p style="margin-left:.8em"><span style="color:#333333">在文章的最后 , 给大家分享一下<strong>SQL</strong> 查询语句中的各个关键字的执行的先后顺序</span></p> 
<table border="1" cellspacing="0" style="width:576.023px">
<thead><tr>
<th style="text-align:center;width:206px"><strong>1</strong></th>
<th style="text-align:center;width:368px"><strong>from</strong></th>
</tr></thead>
<tbody>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>2</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>on</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>3</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>join</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>4</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>where</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>5</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>group by</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>6</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>with</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>7</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>having</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>8</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>select</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>9</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>distinct</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>10</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>order by</strong></td>
</tr>
<tr>
<td style="border-color:#dfe2e5;text-align:center;width:206px"><strong>11</strong></td>
<td style="border-color:#dfe2e5;text-align:center;width:368px"><strong>limit</strong></td>
</tr>
</tbody>
</table>
<p><img alt="" height="54" src="https://images2.imgbox.com/5f/b2/9EBv8Pps_o.png" width="1200"></p> 
<p style="text-align:center"><span style="color:#fe2c24"><strong> 本章到此结束,如果文中有写的不对或不懂的地方,欢迎评论区讨论,谢谢!</strong></span></p> 
<p><img alt="" height="107" src="https://images2.imgbox.com/ec/54/ADw5aI32_o.jpg" width="432">​</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>