<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【Rust】Rust学习 第十九章高级特征 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Rust】Rust学习 第十九章高级特征</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p>现在我们已经学习了 Rust 编程语言中最常用的部分。在第二十章开始另一个新项目之前，让我们聊聊一些总有一天你会遇上的部分内容。你可以将本章作为不经意间遇到未知的内容时的参考。本章将要学习的功能在一些非常特定的场景下很有用处。虽然很少会碰到它们，我们希望确保你了解 Rust 提供的所有功能。</p> 
<p>本章将涉及如下内容：</p> 
<ul>
<li><strong>不安全 Rust：用于当需要舍弃 Rust 的某些保证并负责手动维持这些保证</strong></li>
<li><strong>高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法（fully qualified syntax），超（父）trait（supertraits）和 newtype 模式</strong></li>
<li><strong>高级类型：关于 newtype 模式的更多内容，类型别名，never 类型和动态大小类型</strong></li>
<li><strong>高级函数和闭包：函数指针和返回闭包</strong></li>
<li><strong>宏：定义在编译时定义更多代码的方式</strong></li>
</ul> 
<h2>19.1 不安全Rust</h2> 
<p>目前为止讨论过的代码都有 Rust 在编译时会强制执行的内存安全保证。然而，Rust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：这被称为 <strong>不安全 Rust</strong>（<em>unsafe Rust</em>）。它与常规 Rust 代码无异，但是会提供额外的超级力量。</p> 
<p>不安全 Rust 之所以存在，是因为静态分析本质上是保守的。当编译器尝试确定一段代码是否支持某个保证时，拒绝一些有效的程序比接受无效程序要好一些。这必然意味着有时代码可能是合法的，但是 Rust 不这么认为！在这种情况下，可以使用不安全代码告诉编译器，“相信我，我知道我在干什么。”这么做的缺点就是你只能靠自己了：如果不安全代码出错了，比如解引用空指针，可能会导致不安全的内存使用。</p> 
<p>另一个 Rust 存在不安全一面的原因是：底层计算机硬件固有的不安全性。如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了。Rust 需要能够进行像直接与操作系统交互，甚至于编写你自己的操作系统这样的底层系统编程！这也是 Rust 语言的目标之一。让我们看看不安全 Rust 能做什么，和怎么做。</p> 
<h3>不安全的超级力量</h3> 
<p>可以通过 <code>unsafe</code> 关键字来切换到不安全 Rust，接着可以开启一个新的存放不安全代码的块。这里有四类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作，它们称之为 “不安全的超级力量。” 这些超级力量是：</p> 
<ul>
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
<li>访问 <code>union</code> 的字段</li>
</ul> 
<p>有一点很重要，<code>unsafe</code> 并不会关闭借用检查器或禁用任何其他 Rust 安全检查：如果在不安全代码中使用引用，它仍会被检查。<code>unsafe</code> 关键字只是提供了那四个不会被编译器检查内存安全的功能。你仍然能在不安全块中获得某种程度的安全。</p> 
<p>再者，<code>unsafe</code> 不意味着块中的代码就一定是危险的或者必然导致内存安全问题：其意图在于作为程序员你将会确保 <code>unsafe</code> 块中的代码以有效的方式访问内存。</p> 
<p>人是会犯错误的，错误总会发生，不过通过要求这四类操作必须位于标记为 <code>unsafe</code> 的块中，就能够知道任何与内存安全相关的错误必定位于 <code>unsafe</code> 块内。保持 <code>unsafe</code> 块尽可能小，如此当之后调查内存 bug 时就会感谢你自己了。</p> 
<p>为了尽可能隔离不安全代码，将不安全代码封装进一个安全的抽象并提供安全 API 是一个好主意，当我们学习不安全函数和方法时会讨论到。标准库的一部分被实现为在被评审过的不安全代码之上的安全抽象。这个技术防止了 <code>unsafe</code> 泄露到所有你或者用户希望使用由 <code>unsafe</code> 代码实现的功能的地方，因为使用其安全抽象是安全的。</p> 
<p>让我们按顺序依次介绍上述四个超级力量，同时我们会看到一些提供不安全代码的安全接口的抽象。</p> 
<h3>解引用裸指针</h3> 
<p>回到第四章的悬垂引用部分，那里提到了编译器会确保引用总是有效的。不安全 Rust 有两个被称为 <strong>裸指针</strong>（<em>raw pointers</em>）的类似于引用的新类型。和引用一样，裸指针是可变或不可变的，分别写作 <code>*const T</code> 和 <code>*mut T</code>。这里的星号不是解引用运算符；它是类型名称的一部分。在裸指针的上下文中，<strong>不可变</strong> 意味着指针解引用之后不能直接赋值。</p> 
<p>与引用和智能指针的区别在于，<span style="color:#fe2c24"><strong>记住裸指针</strong></span></p> 
<ul>
<li><span style="color:#fe2c24"><strong>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针</strong></span></li>
<li><span style="color:#fe2c24"><strong>不保证指向有效的内存</strong></span></li>
<li><span style="color:#fe2c24"><strong>允许为空</strong></span></li>
<li><span style="color:#fe2c24"><strong>不能实现任何自动清理功能</strong></span></li>
</ul> 
<p>通过去掉 Rust 强加的保证，你可以放弃安全保证以换取性能或使用另一个语言或硬件接口的能力，此时 Rust 的保证并不适用。</p> 
<pre><code class="language-rust">fn main() {
    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
}
</code></pre> 
<p>注意这里没有引入 <code>unsafe</code> 关键字。可以在安全代码中 <strong>创建</strong> 裸指针，只是不能在不安全块之外 <strong>解引用</strong> 裸指针，稍后便会看到。</p> 
<p>这里使用 <code>as</code> 将不可变和可变引用强转为对应的裸指针类型。因为直接从保证安全的引用来创建他们，可以知道这些特定的裸指针是有效，但是不能对任何裸指针做出如此假设。</p> 
<p>接下来会创建一个不能确定其有效性的裸指针，下面示例展示了如何创建一个指向任意内存地址的裸指针。尝试使用任意内存是未定义行为：此地址可能有数据也可能没有，编译器可能会优化掉这个内存访问，或者程序可能会出现段错误（segmentation fault）。通常没有好的理由编写这样的代码，不过却是可行的：</p> 
<pre><code class="language-rust">fn main() {
   
    let address = 0x012345usize;
    let r = address as *const i32;
}
</code></pre> 
<p>记得我们说过可以在安全代码中创建裸指针，不过不能 <strong>解引用</strong> 裸指针和读取其指向的数据。现在我们要做的就是对裸指针使用解引用运算符 <code>*</code>，这需要一个 <code>unsafe</code> 块</p> 
<pre><code class="language-rust">fn main() {
   
    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
    
    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
}
</code></pre> 
<p>创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值。</p> 
<p>还需注意上面示例中创建了同时指向相同内存位置 <code>num</code> 的裸指针 <code>*const i32</code> 和 <code>*mut i32</code>。相反如果尝试创建 <code>num</code> 的不可变和可变引用，这将无法编译因为 Rust 的所有权规则不允许拥有可变引用的同时拥有不可变引用。通过裸指针，就能够同时创建同一地址的可变指针和不可变指针，若通过可变指针修改数据，则可能潜在造成数据竞争。请多加小心！</p> 
<p>既然存在这么多的危险，为何还要使用裸指针呢？一个主要的应用场景便是调用 C 代码接口，这在下一部分 <a href="https://rust.bootcss.com/ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method" title="“调用不安全函数或方法”">“调用不安全函数或方法”</a> 中会讲到。另一个场景是构建借用检查器无法理解的安全抽象。让我们先介绍不安全函数，接着看一看使用不安全代码的安全抽象的例子。</p> 
<h3>调用不安全函数或方法</h3> 
<p>第二类要求使用不安全块的操作是调用不安全函数。不安全函数和方法与常规函数方法十分类似，除了其开头有一个额外的 <code>unsafe</code>。在此上下文中，关键字<code>unsafe</code>表示该函数具有调用时需要满足的要求，而 Rust 不会保证满足这些要求。通过在 <code>unsafe</code> 块中调用不安全函数，表明我们已经阅读过此函数的文档并对其是否满足函数自身的契约负责。</p> 
<p>如下是一个没有做任何操作的不安全函数 <code>dangerous</code> 的例子：</p> 
<pre><code class="language-rust">fn main() {
   
}

unsafe fn dangerous() {}

unsafe {
    dangerous();
}
</code></pre> 
<p>必须在一个单独的 <code>unsafe</code> 块中调用 <code>dangerous</code> 函数。如果尝试不使用 <code>unsafe</code> 块调用 <code>dangerous</code>，则会得到一个错误：</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/97/91/lQQnOD6s_o.png" width="1010"></p> 
<p>通过将 <code>dangerous</code> 调用插入 <code>unsafe</code> 块中，我们就向 Rust 保证了我们已经阅读过函数的文档，理解如何正确使用，并验证过其满足函数的契约。</p> 
<p>不安全函数体也是有效的 <code>unsafe</code> 块，所以在不安全函数中进行另一个不安全操作时无需新增额外的 <code>unsafe</code> 块。</p> 
<h3>创建不安全代码的安全抽象</h3> 
<p>仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全的。事实上，将不安全代码封装进安全函数是一个常见的抽象。作为一个例子，标准库中的函数，<code>split_at_mut</code>，它需要一些不安全代码，让我们探索如何可以实现它。这个安全函数定义于可变 slice 之上：它获取一个 slice 并从给定的索引参数开始将其分为两个 slice。</p> 
<pre><code class="language-rust">fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];
    
    let (a, b) = r.split_at_mut(3);
    
    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
}
</code></pre> 
<p>这个函数无法只通过安全 Rust 实现。一个尝试可能看起来像下面示例，它不能编译。出于简单考虑，我们将 <code>split_at_mut</code> 实现为函数而不是方法，并只处理 <code>i32</code> 值而非泛型 <code>T</code> 的 slice。</p> 
<pre><code class="language-rust">fn main() {

}

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre> 
<p>此函数首先获取 slice 的长度，然后通过检查参数是否小于或等于这个长度来断言参数所给定的索引位于 slice 当中。该断言意味着如果传入的索引比要分割的 slice 的索引更大，此函数在尝试使用这个索引前 panic。</p> 
<p>之后我们在一个元组中返回两个可变的 slice：一个从原始 slice 的开头直到 <code>mid</code> 索引，另一个从 <code>mid</code> 直到原 slice 的结尾。</p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/29/e0/9LFn1sCP_o.png" width="988"></p> 
<p>Rust 的借用检查器不能理解我们要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次。本质上借用 slice 的不同部分是可以的，因为结果两个 slice 不会重叠，不过 Rust 还没有智能到能够理解这些。当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了。</p> 
<p>下面示例展示了如何使用 <code>unsafe</code> 块，裸指针和一些不安全函数调用来实现 <code>split_at_mut</code>：</p> 
<pre><code class="language-rust">fn main() {

}

use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
</code></pre> 
<p>回忆第四章的 <a href="https://rust.bootcss.com/ch04-03-slices.html#the-slice-type" title="“Slice 类型” ">“Slice 类型” </a>部分，slice 是一个指向一些数据的指针，并带有该 slice 的长度。可以使用 <code>len</code> 方法获取 slice 的长度，使用 <code>as_mut_ptr</code> 方法访问 slice 的裸指针。在这个例子中，因为有一个 <code>i32</code> 值的可变 slice，<code>as_mut_ptr</code> 返回一个 <code>*mut i32</code> 类型的裸指针，储存在 <code>ptr</code> 变量中。</p> 
<p>我们保持索引 <code>mid</code> 位于 slice 中的断言。接着是不安全代码：<code>slice::from_raw_parts_mut</code> 函数获取一个裸指针和一个长度来创建一个 slice。这里使用此函数从 <code>ptr</code> 中创建了一个有 <code>mid</code> 个项的 slice。之后在 <code>ptr</code> 上调用 <code>offset</code> 方法并使用 <code>mid</code> 作为参数来获取一个从 <code>mid</code> 开始的裸指针，使用这个裸指针并以 <code>mid</code> 之后项的数量为长度创建一个 slice。</p> 
<p><code>slice::from_raw_parts_mut</code> 函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的。裸指针上的 <code>offset</code> 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针。因此必须将 <code>slice::from_raw_parts_mut</code> 和 <code>offset</code> 放入 <code>unsafe</code> 块中以便能调用它们。通过观察代码，和增加 <code>mid</code> 必然小于等于 <code>len</code> 的断言，我们可以说 <code>unsafe</code> 块中所有的裸指针将是有效的 slice 中数据的指针。这是一个可以接受的 <code>unsafe</code> 的恰当用法。</p> 
<p>注意无需将 <code>split_at_mut</code> 函数的结果标记为 <code>unsafe</code>，并可以在安全 Rust 中调用此函数。我们创建了一个不安全代码的安全抽象，其代码以一种安全的方式使用了 <code>unsafe</code> 代码，因为其只从这个函数访问的数据中创建了有效的指针。</p> 
<p>与此相对，下面示例中的 <code>slice::from_raw_parts_mut</code> 在使用 slice 时很有可能会崩溃。这段代码获取任意内存地址并创建了一个长为一万的 slice：</p> 
<pre><code class="language-rust">fn main() {

}

use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let slice: &amp;[i32] = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
</code></pre> 
<p>我们并不拥有这个任意地址的内存，也不能保证这段代码创建的 slice 包含有效的 <code>i32</code> 值。试图使用臆测为有效的 <code>slice</code> 会导致未定义的行为。</p> 
<h3>使用extern函数调用外部代码</h3> 
<p>有时你的 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字，<code>extern</code>，有助于创建和使用 <strong>外部函数接口</strong>（<em>Foreign Function Interface</em>， FFI）。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数。</p> 
<p>下面示例展示了如何集成 C 标准库中的 <code>abs</code> 函数。<code>extern</code> 块中声明的函数在 Rust 代码中总是不安全的。因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任：</p> 
<pre><code class="language-rust">extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
</code></pre> 
<p>在 <code>extern "C"</code> 块中，列出了我们希望能够调用的另一个语言中的外部函数的签名和名称。<code>"C"</code> 部分定义了外部函数所使用的 <strong>应用程序接口</strong>（<em>application binary interface</em>，ABI） —— ABI 定义了如何在汇编语言层面调用此函数。<code>"C"</code> ABI 是最常见的，并遵循 C 编程语言的 ABI。</p> 
<blockquote> 
 <p><strong>从其它语言调用Rust函数</strong></p> 
 <p></p> 
 <p>也可以使用 <code>extern</code> 来创建一个允许其他语言调用 Rust 函数的接口。不同于 <code>extern</code> 块，就在 <code>fn</code> 关键字之前增加 <code>extern</code> 关键字并指定所用到的 ABI。还需增加 <code>#[no_mangle]</code> 注解来告诉 Rust 编译器不要 mangle 此函数的名称。<em>Mangling</em> 发生于当编译器将我们指定的函数名修改为不同的名称时，这会增加用于其他编译过程的额外信息，不过会使其名称更难以阅读。每一个编程语言的编译器都会以稍微不同的方式 mangle 函数名，所以为了使 Rust 函数能在其他语言中指定，必须禁用 Rust 编译器的 name mangling。</p> 
 <p>在如下的例子中，一旦其编译为动态库并从 C 语言中链接，<code>call_from_c</code> 函数就能够在 C 代码中访问：</p> 
 <pre><code class="language-rust">#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
</code></pre> 
 <p><code>extern</code> 的使用无需 <code>unsafe</code>。</p> 
</blockquote> 
<h3>访问或修改可变静态变量</h3> 
<p>目前为止全书都尽量避免讨论 <strong>全局变量</strong>（<em>global variables</em>），Rust 确实支持他们，不过这对于 Rust 的所有权规则来说是有问题的。如果有两个线程访问相同的可变全局变量，则可能会造成数据竞争。</p> 
<p>全局变量在 Rust 中被称为 <strong>静态</strong>（<em>static</em>）变量。下面示例展示了一个拥有字符串 slice 值的静态变量的声明和应用：</p> 
<pre><code class="language-rust">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
</code></pre> 
<p><code>static</code> 变量类似于第三章部分讨论的常量。通常静态变量的名称采用 <code>SCREAMING_SNAKE_CASE</code> 写法，并 <strong>必须</strong> 标注变量的类型，在这个例子中是 <code>&amp;'static str</code>。静态变量只能储存拥有 <code>'static</code> 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。访问不可变静态变量是安全的。</p> 
<p>常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是静态变量中的值有一个固定的内存地址。使用这个值总是会访问相同的地址。另一方面，常量则允许在任何被用到的时候复制其数据。</p> 
<p>常量与静态变量的另一个区别在于静态变量可以是可变的。访问和修改可变静态变量都是 <strong>不安全</strong> 的。下面示例展示了如何声明、访问和修改名为 <code>COUNTER</code> 的可变静态变量：</p> 
<pre><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
</code></pre> 
<p>就像常规变量一样，我们使用 <code>mut</code> 关键来指定可变性。任何读写 <code>COUNTER</code> 的代码都必须位于 <code>unsafe</code> 块中。这段代码可以编译并如期打印出 <code>COUNTER: 3</code>，因为这是单线程的。拥有多个线程访问 <code>COUNTER</code> 则可能导致数据竞争。</p> 
<p>拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。任何可能的情况，请优先使用第十六章讨论的并发技术和线程安全智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的。</p> 
<h3>实现不安全trait</h3> 
<p>最后一个只能用在 <code>unsafe</code> 中的操作是实现不安全 trait。当至少有一个方法中包含编译器不能验证的不变量时 trait 是不安全的。可以在 <code>trait</code> 之前增加 <code>unsafe</code> 关键字将 trait 声明为 <code>unsafe</code>，同时 trait 的实现也必须标记为 <code>unsafe</code></p> 
<pre><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
</code></pre> 
<p>通过 <code>unsafe impl</code>，我们承诺将保证编译器所不能验证的不变量。</p> 
<p>作为一个例子，回忆第十六章部分中的 <code>Sync</code> 和 <code>Send</code> 标记 trait，编译器会自动为完全由 <code>Send</code> 和 <code>Sync</code> 类型组成的类型自动实现他们。如果实现了一个包含一些不是 <code>Send</code> 或 <code>Sync</code> 的类型，比如裸指针，并希望将此类型标记为 <code>Send</code> 或 <code>Sync</code>，则必须使用 <code>unsafe</code>。Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程键访问，所以需要我们自己进行检查并通过 <code>unsafe</code> 表明。</p> 
<h3>何时使用不安全代码</h3> 
<p>使用 <code>unsafe</code> 来进行这四个操作（超级力量）之一是没有问题的，甚至是不需要深思熟虑的，不过使得 <code>unsafe</code> 代码正确也实属不易，因为编译器不能帮助保证内存安全。当有理由使用 <code>unsafe</code> 代码时，是可以这么做的，通过使用显式的 <code>unsafe</code> 标注使得在出现错误时易于追踪问题的源头。</p> 
<h2>19.2 高级trait</h2> 
<p>第十章部分，我们第一次涉及到了 trait，不过就像生命周期一样，我们并没有覆盖一些较为高级的细节。现在我们更加了解 Rust 了，可以深入理解其本质了。</p> 
<h3>关联类型在trait定义中指定占位符类型</h3> 
<p><strong>关联类型</strong>（<em>associated types</em>）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。trait 的实现者会针对特定的实现在这个类型的位置指定相应的具体类型。如此可以定义一个使用多种类型的 trait，直到实现此 trait 时都无需知道这些类型具体是什么。</p> 
<p>本章所描述的大部分内容都非常少见。关联类型则比较适中；它们比本书其他的内容要少见，不过比本章中的很多内容要更常见。</p> 
<p>一个带有关联类型的 trait 的例子是标准库提供的 <code>Iterator</code> trait。它有一个叫做 <code>Item</code> 的关联类型来替代遍历的值的类型。第十三章的 <a href="https://rust.bootcss.com/ch13-02-iterators.html#the-iterator-trait-and-the-next-method" title="“Iterator trait 和 next 方法”">“Iterator trait 和 next 方法”</a> 部分曾提到过 <code>Iterator</code> trait 的定义如下面示例所示：</p> 
<pre><code class="language-rust">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre> 
<p><code>Item</code> 是一个占位类型，同时 <code>next</code> 方法定义表明它返回 <code>Option&lt;Self::Item&gt;</code> 类型的值。这个 trait 的实现者会指定 <code>Item</code> 的具体类型，然而不管实现者指定何种类型, <code>next</code> 方法都会返回一个包含了此具体类型值的 <code>Option</code>。</p> 
<p>关联类型看起来像一个类似泛型的概念，因为它允许定义一个函数而不指定其可以处理的类型。那么为什么要使用关联类型呢？</p> 
<p>让我们通过一个在第十三章中出现的 <code>Counter</code> 结构体上实现 <code>Iterator</code> trait 的例子来检视其中的区别。</p> 
<pre><code class="language-rust">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--</code></pre> 
<p>区别在于当如前面示例那样使用泛型时，则不得不在每一个实现中标注类型。这是因为我们也可以实现为 <code>Iterator&lt;String&gt; for Counter</code>，或任何其他类型，这样就可以有多个 <code>Counter</code> 的 <code>Iterator</code> 的实现。换句话说，当 trait 有泛型参数时，可以多次实现这个 trait，每次需改变泛型参数的具体类型。接着当使用 <code>Counter</code> 的 <code>next</code> 方法时，必须提供类型注解来表明希望使用 <code>Iterator</code> 的哪一个实现。</p> 
<p>通过关联类型，则无需标注类型因为不能多次实现这个 trait。对于示例使用关联类型的定义，我们只能选择一次 <code>Item</code> 会是什么类型，因为只能有一个 <code>impl Iterator for Counter</code>。当调用 <code>Counter</code> 的 <code>next</code> 时不必每次指定我们需要 <code>u32</code> 值的迭代器。</p> 
<h3>默认泛型类型参数和运算符重载</h3> 
<p>当使用泛型类型参数时，可以为泛型指定一个默认的具体类型。如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要。为泛型类型指定默认类型的语法是在声明泛型类型时使用 <code>&lt;PlaceholderType=ConcreteType&gt;</code>。</p> 
<p>这种情况的一个非常好的例子是用于运算符重载。<strong>运算符重载</strong>（<em>Operator overloading</em>）是指在特定情况下自定义运算符（比如 <code>+</code>）行为的操作。</p> 
<p>Rust 并不允许创建自定义运算符或重载任意运算符，不过 <code>std::ops</code> 中所列出的运算符和相应的 trait 可以通过实现运算符相关 trait 来重载。</p> 
<pre><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre> 
<p><code>add</code> 方法将两个 <code>Point</code> 实例的 <code>x</code> 值和 <code>y</code> 值分别相加来创建一个新的 <code>Point</code>。<code>Add</code> trait 有一个叫做 <code>Output</code> 的关联类型，它用来决定 <code>add</code> 方法的返回值类型。</p> 
<p>这里默认泛型类型位于 <code>Add</code> trait 中。这里是其定义：</p> 
<pre><code class="language-rust">trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
</code></pre> 
<p>这看来应该很熟悉，这是一个带有一个方法和一个关联类型的 trait。比较陌生的部分是尖括号中的 <code>RHS=Self</code>：这个语法叫做 <strong>默认类型参数</strong>（<em>default type parameters</em>）。<code>RHS</code> 是一个泛型类型参数（“right hand side” 的缩写），它用于定义 <code>add</code> 方法中的 <code>rhs</code> 参数。如果实现 <code>Add</code> trait 时不指定 <code>RHS</code> 的具体类型，<code>RHS</code> 的类型将是默认的 <code>Self</code> 类型，也就是在其上实现 <code>Add</code> 的类型。</p> 
<p>当为 <code>Point</code> 实现 <code>Add</code> 时，使用了默认的 <code>RHS</code>，因为我们希望将两个 <code>Point</code> 实例相加。让我们看看一个实现 <code>Add</code> trait 时希望自定义 <code>RHS</code> 类型而不是使用默认类型的例子</p> 
<p>这里有两个存放不同单元值的结构体，<code>Millimeters</code> 和 <code>Meters</code>。我们希望能够将毫米值与米值相加，并让 <code>Add</code> 的实现正确处理转换。可以为 <code>Millimeters</code> 实现 <code>Add</code> 并以 <code>Meters</code> 作为 <code>RHS</code>，如下面示例所示。</p> 
<pre><code class="language-rust">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}

fn main() {
    
}</code></pre> 
<p>为了使 <code>Millimeters</code> 和 <code>Meters</code> 能够相加，我们指定 <code>impl Add&lt;Meters&gt;</code> 来设定 <code>RHS</code> 类型参数的值而不是使用默认的 <code>Self</code>。</p> 
<p>默认参数类型主要用于如下两个方面：</p> 
<ul>
<li>扩展类型而不破坏现有代码。</li>
<li>在大部分用户都不需要的特定情况进行自定义。</li>
</ul> 
<p>标准库的 <code>Add</code> trait 就是一个第二个目的例子：大部分时候你会将两个相似的类型相加，不过它提供了自定义额外行为的能力。在 <code>Add</code> trait 定义中使用默认类型参数意味着大部分时候无需指定额外的参数。换句话说，一小部分实现的样板代码是不必要的，这样使用 trait 就更容易了。</p> 
<p>第一个目的是相似的，但过程是反过来的：如果需要为现有 trait 增加类型参数，为其提供一个默认类型将允许我们在不破坏现有实现代码的基础上扩展 trait 的功能。</p> 
<h3>完全限定语法与消歧义:调用相同名称的方法</h3> 
<p>Rust 既不能避免一个 trait 与另一个 trait 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 trait。甚至直接在类型上实现开始已经有的同名方法也是可能的！</p> 
<p>不过，当调用这些同名方法时，需要告诉 Rust 我们希望使用哪一个。考虑一下下面示例中的代码，这里定义了 trait <code>Pilot</code> 和 <code>Wizard</code> 都拥有方法 <code>fly</code>。接着在一个本身已经实现了名为 <code>fly</code> 方法的类型 <code>Human</code> 上实现这两个 trait。每一个 <code>fly</code> 方法都进行了不同的操作：</p> 
<pre><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*waving arms furiously*");
    }
}
</code></pre> 
<p>当调用 <code>Human</code> 实例的 <code>fly</code> 时，编译器默认调用直接是现在类型上的方法</p> 
<pre><code class="language-rust">fn main() {
    let person = Human;
    person.fly();
}
</code></pre> 
<p>运行这段代码会打印出 <code>*waving arms furiously*</code>，这表明 Rust 调用了直接实现在 <code>Human</code> 上的 <code>fly</code> 方法。</p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/7c/d0/B053Tw7M_o.png" width="793"></p> 
<p>为了能够调用 <code>Pilot</code> trait 或 <code>Wizard</code> trait 的 <code>fly</code> 方法，我们需要使用更明显的语法以便能指定我们指的是哪个 <code>fly</code> 方法。</p> 
<pre><code class="language-rust">fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre> 
<p>在方法名前指定 trait 名向 Rust 澄清了我们希望调用哪个 <code>fly</code> 实现。也可以选择写成 <code>Human::fly(&amp;person)</code>，这等同于示例中的 <code>person.fly()</code>，不过如果无需消歧义的话这么写就有点长了。</p> 
<p>运行这段代码会打印出：</p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/9e/8d/QDzu46uP_o.png" width="945"></p> 
<p>因为 <code>fly</code> 方法获取一个 <code>self</code> 参数，如果有两个 <strong>类型</strong> 都实现了同一 <strong>trait</strong>，Rust 可以根据 <code>self</code> 的类型计算出应该使用哪一个 trait 实现。</p> 
<p>然而，关联函数是 trait 的一部分，但没有 <code>self</code> 参数。当同一作用域的两个类型实现了同一 trait，Rust 就不能计算出我们期望的是哪一个类型，除非使用 <strong>完全限定语法</strong>（<em>fully qualified syntax</em>）。例如，拿下面示例的 <code>Animal</code> trait 来说，它有关联函数 <code>baby_name</code>，结构体 <code>Dog</code> 实现了 <code>Animal</code>，同时有关联函数 <code>baby_name</code> 直接定义于 <code>Dog</code> 之上：</p> 
<pre><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}
</code></pre> 
<p>这段代码用于一个动物收容所，他们将所有的小狗起名为 Spot，这实现为定义于 <code>Dog</code> 之上的关联函数 <code>baby_name</code>。<code>Dog</code> 类型还实现了 <code>Animal</code> trait，它描述了所有动物的共有的特征。小狗被称为 puppy，这表现为 <code>Dog</code> 的 <code>Animal</code> trait 实现中与 <code>Animal</code> trait 相关联的函数 <code>baby_name</code>。</p> 
<p>在 <code>main</code> 调用了 <code>Dog::baby_name</code> 函数，它直接调用了定义于 <code>Dog</code> 之上的关联函数。这段代码会打印出：</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/4b/11/Dbs23Abt_o.png" width="1011"></p> 
<p>这并不是我们需要的。我们希望调用的是 <code>Dog</code> 上 <code>Animal</code> trait 实现那部分的 <code>baby_name</code> 函数，这样能够打印出 <code>A baby dog is called a puppy</code>。示例 19-18 中用到的技术在这并不管用；如果将 <code>main</code> 改为下面示例中的代码，则会得到一个编译错误：</p> 
<pre><code class="language-rust">fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}
</code></pre> 
<p>因为 <code>Animal::baby_name</code> 是关联函数而不是方法，因此它没有 <code>self</code> 参数，Rust 无法计算出所需的是哪一个 <code>Animal::baby_name</code> 实现。我们会得到这个编译错误：</p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/ae/44/Luu8yLWa_o.png" width="980"></p> 
<p>为了消歧义并告诉 Rust 我们希望使用的是 <code>Dog</code> 的 <code>Animal</code> 实现，需要使用 <strong>完全限定语法</strong>，这是调用函数时最为明确的方式。</p> 
<pre><code class="language-rust">fn main() {
    println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
}
</code></pre> 
<p>我们在尖括号中向 Rust 提供了类型注解，并通过在此函数调用中将 <code>Dog</code> 类型当作 <code>Animal</code> 对待，来指定希望调用的是 <code>Dog</code> 上 <code>Animal</code> trait 实现中的 <code>baby_name</code> 函数。现在这段代码会打印出我们期望的数据：</p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/9b/6a/ZYdx2M4d_o.png" width="896"></p> 
<p>通常，完全限定语法定义为：</p> 
<pre><code class="language-rust">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre> 
<p>对于关联函数，其没有一个 <code>receiver</code>，故只会有其他参数的列表。可以选择在任何函数或方法调用处使用完全限定语法。然而，允许省略任何 Rust 能够从程序中的其他信息中计算出的部分。只有当存在多个同名实现而 Rust 需要帮助以便知道我们希望调用哪个实现时，才需要使用这个较为冗长的语法。</p> 
<h3>父trait用于在另一个trait中使用某trait的功能</h3> 
<p>有时我们可能会需要某个 trait 使用另一个 trait 的功能。在这种情况下，需要能够依赖相关的 trait 也被实现。这个所需的 trait 是我们实现的 trait 的 <strong>父（超） trait</strong>（<em>supertrait</em>）。</p> 
<p>例如我们希望创建一个带有 <code>outline_print</code> 方法的 trait <code>OutlinePrint</code>，它会打印出带有星号框的值。也就是说，如果 <code>Point</code> 实现了 <code>Display</code> 并返回 <code>(x, y)</code>，调用以 <code>1</code> 作为 <code>x</code> 和 <code>3</code> 作为 <code>y</code> 的 <code>Point</code> 实例的 <code>outline_print</code> 会显示如下：</p> 
<pre><code class="language-rust">**********
*        *
* (1, 3) *
*        *
**********
</code></pre> 
<p>在 <code>outline_print</code> 的实现中，因为希望能够使用 <code>Display</code> trait 的功能，则需要说明 <code>OutlinePrint</code> 只能用于同时也实现了 <code>Display</code> 并提供了 <code>OutlinePrint</code> 需要的功能的类型。可以通过在 trait 定义中指定 <code>OutlinePrint: Display</code> 来做到这一点。这类似于为 trait 增加 trait bound。下面示例展示了一个 <code>OutlinePrint</code> trait 的实现：</p> 
<pre><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

fn main() {
    
}
</code></pre> 
<p>因为指定了 <code>OutlinePrint</code> 需要 <code>Display</code> trait，则可以在 <code>outline_print</code> 中使用 <code>to_string</code>， 其会为任何实现 <code>Display</code> 的类型自动实现。如果不在 trait 名后增加 <code>: Display</code> 并尝试在 <code>outline_print</code> 中使用 <code>to_string</code>，则会得到一个错误说在当前作用域中没有找到用于 <code>&amp;Self</code> 类型的方法 <code>to_string</code>。</p> 
<p>让我们看看如果尝试在一个没有实现 <code>Display</code> 的类型上实现 <code>OutlinePrint</code> 会发生什么，比如 <code>Point</code> 结构体：</p> 
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}</code></pre> 
<p>这样会得到一个错误说 <code>Display</code> 是必须的而未被实现：</p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/3d/c5/OWjEZNX5_o.png" width="1099"></p> 
<p>一旦在 <code>Point</code> 上实现 <code>Display</code> 并满足 <code>OutlinePrint</code> 要求的限制，比如这样：</p> 
<pre><code class="language-rust">use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
</code></pre> 
<p>那么在 <code>Point</code> 上实现 <code>OutlinePrint</code> trait 将能成功编译，并可以在 <code>Point</code> 实例上调用 <code>outline_print</code> 来显示位于星号框中的点的值。</p> 
<h3>newtype模式用以在外部类型上实现外部 trait</h3> 
<p>在第十章的 <a href="https://rust.bootcss.com/ch10-02-traits.html#implementing-a-trait-on-a-type" title="“为类型实现 trait”">“为类型实现 trait”</a> 部分，我们提到了孤儿规则（orphan rule），它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait。一个绕开这个限制的方法是使用 <strong>newtype 模式</strong>（<em>newtype pattern</em>），它涉及到在一个元组结构体（第五章 <a href="https://rust.bootcss.com/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types" title="“用没有命名字段的元组结构体来创建不同的类型”">“用没有命名字段的元组结构体来创建不同的类型”</a> 部分介绍了元组结构体）中创建一个新类型。这个元组结构体带有一个字段作为希望实现 trait 的类型的简单封装。接着这个封装类型对于 crate 是本地的，这样就可以在这个封装上实现 trait。<em>Newtype</em> 是一个源自（U.C.0079，逃）Haskell 编程语言的概念。使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了。</p> 
<p>例如，如果想要在 <code>Vec&lt;T&gt;</code> 上实现 <code>Display</code>，而孤儿规则阻止我们直接这么做，因为 <code>Display</code> trait 和 <code>Vec&lt;T&gt;</code> 都定义于我们的 crate 之外。可以创建一个包含 <code>Vec&lt;T&gt;</code> 实例的 <code>Wrapper</code> 结构体，接着可以如列表那样在 <code>Wrapper</code> 上实现 <code>Display</code> 并使用 <code>Vec&lt;T&gt;</code> 的值：</p> 
<pre><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
</code></pre> 
<p><code>Display</code> 的实现使用 <code>self.0</code> 来访问其内部的 <code>Vec&lt;T&gt;</code>，因为 <code>Wrapper</code> 是元组结构体而 <code>Vec&lt;T&gt;</code> 是结构体总位于索引 0 的项。接着就可以使用 <code>Wrapper</code> 中 <code>Display</code> 的功能了。</p> 
<p>此方法的缺点是，因为 <code>Wrapper</code> 是一个新类型，它没有定义于其值之上的方法；必须直接在 <code>Wrapper</code> 上实现 <code>Vec&lt;T&gt;</code> 的所有方法，这样就可以代理到<code>self.0</code> 上 —— 这就允许我们完全像 <code>Vec&lt;T&gt;</code> 那样对待 <code>Wrapper</code>。如果希望新类型拥有其内部类型的每一个方法，为封装类型实现 <code>Deref</code> trait（第十五章 <a href="https://rust.bootcss.com/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait" title="“通过 Deref trait 将智能指针当作常规引用处理”">“通过 Deref trait 将智能指针当作常规引用处理”</a> 部分讨论过）并返回其内部类型是一种解决方案。如果不希望封装类型拥有所有内部类型的方法 —— 比如为了限制封装类型的行为 —— 则必须只自行实现所需的方法。</p> 
<h2>19.3 高级类型</h2> 
<p>Rust 的类型系统有一些我们曾经提到但没有讨论过的功能。首先我们从一个关于为什么 newtype 与类型一样有用的更宽泛的讨论开始。接着会转向类型别名（type aliases），一个类似于 newtype 但有着稍微不同的语义的功能。我们还会讨论 <code>!</code> 类型和动态大小类型。</p> 
<h3>为了类型安全和抽象而使用newtype模式</h3> 
<p>newtype 模式可以用于一些其他我们还未讨论的功能，包括静态的确保某值不被混淆，和用来表示一个值的单元。</p> 
<p>另一个 newtype 模式的应用在于抽象掉一些类型的实现细节：例如，封装类型可以暴露出与直接使用其内部私有类型时所不同的公有 API，以便限制其功能。</p> 
<p>newtype 也可以隐藏其内部的泛型类型。例如，可以提供一个封装了 <code>HashMap&lt;i32, String&gt;</code> 的 <code>People</code> 类型，用来储存人名以及相应的 ID。使用 <code>People</code> 的代码只需与提供的公有 API 交互即可，比如向 <code>People</code> 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 <code>i32</code> ID 赋予了这个名字了。newtype 模式是一种实现第十七章部分所讨论的隐藏实现细节的封装的轻量级方法。</p> 
<h3>类型别名用来创建类型同义词</h3> 
<p>连同 newtype 模式，Rust 还提供了声明 <strong>类型别名</strong>（<em>type alias</em>）的能力，使用 <code>type</code> 关键字来给予现有类型另一个名字。例如，可以像这样创建 <code>i32</code> 的别名 <code>Kilometers</code>：</p> 
<pre><code class="language-rust">type Kilometers = i32;
</code></pre> 
<p>这意味着 <code>Kilometers</code> 是 <code>i32</code> 的 <strong>同义词</strong>（<em>synonym</em>）；</p> 
<pre><code class="language-rust">type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!("x + y = {}", x + y);
</code></pre> 
<p>因为 <code>Kilometers</code> 是 <code>i32</code> 的别名，他们是同一类型，可以将 <code>i32</code> 与 <code>Kilometers</code> 相加，也可以将 <code>Kilometers</code> 传递给获取 <code>i32</code> 参数的函数。但通过这种手段无法获得上一部分讨论的 newtype 模式所提供的类型检查的好处。</p> 
<p>类型别名的主要用途是减少重复。例如，可能会有这样很长的类型：</p> 
<pre><code class="language-rust">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre> 
<p>在函数签名或类型注解中每次都书写这个类型将是枯燥且易于出错的。想象一下如下面示例这样全是如此代码的项目：</p> 
<pre><code class="language-rust">let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));

fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
    // --snip--
}
</code></pre> 
<p>类型别名通过减少项目中重复代码的数量来使其更加易于控制。这里我们为这个冗长的类型引入了一个叫做 <code>Thunk</code> 的别名，这样就可以如下面示例所示将所有使用这个类型的地方替换为更短的 <code>Thunk</code>：</p> 
<pre><code class="language-rust">type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!("hi"));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
}
</code></pre> 
<p>这样就读写起来就容易多了！为类型别名选择一个好名字也可以帮助你表达意图（单词 <em>thunk</em> 表示会在之后被计算的代码，所以这是一个存放闭包的合适的名字）。</p> 
<p>类型别名也经常与 <code>Result&lt;T, E&gt;</code> 结合使用来减少重复。考虑一下标准库中的 <code>std::io</code> 模块。I/O 操作通常会返回一个 <code>Result&lt;T, E&gt;</code>，因为这些操作可能会失败。标准库中的 <code>std::io::Error</code> 结构体代表了所有可能的 I/O 错误。<code>std::io</code> 中大部分函数会返回 <code>Result&lt;T, E&gt;</code>，其中 <code>E</code> 是 <code>std::io::Error</code>，比如 <code>Write</code> trait 中的这些函数：</p> 
<pre><code class="language-rust">use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
</code></pre> 
<p>这里出现了很多的 <code>Result&lt;..., Error&gt;</code>。为此，<code>std::io</code> 有这个类型别名声明：</p> 
<pre><code class="language-rust">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</code></pre> 
<p>因为这位于 <code>std::io</code> 中，可用的完全限定的别名是 <code>std::io::Result&lt;T&gt;</code> —— 也就是说，<code>Result&lt;T, E&gt;</code> 中 <code>E</code> 放入了 <code>std::io::Error</code>。<code>Write</code> trait 中的函数最终看起来像这样：</p> 
<pre><code class="language-rust">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre> 
<p>类型别名在两个方面有帮助：易于编写 <strong>并</strong> 在整个 <code>std::io</code> 中提供了一致的接口。因为这是一个别名，它只是另一个 <code>Result&lt;T, E&gt;</code>，这意味着可以在其上使用 <code>Result&lt;T, E&gt;</code> 的任何方法，以及像 <code>?</code> 这样的特殊语法。</p> 
<h3>从不返回的never type</h3> 
<p>Rust 有一个叫做 <code>!</code> 的特殊类型。在类型理论术语中，它被称为 <em>empty type</em>，因为它没有值。我们更倾向于称之为 <em>never type</em>。这个名字描述了它的作用：在函数从不返回的时候充当返回值。例如：</p> 
<pre><code class="language-rust">fn bar() -&gt; ! {
    // --snip--
}
</code></pre> 
<p>这读 “函数 <code>bar</code> 从不返回”，而从不返回的函数被称为 <strong>发散函数</strong>（<em>diverging functions</em>）。不能创建 <code>!</code> 类型的值，所以 <code>bar</code> 也不可能返回值。</p> 
<pre><code class="language-rust">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre> 
<p>当时我们忽略了代码中的一些细节。在第六章部分，我们学习了 <code>match</code> 的分支必须返回相同的类型。如下代码不能工作：</p> 
<pre><code class="language-rust">let guess = match guess.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; "hello",
}
</code></pre> 
<p>这里的 <code>guess</code> 必须既是整型 <strong>也是</strong> 字符串，而 Rust 要求 <code>guess</code> 只能是一个类型。</p> 
<p>描述 <code>!</code> 的行为的正式方式是 never type 可以强转为任何其他类型。允许 <code>match</code> 的分支以 <code>continue</code> 结束是因为 <code>continue</code> 并不真正返回一个值；相反它把控制权交回上层循环，所以在 <code>Err</code> 的情况，事实上并未对 <code>guess</code> 赋值。</p> 
<p>never type 的另一个用途是 <code>panic!</code>。还记得 <code>Option&lt;T&gt;</code> 上的 <code>unwrap</code> 函数吗？它产生一个值或 panic。这里是它的定义：</p> 
<pre><code class="language-rust">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
</code></pre> 
<p>Rust 知道 <code>val</code> 是 <code>T</code> 类型，<code>panic!</code> 是 <code>!</code> 类型，所以整个 <code>match</code> 表达式的结果是 <code>T</code> 类型。这能工作是因为 <code>panic!</code> 并不产生一个值；它会终止程序。对于 <code>None</code> 的情况，<code>unwrap</code> 并不返回一个值，所以这些代码是有效。</p> 
<p>最后一个有着 <code>!</code> 类型的表达式是 <code>loop</code>：</p> 
<pre><code class="language-rust">print!("forever ");

loop {
    print!("and ever ");
}
</code></pre> 
<p>这里，循环永远也不结束，所以此表达式的值是 <code>!</code>。但是如果引入 <code>break</code> 这就不为真了，因为循环在执行到 <code>break</code> 后就会终止。</p> 
<h3>动态大小类型和sized trait</h3> 
<p>因为 Rust 需要知道例如应该为特定类型的值分配多少空间这样的信息其类型系统的一个特定的角落可能令人迷惑：这就是 <strong>动态大小类型</strong>（<em>dynamically sized types</em>）的概念。这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。</p> 
<p>让我们深入研究一个贯穿本书都在使用的动态大小类型的细节：<code>str</code>。没错，不是 <code>&amp;str</code>，而是 <code>str</code> 本身。<code>str</code> 是一个 DST；直到运行时我们都不知道字符串有多长。因为直到运行时都不能知道大其小，也就意味着不能创建 <code>str</code> 类型的变量，也不能获取 <code>str</code> 类型的参数。考虑一下这些代码，他们不能工作：</p> 
<pre><code class="language-rust">let s1: str = "Hello there!";
let s2: str = "How's it going?";
</code></pre> 
<p>Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存。如果允许编写这样的代码，也就意味着这两个 <code>str</code> 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。</p> 
<p>那么该怎么办呢？你已经知道了这种问题的答案：<code>s1</code> 和 <code>s2</code> 的类型是 <code>&amp;str</code> 而不是 <code>str</code>。如果你回想第四章 <a href="https://rust.bootcss.com/ch04-03-slices.html#string-slices" title="“字符串 slice”">“字符串 slice”</a> 部分，slice 数据结储存了开始位置和 slice 的长度。</p> 
<p>所以虽然 <code>&amp;T</code> 是一个储存了 <code>T</code> 所在的内存位置的单个值，<code>&amp;str</code> 则是 <strong>两个</strong> 值：<code>str</code> 的地址和其长度。这样，<code>&amp;str</code> 就有了一个在编译时可以知道的大小：它是 <code>usize</code> 长度的两倍。也就是说，我们总是知道 <code>&amp;str</code> 的大小，而无论其引用的字符串是多长。这里是 Rust 中动态大小类型的常规用法：他们有一些额外的元信息来储存动态信息的大小。这引出了动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。</p> 
<p>可以将 <code>str</code> 与所有类型的指针结合：比如 <code>Box&lt;str&gt;</code> 或 <code>Rc&lt;str&gt;</code>。事实上，之前我们已经见过了，不过是另一个动态大小类型：trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。在第十七章 <a href="https://rust.bootcss.com/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types" title="“为使用不同类型的值而设计的 trait 对象”">“为使用不同类型的值而设计的 trait 对象”</a> 部分，我们提到了为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 <code>&amp;Trait</code> 或 <code>Box&lt;Trait&gt;</code>（<code>Rc&lt;Trait&gt;</code> 也可以）。</p> 
<p>为了处理 DST，Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知：这就是 <code>Sized</code> trait。这个 trait 自动为编译器在编译时就知道大小的类型实现。另外，Rust 隐式的为每一个泛型函数增加了 <code>Sized</code> bound。也就是说，对于如下泛型函数定义：</p> 
<pre><code class="language-rust">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre> 
<p>实际上被当作如下处理：</p> 
<pre><code class="language-rust">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre> 
<p>泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制：</p> 
<pre><code class="language-rust">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre> 
<p><code>?Sized</code> trait bound 与 <code>Sized</code> 相对；也就是说，它可以读作 “<code>T</code> 可能是也可能不是 <code>Sized</code> 的”。这个语法只能用于 <code>Sized</code> ，而不能用于其他 trait。</p> 
<p>另外注意我们将 <code>t</code> 参数的类型从 <code>T</code> 变为了 <code>&amp;T</code>：因为其类型可能不是 <code>Sized</code> 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。</p> 
<h2>19.4 高级函数与闭包</h2> 
<p>最后我们将探索一些有关函数和闭包的高级功能：函数指针以及返回值闭包。</p> 
<h3>函数指针</h3> 
<p>我们讨论过了如何向函数传递闭包；也可以向函数传递常规函数！这在我们希望传递已经定义的函数而不是重新定义闭包作为参数是很有用。通过函数指针允许我们使用函数作为另一个函数的参数。函数的类型是 <code>fn</code> （使用小写的 “f” ）以免与 <code>Fn</code> 闭包 trait 相混淆。<code>fn</code> 被称为 <strong>函数指针</strong>（<em>function pointer</em>）。指定参数为函数指针的语法类似于闭包。</p> 
<pre><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}
</code></pre> 
<p>这会打印出 <code>The answer is: 12</code>。<code>do_twice</code> 中的 <code>f</code> 被指定为一个接受一个 <code>i32</code> 参数并返回 <code>i32</code> 的 <code>fn</code>。接着就可以在 <code>do_twice</code> 函数体中调用 <code>f</code>。在 <code>main</code> 中，可以将函数名 <code>add_one</code> 作为第一个参数传递给 <code>do_twice</code>。</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/6a/57/3oTmm050_o.png" width="936"></p> 
<p>不同于闭包，<code>fn</code> 是一个类型而不是一个 trait，所以直接指定 <code>fn</code> 作为参数而不是声明一个带有 <code>Fn</code> 作为 trait bound 的泛型参数。</p> 
<p>函数指针实现了所有三个闭包 trait（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>），所以总是可以在调用期望闭包的函数时传递函数指针作为参数。倾向于编写使用泛型和闭包 trait 的函数，这样它就能接受函数或闭包作为参数。</p> 
<p>一个只期望接受 <code>fn</code> 而不接受闭包的情况的例子是与不存在闭包的外部代码交互时：C 语言的函数可以接受函数作为参数，但 C 语言没有闭包。</p> 
<p>作为一个既可以使用内联定义的闭包又可以使用命名函数的例子，让我们看看一个 <code>map</code> 的应用。使用 <code>map</code> 函数将一个数字 vector 转换为一个字符串 vector，就可以使用闭包，比如这样：</p> 
<pre><code class="language-rust">let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();</code></pre> 
<p>或者可以将函数作为 <code>map</code> 的参数来代替闭包，像是这样：</p> 
<pre><code class="language-rust">let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();</code></pre> 
<p>注意这里必须使用 <a href="https://rust.bootcss.com/ch19-03-advanced-traits.html#advanced-traits" title="“高级 trait”">“高级 trait”</a> 部分讲到的完全限定语法，因为存在多个叫做 <code>to_string</code> 的函数；这里使用了定义于 <code>ToString</code> trait 的 <code>to_string</code> 函数，标准库为所有实现了 <code>Display</code> 的类型实现了这个 trait。</p> 
<p>另一个实用的模式暴露了元组结构体和元组结构体枚举成员的实现细节。这些项使用 <code>()</code> 作为初始化语法，这看起来就像函数调用，同时它们确实被实现为返回由参数构造的实例的函数。它们也被称为实现了闭包 trait 的函数指针，并可以采用类似如下的方式调用：</p> 
<pre><code class="language-rust">enum Status {
    Value(u32),
    Stop,
}

let list_of_statuses: Vec&lt;Status&gt; =
    (0u32..20)
    .map(Status::Value)
    .collect();</code></pre> 
<p>这里创建了 <code>Status::Value</code> 实例，它通过 <code>map</code> 用范围的每一个 <code>u32</code> 值调用 <code>Status::Value</code> 的初始化函数。一些人倾向于函数风格，一些人喜欢闭包。这两种形式最终都会产生同样的代码，所以请使用对你来说更明白的形式吧。</p> 
<h3>返回|闭包</h3> 
<p>闭包表现为 trait，这意味着不能直接返回闭包。对于大部分需要返回 trait 的情况，可以使用实现了期望返回的 trait 的具体类型来替代函数的返回值。但是这不能用于闭包，因为他们没有一个可返回的具体类型；例如不允许使用函数指针 <code>fn</code> 作为返回值类型。</p> 
<p>这段代码尝试直接返回闭包，它并不能编译：</p> 
<pre><code class="language-rust">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}</code></pre> 
<p>编译器给出的错误是：</p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/bf/5e/rbeIILgb_o.png" width="965"></p> 
<p> 错误又一次指向了 <code>Sized</code> trait！Rust 并不知道需要多少空间来储存闭包。不过我们在上一部分见过这种情况的解决办法：可以使用 trait 对象：</p> 
<pre><code class="language-rust">fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}</code></pre> 
<p>这段代码正好可以编译。关于 trait 对象的更多内容，请回顾第十七章。</p> 
<h2>19.5 宏</h2> 
<p>我们已经在本书中使用过像 <code>println!</code> 这样的宏了，不过还没完全探索什么是宏以及它是如何工作的。<strong>宏</strong>（<em>Macro</em>）指的是 Rust 中一系列的功能：<strong>声明</strong>（<em>Declarative</em>）宏，使用 <code>macro_rules!</code>，和三种 <strong>过程</strong>（<em>Procedural</em>）宏：</p> 
<ul>
<li>自定义 <code>#[derive]</code> 宏在结构体和枚举上指定通过 <code>derive</code> 属性添加的代码</li>
<li>类属性（Attribute）宏定义可用于任意项的自定义属性</li>
<li>类函数宏看起来像函数不过作用于作为参数传递的 token。</li>
</ul> 
<p>我们会依次讨论每一种宏，不过首要的是，为什么已经有了函数还需要宏呢？</p> 
<h3 style="background-color:transparent">宏和函数的区别</h3> 
<p><span style="color:#fe2c24"><strong>从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 元编程（<em>metaprogramming</em>）。</strong></span>在附录 C 中会探讨 <code>derive</code> 属性，其生成各种 trait 的实现。我们也在本书中使用过 <code>println!</code> 宏和 <code>vec!</code> 宏。所有的这些宏以 <strong>展开</strong> 的方式来生成比你所手写出的更多的代码。</p> 
<p>元编程对于减少大量编写和维护的代码是非常有用的，它也扮演了函数的角色。但宏有一些函数所没有的附加能力。</p> 
<p>一个函数标签必须声明函数参数个数和类型。相比之下，宏只接受一个可变参数：用一个参数调用 <code>println!("hello")</code> 或用两个参数调用 <code>println!("hello {}", name)</code> 。而且，宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait 。而函数则不行，因为函数是在运行时被调用，同时 trait 需要在编译时实现。</p> 
<p><strong>实现一个宏而不是函数的消极面是宏定义要比函数定义更复杂，</strong>因为你正在编写生成 Rust 代码的 Rust 代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。</p> 
<p><span style="color:#fe2c24"><strong>宏和函数的最后一个重要的区别是：在调用宏 之前 必须定义并将其引入作用域，而函数则可以在任何地方定义和调用。</strong></span></p> 
<h3>使用macro_rules!的声明宏用于通用元编程</h3> 
<p>Rust 最常用的宏形式是 <strong>声明宏</strong>（<em>declarative macros</em>）。它们有时也被称为 “macros by example”、“<code>macro_rules!</code> 宏” 或者就是 “macros”。其核心概念是，声明宏允许我们编写一些类似 Rust <code>match</code> 表达式的代码。正如在第六章讨论的那样，<code>match</code> 表达式是控制结构，其接收一个表达式，与表达式的结果进行模式匹配，然后根据模式匹配执行相关代码。宏也将一个值和包含相关代码的模式进行比较；此种情况下，该值是传递给宏的 Rust 源代码字面值，模式用于和传递给宏的源代码进行比较，同时每个模式的相关代码则用于替换传递给宏的代码。所有这一切都发生于编译时。</p> 
<p>可以使用 <code>macro_rules!</code> 来定义宏。让我们通过查看 <code>vec!</code> 宏定义来探索如何使用 <code>macro_rules!</code> 结构。第八章讲述了如何使用 <code>vec!</code> 宏来生成一个给定值的 vector。例如，下面的宏用三个整数创建一个 vector：</p> 
<pre><code class="language-rust">fn main() {
    let v : Vec&lt;u32&gt; = vec![1, 2, 3];
}
</code></pre> 
<p>也可以使用 <code>vec!</code> 宏来构造两个整数的 vector 或五个字符串 slice 的 vector 。但却无法使用函数做相同的事情，因为我们无法预先知道参数值的数量和类型。src/lib.rs</p> 
<pre><code class="language-rust">#[macro_export]
macro_rules! vec {
    ($( $x: expr), *) =&gt; {
        let mut temp = Vec::new();
        &amp;(
            temp.push($x);
        )*
        temp
    };
}
</code></pre> 
<blockquote> 
 <p>注意：标准库中实际定义的 <code>vec!</code> 包括预分配适当量的内存的代码。这部分为代码优化，为了让示例简化，此处并没有包含在内。</p> 
</blockquote> 
<p><span style="color:#fe2c24"><strong>无论何时导入定义了宏的包，<code>#[macro_export]</code> 注解说明宏应该是可用的。 如果没有该注解，这个宏不能被引入作用域。</strong></span></p> 
<p>接着使用 <code>macro_rules!</code> 和宏名称开始宏定义，且所定义的宏并 <em>不带</em> 感叹号。名字后跟大括号表示宏定义体，在该例中宏名称是 <code>vec</code> 。</p> 
<p><code>vec!</code> 宏的结构和 <code>match</code> 表达式的结构类似。此处有一个单边模式 <code>( $( $x:expr ),* )</code> ，后跟 <code>=&gt;</code> 以及和模式相关的代码块。如果模式匹配，该相关代码块将被执行。假设这是这个宏中唯一的模式，则只有这一种有效匹配，其他任何匹配都是错误的。更复杂的宏会有多个单边模式。</p> 
<p>宏定义中有效模式语法和在第十八章提及的模式语法是不同的，因为宏模式所匹配的是 Rust 代码结构而不是值。回过头来检查下上述示例中模式片段什么意思。对于全部的宏模式语法，请查阅<a href="https://doc.rust-lang.org/reference/macros.html" title="参考">参考</a>。</p> 
<p>首先，一对括号包含了全部模式。接下来是后跟一对括号的美元符号（ <code>$</code> ），其通过替代代码捕获了符合括号内模式的值。<code>$()</code> 内则是 <code>$x:expr</code> ，其匹配 Rust 的任意表达式或给定 <code>$x</code> 名字的表达式。</p> 
<p><code>$()</code> 之后的逗号说明一个逗号分隔符可以有选择的出现代码之后，这段代码与在 <code>$()</code> 中所捕获的代码相匹配。紧随逗号之后的 <code>*</code> 说明该模式匹配零个或多个 <code>*</code> 之前的任何模式。</p> 
<p>当以 <code>vec![1, 2, 3];</code> 调用宏时，<code>$x</code> 模式与三个表达式 <code>1</code>、<code>2</code> 和 <code>3</code> 进行了三次匹配。</p> 
<p>现在让我们来看看这个出现在与此单边模式相关的代码块中的模式：在 <code>$()*</code> 部分中所生成的 <code>temp_vec.push()</code> 为在匹配到模式中的 <code>$()</code> 每一部分而生成。<code>$x</code> 由每个与之相匹配的表达式所替换。当以 <code>vec![1, 2, 3];</code> 调用该宏时，替换该宏调用所生成的代码会是下面这样：</p> 
<pre><code class="language-rust">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre> 
<p>我们已经定义了一个宏，其可以接收任意数量和类型的参数，同时可以生成能够创建包含指定元素的 vector 的代码。</p> 
<p><code>macro_rules!</code> 中有一些奇怪的地方。在将来，会有第二种采用 <code>macro</code> 关键字的声明宏，其工作方式类似但修复了这些极端情况。在此之后，<code>macro_rules!</code> 实际上就过时（deprecated）了。在此基础之上，同时鉴于大多数 Rust 程序员 <strong>使用</strong> 宏而非 <strong>编写</strong> 宏的事实，此处不再深入探讨 <code>macro_rules!</code>。请查阅在线文档或其他资源，如 <a href="https://danielkeep.github.io/tlborm/book/index.html" title="“The Little Book of Rust Macros”">“The Little Book of Rust Macros”</a> 来更多地了解如何写宏。</p> 
<h3 style="background-color:transparent">用于从属性生成代码的过程宏</h3> 
<p>第二种形式的宏被称为 <strong>过程宏</strong>（<em>procedural macros</em>），因为它们更像函数（一种过程类型）。过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。</p> 
<p>有三种类型的过程宏（自定义 derive，类属性和类函数），不过它们的工作方式都类似。</p> 
<p>当创建过程宏时，其定义必须位于一种特殊类型的属于它们自己的 crate 中。这么做出于复杂的技术原因，将来我们希望能够消除这些限制。使用这些宏需采用类似下面示例所示的代码形式，其中 <code>some_attribute</code> 是一个使用特定宏的占位符。src/lib.rs</p> 
<pre><code class="language-rust">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre> 
<p>过程宏包含一个函数，这也是其得名的原因：“过程” 是 “函数” 的同义词。那么为何不叫 “函数宏” 呢？好吧，有一个过程宏是 “类函数” 的，叫成函数会产生混乱。无论如何，定义过程宏的函数接受一个 <code>TokenStream</code> 作为输入并产生一个 <code>TokenStream</code> 作为输出。这也就是宏的核心：宏所处理的源代码组成了输入 <code>TokenStream</code>，同时宏生成的代码是输出 <code>TokenStream</code>。最后，函数上有一个属性；这个属性表明过程宏的类型。在同一 crate 中可以有多种的过程宏。</p> 
<p>考虑到这些宏是如此类似，我们会从自定义派生宏开始。接着会解释与其他形式宏的微小区别。</p> 
<h3>如何编写自定义derive宏</h3> 
<p>让我们创建一个 <code>hello_macro</code> crate，其包含名为 <code>HelloMacro</code> 的 trait 和关联函数 <code>hello_macro</code>。不同于让 crate 的用户为其每一个类型实现 <code>HelloMacro</code> trait，我们将会提供一个过程式宏以便用户可以使用 <code>#[derive(HelloMacro)]</code> 注解他们的类型来得到 <code>hello_macro</code> 函数的默认实现。该默认实现会打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 为定义了 trait 的类型名。src/main.rs</p> 
<pre><code class="language-rust">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre> 
<p>运行该代码将会打印 <code>Hello, Macro! My name is Pancakes!</code> 第一步是像下面这样新建一个库 crate：</p> 
<pre><code class="language-rust">$ cargo new hello_macro --lib
</code></pre> 
<p>接下来，会定义 HelloMacro trait 以及其关联函数：</p> 
<pre><code class="language-rust">pub trait HelloMacro {
    fn hello_macro();
}
</code></pre> 
<p>现在有了一个包含函数的 trait 。此时，crate 用户可以实现该 trait 以达到其期望的功能，像这样：</p> 
<pre><code class="language-rust">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre> 
<p>然而，他们需要为每一个他们想使用 <code>hello_macro</code> 的类型编写实现的代码块。我们希望为其节约这些工作。</p> 
<p>另外，我们也无法为 <code>hello_macro</code> 函数提供一个能够打印实现了该 trait 的类型的名字的默认实现：Rust 没有反射的能力，因此其无法在运行时获取类型名。我们需要一个在运行时生成代码的宏。</p> 
<p>下一步是定义过程式宏。在编写本部分时，过程式宏必须在其自己的 crate 内。该限制最终可能被取消。构造 crate 和其中宏的惯例如下：对于一个 <code>foo</code> 的包来说，一个自定义的派生过程宏的包被称为 <code>foo_derive</code> 。在 <code>hello_macro</code> 项目中新建名为 <code>hello_macro_derive</code> 的包。</p> 
<pre><code class="language-rust">$ cargo new hello_macro_derive --lib
</code></pre> 
<p>由于两个 crate 紧密相关，因此在 <code>hello_macro</code> 包的目录下创建过程式宏的 crate。如果改变在 <code>hello_macro</code> 中定义的 trait ，同时也必须改变在 <code>hello_macro_derive</code> 中实现的过程式宏。这两个包需要分别发布，编程人员如果使用这些包，则需要同时添加这两个依赖并将其引入作用域。我们也可以只用 <code>hello_macro</code> 包而将 <code>hello_macro_derive</code> 作为一个依赖，并重新导出过程式宏的代码。但我们组织项目的方式使编程人员使用 <code>hello_macro</code> 成为可能，即使他们无需 <code>derive</code> 的功能。</p> 
<p>需要将 <code>hello_macro_derive</code> 声明为一个过程宏的 crate。同时也需要 <code>syn</code> 和 <code>quote</code> crate 中的功能，正如注释中所说，需要将其加到依赖中。为 <code>hello_macro_derive</code> 将下面的代码加入到 <em>Cargo.toml</em> 文件中。</p> 
<pre><code class="language-XML">[lib]
proc-macro = true

[dependencies]
syn = "0.14.4"
quote = "0.6.3"
</code></pre> 
<p>为定义一个过程式宏，请将下面示例中的代码放在 <code>hello_macro_derive</code> crate 的 <em>src/lib.rs</em> 文件里面。注意这段代码在我们添加 <code>impl_hello_macro</code> 函数的定义之前是无法编译的。</p> 
<pre><code class="language-rust">extern crate proc_macro;

use crate::proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // 构建 Rust 代码所代表的语法树
    // 以便可以进行操作
    let ast = syn::parse(input).unwrap();

    // 构建 trait 实现
    impl_hello_macro(&amp;ast)
}</code></pre> 
<p>注意 <code>hello_macro_derive</code> 函数中代码分割的方式，它负责解析 <code>TokenStream</code>，而 <code>impl_hello_macro</code> 函数则负责转换语法树：这让编写一个过程式宏更加方便。外部函数中的代码（在这里是 <code>hello_macro_derive</code>）几乎在所有你能看到或创建的过程宏 crate 中都一样。内部函数（在这里是 <code>impl_hello_macro</code>）的函数体中所指定的代码则依过程宏的目的而各有不同。</p> 
<p>现在，我们已经引入了三个新的 crate：<code>proc_macro</code> 、 <a href="https://crates.io/crates/syn" title="syn">syn</a> 和 <a href="https://crates.io/crates/quote" title="quote">quote</a> 。Rust 自带 <code>proc_macro</code> crate，因此无需将其加到 <em>Cargo.toml</em> 文件的依赖中。<code>proc_macro</code> crate 是编译器用来读取和操作我们 Rust 代码的 API。</p> 
<p><code>syn</code> crate 将字符串中的 Rust 代码解析成为一个可以操作的数据结构。<code>quote</code> 则将 <code>syn</code> 解析的数据结构反过来传入到 Rust 代码中。这些 crate 让解析任何我们所要处理的 Rust 代码变得更简单：为 Rust 编写整个的解析器并不是一件简单的工作。</p> 
<p>当用户在一个类型上指定 <code>#[derive(HelloMacro)]</code> 时，<code>hello_macro_derive</code> 函数将会被调用。原因在于我们已经使用 <code>proc_macro_derive</code> 及其指定名称对 <code>hello_macro_derive</code> 函数进行了注解：<code>HelloMacro</code> ，其匹配到 trait 名，这是大多数过程宏遵循的习惯。</p> 
<p>该函数首先将来自 <code>TokenStream</code> 的 <code>input</code> 转换为一个我们可以解释和操作的数据结构。这正是 <code>syn</code> 派上用场的地方。<code>syn</code> 中的 <code>parse_derive_input</code> 函数获取一个 <code>TokenStream</code> 并返回一个表示解析出 Rust 代码的 <code>DeriveInput</code> 结构体。</p> 
<pre><code class="language-rust">DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre> 
<p>该结构体的字段展示了我们解析的 Rust 代码是一个类单元结构体，其 <code>ident</code>（ identifier，表示名字）为 <code>Pancakes</code>。该结构体里面有更多字段描述了所有类型的 Rust 代码，查阅 <a href="https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html" title="syn 中 DeriveInput 的文档">syn 中 DeriveInput 的文档</a> 以获取更多信息。</p> 
<p>此时，尚未定义 <code>impl_hello_macro</code> 函数，其用于构建所要包含在内的 Rust 新代码。但在此之前，注意其输出也是 <code>TokenStream</code>。所返回的 <code>TokenStream</code> 会被加到我们的 crate 用户所写的代码中，因此，当用户编译他们的 crate 时，他们会获取到我们所提供的额外功能。</p> 
<p>你可能也注意到了，当调用 <code>parse_derive_input</code> 或 <code>parse</code> 失败时。在错误时 panic 对过程宏来说是必须的，因为 <code>proc_macro_derive</code> 函数必须返回 <code>TokenStream</code> 而不是 <code>Result</code>，以此来符合过程宏的 API。这里选择用 <code>unwrap</code> 来简化了这个例子；在生产代码中，则应该通过 <code>panic!</code> 或 <code>expect</code> 来提供关于发生何种错误的更加明确的错误信息。</p> 
<p>现在我们有了将注解的 Rust 代码从 <code>TokenStream</code> 转换为 <code>DeriveInput</code> 实例的代码，让我们来创建在注解类型上实现 <code>HelloMacro</code> trait 的代码。/lib.rs</p> 
<pre><code class="language-rust">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}", stringify!(#name));
            }
        }
    };
    gen.into()
}
</code></pre> 
<p>我们得到一个包含以 <code>ast.ident</code> 作为注解类型名字（标识符）的 <code>Ident</code> 结构体实例。示例  中的结构体表明当 <code>impl_hello_macro</code> 函数运行于示例中的代码上时 <code>ident</code> 字段的值是 <code>"Pancakes"</code>。因此，示例中 <code>name</code> 变量会包含一个 <code>Ident</code> 结构体的实例，当打印时，会是字符串 <code>"Pancakes"</code>，也就是示例中结构体的名称。</p> 
<p><code>quote!</code> 宏让我们可以编写希望返回的 Rust 代码。<code>quote!</code> 宏执行的直接结果并不是编译器所期望的并需要转换为 <code>TokenStream</code>。为此需要调用 <code>into</code> 方法，它会消费这个中间表示（intermediate representation，IR）并返回所需的 <code>TokenStream</code> 类型值。</p> 
<p>这个宏也提供了一些非常酷的模板机制；我们可以写 <code>#name</code> ，然后 <code>quote!</code> 会以名为 <code>name</code> 的变量值来替换它。你甚至可以做一些类似常用宏那样的重复代码的工作。查阅 <a href="https://docs.rs/quote" title="quote crate 的文档">quote crate 的文档</a> 来获取详尽的介绍。</p> 
<p>我们期望我们的过程式宏能够为通过 <code>#name</code> 获取到的用户注解类型生成 <code>HelloMacro</code> trait 的实现。该 trait 的实现有一个函数 <code>hello_macro</code> ，其函数体包括了我们期望提供的功能：打印 <code>Hello, Macro! My name is</code> 和注解的类型名。</p> 
<p>此处所使用的 <code>stringify!</code> 为 Rust 内置宏。其接收一个 Rust 表达式，如 <code>1 + 2</code> ， 然后在编译时将表达式转换为一个字符串常量，如 <code>"1 + 2"</code> 。这与 <code>format!</code> 或 <code>println!</code> 是不同的，它计算表达式并将结果转换为 <code>String</code> 。有一种可能的情况是，所输入的 <code>#name</code> 可能是一个需要打印的表达式，因此我们用 <code>stringify!</code> 。 <code>stringify!</code> 编译时也保留了一份将 <code>#name</code> 转换为字符串之后的内存分配。</p> 
<p>此时，<code>cargo build</code> 应该都能成功编译 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 。我们将这些 crate 连接到示例的代码中来看看过程宏的行为！在 <em>projects</em> 目录下用 <code>cargo new pancakes</code> 命令新建一个二进制项目。需要将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 作为依赖加到 <code>pancakes</code> 包的 <em>Cargo.toml</em> 文件中去。如果你正将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本发布到 <a href="https://crates.io/" title="crates.io">crates.io</a> 上，其应为正规依赖；如果不是，则可以像下面这样将其指定为 <code>path</code> 依赖：</p> 
<pre><code class="language-rust">[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre> 
<p>然后执行 <code>cargo run</code>：其应该打印 <code>Hello, Macro! My name is Pancakes!</code>。其包含了该过程宏中 <code>HelloMacro</code> trait 的实现，而无需 <code>pancakes</code> crate 实现它；<code>#[derive(HelloMacro)]</code> 增加了该 trait 实现。</p> 
<h3>类属性宏</h3> 
<p>类属性宏与自定义派生宏相似，不同于为 <code>derive</code> 属性生成代码，它们允许你创建新的属性。它们也更为灵活；<code>derive</code> 只能用于结构体和枚举；属性还可以用于其它的项，比如函数。作为一个使用类属性宏的例子，可以创建一个名为 <code>route</code> 的属性用于注解 web 应用程序框架（web application framework）的函数：</p> 
<pre><code class="language-rust">#[route(GET, "/")]
fn index() {
</code></pre> 
<p><code>#[route]</code> 属性将由框架本身定义为一个过程宏。其宏定义的函数签名看起来像这样：</p> 
<pre><code class="language-rust">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre> 
<p>这里有两个 <code>TokenStream</code> 类型的参数；第一个用于属性内容本身，也就是 <code>GET, "/"</code> 部分。第二个是属性所标记的项，在本例中，是 <code>fn index() {}</code> 和剩下的函数体。</p> 
<p>除此之外，类属性宏与自定义派生宏工作方式一致：创建 <code>proc-macro</code> crate 类型的 crate 并实现希望生成代码的函数！</p> 
<h3>类函数宏</h3> 
<p>类函数宏定义看起来像函数调用的宏。类似于 <code>macro_rules!</code>，它们比函数更灵活；例如，可以接受未知数量的参数。然而 <code>macro_rules!</code> 宏只能使用之前 <a href="https://rust.bootcss.com/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming" title="“使用 macro_rules! 的声明宏用于通用元编程”">“使用 macro_rules! 的声明宏用于通用元编程”</a> 介绍的类匹配的语法定义。类函数宏获取 <code>TokenStream</code> 参数，其定义使用 Rust 代码操纵 <code>TokenStream</code>，就像另两种过程宏一样。一个类函数宏例子是可以像这样被调用的 <code>sql!</code> 宏：</p> 
<pre><code class="language-rust">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre> 
<p>这个宏会解析其中的 SQL 语句并检查其是否是句法正确的，这是比 <code>macro_rules!</code> 可以做到的更为复杂的处理。<code>sql!</code> 宏应该被定义为如此：</p> 
<pre><code class="language-rust">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre> 
<p>这类似于自定义派生宏的签名：获取括号中的 token，并返回希望生成的代码。</p> 
<p>参考：<a href="https://rust.bootcss.com/ch19-00-advanced-features.html" title="高级特征 - Rust 程序设计语言 简体中文版 (bootcss.com)">高级特征 - Rust 程序设计语言 简体中文版 (bootcss.com)</a></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>