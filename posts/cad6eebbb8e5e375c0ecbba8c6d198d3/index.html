<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C&#43;&#43;】初窥门径---入门篇 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】初窥门径---入门篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px"><a href="#%E5%89%8D%E8%A8%80" title="前言">前言</a></p> 
<p id="1.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-toc" style="margin-left:0px"><a href="#1.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" title="1.命名空间">1.命名空间</a></p> 
<p id="1.1%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px"><a href="#1.1%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89" title="1.1命名空间定义">1.1命名空间定义</a></p> 
<p id="1.2%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px"><a href="#1.2%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8" title="1.2 命名空间使用">1.2 命名空间使用</a></p> 
<p id="2.%20C%2B%2B%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA-toc" style="margin-left:0px"><a href="#2.%20C%2B%2B%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA" title="2. C++的输入和输出">2. C++的输入和输出</a></p> 
<p id="3.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:0px"><a href="#3.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" title="3.缺省参数">3.缺省参数</a></p> 
<p id="3.1%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#3.1%E6%A6%82%E5%BF%B5" title="3.1概念">3.1概念</a></p> 
<p id="3.2%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#3.2%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB" title="3.2缺省参数分类">3.2缺省参数分类</a></p> 
<p id="4.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px"><a href="#4.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" title="4.函数重载">4.函数重载</a></p> 
<p id="4.1%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#4.1%E6%A6%82%E5%BF%B5" title="4.1概念">4.1概念</a></p> 
<p id="4.2%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0(name%20Mangling)-toc" style="margin-left:40px"><a href="#4.2%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0%28name%20Mangling%29" title="4.2名字修饰(name Mangling)">4.2名字修饰(name Mangling)</a></p> 
<p id="5.extern%20%E2%80%9CC%E2%80%9D-toc" style="margin-left:0px"><a href="#5.extern%20%E2%80%9CC%E2%80%9D" title="5.extern “C”">5.extern “C”</a></p> 
<p id="6.%E5%BC%95%E7%94%A8-toc" style="margin-left:0px"><a href="#6.%E5%BC%95%E7%94%A8" title="6.引用">6.引用</a></p> 
<p id="6.1%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#6.1%E6%A6%82%E5%BF%B5" title="6.1概念">6.1概念</a></p> 
<p id="%C2%A06.2%20%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7-toc" style="margin-left:40px"><a href="#%C2%A06.2%20%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7" title=" 6.2 引用特性"> 6.2 引用特性</a></p> 
<p id="6.3%20%E5%B8%B8%E5%BC%95%E7%94%A8-toc" style="margin-left:40px"><a href="#6.3%20%E5%B8%B8%E5%BC%95%E7%94%A8" title="6.3 常引用">6.3 常引用</a></p> 
<p id="6.4%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px"><a href="#6.4%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" title="6.4 使用场景">6.4 使用场景</a></p> 
<p id="6.5%C2%A0%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px"><a href="#6.5%C2%A0%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB" title="6.5 引用和指针的区别">6.5 引用和指针的区别</a></p> 
<p id="7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0" title="7. 内联函数">7. 内联函数</a></p> 
<p id="7.1%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#7.1%20%E6%A6%82%E5%BF%B5" title="7.1 概念">7.1 概念</a></p> 
<p id="7.2%20%E7%89%B9%E6%80%A7-toc" style="margin-left:40px"><a href="#7.2%20%E7%89%B9%E6%80%A7" title="7.2 特性">7.2 特性</a></p> 
<p id="8.%20auto%E5%85%B3%E9%94%AE%E5%AD%97(C%2B%2B11)-toc" style="margin-left:0px"><a href="#8.%20auto%E5%85%B3%E9%94%AE%E5%AD%97%28C%2B%2B11%29" title="8. auto关键字(C++11)">8. auto关键字(C++11)</a></p> 
<p id="8.1%20auto%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px"><a href="#8.1%20auto%E7%AE%80%E4%BB%8B" title="8.1 auto简介">8.1 auto简介</a></p> 
<p id="8.2%20auto%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px"><a href="#8.2%20auto%E7%9A%84%E4%BD%BF%E7%94%A8" title="8.2 auto的使用">8.2 auto的使用</a></p> 
<p id="8.3%20auto%E4%B8%8D%E8%83%BD%E6%8E%A8%E5%AF%BC%E7%9A%84%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px"><a href="#8.3%20auto%E4%B8%8D%E8%83%BD%E6%8E%A8%E5%AF%BC%E7%9A%84%E5%9C%BA%E6%99%AF" title="8.3 auto不能推导的场景">8.3 auto不能推导的场景</a></p> 
<p id="9.%20%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF(C%2B%2B11)-toc" style="margin-left:0px"><a href="#9.%20%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF%28C%2B%2B11%29" title="9. 基于范围的for循环(C++11)">9. 基于范围的for循环(C++11)</a></p> 
<p id="9.1%20%E8%8C%83%E5%9B%B4for%E7%9A%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px"><a href="#9.1%20%E8%8C%83%E5%9B%B4for%E7%9A%84%E8%AF%AD%E6%B3%95" title="9.1 范围for的语法">9.1 范围for的语法</a></p> 
<p id="9.2%20%E8%8C%83%E5%9B%B4for%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6-toc" style="margin-left:40px"><a href="#9.2%20%E8%8C%83%E5%9B%B4for%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6" title="9.2 范围for的使用条件">9.2 范围for的使用条件</a></p> 
<p id="10.%20%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BCnullptr(C%2B%2B11)-toc" style="margin-left:0px"><a href="#10.%20%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BCnullptr%28C%2B%2B11%29" title="10. 指针空值nullptr(C++11)">10. 指针空值nullptr(C++11)</a></p> 
<hr id="hr-toc">
<h1 id="%E5%89%8D%E8%A8%80">前言</h1> 
<p>经过前面对C语言和数据结构初阶的学习，自己也初步进入了编程的世界。</p> 
<p>从最初的兴趣至极，到热情消减，转至平淡，再到现在代码已经逐渐为生活的一部分。</p> 
<p>越发感觉代码的奇妙，编程世界的广阔无垠。</p> 
<p>希望两年后的自己回首往昔，能够为之感叹~</p> 
<p>感谢各位读者的点赞与支持，与君共勉！</p> 
<p>从本章开始，将进入C++学习阶段。</p> 
<p></p> 
<h1 id="1.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">1.命名空间</h1> 
<blockquote> 
 <p>在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。</p> 
 <p>使用命名空间的目的是<strong>对标识符的名称进行本地化</strong>，以避免命名冲突或名字污染，<strong>namespace</strong>关键字的出现就是针对这种问题的。</p> 
</blockquote> 
<p> 例如：自己定义的变量(函数，类)名与C++内置函数名等冲突，在C语言中是解决不了的。</p> 
<p>            在大型的工程中，自己定义的变量(函数，类)名与其他人定义的相冲突等问题。</p> 
<p></p> 
<h2 id="1.1%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89">1.1命名空间定义</h2> 
<p>定义命名空间，需要使用到<strong>namespace</strong>关键字，后面跟命名空间的名字，然后接一对<strong>{}</strong>即可，<strong>{}</strong>中即为命名空间的成员。</p> 
<pre><code class="language-cpp">//1. 普通的命名空间
namespace N1 // N1为命名空间的名称
{
	// 命名空间中的内容，既可以定义变量，也可以定义函数
	int a;
	int Add(int left, int right)
	{
		return left + right;
	}
}

//2. 命名空间可以嵌套
namespace N2
{
	int a;
	int b;
	int Add(int left, int right)
	{
		return left + right;
	}
	namespace N3
	{
		int c;
		int d;
		int Sub(int left, int right)
		{
			return left - right;
		}
	}
}

//3. 同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中。
namespace N1
{
	int Mul(int left, int right)
	{
		return left * right;
	}
}</code></pre> 
<blockquote> 
 <p><strong>注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。</strong></p> 
</blockquote> 
<p></p> 
<h2 id="1.2%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8">1.2 命名空间使用<br>  </h2> 
<p>命名空间是一个作用域，如果在使用的里面的变量时，只写变量名，编译器肯定是无法识别的。</p> 
<p>例如：</p> 
<pre><code class="language-cpp">namespace N
{
    int a = 10;
    int b = 20;

    int Add(int x, int y)
    {
        return x + y;
    }

    int Sub(int x, int y)
    {
        return x - y;
    }
}
int main()
{
    printf("%dn", a); // 该语句编译出错，无法识别变量a
    return 0;
}</code></pre> 
<p>那该如何使用命名空间中的成员呢？</p> 
<p>这里有三种方法：</p> 
<p><strong>方法1：加命名空间名称及作用域限定符(::) (最安全可靠，但使用时不太方便)</strong></p> 
<pre><code class="language-cpp">int main()
{
    printf("%dn", N::a);
    return 0;
}</code></pre> 
<p><strong>方法二：使用using将命名空间中成员引入 (展开命名空间中常用的成员)</strong></p> 
<pre><code class="language-cpp">using N::b; // 展开后，后续可直接使用
int main()
{
    printf("%dn", N::a);
    printf("%dn", b);
    return 0;
}</code></pre> 
<p><strong>方法三：使用using namespace 命名空间名称引入(不可靠，在项目中不能使用该方法) (展开命名空间中所有成员)</strong></p> 
<pre><code class="language-cpp">using namespce N;
int main()
{
    printf("%dn", N::a);
    printf("%dn", b);
    Add(10, 20);
    return 0;
}</code></pre> 
<p><strong>注意：</strong></p> 
<ul>
<li>在命名空间中定义的成员本质是全局的，放在静态区。</li>
<li>命名空间中变量可以初始化，但不能赋值。</li>
</ul>
<pre><code class="language-cpp">namespace N
{
	int a;// 定义变量a，未初始化
	a = 0;// 不能在命名空间中赋值
	int b = 10;// 定义变量b，同时初始化
}</code></pre> 
<h1 id="2.%20C%2B%2B%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">2. C++的输入和输出</h1> 
<p>C++中有新的输入和输出方式，但C++是包容C语言的，所以C语言中对的输入和输出在C++中同样适用。</p> 
<p><strong>Hello world!!! </strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;"Hello world!!!"&lt;&lt;endl;//C++的输出
    return 0;
}</code></pre> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main()
{
    int a;
    double b;
    char c;

    cin&gt;&gt;a;
    cin&gt;&gt;b&gt;&gt;c;
    cout&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;
    return 0;
}</code></pre> 
<p>对于上面的代码，你是否有许多疑惑，没关系我们来依次解答。</p> 
<blockquote> 
 <ol>
<li> 使用cout标准输出(控制台)和cin标准输入(键盘)时，必须包含&lt; iostream &gt;头文件以及std标准命名空间。</li>
<li>在平常写代码练习时，我们可以直接将std命名空间展开。</li>
<li>C++中的输入是 <strong>cin </strong>输出是 <strong>cout</strong> 。</li>
<li>至于<strong>&gt;&gt;</strong>和<strong>&lt;&lt;</strong>表示将数据输入和输出到流，也可以表示移位运算(在C++中被重载了,后面会将这里不用深究)</li>
<li>endl(end line)表示换行。</li>
<li> 使用C++输入输出更方便，不需增加数据格式控制，比如：整形--%d，字符--%c。</li>
</ol>
</blockquote> 
<p>注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带.h；旧编译器(vc 6.0)中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐使用&lt;iostream&gt;+std的方式。</p> 
<p></p> 
<h1 id="3.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">3.缺省参数</h1> 
<h2 id="3.1%E6%A6%82%E5%BF%B5">3.1概念</h2> 
<p>缺省参数是<strong>声明或定义函数时</strong>为函数的参数指定一个<strong>默认值</strong>。</p> 
<p>在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。<br> 例如：</p> 
<pre><code class="language-cpp">void TestFunc(int a = 0)//默认参数为0
{
    cout&lt;&lt;a&lt;&lt;endl;
}
int main()
{
    TestFunc(); // 没有传参时，使用参数的默认值
    TestFunc(10); // 传参时，使用指定的实参
}</code></pre> 
<p>编译结果：<img alt="" height="260" src="https://images2.imgbox.com/b8/1b/hb7VjY8k_o.png" width="770"></p> 
<p></p> 
<h2 id="3.2%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB">3.2缺省参数分类</h2> 
<ul><li>全缺省参数</li></ul>
<pre><code class="language-cpp">// 函数中所有参数都指定默认值
void TestFunc(int a = 10, int b = 20, int c = 30)
{
    cout&lt;&lt;"a = "&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;"b = "&lt;&lt;b&lt;&lt;endl;
    cout&lt;&lt;"c = "&lt;&lt;c&lt;&lt;endl;
}</code></pre> 
<ul><li>半缺省参数</li></ul>
<pre><code class="language-cpp">//函数中部分参数指定默认值
void TestFunc(int a, int b = 10, int c = 20)
{
    cout&lt;&lt;"a = "&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;"b = "&lt;&lt;b&lt;&lt;endl;
    cout&lt;&lt;"c = "&lt;&lt;c&lt;&lt;endl;
}</code></pre> 
<p><strong>注意：</strong></p> 
<ol>
<li> 半缺省参数必须从右往左依次来给出，不能间隔着给</li>
<li> 缺省参数不能在函数声明和定义中同时出现</li>
<li>缺省值必须是常量或者全局变量</li>
<li> <p>C语言不支持（编译器不支持）</p> </li>
</ol>
<pre><code class="language-cpp">//下面两种均是错误写法！
void TestFunc(int a = 10, int b, int c)
void TestFunc(int a = 10, int b, int c = 30)

//a.h(声明)
void TestFunc(int a = 10);
// a.c(定义)
void TestFunc(int a = 20)
{}
// 注意：如果生命与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那
个缺省值。</code></pre> 
<p></p> 
<h1 id="4.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">4.函数重载</h1> 
<h2 id="4.1%E6%A6%82%E5%BF%B5">4.1概念</h2> 
<p><strong>函数重载:</strong>是函数的一种特殊情况，<strong>C++允许在同一作用域中声明几个功能类似的同名函数</strong>，这些同名函数的形参列表(<strong>参数个数 或 类型 或 顺序</strong>)<strong>必须不同</strong>，常用来处理实现功能类似数据类型不同的问题。</p> 
<pre><code class="language-cpp">int Add(int a, int b)
{
    return a + b;
}

double Add(double a, double b)
{
    return a + b;
}

long Add(long a, long b)
{
    return a + b;
}

int main()
{
    Add(10, 20);
    Add(10.0, 20.0);
    Add(10L, 20L);
    return 0;
}
//上面的函数功能相同，函数名相同，参数类型不同。
//当然这里的重载函数还可以 参数个数不同，参数顺序不同</code></pre> 
<p><strong>下面两个函数属于函数重载吗？</strong></p> 
<pre><code class="language-cpp">short Add(short a, short b)
{
    return a + b;
}
int Add(short a, short b)
{
    return a + b;
}

// 注意：上面两个函数不属于函数重载，返回值不是定义函数重载的标准，调用的时候不能区分</code></pre> 
<pre><code class="language-cpp">// 1、缺省值不同，不能构成重载
void f(int a)
{
	cout &lt;&lt; "f()" &lt;&lt; endl;
}

void f(int a = 0)
{
	cout &lt;&lt; "f(int a)" &lt;&lt; endl;
}

// 2、构成重载，但是使用时会有问题 ： f(); // 调用存在歧义
void f()
{
	cout &lt;&lt; "f()" &lt;&lt; endl;
}

void f(int a = 0)
{
	cout &lt;&lt; "f(int a)" &lt;&lt; endl;
}
</code></pre> 
<h2 id="4.2%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0(name%20Mangling)">4.2名字修饰(name Mangling)</h2> 
<p><strong>为什么C++支持函数重载，而C语言不支持函数重载呢？</strong><br> 在C/C++中，一个程序要运行起来，需要经历以下几个阶段：<strong>预处理</strong>、<strong>编译</strong>、<strong>汇编</strong>、<strong>链接</strong>。</p> 
<p><img alt="" src="https://images2.imgbox.com/7e/90/fbobfGhH_o.png"></p> 
<p></p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/4f/55/9tFvtbfR_o.png"></p> 
<p></p> 
<blockquote> 
 <p>1. 实际我们的项目通常是由多个头文件和多个源文件构成，而通过我们C语言阶段学习的编译链接，我们可以知道，【当前a.cpp中调用了b.cpp中定义的Add函数时】，编译后链接前，a.o的目标文件中没有Add的函数地址，因为Add是在b.cpp中定义的，所以Add的地址在b.o中。那么怎么办呢？<br> 2. 所以链接阶段就是专门处理这种问题，链接器看到a.o调用Add，但是没有Add的地址，就会到b.o的符号表中找Add的地址，然后链接到一起。<br> 3. 那么链接时，面对Add函数，连接器会使用哪个名字去找呢？这里每个编译器都有自己的函数名修饰规则。<br> 4. 由于Windows下vs的修饰规则过于复杂，而Linux下gcc的修饰规则简单易懂，下面我们使用了gcc演示了这个修饰后的名字。<br> 5. 通过下面我们可以看出gcc的函数修饰后名字不变。<strong>而g++的函数修饰后变成【_Z+函数长度+函数名+类型首字母】。</strong></p> 
</blockquote> 
<p><strong>采用C语言编译器编译后结果</strong><br>  <img alt="" height="526" src="https://images2.imgbox.com/65/21/7BQ03hFR_o.png" width="1067"></p> 
<p> <strong>结论：在linux下，采用gcc编译完成后，函数名字的修饰没有发生改变</strong><br>  </p> 
<p><strong>采用C++编译器编译后结果</strong><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/80/45/fYjZsvCp_o.png"></p> 
<p><strong>结论：在linux下，采用g++编译完成后，函数名字的修饰发生改变，编译器将函数参数类型信息<br> 添加到修改后的名字中</strong><br>  </p> 
<p>Windows下名字修饰规则比较复杂，这里不再讲解。</p> 
<blockquote> 
 <p>6. 通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载。<br> 7. 另外我们也理解了，为什么函数重载要求参数不同！而跟返回值没关系。</p> 
</blockquote> 
<p></p> 
<h1 id="5.extern%20%E2%80%9CC%E2%80%9D">5.extern “C”<br>  </h1> 
<blockquote> 
 <p>有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern "C"，意思是告诉编译器，<strong>将该函数按照C语言规则来编译</strong>（例如函数名修饰规则）。</p> 
</blockquote> 
<pre><code class="language-cpp">extern "C" int Add(int a, int b);
int main()
{
    Add(1,2);
    return 0;
}</code></pre> 
<p></p> 
<h1 id="6.%E5%BC%95%E7%94%A8">6.引用</h1> 
<h2 id="6.1%E6%A6%82%E5%BF%B5">6.1概念</h2> 
<p><strong>引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。</strong></p> 
<p><strong>类型&amp; 引用变量名(对象名) = 引用实体</strong><br>  </p> 
<pre><code class="language-cpp">void TestRef()
{
    int a = 10;
    int&amp; ra = a;//&lt;====定义引用类型
    printf("%pn", &amp;a);
    printf("%pn", &amp;ra);
}</code></pre> 
<p> <strong>注意：引用类型必须和引用实体是同种类型的</strong></p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/c9/0b/PdGNTscD_o.png" width="763"></p> 
<p>从上图结果可以看出，ra 和 a 共同一块空间。</p> 
<p></p> 
<h2 id="%C2%A06.2%20%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7"> 6.2 引用特性<br>  </h2> 
<blockquote> 
 <p><strong>1. 引用在定义时必须初始化<br> 2. 一个变量可以有多个引用<br> 3. 引用一旦引用一个实体，再不能引用其他实体</strong></p> 
</blockquote> 
<pre><code class="language-cpp">void TestRef()
{
    int a = 10;
    // int&amp; ra; // 该条语句编译时会出错
    int&amp; ra = a;// 一个变量可以有多个引用
    int&amp; rra = a;
    printf("%p %p %pn", &amp;a, &amp;ra, &amp;rra);
}</code></pre> 
<p></p> 
<h2 id="6.3%20%E5%B8%B8%E5%BC%95%E7%94%A8">6.3 常引用</h2> 
<p>在引用常量时，需在类型前加const。</p> 
<p>引用时如存在隐式类型转换，也需在类型前加const，且这时引用的不是变量本身，而是隐式类型转换时的临时空间。</p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/be/51/kvHYUkQh_o.png" width="664"></p> 
<pre><code class="language-cpp">void TestConstRef()
{
    const int a = 10;
    //int&amp; ra = a; // 该语句编译时会出错，a为常量
    const int&amp; ra = a;

    // int&amp; b = 10; // 该语句编译时会出错，b为常量
    const int&amp; b = 10;

    double d = 12.34;
    //int&amp; rd = d; // 该语句编译时会出错，类型不同
    const int&amp; rd = d;
}</code></pre> 
<p> </p> 
<h2 id="6.4%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">6.4 使用场景</h2> 
<p><strong>1. 做参数</strong></p> 
<pre><code class="language-cpp">void Swap(int&amp; a, int&amp; b)//因为引用使用的是变量原空间，所以可以直接交换
{
    int temp = a;
    a = b;
    b = temp;
}</code></pre> 
<p><strong>2. 做返回值</strong><br> 由于存在栈中的地址，在函数结束后回还给操作系统，所以引用做返回值时，不能用栈中的地址。</p> 
<pre><code class="language-cpp">int&amp; Add(int a, int b)
{
    int c = a + b;
    return c;
}
int main()
{
    int&amp; ret = Add(1, 2);
    Add(3, 4);
    cout &lt;&lt; "Add(1, 2) is :"&lt;&lt; ret &lt;&lt;endl;
    return 0;
}</code></pre> 
<p>这里的c是局部变量，引用做返回值，返回的是c的别名，而c已经被还给操作系统了。</p> 
<p> 这里的结果是：<img alt="" height="542" src="https://images2.imgbox.com/fa/50/g4Eep8V2_o.png" width="1128"></p> 
<p>了解函数栈帧的朋友应该知道，第一次调用Add函数之后，c空间就被释放了，但这块空间还是存在于栈中的，而且里面的值(3)没有被修改；</p> 
<p>第二次调用Add后会在相同的地址开辟c空间，这时里面的值就被第二次得到的结果覆盖了，所以输出这块空间中的值时得到的是 7。</p> 
<pre><code class="language-cpp">int&amp; Count()
{
    static int n = 0；// 加上static之后该变量就被存放在静态区中，函数返回后该空间不会被释放
    n++;
    // ...
    return n;
}</code></pre> 
<p><strong>注意：如果函数返回时，出了函数作用域，如果返回对象还未还给系统，则可以使用引用返回，如果已经还给系统了，则必须使用传值返回。</strong><br>  </p> 
<h2 id="6.5%C2%A0%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB">6.5 引用和指针的区别</h2> 
<p><strong>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</strong><br><br> 在<strong>底层实现</strong>上实际是有空间的，因为<strong>引用是按照指针方式来实现的</strong>。</p> 
<pre><code class="language-cpp">int main()
{
	int a = 10;
	int&amp; ra = a;
	ra = 20;
	int* pa = &amp;a;
	*pa = 20;
	return 0;
}</code></pre> 
<p> 汇编代码比较：</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/10/d6/2wNN0jFJ_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>引用和指针的不同点:</strong></p> 
 <ol>
<li> 引用在定义时必须初始化，指针没有要求</li>
<li> 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体</li>
<li> 没有NULL引用，但有NULL指针</li>
<li> 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)</li>
<li> 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</li>
<li> 有多级指针，但是没有多级引用</li>
<li>访问实体方式不同，指针需要显式解引用，引用编译器自己处理</li>
<li> 引用比指针使用起来相对更安全</li>
</ol>
</blockquote> 
<p></p> 
<h1 id="7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">7. 内联函数</h1> 
<h2 id="7.1%20%E6%A6%82%E5%BF%B5">7.1 概念</h2> 
<p>以<strong>inline</strong>修饰的函数叫做<strong>内联函数</strong>，编译时C++编译器会在调用内联函数的地方展开，<strong>没有函数压栈的开销</strong>，内联函数提升程序运行的效率。</p> 
<p>如果不是内联函数，使用时会有调用函数的操作：<br><img alt="" height="362" src="https://images2.imgbox.com/c7/ef/iyCiu33O_o.png" width="930"></p> 
<p></p> 
<p>如果在上述函数前增加inline关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用。不会有函数压栈的开销。<br><img alt="" height="350" src="https://images2.imgbox.com/62/69/JhZjUsuz_o.png" width="910"></p> 
<p></p> 
<h2 id="7.2%20%E7%89%B9%E6%80%A7">7.2 特性</h2> 
<blockquote> 
 <p>1. inline是一种<strong>以空间换时间</strong>的做法，省去调用函数额开销。所以<strong>代码很长</strong>或者有<strong>循环/递归</strong>的函数不适宜使用作为内联函数。<br> 2. <strong>inline对于编译器而言只是一个建议</strong>，编译器会自动优化，如果定义为inline的函数体内有循环/递归等等，编译器优化时会忽略掉内联。<br> 3. inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。</p> 
 <p>4.频繁使用的小函数，可以定义成内联函数</p> 
</blockquote> 
<p>例如：</p> 
<pre><code class="language-cpp">// F.h
#include &lt;iostream&gt;
using namespace std;
inline void f(int i);

// F.cpp
#include "F.h"
void f(int i)
{
    cout &lt;&lt; i &lt;&lt; endl;
}

// main.cpp
#include "F.h"
int main()
{
    f(10);
    return 0;
}</code></pre> 
<p>上面这段代码，在main函数中f函数的声明和定义是分离的，在F.h展开后，f函数也会被直接展开，而F.h中只有声明，在链接时找不到f函数的地址，程序就会出现链接错误。</p> 
<p></p> 
<h1 id="8.%20auto%E5%85%B3%E9%94%AE%E5%AD%97(C%2B%2B11)">8. auto关键字(C++11)</h1> 
<h2 id="8.1%20auto%E7%AE%80%E4%BB%8B">8.1 auto简介</h2> 
<p>在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，但遗憾的是一直没有人去使用它。</p> 
<p>C++11中，标准委员会赋予了auto全新的含义即：<strong>auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。</strong><br>  </p> 
<pre><code class="language-cpp">int TestAuto()
{
    return 10;
}
int main()
{
    int a = 10;
    auto b = a;//auto自动识别a的类型
    auto c = 'a';
    auto d = TestAuto();
    cout &lt;&lt; typeid(b).name() &lt;&lt; endl;//C++中tyoeid().name可以输出变量类型
    cout &lt;&lt; typeid(c).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(d).name() &lt;&lt; endl;
    //auto e; 无法通过编译，使用auto定义变量时必须对其进行初始化
    return 0;
}</code></pre> 
<blockquote> 
 <p>【注意】<br><strong>使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。</strong></p> 
</blockquote> 
<p> </p> 
<h2 id="8.2%20auto%E7%9A%84%E4%BD%BF%E7%94%A8">8.2 auto的使用</h2> 
<p><strong>1. auto与指针和引用结合起来使用</strong><br><strong>用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;</strong> </p> 
<pre><code class="language-cpp">int main()
{
    int x = 10;
    auto a = &amp;x;
    auto* b = &amp;x;
    auto&amp; c = x;
    cout &lt;&lt; typeid(a).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(b).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(c).name() &lt;&lt; endl;
    *a = 20;
    *b = 30;
    c = 40;
    return 0;
}</code></pre> 
<p><strong>2. 在同一行定义多个变量<br> 当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。</strong></p> 
<pre><code class="language-cpp">void TestAuto()
{
    auto a = 1, b = 2;
    auto c = 3, d = 4.0; // 该行代码会编译失败，因为c和d的初始化表达式类型不同
}</code></pre> 
<p> </p> 
<h2 id="8.3%20auto%E4%B8%8D%E8%83%BD%E6%8E%A8%E5%AF%BC%E7%9A%84%E5%9C%BA%E6%99%AF">8.3 auto不能推导的场景</h2> 
<p><strong>1. auto不能作为函数的参数</strong></p> 
<pre><code class="language-cpp">// 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导
void TestAuto(auto a)
{}</code></pre> 
<p><strong>2. auto不能直接用来声明数组</strong></p> 
<pre><code class="language-cpp">void TestAuto()
{
    int a[] = {1,2,3};
    auto b[] = {4，5，6};
}</code></pre> 
<p>3. 为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法<br> 4. auto在实际中最常见的优势用法就是跟C++11提供的新式for循环，还有lambda表达式等进行配合使用。</p> 
<h1 id="9.%20%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF(C%2B%2B11)">
<br> 9. 基于范围的for循环(C++11)</h1> 
<h2 id="9.1%20%E8%8C%83%E5%9B%B4for%E7%9A%84%E8%AF%AD%E6%B3%95">9.1 范围for的语法</h2> 
<p>在C++98中如果要遍历一个数组，可以按照以下方式进行：</p> 
<pre><code class="language-cpp">void TestFor()
{
    int array[] = { 1, 2, 3, 4, 5 };
    for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i)
    array[i] *= 2;
    for (int* p = array; p &lt; array + sizeof(array)/ sizeof(array[0]); ++p)
    cout &lt;&lt; *p &lt;&lt; endl;
}</code></pre> 
<p>对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。</p> 
<p>因此C++11中引入了基于范围的for循环。</p> 
<p>for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。<br>  </p> 
<pre><code class="language-cpp">void TestFor()
{
    int array[] = { 1, 2, 3, 4, 5 };
    for(auto&amp; e : array)
    e *= 2;
    for(auto e : array)
    cout &lt;&lt; e &lt;&lt; " ";
    return 0;
}</code></pre> 
<p><strong>注意：与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环。</strong><br>  </p> 
<h2 id="9.2%20%E8%8C%83%E5%9B%B4for%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6">9.2 范围for的使用条件<br>  </h2> 
<p><strong>1. for循环迭代的范围必须是确定的</strong></p> 
<p>对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围。<br> 注意：以下代码就有问题，因为for的范围不确定</p> 
<pre><code class="language-cpp">void TestFor(int array[])
{
    for(auto&amp; e : array)
    cout&lt;&lt; e &lt;&lt;endl;
}</code></pre> 
<p><strong>2. 迭代的对象要实现++和==的操作。</strong><br>  </p> 
<h1 id="10.%20%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BCnullptr(C%2B%2B11)">10. 指针空值nullptr(C++11)</h1> 
<p>在良好的C/C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的错误，比如未初始化的指针。</p> 
<p>如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化：<br>  </p> 
<pre><code class="language-cpp">void TestPtr()
{
    int* p1 = NULL;
    int* p2 = 0;
    // ……
}</code></pre> 
<p>NULL实际是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码：</p> 
<pre><code class="language-cpp">#ifndef NULL
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
#endif</code></pre> 
<p>可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如：<br>  </p> 
<pre><code class="language-cpp">void f(int)
{
    cout&lt;&lt;"f(int)"&lt;&lt;endl;
}
void f(int*)
{
    cout&lt;&lt;"f(int*)"&lt;&lt;endl;
}
int main()
{
    f(0);
    f(NULL);
    f((int*)NULL);
    return 0;
}</code></pre> 
<p>结果如下：</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/3c/69/m9WnCaZr_o.png" width="681"> </p> 
<p> </p> 
<p>程序本意是想通过f(NULL)调用指针版本的f(int*)函数，但是由于NULL被定义成0，因此与程序的初衷相悖。</p> 
<p>在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0。</p> 
<blockquote> 
 <p><strong>注意：<br> 1. 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。<br> 2. 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。<br> 3. 为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。</strong></p> 
</blockquote>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>