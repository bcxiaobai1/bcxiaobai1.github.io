<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>rocketmq入门笔记 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">rocketmq入门笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <h2>
<a id="_0"></a>消息队列经典场景</h2> 
<h4>
<a id="_1"></a>优点</h4> 
<ol>
<li>异步 
  <ul><li>原来的下单场景只是用户支付即可结束,现在需要发送成功短信,给用户增加积分,订阅物流信息等等,这就使得用户的 下单时间大大加长,这样就可以使用消息队列,把各个动作发到消息队列,每个服务再去拉取消息队列中的东西进行处理.大大减少时间</li></ul> </li>
<li>解耦:增加积分,发送短信这些可以单独拆分出来,需要使用直接发送到知道的消息队列就行,你只需要关注你当前的业务</li>
<li>削峰: 如果使用线程池来解决,一个服务一个线程在高峰期你的mysql或者redis可能撑不住,使用mq就可以限制主机每次只拉取多少条进行处理</li>
</ol> 
<h4>
<a id="_7"></a>缺点</h4> 
<ol>
<li>可用性降低<br> 引入了mq,一旦mq宕机对业务有影响</li>
<li>复杂度提高<br> 数据链路变得复杂,如何保证顺序性,不重复消费</li>
<li>一致性问题<br> 用户支付了,增加积分出错该怎么处理<br> <img src="https://images2.imgbox.com/76/06/0Lks9lFI_o.png" alt="">
</li>
</ol> 
<h2>
<a id="_15"></a>整体架构</h2> 
<p><img src="https://images2.imgbox.com/ab/c7/drS6eCoW_o.png" alt=""></p> 
<ol>
<li>nameserver 相当于注册中心,连接从这里取ip</li>
<li>broker 消息仓库,里面有topic与队列</li>
<li>product,consumer生产者消费者</li>
</ol> 
<h2>
<a id="_20"></a>安装</h2> 
<ol>
<li>基本的环境<code>yum install java-1.8.0-openjdk-devel.x86_64 wget vim unzip -y</code>
</li>
<li>下载mq安装包<code>wget https://archive.apache.org/dist/rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip</code>
</li>
<li>解压缩<code>unzip rocketmq-all-4.7.1-bin-release.zip -d /usr/local/</code>
</li>
<li>启动nameserver服务 
  <ol>
<li><code>vim bin/runserver.sh</code></li>
<li>默认堆初始化最大都是4g,新生代2g,测试机没这么内存,不修改无法启动,改为256m,新生代128m<code>JAVA_OPT="${JAVA_OPT} -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</code>
</li>
<li>后台启动<code>nohup bin/mqnamesrv &gt; n1.out &amp;</code>
</li>
</ol> </li>
<li>启动broker服务 
  <ol>
<li><code>vim bin/runbroker.sh</code></li>
<li>默认堆初始化最大都是8g,新生代4g,测试机没这么内存,不修改无法启动,改为512m,新生代256m<code>JAVA_OPT="${JAVA_OPT} -server -Xms512m -Xmx512m -Xmn256m"</code>
</li>
<li>暴露namserver地址<code>echo 'export NAMESRV_ADDR=localhost:9876' &gt;&gt; ~/.bash_profile</code>
</li>
<li>后台启动<code>nohup bin/runbroker.sh &gt;n2.out &amp;</code>
</li>
</ol> </li>
<li>日志验证 
  <ul>
<li>n1.out <code>The Name Server boot success. serializeType=JSON</code>
</li>
<li>n2.out <code>The broker[localhost.localdomain, 192.168.147.134:10911] boot success. serializeType=JSON and name server is localhost:9876</code>
</li>
</ul> </li>
<li>发送接收测试 
  <ol>
<li>发送<code>bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</code>
</li>
<li>接收<code>bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</code>
</li>
</ol> </li>
<li>关闭 
  <ul>
<li>关闭nameserver服务<code>bin/mqshutdown namesrv</code>
</li>
<li>关闭broker服务<code>bin/mqshutdown broker</code>
</li>
</ul> </li>
</ol> 
<h2>
<a id="_43"></a>集群</h2> 
<ol><li>4种高可用集群 
  <ul>
<li>多master模式 
    <ul>
<li>优点:配置简单,性能最高</li>
<li>缺点:单个宕机,这台机器上违背消费的消息不可订阅</li>
</ul> </li>
<li>多master多salve 异步复制 
    <ul>
<li>优点:消息丢失少(异步复制),消息实时性不受到影响,master宕机可以从slave上消费,性能与多master基本一致</li>
<li>缺点:master宕机下会丢失少量消息</li>
</ul> </li>
<li>多master多salve 同步双写 
    <ul>
<li>优点:master宕机,消息无延迟,可用性高</li>
<li>缺点:性能有所丢失</li>
</ul> </li>
<li>dledger模式:4.5版本之前采用master-slave架构部署但是master挂掉都slave无法自动晋升为master,这种模式可以将多个master-slave组成一个组,当组内master挂了将选举一个master继续服务</li>
</ul> </li></ol> 
<h3>
<a id="_56"></a>集群搭建</h3> 
<p><img src="https://images2.imgbox.com/db/72/7VmidvK2_o.png" alt=""></p> 
<ol><li>修改vim conf/2m-2s-async/broker-a.properties配置文件</li></ol> 
<pre><code>#名字一样一个集群
brokerClusterName=DefaultCluster
#名字一样一个主从
brokerName=broker-a
# 0表示master &gt;0标识slave
brokerId=0
# 删除文件时间
deleteWhen=04
# namesrv集群
namesrvAddr=work1:9876;work2:9876
# 默认创建队列数
defaultTopicQueueNums=4
# 自动创建队列
autoCreateTopicEnable=true
# 对外监听端口
listenPort=10911
#文件保留时间 默认48h
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#强制销毁文件间隔时间
#destroyMapedFileIntervalForcibly=120000
#重载文件时间
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间 
diskMaxUsedSpaceRatio=88
#存储路径 
storePathRootDir=/usr/local/rocketmq-all-4.7.1-bin-release/store
#commitLog 存储路径 
storePathCommitLog=/usr/local/rocketmq-all-4.7.1-bin-release/store/commitlog
#消费队列存储路径存储路径 
storePathConsumeQueue=/usr/local/rocketmq-all-4.7.1-bin-release/store/consumequeue
#消息索引存储路径 
storePathIndex=/usr/local/rocketmq-all-4.7.1-bin-release/store/index
#checkpoint 文件存储路径 
storeCheckpoint=/usr/local/rocketmq-all-4.7.1-bin-release/store/checkpoint
#abort 文件存储路径
abortFile=/usr/local/rocketmq-all-4.7.1-bin-release/store/abort
#限制的消息大小 
maxMessageSize=65536 
#flushCommitLogLeastPages=4 
#flushConsumeQueueLeastPages=2 
#flushCommitLogThoroughInterval=10000 
#flushConsumeQueueThoroughInterval=60000 
#Broker 的角色 
#- ASYNC_MASTER 异步复制Master 
#- SYNC_MASTER 同步双写Master 
#- SLAVE 
brokerRole=ASYNC_MASTER 
#刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 
flushDiskType=ASYNC_FLUSH 
#checkTransactionMessageEnable=false 
#发消息线程池数量 
#sendMessageThreadPoolNums=128 
#拉消息线程池数量 
#pullMessageThreadPoolNums=128
</code></pre> 
<ol start="2">
<li>将broker-a.properties写入到broker-b-s.properties修改brokerName,brokerId,brokerRole和几个文件存储路径,同一台虚拟机注意端口号也需要修改</li>
<li>克隆当前虚拟机,修改broker-a-s.properties,broker-b.properties文件</li>
<li>修改host文件<code>vim /etc/hosts</code>
</li>
</ol> 
<pre><code>192.168.147.134 work1
192.168.147.135 work2
</code></pre> 
<ol start="5">
<li>启动两台nameserver<code>nohup bin/mqnamesrv &gt;n1.out &amp;</code>
</li>
<li>启动broker,使用-c指定配置文件<code>nohup bin/mqbroker -c conf/2m-2s-async/broker-b-s.properties &gt;nb.out &amp;</code>
</li>
<li>关闭防火墙或者开放9876,两个broker服务的端口<code>firewall-cmd --zone=public --add-port=9876/tcp --add-port=10911/tcp --add-port=11011/tcp --permanent``firewall-cmd --reload</code>
</li>
<li>四个broker服务都启动后验证集群<code>bin/mqadmin clusterList -n work1:9876</code> 
  <ul>
<li>这里可能会报错<code>Caused by: java.security.NoSuchAlgorithmException: Algorithm HmacSHA1 not available</code>
</li>
<li>解决方法:<a href="https://blog.csdn.net/weixin_38232096/article/details/108823827">出处:一篇文章彻底解决RocketMq的疑难杂症之：org.apache.rocketmq.client.exception.MQClientException: No route info of thi</a><code>cp /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64/jre/lib/ext/sunjce_provider.jar /usr/local/rocketmq-all-4.7.1-bin-release/lib</code>具体以实际目录为准</li>
<li>成功:两主两从<br> <img src="https://images2.imgbox.com/1e/c6/KR0A9UYM_o.png" alt="">
</li>
</ul> </li>
</ol> 
<h3>
<a id="_135"></a>控制台搭建</h3> 
<ol>
<li>项目地址<a href="https://github.com/apache/rocketmq-dashboard.git">rocketmq-dashboard</a>
</li>
<li>项目克隆<code>git clone https://github.com/apache/rocketmq-dashboard.git</code>
</li>
<li>打开rocketmq-console导入idea,修改application.properties文件<code>rocketmq.config.namesrvAddr=work1:9876;work2:9876</code>以实际情况修改</li>
<li>打包项目上传jar包,启动<code>nohup java -jar rocketmq-console-ng-2.0.0.jar &amp;</code>
</li>
<li>打开浏览器访问当前服务器8080端口<img src="https://images2.imgbox.com/a5/4b/XXWHqZ4U_o.png" alt="">
</li>
</ol> 
<h3>
<a id="dledger_142"></a>dledger集群搭建</h3> 
<ol>
<li>快速演示 
  <ol>
<li>在<code>bin/dledger/fast-try.sh</code>快速演示的脚本,但脚本给一个broker的内存是1g,虚拟机没有这么大修改一下</li>
<li>这里我修改为256m<pre><code>function startNameserver() {
    export JAVA_OPT_EXT=" -Xms256m -Xmx256m  "
    nohup bin/mqnamesrv &amp;
}

function startBroker() {
    export JAVA_OPT_EXT=" -Xms256m -Xmx256m  "
    conf_name=$1
    nohup bin/mqbroker -c $conf_name &amp;
}
</code></pre> </li>
<li>启动<code>bin/dledger/fast-try.sh start</code>
</li>
<li>查看集群情况<code>bin/mqadmin clusterList -n 127.0.0.1:9876</code><br> <img src="https://images2.imgbox.com/64/f3/UsknbaE6_o.png" alt="">
</li>
<li>查询master节点进程号并把它kill,看slave是否能转为master<br> <img src="https://images2.imgbox.com/7e/a7/659eaP4r_o.png" alt="">
</li>
</ol> </li>
<li>实际搭建 
  <ol><li>配置文件增加一下几条</li></ol> <pre><code>#是否启动dledger
enableDLegerCommitLog=true
#组名与brokerName保持一致
dLegerGroup=broker-a
#当前组所有主机-专门监听端口号
dLegerPeers=n0-192.168.147.134:40911;n1-192.168.147.135:49011;n2-192.168.147.134:40912
#当前主机id
dLegerSelfId=n0
</code></pre> 
  <ol start="2">
<li>集群搭建成功<br> <img src="https://images2.imgbox.com/3a/be/zefV36U8_o.png" alt="">
</li>
<li>直接把135主机关机了</li>
<li>切换成功<br> <img src="https://images2.imgbox.com/e7/60/TnxmGlsM_o.png" alt="">
</li>
</ol> </li>
</ol> 
<h3>
<a id="_180"></a>基本概念</h3> 
<h4>
<a id="_181"></a>消息模型</h4> 
<p>producer生产消息，consumer消费消息，broker存储消息，每个broker对于一台服务器，每个broker可以存储多个opic消息，每个topic消息也可以分片存储于不同的broker上，message queue用于存储多个消息的物理地址，每个topic消息存储于多个message queue中</p> 
<h4>
<a id="_183"></a>生产者</h4> 
<p>producer负责生产消费，将消费者消息发送到broker上，有多种发送方式：同步发送，异步发送，顺序发送，单向发送，同步与异步需要broker返回确认消息，单向发送不需要。同一类producer组成一个集合为生产组发送同一类消息且逻辑一致，如果有异常，broker服务器会联系同一生产者组提交或回滚</p> 
<h4>
<a id="_185"></a>消费者</h4> 
<p>consumer消息者形式分为两种：</p> 
<ol>
<li>拉取式：主动式消费，消费者调用拉取的方法</li>
<li>推动式消费：broker有数据就会推给消费者<br> 消费者组必须订阅同一个topic，消息模式两种：</li>
<li>集群消费模式：平摊消费</li>
<li>广播消费模式：共享消费</li>
</ol> 
<h4>
<a id="_193"></a>主题</h4> 
<p>每个topic若干个消息，每个消息只能有一个主题，同一个topic下的数据分片保存到不同的broker，每个分片单位是messageQueue</p> 
<h4>
<a id="_195"></a>代理服务器</h4> 
<ul>
<li>几个模块<br> <img src="https://images2.imgbox.com/b7/b3/fXrjkjWk_o.png" alt=""> 
  <ul>
<li>remoting module:处理来自clients的请求</li>
<li>client manager:负责管理客户端和维护消费者的topic订阅信息</li>
<li>store service:处理消息的存储查询功能</li>
<li>ha service:高可用服务,负责master与slave的数据同步</li>
<li>index service:索引服务,以提高查询</li>
</ul> </li>
<li>普通集群 
  <ul><li>每个节点固定角色,master负责响应客户端请求并存储消息,slave负责同步数据并响应客户端部分读请求</li></ul> </li>
<li>dledger高可用集群 
  <ul>
<li>dledger 
    <ol>
<li>接管broker的commitlog消息存储</li>
<li>选举leader节点</li>
<li>完成消息同步</li>
</ol> </li>
<li>多副本消息同步<br> leader收到消息会将消息标记为uncommited状态,发给follower,follower收到消息后需要给leader返回一个ack,如果有超过半数的follower返回ack就会把消息改为commited状态,发给follower</li>
<li>leader选举机制 
    <ul>
<li>每个节点有三个状态,leader,follower,candidate(候选人)</li>
<li>每个时间点叫做term</li>
<li>集群启动时,每个节点都是follower,集群内部发送一个timeout信号,follower转为候选人,发起投票后收到半数以上的投票晋升为leader,</li>
<li>选举过程,集群启动,三个节点都是follower,三个节点都给自己投票,term都是1,三个节点随机休眠,a启动term加一为2,第二个节点醒来,发现a的term比自己大,承认a是leader,c同理</li>
</ul> </li>
</ul> </li>
</ul> 
<h4>
<a id="_218"></a>名字服务器</h4> 
<p>充当路由消息的提供者,broker会在启动时向nameserver注册自己的服务信息,后续通过心跳维护当前服务的可用性,生产者或消费者通过名字服务查找各主题消息相应的broker ip列表</p> 
<h4>
<a id="_221"></a>消息</h4> 
<p>每个消息都必须拥有一个topic,每个消息拥有唯一的message id,且可以携带业务标识key, 可以为消息设置一个tag标签</p> 
<h4>
<a id="_224"></a>消息存储</h4> 
<h5>
<a id="_225"></a>消息存储</h5> 
<ul>
<li>时间 
  <ul>
<li>mq收到消息标记为uncommit状态发给follower,follower收到消息,发给leader一个ack,超过半数follower返回ack,消息改为commit状态,存储,状态同步给follower</li>
<li>mqpush消息给消费者,等待消费者ack响应,标记为已消费,没有标记消息会重复推送</li>
<li>mq会定期删除一些过期的消息</li>
</ul> </li>
<li>存储介质:磁盘文件(采用顺序读写,保证存储的速度,采用mmap的方式,省去上下文切换,提高速度)</li>
</ul> 
<h5>
<a id="_232"></a>消息存储结构</h5> 
<ol>
<li>commitlog:存储消息元数据,每个文件1个G</li>
<li>consumerQueue:消息队列,保存commitlog的索引</li>
<li>indexFile:提供通过key或时间来查询消息的方法</li>
</ol> 
<h5>
<a id="_238"></a>刷盘机制</h5> 
<ol>
<li>同步刷盘:消息写入机器的内存时,通知刷盘线程刷盘,等待刷盘线程写入完成后唤醒线程,返回写入完成 
  <ul>
<li>优点:稳定安全</li>
<li>缺点:性能不如异步</li>
</ul> </li>
<li>异步刷盘:消息写入内存后,返回写入完成,当内存累计到一定程度是统一触发刷盘操作 
  <ul>
<li>优点:吞吐量大</li>
<li>缺点:一旦服务器断电丢失部分消息</li>
</ul> </li>
</ol> 
<h5>
<a id="_245"></a>主从复制</h5> 
<ol>
<li>同步复制:生产者发送消息,只有master与slave(半数slave)写入成功才反馈生产者写入成功</li>
<li>异步复制:生产者发送消息,只要master写入消息成功,就反馈生产者写入成功,再异步将消息同步到slave</li>
</ol> 
<h5>
<a id="_248"></a>负载均衡</h5> 
<ol>
<li>生产者负载均衡: 
  <ul><li>生产者发送消息时,获取当前topic下所有broker集合,采用取模递增算法将消息往不同的broker上发送</li></ul> </li>
<li>消费者负载均衡 
  <ul>
<li>集群模式:六种分配算法 
    <ol>
<li>AllocateMachineRoomNearby:同机房的消费者与broker分配一起</li>
<li>AllocateMessageQueueAveragely:平均分配,将所有消息队列平均分配给消费者,先算数后分配</li>
<li>AllocateMessageQueueAveragelyByCircle:先轮流给消费者分配一个队列,后面再增加</li>
<li>AllocateMessageQueueByConfig:直接指定所有队列</li>
<li>AllocateMessageQueueByMachineRoom:按逻辑机房进行分配</li>
<li>AllocateMessageQueueConsistentHash:</li>
</ol> </li>
<li>广播模式:每个消费者分配所有的队列</li>
</ul> </li>
</ol> 
<h5>
<a id="_260"></a>消息重试</h5> 
<p>广播模式下不存在消息重试,会直接消费下一条</p> 
<ol>
<li>如何重试<br> 消息监听器中配置 
  <ol>
<li>返回Action.ReconsumeLater</li>
<li>返回null</li>
<li>抛出异常<br> 不重试返回Action.CommitMessage</li>
</ol> </li>
<li>重试处理<br> 重试的消息会进入“%RETRY%”+ConsumeGroup队列,最多16次,16次后会进入死信队列,可配置例如20次,16次后酶促间隔2h<br> 16次每次间隔10s,30s,1m,2m,3m,4m,5m,6m,7m,8m,9m,10m,20m,30m,1h,2h</li>
<li>messageId<br> 老版本中,无论重试多少次messageId是相同的,4.7.1中每次重试messageId会重建</li>
<li>配置覆盖<br> 最大重试次数对同一个消费组实例有效,最后启动的消费者会覆盖之前的配置</li>
</ol> 
<h5>
<a id="_275"></a>死信队列</h5> 
<ol>
<li>一个死信队列对于一个消费组,而不是一个消费者</li>
<li>一个消费组不需要死信队列是不会创建死信队列的</li>
<li>一个死信队列包含这个消费组所有无法消费的消息,不区分主题</li>
<li>消息无法再被消费者正常消费</li>
<li>默认存储3天,不管是否消费被删除</li>
<li>默认死信队列中的消息无法读取,需要将权限配置为6</li>
</ol> 
<h5>
<a id="_282"></a>消息幂等</h5> 
<p>当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这整个过程就可实现消息幂等。支付时重复提交了多次但最后还是只支付了一次的钱</p> 
<ul>
<li>三种实现语义 
  <ul>
<li>at most once:每条消息最多消费一次</li>
<li>at least once:每条消息至少消费一次</li>
<li>exactly one:确定消费一次<br> rocketmq支持at least once语义</li>
</ul> </li>
<li>消息重复情况 
  <ul>
<li>发送重复:消息发送到服务端并且持久化了,网络断开或者宕机了,生产者判断发送失败了会造次发送</li>
<li>投递重复:消费者收到消息并完成业务处理了,准备发送消息接收时宕机了,服务端在恢复后会再次发送一遍这个消息</li>
<li>负载均衡时消息重复:broker服务重启,扩容,缩容会触发rebalance造成消费者收到重复的消息</li>
</ul> </li>
<li>解决: 
  <ul>
<li>业务唯一标识:例如订单号</li>
<li>利用数据库唯一索引或主键索引</li>
<li>利用redis判断</li>
</ul> </li>
</ul> 
<h3>
<a id="_297"></a>实操</h3> 
<p><a href="https://github.com/apache/rocketmq/issues/2139">dledger模式不支持批量发送/升级v4.8+</a></p> 
<h4>
<a id="_299"></a>基础消息</h4> 
<h5>
<a id="_300"></a>发送者</h5> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>jaminye<span class="token punctuation">.</span>sample<span class="token punctuation">.</span>producer</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">MQBrokerException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">MQClientException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">DefaultMQProducer</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">SendResult</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>common<span class="token punctuation">.</span>message<span class="token punctuation">.</span></span><span class="token class-name">Message</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>remoting<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">RemotingException</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @author Jamin
 * @date 2021/8/15 9:36
 */</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span><span class="token punctuation">,</span> <span class="token class-name">RemotingException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">MQBrokerException</span> <span class="token punctuation">{<!-- --></span>

		<span class="token class-name">DefaultMQProducer</span> product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"product"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		product<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"192.168.147.134:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		product<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">/**
		 * 同步发送
		 */</span>
		<span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"java-topic"</span><span class="token punctuation">,</span> <span class="token string">"hello-world"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> product<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">/**
		 * 批量发送 topic必须相同
		 */</span>
		<span class="token comment">/*Message message1 = new Message("batch-topic2", "hello-world1".getBytes());
		Message message2 = new Message("batch-topic2", "hello-world2".getBytes());
		Message message3 = new Message("batch-topic2", "hello-world3".getBytes());
		List&lt;Message&gt; messages = new ArrayList&lt;&gt;(8);
		messages.add(message1);
		messages.add(message2);
		messages.add(message3);
		SendResult sendResult = product.send(messages);*/</span>
		<span class="token comment">/**
		 *异步发送
		 */</span>
		<span class="token comment">/*CountDownLatch countDownLatch = new CountDownLatch(1);
		Message message = new Message("async-topic", "async-topic".getBytes());
		product.send(message, new SendCallback() {
			@Override
			public void onSuccess(SendResult sendResult) {
				countDownLatch.countDown();
			}

			@Override
			public void onException(Throwable throwable) {
				System.err.println(throwable.getMessage());
			}
		});
		countDownLatch.await();*/</span>
		<span class="token comment">/**
		 * 单向发送
		 */</span>
		<span class="token comment">//主题,标签,key,内容</span>
		<span class="token comment">/*Message message = new Message("send-one-way", "tag1", "1", "send-one-way".getBytes());
		product.sendOneway(message);
		//这种方法无返回值,等待发送完成
		Thread.sleep(5000);*/</span>

		<span class="token comment">// System.out.println("=================发送结果=============" + sendResult);</span>
		product<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h5>
<a id="_371"></a>消费者</h5> 
<pre><code>package cn.jaminye.sample.consumer;

/**
 * 拉
 *
 * @author Jamin
 * @date 2021/8/15 14:48
 */
public class Consumer {
	/**
	 * 拉模式
	 *
	 * @param args
	 * @author Jamin
	 * @date 2021/8/16 10:13
	 */
	// public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException {
	// 	/**
	// 	 * 拉模式,已弃用方式
	// 	 */
	// 	/*DefaultMQPullConsumer consumer = new DefaultMQPullConsumer("pull-group");
	// 	consumer.setNamesrvAddr("192.168.147.134:9876");
	// 	consumer.start();
	// 	MessageQueue messageQueue = new MessageQueue();
	// 	messageQueue.setQueueId(2);
	// 	messageQueue.setBrokerName("broker-a");
	// 	messageQueue.setTopic("java-topic");
	// 	PullResult pullResult = consumer.pullBlockIfNotFound(messageQueue, null, 0, 2);
	// 	pullResult.getMsgFoundList().forEach(System.out::println);
	// 	consumer.shutdown();*/
	// 	/**
	// 	 * 现用
	// 	 */
	// 	DefaultLitePullConsumer consumer = new DefaultLitePullConsumer("pull-group");
	// 	consumer.setNamesrvAddr("192.168.147.134:9876");
	// 	consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
	// 	consumer.subscribe("java-topic", "*");
	// 	consumer.start();
	// 	List&lt;MessageExt&gt; messageExtList = consumer.poll();
	// 	messageExtList.forEach(System.out::println);
	// 	consumer.shutdown();
	// }

	/**
	 * 推模式
	 *
	 * @param args
	 * @author Jamin
	 * @date 2021/8/16 10:13
	 */
	/*public static void main(String[] args) throws MQClientException {
		DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("pull-group");
		consumer.setNamesrvAddr("192.168.147.134:9876");
		consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
		consumer.subscribe("java-topic", "*");
		//负载
		consumer.setAllocateMessageQueueStrategy(new AllocateMessageQueueAveragelyByCircle());
		consumer.registerMessageListener(new MessageListenerConcurrently() {
			@Override
			public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
				System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), list);
				return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
			}
		});
		consumer.start();

	}*/


}
</code></pre> 
<h4>
<a id="_444"></a>顺序消息</h4> 
<h5>
<a id="_445"></a>生产者</h5> 
<pre><code>package cn.jaminye.order.product;

import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.client.producer.MessageQueueSelector;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.apache.rocketmq.remoting.exception.RemotingException;

import java.io.UnsupportedEncodingException;
import java.util.List;

/**
 * @author Jamin
 * @date 2021/8/16 10:24
 */
public class Product {
	public static void main(String[] args) throws MQClientException, UnsupportedEncodingException, RemotingException, InterruptedException, MQBrokerException {
		DefaultMQProducer producer = new DefaultMQProducer("order-group");
		producer.setNamesrvAddr("192.168.147.134:9876");
		producer.start();
		String[] strings = {"下单", "付款", "生成订单"};
		for (int i = 0; i &lt; 100; i++) {
			for (int j = 0; j &lt; 3; j++) {
				String s = "订单__" + i + "___" + strings[j];
				Message message = new Message("order-topic", s.getBytes(RemotingHelper.DEFAULT_CHARSET));
				//根据id取模入队列使分类消息进一个队列
				producer.send(message, new MessageQueueSelector() {
					@Override
					public MessageQueue select(List&lt;MessageQueue&gt; list, Message message, Object o) {
						int index = ((Integer) o) % list.size();
						return list.get(index);
					}
				}, i);
			}
		}
		producer.shutdown();
	}
}
</code></pre> 
<h5>
<a id="_489"></a>消费者</h5> 
<pre><code>package cn.jaminye.order.consumer;

import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.MessageExt;

import java.util.List;

/**
 * @author Jamin
 * @date 2021/8/16 10:36
 */
public class Consumer {
	public static void main(String[] args) throws Exception {
		DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("order-consumer");
		//消费组订阅的消息未过期从头开始,已过期从当前开始
		consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
		consumer.subscribe("order-topic", "*");
		consumer.setNamesrvAddr("192.168.147.134:9876");
		//顺序取
		consumer.registerMessageListener(new MessageListenerOrderly() {
			@Override
			public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext) {
				list.stream().map(messageExt -&gt; new String(messageExt.getBody())).forEach(System.out::println);
				return ConsumeOrderlyStatus.SUCCESS;
			}
		});
		/*consumer.registerMessageListener(new MessageListenerConcurrently() {
			@Override
			public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
				list.stream().map(messageExt -&gt; new String(messageExt.getBody())).forEach(System.out::println);
				return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
			}
		});*/
		consumer.start();
	}
}
</code></pre> 
<h4>
<a id="_532"></a>广播消息</h4> 
<p><code>consumer.setMessageModel(MessageModel.BROADCASTING);</code></p> 
<h4>
<a id="_534"></a>延迟消息</h4> 
<pre><code>//1-18 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
message1.setDelayTimeLevel(3);
</code></pre> 
<h4>
<a id="_539"></a>批量消息</h4> 
<pre><code>/**
 * 批量发送 topic必须相同  官方示例中小于1m 不能是延迟,事务消息
 */
Message message1 = new Message("batch-topic2", "hello-world1".getBytes());
Message message2 = new Message("batch-topic2", "hello-world2".getBytes());
Message message3 = new Message("batch-topic2", "hello-world3".getBytes());
List&lt;Message&gt; messages = new ArrayList&lt;&gt;(8);
messages.add(message1);
messages.add(message2);
messages.add(message3);
SendResult sendResult = product.send(messages);
</code></pre> 
<h4>
<a id="_553"></a>过滤消息</h4> 
<ol>
<li>表达式过滤<br> consumer.subscribe(“filter-topic”, “TAG1 || TAG2”);</li>
<li>sql过滤</li>
</ol> 
<ul>
<li>需要配置<code>enablePropertyFilter=true</code>
</li>
<li><code>message1.putUserProperty("a", "1");</code></li>
<li><code>consumer.subscribe("filter-topic", MessageSelector.bySql("TAGS IN ('TAG1','TAG2') AND a between 0 and 1 "));</code></li>
<li>基本语法<code>&gt;,&lt;,&gt;=,between,in,and,or,not</code>等</li>
</ul> 
<h4>
<a id="_561"></a>事务消息</h4> 
<ul>
<li>代码<pre><code>//组名不能与其他组名相同
TransactionMQProducer transactionGroupProducer = new TransactionMQProducer("transactionGroup");
ExecutorService executorService = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(100));
transactionGroupProducer.setExecutorService(executorService);
transactionGroupProducer.setNamesrvAddr("192.168.147.134:9876");
TransactionListenerImpl transactionListener = new TransactionListenerImpl();
transactionGroupProducer.setTransactionListener(transactionListener);
transactionGroupProducer.start();
for (int i = 0; i &lt; 10; i++) {
	Message message = new Message("transaction-topic", String.valueOf(i).getBytes());
	message.putUserProperty("name", String.valueOf(i));
	TransactionSendResult transactionSendResult = transactionGroupProducer.sendMessageInTransaction(message, null);
	System.out.println(transactionSendResult.getSendStatus());
}
}
</code></pre> <pre><code>public class TransactionListenerImpl implements TransactionListener {
	@Override
	public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {

		try {
			//开启事务
			//	do something
			if ("1".equals(msg.getProperty("name"))) {
				System.out.println("unknow");
				return LocalTransactionState.UNKNOW;
			}
			System.out.println("success");
			return LocalTransactionState.COMMIT_MESSAGE;
		} catch (Exception ex) {
			System.out.println("回滚事务");
			return LocalTransactionState.ROLLBACK_MESSAGE;
		}


	}

	@Override
	public LocalTransactionState checkLocalTransaction(MessageExt msg) {
		System.out.println("进入check");
		//	do something query db
		return true ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.UNKNOW;

	}
}
</code></pre> </li>
<li>流程 
  <ol>
<li>发送消息到服务端,这个消息暂存在服务端,不会被消费者读取到</li>
<li>持久化成功后会返回生产者一个ack,确认消息是否成功</li>
<li>成功回调执行executeLocalTransaction方法,执行本地事务,持久化到数据库类的操作,这块的回滚自行处理,最终返回本地事务的执行结果</li>
<li>根据返回结果进行操作,commit的话会将当前消息移动到实际的topic下,回滚就删除消息</li>
<li>如果本地事务返回unknown,服务端会定时调用checkLocalTransaction方法进行查询,最多15次</li>
<li>根据checkLocalTransaction方法进行执行回滚或者提交</li>
</ol> </li>
</ul> 
<h4>
<a id="acl__618"></a>acl 权限控制</h4> 
<ol><li>开启权限控制</li></ol> 
<pre><code>aclEnable=true
</code></pre> 
<ol start="2"><li>配置文件</li></ol> 
<pre><code>#全局白名单
globalWhiteRemoteAddresses:
#- 192.168.147.*

accounts:
- accessKey: RocketMQ
  secretKey: 12345678
 #白名单地址
  whiteRemoteAddress:
  admin: false
  defaultTopicPerm: DENY
  defaultGroupPerm: SUB
  #针对每个主题
  topicPerms:
  - topicA=DENY
  - topicB=PUB|SUB
  - topicC=SUB
  - java-topic=DENY
  groupPerms:
  # the group should convert to retry topic
  - groupA=DENY
  - groupB=PUB|SUB
  - groupC=SUB
  - product2=DENY
- accessKey: rocketmq2
  secretKey: 12345678
  whiteRemoteAddress: 192.168.1.*
  # if it is admin, it could access all resources
  admin: true
</code></pre> 
<ol start="3"><li>代码</li></ol> 
<pre><code class="prism language-java"><span class="token class-name">DefaultMQProducer</span> product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"product2"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">AclClientRPCHook</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SessionCredentials</span><span class="token punctuation">(</span><span class="token string">"RocketMQ"</span><span class="token punctuation">,</span> <span class="token string">"12345678"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
product<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"192.168.147.134:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
product<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"java-topic"</span><span class="token punctuation">,</span> <span class="token string">"hello-world"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> product<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
product<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="springbootrocketmq_666"></a>springboot整合rocketmq</h3> 
<h4>
<a id="_668"></a>依赖</h4> 
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<h4>
<a id="_676"></a>配置</h4> 
<pre><code>rocketmq.name-server=192.168.147.134:9876
rocketmq.consumer.group=springboot-group
</code></pre> 
<h4>
<a id="_681"></a>普通消息发送</h4> 
<pre><code>@Component
public class SpringProducer {
	@Resource
	RocketMQTemplate mqTemplate;

	public void sendMessage() {
		Message&lt;String&gt; message = MessageBuilder.withPayload("12345").build();
		//topic:tag
		mqTemplate.syncSend("topic-1" + ":" + "TAG1", message, 100000);
		mqTemplate.syncSend("topic-1" + ":" + "TAG2", message, 100000);
	}

}
</code></pre> 
<pre><code>@Component
// selectorType 过滤使用tag还是sql selectorExpression tag或者sql consumeMode顺序还是正常的 messageModel广播还是集群
@RocketMQMessageListener(topic = "topic-1", consumerGroup = "springboot-group", selectorType = SelectorType.SQL92, selectorExpression = "TAGS='TAG1'", consumeMode = ConsumeMode.CONCURRENTLY,
		messageModel = MessageModel.CLUSTERING)
public class SpringConsumer implements RocketMQListener&lt;String&gt; {
	@Override
	public void onMessage(String s) {
		System.out.println(s);
	}
}
</code></pre> 
<h5>
<a id="_712"></a>事务消息</h5> 
<pre><code>@Component
public class Producer {
	@Resource
	RocketMQTemplate rocketMQTemplate;

	public void sendMessage() {
		Message&lt;String&gt; message1 =
				MessageBuilder.withPayload("123").setHeader(RocketMQHeaders.TRANSACTION_ID, "1").setHeader(RocketMQHeaders.TOPIC, "123")
						.setHeader(RocketMQHeaders.TAGS, "1231").setHeader("a", 1).build();
		TransactionSendResult transactionSendResult = rocketMQTemplate.sendMessageInTransaction("springboot-producer1:TAG1", message1, null);
		System.out.println(transactionSendResult);
	}
}
</code></pre> 
<pre><code>@RocketMQTransactionListener
public class Listener implements RocketMQLocalTransactionListener {
	@Override
	public RocketMQLocalTransactionState executeLocalTransaction(Message message, Object o) {
		System.out.println("message===============" + message);
		// 获取时添加前缀RocketMQHeaders.PREFIX
		String tags = message.getHeaders().get(RocketMQHeaders.PREFIX + RocketMQHeaders.TAGS, String.class);
		System.out.println("id==================" + tags);
		System.out.println("UNKNOWN==================");
		return RocketMQLocalTransactionState.UNKNOWN;
	}

	@Override
	public RocketMQLocalTransactionState checkLocalTransaction(Message message) {
		System.out.println("message===============" + message.getPayload());
		return RocketMQLocalTransactionState.COMMIT;
	}
}
</code></pre> 
<h5>
<a id="_748"></a>总结</h5> 
<ol>
<li>使用RocketMQTemplate进行发送消息,相关属性都以rocketmq_开头</li>
<li>topic:tags</li>
</ol> 
<h3>
<a id="_752"></a>源码阅读</h3> 
<h4>
<a id="_753"></a>环境搭建</h4> 
<ol>
<li>源码地址 <a href="https://github.com/apache/rocketmq/releases">源码地址</a> 使用4.7.1版本源码</li>
<li>在项目根目录下创建conf文件夹,复制distribution下broker.conf,logback_broker.xml,logback_nameserv.xml三个文件到conf下</li>
<li>在本机添加环境变量ROCKETMQ_HOME指向项目根目录</li>
<li>启动nameser</li>
<li>修改conf目录下的broker.conf 添加namesrvAddr,storePathRootDir,storePathRootDir,storePathCommitLog,storePathConsumeQueue,storePathIndex,storeCheckpoint,abortFile等参数具体可参考上方配置</li>
<li>启动broker 配置启动参数-c broker.conf文件地址</li>
</ol> 
<h4>
<a id="namesever_760"></a>namesever</h4> 
<ol>
<li>配置信息:创建nameseverconfig与nettyserverconfig</li>
<li>初始化,启动,监听9876端口,提供给客户端拉取路由信息</li>
<li>创建处理请求的线程与定时扫描的线程(10s扫描一次,判断最后最后更新时间+2分钟,超出会删除这个broker并关闭连接)</li>
</ol> 
<h4>
<a id="broker_764"></a>broker</h4> 
<ol>
<li>启动了很多组件</li>
<li>注册到nameserver,每30s(可以配置修改但最长为60s)发送一次心跳</li>
</ol> 
<h4>
<a id="producer_767"></a>producer</h4> 
<ol>
<li>DefaultMQProducerImpl:org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl</li>
<li>判断组名是否符合规定</li>
<li>启动各种定时任务,缓存nameserver上所有的主题,与broker建立心跳</li>
<li>发送消息采用索引自增取模的方式进行</li>
</ol> 
<h4>
<a id="_772"></a>文件存储</h4> 
<ol>
<li>org.apache.rocketmq.store.DefaultMessageStore#putMessage</li>
<li>使用零拷贝追加到commitlog,同步或异步刷盘,主从同步</li>
<li>定时任务:每10s启动启动一次,</li>
</ol>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>