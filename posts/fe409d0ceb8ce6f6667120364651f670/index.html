<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C&#43;&#43;STL：关联容器之map和multimap - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;STL：关联容器之map和multimap</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>文章目录</h3> 
 <ul>
<li><a href="#1_map_1">1. map</a></li>
<li>
<ul>
<li><a href="#_3">概述</a></li>
<li><a href="#_36">成员函数</a></li>
<li><a href="#C_map_67">创建C++ map容器的几种方法</a></li>
<li><a href="#_154">迭代器</a></li>
<li><a href="#map_322">map获取键对应值的几种方法</a></li>
<li><a href="#map_insert4_500">map insert()插入数据的4种方式</a></li>
<li><a href="#map_emplaceemplace_hint_759">map emplace()和emplace_hint()方法</a></li>
</ul> 
  </li>
<li><a href="#2_multimap_860">2. multimap</a></li>
<li>
<ul>
<li><a href="#_862">概述</a></li>
<li><a href="#_887">成员函数</a></li>
<li><a href="#C_multimap_918">创建C++ multimap容器的方法</a></li>
</ul> 
 </li>
</ul> 
</div> 
<p></p> 
<h1>
<a id="1_map_1"></a>1. map</h1> 
<h2>
<a id="_3"></a>概述</h2> 
<p>作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、结构体或类自定义的类型。 
 </p> 
<blockquote> 
 <p>通常情况下，map 容器中存储的各个键值对都选用 string 字符串作为键的类型。</p> 
</blockquote> 
<p>与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用<code>std::less&lt;T&gt;</code>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 STL 标准库中提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>），也可以自定义排序规则。</p> 
<p>另外需要注意的是，使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。</p> 
<blockquote> 
 <p>前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 pair&lt;const K, T&gt; 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。</p> 
</blockquote> 
<p>map 容器定义在 &lt;map&gt; 头文件中，并位于 std 命名空间中。因此，如果想使用 map 容器，代码中应包含如下语句：</p> 
<pre><code class="prism language-C++">#include &lt;map&gt;
using namespace std;
</code></pre> 
<blockquote> 
 <p>注意，第二行代码不是必需的，如果不用，则后续程序中在使用 map 容器时，需手动注明 std 命名空间（建议初学者使用）。</p> 
</blockquote> 
<p>map 容器的模板定义如下：</p> 
<pre><code class="prism language-C++">template &lt; class Key,                                     // 指定键（key）的类型
           class T,                                       // 指定值（value）的类型
           class Compare = less&lt;Key&gt;,                     // 指定排序规则
           class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt;    // 指定分配器对象的类型
           &gt; class map;
</code></pre> 
<p>可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。</p> 
<h2>
<a id="_36"></a>成员函数</h2> 
<p>下表出了 map 容器提供的常用成员方法以及各自的功能：</p> 
<table>
<thead><tr>
<th>成员函数</th>
<th>功能</th>
</tr></thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 map 容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>operator[]</td>
<td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。</td>
</tr>
<tr>
<td>at(key)</td>
<td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 map 容器中插入键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody>
</table> 
<h2>
<a id="C_map_67"></a>创建C++ map容器的几种方法</h2> 
<p>map 容器的模板类中包含多种构造函数，因此创建 map 容器的方式也有多种，下面介绍几种常用的创建 map 容器的方法。</p> 
<ol><li>通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器，比如：</li></ol> 
<pre><code class="prism language-c++">std::map&lt;std::string, int&gt; myMap;
</code></pre> 
<p>通过此方式创建出的 myMap 容器，初始状态下是空的，即没有存储任何键值对。鉴于空 map 容器可以根据需要随时添加新的键值对，因此创建空 map 容器是比较常用的。</p> 
<ol start="2"><li>当然在创建 map 容器的同时，也可以进行初始化，比如：</li></ol> 
<pre><code class="prism language-c++">std::map&lt;std::string, int&gt; myMap{ {"C语言教程",10},{"STL教程",20} };
</code></pre> 
<p>由此，myMap 容器在初始状态下，就包含有 2 个键值对。</p> 
<p>再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：</p> 
<pre><code class="prism language-c++">std::map&lt;std::string, int&gt; myMap{std::make_pair("C语言教程",10),std::make_pair("STL教程",20)};
</code></pre> 
<ol start="3"><li>除此之外，在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。例如：</li></ol> 
<pre><code class="prism language-c++">std::map&lt;std::string, int&gt; newMap(myMap);
</code></pre> 
<p>由此，通过调用 map 容器的拷贝（复制）构造函数，即可成功创建一个和 myMap 完全一样的 newMap 容器。</p> 
<p>C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数。举个例子：</p> 
<pre><code class="prism language-c++">// 创建一个会返回临时 map 对象的函数
std::map&lt;std::string,int&gt; disMap() {
    std::map&lt;std::string, int&gt;tempMap{ {"C语言教程",10},{"STL教程",20} };
    return tempMap;
}
// 调用 map 类模板的移动构造函数创建 newMap 容器
std::map&lt;std::string, int&gt; newMap(disMap());
</code></pre> 
<blockquote> 
 <p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p> 
</blockquote> 
<ol start="4"><li>map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。例如：</li></ol> 
<pre><code class="prism language-c++">std::map&lt;std::string, int&gt; myMap{ {"C语言教程",10},{"STL教程",20} };
std::map&lt;std::string, int&gt; newMap(++myMap.begin(), myMap.end());
</code></pre> 
<p>这里，通过调用 map 容器的双向迭代器，实现了在创建 newMap 容器的同时，将其初始化为包含一个 {“STL教程”,20} 键值对的容器。</p> 
<ol start="5"><li>当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less&lt;T&gt; 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。因此，如下 2 行创建 map 容器的方式，其实是等价的：</li></ol> 
<pre><code class="prism language-c++">std::map&lt;std::string, int&gt; myMap{ {"C语言教程",10},{"STL教程",20} };
std::map&lt;std::string, int, std::less&lt;std::string&gt; &gt; myMap{ {"C语言教程",10},{"STL教程",20} };
</code></pre> 
<p>以上 2 中创建方式生成的 myMap 容器，其内部键值对排列的顺序为：</p> 
<pre><code class="prism language-python"><span class="token operator">&lt;</span><span class="token string">"C语言教程"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token string">"STL教程"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token operator">&gt;</span>
</code></pre> 
<p>下面程序手动修改了 myMap 容器的排序规则，令其作降序排序：</p> 
<pre><code class="prism language-c++">std::map&lt;std::string, int, std::greater&lt;std::string&gt; &gt; myMap{ {"C语言教程",10},{"STL教程",20} };
</code></pre> 
<p>此时，myMap 容器内部键值对排列的顺序为：</p> 
<pre><code class="prism language-python"><span class="token operator">&lt;</span><span class="token string">"STL教程"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token string">"C语言教程"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span>
</code></pre> 
<blockquote> 
 <p>在某些特定场景中，我们还需要为 map 容器自定义排序规则。</p> 
</blockquote> 
<h2>
<a id="_154"></a>迭代器</h2> 
<p>无论是前面学习的顺序容器，还是关联容器，要想实现遍历操作，就必须要用到该类型容器的迭代器。当然，map 容器也不例外。</p> 
<p>C++ STL 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 <code>++p、p++、--p、p--、*p</code> 操作，并且迭代器之间只能使用 <code>==</code> 或者 <code>!=</code> 运算符进行比较。</p> 
<p>值得一提的是，相比顺序容器，map 容器提供了更多的成员方法（如下表所示），通过调用它们，我们可以轻松获取具有指定含义的迭代器。</p> 
<table>
<thead><tr>
<th>成员方法</th>
<th>功能</th>
</tr></thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
</tbody>
</table> 
<p>上表中多数的成员方法，诸如 begin()、end() 等，在学习顺序容器时已经多次使用过，它们的功能如下图所示：</p> 
<p><img src="https://images2.imgbox.com/c5/7c/TMGgkV97_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>注意，图中 Ei 表示的是 pair 类对象，即键值对。对于 map 容器来说，每个键值对的键的值都必须保证是唯一的。</p> 
</blockquote> 
<ol><li>下面程序以 begin()/end() 组合为例，演示如何遍历 map 容器：</li></ol> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;      // pair
#include &lt;string&gt;       // string
using namespace std;

int main() {
    // 创建并初始化 map 容器
    std::map&lt;std::string, std::string&gt;myMap{ {"STL教程","http://c.biancheng.net/stl/"},{"C语言教程","http://c.biancheng.net/c/"} };
    // 调用 begin()/end() 组合，遍历 map 容器
    for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) {
        cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    }
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">C语言教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span>
STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
</code></pre> 
<ol start="2"><li>除此之外，map 类模板中还提供了 find() 成员方法，它能帮我们查找指定 key 值的键值对，如果成功找到，则返回一个指向该键值对的双向迭代器；反之，其功能和 end() 方法相同。举个例子：</li></ol> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;      // pair
#include &lt;string&gt;       // string
using namespace std;

int main() {
    // 创建并初始化 map 容器
    std::map&lt;std::string, std::string&gt;myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                             {"C语言教程","http://c.biancheng.net/c/"},
                                             {"Java教程","http://c.biancheng.net/java/"} };
    // 查找键为 "Java教程" 的键值对
    auto iter = myMap.find("Java教程");
    // 从 iter 开始，遍历 map 容器
    for (; iter != myMap.end(); ++iter) {
        cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    }
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">Java教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>java<span class="token operator">/</span>
STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
</code></pre> 
<p>此程序中，创建并初始化的 myMap 容器，默认会根据各键值对中键的值，对各键值对做升序排序，其排序的结果为：</p> 
<pre><code class="prism language-python"><span class="token operator">&lt;</span><span class="token string">"C语言教程"</span><span class="token punctuation">,</span><span class="token string">"http://c.biancheng.net/c/"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token string">"Java教程"</span><span class="token punctuation">,</span><span class="token string">"http://c.biancheng.net/java/"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token string">"STL教程"</span><span class="token punctuation">,</span><span class="token string">"http://c.biancheng.net/stl/"</span><span class="token operator">&gt;</span>
</code></pre> 
<p>在此基础上，通过调用 find() 方法，我们可以得到一个指向键为 “Java教程” 的键值对的迭代器，由此当使用 for 循环从该迭代器出开始遍历时，就只会遍历到最后 2 个键值对。</p> 
<ol start="3"><li>同时，map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：</li></ol> 
<ul>
<li>lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；</li>
<li>upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；</li>
</ul> 
<p>下面程序演示了它们的功能：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;      // pair
#include &lt;string&gt;       // string
using namespace std;

int main() {
    // 创建并初始化 map 容器
    std::map&lt;std::string, std::string&gt;myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                             {"C语言教程","http://c.biancheng.net/c/"},
                                             {"Java教程","http://c.biancheng.net/java/"} };
    // 找到第一个键的值不小于 "Java教程" 的键值对
    auto iter = myMap.lower_bound("Java教程");
    cout &lt;&lt; "lower：" &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
   
    // 找到第一个键的值大于 "Java教程" 的键值对
    iter = myMap.upper_bound("Java教程");
    cout &lt;&lt;"upper：" &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">lower：Java教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>java<span class="token operator">/</span>
upper：STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
</code></pre> 
<blockquote> 
 <p>lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。</p> 
</blockquote> 
<ol start="4"><li>equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。</li></ol> 
<p>显然，equal_range(key) 成员方法表示的是一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;utility&gt;  // pair
#include &lt;map&gt;      // map
#include &lt;string&gt;       // string
using namespace std;

int main() {
    // 创建并初始化 map 容器
    std::map&lt;string, string&gt;myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                   {"C语言教程","http://c.biancheng.net/c/"},
                                   {"Java教程","http://c.biancheng.net/java/"} };
    // 创建一个 pair 对象，来接收 equal_range() 的返回值
    pair &lt;std::map&lt;string, string&gt;::iterator, std::map&lt;string, string&gt;::iterator&gt; myPair = myMap.equal_range("C语言教程");
    // 通过遍历，输出 myPair 指定范围内的键值对
    for (auto iter = myPair.first; iter != myPair.second; ++iter) {
        cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    }
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">C语言教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span>
</code></pre> 
<blockquote> 
 <p>和 lower_bound(key)、upper_bound(key) 一样，该方法也更常用于 multimap 容器，因为 map 容器中各键值对的键的值都是唯一的，因此通过 map 容器调用此方法，其返回的范围内最多也只有 1 个键值对。</p> 
</blockquote> 
<h2>
<a id="map_322"></a>map获取键对应值的几种方法</h2> 
<p>我们知道，map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。</p> 
<blockquote> 
 <p>注意，使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</p> 
</blockquote> 
<p>庆幸的是，map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。</p> 
<ol><li>map 类模板中对<code>[]</code>运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。举个例子：</li></ol> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;      // map
#include &lt;string&gt;   // string
using namespace std;

int main() {
    // 创建并初始化 map 容器
    std::map&lt;std::string, std::string&gt;myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                             {"C语言教程","http://c.biancheng.net/c/"},
                                             {"Java教程","http://c.biancheng.net/java/"} };
    string cValue = myMap["C语言教程"];
    cout &lt;&lt; cValue &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span>
</code></pre> 
<p>可以看到，在第 11 行代码中，通过指定键的值为 “C语言教程”，借助重载的 [ ] 运算符，就可以在 myMap 容器中直接找到该键对应的值。</p> 
<p>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串（即使用该类型的默认值作为键值对的值）。举个例子：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;      // map
#include &lt;string&gt;   // string
using namespace std;

int main() {
    // 创建空 map 容器
    std::map&lt;std::string, int&gt;myMap;
    int cValue = myMap["C语言教程"];
    for (auto i = myMap.begin(); i != myMap.end(); ++i) {
        cout &lt;&lt; i-&gt;first &lt;&lt; " "&lt;&lt; i-&gt;second &lt;&lt; endl;
    }
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">C语言教程 <span class="token number">0</span>
</code></pre> 
<p>显然，对于空的 myMap 容器来说，其内部没有以 “C语言教程” 为键的键值对，这种情况下如果使用 [ ] 运算符获取该键对应的值，其功能就转变成了向该 myMap 容器中添加一个<code>&lt;"C语言教程",0&gt;</code>键值对（由于 myMap 容器规定各个键值对的值的类型为 int，该类型的默认值为 0）。</p> 
<p>实际上，[ ] 运算符确实有“为 map 容器添加新键值对”的功能，但前提是要保证新添加键值对的键和当前 map 容器中已存储的键值对的键都不一样。例如：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;      // map
#include &lt;string&gt;   // string
using namespace std;

int main() {
    // 创建空 map 容器
    std::map&lt;string, string&gt;myMap;
    myMap["STL教程"]="http://c.biancheng.net/java/";
    myMap["Python教程"] = "http://c.biancheng.net/python/";
    myMap["STL教程"] = "http://c.biancheng.net/stl/";
    for (auto i = myMap.begin(); i != myMap.end(); ++i) {
        cout &lt;&lt; i-&gt;first &lt;&lt; " " &lt;&lt; i-&gt;second &lt;&lt; endl;
    }
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">Python教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>python<span class="token operator">/</span>
STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
</code></pre> 
<p>注意，程序中第 9 行代码已经为 map 容器添加了一个以 “STL教程” 作为键的键值对，则第 11 行代码的作用就变成了修改该键对应的值，而不再是为 map 容器添加新键值对。</p> 
<ol start="2"><li>除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。举个例子：</li></ol> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;      // map
#include &lt;string&gt;   // string
using namespace std;

int main() {
    // 创建并初始化 map 容器
    std::map&lt;std::string, std::string&gt;myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                             {"C语言教程","http://c.biancheng.net/c/"},
                                             {"Java教程","http://c.biancheng.net/java/"} };
    cout &lt;&lt; myMap.at("C语言教程") &lt;&lt; endl;
    // 下面一行代码会引发 out_of_range 异常
    // cout &lt;&lt; myMap.at("Python教程") &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span>
</code></pre> 
<p>程序第 11 行代码处，通过 myMap 容器调用 at() 成员方法，可以成功找到键为 “C语言教程” 的键值对，并返回该键对应的值；而第 13 行代码，由于当前 myMap 容器中没有以 “Python教程” 为键的键值对，会导致 at() 成员方法查找失败，并抛出 out_of_range 异常。</p> 
<ol start="3"><li>除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。举个例子：</li></ol> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;      // map
#include &lt;string&gt;   // string
using namespace std;

int main() {
    // 创建并初始化 map 容器
    std::map&lt;std::string, std::string&gt;myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                             {"C语言教程","http://c.biancheng.net/c/"},
                                             {"Java教程","http://c.biancheng.net/java/"} };
    map&lt; std::string, std::string &gt;::iterator myIter = myMap.find("C语言教程");
    cout &lt;&lt; myIter-&gt;first &lt;&lt; " " &lt;&lt; myIter-&gt;second &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">C语言教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span>
</code></pre> 
<blockquote> 
 <p>注意，此程序中如果 find() 查找失败，会导致第 12 行代码运行出错。因为当 find() 方法查找失败时，其返回的迭代器指向的是容器中最后一个键值对之后的位置，即不指向任何有意义的键值对，也就没有所谓的 first 和 second 成员了。</p> 
</blockquote> 
<ol start="4"><li>如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。比如：</li></ol> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;      // map
#include &lt;string&gt;   // string
using namespace std;

int main() {
    // 创建并初始化 map 容器
    std::map&lt;std::string, std::string&gt;myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                             {"C语言教程","http://c.biancheng.net/c/"},
                                             {"Java教程","http://c.biancheng.net/java/"} };
    for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) {
        // 调用 string 类的 compare() 方法，找到一个键和指定字符串相同的键值对
        if (!iter-&gt;first.compare("C语言教程")) {
            cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">C语言教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span>
</code></pre> 
<blockquote> 
 <p>本节所介绍的几种方法中，仅从“在 map 容器存储的键值对中，获取指定键对应的值”的角度出发，更推荐使用 at() 成员方法，因为该方法既简单又安全。</p> 
</blockquote> 
<h2>
<a id="map_insert4_500"></a>map insert()插入数据的4种方式</h2> 
<p>前面讲过，C++ STL map 类模板中对<code>[]</code>运算符进行了重载，即根据使用场景的不同，借助<code>[]</code>运算符可以实现不同的操作。举个例子：</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
#include &lt;map&gt;  //map
#include &lt;string&gt; //string
using namespace std;

int main()
{
    std::map&lt;string, string&gt; mymap{ {"STL教程","http://c.biancheng.net/java/"} };
    // 获取已存储键值对中，指定键对应的值
    cout &lt;&lt; mymap["STL教程"] &lt;&lt; endl;
    // 向 map 容器添加新键值对
    mymap["Python教程"] = "http://c.biancheng.net/python/";
    // 修改 map 容器已存储键值对中，指定键对应的值
    mymap["STL教程"] = "http://c.biancheng.net/stl/";
    for (auto iter = mymap.begin(); iter != mymap.end(); ++iter) {
        cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    }
   
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>java<span class="token operator">/</span>
Python教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>python<span class="token operator">/</span>
STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
</code></pre> 
<p>可以看到，当操作对象为 map 容器中已存储的键值对时，则借助 [ ] 运算符，既可以获取指定键对应的值，还能对指定键对应的值进行修改；反之，若 map 容器内部没有存储以 [ ] 运算符内指定数据为键的键值对，则使用 [ ] 运算符会向当前 map 容器中添加一个新的键值对。</p> 
<p>实际上，除了使用 [ ] 运算符实现向 map 容器中添加新键值对外，map 类模板中还提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。</p> 
<p>注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。</p> 
<p>自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。</p> 
<ol><li>无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：</li></ol> 
<pre><code class="prism language-C++">// 1、引用传递一个键值对
pair&lt;iterator,bool&gt; insert (const value_type&amp; val);
// 2、以右值引用的方式传递键值对
template &lt;class P&gt;
  pair&lt;iterator,bool&gt; insert (P&amp;&amp; val);
</code></pre> 
<p>其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p> 
<ul>
<li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li>
<li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。</li>
</ul> 
<blockquote> 
 <p>以上 2 种语法格式的区别在于传递参数的方式不同，即无论是局部定义的键值对变量还是全局定义的键值对变量，都采用普通引用传递的方式；而对于临时的键值对变量，则以右值引用的方式传参。</p> 
</blockquote> 
<p>举个例子：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;  // map
#include &lt;string&gt; // string
using namespace std;

int main()
{
    // 创建一个空 map 容器
    std::map&lt;string, string&gt; mymap;
   
    // 创建一个真实存在的键值对变量
    std::pair&lt;string, string&gt; STL = { "STL教程","http://c.biancheng.net/stl/" };
   
    // 创建一个接收 insert() 方法返回值的 pair 对象
    std::pair&lt;std::map&lt;string, string&gt;::iterator, bool&gt; ret;
   
    // 插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参
    ret = mymap.insert(STL);
    cout &lt;&lt; "ret.iter = &lt;{" &lt;&lt; ret.first-&gt;first &lt;&lt; ", " &lt;&lt; ret.first-&gt;second &lt;&lt; "}, " &lt;&lt; ret.second &lt;&lt; "&gt;" &lt;&lt; endl;
    
    // 以右值引用的方式传递临时的键值对变量
    ret = mymap.insert({ "C语言教程","http://c.biancheng.net/c/" });
    cout &lt;&lt; "ret.iter = &lt;{" &lt;&lt; ret.first-&gt;first &lt;&lt; ", " &lt;&lt; ret.first-&gt;second &lt;&lt; "}, " &lt;&lt; ret.second &lt;&lt; "&gt;" &lt;&lt; endl;
    
    // 插入失败样例
    ret = mymap.insert({ "STL教程","http://c.biancheng.net/java/" });
    cout &lt;&lt; "ret.iter = &lt;{" &lt;&lt; ret.first-&gt;first &lt;&lt; ", " &lt;&lt; ret.first-&gt;second &lt;&lt; "}, " &lt;&lt; ret.second &lt;&lt; "&gt;" &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">ret<span class="token punctuation">.</span><span class="token builtin">iter</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token punctuation">{<!-- --></span>STL教程<span class="token punctuation">,</span> http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">&gt;</span>
ret<span class="token punctuation">.</span><span class="token builtin">iter</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token punctuation">{<!-- --></span>C语言教程<span class="token punctuation">,</span> http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">&gt;</span>
ret<span class="token punctuation">.</span><span class="token builtin">iter</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token punctuation">{<!-- --></span>STL教程<span class="token punctuation">,</span> http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">&gt;</span>
</code></pre> 
<p>从执行结果中不难看出，程序中共执行了 3 次插入操作，其中成功了 2 次，失败了 1 次：</p> 
<ul>
<li>对于插入成功的 insert() 方法，其返回的 pair 对象中包含一个指向新插入键值对的迭代器和值为 1 的 bool 变量。</li>
<li>对于插入失败的 insert() 方法，同样会返回一个 pair 对象，其中包含一个指向 map 容器中键为 “STL教程” 的键值对和值为 0 的 bool 变量。</li>
</ul> 
<p>另外，在程序中的第 22 行代码，还可以使用如下 2 种方式创建临时的键值对变量，它们是等价的：</p> 
<pre><code class="prism language-c++">// 调用 pair 类模板的构造函数
ret = mymap.insert(pair&lt;string,string&gt;{ "C语言教程","http://c.biancheng.net/c/" });
// 调用 make_pair() 函数
ret = mymap.insert(make_pair("C语言教程", "http://c.biancheng.net/c/"));
</code></pre> 
<ol start="2"><li>除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下：</li></ol> 
<pre><code class="prism language-c++">// 以普通引用的方式传递 val 参数
iterator insert (const_iterator position, const value_type&amp; val);
// 以右值引用的方式传递 val 键值对参数
template &lt;class P&gt;
  iterator insert (const_iterator position, P&amp;&amp; val);
</code></pre> 
<p>其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：</p> 
<ul>
<li>如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；</li>
<li>如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。</li>
</ul> 
<p>举个例子：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;  // map
#include &lt;string&gt; // string
using namespace std;

int main()
{
    // 创建一个空 map 容器
    std::map&lt;string, string&gt; mymap;
   
    // 创建一个真实存在的键值对变量
    std::pair&lt;string, string&gt; STL = { "STL教程","http://c.biancheng.net/stl/" };
    // 指定要插入的位置
    std::map&lt;string, string&gt;::iterator it = mymap.begin();
    // 向 it 位置以普通引用的方式插入 STL
    auto iter1 = mymap.insert(it, STL);
    cout &lt;&lt; iter1-&gt;first &lt;&lt; " " &lt;&lt; iter1-&gt;second &lt;&lt; endl;
    
    // 向 it 位置以右值引用的方式插入临时键值对
    auto iter2 = mymap.insert(it, std::pair&lt;string, string&gt;("C语言教程", "http://c.biancheng.net/c/"));
    cout &lt;&lt; iter2-&gt;first &lt;&lt; " " &lt;&lt; iter2-&gt;second &lt;&lt; endl;
    
    // 插入失败样例
    auto iter3 = mymap.insert(it, std::pair&lt;string, string&gt;("STL教程", "http://c.biancheng.net/java/"));
    cout &lt;&lt; iter3-&gt;first &lt;&lt; " " &lt;&lt; iter3-&gt;second &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
C语言教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span>
STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
</code></pre> 
<p>再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。</p> 
<ol start="3"><li>insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：</li></ol> 
<pre><code class="prism language-c++">template &lt;class InputIterator&gt;
 void insert (InputIterator first, InputIterator last);
</code></pre> 
<p>其中 first 和 last 都是迭代器，它们的组合<code>&lt;first,last&gt;</code>可以表示某 map 容器中的指定区域。</p> 
<p>举个例子：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;  // map
#include &lt;string&gt; // string
using namespace std;

int main()
{
    // 创建并初始化 map 容器
    std::map&lt;std::string, std::string&gt;mymap{ {"STL教程","http://c.biancheng.net/stl/"},
                                                {"C语言教程","http://c.biancheng.net/c/"},
                                                {"Java教程","http://c.biancheng.net/java/"} };
    // 创建一个空 map 容器
    std::map&lt;std::string, std::string&gt;copymap;
    // 指定插入区域
    std::map&lt;string, string&gt;::iterator first = ++mymap.begin();
    std::map&lt;string, string&gt;::iterator last = mymap.end();
    // 将&lt;first,last&gt;区域内的键值对插入到 copymap 中
    copymap.insert(first, last);
    // 遍历输出 copymap 容器中的键值对
    for (auto iter = copymap.begin(); iter != copymap.end(); ++iter) {
        cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    }
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">Java教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>java<span class="token operator">/</span>p
STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
</code></pre> 
<p>此程序中，&lt;first,last&gt; 指定的区域是从 mumap 容器第 2 个键值对开始，之后所有的键值对，所以 copymap 容器中包含有 2 个键值对。</p> 
<ol start="4"><li>除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：</li></ol> 
<pre><code class="prism language-c++">void insert ({val1, val2, ...});
</code></pre> 
<p>其中，vali 都表示的是键值对变量。</p> 
<p>举个例子：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;  // map
#include &lt;string&gt; // string
using namespace std;

int main()
{
    // 创建空的 map 容器
    std::map&lt;std::string, std::string&gt;mymap;
    // 向 mymap 容器中添加 3 个键值对
    mymap.insert({ {"STL教程", "http://c.biancheng.net/stl/"},
                   { "C语言教程","http://c.biancheng.net/c/" },
                   { "Java教程","http://c.biancheng.net/java/" } });
    for (auto iter = mymap.begin(); iter != mymap.end(); ++iter) {
        cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    }
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">C语言教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span>
Java教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>java<span class="token operator">/</span>
STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
</code></pre> 
<h2>
<a id="map_emplaceemplace_hint_759"></a>map emplace()和emplace_hint()方法</h2> 
<p>学习 map insert() 方法时提到，C++ STL map 类模板中还提供了 emplace() 和 emplace_hint() 成员函数，也可以实现向 map 容器中插入新的键值对。</p> 
<blockquote> 
 <p>值得一提的是，实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高。</p> 
</blockquote> 
<ol><li>和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：</li></ol> 
<pre><code class="prism language-c++">template &lt;class... Args&gt;
 pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);
</code></pre> 
<p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：</p> 
<ul>
<li>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；</li>
<li>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</li>
</ul> 
<p>下面程序演示 emplace() 方法的具体用法：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;  // map
#include &lt;string&gt; // string
using namespace std;

int main()
{
    // 创建并初始化 map 容器
    std::map&lt;string, string&gt;mymap;
    // 插入键值对
    pair&lt;map&lt;string, string&gt;::iterator, bool&gt; ret = mymap.emplace("STL教程", "http://c.biancheng.net/stl/");
    cout &lt;&lt; "1、ret.iter = &lt;{" &lt;&lt; ret.first-&gt;first &lt;&lt; ", " &lt;&lt; ret.first-&gt;second &lt;&lt; "}, " &lt;&lt; ret.second &lt;&lt; "&gt;" &lt;&lt; endl;
    // 插入新键值对
    ret = mymap.emplace("C语言教程", "http://c.biancheng.net/c/");
    cout &lt;&lt; "2、ret.iter = &lt;{" &lt;&lt; ret.first-&gt;first &lt;&lt; ", " &lt;&lt; ret.first-&gt;second &lt;&lt; "}, " &lt;&lt; ret.second &lt;&lt; "&gt;" &lt;&lt; endl;
    // 失败插入的样例
    ret = mymap.emplace("STL教程", "http://c.biancheng.net/java/");
    cout &lt;&lt; "3、ret.iter = &lt;{" &lt;&lt; ret.first-&gt;first &lt;&lt; ", " &lt;&lt; ret.first-&gt;second &lt;&lt; "}, " &lt;&lt; ret.second &lt;&lt; "&gt;" &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python"><span class="token number">1</span>、ret<span class="token punctuation">.</span><span class="token builtin">iter</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token punctuation">{<!-- --></span>STL教程<span class="token punctuation">,</span> http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">&gt;</span>
<span class="token number">2</span>、ret<span class="token punctuation">.</span><span class="token builtin">iter</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token punctuation">{<!-- --></span>C语言教程<span class="token punctuation">,</span> http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">&gt;</span>
<span class="token number">3</span>、ret<span class="token punctuation">.</span><span class="token builtin">iter</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token punctuation">{<!-- --></span>STL教程<span class="token punctuation">,</span> http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">&gt;</span>
</code></pre> 
<p>可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。</p> 
<ol start="2"><li>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</li></ol> 
<pre><code class="prism language-c++">template &lt;class... Args&gt;
 iterator emplace_hint (const_iterator position, Args&amp;&amp;... args);
</code></pre> 
<p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p> 
<ol>
<li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li>
<li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li>
</ol> 
<p>下面程序演示 emplace_hint() 方法的用法：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;  // map
#include &lt;string&gt; // string
using namespace std;

int main()
{
    // 创建并初始化 map 容器
    std::map&lt;string, string&gt;mymap;
    // 指定在 map 容器插入键值对
    map&lt;string, string&gt;::iterator iter = mymap.emplace_hint(mymap.begin(),"STL教程", "http://c.biancheng.net/stl/");
    cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    iter = mymap.emplace_hint(mymap.begin(), "C语言教程", "http://c.biancheng.net/c/");
    cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    // 插入失败样例
    iter = mymap.emplace_hint(mymap.begin(), "STL教程", "http://c.biancheng.net/java/");
    cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>程序执行结果为：</p> 
<pre><code class="prism language-python">STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
C语言教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>c<span class="token operator">/</span>
STL教程 http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>stl<span class="token operator">/</span>
</code></pre> 
<p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p> 
<hr> 
<h1>
<a id="2_multimap_860"></a>2. multimap</h1> 
<h2>
<a id="_862"></a>概述</h2> 
<p>在掌握 C++ STL map 容器的基础上，本节介绍一个和 map 相似的关联容器，即 multimap 容器。</p> 
<p>所谓“相似”，指的是 multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair&lt;const K, T&gt; 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。</p> 
<p>和 map 容器一样，实现 multimap 容器的类模板也定义在&lt;map&gt;头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码：</p> 
<pre><code class="prism language-c++">#include &lt;map&gt;
using namespace std;
</code></pre> 
<p>multimap 容器类模板的定义如下：</p> 
<pre><code class="prism language-c++">template &lt; class Key,                                   // 指定键（key）的类型
           class T,                                     // 指定值（value）的类型
           class Compare = less&lt;Key&gt;,                   // 指定排序规则
           class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt;  // 指定分配器对象的类型
           &gt; class multimap;
</code></pre> 
<p>可以看到，multimap 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。</p> 
<h2>
<a id="_887"></a>成员函数</h2> 
<table>
<thead><tr>
<th>成员方法</th>
<th>功能</th>
</tr></thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 multimap 容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 multimap 容器中插入键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。</td>
</tr>
</tbody>
</table> 
<p>和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。</p> 
<blockquote> 
 <p>另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此上表中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到。</p> 
</blockquote> 
<h2>
<a id="C_multimap_918"></a>创建C++ multimap容器的方法</h2> 
<p>multimap 类模板内部提供有多个构造函数，总的来说，创建 multimap 容器的方式可归为以下 5 种。</p> 
<ol><li>通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：</li></ol> 
<pre><code class="prism language-c++">std::multimap&lt;std::string, std::string&gt; mymultimap;
</code></pre> 
<ol start="2"><li>当然，在创建 multimap 容器的同时，还可以进行初始化操作。比如：</li></ol> 
<pre><code class="prism language-c++">// 创建并初始化 multimap 容器
multimap&lt;string, string&gt;mymultimap{ {"C语言教程", "http://c.biancheng.net/c/"},
                                    {"Python教程", "http://c.biancheng.net/python/"},
                                    {"STL教程", "http://c.biancheng.net/stl/"} };
</code></pre> 
<p>注意，使用此方式初始化 multimap 容器时，其底层会先将每一个<code>{key, value}</code>创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。</p> 
<p>实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：</p> 
<pre><code class="prism language-c++">// 借助 pair 类模板的构造函数来生成各个pair类型的键值对
multimap&lt;string, string&gt; mymultimap{
    pair&lt;string,string&gt;{"C语言教程", "http://c.biancheng.net/c/"},
    pair&lt;string,string&gt;{ "Python教程", "http://c.biancheng.net/python/"},
    pair&lt;string,string&gt;{ "STL教程", "http://c.biancheng.net/stl/"}
};
// 调用 make_pair() 函数，生成键值对元素
// 创建并初始化 multimap 容器
multimap&lt;string, string&gt; mymultimap{
    make_pair("C语言教程", "http://c.biancheng.net/c/"),
    make_pair("Python教程", "http://c.biancheng.net/python/"),
    make_pair("STL教程", "http://c.biancheng.net/stl/")
};
</code></pre> 
<ol start="3"><li>除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器。例如：</li></ol> 
<pre><code class="prism language-c++">multimap&lt;string, string&gt; newmultimap(mymultimap);
</code></pre> 
<p>由此，就成功创建一个和 mymultimap 完全一样的 newmultimap 容器。</p> 
<p>在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。举个例子：</p> 
<pre><code class="prism language-c++">// 创建一个会返回临时 multimap 对象的函数
multimap&lt;string, string&gt; dismultimap() {
    multimap&lt;string, string&gt;tempmultimap{ {"C语言教程", "http://c.biancheng.net/c/"},{"Python教程", "http://c.biancheng.net/python/"} };
    return tempmultimap;
}  
// 调用 multimap 类模板的移动构造函数创建 newMultimap 容器
multimap&lt;string, string&gt; newmultimap(dismultimap());
</code></pre> 
<p>上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数。</p> 
<blockquote> 
 <p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p> 
</blockquote> 
<ol start="4"><li>multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。例如：</li></ol> 
<pre><code class="prism language-c++">// 创建并初始化 multimap 容器
multimap&lt;string, string&gt;mymultimap{ {"C语言教程", "http://c.biancheng.net/c/"},
                                    {"Python教程", "http://c.biancheng.net/python/"},
                                    {"STL教程", "http://c.biancheng.net/stl/"} };
multimap&lt;string, string&gt;newmultimap(++mymultimap.begin(), mymultimap.end());
</code></pre> 
<p>这里使用了 multimap 容器的迭代器，选取了 mymultimap 容器中的最后 2 个键值对，用于初始化 newmultimap 容器。</p> 
<ol start="5"><li>前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为<code>std::less&lt;T&gt;</code>，这意味着以下 2 种创建 multimap 容器的方式是等价的：</li></ol> 
<pre><code class="prism language-c++">multimap&lt;char, int&gt; mymultimap{ {'a',1},{'b',2} };
multimap&lt;char, int, std::less&lt;char&gt;&gt; mymultimap{ {'a',1},{'b',2} };
</code></pre> 
<p>mymultimap 容器中键值对的存储顺序为：</p> 
<pre><code class="prism language-python"><span class="token operator">&lt;</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>b<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">&gt;</span>
</code></pre> 
<p>下面程序利用了 STL 模板库提供的<code>std::greater&lt;T&gt;</code>排序函数，实现令 multimap 容器对存储的键值对做降序排序：</p> 
<pre><code class="prism language-c++">multimap&lt;char, int, std::greater&lt;char&gt;&gt; mymultimap{ {'a',1},{'b',2} };
</code></pre> 
<p>其内部键值对的存储顺序为：</p> 
<pre><code class="prism language-python"><span class="token operator">&lt;</span>b<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">&gt;</span>
</code></pre> 
<blockquote> 
 <p>在某些特定场景中，我们还可以为 multimap 容器自定义排序规则。</p> 
</blockquote>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>