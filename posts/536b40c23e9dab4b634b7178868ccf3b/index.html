<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C/C&#43;&#43;面试高频知识点八股文 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C/C&#43;&#43;面试高频知识点八股文</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    
                        
                    
                    <p>最近有小伙伴找我问面试都问些啥，这不我就把高频被问的一一列出来。<br> </p>
<div class="toc">
 <h3>目录</h3>
 <ul>
<li><a href="#C_2">C语言必考知识点</a></li>
<li>
<ul>
<li><a href="#_3">含参数的宏与函数的不同点</a></li>
<li><a href="#scanf_13">scanf格式化输入的注意事项</a></li>
<li><a href="#_21">指针</a></li>
<li><a href="#_37">数组</a></li>
<li><a href="#_46">数组与指针的区别</a></li>
<li><a href="#sizeof_55">sizeof关键字</a></li>
<li><a href="#sizeofstrlen_63">sizeof关键字与strlen函数的区别</a></li>
<li><a href="#_67">大小端</a></li>
<li><a href="#_77">使用库函数需要知道什么</a></li>
<li><a href="#_83">数值数组与字符数组的区别</a></li>
<li><a href="#strcpymemcpy_93">strcpy和memcpy区别</a></li>
<li><a href="#_105">内存五大分区(超级重要)</a></li>
<li><a href="#_116">三个变量</a></li>
<li><a href="#_122">表达式计算通用规则(优先级表要背会)</a></li>
<li><a href="#_129">字节对齐规则</a></li>
<li><a href="#externstatic_133">extern与static区别</a></li>
<li><a href="#_143">断言</a></li>
<li><a href="#_150">链表和数组的区别</a></li>
<li><a href="#constdefine_161">const和define的区别</a></li>
</ul>
  </li>
<li><a href="#C_192">C++必考知识点</a></li>
<li>
<ul>
<li><a href="#41_193">高频被问(41条)</a></li>
<li><a href="#newmalloc_324">new与malloc的区别</a></li>
<li><a href="#CC_331">C++与C的区别</a></li>
<li><a href="#_340">静态链接和动态链接有什么区别？</a></li>
<li><a href="#_349">指针和引用的区别</a></li>
<li><a href="#_362">类和结构体的区别</a></li>
<li><a href="#defineinline_366">define与inline区别</a></li>
<li><a href="#_376">前置++与后置++区别</a></li>
<li><a href="#staticCc_380">static在C和c++的区别</a></li>
<li><a href="#%E3%80%80friend_391">友元　friend</a></li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<h1>
<a id="C_2"></a>C语言必考知识点</h1> 
<h2>
<a id="_3"></a>含参数的宏与函数的不同点</h2> 
<table>
<thead><tr>
<th>函数</th>
<th>带参数的宏</th>
</tr></thead>
<tbody>
<tr>
<td>函数调用时，先求出实参表达式的值，然后带入形参。</td>
<td>使用带参的宏只是进行简单的字符替换。</td>
</tr>
<tr>
<td>函数调用是在程序运行时进行的，分配临时的内存单元；</td>
<td>而宏替换则是在编译时进行的，在展开时不分配内存单元，不进行值的传递处理，也没有“返回值”的概念。</td>
</tr>
<tr>
<td>对函数中的实参和形参都要定义类型，二者的类型数量要求一致；</td>
<td>宏没有类型检查，宏名无类型，它的参数也无类型，只是一个符号代表，展开时带入指定的字符即可。</td>
</tr>
<tr>
<td>调用函数只可得到一个返回值，</td>
<td>而用宏可以得到几个结果。</td>
</tr>
<tr>
<td>函数调用不使源程序变长。</td>
<td>使用宏时，宏替换后源程序增长</td>
</tr>
<tr>
<td>函数调用占运行时间（分配单元、保留现场、值传递、返回）。</td>
<td>宏替换不占运行时间，只占编译时间；</td>
</tr>
</tbody>
</table>
<h2>
<a id="scanf_13"></a>scanf格式化输入的注意事项</h2> 
<ol>
<li>输入数据时采用的分隔符应与格式控制中的分隔符一致；</li>
<li>输入数据时可指定宽度，但不可规定精度；</li>
<li>输入格式符带有*，表示该数据不赋值；</li>
<li>无符号数可用%d、%o、%x格式输入；</li>
<li>用c格式输入字符时，空格、转义字符均为有效字符；</li>
<li>遇空格、回车、Tab键，遇宽度以及非法输入可认为数据输入结束；</li>
</ol> 
<h2>
<a id="_21"></a>指针</h2> 
<p>英文名pointer，也叫地址，就是内存块的首地址</p> 
<p>指针变量(地址变量）</p> 
<ol>
<li>指针变量就是存放指针数据的变量。</li>
<li>int*p；//p只能存放int类型内存块的地址</li>
<li>所有指针变量都是4字节(32环境)</li>
<li>未赋初值的指针变量禁止使用(访问未初始化的指针的值程序直接崩溃。访问NULL指针的值也会奔溃)</li>
</ol> 
<p><strong>指针常见含义：</strong><br> *<strong>p的含义</strong>： 根据p里面的地址，找对应类型的内存块。<br> <strong>p+n的含义</strong>：• p地址向后偏移n个存储单元，得到一个新地址（在一连续空间中俩个指针相减等于间隔的内存空间个数）<br> <strong>p[n]的含义</strong>：• 表示p地址第n+1个内存块<br> <strong>指针支持的运算</strong> 算术运算、自增自减、关系运算、逻辑运算、赋值运算、条件运算(三目)、逗号运算、sizeof关键字、&amp; *</p> 
<h2>
<a id="_37"></a>数组</h2> 
<p>1、数目固定，类型相同，连续存放的一组有序数的集合；<br> 2、C语言规定，数组名就是内存块的首地址，它是一个常量指针；<br> 3、定义数组时，长度应是常量或常量表达式，不能用变量，而在使用时，a[ i ]表示a之后第i+1个内存块；<br> 4、a + n表示a地址后向右偏移n个储存单元得到新的地址，a[ n ]表示a地址后第n + 1个内存块；<br> 5、数组中每个元素都是变量；<br> 6、int a[ 10 ]={1, 2, 3}；部分元素赋初值，其余未赋值为0； int a[ 10 ]；一个值都不赋，数组元素均为乱值。</p> 
<h2>
<a id="_46"></a>数组与指针的区别</h2> 
<table>
<thead><tr>
<th>数组</th>
<th>指针</th>
</tr></thead>
<tbody>
<tr>
<td>数组是一种数据结构</td>
<td>指针是一个地址</td>
</tr>
<tr>
<td>数组名是该数组的首地址</td>
<td></td>
</tr>
<tr>
<td>sizeof测量数组即为所占内存空间的大小</td>
<td>sizeof测量指针在win32为四字节.win64为八字节</td>
</tr>
</tbody>
</table>
<h2>
<a id="sizeof_55"></a>sizeof关键字</h2> 
<p><strong>sizeof作用</strong>：能测试常量，变量，数组、类型 所占 应占 内存大小的单位字节数</p> 
<p>测试字符串 就是字符个数 + 1<br> printf(“%d”, sizeof(“lovechina”)); 有<br> 测试变量 就是变量对照类型分配的空间大小<br> 测试数组 就是数组所占的空间大小，元素占的空间 * 数组长度<br> 所有指针变量 所占4字节(32 系统)</p> 
<h2>
<a id="sizeofstrlen_63"></a>sizeof关键字与strlen函数的区别</h2> 
<p><strong>Sizeof</strong>:编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度<br> <strong>strlen</strong>只能测量字符串 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符</p> 
<h2>
<a id="_67"></a>大小端</h2> 
<p>大端模式：是指数据的高字节保存在内存的低地址中；<br> 小端模式：是指数据的高字节保存在内存的高地址中；</p> 
<p><strong>使用指针强转</strong><br> <img src="https://images2.imgbox.com/b1/22/VinK95mB_o.png" alt="在这里插入图片描述"></p> 
<p><strong>使用共用体</strong><br> <img src="https://images2.imgbox.com/ef/a1/ENwaEiW6_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="_77"></a>使用库函数需要知道什么</h2> 
<ol>
<li>知道函数的功能及函数名</li>
<li>需要导入使用的包含头文件</li>
<li>参数的数目和顺序，以及每个参数的意义及类型</li>
<li>返回值的意义及类型</li>
</ol> 
<h2>
<a id="_83"></a>数值数组与字符数组的区别</h2> 
<table>
<thead><tr>
<th></th>
<th>数值数组</th>
<th>字符型数组 (1表示用来存放数值 2表示用来存放字符)</th>
</tr></thead>
<tbody>
<tr>
<td>定义及赋初值</td>
<td>int a[5]</td>
<td>1. char str[5] = {1, 2, 3} 2.char str[5] = {“abc”}</td>
</tr>
<tr>
<td>输入和输出：</td>
<td>循环读入和循环输出</td>
<td>1. 用%d %c 循环读入(数值型数组特点) 2. 用%s可以整体读入和整体输出(字符串使用)</td>
</tr>
<tr>
<td>二维数组：</td>
<td>int a[3][5] = {0};</td>
<td>3行5列数字矩阵 char str[3][5] 1. 3行5列一个字节整型数矩阵 2. 3个最大长度为4的字符串</td>
</tr>
<tr>
<td>作为函数参数</td>
<td>int fun(int a[], int n);</td>
<td>1. int fun(char str[], int n)；//数值型数组需要传n 2. int fun(char str[]);//字符型数组不需要传n</td>
</tr>
<tr>
<td>处理函数(专有)</td>
<td>无</td>
<td>1. 无(数值数组无) 2. strstr、strcmp、strcpy、strncpy、strtok、strlwr、strupr 、strcat、strlen</td>
</tr>
<tr>
<td>处理函数(公共)</td>
<td>qsort、memset、memcpy、memcmp、memmove、malloc</td>
<td>qsort、memset、memcpy、memcmp、memmove、malloc</td>
</tr>
</tbody>
</table>
<h2>
<a id="strcpymemcpy_93"></a>strcpy和memcpy区别</h2> 
<p><strong>1.复制的内容不同。</strong><br> strcpy只能复制字符串，<br> memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</p> 
<p><strong>2.复制的方法不同。</strong><br> strcpy不需要指定长度，它遇到被复制字符的串结束符""才结束，如果空间不够，就会引起踩内存。<br> memcpy则是根据其第3个参数决定复制的长度。</p> 
<p><strong>3.用途不同。</strong><br> 通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy，由于字符串是以“”结尾的，所以对于在数据中包含“”的数据只能用memcpy。</p> 
<h2>
<a id="_105"></a>内存五大分区(超级重要)</h2> 
<p><img src="https://images2.imgbox.com/b0/d3/Pd1nc07u_o.png" alt="在这里插入图片描述"><br> 内存总共分为五大分区：栈区，堆区，全局静态区，常量文本区，程序代码区。<br> 从生存周期来说：栈区是运行时分配，结束就释放。堆区是程序员主动分配和释放。全局静态区是程序运行前分配，程序结束释放。常量文本区也是程序运行前分配，程序结束释放<br> 从管理角度来说：只有堆区是由程序员自己来管理，其他四个区都是由系统来管理的。<br> 从可能产生的问题来说：栈区可能会造成栈溢出(1、深度递归，栈帧太多 2、只分配不释放，栈耗尽)。堆区可能造成内存泄漏(就是申请空间，然后忘记释放了)，野指针（指向了一块已经被释放的空间），内存碎片。<br> 从效率来说：栈区比堆区效率高<br> 从内存大小来说：栈区大小m，堆区大小和内存有关。最大可1G。其他三个区都很小<br> 代码区：存放程序体的二进制代码。比如我们写的函数，都是在代码区的。</p> 
<h2>
<a id="_116"></a>三个变量</h2> 
<p>等号左边必须是变量<br> 自增自减必须是变量<br> 形参必须是变量</p> 
<h2>
<a id="_122"></a>表达式计算通用规则(优先级表要背会)</h2> 
<p>从左向右运算符俩俩比较，左边运算符优先级高于右边运算符时 ，先算左边的。<br> 左边运算符优先级低于右边的继续向右比较，直到找到一个相对最高的。（之后的的运算符低，或者到末尾了），进行运算。<br> 如果左右优先级相同看结合性，(单目运算右结合，双目运算左结合。三目运算嵌套是右结合。三目运算是左结合)，<br> 计算完一个运算符再重复前面所有步骤。（遇到||和&amp;&amp;注意短路）<br> <img src="https://images2.imgbox.com/5c/23/fT04dP4E_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="_129"></a>字节对齐规则</h2> 
<p>• 结构体各成员的起始位置相对于结构体变量的起始位置的偏移量，应该为该结构体成员类型所占字节数与pack(n)的n取最小值的倍数<br> • 结构体变量所占字节数应该是结构体各成员所占字节数的最大值与pack(n)的n取最小值</p> 
<h2>
<a id="externstatic_133"></a>extern与static区别</h2> 
<p><strong>static</strong> <br> <strong>作用于局部变量时</strong>： 叫静态局部变量，在函数调用时，只有在该函数第一次调用时才对其分配空间和初始化。在函数调用结束时，不对该变量的内存进行释放，值仍然保留。这也是于自动变量的区别。<br> <strong>作用于全局变量时：</strong> 叫静态全局变量。表示该变量是私有的，只能在该文件使用。不能通过extern关键字对其引用。 <br> <strong>作用于函数时：</strong> 叫静态函数，表示该函数是私有的，只能在本文件中使用，不能通过extern关键字对其引用</p> 
<p><strong>extern</strong> <br> <strong>本文件</strong>： 定义在本文件下面的全局变量，想要在上面使用时需要使用extern关键字对其声明 <br> <strong>其他文件</strong>：定义在其他文件的全局变量想要在本文件使用时，若该变量未被static修饰时可通过extern关键字在本文件对其声明。即可使用</p> 
<h2>
<a id="_143"></a>断言</h2> 
<p>assert(src != NULL);//断言 括号内部成立上面事情不发生，否则报错<br> <strong>头文件：</strong>#include&lt;assert.h&gt;<br> <strong>作用：</strong> 解决预防性编程的问题，例如参数传入一个指针为NULL时，程序就会奔溃时，我们可以增加assert来防御这种问题。<br> 在我们联调中assert会显示崩溃的信息，加快联调速度，也能对参数问题进行判断。assert只能在debug版起作用，发布版不生效。<br> <strong>综上所述：</strong> assert就是预防性编程一个重要的宏，能加快联调速度。</p> 
<h2>
<a id="_150"></a>链表和数组的区别</h2> 
<p><strong>链表</strong><br> 逻辑上相邻的元素在物理位置上不一定相邻。<br> <strong>优点：</strong> 插入、删除效率高，不需要一个连续的很大的内存<br> <strong>缺点：</strong> 查找某一个位置的元素效率低。</p> 
<p><strong>数组</strong><br> <strong>优点：</strong> 存取速度快<br> <strong>缺点：</strong><br> 1.整块连续空间，占很大内存。<br> 2.插入或删除数据效率低、不方便</p> 
<h2>
<a id="constdefine_161"></a>const和define的区别</h2> 
<p><strong>1.编译器处理方式</strong><br> define – 在预处理阶段进行替换<br> const – 在编译时确定其值</p> 
<p><strong>2.类型检查</strong><br> define – 无类型，不进行类型安全检查，可能会产生意想不到的错误<br> const – 有数据类型，编译时会进行类型检查</p> 
<p><strong>3.内存空间</strong><br> define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大<br> const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝</p> 
<p><strong>4.其他</strong><br> 宏只作替换，不做计算，不做表达式求解。</p> 
<p><strong>总结</strong><br> const比define安全</p> 
<table>
<thead><tr>
<th>define</th>
<th>const</th>
</tr></thead>
<tbody>
<tr>
<td>在预处理阶段进行替换</td>
<td>在编译时确定其值</td>
</tr>
<tr>
<td>无类型，不进行类型安全检查，可能会产生意想不到的错误</td>
<td>有数据类型，编译时会进行类型检查</td>
</tr>
<tr>
<td>不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大</td>
<td>在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝</td>
</tr>
<tr>
<td>宏只作替换，不做计算，不做表达式求解。</td>
<td>const比define安全</td>
</tr>
</tbody>
</table>
<h1>
<a id="C_192"></a>C++必考知识点</h1> 
<h2>
<a id="41_193"></a>高频被问(41条)</h2> 
<ol>
<li> <p><strong>空类占用内存空间</strong>：1字节</p> </li>
<li> <p><strong>explicit作用：</strong> 关闭函数的类型自动转换（防止隐式转换）</p> </li>
<li> <p><strong>当初始化列表时，被初始化的顺序是声明是的顺序不是列表顺序。</strong></p> </li>
<li> <p>命名空间 作用：解决同名冲突，使用<br> a. 方法一：使用命名空间名称::标识符的方式来访问<br> b. 方法二：使用命名using namespace 命名空间名称;的方式作前置声明，在声明之后，可以直接使用标符来访问。<br> c. 特点：允许不连续的命名空间、允许嵌套<br> 类：具有相同的属性和行为的对象的集合。从<br> 访问权限：public（共有的） protected(保护的) private(私有的)</p> </li>
<li> <p>函数缺省参数注意事项：<br> a.如果某个位置已经有了默认参数，那么从这个位置往后，从左往右都必须有默认值.如:func(int a, int b = 20, int c)错误<br> b.缺省值放在声明位置</p> </li>
<li> <p>拷贝构造函数（一般类中有指针才需要自己实现）<br> 三种场景：</p> 
  <ol>
<li>无须实现<br> a. 无指针</li>
<li>需要实现<br> a. 一般类中有指针才需要自己实现</li>
<li>无法实现<br> a. File(const File&amp; other) = delete;//表示禁止使用 拷贝构造</li>
</ol> </li>
<li> <p><strong>浅拷贝</strong>：简单的赋值拷贝操作<br> <strong>深拷贝</strong>：在堆区重新申请空间，进行拷贝操作<br> <strong>浅拷贝常见问题</strong>：堆区数据重复释放</p> </li>
<li> <p><strong>成员变量的初始化</strong></p> 
  <ol>
<li>构造函数体内</li>
<li>构造函数的初始化列表 (速度快)</li>
<li>在成员变量声明时</li>
</ol> </li>
<li> <p><strong>类对象作为类成员</strong><br> c++类的成员可以是另一个类的的对象，我们称该成员为 对象成员<br> 例如：</p> </li>
</ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{<!-- --></span>
     A a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>B类中有对象A作为成员，A为对象成员<br> 创建规则：<strong>先创建A，在创建B 先释放b再释放a</strong></p> 
<p>10.<strong>静态成员、函数</strong><br> <strong>概念</strong>：成员变量和成员函数前加一个static，称为静态成员<br> <strong>目的</strong>：为了实现一个类的不同对象之间的数据和函数共享。<br> <strong>静态成员变量特点：</strong><br> • 所有对象共享同一份数据<br> • 在编译阶段分配内存<br> • 类内的声明，类外初始化<br> a. <strong>语法</strong>：类型 类名::静态变量 = 表达式 <br> b. <strong>访问</strong>：对象.静态成员变量 类名.静态成员变量</p> 
<p><strong>静态成员函数：</strong><br> a.所有对象共享同一个函数<br> b.静态成员函数只能访问静态成员变量<br> 11. 在C++中，类内的成员变量和成员函数分开存储、只有非静态成员变量才属于类的对象上<br> 12. this指针：当形参和成员变量同名时，可用this指针来区分(解决同名冲突)、在类的非静态成员函数中返回对象本身，可使用return * this<br> 13. <strong>const修饰成员函数</strong><br> 常函数：<br> a.成员函数后加const，叫常函数 <br> b.常函数内不可以修改成员属性<br> c.成员属性声明时加关键词mutable后，在常函数依然可以修改<br> 常对象：<br> a.声明对象前加const,叫常对象 <br> b.常对象只能调用常函数<br> 14. <strong>静态多态</strong><br> 重载(在编译时期就可以通过函数名和参数确定需要调用那个函数)<br> 模板<br> <strong>动态多态</strong><br> 虚函数(通过运行阶段才能知道需要调用那个对象)<br> 纯虚函数<br> 虚析构函数<br> 虚函数表<br> 15. <strong>虚析构作用</strong>：使用父类指针释放子类对象时可以让子类的析构函数和父类的析构函数同时被调用到。<br> 16. <strong>虚析构和纯虚析构共性</strong>：<br> • 可以解决父类指针释放子类对象<br> • 都需要具体的函数实现<br> 17. <strong>虚析构语法</strong>：virtual ~类名（）{}；<br> <strong>纯虚析构语法：</strong> virtual ~类名（） = 0；<br> <strong>纯虚析构实现</strong> 类名：：~类名（）{}<br> 18. <strong>继承方法</strong><br> 访问权限<br> • public：在子类和外部可以访问<br> • protected：在子类中可以访问，外部不可以访问<br> • private：在子类和外部都不可以访问</p> 
<p><strong>继承方式</strong>：<br> 子类权限 =&gt; 父类权限与继承权限中取严谨值<br> 影响的是外面对该子类的访问权限以及当该子类当父类时，别的子类的访问权限。<br> 19. 创建对象时：String s1;<br> a. 分配空间 <br> b. 调用构造函数<br> 20. <strong>一个类可以没有缺省构造函数，但最多有一个 无缺构造函数时，无法创建对象数组</strong><img src="https://images2.imgbox.com/d0/6c/GYR4T6YY_o.png" alt="在这里插入图片描述"></p> 
<ol start="21">
<li> <p>匿名对象 A() 生命周期只有本行(当前行执行结束后，系统会立即回收掉)。</p> </li>
<li> <p>**函数重载作用：**达到行为标识符统一，减少程序中标识符的个数</p> </li>
<li> <p>父类中所有非静态成员属性都会被子类继承下去<br> 父类中私有属性 是被编译器隐藏了 因此访问不到 但是的确继承下去了</p> </li>
<li> <p><strong>多继承初始化顺序</strong>：从左向右</p> </li>
<li> <p><strong>菱形继承</strong>：一个类被俩个类继承 这俩个又被一个类继承 <img src="https://images2.imgbox.com/8f/d3/HjGNz5PX_o.png" alt="在这里插入图片描述"></p> </li>
<li> <p>**无法继承的内容：**构造函数、析构函数、友元、运算符重载</p> </li>
<li> <p>子类对象可以赋给父类的指针(引用)</p> </li>
<li> <p><strong>final关键字</strong> 用处：当前我这个类就是最终类，我不想让别的类再继承我自己。</p> </li>
</ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Super</span> <span class="token keyword">final</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">//......</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="31">
<li>
<strong>多态的优点</strong>：（提倡）<br> • 代码组织结构清晰<br> • 可读性强<br> • 利与前期和后期的扩展和维护</li>
<li>
<strong>继承语法</strong>：class 子类 ：public 父类 目的：减少重复代码(代码复用) 实现方式：单继承、多继承</li>
<li>
<strong>重载</strong>：作用域相同函数名相同</li>
<li>
<strong>重写</strong>：父类的方法，子类重写，要求父类的该方法必须是虚函数或者纯虚函数virtual</li>
<li>
<strong>隐藏</strong>：父类的方法，子类重写，要求父类的该方法不能被virtual修饰</li>
<li>在当前类的初始化列表调用基类的构造函数</li>
<li>类是具有相同属性和行为的一组对象的集合</li>
<li>封装是将抽象出的属性成员、行为成员相结合，将它们视为一个整体。<br> 目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口（函数），以特定的访问权限，来使用类的成员。</li>
<li>多态是同一名称，不同的功能实现方式。<br> 目的：达到行为标识符统一，减少程序中标识符的个数<br> 实现：重载函数、虚函数和模板</li>
<li>浅拷贝和深拷贝有什么区别？<br> 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存；而深拷贝会创造⼀个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象。</li>
<li>
<strong>虚继承 作用</strong>：解决多继承时产生的菱形继承问题</li>
</ol> 
<h2>
<a id="newmalloc_324"></a>new与malloc的区别</h2> 
<p><strong>特性</strong>:new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。<br> <strong>参数</strong>:使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。<br> <strong>返回类型</strong>:new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。<br> <strong>分配失败</strong>: new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。<br> <strong>特性</strong>:new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。<br> <strong>参数</strong>:使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p> 
<h2>
<a id="CC_331"></a>C++与C的区别</h2> 
<p>C是面向过程的语言，而C++是面向对象的语言<br> • C只能写面向过程的代码，而C++既可以写面向过程的代码，也可以实现面向对象的代码<br> • C和强制类型转换上也不一样 const_cast static_cast reinterpret_cast dynamic_cast<br> • C和C++的输入输出方式也不一样<br> • C++引⼊入 new/delete 运算符，取代了了C中的 malloc/free 库函数；<br> • C++引⼊入引⽤用的概念<br> • C++引⼊入类的概念<br> • C++引⼊入函数重载的特性</p> 
<h2>
<a id="_340"></a>静态链接和动态链接有什么区别？</h2> 
<p><strong>静态链接</strong><br> 静态链接是在编译链接时直接将需要的执行代码拷贝到调⽤用处；<br> <strong>优点:</strong> 在于程序在发布时不需要依赖库，可以独立执行，<br> <strong>缺点:</strong> 在于程序的体积会相对较大，⽽而且如果静态库更更新之后，所有可执行文件需要重新链接；<br> <strong>动态链接</strong><br> 动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运⾏行行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行行到指定代码时，在共享执行内存中寻找已经加载的动态库可执⾏代码，实现运行时链接；<br> <strong>优点</strong> 在于多个程序可以共享同一个动态库，节省资源；<br> <strong>缺点</strong> 在于由于运行时加载，可能影响程序的前期执行性能</p> 
<h2>
<a id="_349"></a>指针和引用的区别</h2> 
<table>
<thead><tr>
<th>指针</th>
<th>引用(优先使用)</th>
</tr></thead>
<tbody>
<tr>
<td>指针是地址，有存储空间</td>
<td>就是别名</td>
</tr>
<tr>
<td>指针可以有多级</td>
<td>引用只能是一级</td>
</tr>
<tr>
<td>指针可以指向NULL</td>
<td>引用不可以为NULL</td>
</tr>
<tr>
<td>指针可以在定义的时候不初始化</td>
<td>引用必须在定义的时候初始化</td>
</tr>
<tr>
<td>指针初始化之后可以再改变指向</td>
<td>引用初始化后不可以再改变指向</td>
</tr>
<tr>
<td>sizeof 的运算结果不同,指针就是4/8字节</td>
<td>而引用是被引⽤用对象的大⼩</td>
</tr>
<tr>
<td>指针作为函数参数时，指针需要检查是否为空。</td>
<td>引用作为函数参数时，引用不需要见检查是否为空</td>
</tr>
<tr>
<td>指针使用自增运算是指针指向向后偏移一个存储单元</td>
<td>引用自增是将对应的值+1</td>
</tr>
<tr>
<td></td>
<td>引用比指针多了类型检查</td>
</tr>
</tbody>
</table>
<h2>
<a id="_362"></a>类和结构体的区别</h2> 
<p><strong>类和结构体的区别</strong>：struct默认访问权限公有 class默认访问权限私有<br> struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。<br> C++之所以要引入结构体，是为了保持和C程序的兼容性。</p> 
<h2>
<a id="defineinline_366"></a>define与inline区别</h2> 
<p>相同点：拿空间换时间，提高程序的执行效率</p> 
<table>
<thead><tr>
<th>define</th>
<th>inline</th>
</tr></thead>
<tbody>
<tr>
<td>内联函数在编译时展开，</td>
<td>宏是由预处理器对宏进行展开</td>
</tr>
<tr>
<td>内联函数会检查参数类型，所以内联函数更安全</td>
<td>宏定义不检查函数参数。</td>
</tr>
<tr>
<td>inline是函数</td>
<td>宏不是函数</td>
</tr>
<tr>
<td>程序员设置的内联函数编译器不一定会满足要求，这取决于函数大小或者函数是否调用自身</td>
<td>宏在定义时要小心处理宏参数，（一般情况是把参数用括弧括起来）</td>
</tr>
</tbody>
</table>
<h2>
<a id="_376"></a>前置++与后置++区别</h2> 
<p>后置++中tmp是一个临时对象，会造成一次构造函数和一次析构函数的额外开销<br> 效率高：前置++，不产生临时对象</p> 
<h2>
<a id="staticCc_380"></a>static在C和c++的区别</h2> 
<p>在C和C++都可以作用于局部变量 叫静态局部变量<br> 在函数调用时，只有在该函数第一次调用时才对其分配空间和初始化。在函数调用结束时，不对该变量的内存进行释放，值仍然保留。这也是于自动变量的区别</p> 
<p>在C和C++中都可以作用于全局变量和全局函数<br> 表示该变量或者函数是私有的，只能在该文件使用。不能通过extern关键字对其引用。</p> 
<p>修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不不加 static</p> 
<p>修饰成员函数时，该函数不接受 this 指针，只能访问类的静态成员；不需要实例化对象即可访问</p> 
<h2>
<a id="%E3%80%80friend_391"></a>友元　friend</h2> 
<p>友元：让一个函数或者类，访问另一个类的私有成员(打破封装)<br> 三种实现：<br> • 全局函数做友元<br> • 类做友元(友元类)<br> • 成员函数做友元</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>