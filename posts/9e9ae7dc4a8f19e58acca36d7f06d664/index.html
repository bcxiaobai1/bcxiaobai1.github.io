<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>十大机器学习算法 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">十大机器学习算法</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p><strong>初学者应该知道的十大机器学习算法</strong></p> 
<blockquote> 
 <p>来源：https://builtin.com/data-science/tour-top-10-algorithms-machine-learning-newbies</p> 
</blockquote> 
<p>机器学习算法被描述为学习一个目标函数 (f)，它最好地将输入变量 (X) 映射到输出变量 (Y)：Y = f(X)</p> 
<p>最常见的机器学习类型是学习映射 Y = f(X) 以针对新 X 预测 Y。这称为预测建模或预测分析，目标就是要做出最准确的预测。<img src="https://images2.imgbox.com/59/a4/5Uznd9FI_o.png" alt=""></p> 
<p></p>
<div class="toc">
 <h3>机器学习算法</h3>
 <ul>
<li><a href="#_10">线性回归</a></li>
<li><a href="#_19">逻辑回归</a></li>
<li><a href="#_29">线性判别分析</a></li>
<li><a href="#_40">分类和回归树</a></li>
<li><a href="#_49">朴素贝叶斯</a></li>
<li><a href="#K_KNN_59">K-最近邻 (KNN)</a></li>
<li><a href="#_LVQ_69">学习向量量化 (LVQ)</a></li>
<li><a href="#_SVM_80">支持向量机 (SVM)</a></li>
<li><a href="#Bagging__92">Bagging 和随机森林</a></li>
<li><a href="#Boosting__AdaBoost_106">Boosting 和 AdaBoost</a></li>
</ul>
</div>
<p></p> 
<h1>
<a id="_10"></a>线性回归</h1> 
<p>线性回归是统计和机器算法中最容易理解的算法之一。</p> 
<p>线性回归的表示是一个方程，它<strong>通过找到称为系数 (B) 的输入变量的特定权重来描述最适合输入变量 (x) 和输出变量 (y) 之间关系的直线。</strong><br> <img src="https://images2.imgbox.com/79/0b/pfpqSjWn_o.png" alt="在这里插入图片描述"><br> <em>例如：y = B0 + B1 * x</em><br> 我们将在给定输入 x 的情况下预测 y，<strong>线性回归学习算法的目标是找到系数 B0 和 B1 的值。</strong></p> 
<p>可以使用不同的技术从数据中学习线性回归模型，例如普通最小二乘的线性代数解决方案和梯度下降优化。</p> 
<h1>
<a id="_19"></a>逻辑回归</h1> 
<p>逻辑回归是机器学习从统计学领域借用的另一种技术。它是二进制分类问题（具有两个类值的问题）的首选方法。</p> 
<p>逻辑回归类似于线性回归，其目标是<strong>找到加权每个输入变量的系数值</strong>。<strong>与线性回归不同，输出的预测是使用称为逻辑函数的非线性函数转换的。</strong></p> 
<p>逻辑函数看起来像一个大 S，会将任何值转换为 0 到 1 的范围。这很有用，因为我们可以将规则应用于逻辑函数的输出以将值捕捉到 0 和 1（例如，如果小于 0.5 则输出 1) 并预测一个类值。<br> <img src="https://images2.imgbox.com/f8/9c/f0D2I8kJ_o.png" alt="逻辑回归：逻辑回归曲线图，显示通过考试的概率与学习时间的关系"><br> 由于模型的学习方式，逻辑回归所做的预测也可以用作给定数据实例属于 0 类或 1 类的概率。这对于需要给出更多理由的问题是很有用一个预测。</p> 
<p>与线性回归一样，当您删除与输出变量无关的属性以及彼此非常相似（相关）的属性时，逻辑回归的效果会更好。这是一个快速学习的模型，并且对二元分类问题有效。</p> 
<h1>
<a id="_29"></a>线性判别分析</h1> 
<p>逻辑回归是一种传统上仅限于两类分类问题的分类算法。如果您有两个以上的类别，则线性判别分析算法是首选的线性分类技术。</p> 
<p>LDA 的表示非常简单。它由您的数据的统计属性组成，为每个类计算。对于单个输入变量，这包括：</p> 
<ol>
<li>每个类别的平均值。</li>
<li>跨所有类计算的方差。</li>
</ol> 
<p><img src="https://images2.imgbox.com/a9/e6/pJWuqGWt_o.png" alt="在这里插入图片描述"><br> 通过计算每个类别的判别值并针对具有最大值的类别进行预测。假设数据具有高斯分布（钟形曲线），因此最好事先从数据中删除异常值。它是分类预测建模问题的一种简单而强大的方法。</p> 
<h1>
<a id="_40"></a>分类和回归树</h1> 
<p>决策树是预测建模机器学习的一种重要算法。</p> 
<p>决策树模型的表示是二叉树。这是来自算法和数据结构的二叉树，没什么花哨的。每个节点代表一个输入变量 (x) 和该变量上的一个分割点（假设变量是数字）。<br> <img src="https://images2.imgbox.com/5d/48/bo7QPGTy_o.png" alt="在这里插入图片描述"><br> 树的叶节点包含一个输出变量 (y)，用于进行预测。通过遍历树的分裂直到到达叶节点并在该叶节点处输出类值来进行预测。</p> 
<p>树的预测速度也很快。它们通常对于广泛的问题也很准确，并且不需要对数据进行任何特殊准备。</p> 
<h1>
<a id="_49"></a>朴素贝叶斯</h1> 
<p>朴素贝叶斯是一种简单但功能强大的预测建模算法。</p> 
<p>该模型由两种类型的概率组成，可以直接从您的训练数据中计算出来：<br> 1）每个类别的概率；<br> 2）给定每个 x 值的每个类的条件概率。<br> 计算后，概率模型可用于使用贝叶斯定理对新数据进行预测。当数据是实值时，通常假设高斯分布（钟形曲线），以便可以轻松估计这些概率。<br> <img src="https://images2.imgbox.com/9e/98/7jVlmMAl_o.png" alt="在这里插入图片描述"><br> 朴素贝叶斯被称为朴素，因为它假设每个输入变量都是独立的。这是一个强有力的假设，对于真实数据来说是不现实的，然而，该技术在处理大量复杂问题时非常有效。</p> 
<h1>
<a id="K_KNN_59"></a>K-最近邻 (KNN)</h1> 
<p>KNN算法非常简单，非常有效。KNN 的模型表示是整个训练数据集。</p> 
<p>通过在整个训练集中搜索 K 个最相似的实例（邻居）并汇总这些 K 个实例的输出变量，对新数据点进行预测。</p> 
<p>对于回归问题，这可能是平均输出变量，对于分类问题，这可能是模式（或最常见的）类值。</p> 
<p><strong>诀窍在于如何确定数据实例之间的相似性。</strong><img src="https://images2.imgbox.com/aa/96/jAISJ3Wc_o.png" alt="在这里插入图片描述"><br> KNN 可能需要大量内存或空间来存储所有数据，但仅在需要预测时才及时执行计算（或学习）。这个期间你可以随着时间的推移更新和管理训练实例，以保持预测的准确性。</p> 
<h1>
<a id="_LVQ_69"></a>学习向量量化 (LVQ)</h1> 
<p><strong>K-Nearest Neighbors 的一个缺点是需要保留整个训练数据集。</strong></p> 
<p>学习向量量化算法（或简称 LVQ）是一种人工神经网络算法，它允许选择要挂起的训练实例数量并准确了解这些实例的外观。</p> 
<p><img src="https://images2.imgbox.com/4b/05/lMFK5yvn_o.png" alt="在这里插入图片描述"><br> LVQ 的表示是码本向量的集合。这些是在开始时随机选择的，并适合在学习算法的多次迭代中最好地总结训练数据集。学习后，码本向量可以像 K-Nearest Neighbors 一样用于进行预测。通过计算每个码本向量与新数据实例之间的距离，找到最相似的邻居（最佳匹配码本向量）。然后返回最佳匹配单元的类值或（回归情况下的实际值）作为预测。<br> 如果重新调整数据以具有相同的范围，例如在 0 和 1 之间，则可以获得最佳结果。</p> 
<p>如果发现 KNN 在你的数据集上提供了良好的结果，可以尝试使用 LVQ 来减少存储整个训练数据集的内存需求。</p> 
<h1>
<a id="_SVM_80"></a>支持向量机 (SVM)</h1> 
<p>支持向量机可能是最受欢迎和谈论最多的机器学习算法之一。</p> 
<p>超平面是分割输入变量空间的线。</p> 
<p>在 SVM 中，选择一个超平面来最好地将输入变量空间中的点按它们的类（类 0 或类 1）分开。在二维中，你可以将其可视化为一条线，假设我们所有的输入点都可以被这条线完全隔开。<strong>SVM 学习算法通过超平面找到导致类的最佳分离的系数。</strong><br> <img src="https://images2.imgbox.com/5c/96/pmYTCCEE_o.png" alt="在这里插入图片描述"><br> <strong>超平面和最近数据点之间的距离称为边距。<br> 可以分离这两个类的最佳或最优超平面是具有最大边距的线。</strong></p> 
<p>只有这些点与定义超平面和构建分类器有关。这些点称为支持向量。它们支持或定义超平面。在实践中，使用优化算法来找到最大化边际的系数值。</p> 
<h1>
<a id="Bagging__92"></a>Bagging 和随机森林</h1> 
<p>随机森林是最流行和最强大的机器学习算法之一。它是一种集成机器学习算法。称为 Bootstrap Aggregation 或 bagging。</p> 
<p>Bootstrap是一种强大的统计方法，用于从数据样本中估计数量。</p> 
<p>在 bagging 中，使用相同的方法，但用于估计整个统计模型，最常见的是决策树。</p> 
<p><strong>获取训练数据的多个样本，然后为每个数据样本构建模型。当你需要对新数据进行预测时，每个模型都会进行预测，并对预测进行平均以更好地估计真实输出值。</strong></p> 
<p><img src="https://images2.imgbox.com/fb/80/n8W13O7A_o.png" alt="在这里插入图片描述"><br> 随机森林是对这种方法的一种调整，其中创建了决策树，因此不是选择最佳分割点，而是<strong>通过引入随机性来进行次优分割。</strong></p> 
<p>因此，为每个数据样本创建的模型与其他模型相比更加不同，但仍然以其独特和不同的方式准确。结合他们的预测可以更好地估计真实的潜在输出值。</p> 
<h1>
<a id="Boosting__AdaBoost_106"></a>Boosting 和 AdaBoost</h1> 
<p><strong>Boosting 是一种集成技术，它试图从多个弱分类器中创建一个强分类器。</strong></p> 
<p>这是通过从训练数据构建模型，然后创建第二个模型来尝试纠正第一个模型中的错误来完成的。添加模型直到训练集被完美预测或添加最大数量的模型。</p> 
<p>AdaBoost 是为二进制分类开发的第一个真正成功的提升算法。这是理解 boosting 的最佳起点。</p> 
<p>AdaBoost 与短决策树一起使用。<br> 在创建第一棵树后，树在每个训练实例上的性能用于衡量下一棵创建的树应该对每个训练实例的关注程度。难以预测的训练数据被赋予更高的权重，而易于预测的实例被赋予更少的权重。</p> 
<p>模型一个接一个地按顺序创建，每个模型都会更新训练实例上的权重，这些权重会影响序列中下一棵树执行的学习。</p> 
<p>在构建完所有树之后，将对新数据进行预测，并且每棵树的性能取决于它在训练数据上的准确程度。</p> 
<p>由于算法非常重视纠正错误，因此拥有干净的数据并删除异常值非常重要。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>