<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>springboot第22集：security，Lombok，token，redis - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot第22集：security，Lombok，token，redis</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>Spring Security是一个基于Spring框架的权限管理框架，用于帮助应用程序实现身份验证和授权功能。它可以为Web应用程序、REST API和方法级安全性提供支持，并支持各种认证方式。</p> 
 <p>Spring Security最初是Acegi Security的前身，但由于其配置繁琐而受到批评。随着Spring Boot的出现，Spring Security的易用性得到了极大的提高，成为了Spring Boot和Spring Cloud项目中常用的安全框架。</p> 
 <p>Spring Security的基本功能包括认证和授权。认证方面，它支持多种常见的认证方式，例如基于表单的认证、HTTP基本认证、OpenID Connect、OAuth2等。授权方面，它提供了基于URL的请求授权、支持方法访问授权以及对象访问授权等能力，可用于限制用户对应用程序中资源的访问。除此之外，Spring Security还提供了一些其他的安全特性，例如CSRF防护、会话管理等，以帮助应用程序保护安全性和保密性。</p> 
 <p>Spring Security是一个强大的安全性框架，它被广泛用于基于Java的Web应用程序中。它基于Servlet过滤器实现了一套标准化的认证和授权机制，通过一系列Filter来处理Web请求，以确保只有经过身份验证的用户可以访问系统中的受保护资源。</p> 
 <p>在Spring Security中，Filter链是一个重要的概念。它由多个Filter组成，每个Filter都负责执行不同的任务，例如身份验证、授权、防止CSRF攻击等。这些Filter按照特定的顺序组成了一个链条，每当一个请求到达应用程序时，请求将被传递给Filter链，直到找到合适的Filter进行处理或者抛出异常。</p> 
 <p>在Filter链中，认证和授权通常是最核心的部分。Spring Security提供了各种方式来进行身份验证和授权，例如表单登录、基本认证、OAuth2等。在处理过程中，如果出现任何异常，如认证失败或权限不足，Spring Security将会抛出异常并将其传递给异常处理器进行处理。异常处理器通常会捕获异常、记录日志并向用户显示错误消息，以便及时解决问题。</p> 
 <p>总之，Filter链是Spring Security中非常重要的一环，它能够为我们的Web应用程序提供强大的安全性保障。通过组织不同的Filter，Spring Security可以提供多种不同的身份验证和授权机制，使我们能够轻松地保护应用程序中的敏感资源。</p> 
 <p>除了上述提到的Spring Security常用组件外，还有以下一些组件：</p> 
 <ol>
<li><p>AccessDecisionManager：用于根据用户和资源的相关信息判断是否允许用户访问资源。</p></li>
<li><p>AuthenticationEntryPoint：如果一个未认证的用户试图访问需要认证的资源，会被重定向到该接口实现的方法处理。</p></li>
<li><p>AuthenticationProvider：用于对用户进行认证并生成认证对象 Authentication。</p></li>
<li><p>FilterSecurityInterceptor：在请求到达后台之前进行拦截和处理，包含很多安全检查点。</p></li>
<li><p>RememberMeAuthenticationProvider：为支持“记住我”功能提供的认证处理器，用于生成认证对象 Authentication。</p></li>
<li><p>SessionRegistry：用于跟踪已经登录的用户，通常在实现“单点登录”时使用。</p></li>
</ol> 
 <p>这些组件可以通过配置文件中的bean来进行自定义，并且可以根据具体情况进行组合搭配，以实现更加灵活、高效的安全管理方案。</p> 
 <p>引入 Spring Security 依赖</p> 
 <pre class="has"><code class="language-go">&lt;!--引入 Spring Security--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
 <p>引入依赖后，不做任何配置，Spring Security 会自动生效，请求将跳转登录页面</p> 
 <p>默认用户名、密码和权限可在 application.yaml 中配置</p> 
 <pre class="has"><code class="language-go">@Configuration
@EnableWebSecurity
// 开启注解设置权限
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    // 配置密码加密器
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // 配置认证管理器
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("admin")
                .password(passwordEncoder().encode("123")).roles("admin")
                .and()
                .withUser("user")
                .password(passwordEncoder().encode("456")).roles("user");
    }
    
    // 配置安全策略
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 设置路径及要求的权限，支持 ant 风格路径写法
        http.authorizeRequests()
            // 设置 OPTIONS 尝试请求直接通过
             .antMatchers(HttpMethod.OPTIONS, "/**").permitAll()
             .antMatchers("/api/demo/user").hasAnyRole("user", "admin")
             // 注意使用 hasAnyAuthority 角色需要以 ROLE_ 开头
                .antMatchers("/api/demo/admin").hasAnyAuthority("ROLE_admin")
                .antMatchers("/api/demo/hello").permitAll()
                .and()
             // 开启表单登录
                .formLogin().permitAll()
                .and()
             // 开启注销
                .logout().permitAll();
    }
}</code></pre> 
 <pre class="has"><code class="language-go">@Override
protected void configure(HttpSecurity http) throws Exception {
    // 关闭 csrf 防御
    http.csrf().disable();
    // 关闭会话管理
    http.sessionManagement()
        .sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    // ...
}</code></pre> 
 <pre class="has"><code class="language-go">public class CustomAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request,
                                                HttpServletResponse response) throws AuthenticationException {
        // 判断是否为 JSON 格式请求
        if(request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)){
            // ...
        } else {
            return super.attemptAuthentication(request, response);
        }
    }
}</code></pre> 
 <pre class="has"><code class="language-go">@Autowired
private CustomUserDetailsService customUserDetailsService
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(customUserDetailsService)
        .passwordEncoder(passwordEncoder());
}</code></pre> 
 <pre class="has"><code class="language-go">public class CustomUserDetailsService implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        // 根据 username 查询用户
        User user = userMapper.getUserByUsername(s);
        if (user == null) {
            // ...
        }
        // 查询角色或权限
        List&lt;SimpleGrantedAuthority&gt; authorities = userMapper.listRolesByUsername(s)
            .stream()
            .map(SimpleGrantedAuthority::new)
            .collect(Collectors.toList());
        // 构造 UserDetails 实例并返回
    }
}</code></pre> 
 <pre class="has"><code class="language-go">public class CustomUserDetailsService implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        // 根据 username 查询用户
        User user = userMapper.getUserByUsername(s);
        if (user == null) {
            // ...
        }
        // 查询角色或权限
        List&lt;SimpleGrantedAuthority&gt; authorities = userMapper.listRolesByUsername(s)
            .stream()
            .map(SimpleGrantedAuthority::new)
            .collect(Collectors.toList());
        // 构造 UserDetails 实例并返回
    }
}</code></pre> 
 <pre class="has"><code class="language-go">@Override
protected void configure(HttpSecurity http) throws Exception {
    http.formLogin().permitAll()
        .loginProcessingUrl("/login")
        .successHandler(customLoginSuccessHandler)
}</code></pre> 
 <p>CustomLoginSuccessHandler，以 JSON 形式返回前端，携带生成的 Token</p> 
 <pre class="has"><code class="language-go">@Component
@RequiredArgsConstructor
public class CustomLoginSuccessHandler implements AuthenticationSuccessHandler {

    private final JwtUtil jwtUtil;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                        Authentication authentication) throws IOException {
        // 构造一个统一返回格式对象
        Map&lt;String, Object&gt; res = new HashMap&lt;&gt;();
        res.put("code", 200);
        res.put("message": "认证成功");
        res.put("path": "login");
        Object principal = authentication.getPrincipal();
        if (principal instanceof User) {
            // 根据用户信息，使用 JWT 工具类构建 Token
            // ...
            // 存到返回内容中
            res.put("data", "xxxxxx")
        }
        // 以 JSON 格式写入 response
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");
        PrintWriter writer = response.getWriter();
        writer.print(JsonUtil.Obj2Str(res));
        writer.flush();
    }
}</code></pre> 
 <pre class="has"><code class="language-go">@Override
protected void configure(HttpSecurity http) throws Exception {
    http.formLogin().permitAll()
        .loginProcessingUrl("/login")
        .failureHandler(customLoginFailureHandler)
}</code></pre> 
 <pre class="has"><code class="language-go">@Component
public class CustomLoginFailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
                                        AuthenticationException exception) {
        // 封装的统一返回格式对象
        Res&lt;Object&gt; res = Res.of(ResCode.TOKEN_CREATE_FAIL).path("/login");
        // 根据异常设置失败信息
        if (exception instanceof LockedException) {
            res.errorMsg("账户被锁定");
        } else if (exception instanceof CredentialsExpiredException) {
            res.errorMsg("密码过期");
        } else if (exception instanceof AccountExpiredException) {
            res.errorMsg("账户过期");
        } else if (exception instanceof DisabledException) {
            res.errorMsg("账户被禁用");
        } else if (exception instanceof BadCredentialsException) {
            res.errorMsg("用户名或者密码输入错误");
        }
        // 封装的 JSON 格式写入 response 工具方法
        WebUtil.writeJsonToResponse(response, JsonUtil.objToStr(res));
    }
}</code></pre> 
 <pre class="has"><code class="language-go">@Override
protected void configure(HttpSecurity http) throws Exception {
    http.exceptionHandling()
        .authenticationEntryPoint(customAuthenticationEntryPoint)
}</code></pre> 
 <pre class="has"><code class="language-go">@Component
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, 
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        // 构造未登录的返回内容
        Res&lt;Object&gt; res = Res.of(ResCode.TOKEN_NOT_EXIST)
                .path(request.getRequestURI());
        WebUtil.writeJsonToResponse(response, JsonUtil.objToStr(res));
    }
}</code></pre> 
 <pre class="has"><code class="language-go">@Override
protected void configure(HttpSecurity http) throws Exception {
    http.exceptionHandling()
        .accessDeniedHandler(customAccessDeniedHandler);
}</code></pre> 
 <pre class="has"><code class="language-go">@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException, ServletException {
        // 构造权限不足的返回内容 
        Res&lt;Object&gt; res = Res.of(ResCode.TOKEN_NO_AUTHORITY)
                .path(request.getRequestURI());
        WebUtil.writeJsonToResponse(response, JsonUtil.objToStr(res));
    }
}</code></pre> 
 <pre class="has"><code class="language-go">@Override
protected void configure(HttpSecurity http) throws Exception {
    http.logout().permitAll()
        .logoutUrl("/logout")
        .logoutSuccessHandler(logoutSuccessHandler);
}</code></pre> 
 <pre class="has"><code class="language-go">@Component
public class CustomLogoutSuccessHandler implements LogoutSuccessHandler {
    @Override
    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response,
                                Authentication authentication) throws IOException, ServletException {
        // 构造注销成功的返回内容
        Res&lt;String&gt; res = Res.ok("注销成功").path("/logout");
        WebUtil.writeJsonToResponse(response, JsonUtil.objToStr(res));
    }
}</code></pre> 
 <pre class="has"><code class="language-go">@Override
protected void configure(HttpSecurity http) throws Exception {
    http.addFilterBefore(jwtAuthenticationTokenFilter,
                         UsernamePasswordAuthenticationFilter.class);
}</code></pre> 
 <pre class="has"><code class="language-go">@Component
@RequiredArgsConstructor
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    private final UserDetailsService userDetailsService;
    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest httpServletRequest, 
                                    HttpServletResponse httpServletResponse,
                                    FilterChain filterChain) throws ServletException, IOException {
        // 取出 header 中的 token 进行校验
        String authHeader = httpServletRequest.getHeader(jwtUtil.getHeader());
        if (authHeader != null &amp;&amp; !StringUtil.isEmpty(authHeader)) {
            String username = jwtUtil.getUsernameFromToken(authHeader);
            if (username != null 
                &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {
                // 根据 username 查询用户，可以从缓存、数据库中获取
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                // 校验
                if (jwtUtil.validateToken(authHeader, userDetails)) {
                    // 构建 authentication
                    UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails,
                                                                null,
                                                                userDetails.getAuthorities());
                    // 设置 details，其中包含地址、session 等
                    authentication.setDetails(new 
                                              WebAuthenticationDetails(httpServletRequest));
                    // 设置 authentication 到上下文对象中
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        filterChain.doFilter(httpServletRequest, httpServletResponse);
    }
}</code></pre> 
 <pre class="has"><code class="language-go">public class MySecurityMetadataSource implements FilterInvocationSecurityMetadataSource {
    private final AntPathMatcher antPathMatcher = new AntPathMatcher();
    private final FilterInvocationSecurityMetadataSource superMetadataSource;
    private final Map&lt;String, String[]&gt; urlRoleMap = new HashMap&lt;&gt;();

    public MySecurityMetadataSource(
            FilterInvocationSecurityMetadataSource metadataSource) {
        this.superMetadataSource = metadataSource;
        // 此处可以从数据库加载权限配置
        urlRoleMap.put("/api/demo/admin", new String[]{"ROLE_admin"});
        urlRoleMap.put("/api/demo/user", new String[]{"ROLE_user", "ROLE_admin"});
    }

    @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException {
        FilterInvocation fi = (FilterInvocation) object;
        String url = fi.getRequestUrl();
        for (Map.Entry&lt;String, String[]&gt; entry : urlRoleMap.entrySet()) {
            if (antPathMatcher.match(entry.getKey(), url)) {
                // 生成 ConfigAttribute
                return SecurityConfig.createList(entry.getValue());
            }
        }
        // 返回配置类定义的默认权限配置
        return superMetadataSource.getAttributes(object);
    }
}</code></pre> 
 <pre class="has"><code class="language-go">http.authorizeRequests()
    .anyRequest().authenticated()
    .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {
        @Override
        public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) {
            // 设置为自定义的 SecurityMetadataSource
            object.setSecurityMetadataSource(mySecurityMetadataSource);
            // AffirmativeBased 是 AccessDecisionManager 的一种
            // AffirmativeBased，有一个投票器通过就通过
            // UnanimousBased，有一个投票器不通过就不通过，全部弃权也不通过
            object.setAccessDecisionManager(new AffirmativeBased(
                Arrays.asList(
                    new WebExpressionVoter(),
                    new RoleVoter()
                )));
            return object;
        }
    })
/**
 * 如果使用 UnanimousBased
 * 到达 RoleVoter 的 ConfigAttribute 是从数据库动态获取的，可能有多个
 * UnanimousBased 对每个 ConfigAttribute 进行投票，即所有权限都有才算通过
 */</code></pre> 
 <p>po, dto，vo</p> 
 <p>post body请求参数，命名规范 XxRequest</p> 
 <p>展示层对象命名，XxVo</p> 
 <p>数据传输对象命名，XxDto</p> 
 <p>es实体名命名 XxIndexDO</p> 
 <p>db实体命名 跟表名相同</p> 
 <p>mongo实体命名 XxDoc</p> 
 <p>db组合关联实体命名 Xx</p> 
 <p>service接口命名 XxService</p> 
 <p>service实现命名 XxServiceImpl</p> 
 <p>manager，service引入多个manager进行负责的组合业务处理 XxManager</p> 
 <p>dao层命名 XxMapper</p> 
 <p>封装持久组合服务 XxRepository</p> 
 <pre class="has"><code class="language-go">apitest
bean
 dto
  CoolBoyDto
  CoolGirlDto
 po
  CoolBoy
  CoolGril
 vo
  CoolBoyVo
 GrilTypeEnums
cache
converter
 BoyGirlConverter
model
repository
request
service</code></pre> 
 <img src="https://images2.imgbox.com/b9/61/JtZnxjKs_o.png" alt="22a417e9ccda4352b4b6ea5c6c33230d.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <p>logback.xml</p> 
 <pre class="has"><code class="language-go">&lt;statusListener class="ch.qos.logback.core.status.NopStatusListener" /&gt;</code></pre> 
 <pre class="has"><code class="language-go">server {

listen 80;

server_name xx.com;

charset utf-8;

 location / {

alias xxn-front/dist/;

try_files $uri $uri/ /index.html;

index  index.html index.htm;

}

location /api {

proxy_pass http://localhost:xxx/api;

proxy_set_header x-forwarded-for  $remote_addr;

}

}</code></pre> 
 <img src="https://images2.imgbox.com/4b/77/ntHWURf9_o.png" alt="07bdfbc137e4e958f5391580319fa68f.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <img src="https://images2.imgbox.com/db/5b/vLeege8m_o.png" alt="2a7db92a6128691f18fe885554b9a0ab.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <img src="https://images2.imgbox.com/32/1b/MQsjwxMG_o.png" alt="700a5a5614b26c1ba0a2a8f95e68d12d.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <pre class="has"><code class="language-go">##qq登陆相关##

qq.app.id=xxx

qq.app.key=xxx

qq.url.authorization=https://graph.qq.com/oauth2.0/authorize?response_type=code&amp;client_id=%s&amp;redirect_uri=%s&amp;state=%s

qq.url.access.token=https://graph.qq.com/oauth2.0/token?grant_type=authorization_code&amp;client_id=%s&amp;client_secret=%s&amp;code=%s&amp;redirect_uri=%s

qq.url.openid=https://graph.qq.com/oauth2.0/me?access_token=%S

qq.url.user.info=https://graph.qq.com/user/get_user_info?access_token=%s&amp;oauth_consumer_key=%s&amp;openid=%s

qq.url.redirect=http://easypan.wuhancoder.com/qqlogincalback</code></pre> 
 <h1>邮箱配置</h1> 
 <p>1、邮箱配置</p> 
 <p>#发送邮件的邮箱，建议就试用qq邮箱</p> 
 <p>spring.mail.username=test@qq.com</p> 
 <p>#发送邮箱的密码</p> 
 <p>spring.mail.password=123</p> 
 <p>qq登录：</p> 
 <p>设置-&gt;账户-&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</p> 
 <img src="https://images2.imgbox.com/89/4f/My2OpZoE_o.png" alt="d5359ec266ed7efd291df32ebccd2deb.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <p>微信登录QQ邮箱:</p> 
 <p>个人头像-&gt;设置-&gt;第三方服务</p> 
 <figcaption></figcaption> 
 <h1>安装Redis</h1> 
 <h2>下载Redis</h2> 
 <p>下载地址：https://wwur.lanzout.com/iD8Ow0ti96dg 密码:4y2e</p> 
 <h2>安装</h2> 
 <p>解压直接双击安装，无需修改配置，一路下一步即可</p> 
 <img src="https://images2.imgbox.com/52/e9/fyCL3hcD_o.png" alt="a74ae953de31f126ec929bfb79fcbac7.png"> 
 <h1>安装ffmpeg</h1> 
 <h2>下载</h2> 
 <p>下载地址:https://wwur.lanzout.com/iORvc0tia6uj 密码:9n15</p> 
 <h2>查看版本</h2> 
 <p>然后开启doc执行ffmpeg -verison</p> 
 <h1>搜索gitlab镜像</h1> 
 <p>由于Mac M1芯片区别去Intel，所以在找镜像的时候需要勾选ARM 64，然后一般推荐的镜像就是gitlab-ce。</p> 
 <img src="https://images2.imgbox.com/ae/76/6OkokCSq_o.png" alt="8b3dabcecf3ca27204c2a7eafb9d28cb.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <img src="https://images2.imgbox.com/02/f0/HOA0wylf_o.png" alt="7e305478366016ab7bc67ea0886adbad.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <pre class="has"><code class="language-go">docker run 
  -itd  
  --detach 
  --restart always 
  --name gitlab-ce 
  --privileged 
  --memory 4096M 
  --publish 9922:22 
  --publish 9980:80 
  --volume 在本地创建一个文件夹保存映射的文件/etc:/etc/gitlab:z 
  --volume 在本地创建一个文件夹保存映射的文件/log:/var/log/gitlab:z 
  --volume 在本地创建一个文件夹保存映射的文件/opt:/var/opt/gitlab:z 
  yrzr/gitlab-ce-arm64v8:latest</code></pre> 
 <pre class="has"><code class="language-go">// 进入容器
docker exec -it gitlab-ce /bin/bash

// 修改gitlab.rb 如图1
vi /etc/gitlab/gitlab.rb

// 在最下面加入以下代码
// gitlab地址,端口默认为80端口
external_url 'http://192.168.124.194'

// ssh主机ip
gitlab_rails['gitlab_ssh_host'] = '192.168.124.194'

// ssh连接端口
gitlab_rails['gitlab_shell_ssh_port'] = 9922

// 修改http和ssh配置，如图2
vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml

注意此处的host为线上服务器IP，或者改为域名，如果没有则不需要修改

// 修改成功后重启
gitlab-ctl restart

// 退出容器
exit</code></pre> 
 <pre class="has"><code class="language-go">// 进入容器
docker exec -it gitlab /bin/bask

// 进入控制台
gitlab-rails console -e production

// 查询id为1的账号，1默认是超级管理员
User.where(id:1).first

// 修改密码 密码如果只有数字无法保存
user.password='abc123456'

// 保存修改 如果返回true则表示保存成功
user.save!

// 退出容器
exit</code></pre> 
 <p>portainer是一款Docker可视化工具，可以方便我们查看和管理Container和Image</p> 
 <p>打开终端输入命令敲回车</p> 
 <pre class="has"><code class="language-go">docker run -d -v "/var/run/docker.sock:/var/run/docker.sock" -p 9000:9000 portainer/portainer</code></pre> 
 <p>安装完成之后运行</p> 
 <pre class="has"><code class="language-go">docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name portainer  docker.io/portainer/portainer</code></pre> 
 <p>浏览器打开 localhost:9000</p> 
 <h1>Lombok(不建议）</h1> 
 <ul>
<li><p>@Getter/@Setter</p></li>
<li><p>@ToString</p></li>
<li><p>@EqualsAndHashCode</p></li>
<li><p>@NoArgsConstructor</p></li>
<li><p>@AllArgsConstructor</p></li>
<li><p>@RequiredArgsConstructor</p></li>
<li><p>@Data</p></li>
<li><p>@Value</p></li>
<li><p>@Builder</p></li>
<li><p>@Slf4j</p></li>
</ul> 
 <p>缺点依赖jdk，版本，插件</p> 
 <img src="https://images2.imgbox.com/73/0d/AyPsK2S5_o.png" alt="cbba7df93077fbbdb574ba65a8e33436.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <img src="https://images2.imgbox.com/a1/68/09ZAi7pB_o.png" alt="99c838783b2abdb9da33a87f25426695.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <pre class="has"><code class="language-go">&lt;!--jsonwebtoken 生成token的库 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
            &lt;version&gt;0.9.1&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
 <pre class="has"><code class="language-go">TokenService</code></pre> 
 <pre class="has"><code class="language-go">createToken</code></pre> 
 <pre class="has"><code class="language-go">parseToken</code></pre> 
 <img src="https://images2.imgbox.com/2c/41/Ueq1Ufsh_o.png" alt="c5bf1ccd8fc4bfc9361bc2164cc9711f.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <pre class="has"><code class="language-go">Claims claims = Jwts.parser() .setSigningKey("my-123") .parseClaimsJws(token) .getBody();</code></pre> 
 <p>接口</p> 
 <pre class="has"><code class="language-go">@RequestMapping(value = '/login')
public Object vLogin(@RequestParam(value = "username") String username, @RequestParam(value = "password") String password) {
 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
 // if (TextUtils.Isempty(username) || TextUtils.Isempty(password)) {
 // else
 User getUser = userService.validLogin(username, password);
 // 如果用户
 // getUser != null
 
 if(getUser!=null){
 String token=CreateJwt.getoken(getUser);
 map.put("user",getUser);
 map.put("token",token);
 map.put("msg", "登录成功");
}</code></pre> 
 <p>刷新</p> 
 <pre class="has"><code class="language-go">@RequestMapping("/tokensign")
public Object tokenSign(@RequestParam(value = "token")String token){

Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();
// 判断token是否为null
Claims claims = Jwts.parser().setSigningKey("my-123").parseClaimsJws(token).getBody();

Integer id=Integer.valueOf(claims.getId());
System.out.println("用户时间:"+new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"). format(claims.getIssuedAt()));
System.out.println("过期时间:"+new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"). format(claims.getExpiration()));
String username=claims.getSubject();
User user=userService.querybyid(id);

f(username!=null&amp;&amp;claims.getId()!=null&amp;&amp;username.equals(user.getUsername())){
String gettoken=CreateJwt.getoken(user);
map.put("user",user);
map.put("token",token);

return map;</code></pre> 
 <p><strong>访问权限进行控制</strong></p> 
 <p>应用的安全性包括<code>用户认证（Authentication）</code>和<code>用户授权（Authorization）</code>两个部分。</p> 
 <ul>
<li><p>用户认证：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码，系统通过校验用户名和密码来完成认证过程。</p></li>
<li><p>用户授权：验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。</p></li>
</ul> 
 <pre class="has"><code class="language-go">&lt;!-- spring security 安全认证 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
 <p>启动日志增加了如下内容，通过该内容可以找到默认<code>用户名</code>和<code>密码</code></p> 
 <p>security JSESSIONID 登录后的用户信息默认在 <code>Cookies</code></p> 
 <h3>自定义登录认证逻辑</h3> 
 <p><code>@Slf4j @Component @RequiredArgsConstructor</code></p> 
 <img src="https://images2.imgbox.com/e0/01/AiZpozXC_o.png" alt="c853babc4dfea3cba57af2f32da55855.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <p>不建议使用lombok</p> 
 <pre class="has"><code class="language-go">UserDetailsServiceImpl</code></pre> 
 <pre class="has"><code class="language-go">用户验证处理</code></pre> 
 <pre class="has"><code class="language-go">import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

LoginFailureHandler
// 账号过期
log.info("[登录失败] - 用户账号过期");
log.info("[登录失败] - 用户密码错误");
log.info("[登录失败] - 用户密码过期");
log.info("[登录失败] - 用户被禁用");
log.info("[登录失败] - 用户被锁定");</code></pre> 
 <pre class="has"><code class="language-go">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter</code></pre> 
 <pre class="has"><code class="language-go">SecurityConfig</code></pre> 
 <pre class="has"><code class="language-go">WebSecurityConfig
/** 登录成功的处理 */
private final LoginSuccessHandler loginSuccessHandler;
/** 登录失败的处理 */
private final LoginFailureHandler loginFailureHandler;

/** 配置认证方式等 */
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
 auth.userDetailsService(mingYueUserDetailsService).passwordEncoder(new BCryptPasswordEncoder());
}

/** http相关的配置，包括登入登出、异常处理、会话管理等 */
protected void configure(HttpSecurity http) throws Exception {
http.cors().and().csrf().disable();
http.authorizeRequests()
 // 放行接口
 // .antMatchers().permitAll()
 // 除上面外的所有请求全部需要鉴权认证
 .anyRequest()
 .authenticated()
 // 登入
 .and()
 .formLogin()
 // 允许所有用户
 .permitAll()
 // 登录成功处理逻辑
 .successHandler(loginSuccessHandler)
 // 登录失败处理逻辑
 .failureHandler(loginFailureHandler);
}</code></pre> 
 <pre class="has"><code class="language-go">&lt;!-- redis 缓存操作 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
 <pre class="has"><code class="language-go">lettuce:
  pool:
    # 连接池中的最小空闲连接
    min-idle: 0
    # 连接池中的最大空闲连接
    max-idle: 8
    # 连接池的最大数据库连接数
    max-active: 8
    # #连接池最大阻塞等待时间（使用负值表示没有限制）
    max-wait: -1ms</code></pre> 
 <pre class="has"><code class="language-go">&lt;!-- redis 缓存操作 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- pool 对象池 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
 <pre class="has"><code class="language-go">RedisCache</code></pre> 
 <pre class="has"><code class="language-go">/**
 * 缓存基本的对象，Integer、String、实体类等
 *
 * @param key 缓存的键值
 * @param value 缓存的值
 */
public &lt;T&gt; void setCacheObject(final String key, final T value)
{
    redisTemplate.opsForValue().set(key, value);
}</code></pre> 
 <img src="https://images2.imgbox.com/a9/93/PGcxWETM_o.png" alt="86be62b6dd8c490edf7b4b646f09ab05.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <img src="https://images2.imgbox.com/7c/92/E6NTSdZl_o.png" alt="89baa6aa7b9b07612be987d4bba7cee3.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <img src="https://images2.imgbox.com/bf/f8/jxr37Doq_o.png" alt="b3963573732d352805bee30a1038b9e8.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <img src="https://images2.imgbox.com/bb/a5/FjDhH8OU_o.png" alt="0d5c4ac2383609f8f2168d4ff7c6d9c1.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <ul>
<li><p>GenericToStringSerializer: 可以将任何对象泛化为字符串并序列化</p></li>
<li><p>Jackson2JsonRedisSerializer: 跟JacksonJsonRedisSerializer实际上是一样的</p></li>
<li><p>JacksonJsonRedisSerializer: 序列化object对象为json字符串</p></li>
<li><p>JdkSerializationRedisSerializer: 序列化java对象</p></li>
<li><p>StringRedisSerializer: 简单的字符串序列化</p></li>
</ul> 
 <p>我们可以根据redis操作的不同数据类型，设置对应的序列化方式。</p> 
 <p>默认使用的是JdkSerializationRedisSerializer. 这种序列化最大的问题就是存入对象后，我们很难直观看到存储的内容，很不方便我们排查问题</p> 
 <p>而一般我们最经常使用的对象序列化方式是：Jackson2JsonRedisSerializer</p> 
 <pre class="has"><code class="language-go">RedisConfig</code></pre> 
 <img src="https://images2.imgbox.com/fb/10/ulY5bcks_o.png" alt="6c4c713ff5052ef3951e405bd934f7bf.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <p>可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行<br>这把锁要是一把可重入锁（避免死锁）<br>这把锁最好是一把阻塞锁<br>有高可用的获取锁和释放锁功能<br>获取锁和释放锁的性能要好</p> 
 <p>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。</p> 
 <ol>
<li><p>互斥性。在任意时刻，只有一个客户端能持有锁。</p></li>
<li><p>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p></li>
<li><p>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</p></li>
<li><p>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p></li>
</ol> 
 <p>登录注册</p> 
 <pre class="has"><code class="language-go">import { validUsername, isNumber } from '@/utils/validate'
export default {
  name: 'Login',
    data() {
       const validatePhoneNo = (rule, value, callback) =&gt; {
          if (!(value.length === 11 &amp;&amp; isNumber(value))) {
            callback(new Error('手机号码必须是11位数字'))
          } else {
            if (value.charAt(0) !== '1' || parseInt(value.charAt(1)) &lt; 3) {
              callback(new Error('输入的手机号码不是有效的手机号'))
            } else {
              callback()
            }
          }
        }
        const validatePhoneCode = (rule, value, callback) =&gt; {
          if (!value) {
            callback(new Error('验证码不能为空'))
          } else {
            if (!(value.length === 6 &amp;&amp; isNumber(value))) {
              callback(new Error('验证码必须是6位数字'))
            } else {
              callback()
            }
          }
        } 
    }

    return {
     loginRules: {
        username: [{ required: true, trigger: 'blur', validator: validateUsername }],
        password: [{ required: true, trigger: 'blur', validator: validatePassword }],
        phoneNo: [{ required: true, trigger: 'blur', validator: validatePhoneNo }],
        phoneCode: [{ required: true, trigger: 'blur', validator: validatePhoneCode }]
      }
      // 其他返回对象在此省略
    }
}

/**
 * 是否数字
 * @param {String} val
 * @returns {Boolean}
 */
export function isNumber(val) {
  for (let i = 0; i &lt; val.length; i++) {
    if (val.charCodeAt(i) &lt; 48 || val.charCodeAt(i) &gt; 57) {
      return false
    }
  }
  return true
}
&lt;el-form ref="loginForm" :model="loginForm" :rules="loginRules" class="login-form" autocomplete="on" label-position="left"&gt;</code></pre> 
 <pre class="has"><code class="language-go">handleLogin() {
      this.$refs.loginForm.validate(valid =&gt; {
        if (valid) {
          this.loading = true
          if (this.activeLoginType === '1') {
            const username = this.loginForm.username
            const password = this.loginForm.password
            this.$store.dispatch('user/login', { username: username, password: password })
              .then(() =&gt; {
                this.$router.push({ path: this.redirect || '/', query: this.otherQuery })
                this.loading = false
              })
          } else {
            const phoneNo = this.loginForm.phoneNo
            const phoneCode = this.loginForm.phoneCode
            this.$store.dispatch('user/mobileLogin', { phoneNo: phoneNo, phoneCode: phoneCode })
              .then(() =&gt; {
                this.$router.push({ path: this.redirect || '/', query: this.otherQuery })
                this.loading = false
              })
          }
        }
      })
    }</code></pre> 
 <pre class="has"><code class="language-go">import { login, logout, phoneCodeLogin } from '@/api/user'
    
const actions = {
  // user login
  login({ commit }, userInfo) {
    const { username, password } = userInfo
    return new Promise((resolve, reject) =&gt; {
      login({ username: username, password: password }).then(response =&gt; {
        if (response.status === 200 &amp;&amp; response.data) {
          const data = response.data.userInfo
          const useBaseInfo = {
            username: data.username,
            nickname: data.nickname,
            email: data.email,
            phoneNum: data.phoneNum
          }
          window.sessionStorage.setItem('userInfo', JSON.stringify(useBaseInfo))
          const { roles, currentRole } = data
          roles[0] = currentRole
          commit('SET_TOKEN', useBaseInfo)
          commit('SET_NAME', useBaseInfo.username)
          setToken(currentRole.id)
          commit('SET_ROLES', roles)
          window.sessionStorage.setItem('roles', JSON.stringify(roles))
          commit('SET_CURRENT_ROLE', currentRole)
          window.sessionStorage.setItem('currentRole', currentRole)
          // commit('SET_AVATAR', avtar)
          getRouteIds(currentRole.id).then(response =&gt; {
            if (response.status === 200 &amp;&amp; response.data.status === 200) {
              const routeIds = response.data['data']
              window.sessionStorage.setItem('routeData', JSON.stringify(routeIds))
            } else {
              Message.error('response.status=' + response.status + 'response.text=' + response.text)
            }
          })
          resolve(useBaseInfo)
        } else {
          Message.error('user login failed')
          resolve()
        }
      }).catch(error =&gt; {
        console.error(error)
        reject(error)
      })
    })
  },
  // phone code login
  mobileLogin({ commit }, phoneParam) {
    const { phoneNo, phoneCode } = phoneParam
    return new Promise((resolve, reject) =&gt; {
      phoneCodeLogin({ phoneNo: phoneNo, phoneCode: phoneCode }).then(res =&gt; {
        if (res.status === 200 &amp;&amp; res.data) {
          const data = res.data.userInfo
          const useBaseInfo = {
            username: data.username,
            nickname: data.nickname,
            phoneNum: data.phoneNum,
            email: data.email
          }
          window.sessionStorage.setItem('userInfo', JSON.stringify(useBaseInfo))
          const { roles, currentRole } = data
          roles[0] = currentRole
          commit('SET_TOKEN', useBaseInfo)
          commit('SET_NAME', useBaseInfo.username)
          setToken(currentRole.id)
          commit('SET_ROLES', roles)
          window.sessionStorage.setItem('roles', JSON.stringify(roles))
          commit('SET_CURRENT_ROLE', currentRole)
          window.sessionStorage.setItem('currentRole', currentRole)
          // commit('SET_AVATAR', avtar)
          getRouteIds(currentRole.id).then(response =&gt; {
            if (response.status === 200 &amp;&amp; response.data.status === 200) {
              const routeIds = response.data['data']
              window.sessionStorage.setItem('routeData', JSON.stringify(routeIds))
            } else {
              Message.error('response.status=' + response.status + 'response.text=' + response.text)
            }
          })
          resolve(useBaseInfo)
        } else {
          Message.error('phone code login failed')
          resolve()
        }
      }).catch(error =&gt; {
        console.error(error)
        reject(error)
      })
    })
  },
    // 其他请求此处省略
}</code></pre> 
 <p>可以在 jwt.io Debugger<sup>[1]</sup> 网站来解码、验证和生成 JWT。</p> 
 <p>由于缺乏安全性，不应该将敏感的会话数据存储在浏览器中。每当用户需要访问受保护的路由或资源时，用户代理应该发送jwt，通常在 Authorization header 中使用 Bearer 模式。</p> 
 <pre class="has"><code class="language-go">&lt;!--加解密依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-codec&lt;/groupId&gt;
            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
            &lt;version&gt;1.11&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--持久层框架mybatis-plus依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.1.2&lt;/version&gt;
        &lt;/dependency&gt;
       &lt;!--spring security依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
            &lt;version&gt;2.2.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--jwt token依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.auth0&lt;/groupId&gt;
            &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;
            &lt;version&gt;3.7.0&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
 <pre class="has"><code class="language-go">public class JwtTokenUtil {

    // 密钥
    private static final String SECRET = "bonusBACKEND2022$";

    // 过期时间7天
    private static final int EXPIRE_SECONDS = 7*24*3600;

    private final static Logger logger = LoggerFactory.getLogger(JwtTokenUtil.class);

    /**
     * 生成token方法
     * @param memInfoMap
     * @return jwtToken
     */
    public static String genAuthenticatedToken(Map&lt;String, Object&gt; memInfoMap){
        List&lt;GrantedAuthority&gt; authorities = (List&lt;GrantedAuthority&gt;) memInfoMap.get("authorities");
        String authorityStr = null;
        if(authorities!=null &amp;&amp; authorities.size()&gt;0){
            StringBuffer buffer = new StringBuffer();
            for(int i=0; i&lt;authorities.size()-1; i++){
                buffer.append(authorities.get(i).getAuthority()).append(",");
            }
            buffer.append(authorities.get(authorities.size()-1).getAuthority());
            authorityStr = buffer.toString();
        }
        String[] authorityArray = authorityStr!=null?authorityStr.split(","):null;
        Calendar nowTime = Calendar.getInstance();
        //过期时间
        nowTime.add(Calendar.SECOND, EXPIRE_SECONDS);
        Date expireDate = nowTime.getTime();
        String jwtToken = JWT.create().withJWTId(UUID.randomUUID().toString().replaceAll("-", ""))
                .withClaim("memId", (Long) memInfoMap.get("memId"))
                .withClaim("memAccount", (String) memInfoMap.get("memAccount"))
                .withClaim("memPwd", (String) memInfoMap.get("memPwd"))
                .withClaim("totalCreditAmount", ((BigDecimal) memInfoMap.get("totalCreditAmount")).doubleValue())
                .withClaim("usedCreditAmount", ((BigDecimal) memInfoMap.get("usedCreditAmount")).doubleValue())
                .withClaim("remainCreditAmount", ((BigDecimal) memInfoMap.get("remainCreditAmount")).doubleValue())
                .withArrayClaim("authorities", authorityArray)
                .withIssuedAt(new Date(System.currentTimeMillis()))
                .withExpiresAt(expireDate)
                .sign(Algorithm.HMAC256(SECRET));
        return jwtToken;
    }
}</code></pre> 
 <p>JwtTokenUtil的工具类用于生成jwt令牌</p> 
 <pre class="has"><code class="language-go">public class JwtTokenUtil {

    // 密钥
    private static final String SECRET = "bonusBACKEND2022$";

    // 过期时间7天
    private static final int EXPIRE_SECONDS = 7*24*3600;

    private final static Logger logger = LoggerFactory.getLogger(JwtTokenUtil.class);

    /**
     * 生成token方法
     * @param memInfoMap
     * @return jwtToken
     */
    public static String genAuthenticatedToken(Map&lt;String, Object&gt; memInfoMap){
        List&lt;GrantedAuthority&gt; authorities = (List&lt;GrantedAuthority&gt;) memInfoMap.get("authorities");
        String authorityStr = null;
        if(authorities!=null &amp;&amp; authorities.size()&gt;0){
            StringBuffer buffer = new StringBuffer();
            for(int i=0; i&lt;authorities.size()-1; i++){
                buffer.append(authorities.get(i).getAuthority()).append(",");
            }
            buffer.append(authorities.get(authorities.size()-1).getAuthority());
            authorityStr = buffer.toString();
        }
        String[] authorityArray = authorityStr!=null?authorityStr.split(","):null;
        Calendar nowTime = Calendar.getInstance();
        //过期时间
        nowTime.add(Calendar.SECOND, EXPIRE_SECONDS);
        Date expireDate = nowTime.getTime();
        String jwtToken = JWT.create().withJWTId(UUID.randomUUID().toString().replaceAll("-", ""))
                .withClaim("memId", (Long) memInfoMap.get("memId"))
                .withClaim("memAccount", (String) memInfoMap.get("memAccount"))
                .withClaim("memPwd", (String) memInfoMap.get("memPwd"))
                .withClaim("totalCreditAmount", ((BigDecimal) memInfoMap.get("totalCreditAmount")).doubleValue())
                .withClaim("usedCreditAmount", ((BigDecimal) memInfoMap.get("usedCreditAmount")).doubleValue())
                .withClaim("remainCreditAmount", ((BigDecimal) memInfoMap.get("remainCreditAmount")).doubleValue())
                .withArrayClaim("authorities", authorityArray)
                .withIssuedAt(new Date(System.currentTimeMillis()))
                .withExpiresAt(expireDate)
                .sign(Algorithm.HMAC256(SECRET));
        return jwtToken;
    }
}</code></pre> 
 <h3>实现用户认证方法</h3> 
 <pre class="has"><code class="language-go">@Service
public class MemInfoServiceImpl extends ServiceImpl&lt;MemInfoMapper, MemInfoDTO&gt; implements MemInfoService {
 private final static Logger logger = LoggerFactory.getLogger(MemInfoServiceImpl.class);
    @Resource
    private MyPasswordEncoder passwordEncoder;
    @Resource
    private RoleInfoService roleInfoService;
    
    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        MemInfoDTO memInfoDTO = this.baseMapper.getMemInfoByAccount(username);
        if(memInfoDTO==null){
            throw  new UsernameNotFoundException("Username" + username + "is invalid!");
        }
        // 获取用户角色列表
        List&lt;RoleInfoDTO&gt; roleInfoDTOList = roleInfoService.getRolesByMemId(memInfoDTO.getMemId());
        if(roleInfoDTOList.size()&gt;0){
            for(RoleInfoDTO roleInfoDTO: roleInfoDTOList){
                SimpleGrantedAuthority grantedAuthority = new SimpleGrantedAuthority("ROLE_" + roleInfoDTO.getRoleName().toUpperCase());
                memInfoDTO.getAuthorities().add(grantedAuthority);
            }
        }
        return memInfoDTO;
    }</code></pre> 
 <pre class="has"><code class="language-go">@Data
@TableName("bonus_mem_info")
@ApiModel(value="MemInfoDTO", description = "会员DTO")
@Validated
public class MemInfoDTO extends BaseDTO implements UserDetails {

    /**
     * 会员id
     */
    @TableId
    @ApiModelProperty(name = "memId", value = "memId", notes = "会员ID", dataType = "Long")
    private Long memId;

    /**
     * 会员账号
     */
    @TableField(value = "mem_account")
    @NotEmpty(message = "会员账号不能为空")
    @ApiModelProperty(name="memAccount", value = "memAccount", notes = "会员账号", dataType = "String")
    private String memAccount;

    /**
     * 会员密码
     */
    @TableField(value = "mem_pwd")
    @NotEmpty(message = "会员密码不能为空")
    @ApiModelProperty(name="memPwd", value = "memPwd", notes = "加密后的会员密码", dataType = "String")
    private String memPwd;

    /**
     * 会员类型：1-vip;2-代理
     */
    @TableField(value = "mem_type")
    @NotEmpty(message = "会员类型不能为空")
    @ApiModelProperty(name="memType", value = "memType", notes = "会员类型", dataType = "Integer", example = "1", allowableValues = "1,2")
    private Integer memType;

    /**
     * 会员信用额度,单位分
     */
    @TableField(value = "total_credit_amount")
    @NotEmpty(message = "会员信用额度不能为空")
    @ApiModelProperty(name = "totalCreditAmount", value = "totalCreditAmount", notes = "会员总信用额度,单位分", dataType = "Long", example = "10000")
    private Long totalCreditAmount;

    /**
     * 会员已使用信用额度，单位分
     */
    @ApiModelProperty(name = "usedCreditAmount", value = "usedCreditAmount", notes = "会员已使用信用额度,单位分", dataType = "Long", example = "5000")
    @TableField(value = "used_credit_amount")
    private Long usedCreditAmount;

    @TableField(exist = false)
    private List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();

    @Override
    public Collection&lt;GrantedAuthority&gt; getAuthorities() {
        return authorities;
    }

    @Override
    public String getPassword() {
        return this.memPwd;
    }

    @Override
    public String getUsername() {
        return this.memAccount;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}</code></pre> 
 <pre class="has"><code class="language-go">@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final static Logger logger = LoggerFactory.getLogger(SecurityConfig.class);

    @Resource
    private MemInfoService memInfoService;

    private MathContext mathContext = new MathContext(2, RoundingMode.HALF_UP);

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        super.configure(auth);
        auth.userDetailsService(memInfoService);
    }

    @Override
    public void configure(WebSecurity web) {
        web.ignoring().antMatchers("/static/**","/index.html","/templates/**", "/admin/**", "/doc.html", "/webjars/**", "/v2/*", "/favicon.ico", "/swagger-resources");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        JwtAuthenticationFilterBean jwtAuthenticationFilterBean = new JwtAuthenticationFilterBean();
        http.addFilterBefore(jwtAuthenticationFilterBean, UsernamePasswordAuthenticationFilter.class); // 将JwtToken认证过滤器注册在登录认证过滤器之前
        // 配置跨域
        http.cors().configurationSource(corsConfigurationSource())
                .and().logout().invalidateHttpSession(true).logoutUrl("/member/logout").permitAll()
        ;
        http.authorizeRequests().antMatchers("/member/checkSafetyCode").permitAll()
                .antMatchers("/doc.html").permitAll()
                .antMatchers("/common/kaptcha").permitAll()
                .antMatchers("/admin/login").permitAll()
                .anyRequest().authenticated()
                .and().httpBasic()
                .and().formLogin()
                .loginProcessingUrl("/member/login") // 登录接口
                .successHandler((httpServletRequest, httpServletResponse, authentication) -&gt; {
                     httpServletResponse.setContentType("application/json;charset=utf-8");
                     httpServletResponse.setStatus(HttpStatus.OK.value());
                     PrintWriter printWriter = httpServletResponse.getWriter();
                     MemInfoDTO memInfoDTO = (MemInfoDTO) authentication.getPrincipal();
                     Map&lt;String, Object&gt; userMap = new HashMap&lt;&gt;();
                     userMap.put("memId", memInfoDTO.getMemId());
                     userMap.put("memAccount", memInfoDTO.getMemAccount());
                     userMap.put("memPwd", memInfoDTO.getMemPwd());
                     BigDecimal totalCredit = memInfoDTO.getTotalCreditAmount()!=null?new BigDecimal(memInfoDTO.getTotalCreditAmount()/100, mathContext): new BigDecimal("0.0");
                     userMap.put("totalCreditAmount", totalCredit);
                     BigDecimal usedCredit = memInfoDTO.getUsedCreditAmount()!=null?new BigDecimal(memInfoDTO.getUsedCreditAmount()/100, mathContext):new BigDecimal("0.0");
                     userMap.put("usedCreditAmount", usedCredit);
                     Long remainCredit = (memInfoDTO.getTotalCreditAmount()==null?0:memInfoDTO.getTotalCreditAmount()) - (memInfoDTO.getUsedCreditAmount()==null?0:memInfoDTO.getUsedCreditAmount());
                     BigDecimal remainCreditAmount = new BigDecimal(remainCredit/100, mathContext);
                     userMap.put("remainCreditAmount", remainCreditAmount);
                     userMap.put("authorities", memInfoDTO.getAuthorities());
                     Map&lt;String, Object&gt; dataMap = new HashMap&lt;&gt;();
                     dataMap.put("memInfo", userMap);
                     dataMap.put("authenticatedToken", "Bearer "+JwtTokenUtil.genAuthenticatedToken(userMap));
                     ResponseResult&lt;Map&lt;String, Object&gt;&gt; responseResult = ResponseResult.success(dataMap, "login success");
                     printWriter.write(JSONObject.toJSONString(responseResult));
                     printWriter.flush();
                     printWriter.close();
                }).failureHandler((httpServletRequest, httpServletResponse, e) -&gt; {
                     logger.error("login failed, caused by " + e.getMessage());
                     httpServletResponse.setContentType(MediaType.APPLICATION_JSON_VALUE);
                     httpServletResponse.setStatus(HttpStatus.OK.value());
                     PrintWriter printWriter = httpServletResponse.getWriter();
                     ResponseResult&lt;String&gt; responseResult = ResponseResult.error(HttpStatus.UNAUTHORIZED.value(), "authentication failed");
                     responseResult.setPath(httpServletRequest.getRequestURI());
                     printWriter.write(JSONObject.toJSONString(responseResult));
                     printWriter.flush();
                     printWriter.close();
                }).permitAll()
                .and().csrf().disable().exceptionHandling().accessDeniedHandler(accessDeniedHandler());

    }

    //配置跨域访问资源
    private CorsConfigurationSource corsConfigurationSource() {
        UrlBasedCorsConfigurationSource source =   new UrlBasedCorsConfigurationSource();
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.addAllowedOrigin("*"); //同源配置，*表示任何请求都视为同源，若需指定ip和端口可以改为如“localhost：8080”，多个以“，”分隔；
        corsConfiguration.addAllowedHeader("*");//header，允许哪些header，本案中使用的是token，此处可将*替换为token；
        corsConfiguration.addAllowedMethod("*"); //允许的请求方法，PSOT、GET等
        corsConfiguration.setAllowCredentials(true);
        // 注册跨域配置
        source.registerCorsConfiguration("/**",corsConfiguration); //配置允许跨域访问的url
        return source;
    }

    @Bean
    AccessDeniedHandler accessDeniedHandler() {
        return new AuthenticationAccessDeniedHandler();
    }
}</code></pre> 
 <img src="https://images2.imgbox.com/a4/e8/2e8vO2KI_o.png" alt="e0dc156aa1b091fc0e63e2d055ec8260.png"> 
 <figcaption>
   image.png 
 </figcaption> 
 <p>加群联系作者vx：xiaoda0423</p> 
 <p>仓库地址：https://github.com/webVueBlog/JavaGuideInterview</p> 
</div>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>