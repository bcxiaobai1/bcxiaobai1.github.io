<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Linux环境及工具（yum/vim/gcc/g&#43;&#43;/gdb/make/Makefile） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux环境及工具（yum/vim/gcc/g&#43;&#43;/gdb/make/Makefile）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>【Linux学习】Linux环境及工具</h3>
 <ul>
<li><a href="#_2">零、前言</a></li>
<li><a href="#Linuxyum_6">一、Linux软件包管理器yum</a></li>
<li>
<ul>
<li><a href="#1yum_8">1、yum介绍</a></li>
<li><a href="#2rzsz_28">2、rzsz</a></li>
<li><a href="#2yum_54">2、yum工具的基本操作</a></li>
<li>
<ul>
<li><a href="#1_56">1)查看软件包</a></li>
<li><a href="#2_82">2)安装软件</a></li>
<li><a href="#3_100">3)卸载软件</a></li>
</ul>
  </li>
</ul>
  </li>
<li><a href="#_Linuxvim_108">二、 Linux开发工具vim</a></li>
<li>
<ul>
<li><a href="#1vim_110">1、vim的介绍</a></li>
<li><a href="#2vim_132">2、vim基本操作</a></li>
<li><a href="#3vim_163">3、vim正常模式命令集</a></li>
<li><a href="#4vim_212">4、vim底行模式命令集</a></li>
<li><a href="#5vim_270">5、vim操作总结</a></li>
<li><a href="#6vim_280">6、简单vim配置</a></li>
</ul>
  </li>
<li><a href="#Linuxgccg_304">三、Linux编译器-gcc/g++</a></li>
<li>
<ul>
<li><a href="#1_306">1、程序生成过程</a></li>
<li>
<ul>
<li><a href="#1_314">1)预处理</a></li>
<li><a href="#2_334">2)编译</a></li>
<li><a href="#3_352">3)汇编</a></li>
<li><a href="#4_370">4)链接</a></li>
</ul>
   </li>
<li><a href="#2_384">2、函数库</a></li>
</ul>
  </li>
<li><a href="#Linuxgdb_432">四、Linux调试器-gdb</a></li>
<li>
<ul>
<li><a href="#1_434">1、背景及概念</a></li>
<li><a href="#2_454">2、调试命令</a></li>
</ul>
  </li>
<li><a href="#LinuxmakeMakefile_557">五、Linux项目自动化构建工具-make/Makefile</a></li>
<li>
<ul>
<li><a href="#1_559">1、背景及概念</a></li>
<li><a href="#2_568">2、使用及原理</a></li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<h1>
<a id="_2"></a>零、前言</h1> 
<blockquote> 
 <p>本章主要将解学习软件包的概念和yum工具以及vim编辑器的使用操作</p> 
</blockquote> 
<h1>
<a id="Linuxyum_6"></a>一、Linux软件包管理器yum</h1> 
<h2>
<a id="1yum_8"></a>1、yum介绍</h2> 
<ul><li>概念：</li></ul> 
<blockquote> 
 <p>yum(Yellow dog Updater, Modified)是Linux下非常常用的一种包管理器</p> 
</blockquote> 
<ul><li>Linux上如何安装软件：</li></ul> 
<blockquote> 
 <p>1.源代码安装（麻烦）</p> 
 <p>2.rpm包安装（类似windows上的安装程序）</p> 
 <p>3.yum命令行（可以帮助搜索，下载，安装，解决软件依赖关系）</p> 
</blockquote> 
<ul><li>什么是软件包：</li></ul> 
<blockquote> 
 <p>安装软件通常的办法是下载到程序的源代码, 并进行编译, 得到可执行程序，而软件包是把一些软件提前编译好，从服务器上获取后可以直接进行安装</p> 
</blockquote> 
<blockquote> 
 <p>注：软件包和软件包管理器, 就好比 “App” 和 “应用商店” 这样的关系</p> 
</blockquote> 
<h2>
<a id="2rzsz_28"></a>2、rzsz</h2> 
<blockquote> 
 <p>注：首先在 root 权限下使用 yum install -y lrzsz 命令，进行安装 rzsz 这个工具</p> 
</blockquote> 
<ul><li>rz 命令：</li></ul> 
<blockquote> 
 <p>windows 机器和远端的 Linux 机器通过 XShell 传输文件，使用指令 rz 则可以进行上传本地文件了</p> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/b6/2c/58jHlbfK_o.png" alt="image-20220129205513918"> 
<ul><li>sz + 文件命令：</li></ul> 
<blockquote> 
 <p>从linux终端将文件发送至本地 windows</p> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/b8/96/JpyisAce_o.png" alt="image-20220129233202754"> 
<blockquote> 
 <p>注： yum 的所有操作必须保证主机(虚拟机)网络畅通，可以通过 ping 指令查看网络状况</p> 
</blockquote> 
<pre><code class="prism language-cpp">ping www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com
</code></pre> 
<h2>
<a id="2yum_54"></a>2、yum工具的基本操作</h2> 
<h3>
<a id="1_56"></a>1)查看软件包</h3> 
<ul><li>命令：</li></ul> 
<blockquote> 
 <p>yum list</p> 
</blockquote> 
<ul><li>功能：</li></ul> 
<blockquote> 
 <p>罗列出当前一共有哪些软件包</p> 
</blockquote> 
<blockquote> 
 <p>注：包的数目非常多, 可以使用 grep 命令筛选出需要的包</p> 
</blockquote> 
<ul><li>示例：</li></ul> 
<img src="https://images2.imgbox.com/64/4a/XCikm74y_o.png" alt="image-20220129210059581"> 
<ul><li>注意：</li></ul> 
<blockquote> 
 <ol>
<li> <p>软件包名称: 主版本号.次版本号.源程序发行号-软件包的发行号.主机平台.cpu架构</p> </li>
<li> <p>“x86_64” 后缀表示64位系统的安装包, “i686” 后缀表示32位系统安装包. 选择包时要和系统匹配</p> </li>
<li> <p>“el7” 表示操作系统发行版的版本. “el7” 表示的是 centos7/redhat7. “el6” 表示 centos6/redhat6</p> </li>
<li> <p>最后一列, base 表示的是 “软件源” 的名称, 类似于 “小米应用商店”, “华为应用商店” 这样的概念</p> </li>
</ol> 
</blockquote> 
<h3>
<a id="2_82"></a>2)安装软件</h3> 
<ul><li>命令：</li></ul> 
<blockquote> 
 <p>sudo yum install 名称</p> 
</blockquote> 
<ul><li>常用选项：</li></ul> 
<pre><code class="prism language-cpp"> <span class="token operator">-</span>y ：表示在找到后确认进行安装
</code></pre> 
<ul><li>注意：</li></ul> 
<blockquote> 
 <ol>
<li> <p>一般需要 sudo 或者切到 root 账户下才能完成（需要向系统目录中写入内容）</p> </li>
<li> <p>无法多台服务器同时使用 yum</p> </li>
</ol> 
</blockquote> 
<h3>
<a id="3_100"></a>3)卸载软件</h3> 
<ul><li>命令：</li></ul> 
<blockquote> 
 <p>sudo yum remove 名称</p> 
</blockquote> 
<blockquote> 
 <p>注：卸载也需要 root 权限</p> 
</blockquote> 
<h1>
<a id="_Linuxvim_108"></a>二、 Linux开发工具vim</h1> 
<h2>
<a id="1vim_110"></a>1、vim的介绍</h2> 
<ul><li>概念：</li></ul> 
<blockquote> 
 <p>vi/vim 的区别简单点来说，它们都是多模式编辑器，不同的是vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面（类似C和C++的关系），Linux自带 vim ，使用较多</p> 
</blockquote> 
<ul><li>基本概念：</li></ul> 
<blockquote> 
 <p>vim的常用三种模式，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）</p> 
</blockquote> 
<ul><li>正常/命令模式：</li></ul> 
<blockquote> 
 <p>可以控制屏幕光标的移动，对文本进行字符、字或行的删除，移动复制某区段等操作</p> 
</blockquote> 
<ul><li>插入模式：</li></ul> 
<blockquote> 
 <p>只有在Insert mode下，才可以进行文字输入</p> 
</blockquote> 
<ul><li>底行模式：</li></ul> 
<blockquote> 
 <p>文件保存或退出，也可以进行文件替换，使用命令等操作</p> 
</blockquote> 
<h2>
<a id="2vim_132"></a>2、vim基本操作</h2> 
<ol start="0"><li>vim 编辑文件命令：vim 文本名</li></ol> 
<blockquote> 
 <p>注：进入vim之后，是处于[正常模式]</p> 
</blockquote> 
<ol><li>[正常模式]切换至[插入模式]</li></ol> 
<pre><code class="prism language-cpp">按「i」进入插入模式后，是从光标当前位置开始输入文件
按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字
按「o」进入插入模式后，是插入新的一行，从行首开始输入文字
</code></pre> 
<ol start="2"><li>[正常模式]切换至[底行模式]</li></ol> 
<pre><code class="prism language-cpp">「shift <span class="token operator">+</span> <span class="token punctuation">;</span>」 其实就是输入「<span class="token operator">:</span>」
</code></pre> 
<blockquote> 
 <p>注：在其他模式下都可以通过按 Esc 退回正常模式</p> 
</blockquote> 
<ol start="3"><li>退出vim及保存文件：</li></ol> 
<pre><code class="prism language-cpp">在<span class="token punctuation">[</span>正常模式<span class="token punctuation">]</span>下按一下「<span class="token operator">:</span>」冒号键进入底行模式
<span class="token operator">:</span> w （保存当前文件）
<span class="token operator">:</span> <span class="token function">wq</span> <span class="token punctuation">(</span>输入「wq」<span class="token punctuation">,</span>存盘并退出vim<span class="token punctuation">)</span>
<span class="token operator">:</span> q<span class="token operator">!</span> <span class="token punctuation">(</span>输入q<span class="token operator">!</span><span class="token punctuation">,</span>不存盘强制退出vim<span class="token punctuation">)</span>
</code></pre> 
<h2>
<a id="3vim_163"></a>3、vim正常模式命令集</h2> 
<ul><li>移动光标：</li></ul> 
<pre><code class="prism language-cpp">上下左右：正规的vim是用小写英文字母「h」、「j」、「k」、「l」分别控制光标左、下、上、右移一格，也可以直接用键盘上的光标来上下左右移动
按「w」：光标跳到下个字的开头
按「e」：光标跳到下个字的字尾
按「b」：光标回到上个字的开头
按「$」：移动到光标所在行的“行尾”
按「<span class="token operator">^</span>」：移动到光标所在行的“行首”
按「n<span class="token operator">+</span>l」：光标移到该行的第n个位置
按［gg］：光标移到文本开始
按［shift<span class="token operator">+</span>g］：光标移到文本末端
按［n<span class="token operator">+</span>shift<span class="token operator">+</span>g］：光标移到文本第n行
</code></pre> 
<ul><li>删除文字：</li></ul> 
<pre><code class="prism language-cpp">「x」：每按一次，删除光标所在位置的一个字符
「n<span class="token operator">+</span>x」：删除光标所在位置的“后面（包含自己在内）”n个字符
「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符
「n<span class="token operator">+</span>X」：表示删除光标所在位置的“前面”n个字符
「dd」：剪切光标所在行
「n<span class="token operator">+</span>dd」：从光标所在行开始剪切n行
<span class="token comment">//注意：dd与“p”配能完成剪切粘贴功能</span>
</code></pre> 
<ul><li>复制：</li></ul> 
<pre><code class="prism language-cpp">「yw」：将光标所在之处到字尾的字符复制到缓冲区中
「n<span class="token operator">+</span>yw」：复制n个字到缓冲区
「yy」：复制光标所在行到缓冲区
「n<span class="token operator">+</span>yy」：表示拷贝从光标所在的该行“往下数”n行文字
「p」：将缓冲区内的字符贴到光标所在位置
<span class="token comment">//注意：y相关的操作与“p”配能完成复制粘贴</span>
</code></pre> 
<ul><li>替换：</li></ul> 
<pre><code class="prism language-cpp">「r」：输入需要改成的字符，替换光标所在处的字符
「R」：切换成替换模式，输入可以替换光标所到之处的字符，按下「ESC」键退回正常模式
「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作，按多次“u”可以执行多次回复
「ctrl <span class="token operator">+</span> r」<span class="token operator">:</span> 撤销的恢复
</code></pre> 
<h2>
<a id="4vim_212"></a>4、vim底行模式命令集</h2> 
<blockquote> 
 <p>注：先按「ESC」键确定您已经处于正常模式，再按「：」冒号即可进入底行模式</p> 
</blockquote> 
<ul><li>列出行号：</li></ul> 
<pre><code class="prism language-cpp">「set nu」<span class="token operator">:</span> 输入「set nu」后，会在文件中的每一行前面列出行号跳到文件中的某一行
「set nonu」<span class="token operator">:</span> 输入「set nonu」后会取消文件中 的行号
「#」<span class="token operator">:</span>「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了
</code></pre> 
<ul><li>查找字符：</li></ul> 
<pre><code class="prism language-cpp">「<span class="token operator">/</span>关键字」：先按「<span class="token operator">/</span>」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止（向下查找）
「<span class="token operator">?</span>关键字」：先按「<span class="token operator">?</span>」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止（向上查找）
</code></pre> 
<ul><li>保存退出：</li></ul> 
<pre><code class="prism language-cpp">「w」<span class="token operator">:</span> 在冒号输入字母「w」就可以将文件保存起来
「q」：按「q」就是退出，如果无法离开vim，可以在「q」后跟一个「<span class="token operator">!</span>」强制离开vim
「wq」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件
</code></pre> 
<ul><li>替换：</li></ul> 
<pre><code class="prism language-cpp">「<span class="token operator">%</span>s<span class="token operator">/</span>要被替换的字符或字符串<span class="token operator">/</span>要替换成的字符或字符串<span class="token operator">/</span>g」：将对应字符或字符串替换成对应字符或字符串（g表示全部）
</code></pre> 
<ul><li>更改：</li></ul> 
<pre><code class="prism language-cpp">「<span class="token operator">~</span>」：从光标所在行将单词大写转小写，小写转大写
</code></pre> 
<ul><li>打开多个窗口：</li></ul> 
<pre><code class="prism language-cpp">vs <span class="token operator">+</span> 文件名：（如果没有那么就会创建一个，如果有就会打开对应的文件）
</code></pre> 
<ul><li>多文件切换：</li></ul> 
<pre><code class="prism language-cpp">ctrl <span class="token operator">+</span> w（双击）：切换文件（注：在多窗口的情况下）
</code></pre> 
<ul><li>特别命令：</li></ul> 
<pre><code class="prism language-cpp">vim test<span class="token punctuation">.</span>c <span class="token operator">+</span><span class="token number">10</span>   <span class="token comment">//打开test.c文件将光标定位到第10行</span>
<span class="token operator">!</span>vim   <span class="token comment">//打开历史上最近一次执行vim的操作</span>
</code></pre> 
<h2>
<a id="5vim_270"></a>5、vim操作总结</h2> 
<ul><li>简图：</li></ul> 
<img src="https://images2.imgbox.com/f1/e7/4RioyZC2_o.png" alt="image-20220129230211592"> 
<ul><li>全图：</li></ul> 
<img src="https://images2.imgbox.com/54/ac/qwk8tlOr_o.png" alt="image-20220220135858762"> 
<h2>
<a id="6vim_280"></a>6、简单vim配置</h2> 
<ul><li>配置文件的位置：</li></ul> 
<blockquote> 
 <p>在目录 /etc/ 下面，有个名为vimrc的文件，这是系统中公共的vim配置文件，对所有用户都有效，而在每个用户的主目录下，都可以自己建立私有的配置文件，命名为：“.vimrc”。例如，/root目录下，通常已经存在一个.vimrc文件,如果不存在，则创建，切换用户成为自己执行 su ，进入自己的主工作目录,执行 cd ~打开自己目录下的.vimrc文件，执行 vim .vimrc 进行配置</p> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/a6/a8/mcRXQH9k_o.png" alt="image-20220129234254764"> 
<ul><li>常用配置选项：</li></ul> 
<pre><code class="prism language-cpp">设置语法高亮<span class="token operator">:</span> syntax on
显示行号<span class="token operator">:</span> set nu
设置缩进的空格数为<span class="token number">4</span><span class="token operator">:</span> set shiftwidth<span class="token operator">=</span><span class="token number">4</span>
</code></pre> 
<ul><li>注意：</li></ul> 
<blockquote> 
 <ol>
<li> <p>建议使用网络上已经配置好的vim，学习教程进行下载就行了</p> </li>
<li> <p>一般vimrc在每一个用户下都有一个，彼此之间互不影响</p> </li>
</ol> 
</blockquote> 
<h1>
<a id="Linuxgccg_304"></a>三、Linux编译器-gcc/g++</h1> 
<h2>
<a id="1_306"></a>1、程序生成过程</h2> 
<blockquote> 
 <p>注：以gcc为示例展示过程</p> 
</blockquote> 
<ul><li>语法：</li></ul> 
<blockquote> 
 <p>gcc [选项] 要编译的文件 [选项] [目标文件]</p> 
</blockquote> 
<h3>
<a id="1_314"></a>1)预处理</h3> 
<ul><li>功能主要包括：</li></ul> 
<blockquote> 
 <p>将源文件进行宏定义替换，文件包含展开，条件编译处理，去注释等</p> 
</blockquote> 
<ul><li>示例：</li></ul> 
<blockquote> 
 <p>gcc –E hello.c –o hello.i</p> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/3e/bc/GpvMID8B_o.png"> 
<ul><li>注：</li></ul> 
<blockquote> 
 <ol>
<li> <p>选项“-E”的作用是让 gcc 在预处理结束后停止编译过程</p> </li>
<li> <p>选项“-o”是指目标文件，“.i”文件为已经过预处理的C原始程序（临时文件）</p> </li>
</ol> 
</blockquote> 
<h3>
<a id="2_334"></a>2)编译</h3> 
<ul><li>功能主要包括：</li></ul> 
<blockquote> 
 <p>首先 gcc 检查代码的规范性、是否有语法错误；在检查无误后, gcc 把代码翻译成汇编语言</p> 
</blockquote> 
<ul><li>实例:</li></ul> 
<blockquote> 
 <p>gcc –S hello.i –o hello.s</p> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/3d/6f/w6QXDgiK_o.png" alt="image-20220211140843722"> 
<ul><li>注：</li></ul> 
<blockquote> 
 <p>“-S”选项来进行查看，该选项只进行编，生成汇编代码</p> 
</blockquote> 
<h3>
<a id="3_352"></a>3)汇编</h3> 
<ul><li>功能主要包括：</li></ul> 
<blockquote> 
 <p>汇编阶段对全局变量生成符号表；把编译阶段生成的“.s”文件转成目标文件（由汇编指令转成二进制指令）</p> 
</blockquote> 
<ul><li>示例：</li></ul> 
<blockquote> 
 <p>gcc –c hello.s –o hello.o</p> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/60/57/BQqrCJwV_o.png" alt="image-20220211141559481"> 
<ul><li>注：</li></ul> 
<blockquote> 
 <p>使用选项“-c”就可看到汇编代码已转化为“.o”的二进制目标代码了</p> 
</blockquote> 
<h3>
<a id="4_370"></a>4)链接</h3> 
<ul><li>功能主要包括：</li></ul> 
<blockquote> 
 <p>合并段表，合并符号表以及符号表的重定位；每个目标文件由链接器捆绑在一起，形成一个单一而完整的可执行程序</p> 
</blockquote> 
<ul><li>示例：</li></ul> 
<blockquote> 
 <p>gcc hello.o –o hello</p> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/e6/d3/pOOqb5ch_o.png" alt="image-20220211141727983"> 
<h2>
<a id="2_384"></a>2、函数库</h2> 
<ul><li>概念：</li></ul> 
<blockquote> 
 <p>在上面的C程序中并没有定义“printf”的函数实现，且在预编译中包含的“stdio.h”中也只有该函数的声明，而没有定义函数的实现，但是系统把这些函数实现都被放入到名为 libc.so.6 的库文件中去了，在没有特别指定时 gcc 会到系统默认的搜索路径“/usr/lib”下进行查找，也就是链接到 libc.so.6 库函数中去，这样就能间接实现函数“printf”了，而这也就是链接的作用</p> 
</blockquote> 
<ul><li>分类：</li></ul> 
<blockquote> 
 <p>函数库一般分为静态库和动态库两种</p> 
</blockquote> 
<ol><li>静态库：</li></ol> 
<blockquote> 
 <p>指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了，其后缀名一般为“.a”</p> 
</blockquote> 
<ol start="2"><li>动态库：</li></ol> 
<blockquote> 
 <p>在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销，一般后缀名为“.so”</p> 
</blockquote> 
<blockquote> 
 <p>注： gcc 在编译时默认使用动态库，可以通过 file 命令查看文件信息</p> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/6f/ef/nyfZ7DWk_o.png" alt="image-20220211142257337"> 
<ul><li>总结：</li></ul> 
<blockquote> 
 <ol>
<li> <p>以动态库链接方式生成的可执行程序体积比较小，比较节省系统资源，缺点是一旦库缺失，所以依赖的程序都不可运行</p> </li>
<li> <p>而如果是以静态库链接方式生成的可执行程序体积比较大，因为他会将库里面的代码拷贝至可执行程序，缺点是程序的体积比较大，浪费系统空间资源，但是如果库缺失不影响程序运行</p> </li>
</ol> 
</blockquote> 
<ul><li>gcc选项总结：</li></ul> 
<pre><code class="prism language-cpp"><span class="token operator">-</span>E 只激活预处理<span class="token punctuation">,</span>这个不生成文件<span class="token punctuation">,</span>你需要把它重定向到一个输出文件里面
<span class="token operator">-</span>S 编译到汇编语言不进行汇编和链接
<span class="token operator">-</span>c 编译到目标代码
<span class="token operator">-</span>o 文件输出到 文件
<span class="token operator">-</span><span class="token keyword">static</span> 此选项对生成的文件采用静态链接
<span class="token operator">-</span>g 生成调试信息。GNU 调试器可利用该信息
<span class="token operator">-</span>shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库
<span class="token operator">-</span>O0
<span class="token operator">-</span>O1
<span class="token operator">-</span>O2
<span class="token operator">-</span>O3 编译器的优化选项的<span class="token number">4</span>个级别，<span class="token operator">-</span>O0表示没有优化<span class="token punctuation">,</span><span class="token operator">-</span>O1为缺省值，<span class="token operator">-</span>O3优化级别最高
<span class="token operator">-</span>w 不生成任何警告信息
<span class="token operator">-</span>Wall 生成所有警告信息（默认生成）
</code></pre> 
<h1>
<a id="Linuxgdb_432"></a>四、Linux调试器-gdb</h1> 
<h2>
<a id="1_434"></a>1、背景及概念</h2> 
<ul><li>相关概念：</li></ul> 
<blockquote> 
 <ol>
<li> <p>程序的发布方式有debug模式和release模式</p> </li>
<li> <p>Linux gcc/g++编译链接出来的可执行程序默认是release模式</p> </li>
<li> <p>gdb 是 Linux 里的调试器，想调试必须在源代码生成可执行程序的时候加上 -g 选项</p> </li>
</ol> 
</blockquote> 
<ul><li>为什么要有debug和release：</li></ul> 
<blockquote> 
 <ol>
<li> <p>在程序开发时程序员遇到bug需要调试，而调试需要在程序里内置调试信息</p> </li>
<li> <p>而对于发布面向的是用户，用户不需要调试信息</p> </li>
</ol> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/3b/71/7N9voQqL_o.png" alt="image-20220215125208924"> 
<h2>
<a id="2_454"></a>2、调试命令</h2> 
<ul><li>示例：</li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
      sum<span class="token operator">+=</span>i<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>                                                                                                                 	 <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token function">Sum</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%dn"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>使用：</li></ul> 
<pre><code class="prism language-cpp">gdb <span class="token operator">+</span>文件名：进入调试

ctrl <span class="token operator">+</span> d 或 quit<span class="token operator">/</span>q ：退出调试
</code></pre> 
<ul><li>展示：</li></ul> 
<pre><code class="prism language-cpp">list／l 行号：显示binFile源代码，接着上次的位置往下列，每次列<span class="token number">10</span>行

list／l 函数名：列出某个函数的源代码

info <span class="token keyword">break</span><span class="token operator">/</span> info b ：查看断点信息

print<span class="token operator">/</span>p：打印表达式的值，通过表达式可以修改变量的值或者调用函数

display 变量名：跟踪查看一个变量，每次停下来都显示它的值

undisplay：取消对先前设置的那些变量的跟踪

info（i<span class="token punctuation">)</span> locals：查看当前栈帧局部变量的值

<span class="token function">breaktrace</span><span class="token punctuation">(</span>或bt<span class="token punctuation">)</span>：查看各级函数调用及参数  
</code></pre> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/7b/b6/yerf7S6m_o.png" alt="image-20220215141611907"> 
<ul><li>修改：</li></ul> 
<pre><code class="prism language-cpp">set var：修改变量的值
</code></pre> 
<ul><li>断点：</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">break</span><span class="token operator">/</span>b 行号：在某一行设置断点

<span class="token keyword">break</span> 函数名：在某个函数开头设置断点

<span class="token keyword">delete</span> breakpoints<span class="token operator">/</span>d：删除所有断点

<span class="token keyword">delete</span> breakpoints n<span class="token operator">/</span>d n：删除序号为n的断点

disable breakpoints<span class="token operator">/</span>disable：禁用断点

enable breakpoints<span class="token operator">/</span>enable：启用断点
</code></pre> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/26/1c/v0Ri9zw2_o.png" alt="image-20220215142523537"> 
<blockquote> 
 <p>注：禁用断点的作用是在使用断点后调试无误用来记录已经调试过</p> 
</blockquote> 
<ul><li>执行：</li></ul> 
<pre><code class="prism language-cpp">run<span class="token operator">/</span>r：从开始连续而非单步执行程序（从新运行，有断点运行到第一个断点，否则运行完毕）

next<span class="token operator">/</span>n：单条执行

<span class="token keyword">continue</span><span class="token operator">/</span>c：从当前位置开始连续而非单步执行程序（执行到下一个断点处）

step<span class="token operator">/</span>s：进入函数调用

finish：执行到当前函数返回，然后挺下来等待命令

until X行号：执行跳至X行
</code></pre> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/f7/25/XQlASMBJ_o.png" alt="image-20220215143100454"> 
<h1>
<a id="LinuxmakeMakefile_557"></a>五、Linux项目自动化构建工具-make/Makefile</h1> 
<h2>
<a id="1_559"></a>1、背景及概念</h2> 
<blockquote> 
 <ol>
<li> <p>一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作</p> </li>
<li> <p>make是一条命令，makefile是一个文件，两个搭配使用，完成项目自动化构建</p> </li>
<li> <p>make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令</p> </li>
<li> <p>makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率</p> </li>
</ol> 
</blockquote> 
<h2>
<a id="2_568"></a>2、使用及原理</h2> 
<blockquote> 
 <p>确定目标文件和源文件的依赖关系，有了依赖关系还需要依赖方法（用来确定具体如何执行生成目标文件）</p> 
</blockquote> 
<ul><li>示例：</li></ul> 
<img src="https://images2.imgbox.com/2d/c7/TCG1YS7V_o.png" alt="image-20220215161415051"> 
<ul><li>注意：</li></ul> 
<blockquote> 
 <ol>
<li> <p>依赖方法快捷写法示例：gcc -o $^ $@</p> </li>
<li> <p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
       
        
         
          
           @
          
          
           ：
          
          
           对
          
          
           应
          
          
           的
          
          
           是
          
          
           目
          
          
           标
          
          
           文
          
          
           件
          
          
           ；
          
         
         
          @：对应的是目标文件；
         
        
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em;vertical-align: 0em"></span><span class="mord">@</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">；</span></span></span></span></span>^：表示依赖文件列表</p> </li>
</ol> 
</blockquote> 
<ul><li>执行过程/原理：</li></ul> 
<blockquote> 
 <ol>
<li> <p>在默认的方式下只输入make命令，则会在当前目录下找名字叫“Makefile”或“makefile”的文件</p> </li>
<li> <p>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，它会找到“test”这个文件，并把这个文件作为最终的目标文件</p> </li>
<li> <p>如果test文件不存在，或是test所依赖的后面的依赖文件的文件修改时间要比这个文件新，那么它就会执行后面所定义的命令来生成test这个文件</p> </li>
<li> <p>如果test所依赖的文件不存在，那么make会在当前文件中找目标为以依赖文件的依赖性，如果找到则再根据那一个规则生成依赖文件</p> </li>
<li> <p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件</p> </li>
<li> <p>在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理</p> </li>
<li> <p>make只管文件的依赖性，即如果在找了依赖关系之后，之后如果还写有目标文件都不会进行生成</p> </li>
</ol> 
</blockquote> 
<ul><li>项目清理：</li></ul> 
<blockquote> 
 <ol>
<li> <p>像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，需要显示make执行，即命令“make clean”以此来清除所有的目标文件，以便重编译</p> </li>
<li> <p>对于clean这种目标文件，我们将它设置为伪目标（用 .PHONY 修饰），伪目标的特性是总是可以被执行（可以多次执行）</p> </li>
</ol> 
</blockquote> 
<ul><li>示图：</li></ul> 
<img src="https://images2.imgbox.com/52/a1/l7oOKS4H_o.png" alt="image-20220215162648769">
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>