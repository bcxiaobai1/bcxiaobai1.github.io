<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Rust 数据类型 之 结构体（Struct） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust 数据类型 之 结构体（Struct）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p><img alt="" height="671" src="https://images2.imgbox.com/d8/b2/s3ZFE4o7_o.png" width="1200"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Struct%EF%BC%89-toc" style="margin-left:0px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Struct%EF%BC%89">结构体（Struct）</a></p> 
<p id="%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E-toc" style="margin-left:40px"><a href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E">定义与声明</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89">结构体定义</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B">结构体实例</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E7%B1%BB">结构体分类</a></p> 
<p id="%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Unit%20Struct%EF%BC%89-toc" style="margin-left:80px"><a href="#%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Unit%20Struct%EF%BC%89">单元结构体（Unit Struct）</a></p> 
<p id="%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Tuple%20Struct%EF%BC%89-toc" style="margin-left:80px"><a href="#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Tuple%20Struct%EF%BC%89">元组结构体（Tuple Struct）</a></p> 
<p id="%E5%85%B7%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Named%20Struct%EF%BC%89-toc" style="margin-left:80px"><a href="#%E5%85%B7%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Named%20Struct%EF%BC%89">具名结构体（Named Struct）</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97-toc" style="margin-left:80px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97">结构体嵌套</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95-toc" style="margin-left:40px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95">结构体方法</a></p> 
<p id="%E4%BE%8B1%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%82%B9%E4%B8%8E%E7%82%B9%E8%B7%9D%E7%A6%BB-toc" style="margin-left:80px"><a href="#%E4%BE%8B1%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%82%B9%E4%B8%8E%E7%82%B9%E8%B7%9D%E7%A6%BB">例1：结构体转换为字符串描述</a></p> 
<p id="%E4%BE%8B2%EF%BC%9A%E7%9F%A9%E5%BD%A2%E7%9A%84%E5%91%A8%E9%95%BF%E5%92%8C%E9%9D%A2%E7%A7%AF-toc" style="margin-left:80px"><a href="#%E4%BE%8B2%EF%BC%9A%E7%9F%A9%E5%BD%A2%E7%9A%84%E5%91%A8%E9%95%BF%E5%92%8C%E9%9D%A2%E7%A7%AF">例2：矩形的周长和面积</a></p> 
<p id="%E4%BE%8B3%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9B%B4%E6%96%B0%E4%B8%8E%E8%BE%93%E5%87%BA-toc" style="margin-left:80px"><a href="#%E4%BE%8B3%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9B%B4%E6%96%B0%E4%B8%8E%E8%BE%93%E5%87%BA">例3：结构体字段的更新与输出</a></p> 
<p id="%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0">关联函数</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95%E4%B8%8E%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95%E4%B8%8E%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">结构体方法与关联函数的区别</a></p> 
<p id="%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:120px"><a href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">参数传递方式的区别</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:120px"><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">使用方式的区别</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84trait-toc" style="margin-left:40px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84trait">结构体的trait</a></p> 
<p id="%23%5Bderive(Debug)%5D-toc" style="margin-left:80px"><a href="#%23%5Bderive%28Debug%29%5D">#[derive(Debug)]</a></p> 
<p id="%E4%BE%8B1%EF%BC%9A-toc" style="margin-left:120px"><a href="#%E4%BE%8B1%EF%BC%9A">例1：</a></p> 
<p id="%E4%BE%8B2%EF%BC%9A-toc" style="margin-left:120px"><a href="#%E4%BE%8B2%EF%BC%9A">例2：</a></p> 
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8D%B0%E5%AE%8F%C2%A0-toc" style="margin-left:80px"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8D%B0%E5%AE%8F%C2%A0">自定义打印宏 </a></p> 
<p id="1.%20impl%20fmt%3A%3ADebug%20for%20Student-toc" style="margin-left:120px"><a href="#1.%20impl%20fmt%3A%3ADebug%20for%20Student">1. impl fmt::Debug for Student</a></p> 
<p id="2.%20impl%20fmt%3A%3ADisplay%C2%A0for%20Student-toc" style="margin-left:120px"><a href="#2.%20impl%20fmt%3A%3ADisplay%C2%A0for%20Student">2. impl fmt::Display for Student</a></p> 
<p id="%23%5Bderive(PartialEq)%5D-toc" style="margin-left:80px"><a href="#%23%5Bderive%28PartialEq%29%5D">#[derive(PartialEq)]</a></p> 
<p id="%E4%BE%8B1%EF%BC%9A-toc" style="margin-left:120px"><a href="#%E4%BE%8B1%EF%BC%9A">例1：</a></p> 
<p id="%E4%BE%8B2%EF%BC%9A-toc" style="margin-left:120px"><a href="#%E4%BE%8B2%EF%BC%9A">例2：</a></p> 
<p id="%23%5Bderive(Default)%5D-toc" style="margin-left:80px"><a href="#%23%5Bderive%28Default%29%5D">#[derive(Default)]</a></p> 
<p id="%E4%BE%8B1%EF%BC%9A-toc" style="margin-left:120px"><a href="#%E4%BE%8B1%EF%BC%9A">例1：</a></p> 
<p id="%E4%BE%8B2%EF%BC%9A-toc" style="margin-left:120px"><a href="#%E4%BE%8B2%EF%BC%9A">例2：</a></p> 
<p id="%23%5Bderive(Clone)%5D-toc" style="margin-left:80px"><a href="#%23%5Bderive%28Clone%29%5D">#[derive(Clone)]</a></p> 
<p id="%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9-toc" style="margin-left:40px"><a href="#%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">其他相关内容</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F-toc" style="margin-left:80px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F">模式匹配</a></p> 
<p id="%E4%BE%8B1%EF%BC%9A-toc" style="margin-left:120px"><a href="#%E4%BE%8B1%EF%BC%9A">例1：</a></p> 
<p id="%E4%BE%8B2%EF%BC%9A-toc" style="margin-left:120px"><a href="#%E4%BE%8B2%EF%BC%9A">例2：</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F-toc" style="margin-left:80px"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F">结构体大小</a></p> 
<p id="1.%20std%3A%3Amem%3A%3Asize_of-toc" style="margin-left:120px"><a href="#1.%20std%3A%3Amem%3A%3Asize_of">1. std::mem::size_of</a></p> 
<p id="2.%20std%3A%3Amem%3A%3Asize_of_val-toc" style="margin-left:120px"><a href="#2.%20std%3A%3Amem%3A%3Asize_of_val">2. std::mem::size_of_val</a></p> 
<p id="%E6%9C%AC%E6%96%87%E6%80%BB%E7%BB%93-toc" style="margin-left:40px"><a href="#%E6%9C%AC%E6%96%87%E6%80%BB%E7%BB%93">本文总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h1 id="%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Struct%EF%BC%89">结构体（Struct）</h1> 
<p>是一种自定义数据类型，允许将多个相关的值组合在一起，形成一个更复杂的数据结构。结构体被广泛应用于组织和管理数据，具有灵活性和强大的表达能力。</p> 
<h2 id="%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E">定义与声明</h2> 
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89">结构体定义</h3> 
<p>在Rust中，定义和声明结构体的语法如下：</p> 
<pre><code class="language-rust">struct Name {  
    field1: Type1,  
    field2: Type2,  
    // ...  
    fieldN: TypeN,  
}</code></pre> 
<p>其中，<code>Name</code>是结构体的名称，每个数据名及其对应的数据类型组成一个字段，<code>field1</code>到<code>fieldN</code>是结构体的<strong>字段</strong>名称，<code>Type1</code>到<code>TypeN</code>是字段的<strong>数据类型</strong>。</p> 
<p>通过关键字 struct 定义，指定结构体名称，结构体内用 field:type, 表示字段名称及数据类型，注意rust语言不能在定义的同时进行赋值，且用<strong>逗号</strong>分隔各字段，不像c/c++用<strong>分号</strong>。</p> 
<p>结构体中可以根据需要定义字段个数，理论上要多少就定义多少；但实际上字段太多，结构体也会变得很占空间，对程序的空间效率是个负担。</p> 
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B">结构体实例</h3> 
<p>如以下代码<strong>定义</strong>了一个名为Point的结构体，包含x和y两个字段，类型分别为i32和f64：</p> 
<p><em>struct Point {<!-- --><br>     x: i32,<br>     y: f64,<br> }</em></p> 
<p>定义结构体后，可以像使用其他类型一样使用它。例如，可以<strong>声明</strong>一个Point类型的变量，并为其字段<strong>赋值</strong>：</p> 
<p><em>let my_point = Point { x: 10, y: 20.0 };</em></p> 
<p>使用结构体时，用成员运算符 my_point.x 来调用对应字段的值：</p> 
<p><em>println!("({},{})", point.x, point.y);    </em>// 输出：(10,20)</p> 
<p><strong>可变实例</strong></p> 
<p>需要变动字段的值，在声明时需要用 <strong>let mut</strong>，如：</p> 
<pre><code class="language-rust">struct Point {  
    x: i32,  
    y: f64,  
}

fn main() {
	let mut point = Point { x: 10, y: 20.0 }; 
	point.x = 5;
    println!("({},{})", point.x, point.y);  // 输出：(5,20)
}</code></pre> 
<h2 id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E7%B1%BB">结构体分类</h2> 
<p>在Rust中，结构体（Struct）可以按照不同的方式进行分类，以下是一些常见的分类方式：</p> 
<h3 id="%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Unit%20Struct%EF%BC%89">单元结构体（Unit Struct）</h3> 
<p>这种结构体没有任何字段，它只是用于表示一个空的类型。这种结构体通常用于作为其他结构体的组成部分或返回类型。例如：</p> 
<p><em>struct UnitStruct;</em></p> 
<h3 id="%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Tuple%20Struct%EF%BC%89">元组结构体（Tuple Struct）</h3> 
<p>这种结构体包含一组字段，可以通过元组语法来访问每个字段。元组结构体可以用于表示简单的数据集合，不使用大括号{}，而是使用<strong>元组</strong>的小括号()。例如：</p> 
<p><em>struct TupleStruct(i32, String);</em></p> 
<p>相当字段数据没有名称的结构体，访问时使用索引。如：</p> 
<pre><code class="language-rust">struct Point (i32, f64);

fn main() {
	let mut point = Point(10, 20.0); 
	point.0 = 5;
    println!("({},{})", point.0, point.1);  
}</code></pre> 
<h3 id="%E5%85%B7%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Named%20Struct%EF%BC%89">具名结构体（Named Struct）</h3> 
<p>这种结构体有一个显式的名称，并且包含一组字段。具名结构体可以用于表示复杂的数据结构，例如一个包含多个字段的对象，本文的示例大多数都为具名结构体，用法已在本文开头讲过：</p> 
<p><em>struct MyStruct {  <br>     field1: i32,  <br>     field2: String,  <br>     // ...  <br> }</em></p> 
<p>除了以上三种常见的结构体类型，Rust还支持其他特殊类型的结构体，例如带有泛型参数的结构体、具名元组结构体（Named Tuple Struct）和结构体路径（Struct Type Alias）等。</p> 
<p>需要注意的是，在Rust中，结构体的分类并不是强制性的，也就是说，<strong>一个结构体可以包含任意类型的字段</strong>，并且可以在任何地方使用。这使得结构体非常灵活，可以用于实现各种复杂的数据结构。</p> 
<p>结构体字段的数据类型可以是以下常见的rust数据，甚至可以是函数、引用、指针类型。</p> 
<ol>
<li> <p>标量类型（Scalar Types）：</p> 
  <ul>
<li>整数类型（Integer Types）：包括有符号整数类型和无符号整数类型。常见的整数类型有 <code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code> 表示有符号整数，<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code> 表示无符号整数。此外，还有 <code>isize</code> 和 <code>usize</code>，它们根据平台的位数自动调整大小。</li>
<li>浮点数类型（Floating-Point Number Types）：包括 <code>f32</code> 和 <code>f64</code> 两种类型，表示单精度和双精度浮点数。</li>
<li>布尔类型（Boolean Type）：只有两个取值，<code>true</code> 和 <code>false</code>。</li>
<li>字符类型（Character Type）：表示单个 Unicode 字符，通常存储为 4 个字节。</li>
</ul>
</li>
<li> <p>复合类型（Composite Types）：</p> 
  <ul>
<li>数组类型（Array Types）：由相同类型的元素组成的有限集合。可以通过固定长度或动态长度来定义数组。</li>
<li>切片类型（Slice Types）：对一个连续的内存块进行引用，可以看作是动态数组。切片类型提供了访问和操作数据的一种高效方式。</li>
<li>元组类型（Tuple Types）：一种将多个不同类型的值组合在一起的数据结构，用圆括号和逗号分隔的元素序列表示。元组可以包含不同类型的元素，例如整数、浮点数、布尔值、字符串等。</li>
<li>结构体类型（Struct Types）：一种自定义的数据类型，可以包含多个不同类型的字段。结构体可以通过定义来指定其字段和属性。</li>
<li>枚举类型（Enum Types）：表示一个可能取多个值的变量。在 Rust 中，枚举类型使用 <code>enum</code> 关键字定义，每个可能的取值都是一个不同的枚举成员。</li>
</ul>
</li>
</ol> 
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97">结构体嵌套</h3> 
<p>一个结构体可以包含任意类型的字段，当然也包括结构体。</p> 
<p>在以下这个例子中，Address 结构体包含了 street、city 和 state 三个字段，而 Person 结构体则包含了 name、age 和 address 三个字段，其中 address 字段的类型是 Address 结构体。</p> 
<pre><code class="language-rust">struct Address {  
    street: String,  
    city: String,  
    state: String,  
}  
  
struct Person {  
    name: String,  
    age: u8,  
    address: Address,  
}</code></pre> 
<h2 id="%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95">结构体方法</h2> 
<p>方法（method）是在结构体上定义的功能，可以访问结构体的字段并执行一些操作。使用关键字impl，结构体可以对应一个或多个impl代码块。</p> 
<h3 id="%E4%BE%8B1%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%82%B9%E4%B8%8E%E7%82%B9%E8%B7%9D%E7%A6%BB">例1：结构体转换为字符串描述</h3> 
<pre><code class="language-rust">struct Student {
    name:String,
    age:u32,
    school:String,
    major:String,
    grade:String,
    state:bool
}
  
impl Student {  
    fn to_string(&amp;self) -&gt; String {  
        format!("Student {<!-- -->{ name: {}, age: {}, school: {}, major: {}, grade: {}, state: {} }}", 
            self.name, self.age, self.school, self.major, self.grade, self.state)  
    }  
} 

fn main() {
    let school = String::from("东南大学");
    let major = String::from("土木工程学院");
    let s = Student{
        name:String::from("杨程"),
        age:22,
        school,
        major,
        grade:String::from("大三"),
        state:true
    };
    println!("{}", s.to_string());
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Student { name: 杨程, age: 22, school: 东南大学, major: 土木工程学院, grade: 大三, state: true }</p> 
<p>注意：上例中有一个rust结构体的特殊用法，使用同名变量在结构体外为对应字段赋值。</p> 
<h3 id="%E4%BE%8B2%EF%BC%9A%E7%9F%A9%E5%BD%A2%E7%9A%84%E5%91%A8%E9%95%BF%E5%92%8C%E9%9D%A2%E7%A7%AF">例2：矩形的周长和面积</h3> 
<pre><code class="language-rust">struct Rectangle {  
    width: f32,  
    height: f32,  
}  
  
impl Rectangle {  
    // 构造函数  
    fn new(width: f32, height: f32) -&gt; Rectangle {  
        Rectangle { width, height }  
    }  
  
    // 计算矩形的面积  
    fn area(&amp;self) -&gt; f32 {  
        self.width * self.height  
    }  
  
    // 计算矩形的周长  
    fn perimeter(&amp;self) -&gt; f32 {  
        (self.width + self.height) * 2.0
    }  
}

impl Rectangle {  
    // 判断矩形是否相等  
    fn is_equal(&amp;self, other: &amp;Rectangle) -&gt; bool {  
        self.width == other.width &amp;&amp; self.height == other.height  
    }  
}  
  
fn main() {  
    let rect1 = Rectangle::new(5.0, 6.0);  
    let rect2 = Rectangle::new(5.0, 6.0);  
  
    println!("Rectangle 1 area: {}", rect1.area());  
    println!("Rectangle 1 perimeter: {}", rect1.perimeter());  
  
    println!("Rectangle 2 area: {}", rect2.area());  
    println!("Rectangle 2 perimeter: {}", rect2.perimeter());  
  
    if rect1.is_equal(&amp;rect2) {  
        println!("Rectangles are equal");  
    } else {  
        println!("Rectangles are not equal");  
    }  
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Rectangle 1 area: 30<br> Rectangle 1 perimeter: 22<br> Rectangle 2 area: 30<br> Rectangle 2 perimeter: 22<br> Rectangles are equal </p> 
<h3 id="%E4%BE%8B3%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9B%B4%E6%96%B0%E4%B8%8E%E8%BE%93%E5%87%BA">例3：结构体字段的更新与输出</h3> 
<pre><code class="language-rust">struct Person {  
    name: String,  
    age: u32,  
}  
  
impl Person {  
    // 这是构造函数，用于创建一个新的 Person 实例  
    fn new(name: String, age: u32) -&gt; Person {  
        Person { name, age }  
    }  
  
    fn say_hello(&amp;self) {  
        println!("Hello, my name is {} and I'm {}.", self.name, self.age);  
    }  
  
    fn update_age(&amp;mut self, new_age: u32) {  
        self.age = new_age;  
    } 

    fn update_name(&amp;mut self, new_name: String) {  
        self.name = new_name;  
    }  
}  
  
fn main() {  
    // 创建一个新的 Person 实例  
    let mut person = Person::new("Tom".to_string(), 5);  
  
    // 调用 say_hello 方法，输出 Person 的信息  
    person.say_hello();  
  
    // 调用 update_age 方法，更新 Person 的年龄  
    person.update_age(3);  
  
    // 再次调用 say_hello 方法，输出更新后的信息  
    person.say_hello(); 

    person.update_age(5);
    person.update_name(String::from("Jerry"));  
    person.say_hello();  
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Hello, my name is Tom and I'm 5.<br> Hello, my name is Tom and I'm 3.<br> Hello, my name is Jerry and I'm 5.</p> 
<h2 id="%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0">关联函数</h2> 
<p>之所以"结构体方法"不叫"结构体函数"是因为"函数"这个名字留给了这种函数：它在 impl 块中却没有 &amp;self 参数。这种函数不依赖实例，但是使用它需要声明是在哪个 impl 块中的，比如上小节例2和例3中的构造函数new()就是关联函数，类似于字符串函数String::new()，String::from("Jerry")。</p> 
<p><strong>示例：</strong></p> 
<pre><code class="language-rust">#[derive(Debug,Clone)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn create(width: u32, height: u32) -&gt; Rectangle {
        Rectangle { width, height }
    }
    fn area(self) -&gt; u32 {
        self.width * self.height
    }
    fn area2(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect = Rectangle::create(30, 50);
    println!("{:?}", rect);
    println!("Area: {}", Rectangle::area(rect.clone()));
    println!("Area: {}", rect.area2());
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Rectangle { width: 30, height: 50 }<br> Area: 1500<br> Area: 1500</p> 
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95%E4%B8%8E%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">结构体方法与关联函数的区别</h3> 
<h4 id="%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">参数传递方式的区别</h4> 
<p>结构体方法：结构体方法默认情况下是可变的（mutable），也就是说可以修改结构体的字段。在调用方法时，可以通过引用（&amp;self）或可变引用（&amp;mut self）来传递结构体实例，以便修改其字段。例如：my_struct.my_method(&amp;mut my_struct)。</p> 
<p>关联函数：关联函数默认情况下是不可变的（immutable），也就是说无法修改结构体的字段。在调用函数时，只能通过常量引用（&amp;self）来传递结构体实例，因为常量引用是只读的。例如：let my_struct = MyStruct {...}; my_struct.my_function()。</p> 
<h4 id="%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">使用方式的区别</h4> 
<p>结构体方法：结构体方法可以直接在结构体实例上调用，无需显式传递结构体实例。例如：my_struct.my_method()。</p> 
<p>关联函数：关联函数需要显式传递结构体实例作为参数。例如：MyStruct::my_function(my_struct)。</p> 
<h2 id="%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84trait">结构体的trait</h2> 
<p>Rust 中的 trait 是一种抽象类型，用于定义泛型行为，trait 可以理解为一种接口。trait 使用关键字 derive 来自动生成实现。通过使用 derive，可以避免手动编写冗长的代码，提高代码的可读性和可维护性。trait 有很多，比如Copy，Clone，Debug，Default，Drop，Hash，Ord，PartialOrd，Send，Sync等等，先挑几种最常用的学一下：</p> 
<h3 id="%23%5Bderive(Debug)%5D">#[derive(Debug)]</h3> 
<p>在 Rust 语言中用于自动生成一个结构体的 Debug 实现，Debug 是 Rust 标准库中的一个 trait，用于在控制台打印调试信息。</p> 
<p>使用 #[derive(Debug)] 属性可以为结构体自动生成一个 Debug 实现，这样在需要打印调试信息时，就可以使用 {:?} 格式化字符串来打印该结构体的内容。例如，在上面的代码中，s 结构体的 Debug 实现已经被自动生成，因此可以使用 <span style="color:#fe2c24"><strong>println!("{:?}", s)</strong></span> 来打印出结构体 s 的内容。</p> 
<h4 id="%E4%BE%8B1%EF%BC%9A"><strong>例1：</strong></h4> 
<pre><code class="language-rust">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn distance(&amp;self, other: &amp;Point) -&gt; f32 {
        let x_diff = self.x - other.x;
        let y_diff = self.y - other.y;
        ((x_diff * x_diff + y_diff * y_diff) as f32).sqrt()
    }
}

fn main() {
    let p1 = Point { x: 3, y: 0 };
    let p2 = Point { x: 0, y: 4 };
    println!("Distance between {:?} and {:?} is {}.", p1, p2, p1.distance(&amp;p2));
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Distance between Point { x: 3, y: 0 } and Point { x: 0, y: 4 } is 5. </p> 
<h4 id="%E4%BE%8B2%EF%BC%9A"><strong>例2：</strong></h4> 
<pre><code class="language-rust">#[derive(Debug)]
struct Student {
    name: String,
    age: u32,
    school: String,
    major: String,
    grade: String,
    state: bool,
}  

impl Student {
    fn new() -&gt; Student {
        return Student {
            age: 0,
            name: String::new(),
            school: String::from(""),
            major: "".to_string(),
            grade: "".to_string(),
            state: false,
        };
    }
}

fn main() {  
    let mut s = Student::new();
    s.name = String::from("杨程");
    s.age = 22;
    s.school = String::from("东南大学");
    s.major = String::from("土木工程学院");
    s.grade = String::from("大三");
    s.state = true;
    println!("{:?}", s);
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Student { name: "杨程", age: 22, school: "东南大学", major: "土木工程学院", grade: "大三", state: true } </p> 
<p>与上一小节的例2对比，输出内容基本一致，就多了String的引号标记。相比自动生成 Debug 实现可以简化代码编写过程，并且可以避免手动实现 Debug 时可能出现的错误。</p> 
<p>在本例中，使用宏打印结构体<span style="color:#fe2c24"><strong>println!("{:?}", s);</strong></span>时，第一行的代码#[derive(Debug)]是必须的，如果去掉就会报错：</p> 
<p></p> 
<blockquote> 
 <p>error[E0277]: `Student` doesn't implement `Debug`<br>   --&gt; E:.rsstruct2.rs:31:22<br>    |<br> 31 |     println!("{:?}", s);<br>    |                      ^ `Student` cannot be formatted using `{:?}`<br>    |<br>    = help: the trait `Debug` is not implemented for `Student`<br>    = note: add `#[derive(Debug)]` to `Student` or manually `impl Debug for Student`<br>    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)<br> help: consider annotating `Student` with `#[derive(Debug)]`<br>    |<br> 1  + #[derive(Debug)]<br> 2  | struct Student {<!-- --><br>    |</p> 
 <p>error: aborting due to previous error</p> 
</blockquote> 
<p></p> 
<h3 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8D%B0%E5%AE%8F%C2%A0">自定义打印宏 </h3> 
<h4 id="1.%20impl%20fmt%3A%3ADebug%20for%20Student">1. impl fmt::<span style="color:#fe2c24"><strong>Debug</strong></span> for Student</h4> 
<p>返回值：fmt::Result； 调用：println!("{:?}", s);</p> 
<pre><code class="language-rust">use std::fmt;

struct Student {
    name: String,
    age: u32,
    school: String,
    major: String,
    grade: String,
    state: bool,
}  
  
impl fmt::Debug for Student {  
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f,
               "Student {<!-- -->{ name: {}, age: {}, school: {}, major: {}, grade: {}, state: {} }}",
               self.name, self.age, self.school, self.major, self.grade, self.state)
    }  
}  
  
fn main() {  
    let school = String::from("东南大学");
    let major = String::from("土木工程学院");
    let s = Student {
        name: String::from("杨程"),
        age: 22,
        school,
        major,
        grade: String::from("大三"),
        state: true,
    };  
    println!("{:?}", s);
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Student { name: 杨程, age: 22, school: 东南大学, major: 土木工程学院, grade: 大三, state: true }  </p> 
<h4 id="2.%20impl%20fmt%3A%3ADisplay%C2%A0for%20Student">2. impl fmt::<span style="color:#fe2c24"><strong>Display</strong></span> for Student</h4> 
<p>返回值：fmt::Result； 调用：println!("{}", s); {}里不需要:?</p> 
<pre><code class="language-rust">use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

impl Point {
    fn distance(&amp;self, other: &amp;Point) -&gt; f32 {
        let x_diff = self.x - other.x;
        let y_diff = self.y - other.y;
        ((x_diff * x_diff + y_diff * y_diff) as f32).sqrt()
    }
}

fn main() {
    let p1 = Point { x: 3, y: 0 };
    let p2 = Point { x: 0, y: 4 };
    println!("Distance between {} and {} is {}.", p1, p2, p1.distance(&amp;p2));
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Distance between Point(3, 0) and Point(0, 4) is 5.</p> 
<p>输出要与使用#[derive(Debug)]时一样，只要修改write宏的第2个参数，如：</p> 
<pre><code class="language-rust">impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "Point {<!-- -->{ x: {}, y: {} }}", self.x, self.y)
    }
}</code></pre> 
<h3 id="%23%5Bderive(PartialEq)%5D">#[derive(PartialEq)]</h3> 
<p>使用#[derive(PartialEq)]为结构体自动实现了PartialEq trait。这使得可以直接使用==运算符比较两个结构体实例的相等性。</p> 
<h4><strong>例1：</strong></h4> 
<pre><code class="language-rust">#[derive(PartialEq)]
struct Point {  
    x: i32,  
    y: i32,  
}

fn main() {
	let point1 = Point { x: 10, y: 20 };  
	let point2 = Point { x: 10, y: 20 };  
	if point1 == point2 {  
	    println!("The two points are equal.");  
	} else {  
	    println!("The two points are not equal.");  
	}
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>The two points are equal.</p> 
<h4><strong>例2：</strong></h4> 
<pre><code class="language-rust">#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let person1 = Person {
        name: String::from("Alice"),
        age: 25,
    };

    let person2 = Person {
        name: String::from("Bob"),
        age: 30,
    };

    let person3 = Person {
        name: String::from("Alice"),
        age: 25,
    };

    println!("Is {:?} equal to {:?}? {}", person1, person2, person1 == person2);
    println!("Is {:?} equal to {:?}? {}", person1, person3, person1 == person3);
}
</code></pre> 
<p><strong>输出：</strong></p> 
<p>Is Person { name: "Alice", age: 25 } equal to Person { name: "Bob", age: 30 }? false<br> Is Person { name: "Alice", age: 25 } equal to Person { name: "Alice", age: 25 }? true</p> 
<h3 id="%23%5Bderive(Default)%5D">#[derive(Default)]</h3> 
<p>调用#[derive(Default)]，相当于创建一个默认的结构体实例，每一个字段都是对应数据类型的默认值，无需手动为每个字段设置默认值。</p> 
<h4><strong>例1：</strong></h4> 
<pre><code class="language-rust">#[derive(Default,Debug)]
struct Circle {
    radius: f32,
}  

impl Circle {
    fn area(&amp;self) -&gt; f32 {
        let pi = std::f32::consts::PI;
        pi * self.radius * self.radius
    }
}

fn main() {
    let mut c = Circle::default();
    println!("Circular area of {:?} = {}.", c, c.area());
    c.radius = 1.0;
    println!("Circular area of {:?} = {}.", c, c.area());
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Circular area of Circle { radius: 0.0 } = 0.<br> Circular area of Circle { radius: 1.0 } = 3.1415927.</p> 
<h4><strong>例2：</strong></h4> 
<pre><code class="language-rust">#[derive(Debug, Default)]
struct Student {  
    name: String,  
    age: u32,  
    school: String,  
    major: String,  
    grade: String,  
    state: bool,  
}  
  
fn main() {  
    let mut s1 = Student::default(); 
    println!("{:?}", s1);
    
    s1.name = String::from("杨程");  
    s1.age = 22;  
    s1.school = String::from("东南大学");  
    s1.major = String::from("土木工程学院");  
    s1.grade = String::from("大三");  
    s1.state = true;  
    println!("{:?}", s1);  
  
    let s2 = Student {  
        age: 23,  
        grade: String::from("大四"),  
        ..s1  //注意这里的结构体更新语法
    };  
    println!("{:?}", s2);  
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Student { name: "", age: 0, school: "", major: "", grade: "", state: false }<br> Student { name: "杨程", age: 22, school: "东南大学", major: "土木工程学院", grade: "大三", state: true }<br> Student { name: "杨程", age: 23, school: "东南大学", major: "土木工程学院", grade: "大四", state: true }</p> 
<p>此例还有一个rust结构体的特殊用法，当结构体大部分字段需要被设置成与现存的另一个结构体的一样，仅需更改其中的一两个字段的值，可以使用结构体<span style="color:#fe2c24"><strong>更新语法</strong></span>，在现存的结构体名前加上两个连续的句号：“<span style="color:#fe2c24"><strong>..</strong></span>Struct_Name”。</p> 
<h3 id="%23%5Bderive(Clone)%5D">#[derive(Clone)]</h3> 
<p>Clone 在复制过程中对所有字段进行逐个复制，包括所有引用类型和原始类型。这意味着每次进行克隆时，都会创建新的数据副本。 </p> 
<p><strong>示例：</strong></p> 
<pre><code class="language-rust">#[derive(Clone)]
struct Person {  
    name: String,  
    age: i32,  
}  
  
fn main() {  
    let mut person1 = Person { name: String::new(), age: 0 };  
    let mut person2 = person1.clone();

    person1.name = "Alice".to_string();
    person1.age = 22;
    println!("Person 1: {}, {}", person1.name, person1.age);
    println!("Person 2: {}, {}", person2.name, person2.age);
    person2 = person1.clone();
    println!("Person 2: {}, {}", person2.name, person2.age);
}
</code></pre> 
<p>输出：</p> 
<p>Person 1: Alice, 22<br> Person 2: , 0<br> Person 2: Alice, 22</p> 
<h2 id="%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">其他相关内容</h2> 
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F">模式匹配</h3> 
<p>结构体可用 模式匹配（Pattern Matching）来解构和访问其字段。</p> 
<h4><strong>例1：</strong></h4> 
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 10, y: 20 };

    match p {
        Point { x, y } =&gt; {
            println!("x:{}, y: {}", x, y);
        }
    }
}</code></pre> 
<h4><strong>例2：</strong></h4> 
<pre><code class="language-rust">struct Time {  
    hour: i32,  
    minute: i32,  
    second: i32,  
}  
  
fn main() {  
    let t = Time { hour: 10, minute: 30, second: 45 };  
    match t {  
        Time { hour, minute, second } =&gt; {  
            print!("The time is {}:", hour);
            println!("{}:{}", minute, second);  
        }  
    }  
}</code></pre> 
<h3>结构体大小</h3> 
<p>结构体的大小在C/C++中使用运算符 sizeof 来计算；在Rust语言中，则使用标准库中的一个模块std::mem::中的size_of和size_of_val，它提供了与内存管理相关的函数。</p> 
<h4 id="1.%20std%3A%3Amem%3A%3Asize_of">1. std::mem::size_of</h4> 
<p>用于计算给定类型的大小，不接受任何参数。这个函数返回一个给定类型的大小（以字节为单位）。它是一个泛型函数，可以用于任何类型。</p> 
<p><strong>示例：</strong></p> 
<pre><code class="language-rust">#![allow(dead_code)]

struct Point {
    x: i32,
    y: i32,
}  
  
struct Person {
    name: String,
    age: i32,
    height: f32,
    is_employed: bool,
}  
  
fn main() {
    let point = Point { x: 10, y: 20 };  
    println!("Size of Point: {}", std::mem::size_of::&lt;Point&gt;());

    let person = Person {
        name: "Hann Yang".to_string(),
        age: 50,
        height: 1.72,
        is_employed: true,
    };  
    println!("Size of Person: {}", std::mem::size_of::&lt;Person&gt;());
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Size of Point: 8<br> Size of Person: 40 </p> 
<h4 id="2.%20std%3A%3Amem%3A%3Asize_of_val">2. std::mem::size_of_val</h4> 
<p>用于计算给定值的大小，接受一个值作为参数。它用于获取一个值的大小（以字节为单位）。与 size_of 函数不同的是，size_of_val 函数可以用于任何值，而非类型。</p> 
<p><strong>示例：</strong></p> 
<pre><code class="language-rust">#![allow(dead_code)]

struct Point {
    x: i32,
    y: i32,
}  
  
struct Person {
    name: String,
    age: i32,
    height: f32,
    is_employed: bool,
}  
  
fn main() {
    let point = Point { x: 10, y: 20 };  
    println!("Size of Point: {}", std::mem::size_of_val(&amp;point));

    let person = Person {
        name: "Hann Yang".to_string(),
        age: 50,
        height: 1.72,
        is_employed: true,
    };  
    println!("Size of Person: {}", std::mem::size_of_val(&amp;person));
}</code></pre> 
<p><strong>输出：</strong></p> 
<p>Size of Point: 8<br> Size of Person: 40 </p> 
<p>注意：在这两个例子中，计算类型大小和值大小的结果都是相同的，因为这里没有涉及到指针或其他复杂的情况。 </p> 
<hr> 
<h2 id="%E6%9C%AC%E6%96%87%E6%80%BB%E7%BB%93">本文总结</h2> 
<p>结构体是Rust中一种重要的数据结构，用于组织不同类型的字段。以下是结构体的重点内容的总结：</p> 
<ul>
<li>结构体定义：使用<code>struct</code>关键字来定义结构体，结构体可以包含多个字段，每个字段可以有不同的类型。</li>
<li>结构体实例：定义一个结构体后，可以使用结构体名称来创建结构体实例，通过<code>.</code>运算符来访问结构体字段。</li>
<li>结构体分类：结构体可以分为三种类型：单元结构体（<code>()</code>）、元组结构体（用逗号分隔的多个字段）和具名结构体（有自定义名称的字段）。</li>
<li>结构体嵌套：结构体可以嵌套，用于组织和存储复杂的数据。</li>
<li>结构体方法：结构体可以定义方法，用于在结构体上执行操作。结构体方法与关联函数类似，但只能在结构体上调用。</li>
<li>关联函数：通过<code>impl</code>关键字在结构体上定义关联函数，用于在结构体实例上执行特定操作。关联函数可以是普通函数或方法。</li>
<li>自定义打印宏：使用<code>derive(Debug)]</code>来自动实现<code>fmt::Debug</code> trait，实现自定义的打印输出格式。</li>
<li>其他相关内容：结构体可以通过<code>derive</code>属性来自动实现其他trait，如<code>PartialEq</code>（部分相等性）、<code>Default</code>（默认值）和<code>Clone</code>（克隆）。</li>
<li>结构体大小：在Rust中，结构体的内存大小是固定的，可以在定义时指定大小，也可以使用<code>#[repr(C)]</code>来指定大小和布局。</li>
<li>模式匹配：可以使用模式匹配来访问和匹配结构体的字段，这使得在编写代码时更加灵活和方便。</li>
</ul> 
<p>总的来说，结构体是Rust中非常强大和灵活的数据结构，可以用于组织和操作各种类型的数据。通过使用结构体、方法、关联函数和其他相关特性，可以轻松地实现复杂的数据结构和算法。</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>