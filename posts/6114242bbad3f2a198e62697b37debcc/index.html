<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>前端面试的性能优化部分（1）每篇10题 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端面试的性能优化部分（1）每篇10题</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <h2>
<a id="1__0"></a><strong>1. 懒加载的概念</strong>
</h2> 
<p>懒加载（Lazy Loading）是一种优化技术，它用于延迟加载页面资源，只在需要时才加载特定的内容，而不是在页面初始加载时一次性加载所有资源。懒加载的目的是提高页面加载速度和性能，尤其对于单页应用（SPA）或包含大量图片和其他资源的网页来说尤为重要。</p> 
<p>懒加载可以应用在多种场景中，包括但不限于以下几个方面：</p> 
<ol>
<li> <p><strong>图片懒加载：</strong> 在网页中加载大量图片时，可以先加载可视区域内的图片，当用户滚动页面时再动态加载其他图片。这样可以减少页面的初始加载时间，提高用户体验。</p> </li>
<li> <p><strong>延迟加载非关键资源：</strong> 将非关键资源（如广告、社交媒体插件等）的加载推迟到页面其他内容加载完毕后再进行，从而提高页面的加载速度。</p> </li>
<li> <p><strong>按需加载组件：</strong> 对于复杂的单页应用，可以根据用户的操作，动态加载所需的组件和模块，从而减少初始加载时间，提高页面响应速度。</p> </li>
<li> <p><strong>按需加载字体和样式：</strong> 对于字体和样式等资源，可以在需要时再进行加载，而不是在页面初始加载时全部加载，从而减少不必要的网络请求。</p> </li>
</ol> 
<p>懒加载的实现方式通常基于浏览器的事件，如监听页面滚动事件来判断元素是否进入可视区域，然后触发加载相应的内容。在前端开发中，可以使用JavaScript库（如Intersection Observer API）或自定义实现懒加载功能。懒加载是一种常用的前端性能优化技术，可以有效减少不必要的资源加载，提高页面加载速度和用户体验。</p> 
<h2>
<a id="2__16"></a><strong>2. 懒加载的特点</strong>
</h2> 
<p>懒加载具有以下特点：</p> 
<ol>
<li> <p><strong>减少初始加载时间：</strong> 懒加载可以将页面资源分成多个部分，只加载首屏可视区域内的内容，从而减少页面的初始加载时间。用户打开页面时只加载必要的资源，其他内容在用户需要时再进行加载，提高了页面的加载速度和响应性。</p> </li>
<li> <p><strong>节省带宽和资源：</strong> 懒加载可以避免一次性加载所有资源，节省了不必要的带宽和服务器资源。特别是对于移动端用户或者网络状况较差的用户来说，懒加载可以减少页面的数据传输量，提高页面的加载效率。</p> </li>
<li> <p><strong>优化用户体验：</strong> 懒加载可以让用户更快地访问页面内容，减少等待时间，提高用户体验。用户在滚动页面时，页面内容逐渐显示，给予用户逐步展示内容的感觉，增加了交互性和吸引力。</p> </li>
<li> <p><strong>按需加载：</strong> 懒加载可以根据用户的操作和需要，按需加载相应的资源。对于复杂的单页应用或需要动态加载内容的场景，懒加载可以帮助按需加载组件、模块或其他资源，提高页面响应速度。</p> </li>
<li> <p><strong>节省资源成本：</strong> 懒加载可以在一定程度上降低服务器的负载，因为只有在用户需要时才进行资源加载，避免了不必要的资源消耗。对于大型网站或高并发的应用，懒加载有助于优化资源利用，节省资源成本。</p> </li>
</ol> 
<p>总的来说，懒加载是一种重要的前端优化技术，通过延迟加载页面资源，优化了页面的加载性能，提高了用户体验，同时节省了带宽和服务器资源。在现代的网页开发中，懒加载已经成为一种常用的优化手段，特别适用于需要处理大量资源或图片的页面。</p> 
<h2>
<a id="3__32"></a><strong>3. 懒加载的实现原理</strong>
</h2> 
<p>懒加载的实现原理通常基于浏览器的事件和一些JavaScript技术。主要的实现原理如下：</p> 
<ol>
<li> <p><strong>监听页面滚动事件：</strong> 在页面上注册滚动事件，当用户滚动页面时，触发相应的懒加载操作。</p> </li>
<li> <p><strong>计算元素位置：</strong> 获取需要懒加载的元素的位置信息，比如元素的相对位置、可视区域的位置等。</p> </li>
<li> <p><strong>判断元素是否进入可视区域：</strong> 根据页面滚动和元素位置信息，判断元素是否进入可视区域。如果元素进入了可视区域，表示用户可以看到该元素，即需要进行懒加载。</p> </li>
<li> <p><strong>触发加载操作：</strong> 当元素进入可视区域时，触发加载操作，加载元素的内容，比如加载图片、组件、模块或其他资源。</p> </li>
<li> <p><strong>延迟加载：</strong> 懒加载会延迟加载页面资源，即在页面初始加载时只加载必要的内容，其他内容在需要时再加载。这样可以提高页面的初始加载速度。</p> </li>
<li> <p><strong>懒加载策略：</strong> 对于不同的页面元素，可以采取不同的懒加载策略。比如对于图片，可以使用<code>&lt;img&gt;</code>标签的<code>data-src</code>属性来存储真实的图片地址，在滚动时再将<code>data-src</code>属性的值赋给<code>src</code>属性，从而实现图片懒加载。</p> </li>
</ol> 
<p>常见的懒加载实现方式包括使用Intersection Observer API、手动监听滚动事件、使用第三方懒加载库等。Intersection Observer API是浏览器提供的一种现代的懒加载实现方式，它可以监听元素是否进入可视区域，并触发相应的回调函数。手动监听滚动事件需要开发者自行计算元素位置并判断是否进入可视区域，较为复杂。第三方懒加载库（如<code>LazyLoad</code>、<code>Lozad.js</code>等）提供了简单易用的接口，可以快速实现懒加载功能。</p> 
<p>懒加载是一种重要的前端优化技术，通过延迟加载页面资源，提高了页面的加载性能和用户体验。在开发中，根据项目需求和性能优化目标，选择合适的懒加载方式来实现延迟加载，从而提升网页性能。</p> 
<h2>
<a id="4__52"></a><strong>4. 回流与重绘的概念及触发条件</strong>
</h2> 
<p>回流（Reflow）和重绘（Repaint）是浏览器渲染页面时的两个重要概念。</p> 
<p>**回流（Reflow）**是指当DOM结构发生变化或者元素的样式发生改变时，浏览器重新计算元素的几何属性（比如位置、大小），并重新布局页面，使得页面的结构发生改变。回流是比较耗费性能的操作，因为它需要重新计算和布局整个页面。</p> 
<p>**重绘（Repaint）**是指当元素的样式发生改变，但不影响其几何属性时，浏览器只需要重新绘制元素的外观，而无需重新计算和布局页面。重绘的性能开销较小，比回流要快。</p> 
<p><strong>触发条件：</strong></p> 
<ol>
<li> <p><strong>回流触发条件：</strong></p> 
  <ul>
<li>添加或删除DOM元素。</li>
<li>元素位置、尺寸、内容发生改变。</li>
<li>浏览器窗口大小变化。</li>
<li>元素字体大小变化。</li>
<li>激活CSS伪类（如:hover）。</li>
<li>添加或删除样式表。</li>
<li>设置元素的style属性。</li>
</ul> </li>
<li> <p><strong>重绘触发条件：</strong></p> 
  <ul><li>元素的颜色、背景色等外观样式发生改变，但不影响元素的几何属性。</li></ul> </li>
</ol> 
<p><strong>优化策略：</strong></p> 
<p>由于回流和重绘操作会消耗较多的性能，因此在前端开发中，我们应该尽量避免频繁的触发回流和重绘操作，以提高页面性能。以下是一些优化策略：</p> 
<ul>
<li>使用<code>transform</code>属性代替<code>top</code>和<code>left</code>等位置属性来移动元素，因为<code>transform</code>不会触发回流。</li>
<li>使用<code>visibility: hidden</code>代替<code>display: none</code>，因为前者只会触发重绘，而后者会触发回流。</li>
<li>使用<code>classList</code>一次性添加或删除多个class，避免多次回流。</li>
<li>使用<code>documentFragment</code>来批量操作DOM，减少回流次数。</li>
<li>将频繁发生改变的DOM元素脱离文档流，改变其样式后再插入文档，减少回流次数。</li>
</ul> 
<p>通过合理优化页面结构和样式，尽量减少回流和重绘的触发，可以提高页面性能，提升用户体验。</p> 
<h2>
<a id="5__86"></a><strong>5. 如何避免回流与重绘？</strong>
</h2> 
<p>避免回流和重绘是优化页面性能的重要手段。以下是一些方法可以帮助我们尽量避免回流和重绘：</p> 
<p><strong>1. 使用<code>transform</code>和<code>opacity</code>属性：</strong> <code>transform</code>和<code>opacity</code>属性不会触发回流，可以使用它们来实现动画效果而不影响页面布局。</p> 
<p><strong>2. 批量修改DOM：</strong> 使用<code>documentFragment</code>或<code>innerHTML</code>等方式，将多次DOM操作合并成一次，减少回流次数。</p> 
<p><strong>3. 使用虚拟DOM：</strong> 一些前端框架（如React、Vue）使用虚拟DOM来优化页面更新过程，通过对比虚拟DOM和真实DOM的差异，最小化更新操作，减少回流和重绘。</p> 
<p><strong>4. 使用<code>display: none</code>：</strong> 尽量避免在频繁变动的元素上使用<code>display: none</code>，因为它会导致回流。可以使用<code>visibility: hidden</code>代替，因为它只触发重绘。</p> 
<p><strong>5. 使用<code>position: absolute</code>：</strong> 在一些情况下，将元素的<code>position</code>设置为<code>absolute</code>，可以将其脱离文档流，减少对其他元素的影响，避免回流。</p> 
<p><strong>6. 避免频繁读取样式信息：</strong> 多次读取样式信息会导致多次回流，尽量避免频繁读取样式信息。可以使用缓存或将样式信息保存在变量中，减少回流次数。</p> 
<p><strong>7. 使用<code>requestAnimationFrame</code>：</strong> 使用<code>requestAnimationFrame</code>来优化动画效果，它可以在浏览器下一次重绘之前执行动画更新，避免频繁的重绘。</p> 
<p><strong>8. 使用CSS动画：</strong> CSS动画使用GPU来执行动画效果，可以避免触发回流，提高动画性能。</p> 
<p>综合运用上述方法，我们可以有效地避免回流和重绘，提高页面性能，提升用户体验。在开发过程中，需要综合考虑页面结构和样式，以及动画效果的优化，从而减少不必要的回流和重绘操作。</p> 
<h2>
<a id="6__108"></a><strong>6. 如何优化动画？</strong>
</h2> 
<p>优化动画是为了提高页面性能和用户体验。以下是一些优化动画的方法：</p> 
<p><strong>1. 使用CSS动画：</strong> 尽量使用CSS动画而不是JavaScript动画。CSS动画可以使用GPU加速，比JavaScript动画更高效。可以使用<code>transition</code>、<code>animation</code>等CSS属性来实现动画效果。</p> 
<p><strong>2. 使用transform和opacity：</strong> 对于需要改变元素位置和透明度的动画，尽量使用<code>transform</code>和<code>opacity</code>属性。它们不会触发回流，性能更好。</p> 
<p><strong>3. 使用requestAnimationFrame：</strong> 使用<code>requestAnimationFrame</code>来优化动画更新。它会在浏览器下一次重绘之前执行动画更新，避免频繁的重绘操作。</p> 
<p><strong>4. 避免频繁的样式改变：</strong> 尽量避免在短时间内频繁改变元素样式，因为这会导致多次回流和重绘。可以使用<code>classList</code>一次性添加或删除多个class，来优化样式的改变。</p> 
<p><strong>5. 合理设置动画时长：</strong> 动画时长不宜过长，也不宜过短。过长的动画会影响页面加载速度和用户体验，而过短的动画可能无法让用户完整地感知动画效果。</p> 
<p><strong>6. 避免在影响性能的元素上使用动画：</strong> 尽量避免在影响性能的元素（如较大的图片、复杂的DOM结构）上使用动画，因为这会导致动画性能下降。</p> 
<p><strong>7. 使用硬件加速：</strong> 可以使用<code>will-change</code>属性来告诉浏览器一个元素将要被改变，从而启用硬件加速，提高动画性能。</p> 
<p><strong>8. 压缩动画资源：</strong> 对于使用视频或大型图片的动画，可以压缩资源来减小文件大小，提高加载速度。</p> 
<p><strong>9. 使用虚拟DOM：</strong> 在使用前端框架时，可以使用虚拟DOM来优化页面更新过程，最小化DOM操作，减少重绘次数。</p> 
<p><strong>10. 避免动画阻塞主线程：</strong> 如果动画执行时间较长，可以将动画放在Web Worker中执行，避免阻塞主线程。</p> 
<p>综合运用上述方法，可以优化动画效果，提高页面性能，让用户体验更加流畅和舒适。在进行动画开发时，需要注意性能问题，并根据具体情况采取相应的优化措施。</p> 
<h2>
<a id="7_documentFragment__DOM__134"></a><strong>7. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？</strong>
</h2> 
<p><code>DocumentFragment</code>是DOM中的一个接口，它表示一个轻量级的文档片段。它可以包含多个节点，类似于一个虚拟的文档容器，但不会直接插入到页面中，不会影响页面的回流和重绘。</p> 
<p>使用<code>DocumentFragment</code>可以实现高效的DOM操作，特别是在需要频繁插入多个DOM节点的情况下，可以显著提高性能。</p> 
<p>区别：</p> 
<ol>
<li> <p><strong>性能：</strong> 直接操作DOM节点会导致页面的回流和重绘，而<code>DocumentFragment</code>不会直接插入到页面中，可以避免这些性能问题。</p> </li>
<li> <p><strong>插入次数：</strong> 直接操作DOM节点每次插入都会触发页面的回流和重绘，而<code>DocumentFragment</code>可以将多个节点一次性插入到页面中，减少了插入的次数，提高了性能。</p> </li>
<li> <p><strong>代码简洁性：</strong> 使用<code>DocumentFragment</code>可以将多个DOM操作合并成一次，使代码更加简洁和易于维护。</p> </li>
</ol> 
<p>使用<code>DocumentFragment</code>的示例代码如下：</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 直接操作DOM节点</span>
<span class="token keyword">function</span> <span class="token function">insertNodesDirectly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> parent <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'parent'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'Node '</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>
    parent<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用DocumentFragment</span>
<span class="token keyword">function</span> <span class="token function">insertNodesWithFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> parent <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'parent'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'Node '</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>
    fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  parent<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的例子中，<code>insertNodesDirectly</code>函数每次循环都直接插入一个节点到页面中，会触发1000次回流和重绘。而<code>insertNodesWithFragment</code>函数使用了<code>DocumentFragment</code>，将所有节点一次性插入到页面中，只触发一次回流和重绘，性能明显更好。</p> 
<h2>
<a id="8__179"></a><strong>8. 对节流与防抖的理解</strong>
</h2> 
<p>节流（Throttle）和防抖（Debounce）都是用来优化函数执行频率的技术，特别在处理一些频繁触发的事件（如滚动、拖拽、窗口大小调整等）时非常有用。</p> 
<p><strong>节流（Throttle）：</strong><br> 节流是指在一定时间间隔内只执行一次函数。当事件频繁触发时，节流会让函数在每个时间间隔内只执行一次，不会被高频率的触发事件影响。</p> 
<p>实现节流的方式有多种，其中一种比较简单的实现方式是使用<code>setTimeout</code>延时执行函数。具体步骤如下：</p> 
<ol>
<li>在事件触发时设置一个定时器，延时执行函数。</li>
<li>如果在定时器的等待时间内，事件再次触发，清除之前的定时器，重新设置新的定时器。</li>
</ol> 
<p><strong>防抖（Debounce）：</strong><br> 防抖是指当事件频繁触发时，在规定时间间隔内，只执行最后一次触发的事件。如果在规定时间间隔内再次触发事件，则会重新计时。</p> 
<p>防抖的实现方式也有多种，其中一种简单的实现方式是使用<code>setTimeout</code>和<code>clearTimeout</code>来延时执行函数。具体步骤如下：</p> 
<ol>
<li>在事件触发时设置一个定时器。</li>
<li>如果在定时器的等待时间内再次触发事件，清除之前的定时器，重新设置新的定时器。</li>
</ol> 
<p><strong>应用场景：</strong><br> 节流适用于在频繁触发的事件中，需要在固定的时间间隔内处理，比如窗口调整大小、滚动事件。</p> 
<p>防抖适用于在频繁触发的事件中，只需要处理最后一次触发的事件，比如搜索框输入、按钮点击等，可以防止重复提交或者频繁请求。</p> 
<p>综上所述，节流和防抖都是优化事件处理的方法，通过合理地控制函数执行的频率，提高页面性能和用户体验。选择使用哪种方法取决于具体的场景和需求。</p> 
<h2>
<a id="9__206"></a><strong>9. 实现节流函数和防抖函数</strong>
</h2> 
<p>实现节流函数和防抖函数可以通过闭包和定时器来实现。下面分别给出节流函数和防抖函数的实现代码：</p> 
<p><strong>节流函数的实现：</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime <span class="token operator">&gt;=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      lastTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例用法</span>
<span class="token keyword">function</span> <span class="token function">handleScroll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Scroll event is throttled.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span>handleScroll<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>防抖函数的实现：</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> timer<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例用法</span>
<span class="token keyword">function</span> <span class="token function">handleInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Input event is debounced.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> debouncedInputHandler <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span>handleInput<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'searchInput'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> debouncedInputHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在节流函数中，通过比较当前时间和上次执行函数的时间来控制函数执行的频率，在规定的时间间隔内只会执行一次。</p> 
<p>在防抖函数中，通过设置一个定时器，在规定的时间间隔内如果再次触发事件，则会重新设置定时器，直到规定时间间隔内没有再次触发事件，然后执行函数。</p> 
<p>使用这两个函数可以有效地优化频繁触发的事件，提高页面性能和用户体验。</p> 
<h2>
<a id="10__260"></a><strong>10. 如何对项目中的图片进行优化？</strong>
</h2> 
<p>对项目中的图片进行优化是提高网页性能的重要一环。优化图片可以减小页面加载时间，减少网络带宽消耗，提升用户体验。以下是对项目中图片进行优化的一些常见方法：</p> 
<ol>
<li> <p><strong>选择合适的图片格式：</strong> 根据图片的特点选择合适的格式。一般情况下，JPEG 格式适用于照片和复杂图像，PNG 格式适用于透明背景的图像，而 GIF 格式适用于简单动画。</p> </li>
<li> <p><strong>压缩图片：</strong> 使用压缩工具（如 TinyPNG、ImageOptim）对图片进行压缩，减小图片文件的大小，但要注意保持图片质量不至于过度压缩导致失真。</p> </li>
<li> <p><strong>使用雪碧图：</strong> 将多个小图标合并成一个雪碧图，减少 HTTP 请求次数，优化加载速度。</p> </li>
<li> <p><strong>使用响应式图片：</strong> 对于不同尺寸的设备，使用适应不同屏幕大小的图片，可以节省带宽并提高加载速度。</p> </li>
<li> <p><strong>懒加载：</strong> 对于页面上需要滚动才能看到的图片，可以使用懒加载技术，延迟加载图片，节省初次加载时的流量。</p> </li>
<li> <p><strong>使用 WebP 格式：</strong> WebP 是一种支持有损和无损压缩的图片格式，它比 JPEG 和 PNG 格式更高效，可以显著减小图片文件大小。</p> </li>
<li> <p><strong>CDN 加速：</strong> 使用内容分发网络（CDN）来加速图片的加载，将图片缓存在全球各地的服务器上，减少加载时间。</p> </li>
<li> <p><strong>适当的尺寸：</strong> 使用合适的图片尺寸，不要在网页上显示超过实际需要的图片大小。</p> </li>
<li> <p><strong>图片懒加载：</strong> 对于长页面或有大量图片的页面，可以使用图片懒加载技术，只在图片进入可视区域时加载图片，而不是一次性加载全部图片。</p> </li>
</ol> 
<p>综合使用这些优化方法，可以有效地减小图片文件大小，提高网页加载速度，优化用户体验。在开发过程中，要注意图片的优化，并定期检查和更新优化措施，以确保网页性能保持在一个良好的水平。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>