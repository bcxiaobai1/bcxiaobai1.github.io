<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>c# 正则表达式 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c# 正则表达式</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p><strong>正则表达式</strong> 是一种匹配输入文本的模式。.Net 框架提供了允许这种匹配的正则表达式引擎。模式由一个或多个字符、运算符和结构组成。</p> 
<h3 id="%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">定义正则表达式</h3> 
<p>下面列出了用于定义正则表达式的各种类别的字符、运算符和结构。</p> 
<ul>
<li>字符转义</li>
<li>字符类</li>
<li>定位点</li>
<li>分组构造</li>
<li>限定符</li>
<li>反向引用构造</li>
<li>备用构造</li>
<li>替换</li>
<li>杂项构造</li>
</ul> 
<h4 id="%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B9%89">字符转义</h4> 
<p>正则表达式中的反斜杠字符（）指示其后跟的字符是特殊字符，或应按原义解释该字符。</p> 
<p>下表列出了转义字符：</p> 
<table>
<thead><tr>
<th> <p>转义字符</p> </th>
<th> <p>描述</p> </th>
<th> <p>模式</p> </th>
<th> <p>匹配</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p>a</p> </td>
<td> <p>与报警 (bell) 符 u0007 匹配。</p> </td>
<td> <p>a</p> </td>
<td> <p>"Warning!" + 'u0007' 中的 "u0007"</p> </td>
</tr>
<tr>
<td> <p>b</p> </td>
<td> <p>在字符类中，与退格键 u0008 匹配。</p> </td>
<td> <p>[b]{3,}</p> </td>
<td> <p>"bbbb" 中的 "bbbb"</p> </td>
</tr>
<tr>
<td> <p>t</p> </td>
<td> <p>与制表符 u0009 匹配。</p> </td>
<td> <p>(w+)t</p> </td>
<td> <p>"NametAddrt" 中的 "Namet" 和 "Addrt"</p> </td>
</tr>
<tr>
<td> <p>r</p> </td>
<td> <p>与回车符 u000D 匹配。（r 与换行符 n 不是等效的。）</p> </td>
<td> <p>rn(w+)</p> </td>
<td> <p>"rHellonWorld." 中的 "rnHello"</p> </td>
</tr>
<tr>
<td> <p>v</p> </td>
<td> <p>与垂直制表符 u000B 匹配。</p> </td>
<td> <p>[v]{2,}</p> </td>
<td> <p>"vvv" 中的 "vvv"</p> </td>
</tr>
<tr>
<td> <p>f</p> </td>
<td> <p>与换页符 u000C 匹配。</p> </td>
<td> <p>[f]{2,}</p> </td>
<td> <p>"fff" 中的 "fff"</p> </td>
</tr>
<tr>
<td> <p>n</p> </td>
<td> <p>与换行符 u000A 匹配。</p> </td>
<td> <p>rn(w+)</p> </td>
<td> <p>"rHellonWorld." 中的 "rnHello"</p> </td>
</tr>
<tr>
<td> <p>e</p> </td>
<td> <p>与转义符 u001B 匹配。</p> </td>
<td> <p>e</p> </td>
<td> <p>"x001B" 中的 "x001B"</p> </td>
</tr>
<tr>
<td> <p> nnn</p> </td>
<td> <p>使用八进制表示形式指定一个字符（nnn 由二到三位数字组成）。</p> </td>
<td> <p>w40w</p> </td>
<td> <p>"a bc d" 中的 "a b" 和 "c d"</p> </td>
</tr>
<tr>
<td> <p>x nn</p> </td>
<td> <p>使用十六进制表示形式指定字符（nn 恰好由两位数字组成）。</p> </td>
<td> <p>wx20w</p> </td>
<td> <p>"a bc d" 中的 "a b" 和 "c d"</p> </td>
</tr>
<tr>
<td> <p>c X c x</p> </td>
<td> <p>匹配 X 或 x 指定的 ASCII 控件字符，其中 X 或 x 是控件字符的字母。</p> </td>
<td> <p>cC</p> </td>
<td> <p>"x0003" 中的 "x0003" (Ctrl-C)</p> </td>
</tr>
<tr>
<td> <p>u nnnn</p> </td>
<td> <p>使用十六进制表示形式匹配一个 Unicode 字符（由 nnnn 表示的四位数）。</p> </td>
<td> <p>wu0020w</p> </td>
<td> <p>"a bc d" 中的 "a b" 和 "c d"</p> </td>
</tr>
<tr>
<td> <p></p> </td>
<td> <p>在后面带有不识别的转义字符时，与该字符匹配。</p> </td>
<td> <p>d+[+-x*]d+d+[+-x*d+</p> </td>
<td> <p>"(2+2) * 3*9" 中的 "2+2" 和 "3*9"</p> </td>
</tr>
</tbody>
</table> 
<h4 id="%E5%AD%97%E7%AC%A6%E7%B1%BB">字符类</h4> 
<p>字符类与一组字符中的任何一个字符匹配。</p> 
<p>下表列出了字符类：</p> 
<table>
<thead><tr>
<th> <p>字符类</p> </th>
<th> <p>描述</p> </th>
<th> <p>模式</p> </th>
<th> <p>匹配</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p>[character_group]</p> </td>
<td> <p>匹配 character_group 中的任何单个字符。 默认情况下，匹配区分大小写。</p> </td>
<td> <p>[mn]</p> </td>
<td> <p>"mat" 中的 "m"，"moon" 中的 "m" 和 "n"</p> </td>
</tr>
<tr>
<td> <p>[^character_group]</p> </td>
<td> <p>非：与不在 character_group 中的任何单个字符匹配。 默认情况下，character_group 中的字符区分大小写。</p> </td>
<td> <p>[^aei]</p> </td>
<td> <p>"avail" 中的 "v" 和 "l"</p> </td>
</tr>
<tr>
<td> <p>[ first - last ]</p> </td>
<td> <p>字符范围：与从 first 到 last 的范围中的任何单个字符匹配。</p> </td>
<td> <p>(w+)t</p> </td>
<td> <p>"NametAddrt" 中的 "Namet" 和 "Addrt"</p> </td>
</tr>
<tr>
<td> <p>.</p> </td>
<td> <p>通配符：与除 n 之外的任何单个字符匹配。 若要匹配原意句点字符（. 或 u002E），您必须在该字符前面加上转义符 (.)。</p> </td>
<td> <p>a.e</p> </td>
<td> <p>"have" 中的 "ave"， "mate" 中的 "ate"</p> </td>
</tr>
<tr>
<td> <p>p{ name }</p> </td>
<td> <p>与 name 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。</p> </td>
<td> <p>p{Lu}</p> </td>
<td> <p>"City Lights" 中的 "C" 和 "L"</p> </td>
</tr>
<tr>
<td> <p>P{ name }</p> </td>
<td> <p>与不在 name 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。</p> </td>
<td> <p>P{Lu}</p> </td>
<td> <p>"City" 中的 "i"、 "t" 和 "y"</p> </td>
</tr>
<tr>
<td> <p>w</p> </td>
<td> <p>与任何单词字符匹配。</p> </td>
<td> <p>w</p> </td>
<td> <p>"Room#1" 中的 "R"、 "o"、 "m" 和 "1"</p> </td>
</tr>
<tr>
<td> <p>W</p> </td>
<td> <p>与任何非单词字符匹配。</p> </td>
<td> <p>W</p> </td>
<td> <p>"Room#1" 中的 "#"</p> </td>
</tr>
<tr>
<td> <p>s</p> </td>
<td> <p>与任何空白字符匹配。</p> </td>
<td> <p>ws</p> </td>
<td> <p>"ID A1.3" 中的 "D "</p> </td>
</tr>
<tr>
<td> <p>S</p> </td>
<td> <p>与任何非空白字符匹配。</p> </td>
<td> <p>sS</p> </td>
<td> <p>"int __ctr" 中的 " _"</p> </td>
</tr>
<tr>
<td> <p>d</p> </td>
<td> <p>与任何十进制数字匹配。</p> </td>
<td> <p>d</p> </td>
<td> <p>"4 = IV" 中的 "4"</p> </td>
</tr>
<tr>
<td> <p>D</p> </td>
<td> <p>匹配不是十进制数的任意字符。</p> </td>
<td> <p>D</p> </td>
<td> <p>"4 = IV" 中的 " "、 "="、 " "、 "I" 和 "V"</p> </td>
</tr>
</tbody>
</table> 
<h4 id="%E5%AE%9A%E4%BD%8D%E7%82%B9">定位点</h4> 
<p>定位点或原子零宽度断言会使匹配成功或失败，具体取决于字符串中的当前位置，但它们不会使引擎在字符串中前进或使用字符。</p> 
<p>下表列出了定位点：</p> 
<table>
<thead><tr>
<th> <p>断言</p> </th>
<th> <p>描述</p> </th>
<th> <p>模式</p> </th>
<th> <p>匹配</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p>^</p> </td>
<td> <p>匹配必须从字符串或一行的开头开始。</p> </td>
<td> <p>^d{3}</p> </td>
<td> <p>"567-777-" 中的 "567"</p> </td>
</tr>
<tr>
<td> <p>$</p> </td>
<td> <p>匹配必须出现在字符串的末尾或出现在行或字符串末尾的 n 之前。</p> </td>
<td> <p>-d{4}$</p> </td>
<td> <p>"8-12-2012" 中的 "-2012"</p> </td>
</tr>
<tr>
<td> <p>A</p> </td>
<td> <p>匹配必须出现在字符串的开头。</p> </td>
<td> <p>Aw{4}</p> </td>
<td> <p>"Code-007-" 中的 "Code"</p> </td>
</tr>
<tr>
<td> <p>Z</p> </td>
<td> <p>匹配必须出现在字符串的末尾或出现在字符串末尾的n 之前。</p> </td>
<td> <p>-d{3}Z</p> </td>
<td> <p>"Bond-901-007" 中的 "-007"</p> </td>
</tr>
<tr>
<td> <p>z</p> </td>
<td> <p>匹配必须出现在字符串的末尾。</p> </td>
<td> <p>-d{3}z</p> </td>
<td> <p>"-901-333" 中的 "-333"</p> </td>
</tr>
<tr>
<td> <p>G</p> </td>
<td> <p>匹配必须出现在上一个匹配结束的地方。</p> </td>
<td> <p>\G(d)</p> </td>
<td> <p>"(1)(3)(5)[7](9)" 中的 "(1)"、 "(3)" 和 "(5)"</p> </td>
</tr>
<tr>
<td> <p>b</p> </td>
<td> <p>匹配必须出现在 w（字母数字）和 W（非字母数字）字符之间的边界上。</p> </td>
<td> <p>w</p> </td>
<td> <p>"Room#1" 中的 "R"、 "o"、 "m" 和 "1"</p> </td>
</tr>
<tr>
<td> <p>B</p> </td>
<td> <p>匹配不得出现在 b 边界上。</p> </td>
<td> <p>Bendw*b</p> </td>
<td> <p>"end sends endure lender" 中的 "ends" 和 "ender"</p> </td>
</tr>
</tbody>
</table> 
<h4 id="%E5%88%86%E7%BB%84%E6%9E%84%E9%80%A0">分组构造</h4> 
<p>分组构造描述了正则表达式的子表达式，通常用于捕获输入字符串的子字符串。</p> 
<p>下表列出了分组构造：</p> 
<table>
<thead><tr>
<th> <p>分组构造</p> </th>
<th> <p>描述</p> </th>
<th> <p>模式</p> </th>
<th> <p>匹配</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p>( subexpression )</p> </td>
<td> <p>捕获匹配的子表达式并将其分配到一个从零开始的序号中。</p> </td>
<td> <p>(w)1</p> </td>
<td> <p>"deep" 中的 "ee"</p> </td>
</tr>
<tr>
<td> <p>(?&lt; name &gt;subexpression)</p> </td>
<td> <p>将匹配的子表达式捕获到一个命名组中。</p> </td>
<td> <p>(?&lt; double&gt;w)k&lt; double&gt;</p> </td>
<td> <p>"deep" 中的 "ee"</p> </td>
</tr>
<tr>
<td> <p>(?&lt; name1 -name2 &gt;subexpression)</p> </td>
<td> <p>定义平衡组定义。</p> </td>
<td> <p>(((?'Open'()[^()]*)+((?'Close-Open'))[^()]*)+)*(?(Open)(?!))$</p> </td>
<td> <p>"3+2^((1-3)*(3-1))" 中的 "((1-3)*(3-1))"</p> </td>
</tr>
<tr>
<td> <p>(?: subexpression)</p> </td>
<td> <p>定义非捕获组。</p> </td>
<td> <p>Write(?:Line)?</p> </td>
<td> <p>"Console.WriteLine()" 中的 "WriteLine"</p> </td>
</tr>
<tr>
<td> <p>(?imnsx-imnsx:subexpression)</p> </td>
<td> <p>应用或禁用 subexpression 中指定的选项。</p> </td>
<td> <p>Ad{2}(?i:w+)b</p> </td>
<td> <p>"A12xl A12XL a12xl" 中的 "A12xl" 和 "A12XL"</p> </td>
</tr>
<tr>
<td> <p>(?= subexpression)</p> </td>
<td> <p>零宽度正预测先行断言。</p> </td>
<td> <p>w+(?=.)</p> </td>
<td> <p>"He is. The dog ran. The sun is out." 中的 "is"、 "ran" 和 "out"</p> </td>
</tr>
<tr>
<td> <p>(?! subexpression)</p> </td>
<td> <p>零宽度负预测先行断言。</p> </td>
<td> <p>b(?!un)w+b</p> </td>
<td> <p>"unsure sure unity used" 中的 "sure" 和 "used"</p> </td>
</tr>
<tr>
<td> <p>(?&lt; =subexpression)</p> </td>
<td> <p>零宽度正回顾后发断言。</p> </td>
<td> <p>(?&lt;=19)d{2}b</p> </td>
<td> <p>"1851 1999 1950 1905 2003" 中的 "99"、"50"和 "05"</p> </td>
</tr>
<tr>
<td> <p>(?&lt; ! subexpression)</p> </td>
<td> <p>零宽度负回顾后发断言。</p> </td>
<td> <p>(?&lt; !19)d{2}b</p> </td>
<td> <p>"end sends endure lender" 中的 "ends" 和 "ender"</p> </td>
</tr>
<tr>
<td> <p>(?&gt; subexpression)</p> </td>
<td> <p>非回溯（也称为"贪婪"）子表达式。</p> </td>
<td> <p>[13579](?&gt;A+B+)</p> </td>
<td> <p>"1ABB 3ABBC 5AB 5AC" 中的 "1ABB"、 "3ABB" 和 "5AB"</p> </td>
</tr>
</tbody>
</table> 
<h4 id="%E5%AE%9E%E4%BE%8B">实例</h4> 
<pre><code class="language-html">using System;
using System.Text.RegularExpressions;

public class Example
{
   public static void Main()
   {
      string input = "1851 1999 1950 1905 2003";
      string pattern = @"(?&lt;=19)d{2}b";

      foreach (Match match in Regex.Matches(input, pattern))
         Console.WriteLine(match.Value);
   }
}</code></pre> 
<p><a href="http://www.runoob.com/try/runcode.php?filename=regular_demo&amp;type=cs" title="运行实例 »">运行实例 »</a></p> 
<h4 id="%E9%99%90%E5%AE%9A%E7%AC%A6">限定符</h4> 
<p>限定符指定在输入字符串中必须存在上一个元素（可以是字符、组或字符类）的多少个实例才能出现匹配项。 限定符包括下表中列出的语言元素。</p> 
<p>下表列出了限定符：</p> 
<table>
<thead><tr>
<th> <p>限定符</p> </th>
<th> <p>描述</p> </th>
<th> <p>模式</p> </th>
<th> <p>匹配</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p>*</p> </td>
<td> <p>匹配上一个元素零次或多次。</p> </td>
<td> <p>d*.d</p> </td>
<td> <p>".0"、 "19.9"、 "219.9"</p> </td>
</tr>
<tr>
<td> <p>+</p> </td>
<td> <p>匹配上一个元素一次或多次。</p> </td>
<td> <p>"be+"</p> </td>
<td> <p>"been" 中的 "bee"， "bent" 中的 "be"</p> </td>
</tr>
<tr>
<td> <p>?</p> </td>
<td> <p>匹配上一个元素零次或一次。</p> </td>
<td> <p>"rai?n"</p> </td>
<td> <p>"ran"、 "rain"</p> </td>
</tr>
<tr>
<td> <p>{ n }</p> </td>
<td> <p>匹配上一个元素恰好 n 次。</p> </td>
<td> <p>",d{3}"</p> </td>
<td> <p>"1,043.6" 中的 ",043"， "9,876,543,210" 中的 ",876"、 ",543" 和 ",210"</p> </td>
</tr>
<tr>
<td> <p>{ n ,}</p> </td>
<td> <p>匹配上一个元素至少 n 次。</p> </td>
<td> <p>"d{2,}"</p> </td>
<td> <p>"166"、 "29"、 "1930"</p> </td>
</tr>
<tr>
<td> <p>{ n , m }</p> </td>
<td> <p>匹配上一个元素至少 n 次，但不多于 m 次。</p> </td>
<td> <p>"d{3,5}"</p> </td>
<td> <p>"166"， "17668"， "193024" 中的 "19302"</p> </td>
</tr>
<tr>
<td> <p>*?</p> </td>
<td> <p>匹配上一个元素零次或多次，但次数尽可能少。</p> </td>
<td> <p>d*?.d</p> </td>
<td> <p>".0"、 "19.9"、 "219.9"</p> </td>
</tr>
<tr>
<td> <p>+?</p> </td>
<td> <p>匹配上一个元素一次或多次，但次数尽可能少。</p> </td>
<td> <p>"be+?"</p> </td>
<td> <p>"been" 中的 "be"， "bent" 中的 "be"</p> </td>
</tr>
<tr>
<td> <p>??</p> </td>
<td> <p>匹配上一个元素零次或一次，但次数尽可能少。</p> </td>
<td> <p>"rai??n"</p> </td>
<td> <p>"ran"、 "rain"</p> </td>
</tr>
<tr>
<td> <p>{ n }?</p> </td>
<td> <p>匹配前导元素恰好 n 次。</p> </td>
<td> <p>",d{3}?"</p> </td>
<td> <p>"1,043.6" 中的 ",043"， "9,876,543,210" 中的 ",876"、 ",543" 和 ",210"</p> </td>
</tr>
<tr>
<td> <p>{ n ,}?</p> </td>
<td> <p>匹配上一个元素至少 n 次，但次数尽可能少。</p> </td>
<td> <p>"d{2,}?"</p> </td>
<td> <p>"166"、 "29" 和 "1930"</p> </td>
</tr>
<tr>
<td> <p>{ n , m }?</p> </td>
<td> <p>匹配上一个元素的次数介于 n 和 m 之间，但次数尽可能少。</p> </td>
<td> <p>"d{3,5}?"</p> </td>
<td> <p>"166"， "17668"， "193024" 中的 "193" 和 "024"</p> </td>
</tr>
</tbody>
</table> 
<h4 id="%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0">反向引用构造</h4> 
<p>反向引用允许在同一正则表达式中随后标识以前匹配的子表达式。</p> 
<p>下表列出了反向引用构造：</p> 
<table>
<thead><tr>
<th> <p>反向引用构造</p> </th>
<th> <p>描述</p> </th>
<th> <p>模式</p> </th>
<th> <p>匹配</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p> number</p> </td>
<td> <p>反向引用。 匹配编号子表达式的值。</p> </td>
<td> <p>(w)1</p> </td>
<td> <p>"seek" 中的 "ee"</p> </td>
</tr>
<tr>
<td> <p>k&lt; name &gt;</p> </td>
<td> <p>命名反向引用。 匹配命名表达式的值。</p> </td>
<td> <p>(?&lt; char&gt;w)k&lt; char&gt;</p> </td>
<td> <p>"seek" 中的 "ee"</p> </td>
</tr>
</tbody>
</table> 
<h4 id="%E5%A4%87%E7%94%A8%E6%9E%84%E9%80%A0">备用构造</h4> 
<p>备用构造用于修改正则表达式以启用 either/or 匹配。</p> 
<p>下表列出了备用构造：</p> 
<table>
<thead><tr>
<th> <p>备用构造</p> </th>
<th> <p>描述</p> </th>
<th> <p>模式</p> </th>
<th> <p>匹配</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p>|</p> </td>
<td> <p>匹配以竖线 (|) 字符分隔的任何一个元素。</p> </td>
<td> <p>th(e|is|at)</p> </td>
<td> <p>"this is the day. " 中的 "the" 和 "this"</p> </td>
</tr>
<tr>
<td> <p>(?( expression )yes | no )</p> </td>
<td> <p>如果正则表达式模式由 expression 匹配指定，则匹配 yes；否则匹配可选的no 部分。 expression 被解释为零宽度断言。</p> </td>
<td> <p>(?(A)Ad{2}b|bd{3}b)</p> </td>
<td> <p>"A10 C103 910" 中的 "A10" 和 "910"</p> </td>
</tr>
<tr>
<td> <p>(?( name )yes | no )</p> </td>
<td> <p>如果 name 或已命名或已编号的捕获组具有匹配，则匹配 yes；否则匹配可选的 no。</p> </td>
<td> <p>(?&lt; quoted&gt;")?(?(quoted).+?"|S+s)</p> </td>
<td> <p>"Dogs.jpg "Yiska playing.jpg"" 中的 Dogs.jpg 和 "Yiska playing.jpg"</p> </td>
</tr>
</tbody>
</table> 
<h4 id="%E6%9B%BF%E6%8D%A2">替换</h4> 
<p>替换是替换模式中使用的正则表达式。</p> 
<p>下表列出了用于替换的字符：</p> 
<table>
<thead><tr>
<th> <p>字符</p> </th>
<th> <p>描述</p> </th>
<th> <p>模式</p> </th>
<th> <p>替换模式</p> </th>
<th> <p>输入字符串</p> </th>
<th> <p>结果字符串</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p>$number</p> </td>
<td> <p>替换按组 number 匹配的子字符串。</p> </td>
<td> <p>b(w+)(s)(w+)b</p> </td>
<td> <p>$3$2$1</p> </td>
<td> <p>"one two"</p> </td>
<td> <p>"two one"</p> </td>
</tr>
<tr>
<td> <p>${name}</p> </td>
<td> <p>替换按命名组 name 匹配的子字符串。</p> </td>
<td> <p>b(?&lt; word1&gt;w+)(s)(?&lt; word2&gt;w+)b</p> </td>
<td> <p>${word2} ${word1}</p> </td>
<td> <p>"one two"</p> </td>
<td> <p>"two one"</p> </td>
</tr>
<tr>
<td> <p>$$</p> </td>
<td> <p>替换字符"$"。</p> </td>
<td> <p>b(d+)s?USD</p> </td>
<td> <p>$$$1</p> </td>
<td> <p>"103 USD"</p> </td>
<td> <p>"$103"</p> </td>
</tr>
<tr>
<td> <p>$&amp;</p> </td>
<td> <p>替换整个匹配项的一个副本。</p> </td>
<td> <p>($*(d*(.+d+)?){1})</p> </td>
<td> <p>**$&amp;</p> </td>
<td> <p>"$1.30"</p> </td>
<td> <p>"**$1.30**"</p> </td>
</tr>
<tr>
<td> <p>$`</p> </td>
<td> <p>替换匹配前的输入字符串的所有文本。</p> </td>
<td> <p>B+</p> </td>
<td> <p>$`</p> </td>
<td> <p>"AABBCC"</p> </td>
<td> <p>"AAAACC"</p> </td>
</tr>
<tr>
<td> <p>$'</p> </td>
<td> <p>替换匹配后的输入字符串的所有文本。</p> </td>
<td> <p>B+</p> </td>
<td> <p>$'</p> </td>
<td> <p>"AABBCC"</p> </td>
<td> <p>"AACCCC"</p> </td>
</tr>
<tr>
<td> <p>$+</p> </td>
<td> <p>替换最后捕获的组。</p> </td>
<td> <p>B+(C+)</p> </td>
<td> <p>$+</p> </td>
<td> <p>"AABBCCDD"</p> </td>
<td> <p>AACCDD</p> </td>
</tr>
<tr>
<td> <p>$_</p> </td>
<td> <p>替换整个输入字符串。</p> </td>
<td> <p>B+</p> </td>
<td> <p>$_</p> </td>
<td> <p>"AABBCC"</p> </td>
<td> <p>"AAAABBCCCC"</p> </td>
</tr>
</tbody>
</table> 
<h4 id="%E6%9D%82%E9%A1%B9%E6%9E%84%E9%80%A0">杂项构造</h4> 
<p>下表列出了各种杂项构造：</p> 
<table>
<thead><tr>
<th> <p>构造</p> </th>
<th> <p>描述</p> </th>
<th> <p>实例</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p>(?imnsx-imnsx)</p> </td>
<td> <p>在模式中间对诸如不区分大小写这样的选项进行设置或禁用。</p> </td>
<td> <p>bA(?i)bw+b 匹配 "ABA Able Act" 中的 "ABA" 和 "Able"</p> </td>
</tr>
<tr>
<td> <p>(?#注释)</p> </td>
<td> <p>内联注释。该注释在第一个右括号处终止。</p> </td>
<td> <p>bA(?#匹配以A开头的单词)w+b</p> </td>
</tr>
<tr>
<td> <p># [行尾]</p> </td>
<td> <p>该注释以非转义的 # 开头，并继续到行的结尾。</p> </td>
<td> <p>(?x)bAw+b#匹配以 A 开头的单词</p> </td>
</tr>
</tbody>
</table> 
<h3 id="Regex-%E7%B1%BB">Regex 类</h3> 
<p>Regex 类用于表示一个正则表达式。</p> 
<p>下表列出了 Regex 类中一些常用的方法：</p> 
<table>
<thead><tr>
<th> <p>序号</p> </th>
<th> <p>方法 &amp; 描述</p> </th>
</tr></thead>
<tbody>
<tr>
<td> <p>1</p> </td>
<td> <p>public bool IsMatch( string input ) 指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项。</p> </td>
</tr>
<tr>
<td> <p>2</p> </td>
<td> <p>public bool IsMatch( string input, int startat ) 指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项，从字符串中指定的开始位置开始。</p> </td>
</tr>
<tr>
<td> <p>3</p> </td>
<td> <p>public static bool IsMatch( string input, string pattern ) 指示指定的正则表达式是否在指定的输入字符串中找到匹配项。</p> </td>
</tr>
<tr>
<td> <p>4</p> </td>
<td> <p>public MatchCollection Matches( string input ) 在指定的输入字符串中搜索正则表达式的所有匹配项。</p> </td>
</tr>
<tr>
<td> <p>5</p> </td>
<td> <p>public string Replace( string input, string replacement ) 在指定的输入字符串中，把所有匹配正则表达式模式的所有匹配的字符串替换为指定的替换字符串。</p> </td>
</tr>
<tr>
<td> <p>6</p> </td>
<td> <p>public string[] Split( string input ) 把输入字符串分割为子字符串数组，根据在 Regex 构造函数中指定的正则表达式模式定义的位置进行分割。</p> </td>
</tr>
</tbody>
</table> 
<p>如需了解 Regex 类的完整的属性列表，请参阅微软的 C# 文档。</p> 
<h3 id="%E5%AE%9E%E4%BE%8B-1">实例 1</h3> 
<p>下面的实例匹配了以 'S' 开头的单词：</p> 
<pre><code class="language-html">using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      private static void showMatch(string text, string expr)
      {
         Console.WriteLine("The Expression: " + expr);
         MatchCollection mc = Regex.Matches(text, expr);
         foreach (Match m in mc)
         {
            Console.WriteLine(m);
         }
      }
      static void Main(string[] args)
      {
         string str = "A Thousand Splendid Suns";

         Console.WriteLine("Matching words that start with 'S': ");
         showMatch(str, @"bSS*");
         Console.ReadKey();
      }
   }
}</code></pre> 
<p>当上面的代码被编译和执行时，它会产生下列结果：</p> 
<pre><code class="language-html">Matching words that start with 'S':
The Expression: bSS*
Splendid
Suns</code></pre> 
<h3 id="%E5%AE%9E%E4%BE%8B-2">实例 2</h3> 
<p>下面的实例匹配了以 'm' 开头以 'e' 结尾的单词：</p> 
<pre><code class="language-html">using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      private static void showMatch(string text, string expr)
      {
         Console.WriteLine("The Expression: " + expr);
         MatchCollection mc = Regex.Matches(text, expr);
         foreach (Match m in mc)
         {
            Console.WriteLine(m);
         }
      }
      static void Main(string[] args)
      {
         string str = "make maze and manage to measure it";

         Console.WriteLine("Matching words start with 'm' and ends with 'e':");
         showMatch(str, @"bmS*eb");
         Console.ReadKey();
      }
   }
}</code></pre> 
<p>当上面的代码被编译和执行时，它会产生下列结果：</p> 
<pre><code class="language-html">Matching words start with 'm' and ends with 'e':
The Expression: bmS*eb
make
maze
manage
measure</code></pre> 
<h3 id="%E5%AE%9E%E4%BE%8B-3">实例 3</h3> 
<p>下面的实例替换掉多余的空格：</p> 
<pre><code class="language-html">using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      static void Main(string[] args)
      {
         string input = "Hello   World   ";
         string pattern = "\s+";
         string replacement = " ";
         Regex rgx = new Regex(pattern);
         string result = rgx.Replace(input, replacement);

         Console.WriteLine("Original String: {0}", input);
         Console.WriteLine("Replacement String: {0}", result);    
         Console.ReadKey();
      }
   }
}</code></pre> 
<p>当上面的代码被编译和执行时，它会产生下列结果：</p> 
<pre><code class="language-html">Original String: Hello   World   
Replacement String: Hello World   </code></pre> 
<pre><code class="language-html">转载：Jacob-wj 比较常用的几个正则表达式(匹配数字)</code></pre> 
<p>正则表达式用于字符串处理、表单验证等场合，实用高效。现将一些常用的表达式收集于此，以备不时之需。</p> 
<p>匹配中文字符的正则表达式： [u4e00-u9fa5]</p> 
<p>评注：匹配中文还真是个头疼的事，有了这个表达式就好办了</p> 
<p></p> 
<p>匹配双字节字符(包括汉字在内)：[^x00-xff]</p> 
<p>评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</p> 
<p></p> 
<p>匹配空白行的正则表达式：ns*r</p> 
<p>评注：可以用来删除空白行</p> 
<p></p> 
<p>匹配HTML标记的正则表达式：&lt;(S*?)[^&gt;]*&gt;.*?&lt;/1&gt;|&lt;.*? /&gt;</p> 
<p>评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力</p> 
<p></p> 
<p>匹配首尾空白字符的正则表达式：^s*|s*$</p> 
<p>评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式</p> 
<p></p> 
<p>匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*</p> 
<p>评注：表单验证时很实用</p> 
<p></p> 
<p>匹配网址URL的正则表达式：[a-zA-z]+://[^s]*</p> 
<p>评注：网上流传的版本功能很有限，上面这个基本可以满足需求</p> 
<p></p> 
<p>匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p> 
<p>评注：表单验证时很实用</p> 
<p></p> 
<p>匹配国内电话号码：d{3}-d{8}|d{4}-d{7}</p> 
<p>评注：匹配形式如 0511-4405222 或 021-87888822</p> 
<p></p> 
<p>匹配腾讯QQ号：[1-9][0-9]{4,}</p> 
<p>评注：腾讯QQ号从10000开始</p> 
<p></p> 
<p>匹配中国邮政编码：[1-9]d{5}(?!d)</p> 
<p>评注：中国邮政编码为6位数字</p> 
<p></p> 
<p>匹配身份证：d{15}|d{18}</p> 
<p>评注：中国的身份证为15位或18位</p> 
<p></p> 
<p>匹配ip地址：d+.d+.d+.d+</p> 
<p>评注：提取ip地址时有用</p> 
<p></p> 
<p>匹配特定数字：</p> 
<p>^[1-9]d*$　 　 //匹配正整数</p> 
<p>^-[1-9]d*$ 　 //匹配负整数</p> 
<p>^-?[1-9]d*$　　 //匹配整数</p> 
<p>^[1-9]d*|0$　 //匹配非负整数（正整数 + 0）</p> 
<p>^-[1-9]d*|0$　　 //匹配非正整数（负整数 + 0）</p> 
<p>^[1-9]d*.d*|0.d*[1-9]d*$　　 //匹配正浮点数</p> 
<p>^-([1-9]d*.d*|0.d*[1-9]d*)$　 //匹配负浮点数</p> 
<p>^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　 //匹配浮点数</p> 
<p>^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）</p> 
<p>^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）</p> 
<p>评注：处理大量数据时有用，具体应用时注意修正</p> 
<p></p> 
<p>匹配特定字符串：</p> 
<p>^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串</p> 
<p>^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串</p> 
<p>^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串</p> 
<p>^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串</p> 
<p>^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>