<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>《数据库系统概念》学习笔记——中级SQL - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《数据库系统概念》学习笔记——中级SQL</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>数据库系统概念——中级SQL</h3>
 <ul>
<li><a href="#SQL_2">中级SQL</a></li>
<li>
<ul>
<li><a href="#_5">连接表达式</a></li>
<li>
<ul>
<li><a href="#_13">连接条件</a></li>
<li><a href="#_53">外连接</a></li>
<li><a href="#_156">连接类型和条件</a></li>
</ul>
   </li>
<li><a href="#_179">视图</a></li>
<li>
<ul>
<li><a href="#_215">视图定义</a></li>
<li><a href="#SQL_258">SQL查询中使用视图</a></li>
<li><a href="#_315">物化视图</a></li>
<li><a href="#_341">视图更新</a></li>
</ul>
   </li>
<li><a href="#_409">事务</a></li>
<li><a href="#_438">完整性约束</a></li>
<li>
<ul>
<li><a href="#_459">单个关系上的约束</a></li>
<li><a href="#not_null__468">not null 约束</a></li>
<li><a href="#unique__481">unique 约束</a></li>
<li><a href="#check__492">check 子句</a></li>
<li><a href="#_516">参照完整性</a></li>
<li><a href="#_580">事务中对完整性约束的违反</a></li>
<li><a href="#_check__596">复杂 check 条件与断言</a></li>
</ul>
   </li>
<li><a href="#SQL_646">SQL的数据类型与模式</a></li>
<li>
<ul>
<li><a href="#SQL_648">SQL中的日期和时间类型</a></li>
<li><a href="#_684">默认值</a></li>
<li><a href="#_707">创建索引</a></li>
<li><a href="#_719">大对象类型</a></li>
<li><a href="#_734">用户定义的类型</a></li>
<li><a href="#create_table__803">create table 的扩展</a></li>
<li><a href="#_833">模式、目录与环境</a></li>
</ul>
   </li>
<li><a href="#_862">授权</a></li>
<li>
<ul>
<li><a href="#_879">权限的授予与收回</a></li>
<li><a href="#_935">角色</a></li>
<li><a href="#_974">视图的授权</a></li>
<li><a href="#_996">模式的授权</a></li>
<li><a href="#_1014">权限的转移</a></li>
<li><a href="#_1036">权限的收回</a></li>
</ul>
   </li>
<li><a href="#_1082">总结</a></li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<h1>
<a id="SQL_2"></a>中级SQL</h1> 
<h2>
<a id="_5"></a>连接表达式</h2> 
<p>SQL提供了连接运算的其他形式，包括能够指定显式的<strong>连接谓词</strong>（join predicate），能够在结果中包含被<strong>自然连接</strong>排除在外的元组。</p> 
<p>例子：student 和 takes 两个关系。</p> 
<p><img src="https://images2.imgbox.com/db/b9/YPCXutcB_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/ca/0a/hltECHc5_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="_13"></a>连接条件</h3> 
<p><strong>join…using</strong> 子句，它是一种自然连接的形式，只需要在指定属性上的取值匹配。</p> 
<p><strong>on</strong> 条件允许在参与连接的关系上设置通用的谓词。<br> 该谓词的写法与 where 子句谓词类似，只不过使用的是关键词 on 而不是 where。<br> 与 using 条件一样， on 条件出现在连接表达式的末尾。</p> 
<p>包含 on 条件的连接表达式：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> student <span class="token keyword">join</span> takes <span class="token keyword">on</span> student<span class="token punctuation">.</span>ID <span class="token operator">=</span> takes<span class="token punctuation">.</span>ID<span class="token punctuation">;</span>
</code></pre> 
<pre><code>上述 on 条件表明：如果一个来自 student 的元组和一个来自 takes 的元组在ID上的取值相同，那么它们是匹配的。
</code></pre> 
<p>等价于</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> student<span class="token punctuation">,</span> takes
<span class="token keyword">where</span> student<span class="token punctuation">.</span>ID <span class="token operator">=</span> takes<span class="token punctuation">.</span>ID<span class="token punctuation">;</span>
</code></pre> 
<p>只显示一次ID值的查询如下：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> student<span class="token punctuation">.</span>ID <span class="token keyword">as</span> ID<span class="token punctuation">,</span> name<span class="token punctuation">,</span> dept_name<span class="token punctuation">,</span> tot_cred<span class="token punctuation">,</span> 
	course_id<span class="token punctuation">,</span> sec_id<span class="token punctuation">,</span> semester<span class="token punctuation">,</span> <span class="token keyword">year</span><span class="token punctuation">,</span> grade
<span class="token keyword">from</span> student <span class="token keyword">join</span> takes <span class="token keyword">on</span> student<span class="token punctuation">.</span>ID <span class="token operator">=</span> takes<span class="token punctuation">.</span>ID<span class="token punctuation">;</span>
</code></pre> 
<p>查询结果如下：<br> <img src="https://images2.imgbox.com/1d/aa/GZQmwiYF_o.png" alt="在这里插入图片描述"><br> <strong>on</strong> 条件可以表示任何SQL谓词，从而使用on条件的连接表达式就可以表示比<strong>自然连接</strong>更为丰富的连接条件。</p> 
<ul>
<li>被称为外连接的这类连接来说，on条件的表现与where条件不同。</li>
<li>如在on子句中指定连接条件，并在where子句出现其余条件，这样更易读。</li>
</ul> 
<h3>
<a id="_53"></a>外连接</h3> 
<p>假设显示一个所有学生的列表，显示他们的ID，name，dept_name和tot_cred，及他们选修的课程。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> student <span class="token keyword">natural</span> <span class="token keyword">join</span> takes<span class="token punctuation">;</span>
</code></pre> 
<p><strong>外连接</strong>（outer join）运算与我们已经学过的连接运算类似，但通过在结果中创建包含空值元组的方式，保留了那些在连接中丢失的分组。</p> 
<p>上述例子在图1和图2的情形下，snow学生未选课将不会出现在natual join结果中。<br> 为保证snow出现在结果中，可在连接结果中加入一个元组，它在来自student关系的所有属性上的值被设置为学生snow的相应值。</p> 
<p>在所有余下的来自takes关系属性上的值被设为null。<br> 这些属性是course_id, sec_id, semester, year<br> 有三种外连接：</p> 
<ul>
<li>
<strong>左外连接</strong>（left outer join），只保留出现在左外连接运算之前(左边)的关系中的元组</li>
<li>
<strong>右外连接</strong>（right outer join），只保留出现在右外连接运算之后(右边)的关系中的元组。</li>
<li>
<strong>全外连接</strong>（full outer join），保留出现在两个关系中的元组。</li>
</ul> 
<p>此前学习的不保留未匹配元组的连接运算称为<strong>内连接</strong>（inner join）运算。</p> 
<p>计算左外连接运算：<br> 首先，计算出内连接的结果；<br> 然后，对内连接的左侧关系中任意一个与右侧关系中任何元组都不匹配的元组 t ，向连接结果中加入一个元组r。<br> r的构造如下：</p> 
<ul>
<li>元组r从左侧关系得到的属性被赋为t中的值</li>
<li>r的其他属性被赋为空值</li>
</ul> 
<pre><code class="prism language-sql"><span class="token comment">// 结果包含snow，在snow对应的元组中，在那些只出现在takes关系模式中的属性上取空值</span>
<span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> student <span class="token keyword">natural</span> <span class="token keyword">left</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> takes<span class="token punctuation">;</span>
</code></pre> 
<p>使用外连接运算的例子：</p> 
<pre><code class="prism language-sql"><span class="token comment">// 找出一门课程也没有选修的学生</span>
	<span class="token keyword">select</span> ID
	<span class="token keyword">from</span> student <span class="token keyword">natural</span> <span class="token keyword">left</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> takes
	<span class="token keyword">where</span> course id <span class="token operator">is</span> <span class="token boolean">null</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>右外连接</strong>和<strong>左外连接</strong>是对称的。</p> 
<p>等价的右外连接</p> 
<pre><code class="prism language-sql">	<span class="token keyword">select</span> <span class="token operator">*</span>
	<span class="token keyword">from</span> takes <span class="token keyword">natural</span> <span class="token keyword">right</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> student<span class="token punctuation">;</span>
</code></pre> 
<p>得到的结果是一样的，差别是元组中各个属性出现顺序不一致。</p> 
<p><strong>全外连接</strong>是左外连接与右外连接类型的组合。</p> 
<p>在内连接结果计算出来后，左侧关系中不匹配右侧关系任何元组的元组被添上空值并加到结果中。<br> 右侧关系中不匹配左侧关系任何元组的元组也被添上空值并加到结果中。</p> 
<p>全外连接的例子：<br> 查询 “显示Comp. Sci.系所有学生及他们在2009年春季选修的所有课程段的列表。2009年春季开设的所有课程段都必须显示，即使没有Comp. Sci.系的学生选修这些课程段 ”</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span>
	<span class="token comment">// 学生集合</span>
	  <span class="token keyword">from</span> student
	<span class="token comment">// 选出Comp. Sci系的</span>
	  <span class="token keyword">where</span> dept_name<span class="token operator">=</span> ’Comp<span class="token punctuation">.</span> Sci’<span class="token punctuation">)</span>
	<span class="token comment">// 全外连接</span>
	<span class="token keyword">natural</span> <span class="token keyword">full</span> <span class="token keyword">outer</span> <span class="token keyword">join</span>
	<span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span>
	<span class="token comment">// 选课信息</span>
	<span class="token keyword">from</span> takes
	<span class="token comment">// 选出2009,Spring的被选课程</span>
	<span class="token keyword">where</span> semester <span class="token operator">=</span> ’Spring’ <span class="token operator">and</span> <span class="token keyword">year</span> <span class="token operator">=</span> <span class="token number">2009</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>on 子句可以和外连接一起使用。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> student <span class="token keyword">left</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> takes <span class="token keyword">on</span> student<span class="token punctuation">.</span>ID <span class="token operator">=</span> takes<span class="token punctuation">.</span>ID<span class="token punctuation">;</span>
</code></pre> 
<p>on 和 where 在外连接中的表现是不同的。<br> 其原因是外连接只为那些对相应内连接结果没有贡献的元组补上空值并加入结果。<br> on 条件是外连接声明的一部分，但where子句却不是。</p> 
<p>把前述查询中的 on 子句谓词换成 where子句，并使用on条件 true：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> student <span class="token keyword">left</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> takes <span class="token keyword">on</span> <span class="token boolean">true</span>
<span class="token keyword">where</span> student<span class="token punctuation">.</span>ID <span class="token operator">=</span> takes<span class="token punctuation">.</span>ID<span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="_156"></a>连接类型和条件</h3> 
<p>SQL中把常规连接称作<strong>内连接</strong>。<br> 这样连接子句可用 <strong>inner join</strong> 来替换 <strong>outer join</strong> ，说明使用的是常规连接。<br> 关键词<strong>inner</strong>是可选，当 <strong>join</strong> 子句中没有使用 <strong>outer</strong> 前缀，默认的连接类型是 <strong>inner join</strong> 。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> student <span class="token keyword">join</span> takes <span class="token keyword">using</span> <span class="token punctuation">(</span>ID<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>等价于</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> student <span class="token keyword">inner</span> <span class="token keyword">join</span> takes <span class="token keyword">using</span> <span class="token punctuation">(</span>ID<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>类似地，<strong>natural join</strong> 等价于 <strong>natural inner join</strong> 。</p> 
<p><img src="https://images2.imgbox.com/6c/8d/TRVQRptB_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="_179"></a>视图</h2> 
<p>考虑一个职员需要知道教师的标识，姓名，所在系名，但没权限看到教师的工资值。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> ID<span class="token punctuation">,</span> name<span class="token punctuation">,</span> dept name
<span class="token keyword">from</span> instructor<span class="token punctuation">;</span>
</code></pre> 
<p>除了安全考虑，还可能希望创建一个比逻辑模型更符号特定用户直觉的个人化的关系集合。</p> 
<pre><code class="prism language-sql"><span class="token comment">// 希望有一个关于Physics系在2009秋季学期开设的所有课程段的列表</span>
<span class="token comment">// 包括每个课程段在那栋建筑，那个房间授课</span>
<span class="token keyword">select</span> course<span class="token punctuation">.</span>course_id<span class="token punctuation">,</span> sec_id<span class="token punctuation">,</span> building<span class="token punctuation">,</span> room_number
<span class="token comment">// 课程和开设课程笛卡尔积</span>
<span class="token keyword">from</span> course<span class="token punctuation">,</span> section
<span class="token comment">// 针对每个课程，</span>
<span class="token comment">// 此课程的每个开设信息，与课程结合形成一个结果元组</span>
<span class="token comment">// 结果元组满足物理系，2009，秋季，则被选入结果元组</span>
<span class="token keyword">where</span> course<span class="token punctuation">.</span>course_id <span class="token operator">=</span> section<span class="token punctuation">.</span>course_id
	<span class="token operator">and</span> course<span class="token punctuation">.</span>dept_name <span class="token operator">=</span> ’Physics’
	<span class="token operator">and</span> section<span class="token punctuation">.</span>semester <span class="token operator">=</span> ’Fall’
	<span class="token operator">and</span> section<span class="token punctuation">.</span><span class="token keyword">year</span> <span class="token operator">=</span> ’<span class="token number">2009</span>’<span class="token punctuation">;</span>
</code></pre> 
<p>可以获得上述查询的结果，将其存储下来，然后把存下关系提供给用户。</p> 
<p>SQL允许通过查询定义"虚关系"，它在概念上包含查询的结果。<br> 虚关系并不预先计算并存储，而是在使用虚关系的时候才通过执行查询被计算出来。</p> 
<p>任何像这种不是逻辑模型的一部分，但作为虚关系对用户可见的关系称为<strong>视图</strong>（view）。</p> 
<h3>
<a id="_215"></a>视图定义</h3> 
<p>在SQL中用<strong>create view</strong>定义视图。<br> 为定义试图，需给视图一个名称，需提供计算视图的查询。</p> 
<p><strong>create view</strong> 命令的格式为</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> v <span class="token keyword">as</span> <span class="token operator">&lt;</span>query expression<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中可以是任何合法的查询表达式，v表示试图名。</p> 
<p>重新考虑需访问instructor关系中除salary外的所有数据的职员。</p> 
<pre><code class="prism language-sql"><span class="token comment">// 可把视图关系faculty提供给职员</span>
<span class="token comment">// 此视图定义如下</span>
<span class="token keyword">create</span> <span class="token keyword">view</span> faculty <span class="token keyword">as</span>
<span class="token keyword">select</span> ID<span class="token punctuation">,</span> name<span class="token punctuation">,</span> dept_name
<span class="token keyword">from</span> instructor<span class="token punctuation">;</span>
</code></pre> 
<p>视图关系在概念上包含查询结果中的元组，但并不进行预计算和存储。</p> 
<p>数据库系统存储与视图关系相关联的查询表达式。</p> 
<p>视图关系被访问时，其中的元组通过计算查询结果创建出来的。<br> 视图关系是在需要时候创建的。</p> 
<pre><code class="prism language-sql"><span class="token comment">// 列出Physics系在2009，秋季开设的所有课程段</span>
<span class="token comment">// 每个课程段在哪栋建筑，哪个房间授课</span>
<span class="token keyword">create</span> view_physics_fall_2009 <span class="token keyword">as</span>
	<span class="token keyword">select</span> course<span class="token punctuation">.</span>course_id<span class="token punctuation">,</span> sec_id<span class="token punctuation">,</span> building<span class="token punctuation">,</span> room_number
	<span class="token keyword">from</span> course<span class="token punctuation">,</span> section
	<span class="token keyword">where</span> course<span class="token punctuation">.</span>course_id <span class="token operator">=</span> section<span class="token punctuation">.</span>course_id
		<span class="token operator">and</span> course<span class="token punctuation">.</span>dept_name <span class="token operator">=</span> ’Physics’
		<span class="token operator">and</span> section<span class="token punctuation">.</span>semester <span class="token operator">=</span> ’Fall’
		<span class="token operator">and</span> section<span class="token punctuation">.</span><span class="token keyword">year</span> <span class="token operator">=</span> ’<span class="token number">2009</span>’<span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="SQL_258"></a>SQL查询中使用视图</h3> 
<p>一旦定义了一个视图，就可以用视图名指代该视图生成的虚关系。</p> 
<p>使用视图physics_fall_2009，可用下面的查询找到所有于2009，秋季，在Watson大楼开设的Physics课程：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> course_id
<span class="token keyword">from</span> physics_fall_2009
<span class="token keyword">where</span> building<span class="token operator">=</span> ’Watson’<span class="token punctuation">;</span>
</code></pre> 
<p>在查询中，视图名可出现在关系名可出现的任何地方。</p> 
<p>视图的属性名可按下述方式显式指定：</p> 
<pre><code class="prism language-sql"><span class="token comment">// 给出了每个系中所有教师的工资总和</span>
<span class="token comment">// 显式指定视图各个属性名</span>
<span class="token keyword">create</span> <span class="token keyword">view</span> departments_total_salary<span class="token punctuation">(</span>dept_name<span class="token punctuation">,</span> total_salary<span class="token punctuation">)</span> <span class="token keyword">as</span>
	<span class="token keyword">select</span> dept_name<span class="token punctuation">,</span> <span class="token function">sum</span> <span class="token punctuation">(</span>salary<span class="token punctuation">)</span>
	<span class="token keyword">from</span> instructor
	<span class="token keyword">group</span> <span class="token keyword">by</span> dept_name<span class="token punctuation">;</span>
</code></pre> 
<p>直觉上，任何给定时刻，视图关系中的元组集是该时刻视图定义中的查询表达式的计算结果。</p> 
<p>如果一个视图关系被计算并存储，一旦用于定义该视图的关系被修改，视图就会过期。</p> 
<p>为避免这一点，视图常这样实现：<br> 定义一个视图时，数据库系统存储视图的定义本身，<br> 不存储该视图查询表达式的执行结果。</p> 
<p>无论何时执行查询，视图关系均被重新计算。</p> 
<p>一个视图可能被用到定义另一个视图的表达式中。</p> 
<p>如下定义视图physics_fall_2009_watson，</p> 
<pre><code class="prism language-sql"><span class="token comment">// 列出了于2009，秋季，在Watson大楼开设的所有Physics课程的标识和房间号</span>
<span class="token keyword">create</span> <span class="token keyword">view</span> physics_fall_2009_watson <span class="token keyword">as</span>
	<span class="token keyword">select</span> course_id<span class="token punctuation">,</span> room_number
	<span class="token keyword">from</span> physics_fall_2009
	<span class="token keyword">where</span> building<span class="token operator">=</span> ’Watson’<span class="token punctuation">;</span>
</code></pre> 
<p>等价于</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> physics_fall_2009_watson <span class="token keyword">as</span>
	<span class="token punctuation">(</span><span class="token keyword">select</span> course_id<span class="token punctuation">,</span> room_number
	<span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> course<span class="token punctuation">.</span>course_id<span class="token punctuation">,</span> building<span class="token punctuation">,</span> room_number
		  <span class="token keyword">from</span> course<span class="token punctuation">,</span> section
	      <span class="token keyword">where</span> course<span class="token punctuation">.</span>course_id <span class="token operator">=</span> section<span class="token punctuation">.</span>course_id
	      <span class="token operator">and</span> course<span class="token punctuation">.</span>dept name <span class="token operator">=</span> ’Physics’
	      <span class="token operator">and</span> section<span class="token punctuation">.</span>semester <span class="token operator">=</span> ’Fall’
	      <span class="token operator">and</span> section<span class="token punctuation">.</span><span class="token keyword">year</span> <span class="token operator">=</span> ’<span class="token number">2009</span>’<span class="token punctuation">)</span>
	<span class="token keyword">where</span> building<span class="token operator">=</span> ’Watson’<span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="_315"></a>物化视图</h3> 
<p>特定数据库允许存储视图关系，但它们保证：如用于定义视图的实际关系改变，视图也跟着修改。这样的视图称为<strong>物化视图</strong>（materialized view）。</p> 
<p>例：</p> 
<pre><code>考察视图departments_total_salary。
如上述视图是物化的，它的结果会存放在数据库中。
如果一个instructor元组被插入到instructor关系中，或从instructor关系中删除，
定义视图的查询结果就会变化，结果是物化视图的内容也必须更新。

类似地，如一位教师的工资被更新，departments_total_salary中对应于该教师所在系的元组必须更新
</code></pre> 
<p>保持物化视图一直在最新状态的过程称为<strong>物化视图维护</strong>（materialized view maintenance），或通常简称<strong>视图维护</strong>（view maintenance）。</p> 
<p>当构成视图定义的任何关系被更新时，可马上进行视图维护。<br> 然而，某些数据库系统在视图被访问时才执行视图维护。<br> 还有一些系统仅采用周期性物化视图更新方式。</p> 
<p>频繁使用视图的应用将会从视图的物化中获益。<br> 需要快速响应基于大关系上聚集计算的特定查询也会从创建与查询相对应的物化视图中受益良多。<br> 在这种情况下，聚集结果很可能比定义视图的大关系要小得多，其结果是利用物化视图来回答查询就很快，它避免读取大的底层关系。</p> 
<p>SQL没有定义指定物化视图的标准方式，但很多数据库系统提供各自的SQL扩展来实现这项任务。</p> 
<h3>
<a id="_341"></a>视图更新</h3> 
<p>用视图表达的数据库修改必须被翻译为对数据库逻辑模型中实际关系的修改。</p> 
<p>设此前的faculty被提供给一个职员。</p> 
<pre><code class="prism language-sql"><span class="token comment">// 该职员可这样写</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> faculty
	<span class="token keyword">values</span> <span class="token punctuation">(</span>’<span class="token number">30765</span>’<span class="token punctuation">,</span> ’Green’<span class="token punctuation">,</span> ’Music’<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这个插入必须表示为对instructor关系的插入，因为instructor是数据库系统用于构造图faculty的实际关系。<br> 然而，为把一个元组插入instructor，必须给出salary值。</p> 
<p>存在两种合理的解决方法来处理该插入：</p> 
<ul>
<li>拒绝插入，并向用户返回一个错误消息。</li>
<li>向instructor关系插入元组(‘30765’, ‘Green’, ‘Music’, null)。</li>
</ul> 
<p>通过视图修改数据库的另一类问题发生在这样的视图上</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> instructor_info <span class="token keyword">as</span>
<span class="token keyword">select</span> ID<span class="token punctuation">,</span> name<span class="token punctuation">,</span> building
	<span class="token comment">// 每个教员和每个建筑的组合</span>
<span class="token keyword">from</span> instructor<span class="token punctuation">,</span> department
<span class="token keyword">where</span> instructor<span class="token punctuation">.</span>dept_name<span class="token operator">=</span> department<span class="token punctuation">.</span>dept_name<span class="token punctuation">;</span>
</code></pre> 
<p>考虑如下通过该视图的插入：</p> 
<pre><code class="prism language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> instructor_info
<span class="token keyword">values</span> <span class="token punctuation">(</span>’<span class="token number">69987</span>’<span class="token punctuation">,</span> ’White’<span class="token punctuation">,</span> ’Taylor’<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code>假设没有标识为69987的教师，也没有位于Taylor大楼的系。
则向instructor和department关系插入元组的唯一可能的方法是：
向instructor中插入元组('69987', 'White', null, null)，
并向department中插入元组(null, 'Taylor', null)

但这个更新并没有产生所需的结果因为视图关系instructor_info中仍然不包含元组（'69987', 'White', 'Taylor'） 。
因此，通过空值来更新instructor和department关系，以得到对instructor_info所需的更新是不可行的。
</code></pre> 
<p>由于如上所述的种种问题，除了一些有限的情况外，<br> 一般不允许对视图关系进行修改。</p> 
<p>一般说来，如果定义视图的查询对下列条件都能满足，我们称SQL视图是<strong>可更新</strong>的（updatable）(即视图上可以执行插入，更新，删除)：</p> 
<ul>
<li>
<strong>from</strong> 子句中只有一个数据库关系</li>
<li>
<strong>select</strong> 子句中只包含关系的属性名，不包含任何表达式，聚集或distinct声明</li>
<li>任何没有出现在select子句中的属性可以取空值。即这些属性上没有not null约束，也不构成主码的一部分。</li>
<li>查询中不含有group by或having子句。</li>
</ul> 
<p>下面的视图上允许执行 <strong>update，insert，delete</strong> 操作：</p> 
<pre><code class="prism language-sql">	<span class="token keyword">create</span> <span class="token keyword">view</span> history instructors <span class="token keyword">as</span>
	<span class="token keyword">select</span> <span class="token operator">*</span>
	<span class="token keyword">from</span> instructor
	<span class="token keyword">where</span> dept name<span class="token operator">=</span> ’History’<span class="token punctuation">;</span>
</code></pre> 
<p>即使是在可更新的情况下，问题仍然存在。</p> 
<p>假设向上述视图添加非历史系教师，由于它不满足视图所要求的选择条件，它不会出现在视图history_instructors中。</p> 
<p>可以通过在视图定义的末尾包含 <strong>with check option</strong> 子句的方式来定义视图。</p> 
<h2>
<a id="_409"></a>事务</h2> 
<p><strong>事务</strong>（transaction）由查询和(或)更新语句的序列组成。<br> 一个SQL语句被执行，隐式地开始了一个事务。</p> 
<p>下列SQL语句之一会结束一个事务：</p> 
<ul>
<li>
<strong>Commit work:</strong> 提交当前事物，即将该事务所做的更新在数据库中持久保存。</li>
<li>
<strong>Rollback work:</strong> 回滚当前事务。即撤销该事务中所有SQL语句对数据库的更新。</li>
</ul> 
<p>一旦某事务执行了Commit work，它的影响就不能用rollback work来撤销了。<br> 数据库系统保证在发生诸如某条SQL语句错误、断电、系统崩溃这些故障的情况下，如一个事务还没有完成commit work，其影响将被回滚。<br> 在断电和系统崩溃的情况下，回滚会在系统重启后执行。</p> 
<p>例子：</p> 
<pre><code>假设student关系中每个元组在tot_cred属性上的取值需要保持在最新状态，
只要学生成功修完一门课，该属性值就更新。
如takes更新后，student更新时发生故障。数据库中数据就是不一致的。
</code></pre> 
<p>一个事务或者在完成所有步骤后提交其行为，或者在不能成功完成其所有动作的情况下回滚其所有动作,<br> 通过这种方式数据库提供了对事务具有<strong>原子性</strong>（atomic）的抽象，原子性也就是不可分割性。</p> 
<p>很多SQL实现中，默认方式下每个SQL语句自成一个事务，且一执行完就提交。</p> 
<p>SQL：1999 标准的一部分，允许多条SQL语句包含在关键字 <strong>begin atomic . . . end</strong>之间。<br> 所有在关键字之间的语句构成了一个单一事务。</p> 
<h2>
<a id="_438"></a>完整性约束</h2> 
<p>完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性。因此，完整性约束防止的是对数据的意外破坏。</p> 
<p>例：</p> 
<pre><code>- 教师姓名不能为null。
- 任意两位教师的教师标识不同。
- course 中每个系须在department关系中有一个对应的系名。
- 一个系的预算必须大于0.00 美元。
</code></pre> 
<p>完整性约束通常被看成是数据库模式设计过程的一部分，它作为用于创建关系 <strong>create table</strong> 命令的一部分被声明。</p> 
<p>完整性约束也可通过使用 <strong>alter table table-name add constraint</strong> 命令施加到已有关系上，其中 constraint 可以是关系上的任意约束。</p> 
<p>执行上述命令时，系统首先保证关系满足指定的约束。<br> 如果满足，那么约束被施加到关系上。否则，拒绝执行上述命令。</p> 
<h3>
<a id="_459"></a>单个关系上的约束</h3> 
<p><strong>create table</strong> 命令还可以包括完整性约束语句。<br> 允许的完整性约束包括：</p> 
<ul>
<li>not null</li>
<li>unique</li>
<li>check（&lt;谓词&gt;）</li>
</ul> 
<h3>
<a id="not_null__468"></a>not null 约束</h3> 
<p>通过限定属性name和budget的域来排除空值：</p> 
<pre><code class="prism language-sql">name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span>
budget <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span>
</code></pre> 
<p>not null 声明禁止在该属性上插入空值。</p> 
<p>SQL禁止在关系模式的主码中出现空值。</p> 
<h3>
<a id="unique__481"></a>unique 约束</h3> 
<p>SQL还支持下面这种完整性约束：</p> 
<pre><code class="prism language-sql"><span class="token keyword">unique</span> <span class="token punctuation">(</span>Aj1<span class="token punctuation">,</span> Aj2<span class="token punctuation">,</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">,</span> Ajm<span class="token punctuation">)</span>
</code></pre> 
<p>unique 指明Aj1, Aj2, . . . , Ajm形成了一个候选码；<br> 即在关系中没有两个元组能在所有列出的属性上取值相同。</p> 
<h3>
<a id="check__492"></a>check 子句</h3> 
<p>应用于关系声明时，<strong>check§</strong> 子句指定一个谓词Ｐ，关系中的每个谓词都必须满足谓词Ｐ。</p> 
<p>通常用 check 子句来保证属性值满足指定的条件，实际上创建了一个强大的类型系统。</p> 
<p>例：<br> 在创建department的create table命令中，check(budget&gt;0)保证budget取值是正数。</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> section
	<span class="token punctuation">(</span>course_id <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	sec_id <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	semester <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">year</span> <span class="token keyword">numeric</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	building <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	room_number <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	time_slot_id <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>course_id<span class="token punctuation">,</span> sec_id<span class="token punctuation">,</span> semester<span class="token punctuation">,</span> <span class="token keyword">year</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">check</span> <span class="token punctuation">(</span>semester <span class="token operator">in</span> <span class="token punctuation">(</span>’Fall’<span class="token punctuation">,</span> ’Winter’<span class="token punctuation">,</span> ’Spring’<span class="token punctuation">,</span> ’Summer’<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>根据SQL标准，check 子句中的谓词可以是包括子查询在内的任意谓词。</p> 
<h3>
<a id="_516"></a>参照完整性</h3> 
<p>我们常常希望保证在一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现。这称为<strong>参照完整性</strong>（referential integrity）。</p> 
<p>course 表的定义中有一个声明 “<strong>foreign key</strong> (dept_name) <strong>references</strong> department”。<br> 这个外码声明表示，在每个课程元组中指定的系名必须在 department 关系中存在 。</p> 
<p>更一般地，令关系r1和r2的属性集分别为R1和R2，主码分别为K1和Ｋ2。<br> 如要求对r2中任意元组 t2，均存在r1中元组t1使得t1.K1 = t2.a，我们称R2的子集<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        α
       
      
      
       alpha
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em;vertical-align: 0em"></span><span style="margin-right: 0.0037em" class="mord mathdefault">α</span></span></span></span></span>为参照关系r1中K1的<strong>外码</strong>（foreign key）。</p> 
<p>这种要求称为<strong>参照完整性约束</strong>（referential-intergrity constraint）或<strong>子集依赖</strong>（subset dependency）。</p> 
<p>r2中<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        α
       
      
      
       alpha
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em;vertical-align: 0em"></span><span style="margin-right: 0.0037em" class="mord mathdefault">α</span></span></span></span></span>上的取值集合必须是r1中k1上的取值集合的子集。<br> 为使参照完整性约束有意义，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        α
       
      
      
       alpha
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em;vertical-align: 0em"></span><span style="margin-right: 0.0037em" class="mord mathdefault">α</span></span></span></span></span>和K1必须是相容的属性集；<br> 也就是说，要么<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        α
       
      
      
       alpha
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em;vertical-align: 0em"></span><span style="margin-right: 0.0037em" class="mord mathdefault">α</span></span></span></span></span>等于K1，要么它们须包含相同数目的属性，并且对应的属性类型必须相容。</p> 
<p>不同于外码约束，参照完整性约束通常不要求K1是r1的主码；其结果是，r1中可能有不止一个元组在属性Ｋ1上取值相同。</p> 
<p>默认情况下，SQL中外码参照的是被参照表中的主码属性。<br> SQL还支持一个可显式指定被参照关系的属性列表的references子句。<br> 这个指定的属性列表必须被声明为被参照关系的候选码，要么使用primary key约束，要么使用 unique 约束。</p> 
<p>可用如下简写作为属性定义的一部分，且声明该属性为外码：</p> 
<pre><code class="prism language-sql">dept_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">references</span> department
</code></pre> 
<p>当违反参照完整性约束时，通常的处理是拒绝执行导致完整性破坏的操作（即执行更新操作的事务被回滚）。</p> 
<p>在foreign key子句中可指明：如被参照关系上的删除或更新动作违反了约束，那么系统需采取一些步骤通过修改参照关系中的元组来恢复完整性约束，而不是拒绝这样的动作。</p> 
<p>考虑在关系course上的如下完整性约束定义：<br> <img src="https://images2.imgbox.com/f9/1e/hgefNMz5_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> course
	<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	foreign_key <span class="token punctuation">(</span>dept_name<span class="token punctuation">)</span> <span class="token keyword">references</span> department
		<span class="token keyword">on</span> <span class="token keyword">delete</span> <span class="token keyword">cascade</span>
		<span class="token keyword">on</span> <span class="token keyword">update</span> <span class="token keyword">cascade</span><span class="token punctuation">,</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code>如删除 department 中的元组导致此参照完整性约束被违反，
由于有 on 语句，删除不被系统拒绝，而是对 course 关系作"级联"删除。
类似地，如果更新被参照字段时违反了约束，更新操作不被拒绝，
而是将 course 中参照的元组的 dept_name 字段也改为新值。

SQL还允许 foreign key 子句指明除了cascade 外的其他动作，如约束被违反：
可将参照域（这里为dept_name）设置为null（用set null 代替cascade），或设置为域的默认值（用set default）。
</code></pre> 
<p>如存在涉及多个关系的外码依赖链，则在链一端所做的删除或更新可能传至整个链。</p> 
<p>空值使得SQL中参照约束的语义复杂化了。<br> 外码中的属性允许为 null ，只要它们没有被声明为 not null。<br> 如果给定元组中外码的所有列上均取非空值，则对该元组采用外码约束的通常定义。<br> 如果某外码列为 null ，则该元组自动被认为满足约束。</p> 
<h3>
<a id="_580"></a>事务中对完整性约束的违反</h3> 
<p>事务可能包含几个步骤，在某一步之后完整性约束也许会暂时被违反。但是后面某一步也许就消除此违反。</p> 
<p>SQL标准允许将 <strong>initially deferred</strong> 子句加入到约束声明中。<br> 这样完整性约束不是在事务的中间步骤上检查，而是在事务结束时检查。</p> 
<p>一个约束可被指定为<strong>可延迟的</strong>（deferrable），这意味着默认情况下，它会被立即检查，但是在需要时，可以延迟检查。</p> 
<p>对声明为可延迟的约束，执行 <strong>set constraints constraint-list defered</strong> 语句作为事务的一部分，<br> 会导致对指定约束的检查被延迟到事务结束时执行。</p> 
<h3>
<a id="_check__596"></a>复杂 check 条件与断言</h3> 
<p>如果一个数据库支持在 check 子句中出现子查询，就可在关系 section 上声明如下所示的参照完整性约束：</p> 
<pre><code class="prism language-sql">heck <span class="token punctuation">(</span>time_slot_id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> time_slot_id <span class="token keyword">from</span> time_slot<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>这个 check 检测在 section 关系中每个元组的time_slot_id 的确是在time_slot 关系改变时也需要检测（如在 time_slot 关系中，当一个元组被删除或修改的情况下）。</p> 
<p>在我们大学模式上，另一个自然的约束是：每个课程段都至少需要一位教师来讲授。</p> 
<p>一种方案是声明section关系的属性集(course_id, sec_id, semester, year)作为外码，它参照了 teaches 关系中的相应属性。</p> 
<p>如数据库系统支持在 check 约束中出现子查询的话，可以使用与 time_slot 属性类似的 check 约束来强制实现上述约束。</p> 
<p>一个<strong>断言</strong>（assertion）就是一个谓词，它表达了我们希望数据库总能满足的一个条件。<br> 域约束和参照完整性约束是断言特殊形式。</p> 
<p>例子：</p> 
<ul>
<li>对student关系中的每个元组，它在属性tot_cred上的取值必须等于该生所成功修完课程的学分总和</li>
<li>每位教师不能在同一个学期的同一个时间段的两个不同的教室授课</li>
</ul> 
<p>SQL中断言的形式：</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> assertion <span class="token operator">&lt;</span>assertion<span class="token operator">-</span>name<span class="token operator">&gt;</span> <span class="token keyword">check</span> <span class="token operator">&lt;</span>predicate<span class="token operator">&gt;</span>
</code></pre> 
<p>用SQL写出第一个约束的示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> assertion credits_earned_constraint <span class="token keyword">check</span>
	<span class="token punctuation">(</span><span class="token operator">not</span> <span class="token keyword">exists</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ID
	 <span class="token keyword">from</span> student
	 <span class="token keyword">where</span> tot_cred <span class="token operator">&lt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">sum</span><span class="token punctuation">(</span>credits<span class="token punctuation">)</span>
						<span class="token keyword">from</span> takes <span class="token keyword">natural</span> <span class="token keyword">join</span> course
						<span class="token keyword">where</span> student<span class="token punctuation">.</span>ID<span class="token operator">=</span> takes<span class="token punctuation">.</span>ID
						<span class="token operator">and</span> grade <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token operator">and</span> grade<span class="token operator">&lt;&gt;</span> ’F’ <span class="token punctuation">)</span>
</code></pre> 
<p>当创建断言时，系统要检查其有效性。<br> 如果断言有效，则今后只有不破坏断言的数据库修改才被允许。如果断言较复杂，则检查会带来相当大的开销。因此，使用断言应该特别小心。</p> 
<p>目前，还没有一个广泛使用的数据库系统支持check子句的谓词中使用子查询或 <strong>create assertion</strong> 结构。</p> 
<h2>
<a id="SQL_646"></a>SQL的数据类型与模式</h2> 
<h3>
<a id="SQL_648"></a>SQL中的日期和时间类型</h3> 
<p>SQL标准支持与日期和时间相关的几种数据类型：</p> 
<ul>
<li>
<strong>date：</strong> 日历日期，包括年（四位），月，日</li>
<li>
<strong>time：</strong> 一天中的时间，包括小时，分，秒。<br> 可以用变量 time§来表示秒的小数点后的数字位数（这里默认值为0）。<br> 通过指定 <strong>time with timezone</strong> ，还可以把时区信息连同时间一起存储。</li>
<li>
<strong>timestamp:</strong> date 和 time 的组合。<br> 可以用变量 timestamp§来表示秒的小数点后的数字位数（这里默认值为6）。<br> 如果指定 <strong>with timezone</strong>，则时区信息也会被存储。</li>
</ul> 
<pre><code class="prism language-sql"><span class="token keyword">date</span> ’<span class="token number">2001</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">25</span>’
<span class="token keyword">time</span> ’<span class="token number">09</span>:<span class="token number">30</span>:<span class="token number">00</span>’
<span class="token keyword">timestamp</span> ’<span class="token number">2001</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">25</span> <span class="token number">10</span>:<span class="token number">29</span>:<span class="token number">01.45</span>’
</code></pre> 
<p>可用 <strong>cast e as t</strong> 形式的表达式来将一个字符串（或字符串表达式） e 转换为类型 t ,其中 t 是 <strong>date, time, timestamp</strong> 中的一种。</p> 
<p>可利用 <strong>extract(field from d)</strong>， 从 date 或 time 值 d中提取出单独的域，这里的域可以是 <strong>year、month、day、hour、minute</strong> 或者 <strong>second</strong> 中的任意一种。</p> 
<p>时区信息可用 <strong>timezone_hour</strong> 和 t<strong>imezone_minute</strong> 来提取。</p> 
<p>SQL定义了一些函数以获取当前日期和时间。<br> 例如：</p> 
<pre><code>current_date 返回当前日期
current_time 返回当前时间（带有时区）
localtime 返回当前的本地时间（不带时区）
时间戳【日期＋时间】由 current_timestamp 及 localtimestamp返回。
</code></pre> 
<p>SQL还支持 <strong>interval</strong> 类型，它允许在日期、时间和时间间隔上进行计算。</p> 
<h3>
<a id="_684"></a>默认值</h3> 
<p>SQL允许为属性指定默认值，如下：</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> student
	<span class="token punctuation">(</span>ID <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	name <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
	dept_name <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	tot_cred <span class="token keyword">numeric</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">,</span>
	<span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>ID<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>下面的插入语句说明了在插入操作中如何省略 tot_cred 属性的值：</p> 
<pre><code class="prism language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>ID<span class="token punctuation">,</span> name<span class="token punctuation">,</span> dept_name<span class="token punctuation">)</span>
	<span class="token keyword">values</span> <span class="token punctuation">(</span>’<span class="token number">12789</span>’<span class="token punctuation">,</span> ’Newman’<span class="token punctuation">,</span> ’Comp<span class="token punctuation">.</span> Sci<span class="token punctuation">.</span>’<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="_707"></a>创建索引</h3> 
<p>在关系的属性上所创建的<strong>索引</strong>（index）是一种数据结构，它允许数据库系统高效地找到关系中那些在索引属性上取给定值的元组，而不用扫描关系中的所有元组。</p> 
<p>很多数据库支持如下创建索引：</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">index</span> studentID_index <span class="token keyword">on</span> student<span class="token punctuation">(</span>ID<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>上述语句在 student 关系的属性 ID 上创建了一个名为 studentID_index 的索引。</p> 
<h3>
<a id="_719"></a>大对象类型</h3> 
<p>SQL提供字符数据的大对象数据类型（clob）和二进制数据的大对象数据类型（blob）。</p> 
<p>例如，可以声明属性：</p> 
<pre><code class="prism language-sql">book review clob<span class="token punctuation">(</span><span class="token number">10</span>KB<span class="token punctuation">)</span>
image <span class="token keyword">blob</span><span class="token punctuation">(</span><span class="token number">10</span>MB<span class="token punctuation">)</span>
movie <span class="token keyword">blob</span><span class="token punctuation">(</span><span class="token number">2</span>GB<span class="token punctuation">)</span>
</code></pre> 
<p>一个应用常用一个SQL查询来检索出一个大对象的"定位器"，然后在宿主语言中用这个定位器来操纵对象，应用本身也是用宿主语言书写的。</p> 
<h3>
<a id="_734"></a>用户定义的类型</h3> 
<p>SQL支持两种形式的用户定义数据类型。</p> 
<ul>
<li>
<strong>独特类型</strong>（distinct type）</li>
<li>
<strong>结构化数据类型</strong>（structured data type）<br> 允许创建具有嵌套记录结构、数组和多重集的复杂数据类型。</li>
</ul> 
<p>可以用 create typep 子句来定义新类型：</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">type</span> Dollars <span class="token keyword">as</span> <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> final<span class="token punctuation">;</span>
<span class="token keyword">create</span> <span class="token keyword">type</span> Pounds <span class="token keyword">as</span> <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> final<span class="token punctuation">;</span>
</code></pre> 
<p>可以把 department 表定义为：</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> department
	<span class="token punctuation">(</span>dept_name <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	building <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
budget Dollars<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>一种类型的数值可<strong>被转换</strong>（也即 cast）到另一个域：</p> 
<pre><code class="prism language-sql">cast <span class="token punctuation">(</span>department<span class="token punctuation">.</span>budget <span class="token keyword">to</span> <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>SQL提供了<strong>drop type</strong> 和 <strong>alter type</strong> 子句来删除或修改之前创建过的类型。</p> 
<p><strong>域</strong>（domain），它可以在基本类型上施加完整性约束。</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> domain DDollars <span class="token keyword">as</span> <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">;</span>
</code></pre> 
<p>DDollars 域可作为属性类型。<br> 类型和域之间两个大的差别：</p> 
<ul>
<li>在域上可以声明约束，例如 <strong>not null</strong> ，也可为域类型变量定义默认值，然而在用户定义类型上不能声明约束或默认值。</li>
<li>域并不是强类型的。因此一个域类型的值可以被赋给另一个域类型，只要它们的基本类型是相容的。</li>
</ul> 
<p>当把 check 子句应用到域上时，允许模式设计者指定一个谓词，被声明为来自该域的任何变量都必须满足这个谓词。</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> domain YearlySalary <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token keyword">constraint</span> salary_value_test <span class="token keyword">check</span><span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token operator">&gt;=</span> <span class="token number">29000.00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>作为另一个例子，使用 in 子句可以限定一个域只包含指定的一组值：</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> domain degree_level <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token keyword">constraint</span> degree_level_test
		<span class="token keyword">check</span> <span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'Bachelors'</span><span class="token punctuation">,</span> <span class="token string">'Masters'</span><span class="token punctuation">,</span> <span class="token operator">or</span> <span class="token string">'Doctorate'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="create_table__803"></a>create table 的扩展</h3> 
<p>创建与现有某个表的模式相同的表。<br> SQL提供了一个 create table like 的扩展来支持这项任务：</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> temp_instructor <span class="token operator">like</span> instructor<span class="token punctuation">;</span>
</code></pre> 
<p>当书写一个复杂查询时，把查询的结果存储成一个新表通常是很有用的；这个表通常是临时的。</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> t1 <span class="token keyword">as</span>
	<span class="token comment">// 新表所参照的表</span>
	<span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span>
	<span class="token keyword">from</span> instructor
	<span class="token keyword">where</span> dept_name<span class="token operator">=</span> ’Music’<span class="token punctuation">)</span>
<span class="token comment">// 表示新表使用前面表的数据初始化</span>
<span class="token keyword">with</span> <span class="token keyword">data</span><span class="token punctuation">;</span>
</code></pre> 
<p>create table… as 语句与 create view 语句非常相似，并且都用查询来定义。<br> 两者主要的区别在于当表被创建时表的内容被加载，但视图的内容总是反映当前查询的结果。</p> 
<h3>
<a id="_833"></a>模式、目录与环境</h3> 
<p>当代数据库系统提供了三层结构的关系命名机制。<br> 最顶层由<strong>目录</strong>（catalog）构成，每个目录都可包含<strong>模式</strong>（schema）。</p> 
<p>每个用户有一个默认的目录和模式，这个组合对用户来说是唯一的。</p> 
<p>要在数据库上做任何操作，用户（或程序）都必须先连接到数据库。</p> 
<p>为了唯一标识出一个关系，须使用一个名字，它包含三部分，例如：</p> 
<pre><code class="prism language-c"><span class="token comment">// 目录.模式.关系</span>
catalog5<span class="token punctuation">.</span>univ_schema<span class="token punctuation">.</span>course
</code></pre> 
<p>当名字的目录被认为是连接的默认目录时，可省略目录部分。</p> 
<p>如果一个关系存在于特定用户的默认模式中，那么连模式的名字也可以省略。<br> 如果catalog5是默认目录并且 univ_schema是默认模式，我们可以只用 course。</p> 
<p>当有多个目录和模式可用时，不同应用和不同用户可以独立工作而不必担心命名冲突。</p> 
<p>默认目录和模式是为每个连接建立的<strong>SQL环境</strong>（SQL environment）的一部分。</p> 
<p>可以用 create schema 和 drop schema 语句来创建和删除模式。</p> 
<h2>
<a id="_862"></a>授权</h2> 
<p>对数据的授权包括：</p> 
<ul>
<li>授权读取数据</li>
<li>授权插入新数据</li>
<li>授权更新数据</li>
<li>授权删除数据<br> 每种类型的授权都称为一个<strong>权限</strong>（privilege）。</li>
</ul> 
<p>除了在数据上授权之外，用户还可被授予在数据库模式上的权限，例如，可以允许用户创建、修改或删除关系。<br> 拥有某些形式的权限的用户还可以把这样的权限转授（授予）给其他用户，或者撤销（收回）一种此前授出的权限。</p> 
<p>最大的授权形式是被授予数据库管理员的。<br> 数据库管理员可以授权新用户、重构数据库，等等。</p> 
<h3>
<a id="_879"></a>权限的授予与收回</h3> 
<p>SQL标准包括<strong>select、insert、update、delete</strong>权限。<br> 权限所有权限（all privileges）可以用作所有允许权限的简写形式。<br> 一个创建了新关系的用户将自动被授予该关系上的所有权限。</p> 
<p>grant 语句用来授予权限。此语句的基本形式为：</p> 
<pre><code class="prism language-sql"><span class="token keyword">grant</span> <span class="token operator">&lt;</span>权限列表<span class="token operator">&gt;</span>
<span class="token keyword">on</span> <span class="token operator">&lt;</span>关系名或视图名<span class="token operator">&gt;</span>
<span class="token keyword">to</span> <span class="token operator">&lt;</span>用户<span class="token operator">/</span>角色列表<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre> 
<p>权限列表使得一个命令可以授予多个权限。</p> 
<p>关系上的 <strong>select</strong> 权限用于读取关系中的元组。</p> 
<pre><code class="prism language-sql"><span class="token keyword">grant</span> <span class="token keyword">select</span> <span class="token keyword">on</span> department <span class="token keyword">to</span> Amit<span class="token punctuation">,</span> Satoshi<span class="token punctuation">;</span>
</code></pre> 
<p>关系上的 <strong>update</strong> 权限允许用户修改关系中的任意元组。</p> 
<pre><code class="prism language-sql"><span class="token keyword">grant</span> <span class="token keyword">update</span> <span class="token punctuation">(</span>budget<span class="token punctuation">)</span> <span class="token keyword">on</span> department <span class="token keyword">to</span> Amit<span class="token punctuation">,</span> Satoshi<span class="token punctuation">;</span>
</code></pre> 
<p>关系上的 <strong>insert</strong> 权限允许用户往关系中插入元组。</p> 
<p>关系上的 <strong>delete</strong> 权限允许用户从关系中删除元组。</p> 
<p>用户名 <strong>public</strong> 指系统的所有当前和将来的用户。</p> 
<p>在默认情况下，被授予权限的用户/角色无权把此权限授予其他用户/角色。<br> SQL允许用授予权限，来指定权限的接受者可以进一步把权限授予其他用户。</p> 
<p>revoke语句来收回权限。</p> 
<pre><code class="prism language-sql"><span class="token keyword">revoke</span> <span class="token operator">&lt;</span>权限列表<span class="token operator">&gt;</span>
<span class="token keyword">on</span> <span class="token operator">&lt;</span>关系名或视图名<span class="token operator">&gt;</span>
<span class="token keyword">from</span> <span class="token operator">&lt;</span>用户<span class="token operator">/</span>角色列表<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre> 
<p>收回前面我们所授予的那些权限，我们书写下列语句：</p> 
<pre><code class="prism language-sql"><span class="token keyword">revoke</span> <span class="token keyword">select</span> <span class="token keyword">on</span> department <span class="token keyword">from</span> Amit<span class="token punctuation">,</span> Satoshi<span class="token punctuation">;</span>
<span class="token keyword">revoke</span> <span class="token keyword">update</span> <span class="token punctuation">(</span>budget<span class="token punctuation">)</span> <span class="token keyword">on</span> department <span class="token keyword">from</span> Amit<span class="token punctuation">,</span> Satoshi<span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="_935"></a>角色</h3> 
<p>在数据库中建立一个角色集，可以给角色授予权限，就和给每个用户授权的方式完全一样。</p> 
<p>任何可以授予给用户的权限都可以授予给角色。给用户授予角色就跟给用户授权一样。</p> 
<p>在SQL中创建角色如下所示：</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> role instructor<span class="token punctuation">;</span>
</code></pre> 
<p>基于角色授予权限</p> 
<pre><code class="prism language-sql"><span class="token keyword">grant</span> <span class="token keyword">select</span> <span class="token keyword">on</span> takes
<span class="token keyword">to</span> instructor<span class="token punctuation">;</span>
</code></pre> 
<p>角色可授予给用户，也可授予给其他角色</p> 
<pre><code class="prism language-sql"><span class="token keyword">grant</span> dean <span class="token keyword">to</span> Amit<span class="token punctuation">;</span>
<span class="token keyword">create</span> role dean<span class="token punctuation">;</span>
<span class="token keyword">grant</span> instructor <span class="token keyword">to</span> dean<span class="token punctuation">;</span>
<span class="token keyword">grant</span> dean <span class="token keyword">to</span> Satoshi<span class="token punctuation">;</span>
</code></pre> 
<p>一个用户或一个角色的权限包括：</p> 
<ul>
<li>所有直接授予用户/角色的权限</li>
<li>所有授予给用户/角色所拥有角色的权限</li>
</ul> 
<h3>
<a id="_974"></a>视图的授权</h3> 
<p>创建视图</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> geo_instructor <span class="token keyword">as</span>
	<span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span>
	<span class="token keyword">from</span> instructor
	<span class="token keyword">where</span> dept_name <span class="token operator">=</span> ’Geology’<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>实际select　instructor需要用户有此权限</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> geo_instructor<span class="token punctuation">;</span>
</code></pre> 
<p>创建视图的用户不需要获得该视图上的所有权限。</p> 
<h3>
<a id="_996"></a>模式的授权</h3> 
<p>SQL标准为数据库模式指定了一种基本的授权机制：<br> 只有模式的拥有者才能够执行对模式的任何修改，诸如创建或删除关系，增加或删除关系的属性，以及增加或删除索引。</p> 
<p>SQL提供了一种 <strong>references</strong> 权限，允许用户在创建关系时声明外码。</p> 
<p>SQL的 <strong>references</strong> 权限可以与 <strong>update</strong> 权限类似的方式授予到特定属性上。</p> 
<p>grant 允许Mariano创建，可参照department的码dept_name的关系：</p> 
<pre><code class="prism language-sql"><span class="token keyword">grant</span> <span class="token keyword">references</span> <span class="token punctuation">(</span>dept_name<span class="token punctuation">)</span> <span class="token keyword">on</span> department <span class="token keyword">to</span> Mariano<span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="_1014"></a>权限的转移</h3> 
<p>在默认方式下，被授予权限的用户/角色无权把得到的权限再授予另外的用户/角色。</p> 
<p>如果在授权时允许接受者把得到的权限再传递给其他用户，可在 <strong>grant</strong> 命令后附加 <strong>with grant option</strong> 子句。</p> 
<p>如果希望授予 Amit 在 department 上的 select 权限，且允许Amit将该授权授予其他用户，可以写：</p> 
<pre><code class="prism language-sql"><span class="token keyword">grant</span> <span class="token keyword">select</span> <span class="token keyword">on</span> department <span class="token keyword">to</span> Amit <span class="token keyword">with</span> <span class="token keyword">grant</span> <span class="token keyword">option</span><span class="token punctuation">;</span>
</code></pre> 
<p>一个对象（关系/视图/角色）的创建者拥有该对象上的所有权限，包括给其他用户授权的权限。</p> 
<p>例子：<br> 考虑大学数据库中 teaches 关系上更新权限的授予。<br> 假设最初数据库管理员将 teaches 上的更新权限授给用户U1、U2 和 U3，他们接下来又将这一授权传递给其他用户。</p> 
<p>指定权限从一个用户到另一个用户的传递可以表示为<strong>授权图</strong>（authorization graph）。</p> 
<p><img src="https://images2.imgbox.com/38/9d/8j9akHx5_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="_1036"></a>权限的收回</h3> 
<p>从一个用户/角色那里收回权限可能导致其他用户/角色也失去该权限。这一行为称作<strong>级联收回</strong>。</p> 
<p><strong>revoke</strong> 语句可以申明 <strong>restrict</strong> 来放在级联收回：</p> 
<pre><code class="prism language-sql"><span class="token keyword">revoke</span> <span class="token keyword">select</span> <span class="token keyword">on</span> department <span class="token keyword">from</span> Amit<span class="token punctuation">,</span> Satoshi 
</code></pre> 
<p>此时如果存在级联收回，系统返回一个错误，且不执行收权动作。</p> 
<p>可用cascade替换restrict来表示需要级联收回。<br> 然而，cascade可以省略，因为它是默认行为。</p> 
<p>下面的 revoke 语句仅仅收回 grant option ，而并不是真正收回 select 其权限：</p> 
<pre><code class="prism language-sql"><span class="token keyword">revoke</span> <span class="token keyword">grant</span> <span class="token keyword">option</span> <span class="token keyword">for</span> <span class="token keyword">select</span> <span class="token keyword">on</span> department <span class="token keyword">from</span> Amit<span class="token punctuation">;</span>
</code></pre> 
<p>SQL允许权限由一个角色授予，而不是由用户来授予。</p> 
<p>SQL有一个与会话所关联的当前角色概念。</p> 
<p>默认情况下，一个会话所关联的当前角色是空的（某些特殊情况除外）。</p> 
<p>一个会话所关联的当前角色可通过执行 <strong>set role role_name</strong> 来设置。</p> 
<p>指定的角色必须已经授予给用户，否则 <strong>set role</strong> 语句执行失败。</p> 
<p>如果要在授予权限时将授权人设置为一个会话所关联的当前角色，并且当前角色不为空的话，可在授权后加上如下子句：</p> 
<pre><code class="prism language-sql">granted <span class="token keyword">by</span> current_role 
</code></pre> 
<p>假设将角色 instructor（或其他权限） 授给 Amit 是用<strong>granted by current_role</strong> 子句实现的，当前角色被设置为 dean 而不是授权人，那么，从 Satoshi 处收回角色/权限（包括角色 dean）就不会导致收回以角色 dean 为授权人所授予的权限。</p> 
<h2>
<a id="_1082"></a>总结</h2> 
<ul>
<li>SQL支持包括内连接、外连接在内的几种连接类型，以及几种形式的连接条件。</li>
<li>视图关系可以定义为包含查询结果的关系。视图是有用的，它可以隐藏不需要的信息，可以把信息从多个关系收集到一个单一的视图中。</li>
<li>事务是一个查询和更新的序列，它们共同执行某项任务。事务可以被提交或回滚。当一个事务被回滚，该事务执行的所有更新所代理的影响将被撤销。</li>
<li>完整性约束保证授权用户对数据库所做的改变不会导致数据一致性的破坏。</li>
<li>参照完整性约束保证出现在一个关系的给定属性集上的值同样出现在另一个关系的特定属性集上。</li>
<li>域约束指定了在一个属性上可能取值的集合。这种约束也可以禁止在特定属性上使用的空值。</li>
<li>断言是描述性表达式，它指定了我们要求总是为真的谓词。</li>
<li>SQL数据定义语言提供对定义诸如 data 和 time 那样的固有域类型的支持。</li>
<li>通过SQL授权机制，可以按照在数据库中不同数据值上数据库用户所允许的访问类型对他们进行区分。</li>
<li>获得了某种形式授权的用户可能允许将此授权传递给其他用户。</li>
<li>角色有助于根据用户在组织机构中所扮演的角色，把一组权限分配给用户。</li>
</ul> 
<p>学习参考资料：</p> 
<pre><code>《数据库系统概念》第6版
</code></pre>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>