<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Kotlin学习笔记——（六）接口、抽象类、泛型、扩展、集合操作符、与Java互操作性、单例 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kotlin学习笔记——（六）接口、抽象类、泛型、扩展、集合操作符、与Java互操作性、单例</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p>注：编码工具为IntelliJ</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%8E%A5%E5%8F%A3-toc" style="margin-left:0px"><a href="#%E6%8E%A5%E5%8F%A3" title="接口">接口</a></p> 
<p id="%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px"><a href="#%E7%A4%BA%E4%BE%8B" title="示例">示例</a></p> 
<p id="%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F-toc" style="margin-left:40px"><a href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F" title="定义变量">定义变量</a></p> 
<p id="%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px"><a href="#%E7%A4%BA%E4%BE%8B" title="示例">示例</a></p> 
<p id="%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E5%80%BC-toc" style="margin-left:40px"><a href="#%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E5%80%BC" title="变量默认值">变量默认值</a></p> 
<p id="%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc" style="margin-left:0px"><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB" title="抽象类">抽象类</a></p> 
<p id="%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px"><a href="#%E7%A4%BA%E4%BE%8B" title="示例">示例</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px"><a href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3" title="实现接口">实现接口</a></p> 
<p id="%E6%B3%9B%E5%9E%8B-toc" style="margin-left:0px"><a href="#%E6%B3%9B%E5%9E%8B" title="泛型">泛型</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E7%B1%BB-toc" style="margin-left:40px"><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB" title="泛型类">泛型类</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0" title="泛型函数">泛型函数</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89map%E5%8F%98%E6%8D%A2-toc" style="margin-left:40px"><a href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89map%E5%8F%98%E6%8D%A2" title="泛型实现自定义map变换">泛型实现自定义map变换</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E7%B1%BB%E8%81%94%E5%90%88%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E8%81%94%E5%90%88%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0" title="泛型类联合泛型函数实现">泛型类联合泛型函数实现</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px"><a href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0" title="泛型函数实现">泛型函数实现</a></p> 
<p id="%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F-toc" style="margin-left:40px"><a href="#%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F" title="类型约束">类型约束</a></p> 
<p id="%E6%B3%9B%E5%9E%8Bvararg%E5%8F%82%E6%95%B0-toc" style="margin-left:40px"><a href="#%E6%B3%9B%E5%9E%8Bvararg%E5%8F%82%E6%95%B0" title="泛型vararg参数">泛型vararg参数</a></p> 
<p id="vararg%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px"><a href="#vararg%E7%A4%BA%E4%BE%8B" title="vararg示例">vararg示例</a></p> 
<p id="%E6%B3%9B%E5%9E%8Bvararg-toc" style="margin-left:80px"><a href="#%E6%B3%9B%E5%9E%8Bvararg" title="泛型vararg">泛型vararg</a></p> 
<p id="%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD-toc" style="margin-left:40px"><a href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD" title="类型判断">类型判断</a></p> 
<p id="out%E5%92%8Cin%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px"><a href="#out%E5%92%8Cin%E5%85%B3%E9%94%AE%E5%AD%97" title="out和in关键字">out和in关键字</a></p> 
<p id="%E6%89%A9%E5%B1%95-toc" style="margin-left:0px"><a href="#%E6%89%A9%E5%B1%95" title="扩展">扩展</a></p> 
<p id="%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0" title="扩展函数">扩展函数</a></p> 
<p id="%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px"><a href="#%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7" title="扩展属性">扩展属性</a></p> 
<p id="%E5%AF%B9%E6%B3%9B%E5%9E%8B%E6%89%A9%E5%B1%95-toc" style="margin-left:40px"><a href="#%E5%AF%B9%E6%B3%9B%E5%9E%8B%E6%89%A9%E5%B1%95" title="对泛型扩展">对泛型扩展</a></p> 
<p id="infix%EF%BC%9A%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px"><a href="#infix%EF%BC%9A%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="infix：中缀表达式">infix：中缀表达式</a></p> 
<p id="%E7%BB%93%E5%90%88%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px"><a href="#%E7%BB%93%E5%90%88%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8" title="结合泛型使用">结合泛型使用</a></p> 
<p id="%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px"><a href="#%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6" title="集合操作符">集合操作符</a></p> 
<p id="map-toc" style="margin-left:40px"><a href="#map" title="map">map</a></p> 
<p id="flatMap-toc" style="margin-left:40px"><a href="#flatMap" title="flatMap">flatMap</a></p> 
<p id="filter-toc" style="margin-left:40px"><a href="#filter" title="filter">filter</a></p> 
<p id="zip-toc" style="margin-left:40px"><a href="#zip" title="zip">zip</a></p> 
<p id="%E4%B8%8EJava%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px"><a href="#%E4%B8%8EJava%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C" title="与Java的互操作">与Java的互操作</a></p> 
<p id="%E7%94%A8%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%8E%A5%E6%94%B6Java%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px"><a href="#%E7%94%A8%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%8E%A5%E6%94%B6Java%E7%9A%84%E6%95%B0%E6%8D%AE" title="用可空类型接收Java的数据">用可空类型接收Java的数据</a></p> 
<p id="%40file%3AJvmName()-toc" style="margin-left:40px"><a href="#%40file%3AJvmName%28%29" title="@file:JvmName()">@file:JvmName()</a></p> 
<p id="%40JvmField-toc" style="margin-left:40px"><a href="#%40JvmField" title="@JvmField">@JvmField</a></p> 
<p id="%40JvmOverloads-toc" style="margin-left:40px"><a href="#%40JvmOverloads" title="@JvmOverloads">@JvmOverloads</a></p> 
<p id="%40JavaStatic-toc" style="margin-left:40px"><a href="#%40JavaStatic" title="@JavaStatic">@JavaStatic</a></p> 
<p id="%E5%8D%95%E4%BE%8B-toc" style="margin-left:0px"><a href="#%E5%8D%95%E4%BE%8B" title="单例">单例</a></p> 
<p id="%E9%A5%BF%E6%B1%89%E5%BC%8F-toc" style="margin-left:40px"><a href="#%E9%A5%BF%E6%B1%89%E5%BC%8F" title="饿汉式">饿汉式</a></p> 
<p id="%E6%87%92%E6%B1%89%E5%BC%8F-toc" style="margin-left:40px"><a href="#%E6%87%92%E6%B1%89%E5%BC%8F" title="懒汉式">懒汉式</a></p> 
<hr id="hr-toc">
<h1 id="%E6%8E%A5%E5%8F%A3">接口</h1> 
<p>        接口默认是open的，接口成员默认也是open的。</p> 
<h2 id="%E7%A4%BA%E4%BE%8B">示例</h2> 
<pre><code class="language-Kotlin">interface InterfaceTest {
    fun test()
}

class InterfaceTestImpl : InterfaceTest{
    override fun test() {
        println("这是实现自InterfaceTest的方法")
    }
}

fun main() {
    InterfaceTestImpl().test()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">这是实现自InterfaceTest的方法</code></pre> 
<h2 id="%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">定义变量</h2> 
<p>        实现类可以通过构造函数参数或者在类内部两种方式重写接口的变量。</p> 
<p>        接口内部可以有函数默认实现。</p> 
<h3>示例</h3> 
<pre><code class="language-Kotlin">interface InterfaceVariable {
    var name : String
    val des: String

    fun show(){
        println("name = $name, des = $des")
    }
}

class InterfaceVariableImpl(override var name: String,
                            override val des: String) : InterfaceVariable

class InterfaceVariableImpl2(name: String, des: String): InterfaceVariable{
    override var name: String = name
    override val des: String = des
}

fun main() {
    InterfaceVariableImpl("Happy", "Word").show()
    InterfaceVariableImpl2("Terminal", "When").show()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">name = Happy, des = Word
name = Terminal, des = When</code></pre> 
<h2 id="%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E5%80%BC">变量默认值</h2> 
<p>        接口定义的变量不可以用=直接赋值，但是val修饰的变量可以用get属性赋值。</p> 
<p>        有默认值的接口变量，可以重写，也可以不重写。</p> 
<pre><code class="language-Kotlin">interface InterfaceVariable2 {
    val randNum: String
        get() = (1..100).shuffled().first().toString()
    val des : String
        get() = "不要问我从哪里来"

    fun show(){
        println("randNum = $randNum, des = $des")
    }
}

class InterfaceVariable2Impl: InterfaceVariable2 // 接口内变量有默认值，则可以不重载

class InterfaceVariable2Impl2(randNum: String, des: String): InterfaceVariable2{
    override val randNum: String = randNum
    override val des: String = des
}

fun main() {
    InterfaceVariable2Impl().show()
    InterfaceVariable2Impl2("hahaha", "song").show()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">randNum = 89, des = 不要问我从哪里来
randNum = hahaha, des = song</code></pre> 
<h1 id="%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</h1> 
<p>        抽象类默认是open的，抽象类的抽象函数和抽象属性默认也是open的。</p> 
<p>        抽象类可以有非抽象成员变量和非抽象函数。</p> 
<p>        非抽象成员变量和非抽象函数如果想要被重写，需要添加open关键字。</p> 
<h2>示例</h2> 
<pre><code class="language-Kotlin">abstract class Abstract(age: Int) {
    abstract var name: String
    open var age: Int = age
    open fun show() {
        println("age = $age")
    }

    abstract fun show2()
}

class SubAbstract(override var name: String, override var age: Int) : Abstract(age) {
    override fun show2() {
        println("name = $name, age = $age")
    }

    override fun show() {
        println("override show")
    }
}

fun main() {
    val subAbstract = SubAbstract("Sjh", 30)
    subAbstract.show()
    subAbstract.show2()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">override show
name = Sjh, age = 30</code></pre> 
<h2 id="%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">实现接口</h2> 
<p>        抽象类可以实现接口，既可以重写接口成员，也可以不重写。</p> 
<pre><code class="language-Kotlin">interface Animal{
    fun show()
}

abstract class Cat: Animal

abstract class Dog: Animal{
    override fun show() {
        println("Dog重写了show")
    }
}

class Poodle: Dog()

fun main() {
    Poodle().show()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">Dog重写了show</code></pre> 
<h1 id="%E6%B3%9B%E5%9E%8B">泛型</h1> 
<h2 id="%E6%B3%9B%E5%9E%8B%E7%B1%BB">泛型类</h2> 
<pre><code class="language-Kotlin">class GenericClass&lt;T&gt;(val t: T){
    fun printAny() = println(t)
}

fun main() {
    GenericClass(123).printAny()
    GenericClass("hello").printAny()
    GenericClass(123.3987f).printAny()
    GenericClass('C').printAny()
    GenericClass(3214.908).printAny()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">123
hello
123.3987
C
3214.908</code></pre> 
<h2 id="%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">泛型函数</h2> 
<pre><code class="language-Kotlin">fun &lt;TYPE&gt; getSelf(t: TYPE) = t.takeIf { t != null } ?: "t is null"

fun main() {
    println(getSelf(null))
    println(getSelf("今天星期天"))
    println(getSelf(234))
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">t is null
今天星期天
234</code></pre> 
<h2 id="%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89map%E5%8F%98%E6%8D%A2">泛型实现自定义map变换</h2> 
<p>map变换把一种类型输入，变换为一种类型输出</p> 
<h3 id="%E6%B3%9B%E5%9E%8B%E7%B1%BB%E8%81%94%E5%90%88%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0">泛型类联合泛型函数实现</h3> 
<pre><code class="language-Kotlin">package step_six

class GenericClassMap&lt;I&gt;(val input: I, val isMap : Boolean = true){
    fun &lt;O&gt; map(action:(I)-&gt;O) = action(input).takeIf { isMap }
}

fun main() {
    println(GenericClassMap("i love this").map {
        it.uppercase()
    })
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">I LOVE THIS</code></pre> 
<h3 id="%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0">泛型函数实现</h3> 
<pre><code class="language-Kotlin">private fun &lt;I, O&gt; map(input: I, isMap: Boolean = true, action: (I) -&gt; O) 
    = action(input).takeIf { isMap }

fun main() {
    println(map("into the unknown") {
        it.uppercase()
    })
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">INTO THE UNKNOWN</code></pre> 
<h2 id="%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F">类型约束</h2> 
<p>        类似于Java的T extends CharSequence，Kotlin写法为T: CharSequence。</p> 
<pre><code class="language-Kotlin">open class SuperObject(val name: String)

open class Human(val humanName: String): SuperObject(humanName)

class Man(val manName: String): Human(manName)

class Woman(val womanName: String): Human(womanName)

class Other(val name: String)

fun &lt;T: Human&gt; show(t: T){ // 只能接收Human及子类对象
    println("name = ${t.humanName}")
}

fun main() {
//    show(SuperObject("super object"))// 编译不通过
    show(Human("human"))
    show(Man("man"))
    show(Woman("woman"))
//    show(Other("other"))// 编译不通过
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">name = human
name = man
name = woman</code></pre> 
<h2 id="%E6%B3%9B%E5%9E%8Bvararg%E5%8F%82%E6%95%B0">泛型vararg参数</h2> 
<p>        vararg相当于Java的可变参数。</p> 
<h3 id="vararg%E7%A4%BA%E4%BE%8B">vararg示例</h3> 
<pre><code class="language-Kotlin">fun show(vararg arr: Int){
    arr[0] = 1
    arr.forEach {
        println(it)
    }
}

fun main() {
    show(-1)
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">1</code></pre> 
<h3 id="%E6%B3%9B%E5%9E%8Bvararg">泛型vararg</h3> 
<p>        泛型vararg参数，只能用out修饰的泛型参数数组接收，只能读取其中元素，不能修改。</p> 
<pre><code class="language-Kotlin">private fun &lt;T&gt; show(vararg ts: T){
    ts.forEach {
        print("$it ")
    }
}

fun main() {
    show(1, 2, 3)
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">1 2 3 </code></pre> 
<h2 id="%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">类型判断</h2> 
<p>        泛型参数进行is和as操作的时候，后面要跟可空数据类型，因为泛型可以接收null。</p> 
<pre><code class="language-Kotlin">private fun &lt;T&gt; show(t : T){
    if(t is String?){
        println(t?.length ?: null)
    }else if(t is Int?){
        println(t ?: null)
    }else{
        println("其他类型")
    }
}

fun main() {
    show(null)
    show("Hope")
    show(123)
    show('C')
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">null
4
123
其他类型</code></pre> 
<h2 id="out%E5%92%8Cin%E5%85%B3%E9%94%AE%E5%AD%97">out和in关键字</h2> 
<p>        out：        </p> 
<p>                out T相当于Java的? extends T，与Java的不同点是out T只能在类或接口上声明。</p> 
<p>                out T在类或接口上声明时，该类的所有函数只能将T类型变量作为返回值，不能作为函数入参。 </p> 
<p>        in:</p> 
<p>                in T相当于Java的? super T，与Java的不同点是in T只能在类或接口上声明。</p> 
<p>                in T在类或接口上声明时，该类的所有函数只能将T类型变量作为入参，不能作为函数返回值。</p> 
<h1 id="%E6%89%A9%E5%B1%95">扩展</h1> 
<h2 id="%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0">扩展函数</h2> 
<p>        在类的外部定义的类的成员函数，可以和类内部的成员函数一样调用，可以访问类内部成员。</p> 
<pre><code class="language-Kotlin">class ExpandTest(val info: String)

fun ExpandTest.show() = println(info)

fun main() {
    ExpandTest("扩展函数").show()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">扩展函数</code></pre> 
<h2 id="%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7">扩展属性</h2> 
<p>         在类的外部定义的类的成员属性，可以和类内部的成员属性一样调用。</p> 
<pre><code class="language-Kotlin">class ExpandField(val info: String)

val ExpandField.infoLength
    get() = info.length

fun main() {
    println(ExpandField("扩展属性").infoLength)
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">4</code></pre> 
<p>注意：</p> 
<p>        扩展函数和扩展属性不限制访问范围的话，全局都可以访问。</p> 
<p>        如果想让可空类型也可以调用扩展函数或扩展属性的话，则需要对可空类型进行扩展。</p> 
<p>        可以将扩展函数和扩展属性定义到单独的文件中，便于查找和维护。</p> 
<h2 id="%E5%AF%B9%E6%B3%9B%E5%9E%8B%E6%89%A9%E5%B1%95">对泛型扩展</h2> 
<p>        内置函数如：apply、let、run、with、also、takeIf、takeUnless的实现原理。</p> 
<pre><code class="language-Kotlin">private fun &lt;T&gt; T.log() = println(this)

fun main() {
    123.log()
    "abc".log()
    'C'.log()
    null.log()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">123
abc
C
null</code></pre> 
<h2 id="infix%EF%BC%9A%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">infix：中缀表达式</h2> 
<pre><code class="language-Kotlin">infix fun String.infixTest(i: Int){
    println("$this:::$i")
}

fun main() {
    "abcd" infixTest 1324
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">abcd:::1324</code></pre> 
<h3 id="%E7%BB%93%E5%90%88%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8">结合泛型使用</h3> 
<p>        应用范围更广，如 to，可以生成任意类型的Pair变量。</p> 
<pre><code class="language-Kotlin">private infix fun &lt;T, X&gt; T.union(x: X){
    println("t = $this, x = $x")
}

fun main() {
    8734.2 union "abc"
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">t = 8734.2, x = abc</code></pre> 
<p>tips：导包可以用as取别名，可以提高开发效率，解决包冲突问题。</p> 
<h1 id="%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6">集合操作符</h1> 
<h2 id="map">map</h2> 
<p>        可以将集合元素做一些转换后添加到另一个集合中。</p> 
<pre><code class="language-Kotlin">fun main() {
    listOf("Beijing", "Shanghai", "Nanjing").map {
        it.length
    }.forEach{
        print("$it ")
    }
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">7 8 7 </code></pre> 
<h2 id="flatMap">flatMap</h2> 
<p>        可以将集合元素做一些转换，flatMap的lambda必须返回一个集合。</p> 
<pre><code class="language-Kotlin">fun main() {
    listOf("张三", "李四", "王五").flatMap {
        listOf("&amp;$it&amp;")
    }.forEach { print("$it ") }
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">&amp;张三&amp; &amp;李四&amp; &amp;王五&amp; </code></pre> 
<h2 id="filter">filter</h2> 
<p>        根据过滤条件挑选符合的元素。</p> 
<pre><code class="language-Kotlin">fun main() {
    listOf("Hi", "Hello", "What", "World", "Happy")
        .filter {it.contains("H")}
        .forEach { print("$it ") }
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">Hi Hello Happy </code></pre> 
<h2 id="zip">zip</h2> 
<p>        合并两个集合，将对应下标的元素封装成一个Pair，最终放到一个新的集合里。</p> 
<pre><code class="language-Kotlin">fun main() {
    val words = listOf("Hi", "Hello", "Hope", "Happy", "Work")
    val lengths = listOf(2, 5, 4, 5, 4)
    words.zip(lengths).forEach {
        println("word = ${it.first}, length = ${it.second}")
    }
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">word = Hi, length = 2
word = Hello, length = 5
word = Hope, length = 4
word = Happy, length = 5
word = Work, length = 4</code></pre> 
<h1 id="%E4%B8%8EJava%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C">与Java的互操作</h1> 
<h2 id="%E7%94%A8%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%8E%A5%E6%94%B6Java%E7%9A%84%E6%95%B0%E6%8D%AE">用可空类型接收Java的数据</h2> 
<p>Java代码：</p> 
<pre><code class="language-java">package communicate_with_kotlin;

public class ProvideValue {

    public static String getInfo(){
        return null;
    }

    public static String getString(){
        return "测试";
    }
}</code></pre> 
<p>Kotlin代码：</p> 
<pre><code class="language-Kotlin">import communicate_with_kotlin.ProvideValue

fun main() {
    val info: String? = ProvideValue.getInfo()
    val string: String? = ProvideValue.getString()
    println(info?.length ?: "info是空值")
    println(string?.length ?: "string是空值")
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">info是空值
2</code></pre> 
<h2 id="%40file%3AJvmName()">@file:JvmName()</h2> 
<p>        用于定义Kotlin文件生成的类名，必须写在包名前面。</p> 
<p>Kotlin代码：</p> 
<pre><code class="language-Kotlin">@file:JvmName("NewClassName")
package step_six

fun jvmName(){
    println("测试JvmName")
}</code></pre> 
<p>Java代码：</p> 
<pre><code class="language-java">import step_six.NewClassName;

public class JvmNameTest {
    public static void main(String[] args) {
        NewClassName.jvmName();
    }
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">测试JvmName</code></pre> 
<h2 id="%40JvmField">@JvmField</h2> 
<p>        可以使Java代码可以直接访问Kotlin的变量，而不需要通过get方法。</p> 
<p>Kotlin代码：</p> 
<pre><code class="language-Kotlin">package step_six

class JvmFieldTest(@JvmField val msg: String)</code></pre> 
<p>Java代码：</p> 
<pre><code class="language-java">
import step_six.JvmFieldTest;

public class JvmField {
    public static void main(String[] args) {
        System.out.println(new JvmFieldTest("JvmField测试").msg);
    }
}
</code></pre> 
<p>输出：</p> 
<pre><code class="language-java">JvmField测试</code></pre> 
<h2 id="%40JvmOverloads">@JvmOverloads</h2> 
<p>        可以使Java代码能够用Kotlin的默认参数特性。</p> 
<p>Kotlin代码：</p> 
<pre><code class="language-Kotlin">package step_six

@JvmOverloads
fun show(name: String, age: Int = 99, gender: Char = 'F')
{
    println("name = $name, age = $age, gender = $gender")
}</code></pre> 
<p>Java代码：</p> 
<pre><code class="language-java">package communicate_with_kotlin;

import step_six.JvmOverloadsTestKt;

public class JvmOverloads {
    public static void main(String[] args) {
        JvmOverloadsTestKt.show("ss");
        JvmOverloadsTestKt.show("gg", 14);
        JvmOverloadsTestKt.show("h", 30);
    }
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-java">name = ss, age = 99, gender = F
name = gg, age = 14, gender = F
name = h, age = 30, gender = F</code></pre> 
<h2 id="%40JavaStatic">@JavaStatic</h2> 
<p>        使Java代码像调用Java的static方法一样调用Kotlin的函数。</p> 
<p>Kotlin代码：</p> 
<pre><code class="language-Kotlin">package step_six

class JvmStaticTest {
    companion object{
        @JvmStatic
        fun show(){
            println("JvmStatic测试")
        }
    }
}</code></pre> 
<p>Java代码：</p> 
<pre><code class="language-java">public class JvmStatic {
    public static void main(String[] args) {
        JvmStaticTest.show();
    }
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-java">JvmStatic测试</code></pre> 
<h1 id="%E5%8D%95%E4%BE%8B">单例</h1> 
<h2 id="%E9%A5%BF%E6%B1%89%E5%BC%8F">饿汉式</h2> 
<pre><code class="language-Kotlin">object EHanSingleton{
    fun show(){
        println("Kotlin饿汉式单例")
    }
}

fun main() {
    EHanSingleton.show()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">Kotlin饿汉式单例</code></pre> 
<h2 id="%E6%87%92%E6%B1%89%E5%BC%8F">懒汉式</h2> 
<pre><code class="language-Kotlin">package step_six

class LanHanSingleton private constructor(){

    init{
        println("主构造函数执行了")
    }

    companion object{
        val INSTANCE: LanHanSingleton by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED){
            LanHanSingleton()
        }
    }

    fun show(){
        println("Kotlin懒汉式单例")
    }
}

fun main() {
    LanHanSingleton.INSTANCE.show()
    LanHanSingleton.INSTANCE.show()
}</code></pre> 
<p>输出：</p> 
<pre><code class="language-Kotlin">主构造函数执行了
Kotlin懒汉式单例
Kotlin懒汉式单例</code></pre> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>