<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>《Vue.js 设计与实现》—— 02 框架设计核心要素 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《Vue.js 设计与实现》—— 02 框架设计核心要素</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    
                        
                    
                    <p>框架设计并非仅仅实现功能那么简单，里面有很多学问。例如：</p> 
<ul>
<li> <p>框架应该给用户提供哪些构建产物？产物的模块格式如何？</p> </li>
<li> <p>当用户没有以预期的方式使用框架时，是否应该打印合适的警告信息从而提供更好的开发体验，让用户快速定位问题？</p> </li>
<li> <p>开发版本和生产版本的构建有何区别？</p> </li>
<li> <p>热更新（hot module replacement，HMR）需要框架层面的支持，是否也应该考虑？</p> </li>
<li> <p>当框架提供了多个功能，而用户只需要其中几个功能时，用户能否选择关闭其他功能从而减少最终资源的打包体积？</p> </li>
<li> <p>…</p> </li>
</ul> 
<h3>
<a id="1__10"></a>1. 提升开发体验</h3> 
<p>衡量一个框架是否足够优秀的指标之一就是看它的开发体验如何，以 Vue.js 3 为例：</p> 
<pre><code class="prism language-js"><span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#not-exist'</span><span class="token punctuation">)</span>
</code></pre> 
<p>当创建一个组件并试图将其挂载到一个不存在的 DOM 节点时，就会收到一条警告信息：</p> 
<pre><code class="prism language-text">[Vue warn]: Failed to mount app: mount target selector "#not-exist" returned null.
</code></pre> 
<p>这条信息让我们能够清晰且快速地定位问题。如果 Vue.js 内部不做任何处理，那么很可能得到的是 JavaScript 层面的错误信息，如 <code>Uncaught TypeError: Cannot read property 'xxx' of null</code>，而根据此信息很难知道问题所在。</p> 
<p>因此，在框架设计和开发过程中，提供友好的警告信息至关重要。始终提供友好的警告信息不仅能够帮助用户快速定位问题，节省用户的时间，还能够让框架收获良好的口碑，让用户认可框架的专业性。</p> 
<p>在 Vue.js 的源码中，经常能够看到 <code>warn</code> 函数的调用，例如：</p> 
<pre><code class="prism language-js"><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Failed to mount app: mount target selector "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>container<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" returned null.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
</code></pre> 
<p>除了提供必要的警告信息外，还有很多其他方面可以作为切入口，进一步提升用户的开发体验。例如，在 Vue.js 3 中，当在控制台打印一个 ref 数据时：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
</code></pre> 
<p>打印结果是一个 ref 对象，很不直观，但调用 <code>count.value</code> 后，得到的就是响应式对象的值，变得非常直观。</p> 
<p>那么有没有办法在直接打印 <code>count</code> 时让输出的信息更友好呢？当然可以，浏览器允许我们编写自定义的 formatter，从而自定义输出形式。</p> 
<p>在 Vue.js 3 的源码中，有一个名为 <code>initCustomFormatter</code> 的函数，用来在开发环境下初始化自定义 formatter。</p> 
<p>以 Chrome 为例，打开 DevTools 的设置，然后勾选 “Console” -&gt; “Enable custom formatters” 选项，如下：</p> 
<p><img src="https://images2.imgbox.com/45/22/HSBgINPi_o.jpg" alt=""></p> 
<p>然后刷新浏览器并查看控制台，会发现输出内容变得非常直观，如下：</p> 
<p><img src="https://images2.imgbox.com/96/4d/jgOLe12E_o.jpg" alt=""></p> 
<h3>
<a id="2__55"></a>2. 控制代码体积</h3> 
<p>框架的大小也是衡量框架的标准之一。在实现同样功能的情况下，代码越少越好，这样体积就会越小，最后浏览器加载资源的时间也就越少。前面说到，框架提供越完善的警告信息越好，但这意味着要编写更多的代码，那么如何在这个基础上实现代码体积的控制呢？</p> 
<p>如果去看 Vue.js 3 的源码，就会发现每一个 <code>warn</code> 函数的调用都会配合 <code>__DEV__</code> 常量的检查，例如：</p> 
<pre><code class="prism language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__ <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>res<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 打印警告信息的前提时 __DEV__ 为 true</span>
  <span class="token function">warn</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Failed to mount app: mount target selector "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>container<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" returned null.</span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Vue.js 使用 rollup.js 对项目进行构建，这里的 <code>__DEV__</code> 常量实际上是通过 rollup.js 的插件配置来预定义的，其功能类似于 webpack 中的 DefinePlugin 插件。</p> 
<p>Vue.js 在输出资源的时候，会输出两个版本，其中一个用于开发环境，如 vue.global.js，另一个用于生产环境，如 vue.global.prod.js。</p> 
<p>当 Vue.js 构建用于开发环境的资源时，会把 <code>__DEV__</code> 常量设置为 <code>true</code>；当构建生产环境的资源时，会把 <code>__DEV__</code> 常量设置为 <code>false</code>。</p> 
<p>因为生产环境下判断条件始终为假，这段永远不会执行的代码称为 <strong>dead code</strong>，它不会出现在最终产物中，在构建资源时就会被移除。这样就做到了在开发环境中为用户提供友好的警告信息的同时，不会增加生产环境代码的体积。</p> 
<h3>
<a id="3__TreeShaking_77"></a>3. 良好的 Tree-Shaking</h3> 
<p>仅仅通过 <code>__dev__</code> 变量控制代码量是远远不够的。还以 Vue.js 为例，其内建了很多组件，例如 <code>&lt;Transition&gt;</code> 组件，如果项目中没有用到该组件，其对应的代码就不需要也不应该包含在最终的构建资源中。那么如何做到这一点呢？答案就是 <strong>Tree-Shaking</strong>。</p> 
<p>在前端领域，这个概念是由 rollup.js 普及的。简单地说，<strong>Tree-Shaking 指的就是消除那些永远不会被执行的代码，也就是排除 dead code，现在无论是 rollup.js 还是webpack，都支持 Tree-Shaking</strong>。</p> 
<p>想要实现 Tree-Shaking，必须满足一个条件，即模块必须是 ESM（ES Module），因为 Tree-Shaking 依赖 ESM 的静态结构。以 rollup.js 为例看看 Tree-Shaking 如何工作，其目录结构如下：</p> 
<pre><code class="prism language-text">- demo
	- package.json
	- input.js
	- utils.js
</code></pre> 
<p>首先安装 rollup.js：</p> 
<pre><code class="prism language-bash"><span class="token function">yarn</span> <span class="token function">add</span> rollup -D <span class="token comment"># 或 npm install rollup -D</span>
</code></pre> 
<p>input.js 和 utils.js 文件的内容如下：</p> 
<pre><code class="prism language-js"><span class="token comment">// input.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./utils.js'</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// utils.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>foo
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// bar 函数未被使用</span>
    obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>bar
<span class="token punctuation">}</span>
</code></pre> 
<p>接着，执行如下命令进行构建：</p> 
<pre><code class="prism language-bash">npx rollup input.js -f esm -o bundle.js
</code></pre> 
<p>构建后，输出的 bundle.js 的内容为：</p> 
<pre><code class="prism language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>foo
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>这说明 Tree-Shaking 起了作用，我们并没有使用 <code>bar</code> 函数，因此它作为 dead code 被删除了。但是仔细观察会发现，<code>foo</code> 函数的执行也没有什么意义，仅仅是读取了对象的值，所以它的执行似乎没什么必要。既然把这段代码删了也不会对程序产生影响，那为什么 rollup.js 不把这段代码也作为 dead code 移除呢？</p> 
<p>这涉及 Tree-Shaking 中的第二个关键点 —— 副作用。<strong>如果一个函数调用会产生副作用，那么就不能将其移除</strong>。</p> 
<p>简单地说，副作用就是，当调用函数的时候会对外部产生影响，例如修改了全局变量。</p> 
<p>但是，上面的代码只读取对象的值，怎么会产生副作用呢？其实是有可能的，如果 <code>obj</code> 对象是一个通过 Proxy 创建的代理对象，那么读取对象属性时，就会触发代理对象的 get 夹子（trap），在 get 夹子中是可能产生副作用的。至于到底会不会产生副作用，只有代码真正运行的时候才能知道，JavaScript 本身是动态语言，因此想要静态地分析哪些代码是 dead code 很有难度。</p> 
<p>即然静态地分析代码很困难，所以像 rollup.js 这类工具都会提供一个机制，让我们手动明确地告诉 rollup.js 该段代码是一个纯函数，不会产生副作用，可以移除它。具体实现如下：</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span>foo<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./utils'</span>

<span class="token comment">/*#__PURE__*/</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 前面的 __PURE__ 告知是一个纯函数，不会产生副作用，可以移除</span>
</code></pre> 
<p>此时再次执行构建命令并查看 bundle.js 文件，就会发现它的内容是空的。</p> 
<p>因此，我们在编写框架的时候需要合理使用 <code>/*#__PURE__*</code> 注释。Vue.js 3 的源码里面大量使用了该注释。</p> 
<p>那么，这会不会对编写代码造成很大的心智负担呢？其实不会，因为通常产生副作用的代码都是模块内函数的顶级调用。</p> 
<p>什么是顶级调用呢？如下：</p> 
<pre><code class="prism language-js"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 顶级调用</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 函数内调用 -- 没有副作用，除非 bar() 顶级调用</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>/*#__PURE__*/</code> 注释不仅仅作用于函数，它可以应用于任何语句上。该注释也不是只有 rollup.js 才能识别，webpack 以及压缩工具（如 terser）都能识别它。</p> 
<h3>
<a id="4__163"></a>4. 输出构建产物</h3> 
<p>前面说到 Vue.js 会为开发环境和生产环境输出不同的包，如 vue.global.js 用于开发环境，它包含必要的警告信息，而 vue.global.prod.js 用于生产环境，不包含警告信息。实际上，Vue.js 的构建产物除了有环境上的区分之外，还会根据使用场景的不同而输出其他形式的产物。</p> 
<p>不同类型的产物一定有对应的需求背景，因此需要从需求讲起。首先我们希望用户可以直接在 HTML 页面中使用 <code>&lt;script&gt;</code> 标签引入框架并使用：</p> 
<pre><code class="prism language-js"><span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"/path/to/vue.js"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> createApp <span class="token punctuation">}</span> <span class="token operator">=</span> Vue
    <span class="token comment">// ...</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
</code></pre> 
<p>为了实现这个需求，需要输出一种叫作 IIFE 格式的资源。IIFE 的全称是 Immediately Invoked Function Expression，即“立即调用的函数表达式”，易于用 JavaScript 来表达：</p> 
<pre><code class="prism language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>如以上代码所示，这是一个立即执行的函数表达式。实际上，vue.global.js 文件就是 IIFE 形式的资源，它的代码结构如下所示：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> Vue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">exports</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token comment">// ...</span>
  exports<span class="token punctuation">.</span>createApp <span class="token operator">=</span> createApp<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">return</span> exports
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>这样当我们使用 <code>&lt;script&gt;</code> 标签直接引入 vue.global.js 文件后，全局变量 Vue 就是可用的了。在 rollup.js 中，可以通过配置 <code>format: 'iife'</code> 来输出这种形式的资源：</p> 
<pre><code class="prism language-js"><span class="token comment">// rollup.config.js</span>
<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">input</span><span class="token operator">:</span> <span class="token string">'input.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">file</span><span class="token operator">:</span> <span class="token string">'output.js'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">format</span><span class="token operator">:</span> <span class="token string">'iife'</span> <span class="token comment">// 指定模块形式</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> config
</code></pre> 
<p>随着技术的发展和浏览器的支持，现在主流浏览器对原生 ESM 的支持都不错，所以用户除了能够使用 <code>&lt;script&gt;</code> 标签引用 IIFE 格式的资源外，还可以直接引入 ESM 格式的资源，例如 Vue.js 3 还会输出 vue.esm-browser.js 文件，用户可以直接用 <code>&lt;script type="module"&gt;</code> 标签引入：</p> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/path/to/vue.esm-browser.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>为了输出 ESM 格式的资源，rollup.js 的输出格式需要配置为：<code>format: 'esm'</code>。</p> 
<p>为什么 vue.esm-browser.js 文件中会有 -browser 字样？其实对于 ESM 格式的资源来说，Vue.js 还会输出一个 vue.esm-bundler.js 文件，其中 -browser 变成了 -bundler。为什么这么做呢？我们知道，无论是 rollup.js 还是 webpack，在寻找资源时，如果 package.json 中存在 <code>module</code> 字段，那么会优先使用 <code>module</code> 字段指向的资源来代替 <code>main</code> 字段指向的资源。</p> 
<p>可以打开 Vue.js 源码中的 packages/vue/package.json 文件看一下：</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"main"</span><span class="token operator">:</span> <span class="token string">"index.js"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"module"</span><span class="token operator">:</span> <span class="token string">"dist/vue.runtime.esm-bundler.js"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其中 <code>module</code> 字段指向的是 vue.runtime.esm-bundler.js 文件，意思是说，如果项目是使用webpack 构建的，那么你使用的 Vue.js 资源就是 vue.runtime.esm-bundler.js，也就是说，带有 -bundler 字样的 ESM 资源是给 rollup.js 或 webpack 等打包工具使用的，而带有 -browser 字样的 ESM 资源是直接给 <code>&lt;script type="module"&gt;</code> 使用的。它们之间有何区别？这就不得不提到上文中的 <code>__DEV__</code> 常量。当构建用于 <code>&lt;script&gt;</code> 标签的 ESM 资源时，如果是用于开发环境，那么 <code>__DEV__</code> 会设置为 <code>true</code>；如果是用于生产环境，那么 <code>__DEV__</code> 常量会设置为 <code>false</code>，从而被 Tree-Shaking 移除。但是当我们构建提供给打包工具的 ESM 格式的资源时，不能直接把 <code>__DEV__</code> 设置为 <code>true</code> 或 <code>false</code>，而要使用（<code>process.env.NODE_ENV !== 'production'</code>）替换 <code>__DEV__</code> 常量。例如下面的源码：</p> 
<pre><code class="prism language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">useCssModule() is not supported in the global build.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在带有 -bundler 字样的资源中会变成：</p> 
<pre><code class="prism language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">useCssModule() is not supported in the global build.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样做的好处是，用户可以通过 webpack 配置自行决定构建资源的目标环境，但是最终效果其实一样，这段代码也只会出现在开发环境中。用户除了可以直接使用 <code>&lt;script&gt;</code> 标签引入资源外，我们还希望用户可以在 Node.js 中通过 <code>require</code> 语句引用资源，例如：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> Vue <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span>
</code></pre> 
<p>为什么会有这种需求呢？因为当进行服务端渲染时，Vue.js 的代码是在 Node.js 环境中运行的。在 Node.js 环境中，资源的模块格式应该是 CommonJS，简称 cjs。为了能够输出 cjs 模块的资源，可以通过修改 rollup.config.js 的配置 <code>format: 'cjs'</code> 来实现：</p> 
<h3>
<a id="5__256"></a>5. 特征开关</h3> 
<p>在设计框架时，框架会给用户提供诸多特性（或功能），例如提供 A、B、C 三个特性给用户，同时还提供了 a、b、c 三个对应的特性开关，用户可以通过设置 a、b、c 为 <code>true</code> 或 <code>false</code> 来代表开启或关闭对应的特性，这将会带来很多益处，如：</p> 
<ul>
<li>对于用户关闭的特性，可以利用 Tree-Shaking 机制让其不打包在最终的资源中。</li>
<li>该机制为框架设计带来了灵活性，可以通过特性开关任意为框架添加新的特性，而不用担心资源体积变大。</li>
<li>当框架升级时，也可以通过特性开关来支持遗留 API，这样新用户可以选择不使用遗留 API，从而使最终打包的资源体积最小化。</li>
</ul> 
<p>那如何实现特性开关呢？其原理和前面提到的 <code>__DEV__</code> 常量一样，本质上是利用 rollup.js 的预定义常量插件来实现。拿 Vue.js 3 源码中的一段 rollup.js 配置来说：</p> 
<pre><code class="prism language-js"><span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">__FEATURE_OPTIONS_API__</span><span class="token operator">:</span> isBundlerESMBuild <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">__VUE_OPTIONS_API__</span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其中 <code>__FEATURE_OPTIONS_API__</code> 类似于 <code>__DEV__</code>。在 Vue.js 3 的源码中搜索，可以找到很多类似于如下代码的判断分支：</p> 
<pre><code class="prism language-js"><span class="token comment">// support for 2.x options</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>__FEATURE_OPTIONS_API__<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  currentInstance <span class="token operator">=</span> instance
  <span class="token function">pauseTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">applyOptions</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Component<span class="token punctuation">)</span>
  <span class="token function">resetTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  currentInstance <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当 Vue.js 构建资源时，如果构建的资源是供打包工具使用的（即带有 -bundler 字样的资源），那么上面的代码在资源中会变成：</p> 
<pre><code class="prism language-js"><span class="token comment">// support for 2.x options</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>__VUE_OPTIONS_API__<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 这里不一样</span>
  currentInstance <span class="token operator">=</span> instance
  <span class="token function">pauseTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">applyOptions</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Component<span class="token punctuation">)</span>
  <span class="token function">resetTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  currentInstance <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其中 <code>__VUE_OPTIONS_API__</code> 是一个特性开关，用户可以通过设置 <code>__VUE_OPTIONS_API__</code> 预定义常量的值来控制是否要包含这段代码。通常用户可以使用 webpack.DefinePlugin 插件来实现：</p> 
<pre><code class="prism language-js"><span class="token comment">// webpack.DefinePlugin 插件配置</span>
<span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">__VUE_OPTIONS_API__</span><span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 开启特性</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>最后解释一下 <code>__VUE_OPTIONS_API__</code> 开关有什么用。在 Vue.js 2 中，我们编写的组件叫作Options API；在 Vue.js 3 中，推荐使用 Composition API 来编写代码。为了兼容 Vue.js 2，在 Vue.js 3 中仍然可以使用 Options API 的方式编写代码。但是如果明确知道自己不会使用选项 API，用户就可以使用 <code>__VUE_OPTIONS_API__</code> 开关来关闭该特性，这样在打包的时候 Vue.js 的这部分代码就不会包含在最终的资源中，从而减小资源体积。</p> 
<h3>
<a id="6__309"></a>6. 错误处理</h3> 
<p>错误处理是框架开发过程中非常重要的环节。框架错误处理机制的好坏直接决定了用户应用程序的健壮性，还决定了用户开发时处理错误的心智负担。</p> 
<p>假设我们开发了一个工具模块，代码如下：</p> 
<pre><code class="prism language-js"><span class="token comment">// utils.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        fn <span class="token operator">&amp;&amp;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该模块导出一个对象，其中 <code>foo</code> 属性是一个函数，接收一个回调函数作为参数，调用 <code>foo</code> 函数时会执行该回调函数，在用户侧使用时：</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> utils <span class="token keyword">from</span> <span class="token string">'utils.js'</span>
utils<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果用户提供的回调函数在执行的时候出错了，怎么办？有两个办法，第一个办法是让用户自行处理，这需要用户自己执行 <code>try ... catch</code>：</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> utils <span class="token keyword">from</span> <span class="token string">'utils.js'</span>
utils<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>但是这会增加用户的负担。如果 utils.js 提供了几十上百个类似的函数，那么用户在使用的时候就需要逐一添加错误处理程序。</p> 
<p>第二个办法是我们代替用户统一处理错误，如以下代码所示：</p> 
<pre><code class="prism language-js"><span class="token comment">// utils.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            fn <span class="token operator">&amp;&amp;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">/* ... */</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            fn <span class="token operator">&amp;&amp;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">/* ... */</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>事实上，可以进一步将错误处理程序封装在一个函数上，假设称为 <code>callWithErrorHandling</code>：</p> 
<pre><code class="prism language-js"><span class="token comment">// utils.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">callWithErrorHandling</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">callWithErrorHandling</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">callWithErrorHandling</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        fn <span class="token operator">&amp;&amp;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/* ... */</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>简洁还不是封装函数的主要目的，我们能为用户提供统一的错误处理接口，如：</p> 
<pre><code class="prism language-js"><span class="token comment">// utils.js</span>
<span class="token keyword">let</span> handleError <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">callWithErrorHandling</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 用户可以调用该函数注册统一的错误处理函数</span>
  <span class="token function">registerErrorHandler</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    handleError <span class="token operator">=</span> fn
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">callWithErrorHandling</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
    fn <span class="token operator">&amp;&amp;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 将捕获到的错误传递给用户的错误处理程序</span>
    <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样用户侧的代码就会非常简洁且健壮：</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> utils <span class="token keyword">from</span> <span class="token string">'utils.js'</span>

<span class="token comment">// 注册错误处理程序</span>
utils<span class="token punctuation">.</span><span class="token function">registerErrorHandler</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
utils<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token comment">/*...*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
utils<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token comment">/*...*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>这时错误处理的能力完全由用户控制，用户既可以选择忽略错误，也可以调用上报程序将错误上报给监控系统。实际上，这就是 Vue.js 错误处理的原理，可以在源码中搜索到 <code>callWithErrorHandling</code> 函数。另外，在 Vue.js 中，也可以注册统一的错误处理函数：</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'App.vue'</span>

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>
app<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function-variable function">errorHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 错误处理程序</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="7__TS__444"></a>7. 良好的 TS 支持</h3> 
<p>TypeScript 是由微软开源的编程语言，简称 TS，它是 JavaScript 的超集，能够为 JavaScript 提供类型支持。使用 TS 的好处有很多，如代码即文档、编辑器自动提示、一定程度上能够避免低级 bug、代码的可维护性更强等。因此对 TS 类型的支持是否完善也成为评价一个框架的重要指标。</p> 
<p>如何衡量一个框架对 TS 类型支持的水平呢？这里有一个常见的误区，很多人以为只要是使用 TS 编写框架，就等价于对 TS 类型支持友好，其实这两种完全不同。</p> 
<p>举例来说。下面是使用 TS 编写的函数：</p> 
<pre><code class="prism language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre> 
<p>这个函数直接将参数作为返回值，这说明返回值的类型是由参数决定的，如果参数是 number 类型，那么返回值也是 number 类型。但是，假设有下面的代码：</p> 
<pre><code class="prism language-typescript"><span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'str'</span><span class="token punctuation">)</span> <span class="token comment">// 参数为字符串类型，理论上 res 也为字符串类型，但是却推断成了 any 类型</span>
</code></pre> 
<p>为了达到理想状态，只需要对 <code>foo</code> 函数做简单的修改即可：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> foo<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">any</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> val
<span class="token punctuation">}</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'str'</span><span class="token punctuation">)</span> <span class="token comment">// 这时就会将 res 推断为 "str" 字符串字面量了</span>
</code></pre> 
<p>通过这个例子可以认识到，使用 TS 编写代码与对 TS 类型支持友好是两件事。在编写大型框架时，想要做到完善的 TS 类型支持很不容易，可以查看 Vue.js 源码中的 runtime-core/src/apiDefineComponent.ts 文件，整个文件里真正会在浏览器中运行的代码其实只有 3 行，但是全部的代码接近 200 行，其实这些代码都是在为类型支持服务。由此可见，框架想要做到完善的类型支持，需要付出相当大的努力。</p> 
<p>更多文章可关注：<a href="https://blog.gopher.fit">GopherBlog</a>、<a href="https://www.goher.fit">GopherBlog副站</a></p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>