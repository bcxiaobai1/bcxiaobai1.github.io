<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Solidity 介绍 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Solidity 介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h1></h1> 
<h1 id="solidity-语言">一.Solidity 语言</h1> 
<p>Solidity 语言是一种面向<span style="color:#fe2c24">合约</span>的高级编程语言，用于在以太坊区块链网络上实现智能合约。Solidity 语言深受c++、Python 和 JavaScript 的影响，针对<span style="color:#fe2c24">以太坊</span>(Ethereum)<span style="color:#fe2c24">虚拟机</span>(EVM)设计。</p> 
<p>Solidity 语言是<span style="color:#fe2c24">静态类型语言</span>支持继承、库和复杂的用户定义类型。</p> 
<blockquote> 
 <p>1、<strong>静态类型语言</strong>：变量定义时有类型声明的语言。</p> 
 <p>（1）变量的类型在编译的时候确定</p> 
 <p>（2）变量的类型在运行时不能修改，这样编译器就可以确定运行时<span style="color:#ff9900">需要的内存总量</span>。</p> 
 <p>         例如：C、Scala、Java、F#语言是静态类型语言。</p> 
 <p>2、<strong>动态类型语言</strong>：变量定义时无类型声明的语言。</p> 
 <p>（1）变量的类型在运行的时候确定</p> 
 <p>（2）变量的类型在运行可以修改</p> 
 <p>例如：python、Javascript、Ruby语言是动态类型语言。</p> 
</blockquote> 
<blockquote> 
 <p>3、<strong>强类型定义语言</strong></p> 
 <p>强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。</p> 
 <p>4、<strong>弱类型定义语言</strong></p> 
 <p>数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。</p> 
</blockquote> 
<p><img alt="" height="327" src="https://images2.imgbox.com/c9/ca/KTV7DSUu_o.png" width="482"></p> 
<p></p> 
<p>可以使用 <span style="color:#fe2c24">Solidity 语言</span>创建区块链上运行的投票、众筹、钱包等各种类型的<span style="color:#fe2c24">智能合约</span>。</p> 
<h3></h3> 
<h2 id="以太坊ethereum是什么">以太坊/Ethereum是什么?</h2> 
<p>以太坊是一个<span style="color:#ff9900">去中心化的</span>，<span style="color:#ff9900">运行智能合约</span>的<span style="color:#fe2c24">区块链平台</span>。</p> 
<p></p> 
<h2 id="以太坊ethereum虚拟机evm">以太坊/Ethereum虚拟机(EVM)</h2> 
<p>Ethereum 虚拟机，也称为EVM，是以太坊/Ethereum中智能合约的<span style="color:#fe2c24">运行时环境</span>。</p> 
<p>可以用某种语言，例如 <span style="color:#fe2c24">Solidity 语言</span>，开发智能合约程序，编译成以太坊(Ethereum)虚拟机支持的<strong><span style="color:#fe2c24">字节码/bytecode</span></strong>，然后该程序就可以在虚拟机中执行了。</p> 
<p></p> 
<h2 id="什么是智能合约">什么是智能合约?</h2> 
<p>智能合约（Smart contract ）是一种旨在以<span style="color:#fe2c24">信息化方式</span><span style="color:#ff9900">传播</span>、<span style="color:#ff9900">验证</span>或<span style="color:#ff9900">执行</span>合同的<span style="color:#fe2c24">计算机协议</span>。智能合约<span style="color:#fe2c24">允许在没有第三方的情况下进行可信交易</span>，这些交易<span style="color:#fe2c24"><strong>可追踪且不可逆转</strong></span>。智能合约概念于1995年由Nick Szabo首次提出。</p> 
<p>智能合约的目的是提供优于传统合约的安全方法，并减少与合约相关的其他交易成本。</p> 
<p>简单地说，智能合约可以理解为一个<span style="color:#fe2c24">自执行的协议</span>。智能合约可以自动处理协议的<span style="color:#fe2c24">履行、管理、以及支付。</span></p> 
<p>例如，可以编写这样一个智能合约：本月底之前，老王转账给小张1个以太币，这个智能合约部署后，就会在月底之前，<span style="color:#fe2c24">自动</span>把老王的1个以太币转账给小张，无需人为干预。</p> 
<h1 id="%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%8E%B0%E5%9C%A8%E4%B8%8D%E7%90%86%E8%A7%A3%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E4%B9%9F%E6%B2%A1%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E7%A8%8D%E5%90%8E%E4%BC%9A%E6%9B%B4%E8%AF%A6%E7%BB%86%E5%9C%B0%E8%AE%B2%E8%A7%A3%E3%80%82">如果你现在不理解智能合约也没关系，我们稍后会更详细地讲解。</h1> 
<hr> 
<h2></h2> 
<h1 id="solidity安装本地编译器">二.Solidity安装本地编译器</h1> 
<h3 id="安装本地编译器">安装本地编译器</h3> 
<h3 id="安装-nodejs-npm">安装 nodejs / npm</h3> 
<p><a class="link-info" href="https://nodejs.org/en/" title="node官方网站">node官方网站</a>下载node，推荐LTS版本，按提示完成安装，npm会同时装上。</p> 
<p>验证Node版本：</p> 
<pre><code>&gt; node -v
v10.16.3

&gt; npm -v
6.11.3
</code></pre> 
<h3></h3> 
<h3 id="安装-solidity-编译器-solc">安装 Solidity 编译器 solc</h3> 
<p>一旦安装了Node.js包管理器，就可以按照下面的步骤安装 Solidity 编译器</p> 
<pre><code>$ npm install -g solc@0.4.25
</code></pre> 
<p>上面的命令将安装solcjs程序，并使其在整个系统中都可用。</p> 
<p>验证solc安装：</p> 
<pre><code>$ solcjs --version
</code></pre> 
<p>如果一切顺利，这将打印如下内容</p> 
<pre><code>0.4.25+commit.c082d0b4.Emscripten.clang
</code></pre> 
<p>现在，可以使用本地的 solcjs 了，它比标准的 solidity 编译器少很多特性，但对于学习来说足够了。</p> 
<p></p> 
<hr> 
<h2></h2> 
<h1 id="基本语法">三.基本语法</h1> 
<p>一个 Solidity 源文件可以包含<span style="color:#fe2c24">任意数量的合约定义</span>、<span style="color:#fe2c24">import指令</span>和<span style="color:#fe2c24">pragma指令</span>。</p> 
<p>让我们从一个简单的 Solidity 源程序开始。下面是一个 Solidity 源文件的例子：</p> 
<p><img alt="" height="412" src="https://images2.imgbox.com/ba/ab/aBfLMgxS_o.png" width="461"></p> 
<p></p> 
<h3 id="pragma">Pragma</h3> 
<p>第一行是pragma指令，它告诉我们源代码是为Solidity version 0.4.25版本编写的。</p> 
<p>pragma指令只对自己的源文件起作用，如果把文件B导入到文件A，文件B的pragma将不会自动应用于文件A。</p> 
<pre><code>pragma solidity ^0.4.0;
</code></pre> 
<p>上面的pragma指令意思是，源文件不能用低于0.4.0版本的编译器编译，也不能用0.5.0版本及以上版本的编译器编译。</p> 
<p>这里第二个条件是用<code>^</code>加上的，表示不超过0.5.0版本，背后的意思是，0.4.0 ~ 0.4.9 之间的小版本改动通常不会有破坏性更改，源代码应该都是兼容的。</p> 
<p></p> 
<h3 id="contract智能合约">Contract/智能合约</h3> 
<p>智能合约是位于以太坊区块链上<span style="color:#ff9900">特定地址的代码(函数)</span>和<span style="color:#ff9900">数据(状态)</span>的<span style="color:#fe2c24">集合</span>。</p> 
<p>这行代码：<code>uint </code>number<code>;</code>，声明了一个名为<span style="color:#0d0016"><strong>number</strong></span>的状态变量，类型为<code>uint，</code><span style="color:#fe2c24"><code>set</code>和<code>get</code>函数</span>可用于修改或检索变量的值。</p> 
<h3></h3> 
<h3 id="导入文件">导入文件</h3> 
<p>上面的例子没有import语句，但是Solidity 支持与JavaScript非常相似的导入语句。</p> 
<p>下面的语句从“filename”导入所有全局符号。</p> 
<pre><code>import "filename";
</code></pre> 
<p>下面的示例，创建一个新的全局符号<code>symbolName</code>，它的成员都是来自“filename”的全局符号。</p> 
<pre><code>import * as symbolName from "filename";
</code></pre> 
<p>要从<span style="color:#fe2c24">当前目录</span>导入文件x，请使用<code>import "./x"</code>。如果<span style="color:#fe2c24">不指定当前路径</span>，可能会在全局“include目</p> 
<p>；录”中引用另一个文件。</p> 
<h3></h3> 
<h3 id="保留关键字">保留关键字</h3> 
<p>下面是 Solidity 语言中的保留关键字：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr>
<td>abstract</td>
<td><strong>auto</strong></td>
<td><strong>case</strong></td>
<td><strong>default</strong></td>
<td><strong>final</strong></td>
</tr>
<tr>
<td>after</td>
<td>immutable</td>
<td>implements</td>
<td>in</td>
<td>inline</td>
</tr>
<tr>
<td>alias</td>
<td><strong>let</strong></td>
<td>macro</td>
<td>match</td>
<td>mutable</td>
</tr>
<tr>
<td>apply</td>
<td>null</td>
<td>of</td>
<td>override</td>
<td>partial</td>
</tr>
<tr>
<td>catch</td>
<td>promise</td>
<td>reference</td>
<td>relocatable</td>
<td>sealed</td>
</tr>
<tr>
<td>copyof</td>
<td>sizeof</td>
<td><strong>static</strong></td>
<td><strong>supports</strong></td>
<td>switch</td>
</tr>
<tr>
<td><strong>define</strong></td>
<td>try</td>
<td>typedef</td>
<td>typeof</td>
<td>unchecked</td>
</tr>
</tbody></table> 
<p></p> 
<hr> 
<h2></h2> 
<h2 id="第一个程序">四、第一个程序</h2> 
<p>为简单起见，我们使用在线Solidity开发工具<a href="https://remix.ethereum.org/" title="Remix IDE">Remix IDE</a>编译和运行Solidity程序。</p> 
<p><strong>第1步</strong> – 在<code>File explorers</code>选项卡下，新建一个test1.sol文件，代码如下：</p> 
<p><strong>示例</strong></p> 
<pre><code>pragma solidity ^0.5.0;
contract SolidityTest {
   constructor() public{
   }
   
   function getResult() public view returns(uint){
      uint a = 1;
      uint b = 2;
      uint result = a + b;
      return result;
   }
}
</code></pre> 
<p><strong>第2步</strong> – 在<code>Compiler</code>选项卡下，单击 <strong>Compile</strong> 按钮，开始<span style="color:#fe2c24">编译</span><br><strong>第3步</strong> – 在<code>Run</code>选项卡下，单击 <strong>Deploy</strong> 按钮进行<span style="color:#fe2c24">部署</span><br><strong>第4步</strong> – 在<code>Run</code>选项卡下，选择 <strong>SolidityTest at 0x…</strong> 下拉<br><strong>第5步</strong> – 单击 <strong>getResult</strong> 按钮显示结果。</p> 
<p><strong>输出</strong></p> 
<pre><code>0: uint256: 3</code></pre> 
<p></p> 
<h2 id="代码注释">五、代码注释</h2> 
<p>Solidity 支持c风格和c++风格的注释。</p> 
<ul>
<li>
<code>//</code>之后到行尾的文本，都被看作注释，编译器忽略此内容，”<strong>ctrl+/</strong>“</li>
<li>
<code>/*</code> 与 <code>*/</code> 之间的文本被看作注释， 编译器忽略此内容， ”<strong>shift+ctrl+a</strong>“</li>
</ul> 
<p><strong>示例</strong></p> 
<pre><code>function getResult() public view returns(uint){
   // 这是一行注释，类似于c++中的注释

   /*
    * 这是多行注释
    * 类似于c语言中的注释
    */
   uint a = 1;
   uint b = 2;
   uint result = a + b;
   return result;
}</code></pre> 
<h2></h2> 
<h2 id="数据类型">六、数据类型</h2> 
<p>在用任何语言编写程序时，都需要使用<span style="color:#fe2c24">变量</span>来<span style="color:#fe2c24">存储各种信息</span>。变量是<span style="color:#fe2c24">内存空间的名称</span>，变量有不同类型，例如整型、字符串类型等等。操作系统根据变量的数据类型分配内存。</p> 
<p>Solidity中，变量类型有以下几大类：</p> 
<ul>
<li>值类型</li>
<li>地址类型</li>
<li>引用类型</li>
</ul> 
<h3 id="值类型">1.值类型</h3> 
<table>
<thead><tr>
<th>类型</th>
<th>保留字</th>
<th>取值</th>
</tr></thead>
<tbody>
<tr>
<td>布尔型</td>
<td>bool</td>
<td>true/false</td>
</tr>
<tr>
<td>整型</td>
<td>int/uint</td>
<td>有符号整数/无符号整数。</td>
</tr>
<tr>
<td>整型</td>
<td>int8 to int256</td>
<td>8位到256位的带符号整型数。int256与int相同。</td>
</tr>
<tr>
<td>整型</td>
<td>uint8 to uint256</td>
<td>8位到256位的无符号整型。uint256和uint是一样的。</td>
</tr>
<tr>
<td>定长浮点型</td>
<td>fixed/unfixed</td>
<td>有符号和无符号的定长浮点型</td>
</tr>
<tr>
<td>定长浮点型</td>
<td>fixedMxN</td>
<td>带符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td>
</tr>
<tr>
<td>定长浮点型</td>
<td>ufixedMxN</td>
<td>无符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td>
</tr>
</tbody>
</table> 
<h3></h3> 
<h3 id="地址类型">2.地址类型</h3> 
<p>地址类型表示<span style="color:#fe2c24">以太坊地址</span>，长度为20字节。地址可以使用<strong><span style="color:#fe2c24"><code>.balance</code>方法</span></strong>获得<span style="color:#fe2c24">余额</span>，也可以使用<strong><span style="color:#fe2c24"><code>.transfer</code>方法</span></strong>将余额<span style="color:#fe2c24">转到另一个地址</span>。</p> 
<pre><code>address x = 0x212;
address myAddress = this;

if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) 
    x.transfer(10);
</code></pre> 
<h3></h3> 
<h3 id="引用类型复合数据类型">3.引用类型/复合数据类型</h3> 
<p>Solidity中，有一些数据类型由<span style="color:#fe2c24"><strong>值类型组合</strong></span>而成，相比于简单的值类型，这些类型通常通过<span style="color:#fe2c24">名称引用</span>，被称为<span style="color:#fe2c24">引用类型</span>。</p> 
<p>引用类型包括：</p> 
<ul>
<li>数组 (字符串与bytes是特殊的数组，所以也是引用类型)</li>
<li>struct (结构体)</li>
<li>map (映射)</li>
</ul> 
<p></p> 
<p></p> 
<p></p> 
<h1 id="变量">七、变量</h1> 
<p>Solidity 支持三种类型的变量：</p> 
<ul>
<li>
<strong>状态变量</strong> – 变量值永久保存在<span style="color:#fe2c24">合约存储空间中的</span>变量。</li>
<li>
<strong>局部变量</strong> – 变量值<span style="color:#fe2c24">仅在函数执行过程中有效的</span>变量，函数退出后，变量无效。</li>
<li>
<strong>全局变量</strong> – 保存在<span style="color:#fe2c24">全局命名空间</span>，用于获取<span style="color:#fe2c24">区块链相关信息的特殊变量</span>。</li>
</ul> 
<p>Solidity 是一种静态类型语言，这意味着需要<span style="color:#ff9900">在声明期间指定变量类型</span>。每个变量声明时，都有一个基于其类型的<span style="color:#ff9900">默认值</span>。没有<code>undefined</code>或<code>null</code>的概念。</p> 
<h3 id="状态变量">1.状态变量</h3> 
<p>变量值永久保存在合约存储空间中的变量。</p> 
<pre><code>pragma solidity ^0.5.0;
contract SolidityTest {
   uint storedData;      // 状态变量
   constructor() public {
      storedData = 10;   // 使用状态变量
   }
}
</code></pre> 
<p></p> 
<h3 id="局部变量">2.局部变量</h3> 
<p>变量值仅在函数执行过程中有效的变量，函数退出后，变量无效。函数参数是局部变量。</p> 
<pre><code>pragma solidity ^0.5.0;
contract SolidityTest {
   uint storedData; // 状态变量
   constructor() public {
      storedData = 10;   
   }
   function getResult() public view returns(uint){
      uint a = 1; // 局部变量
      uint b = 2;
      uint result = a + b;
      return result; // 访问局部变量
   }
}
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code>pragma solidity ^0.5.0;
contract SolidityTest {
   uint storedData; // 状态变量
   constructor() public {
      storedData = 10;   
   }
   function getResult() public view returns(uint){
      uint a = 1; // 局部变量
      uint b = 2;
      uint result = a + b;
      return storedData; // 访问状态变量
   }
}
</code></pre> 
<p>可以使用 Solidity 第一个程序中的步骤，运行上述程序。</p> 
<p>输出</p> 
<pre><code>0: uint256: 10
</code></pre> 
<h3></h3> 
<h3 id="全局变量">3.全局变量</h3> 
<p>这些是全局工作区中存在的特殊变量，提供有关区块链和交易属性的信息。</p> 
<table>
<thead><tr>
<th>名称</th>
<th>返回</th>
</tr></thead>
<tbody>
<tr>
<td>blockhash(uint blockNumber) returns (bytes32)</td>
<td>给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</td>
</tr>
<tr>
<td>block.coinbase (address payable)</td>
<td>当前区块矿工的地址</td>
</tr>
<tr>
<td>block.difficulty (uint)</td>
<td>当前区块的难度</td>
</tr>
<tr>
<td>block.gaslimit (uint)</td>
<td>当前区块的gaslimit</td>
</tr>
<tr>
<td>block.number (uint)</td>
<td>当前区块的number</td>
</tr>
<tr>
<td>block.timestamp (uint)</td>
<td>当前区块的时间戳，为unix纪元以来的秒</td>
</tr>
<tr>
<td>gasleft() returns (uint256)</td>
<td>剩余 gas</td>
</tr>
<tr>
<td>msg.data (bytes calldata)</td>
<td>完成 calldata</td>
</tr>
<tr>
<td>msg.sender (address payable)</td>
<td>消息发送者 (当前 caller)</td>
</tr>
<tr>
<td>msg.sig (bytes4)</td>
<td>calldata的前四个字节 (function identifier)</td>
</tr>
<tr>
<td>msg.value (uint)</td>
<td>当前消息的wei值</td>
</tr>
<tr>
<td>now (uint)</td>
<td>当前块的时间戳</td>
</tr>
<tr>
<td>tx.gasprice (uint)</td>
<td>交易的gas价格</td>
</tr>
<tr>
<td>tx.origin (address payable)</td>
<td>交易的发送方</td>
</tr>
</tbody>
</table> 
<h3></h3> 
<h3 id="solidity-变量名">Solidity 变量名</h3> 
<p>在为变量<span style="color:#fe2c24">命名</span>时，请记住以下规则</p> 
<ul>
<li>不应使用 Solidity 保留<span style="color:#fe2c24">关键字</span>作为变量名。例如，<code>break</code>或<code>boolean</code>变量名无效。</li>
<li>不应以数字(0-9)<span style="color:#fe2c24">开头</span>，必须以字母或下划线开头。例如，<code>123test</code>是一个无效的变量名，但是<code>_123test</code>是一个有效的变量名。</li>
<li>变量名<span style="color:#fe2c24">区分大小写</span>。例如，<code>Name</code>和<code>name</code>是两个不同的变量。</li>
</ul> 
<p></p> 
<p></p> 
<h1 id="变量作用域">八、变量作用域</h1> 
<p>局部变量的作用域<span style="color:#fe2c24">仅限于定义它们的函数</span>，但是<span style="color:#fe2c24">状态变量</span>可以有三种作用域类型。</p> 
<ul>
<li>
<strong>Public</strong> – 公共状态变量可以在内部访问，也可以通过消息访问。对于公共状态变量，将生成一个<span style="color:#fe2c24">自动getter函数</span>。</li>
<li>
<strong>Internal</strong> – <span style="color:#fe2c24">内部</span>状态变量只能从<span style="color:#fe2c24">当前合约或其派生合约内</span>访问。</li>
<li>
<strong>Private</strong> – <span style="color:#fe2c24">私有</span>状态变量只能从<span style="color:#fe2c24">当前合约内部</span>访问，派生合约内不能访问。</li>
</ul> 
<p><strong>示例</strong></p> 
<pre><code>pragma solidity ^0.5.0;
contract C {
   uint public data = 30;
   uint internal iData= 10;

   function x() public returns (uint) {
      data = 3; // 内部访问
      return data;
   }
}
contract Caller {
   C c = new C();
   function f() public view returns (uint) {
      return c.data(); // 外部访问
   }
}
contract D is C {
   uint storedData; // 状态变量

   function y() public returns (uint) {
      iData = 3; // 派生合约内部访问
      return iData;
   }
   function getResult() public view returns(uint){
      uint a = 1; // 局部变量
      uint b = 2;
      uint result = a + b;
      return storedData; // 访问状态变量
   }
}</code></pre> 
<p></p> 
<h1 id="运算符">九、运算符</h1> 
<h3 id="算术运算符">1.算术运算符</h3> 
<p>Solidity 支持的算术运算符，如下表所示：</p> 
<p>假设变量A的值为10，变量B的值为20。</p> 
<table>
<thead><tr>
<th>序号</th>
<th>运算符与描述</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>
<strong>+ (加)</strong> 求和 <strong>例:</strong> A + B = 30</td>
</tr>
<tr>
<td>2</td>
<td>
<strong>– (减)</strong> 相减 <strong>例:</strong> A – B = -10</td>
</tr>
<tr>
<td>3</td>
<td>*** (乘)** 相乘 <strong>例:</strong> A * B = 200</td>
</tr>
<tr>
<td>4</td>
<td>
<strong>/ (除)</strong> 相除 <strong>例:</strong> B / A = 2</td>
</tr>
<tr>
<td>5</td>
<td>
<strong>% (取模)</strong> 取模运算 <strong>例:</strong> B % A = 0</td>
</tr>
<tr>
<td>6</td>
<td>
<strong>++ (递增)</strong> 递增 <strong>例:</strong> A++ = 11</td>
</tr>
<tr>
<td>7</td>
<td>
<strong>— (递减)</strong> 递减 <strong>例:</strong> A– = 9</td>
</tr>
<tr>
<td>8</td>
<td>
<strong><code>**</code>(乘方)</strong> 例：2**2 = 4</td>
</tr>
</tbody>
</table> 
<p><strong>示例</strong></p> 
<p>下面的代码展示了如何使用算术运算符。</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   constructor() public{
   }
   function getResult() public view returns(uint){
      uint a = 1; 
      uint b = 2;
      uint result = a + b; // 算术运算
      return result; 
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: uint256: 3
</code></pre> 
<h3></h3> 
<h3 id="比较运算符">2.比较运算符</h3> 
<p>Solidity 支持的比较运算符，如下表所示：</p> 
<table>
<thead><tr>
<th>序号</th>
<th>运算符与描述</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td><strong>== (等于)</strong></td>
</tr>
<tr>
<td>2</td>
<td><strong>!= (不等于)</strong></td>
</tr>
<tr>
<td>3</td>
<td><strong>&gt; (大于)</strong></td>
</tr>
<tr>
<td>4</td>
<td><strong>&lt; (小于)</strong></td>
</tr>
<tr>
<td>5</td>
<td><strong>&gt;= (大于等于)</strong></td>
</tr>
<tr>
<td>6</td>
<td><strong>&lt;= (小于等于)</strong></td>
</tr>
</tbody>
</table> 
<p>下面的代码展示了如何使用比较运算符。</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; 
   constructor() public{
      storedData = 10;   
   }
   function getResult() public view returns(string memory){
      uint a = 1; // 局部变量
      uint b = 2;
      uint result = a + b;
      return integerToString(result); 
   }
   function integerToString(uint _i) internal pure 
      returns (string memory _uintAsString) {

      if (_i == 0) {   // 比较运算符
         return "0";
      }
      uint j = _i;
      uint len;

      while (j != 0) {  // 比较运算符
         len++;
         j /= 10;
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;

      while (_i != 0) {
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;
      }
      return string(bstr);// 访问局部变量
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 3
</code></pre> 
<h3></h3> 
<h3 id="逻辑运算符">3.逻辑运算符</h3> 
<p>Solidity 支持的逻辑运算符，如下表所示：</p> 
<p>假设变量A的值为10，变量B的值为20。</p> 
<table>
<thead><tr>
<th>序号</th>
<th>运算符与描述</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>
<strong>&amp;&amp; (逻辑与)</strong> 如果两个操作数都非零，则条件为真。 <strong>例:</strong> (A &amp;&amp; B) 为真</td>
</tr>
<tr>
<td>2</td>
<td>
<strong>|| (逻辑或)</strong> 如果这两个操作数中有一个非零，则条件为真。 <strong>例:</strong> (A || B) 为真</td>
</tr>
<tr>
<td>3</td>
<td>
<strong>! (逻辑非)</strong> 反转操作数的逻辑状态。如果条件为真，则逻辑非操作将使其为假。 <strong>例:</strong> ! (A &amp;&amp; B) 为假</td>
</tr>
</tbody>
</table> 
<p><strong>示例</strong></p> 
<p>下面的代码展示了如何使用逻辑运算符</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; // 状态变量
   constructor() public{
      storedData = 10;   
   }
   function getResult() public view returns(string memory){
      uint a = 1; // 局部变量
      uint b = 2;
      uint result = a + b;
      return integerToString(storedData); // 访问状态变量
   }
   function integerToString(uint _i) internal pure 
      returns (string memory) {

      if (_i == 0) {
         return "0";
      }
      uint j = _i;
      uint len;

      while (!(j == 0)) {  // 逻辑运算符
         len++;
         j /= 10;
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;

      while (_i != 0) {
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;
      }
      return string(bstr);
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 3
</code></pre> 
<h3></h3> 
<h3 id="位运算符">4.位运算符</h3> 
<p>Solidity 支持的位运算符，如下表所示：</p> 
<p>假设变量A的值为2，变量B的值为3。</p> 
<table>
<thead><tr>
<th>序号</th>
<th>运算符与描述</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>
<strong>&amp; (位与)</strong> 对其整数参数的每个位执行位与操作。 <strong>例:</strong> (A &amp; B) 为 2.</td>
</tr>
<tr>
<td>2</td>
<td>
<strong>| (位或)</strong> 对其整数参数的每个位执行位或操作。 <strong>例:</strong> (A | B) 为 3.</td>
</tr>
<tr>
<td>3</td>
<td>
<strong>^ (位异或)</strong> 对其整数参数的每个位执行位异或操作。 <strong>例:</strong> (A ^ B) 为 1.</td>
</tr>
<tr>
<td>4</td>
<td>
<strong>~ (位非)</strong> 一元操作符，反转操作数中的所有位。 <strong>例:</strong> (~B) 为 -4.</td>
</tr>
<tr>
<td>5</td>
<td>
<strong>&lt;&lt; (左移位))</strong> 将第一个操作数中的所有位向左移动，移动的位置数由第二个操作数指定，新的位由0填充。将一个值向左移动一个位置相当于乘以2，移动两个位置相当于乘以4，以此类推。 <strong>例:</strong> (A &lt;&lt; 1) 为 4.</td>
</tr>
<tr>
<td>6</td>
<td>
<strong>&gt;&gt; (右移位)</strong> 左操作数的值向右移动，移动位置数量由右操作数指定 <strong>例:</strong> (A &gt;&gt; 1) 为 1.</td>
</tr>
</tbody>
</table> 
<p><strong>示例</strong></p> 
<p>下面的代码展示了如何使用位运算符</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; 
   constructor() public{
      storedData = 10;   
   }
   function getResult() public view returns(string memory){
      uint a = 2; // 局部变量
      uint b = 2;
      uint result = a &amp; b;  // 位与
      return integerToString(result); 
   }
   function integerToString(uint _i) internal pure 
      returns (string memory) {
      if (_i == 0) {
         return "0";
      }
      uint j = _i;
      uint len;

      while (j != 0) {
         len++;
         j /= 10;
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;

      while (_i != 0) {
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;
      }
      return string(bstr);// 访问局部变量
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 2
</code></pre> 
<h3></h3> 
<h3 id="赋值运算符">5.赋值运算符</h3> 
<p>Solidity 支持的赋值运算符，如下表所示：</p> 
<table>
<thead><tr>
<th>序号</th>
<th>运算符与描述</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
<td>
<strong>= (简单赋值)</strong> 将右侧操作数的值赋给左侧操作数 <strong>例:</strong> C = A + B 表示 A + B 赋给 C</td>
</tr>
<tr>
<td>2</td>
<td>
<strong>+= (相加赋值)</strong> 将右操作数添加到左操作数并将结果赋给左操作数。 <strong>例:</strong> C += A 等价于 C = C + A</td>
</tr>
<tr>
<td>3</td>
<td>
<strong>−= (相减赋值)</strong> 从左操作数减去右操作数并将结果赋给左操作数。 <strong>例:</strong> C -= A 等价于 C = C – A</td>
</tr>
<tr>
<td>4</td>
<td>*<strong>= (相乘赋值)</strong> 将右操作数与左操作数相乘，并将结果赋给左操作数。 <strong>例:</strong> C *= A 等价于 C = C * A</td>
</tr>
<tr>
<td>5</td>
<td>
<strong>/= (相除赋值)</strong> 将左操作数与右操作数分开，并将结果分配给左操作数。 <strong>例:</strong> C /= A 等价于 C = C / A</td>
</tr>
<tr>
<td>6</td>
<td>
<strong>%= (取模赋值)</strong> 使用两个操作数取模，并将结果赋给左边的操作数。 <strong>例:</strong> C %= A 等价于 C = C % A</td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p><strong>注意</strong> – 同样的逻辑也适用于位运算符，因此它们将变成<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>|=</code>和<code>^=</code>。</p> 
</blockquote> 
<p>下面的代码展示了如何使用赋值运算符。</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; 
   constructor() public{
      storedData = 10;   
   }
   function getResult() public view returns(string memory){
      uint a = 1; 
      uint b = 2;
      uint result = a + b;
      return integerToString(storedData); 
   }
   function integerToString(uint _i) internal pure 
      returns (string memory) {
      if (_i == 0) {
         return "0";
      }
      uint j = _i;
      uint len;
      while (j != 0) {
         len++;
         j /= 10; // 赋值运算
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;
      while (_i != 0) {
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;// 赋值运算
      }
      return string(bstr);  // 访问局部变量
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 10
</code></pre> 
<h3></h3> 
<h3 id="条件运算符">6.条件运算符</h3> 
<p>Solidity 支持条件运算符。</p> 
<table>
<thead><tr>
<th>序号</th>
<th>运算符与描述</th>
</tr></thead>
<tbody><tr>
<td>1</td>
<td>
<strong>? : (条件运算符 )</strong> 如果条件为真 ? 则取值X : 否则值Y</td>
</tr></tbody>
</table> 
<p><strong>示例</strong></p> 
<p>下面的代码展示了如何使用这个运算符</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; 
   constructor() public{
      storedData = 10;   
   }
   function getResult() public view returns(string memory){
      uint a = 1; // 局部变量
      uint b = 2;
      uint result = (a &gt; b? a: b);  //条件运算
      return integerToString(result); 
   }
   function integerToString(uint _i) internal pure 
      returns (string memory) {
      if (_i == 0) {
         return "0";
      }
      uint j = _i;
      uint len;
      while (j != 0) {
         len++;
         j /= 10;
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;
      while (_i != 0) {
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;
      }
      return string(bstr);
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 2</code></pre> 
<p></p> 
<h1 id="循环语句">十、循环语句</h1> 
<h3 id="while-循环">1.while 循环</h3> 
<p>语法</p> 
<p>Solidity 中， while循环的语法如下：</p> 
<pre><code>while (表达式) {
   被执行语句(如果表示为真)
}
</code></pre> 
<p>示例</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; 
   constructor() public{
      storedData = 10;   
   }
   function getResult() public view returns(string memory){
      uint a = 10; 
      uint b = 2;
      uint result = a + b;
      return integerToString(result); 
   }
   function integerToString(uint _i) internal pure 
      returns (string memory) {

      if (_i == 0) {
         return "0";
      }
      uint j = _i;
      uint len;

      while (j != 0) {
         len++;
         j /= 10;
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;

      while (_i != 0) { // while 循环
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;
      }
      return string(bstr);
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 12
</code></pre> 
<h3></h3> 
<h3 id="dowhile-循环">2.do...while 循环</h3> 
<p>语法</p> 
<p>Solidity 中， do…while循环的语法如下：</p> 
<pre><code>do {
   被执行语句(如果表示为真)
} while (表达式);
</code></pre> 
<blockquote> 
 <p><strong>注意</strong>: 不要漏掉 do 后面的分号</p> 
</blockquote> 
<p>示例</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; 
   constructor() public{
      storedData = 10;   
   }
   function getResult() public view returns(string memory){
      uint a = 10; 
      uint b = 2;
      uint result = a + b;
      return integerToString(result); 
   }
   function integerToString(uint _i) internal pure 
      returns (string memory) {

      if (_i == 0) {
         return "0";
      }
      uint j = _i;
      uint len;

      while (j != 0) {
         len++;
         j /= 10;
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;

      do {                   // do while 循环 
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;
      }
      while (_i != 0);
      return string(bstr);
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 12
</code></pre> 
<h3 id="for-循环">3.for 循环</h3> 
<p>语法</p> 
<p>Solidity 中， for循环的语法如下：</p> 
<pre><code>for (初始化; 测试条件; 迭代语句) {
   被执行语句(如果表示为真)
}
</code></pre> 
<p>示例</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; 
   constructor() public{
      storedData = 10;   
   }

   function getResult() public view returns(string memory){
      uint a = 10; 
      uint b = 2;
      uint result = a + b;
      return integerToString(result); 
   }

   function integerToString(uint _i) internal pure 
      returns (string memory) {
      if (_i == 0) {
         return "0";
      }
      uint j=0;
      uint len;
      for (j = _i; j != 0; j /= 10) {  //for循环的例子
         len++;         
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;
      while (_i != 0) {
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;
      }
      return string(bstr);//访问局部变量
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 12
</code></pre> 
<h3></h3> 
<h3 id="break-和-continue">4.break 和 continue</h3> 
<ul>
<li>
<code>continue</code> – 跳出<span style="color:#fe2c24">本次</span>循环，继续执行接下来的循环</li>
<li>
<code>break</code> – 跳出<span style="color:#fe2c24"><strong>循环</strong></span>(或跳出<span style="color:#fe2c24">代码块</span>)</li>
</ul> 
<p>break 示例</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; 
   constructor() public{
      storedData = 10;   
   }
   function getResult() public view returns(string memory){
      uint a = 1; 
      uint b = 2;
      uint result = a + b;
      return integerToString(result); 
   }
   function integerToString(uint _i) internal pure 
      returns (string memory) {

      if (_i == 0) {
         return "0";
      }
      uint j = _i;
      uint len;

      while (true) {
         len++;
         j /= 10;
         if(j==0){
            break;   // break 语句跳出循环
         }
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;

      while (_i != 0) {
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;
      }
      return string(bstr);
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 3
</code></pre> 
<p>continue 示例</p> 
<pre><code>pragma solidity ^0.5.0;

contract SolidityTest {
   uint storedData; 
   constructor() public{
      storedData = 10;   
   }
   function getResult() public view returns(string memory){
      uint n = 1;
      uint sum = 0;

      while( n &lt; 10){
         n++;
         if(n == 5){
            continue; // 当n的和是5时，跳过n。
         }
         sum = sum + n;
      }
      return integerToString(sum); 
   }
   function integerToString(uint _i) internal pure 
      returns (string memory) {

      if (_i == 0) {
         return "0";
      }
      uint j = _i;
      uint len;

      while (true) {
         len++;
         j /= 10;
         if(j==0){
            break;   // break跳出循环
         }
      }
      bytes memory bstr = new bytes(len);
      uint k = len - 1;

      while (_i != 0) {
         bstr[k--] = byte(uint8(48 + _i % 10));
         _i /= 10;
      }
      return string(bstr);
   }
}
</code></pre> 
<p>输出</p> 
<pre><code>0: string: 49	</code></pre> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>