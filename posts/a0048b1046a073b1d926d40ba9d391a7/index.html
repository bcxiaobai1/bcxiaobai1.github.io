<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>从零开始用 Python 构建一个简单的神经网络 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从零开始用 Python 构建一个简单的神经网络</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <h2 id="Linearly-Separable-Data-Sets"><span style="background-color:#3777ad"><span style="color:#ffffff">线性可分数据集</span></span></h2> 
<p style="text-align:center"><img alt="鸡蛋上的神经网络作为神经网络的符号从零开始" height="388" src="https://images2.imgbox.com/83/2f/427YA1te_o.png" width="300"></p> 
<p><span style="color:#000000">正如我们在机器学习教程的前一章中所展示的，仅由一个感知器组成的神经网络足以分离我们的示例类。当然，我们精心设计了这些类以使其工作。有许多类集群，对于它们不起作用。我们将查看其他一些示例，并将讨论无法分离类的情况。</span></p> 
<p><span style="color:#000000">我们的类是线性可分的。<strong>线性可分性</strong>在欧几里得几何中有意义。两组点（或类）称为<strong>线性可分的</strong>，如果平面中至少存在一条直线，使得一类的所有点都在直线的一侧，而另一类的所有点都在另一侧边。</span></p> 
<p><span style="color:#000000">更正式的：</span></p> 
<p><span style="color:#000000">如果两个数据簇（类）可以通过线性方程形式的决策边界分开</span></p> 
<p><span style="color:#000000">∑一世=1nX一世⋅瓦一世=0</span></p> 
<p><span style="color:#000000">它们被称为线性可分。</span></p> 
<p><span style="color:#000000">否则，即如果这样的决策边界不存在，则这两个类被称为线性不可分。在这种情况下，我们不能使用简单的神经网络。</span></p> 
<h2 id="Perceptron-for-the-AND-Function"><span style="background-color:#3777ad"><span style="color:#ffffff">AND 函数的感知器</span></span></h2> 
<p><span style="color:#000000">在我们的下一个示例中，我们将用 Python 编写一个神经网络，它实现逻辑“与”函数。它按以下方式为两个输入定义：</span></p> 
<table border="1" cellspacing="0">
<thead><tr>
<th style="vertical-align:top">输入1</th>
<th style="vertical-align:top">输入2</th>
<th style="vertical-align:top">输出</th>
</tr></thead>
<tbody>
<tr>
<td style="border-color:#999999;vertical-align:top">0</td>
<td style="border-color:#999999;vertical-align:top">0</td>
<td style="border-color:#999999;vertical-align:top">0</td>
</tr>
<tr>
<td style="border-color:#999999;vertical-align:top">0</td>
<td style="border-color:#999999;vertical-align:top">1</td>
<td style="border-color:#999999;vertical-align:top">0</td>
</tr>
<tr>
<td style="border-color:#999999;vertical-align:top">1</td>
<td style="border-color:#999999;vertical-align:top">0</td>
<td style="border-color:#999999;vertical-align:top">0</td>
</tr>
<tr>
<td style="border-color:#999999;vertical-align:top">1</td>
<td style="border-color:#999999;vertical-align:top">1</td>
<td style="border-color:#999999;vertical-align:top">1</td>
</tr>
</tbody>
</table>
<p><span style="color:#000000">我们在上一章中了解到，具有一个感知器和两个输入值的神经网络可以解释为决策边界，即划分两个类别的直线。我们要在示例中分类的两个类如下所示：</span></p> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>matplotlib.pyplot</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>plt</strong></span>
<span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>numpy</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>np</strong></span>

图,  ax  <span style="color:#666666">= </span> plt <span style="color:#666666">。</span>子图() 
xmin ,  xmax  <span style="color:#666666">= </span> <span style="color:#666666">- </span>0.2 ,  1.4 
X  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>arange ( xmin ,  xmax ,  0.1 ) 
ax <span style="color:#666666">。</span>scatter ( 0 ,  0 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>scatter ( 0 ,  1 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>分散（1 ,  0 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>scatter ( 1 ,  1 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"g" </span>) 
ax <span style="color:#666666">。</span>set_xlim ([ xmin ,  xmax ]) 
ax <span style="color:#666666">。</span>set_ylim ([ <span style="color:#666666">- </span>0.1 ,  1.1 ]) 
m  <span style="color:#666666">= </span> <span style="color:#666666">- </span>1 
<span style="color:#408080"><em>#ax.plot(X, m * X + 1.2, label="decision boundary") </em></span>
plt <span style="color:#666666">. </span>情节()
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：</strong></span></span></h3> 
 <div> 
  <p><img alt="" height="248" src="https://images2.imgbox.com/c1/2d/giKaF6Zn_o.png" width="380"></p> 
 </div> 
</div> 
<p><span style="color:#000000">我们还发现，这样一个原始的神经网络只能创建穿过原点的直线。所以分割线是这样的：</span></p> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>matplotlib.pyplot</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>plt</strong></span>
<span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>numpy</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>np</strong></span>

图,  ax  <span style="color:#666666">= </span> plt <span style="color:#666666">。</span>子图() 
xmin ,  xmax  <span style="color:#666666">= </span> <span style="color:#666666">- </span>0.2 ,  1.4 
X  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>arange ( xmin ,  xmax ,  0.1 ) 
ax <span style="color:#666666">。</span>set_xlim ([ xmin ,  xmax ]) 
ax <span style="color:#666666">。</span>set_ylim ([ <span style="color:#666666">- </span>0.1 ,  1.1 ]) 
m  <span style="color:#666666">= </span> <span style="color:#666666">- </span>1 
<span style="color:#008000"><strong>for </strong></span> m  <span style="color:#aa22ff"><strong>in </strong></span> np <span style="color:#666666">。</span>范围（0 ,  6 ,  0.1 ): 
    ax <span style="color:#666666">。</span>绘图( X ,  m  <span style="color:#666666">* </span> X  ) 
ax <span style="color:#666666">。</span>scatter ( 0 ,  0 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>scatter ( 0 ,  1 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>scatter ( 1 ,  0 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>分散( 1,  1 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"g" </span>) 
plt <span style="color:#666666">. </span>情节()
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：  </strong></span></span></h3> 
 <div> 
  <p><img alt="" height="248" src="https://images2.imgbox.com/34/35/5OUthqSY_o.png" width="380"></p> 
 </div> 
</div> 
<p><span style="color:#000000">我们可以看到，这些直线都不能用作决策边界，也不能用作穿过原点的任何其他直线。</span></p> 
<p><span style="color:#000000">我们需要一条线</span></p> 
<p><span style="color:#000000">是=米⋅X+C其中截距<code>c</code>不等于 0。</span></p> 
<p><span style="color:#000000">例如线</span></p> 
<p><span style="color:#000000">是=-X+1.2</span></p> 
<p><span style="color:#000000">可以用作我们问题的分隔线：</span></p> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>matplotlib.pyplot</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>plt</strong></span>
<span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>numpy</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>np</strong></span>

图,  ax  <span style="color:#666666">= </span> plt <span style="color:#666666">。</span>子图() 
xmin ,  xmax  <span style="color:#666666">= </span> <span style="color:#666666">- </span>0.2 ,  1.4 
X  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>arange ( xmin ,  xmax ,  0.1 ) 
ax <span style="color:#666666">。</span>scatter ( 0 ,  0 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>scatter ( 0 ,  1 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>分散（1 ,  0 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>scatter ( 1 ,  1 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"g" </span>) 
ax <span style="color:#666666">。</span>set_xlim ([ xmin ,  xmax ]) 
ax <span style="color:#666666">。</span>set_ylim ([ <span style="color:#666666">- </span>0.1 ,  1.1 ]) 
m ,  c  <span style="color:#666666">= </span> <span style="color:#666666">- </span>1 ,  1.2 
ax <span style="color:#666666">。</span>绘图( X ,  m  <span style="color:#666666">* </span> X  <span style="color:#666666">+ </span> c  )
PLT <span style="color:#666666">。</span>情节()
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：  </strong></span></span></h3> 
 <div> 
  <p><img alt="" height="248" src="https://images2.imgbox.com/b4/a5/vtZdJDLH_o.png" width="380"></p> 
 </div> 
</div> 
<p><span style="color:#000000">现在的问题是，我们能否找到对网络模型稍加修改的解决方案？或者换句话说：我们能否创建一个能够定义任意决策边界的感知器？</span></p> 
<p><span style="color:#000000">解决方案包括添加偏置节点。</span></p> 
<h3 id="Single-Perceptron-with-a-Bias" style="margin-left:0"><span style="color:#3777ad">具有偏差的单个感知器</span></h3> 
<p><span style="color:#000000">具有两个输入值和一个偏差的感知器对应于一条一般直线。借助偏置值，<code>b</code>我们可以训练感知器来确定具有非零截距的决策边界<code>c</code>。</span></p> 
<p style="text-align:center"><img alt="具有两个输入值和一个偏置值的感知器" height="158" src="https://images2.imgbox.com/ac/37/lMSIR1zv_o.png" width="400"></p> 
<p><span style="color:#000000">虽然输入值可以改变，但偏置值始终保持不变。只能调整偏置节点的权重。</span></p> 
<p><span style="color:#000000">现在，感知器的线性方程包含偏差：</span></p> 
<p><span style="color:#000000">∑一世=1n瓦一世⋅X一世+瓦n+1⋅乙=0</span></p> 
<p><span style="color:#000000">在我们的例子中，它看起来像这样：</span></p> 
<p><span style="color:#000000">瓦1⋅X1+瓦2⋅X2+瓦3⋅乙=0</span></p> 
<p><span style="color:#000000">这相当于</span></p> 
<p><span style="color:#000000">X2=-瓦1瓦2⋅X1-瓦3瓦2⋅乙</span></p> 
<p><span style="color:#000000">这意味着：</span></p> 
<p><span style="color:#000000">米=-瓦1瓦2</span></p> 
<p><span style="color:#000000">和</span></p> 
<p><span style="color:#000000">C=-瓦3瓦2⋅乙</span></p> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"> 
<span style="color:#008000"><strong>import </strong></span> <span style="color:#0000ff"><strong>numpy </strong></span> <span style="color:#008000"><strong>as </strong></span> <span style="color:#0000ff"><strong>np </strong></span>
<span style="color:#008000"><strong>from </strong></span> <span style="color:#0000ff"><strong>collections </strong></span> <span style="color:#008000"><strong>import </strong></span> Counter

<span style="color:#008000"><strong>类</strong></span> <span style="color:#0000ff"><strong>感知器</strong></span>：
    
    <span style="color:#008000"><strong>def </strong></span> <span style="color:#0000ff"><strong>__init__ </strong></span>( self ,  
                 weights , 
                 bias <span style="color:#666666">= </span>1 , 
                 learning_rate <span style="color:#666666">= </span>0.3 ): 
        <span style="color:#ba2121"><em>""" </em></span>
<span style="color:#ba2121"><em>        'weights' 可以是一个 numpy 数组、列表或具有</em></span>
<span style="color:#ba2121"><em>        权重实际值的</em></span>
<span style="color:#ba2121"><em>元组</em></span><span style="color:#ba2121"><em>。输入值的数量</em></span><span style="color:#ba2121"><em>        由'weights' </em></span>
<span style="color:#ba2121"><em>        """ </em></span>
        self 的<span style="color:#ba2121"><em>长度</em></span><span style="color:#666666">。</span>权重 <span style="color:#666666">= </span> np <span style="color:#666666">。</span>数组（权重）
        自我<span style="color:#666666">。</span>偏见 <span style="color:#666666">=</span> 偏见
        自我<span style="color:#666666">。</span>学习率 <span style="color:#666666">=</span> 学习率
        
    @staticmethod 
    <span style="color:#008000"><strong>def </strong></span> unit_step_function ( x ):
        <span style="color:#008000"><strong>如果</strong></span>  x  <span style="color:#666666">&lt;= </span> 0 : 
            <span style="color:#008000"><strong>return </strong></span> 0 
        <span style="color:#008000"><strong>else </strong></span>: 
            <span style="color:#008000"><strong>return </strong></span> 1
        
    <span style="color:#008000"><strong>def </strong></span> <span style="color:#0000ff"><strong>__call__ </strong></span>( self ,  in_data ): 
        in_data  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>串连（ （IN_DATA ， [自<span style="color:#666666">。</span>偏压]）  ）
        结果 <span style="color:#666666">=</span> 自我<span style="color:#666666">。</span>weights  <span style="color:#666666">@ </span> in_data
        <span style="color:#008000"><strong>返回</strong></span> 感知器<span style="color:#666666">。</span>unit_step_function (结果)
    
    <span style="color:#008000"><strong>def</strong></span> 调整( self ,  
               target_result ,  
               in_data ): 
        <span style="color:#008000"><strong>if </strong></span> <span style="color:#008000"><strong>type </strong></span>( in_data )  <span style="color:#666666">!= </span> np <span style="color:#666666">. </span>ndarray ：
            in_data  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>阵列（IN_DATA ）  <span style="color:#408080"><em>＃</em></span>
        calculated_result  <span style="color:#666666">=</span> 自（IN_DATA ）
        误差 <span style="color:#666666">= </span> target_result  <span style="color:#666666">- </span> calculated_result
        <span style="color:#008000"><strong>如果</strong></span> 错误 <span style="color:#666666">=！</span> 0 ：
            IN_DATA  <span style="color:#666666">= </span> NP <span style="color:#666666">。</span>连接(  (in_data ,  [ self <span style="color:#666666">. </span>偏差])  )
            校正 <span style="color:#666666">=</span> 错误 <span style="color:#666666">* </span> in_data  <span style="color:#666666">* </span> self <span style="color:#666666">。</span>learning_rate
            自我<span style="color:#666666">。</span>权重 <span style="color:#666666">+=</span> 修正
            
    <span style="color:#008000"><strong>DEF</strong></span> 评估（自， 数据， 标签）：
        评价 <span style="color:#666666">=</span> 计数器（）
        <span style="color:#008000"><strong>对于</strong></span> 样品， 标签 <span style="color:#aa22ff"><strong>在</strong></span> <span style="color:#008000"><strong>拉链</strong></span>（数据， 标签）：
            结果 <span style="color:#666666">=</span> 自（样品） <span style="color:#408080"><em>＃预测</em></span>
            <span style="color:#008000"><strong>如果</strong></span> 结果 <span style="color:#666666">==</span> 标签：
                评价[ <span style="color:#ba2121">“正确” </span>]  <span style="color:#666666">+ = </span> 1
            <span style="color:#008000"><strong>否则</strong></span>：
                评估[ <span style="color:#ba2121">“错误” </span>]  <span style="color:#666666">+= </span> 1
        <span style="color:#008000"><strong>返回</strong></span> 评估
</span></span></pre> 
 </div> 
</div> 
<p><span style="color:#000000">我们假设上面带有 Perceptron 类的 Python 代码以“perceptrons.py”的名称存储在您当前的工作目录中。</span></p> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>import </strong></span> <span style="color:#0000ff"><strong>numpy </strong></span> <span style="color:#008000"><strong>as </strong></span> <span style="color:#0000ff"><strong>np </strong></span>
<span style="color:#008000"><strong>from </strong></span> <span style="color:#0000ff"><strong>perceptrons </strong></span> <span style="color:#008000"><strong>import </strong></span> Perceptron

<span style="color:#008000"><strong>def </strong></span> labelled_samples ( n ): 
    <span style="color:#008000"><strong>for </strong></span> _  <span style="color:#aa22ff"><strong>in </strong></span> <span style="color:#008000"><strong>range </strong></span>( n ): 
        s  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>随机的<span style="color:#666666">。</span>randint ( 0 ,  2 ,  ( 2 ,)) 
        <span style="color:#008000"><strong>yield </strong></span> ( s ,  1 )  <span style="color:#008000"><strong>if </strong></span> s [ 0 ]  <span style="color:#666666">== </span> 1  <span style="color:#aa22ff"><strong>and </strong></span> s [ 1 ]  <span style="color:#666666">== </span> 1  <span style="color:#008000"><strong>else </strong></span> ( s ,  0 )

p  <span style="color:#666666">=</span> 感知器（权重<span style="color:#666666">= </span>[ 0.3 ,  0.3 ,  0.3 ], 
               learning_rate <span style="color:#666666">= </span>0.2 ）

<span style="color:#008000"><strong>对于</strong></span> IN_DATA ， 标签 <span style="color:#aa22ff"><strong>在</strong></span> labelled_samples （30 ）：
    p <span style="color:#666666">。</span>调整（标签， 
             输入数据）

test_data ,  test_labels  <span style="color:#666666">= </span> <span style="color:#008000"><strong>list </strong></span>( <span style="color:#008000"><strong>zip </strong></span>( <span style="color:#666666">* </span>labelled_samples ( 30 )))

评价 <span style="color:#666666">= </span> p <span style="color:#666666">。</span>评估（test_data ， test_labels ）
<span style="color:#008000"><strong>打印</strong></span>（评估）
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：</strong></span></span></h3> 
 <div> 
  <pre style="margin-left:2em"><span style="color:#000000">计数器（{'正确'：30}）
</span></pre> 
 </div> 
</div> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>matplotlib.pyplot</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>plt</strong></span>
<span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>numpy</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>np</strong></span>

图,  ax  <span style="color:#666666">= </span> plt <span style="color:#666666">。</span>子图() 
xmin ,  xmax  <span style="color:#666666">= </span> <span style="color:#666666">- </span>0.2 ,  1.4 
X  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>arange ( xmin ,  xmax ,  0.1 ) 
ax <span style="color:#666666">。</span>scatter ( 0 ,  0 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>scatter ( 0 ,  1 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>分散（1 ,  0 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>scatter ( 1 ,  1 ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"g" </span>) 
ax <span style="color:#666666">。</span>set_xlim ([ xmin ,  xmax ]) 
ax <span style="color:#666666">。</span>set_ylim ([ <span style="color:#666666">- </span>0.1 ,  1.1 ]) 
m  <span style="color:#666666">= </span> <span style="color:#666666">- </span>p <span style="color:#666666">。</span>权重[ 0 ]  <span style="color:#666666">/ </span> p <span style="color:#666666">。</span>权重[ 1 ] 
c  <span style="color:#666666">= </span> <span style="color:#666666">- </span>p<span style="color:#666666">. </span>权重[ 2 ]  <span style="color:#666666">/ </span> p <span style="color:#666666">。</span>weights [ 1 ]
<span style="color:#008000"><strong>打印</strong></span>( m ,  c ) 
ax <span style="color:#666666">。</span>绘图( X ,  m  <span style="color:#666666">* </span> X  <span style="color:#666666">+ </span> c  ) 
plt <span style="color:#666666">。</span>情节()
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：</strong></span></span></h3> 
 <div> 
  <p><img alt="" height="248" src="https://images2.imgbox.com/87/7a/MXtiRu15_o.png" width="380"></p> 
  <span style="color:#000000">-3.0000000000000004 3.0000000000000013 []</span>
 </div> 
</div> 
<p><span style="color:#000000">我们将创建另一个具有线性可分数据集的示例，该数据集需要一个偏置节点才能进行分离。我们将使用以下<code>make_blobs</code>函数<code>sklearn.datasets</code>：</span></p> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>从</strong></span> <span style="color:#0000ff"><strong>sklearn.datasets</strong></span> <span style="color:#008000"><strong>导入</strong></span> make_blobs

n_samples  <span style="color:#666666">= </span> 250 个
样本， 标签 <span style="color:#666666">= </span> make_blobs ( n_samples <span style="color:#666666">= </span>n_samples ， 
                             中心<span style="color:#666666">= </span>([ 2.5 ,  3 ],  [ 6.7 ,  7.9 ]),  
                             random_state <span style="color:#666666">= </span>0 )
</span></span></pre> 
 </div> 
</div> 
<p><span style="color:#000000">让我们可视化之前创建的数据：</span></p> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>导入</strong></span> <span style="color:#0000ff"><strong>matplotlib.pyplot</strong></span> <span style="color:#008000"><strong>作为</strong></span> <span style="color:#0000ff"><strong>plt</strong></span>

颜色 <span style="color:#666666">= </span> ( <span style="color:#ba2121">'green' </span>,  <span style="color:#ba2121">'magenta' </span>,  <span style="color:#ba2121">'blue' </span>,  <span style="color:#ba2121">'cyan' </span>,  <span style="color:#ba2121">'yellow' </span>,  <span style="color:#ba2121">'red' </span>) 
fig ,  ax  <span style="color:#666666">= </span> plt <span style="color:#666666">. </span>子图()


<span style="color:#008000"><strong>用于</strong></span> n_class <span style="color:#aa22ff"><strong>在</strong></span> <span style="color:#008000"><strong>范围</strong></span>（2 ）：
    斧<span style="color:#666666">。</span>分散（样本[标签<span style="color:#666666">== </span>n_class ][:,  0 ], 样本[标签<span style="color:#666666">== </span>n_class ][:,  1 ],  
               c <span style="color:#666666">=</span>颜色[ n_class ],  s <span style="color:#666666">= </span>40 ,  label <span style="color:#666666">= </span><span style="color:#008000"><strong>str </strong></span>( n_class )）
</span></span></pre> 
 </div> 
 <p><img alt="" height="248" src="https://images2.imgbox.com/68/18/a2HW0weA_o.png" width="368"></p> 
</div> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1">n_learn_data  <span style="color:#666666">= </span> <span style="color:#008000"><strong>int </strong></span>( n_samples  <span style="color:#666666">* </span> 0.8 )  <span style="color:#408080"><em># 80% 的可用数据点</em></span>
learn_data ,  test_data  <span style="color:#666666">= </span> samples [: n_learn_data ],  samples [ <span style="color:#666666">- </span>n_learn_data :] 
learn_labels ,  test_labels  <span style="color:#666666">= </span> labels [: n_learn_data ],  labels [ <span style="color:#666666">- </span>n_learn_data :]

<span style="color:#008000"><strong>从</strong></span> <span style="color:#0000ff"><strong>感知器</strong></span> <span style="color:#008000"><strong>导入</strong></span> 感知器

p  <span style="color:#666666">=</span> 感知器（权重<span style="color:#666666">= </span>[ 0.3 ,  0.3 ,  0.3 ], 
               learning_rate <span style="color:#666666">= </span>0.8 ）

<span style="color:#008000"><strong>为</strong></span> 样品， 标签 <span style="color:#aa22ff"><strong>在</strong></span> <span style="color:#008000"><strong>拉链</strong></span>（learn_data ， learn_labels ）：
    p <span style="color:#666666">。</span>调整（标签，
             样本）

评价 <span style="color:#666666">= </span> p <span style="color:#666666">。</span>评估（学习数据， 学习标签）
<span style="color:#008000"><strong>打印</strong></span>（评估）
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：</strong></span></span></h3> 
 <div> 
  <pre style="margin-left:2em"><span style="color:#000000">计数器（{'正确'：200}）
</span></pre> 
 </div> 
</div> 
<p><span style="color:#000000">让我们可视化决策边界：</span></p> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>导入</strong></span> <span style="color:#0000ff"><strong>matplotlib.pyplot</strong></span> <span style="color:#008000"><strong>作为</strong></span> <span style="color:#0000ff"><strong>plt</strong></span>


图,  ax  <span style="color:#666666">= </span> plt <span style="color:#666666">。</span>子图()

<span style="color:#408080"><em># 绘制学习数据</em></span>
colors  <span style="color:#666666">= </span> ( <span style="color:#ba2121">'green' </span>,  <span style="color:#ba2121">'blue' </span>) 
<span style="color:#008000"><strong>for </strong></span> n_class  <span style="color:#aa22ff"><strong>in </strong></span> <span style="color:#008000"><strong>range </strong></span>( 2 ): 
    ax <span style="color:#666666">。</span>分散( learn_data [ learn_labels <span style="color:#666666">== </span>n_class ][:,  0 ],  
               learn_data [ learn_labels <span style="color:#666666">== </span>n_class ][:,  1 ],  
               c <span style="color:#666666">=</span>颜色[ n_class ],  s <span style="color:#666666">= </span>40 ,  label <span style="color:#666666">= </span><span style="color:#008000"><strong>str </strong></span>( n_class))
    
<span style="color:#408080"><em># 绘制测试数据</em></span>
colors  <span style="color:#666666">= </span> ( <span style="color:#ba2121">'lightgreen' </span>,  <span style="color:#ba2121">' </span>lightblue <span style="color:#ba2121">' </span>) 
<span style="color:#008000"><strong>for </strong></span> n_class  <span style="color:#aa22ff"><strong>in </strong></span> <span style="color:#008000"><strong>range </strong></span>( 2 ): 
    ax <span style="color:#666666">. </span>分散( test_data [ test_labels <span style="color:#666666">== </span>n_class ][:,  0 ],  
               test_data [ test_labels <span style="color:#666666">== </span>n_class ][:,  1 ],  
               c <span style="color:#666666">=</span>颜色[ n_class ],  s <span style="color:#666666">= </span>40 ,  label <span style="color:#666666">= </span><span style="color:#008000"><strong>str </strong></span>( n_class))


    
X  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>arange ( np <span style="color:#666666">. </span>max ( samples [:, 0 ])) 
m  <span style="color:#666666">= </span> <span style="color:#666666">- </span>p <span style="color:#666666">。</span>权重[ 0 ]  <span style="color:#666666">/ </span> p <span style="color:#666666">。</span>权重[ 1 ] 
c  <span style="color:#666666">= </span> <span style="color:#666666">- </span>p <span style="color:#666666">。</span>权重[ 2 ]  <span style="color:#666666">/ </span> p <span style="color:#666666">。</span>weights [ 1 ]
<span style="color:#008000"><strong>打印</strong></span>( m ,  c ) 
ax <span style="color:#666666">。</span>情节( X,  m  <span style="color:#666666">* </span> X  <span style="color:#666666">+ </span> c  ) 
plt <span style="color:#666666">。</span>情节（）
plt <span style="color:#666666">。</span>显示()
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：  </strong></span></span></h3> 
 <div> 
  <p><img alt="" height="248" src="https://images2.imgbox.com/b6/22/PmBfQ6ga_o.png" width="370"></p> 
  <span style="color:#000000">-1.5513529034664024 11.736643489707035</span>
 </div> 
</div> 
<p><span style="color:#000000">在下一节中，我们将介绍神经网络的 XOR 问题。它是非线性可分神经网络的最简单示例。它可以通过额外的神经元层来解决，称为隐藏层。</span></p> 
<h2 id="The-XOR-Problem-for-Neural-Networks"><span style="background-color:#3777ad"><span style="color:#ffffff">神经网络的异或问题</span></span></h2> 
<p><span style="color:#000000">XOR（异或）函数由以下真值表定义：</span></p> 
<table border="1" cellspacing="0">
<thead><tr>
<th style="vertical-align:top">输入1</th>
<th style="vertical-align:top">输入2</th>
<th style="vertical-align:top">异或输出</th>
</tr></thead>
<tbody>
<tr>
<td style="border-color:#999999;vertical-align:top">0</td>
<td style="border-color:#999999;vertical-align:top">0</td>
<td style="border-color:#999999;vertical-align:top">0</td>
</tr>
<tr>
<td style="border-color:#999999;vertical-align:top">0</td>
<td style="border-color:#999999;vertical-align:top">1</td>
<td style="border-color:#999999;vertical-align:top">1</td>
</tr>
<tr>
<td style="border-color:#999999;vertical-align:top">1</td>
<td style="border-color:#999999;vertical-align:top">0</td>
<td style="border-color:#999999;vertical-align:top">1</td>
</tr>
<tr>
<td style="border-color:#999999;vertical-align:top">1</td>
<td style="border-color:#999999;vertical-align:top">1</td>
<td style="border-color:#999999;vertical-align:top">0</td>
</tr>
</tbody>
</table>
<p><span style="color:#000000">这个问题不能用简单的神经网络解决，如下图所示：</span></p> 
<p style="text-align:center"><img alt="平面中的异或问题点" height="293" src="https://images2.imgbox.com/79/7a/m4AUFCJS_o.png" width="300"></p> 
<p><span style="color:#000000">无论您选择哪条直线，您都不会成功地在一侧拥有蓝色点而在另一侧拥有橙色点。这如下图所示。橙色点位于橙色线上。这意味着这不能是一条分界线。如果我们平行移动这条线——无论朝哪个方向，总会有两个橙色和一个蓝色点在一侧，而在另一侧只有一个蓝色点。如果我们以非平行方式移动橙色线，则两侧将有一个蓝色和一个橙色点，除非该线通过橙色点。所以没有办法用一条直线来分隔这些点。</span></p> 
<p style="text-align:center"><img alt="XOR 问题没有单一的决策边界" height="256" src="https://images2.imgbox.com/84/0e/ym61HXn2_o.png" width="300"></p> 
<p><span style="color:#000000">为了解决这个问题，我们需要引入一种新型的神经网络，一种具有所谓隐藏层的网络。隐藏层允许网络重新组织或重新排列输入数据。</span></p> 
<p style="text-align:center"><img alt="带有隐藏层的简单人工网络" height="504" src="https://images2.imgbox.com/a9/91/Pl6lTqW8_o.png" width="500"></p> 
<p><span style="color:#000000">我们只需要一个带有两个神经元的隐藏层。一个像与门一样工作，另一个像或门一样工作。当 OR 门触发而 AND 门不触发时，输出将“触发”。</span></p> 
<p><span style="color:#000000">正如我们已经提到的，我们找不到将橙色点与蓝色点分开的线。但是它们可以用两条线分开，例如下图中的L 1和 L 2：</span></p> 
<p style="text-align:center"><img alt="神经网络中的异或问题" height="342" src="https://images2.imgbox.com/f1/d3/Dd7N78wy_o.png" width="350"></p> 
<p><span style="color:#000000">为了解决这个问题，我们需要以下类型的网络，即具有隐藏层 N 1和 N 2</span></p> 
<p style="text-align:center"><img alt="网络解决异或问题" height="783" src="https://images2.imgbox.com/5f/6c/J1Y1Gp9k_o.png" width="300"></p> 
<p><span style="color:#000000">神经元N 1将确定一条线，例如L 1并且神经元N 2将确定另一条线L 2。N 3最终会解决我们的问题：</span></p> 
<p style="text-align:center"><img alt="解释解决异或问题的网络" height="860" src="https://images2.imgbox.com/9b/da/IEaARRgT_o.png" width="500"></p> 
<p><span style="color:#000000">在 Python 中实现这一点必须等到我们机器学习教程的下一章。</span></p> 
<h2 id="Exercises"><span style="background-color:#3777ad"><span style="color:#ffffff">练习</span></span></h2> 
<h3 id="Exercise-1" style="margin-left:0"><span style="color:#3777ad">练习 1</span></h3> 
<p><span style="color:#000000">我们可以通过以下方式将逻辑 AND 扩展为 0 和 1 之间的浮点值：</span></p> 
<table border="1" cellspacing="0">
<thead><tr>
<th style="vertical-align:top">输入1</th>
<th style="vertical-align:top">输入2</th>
<th style="vertical-align:top">输出</th>
</tr></thead>
<tbody>
<tr>
<td style="border-color:#999999;vertical-align:top">x1 &lt; 0.5</td>
<td style="border-color:#999999;vertical-align:top">x2 &lt; 0.5</td>
<td style="border-color:#999999;vertical-align:top">0</td>
</tr>
<tr>
<td style="border-color:#999999;vertical-align:top">x1 &lt; 0.5</td>
<td style="border-color:#999999;vertical-align:top">x2 &gt;= 0.5</td>
<td style="border-color:#999999;vertical-align:top">0</td>
</tr>
<tr>
<td style="border-color:#999999;vertical-align:top">x1 &gt;= 0.5</td>
<td style="border-color:#999999;vertical-align:top">x2 &lt; 0.5</td>
<td style="border-color:#999999;vertical-align:top">0</td>
</tr>
<tr>
<td style="border-color:#999999;vertical-align:top">x1 &gt;= 0.5</td>
<td style="border-color:#999999;vertical-align:top">x2 &gt;= 0.5</td>
<td style="border-color:#999999;vertical-align:top">1</td>
</tr>
</tbody>
</table>
<p><span style="color:#000000">尝试训练一个只有一个感知器的神经网络。为什么不起作用？</span></p> 
<h3 id="Exercise-2" style="margin-left:0"><span style="color:#3777ad">练习 2</span></h3> 
<p><span style="color:#000000">一个点属于 0 类，如果 X1&lt;0.5 并且属于第 1 类，如果 X1&gt;=0.5. 用一个感知器训练一个网络来对任意点进行分类。你对切割边界有什么看法？输入值怎么样X2</span></p> 
<h2 id="Solutions-to-the-exercises"><span style="background-color:#3777ad"><span style="color:#ffffff">练习题解答</span></span></h2> 
<h3 id="Solution-to-the-1.-Exercise" style="margin-left:0"><span style="color:#3777ad">第一个练习的解决方案</span></h3> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>从</strong></span> <span style="color:#0000ff"><strong>感知器</strong></span> <span style="color:#008000"><strong>导入</strong></span> 感知器

p  <span style="color:#666666">=</span> 感知器（权重<span style="color:#666666">= </span>[ 0.3 ,  0.3 ,  0.3 ],
               偏差<span style="color:#666666">= </span>1 , 
               learning_rate <span style="color:#666666">= </span>0.2 ）

<span style="color:#008000"><strong>def </strong></span> labelled_samples ( n ): 
    <span style="color:#008000"><strong>for </strong></span> _  <span style="color:#aa22ff"><strong>in </strong></span> <span style="color:#008000"><strong>range </strong></span>( n ): 
        s  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>随机的<span style="color:#666666">。</span>random (( 2 ,)) 
        <span style="color:#008000"><strong>yield </strong></span> ( s ,  1 )  <span style="color:#008000"><strong>if </strong></span> s [ 0 ]  <span style="color:#666666">&gt;= </span> 0.5  <span style="color:#aa22ff"><strong>and </strong></span> s [ 1 ]  <span style="color:#666666">&gt;= </span> 0.5  <span style="color:#008000"><strong>else </strong></span> ( s ,  0 )

<span style="color:#008000"><strong>对于</strong></span> IN_DATA ， 标签 <span style="color:#aa22ff"><strong>在</strong></span> labelled_samples （30 ）：
    p <span style="color:#666666">。</span>调整（标签， 
             输入数据）

test_data ,  test_labels  <span style="color:#666666">= </span> <span style="color:#008000"><strong>list </strong></span>( <span style="color:#008000"><strong>zip </strong></span>( <span style="color:#666666">* </span>labelled_samples ( 60 )))

评价 <span style="color:#666666">= </span> p <span style="color:#666666">。</span>评估（test_data ， test_labels ）
<span style="color:#008000"><strong>打印</strong></span>（评估）
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：</strong></span></span></h3> 
 <div> 
  <pre style="margin-left:2em"><span style="color:#000000">计数器（{'正确'：52，'错误'：8}）
</span></pre> 
 </div> 
</div> 
<p><span style="color:#000000">查看为什么它不起作用的最简单方法是将数据可视化。</span></p> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>matplotlib.pyplot</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>plt</strong></span>
<span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>numpy</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>np</strong></span>

ones  <span style="color:#666666">= </span> [ test_data [ i ]  <span style="color:#008000"><strong>for </strong></span> i  <span style="color:#aa22ff"><strong>in </strong></span> <span style="color:#008000"><strong>range </strong></span>( <span style="color:#008000"><strong>len </strong></span>( test_data ))  <span style="color:#008000"><strong>if </strong></span> test_labels [ i ]  <span style="color:#666666">== </span> 1 ] 
zeroes  <span style="color:#666666">= </span> [ test_data [ i ]  <span style="color:#008000"><strong>for </strong></span> i  <span style="color:#aa22ff"><strong>in </strong></span> <span style="color:#008000"><strong>range </strong></span>( <span style="color:#008000"><strong>len </strong></span>( test_data ))  <span style="color:#008000"><strong>if </strong></span> test_labels [ i ]  <span style="color:#666666">== </span> 0 ]

图,  ax  <span style="color:#666666">= </span> plt <span style="color:#666666">。</span>subplots () 
xmin ,  xmax  <span style="color:#666666">= </span> <span style="color:#666666">- </span>0.2 ,  1.2 
X ,  Y  <span style="color:#666666">= </span> <span style="color:#008000"><strong>list </strong></span>( <span style="color:#008000"><strong>zip </strong></span>( <span style="color:#666666">* </span>ones )) 
ax <span style="color:#666666">。</span>scatter ( X ,  Y ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"g" </span>) 
X ,  Y  <span style="color:#666666">= </span> <span style="color:#008000"><strong>list </strong></span>( <span style="color:#008000"><strong>zip </strong></span>( <span style="color:#666666">* </span>zeroes )) 
ax <span style="color:#666666">。</span>散射( X , Y ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>set_xlim ([ xmin ,  xmax ]) 
ax <span style="color:#666666">。</span>set_ylim ([ <span style="color:#666666">- </span>0.1 ,  1.1 ]) 
c  <span style="color:#666666">= </span> <span style="color:#666666">- </span>p <span style="color:#666666">。</span>权重[ 2 ]  <span style="color:#666666">/ </span> p <span style="color:#666666">。</span>权重[ 1 ] 
m  <span style="color:#666666">= </span> <span style="color:#666666">- </span>p <span style="color:#666666">。</span>权重[ 0 ]  <span style="color:#666666">/ </span> p <span style="color:#666666">。</span>权重[ 1 ] 
X  <span style="color:#666666">=</span> NP <span style="color:#666666">. </span>arange ( xmin ,  xmax ,  0.1 ) 
ax <span style="color:#666666">。</span>绘图（X ， m  <span style="color:#666666">* </span> X  <span style="color:#666666">+ </span> c ， 标签<span style="color:#666666">= </span><span style="color:#ba2121">“决策边界” </span>）
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：  </strong></span></span></h3> 
 <div> 
  <p><img alt="" height="248" src="https://images2.imgbox.com/f5/67/F8qgkDtq_o.png" width="380"></p> 
  <span style="color:#000000">[&lt;matplotlib.lines.Line2D 在 0x7fba8a295790&gt;]</span>
 </div> 
</div> 
<p><span style="color:#000000">我们可以看到，绿点和红点不是一条直线。</span></p> 
<h3 id="Solution-to-the-2nd-Exercise" style="margin-left:0"><span style="color:#3777ad">第二个练习的解决方案</span></h3> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>从</strong></span> <span style="color:#0000ff"><strong>感知器</strong></span> <span style="color:#008000"><strong>导入</strong></span> 感知器

<span style="color:#008000"><strong>import </strong></span> <span style="color:#0000ff"><strong>numpy </strong></span> <span style="color:#008000"><strong>as </strong></span> <span style="color:#0000ff"><strong>np </strong></span>
<span style="color:#008000"><strong>from </strong></span> <span style="color:#0000ff"><strong>collections </strong></span> <span style="color:#008000"><strong>import </strong></span> Counter

<span style="color:#008000"><strong>def </strong></span> labelled_samples ( n ): 
    <span style="color:#008000"><strong>for </strong></span> _  <span style="color:#aa22ff"><strong>in </strong></span> <span style="color:#008000"><strong>range </strong></span>( n ): 
        s  <span style="color:#666666">= </span> np <span style="color:#666666">。</span>随机的<span style="color:#666666">。</span>random (( 2 ,)) 
        <span style="color:#008000"><strong>yield </strong></span> ( s ,  0 )  <span style="color:#008000"><strong>if </strong></span> s [ 0 ]  <span style="color:#666666">&lt; </span> 0.5  <span style="color:#008000"><strong>else </strong></span> ( s ,  1 )


p  <span style="color:#666666">=</span> 感知器（权重<span style="color:#666666">= </span>[ 0.3 ,  0.3 ,  0.3 ], 
               learning_rate <span style="color:#666666">= </span>0.4 ）

<span style="color:#008000"><strong>对于</strong></span> IN_DATA ， 标签 <span style="color:#aa22ff"><strong>在</strong></span> labelled_samples （300 ）：
    p <span style="color:#666666">。</span>调整（标签， 
             输入数据）

test_data ,  test_labels  <span style="color:#666666">= </span> <span style="color:#008000"><strong>list </strong></span>( <span style="color:#008000"><strong>zip </strong></span>( <span style="color:#666666">* </span>labelled_samples ( 500 )))

<span style="color:#008000"><strong>打印</strong></span>（p <span style="color:#666666">。</span>权重）
p <span style="color:#666666">。</span>评估（test_data ， test_labels ）
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：</strong></span></span></h3> 
 <div> 
  <pre style="margin-left:2em"><span style="color:#000000">[ 2.22622234 -0.05588858 -0.9 ]
计数器（{'正确'：460，'错误'：40}）</span></pre> 
 </div> 
</div> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1"><span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>matplotlib.pyplot</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>plt</strong></span>
<span style="color:#008000"><strong>将</strong></span> <span style="color:#0000ff"><strong>numpy</strong></span> <span style="color:#008000"><strong>导入</strong></span><span style="color:#008000"><strong>为</strong></span> <span style="color:#0000ff"><strong>np</strong></span>

ones  <span style="color:#666666">= </span> [ test_data [ i ]  <span style="color:#008000"><strong>for </strong></span> i  <span style="color:#aa22ff"><strong>in </strong></span> <span style="color:#008000"><strong>range </strong></span>( <span style="color:#008000"><strong>len </strong></span>( test_data ))  <span style="color:#008000"><strong>if </strong></span> test_labels [ i ]  <span style="color:#666666">== </span> 1 ] 
zeroes  <span style="color:#666666">= </span> [ test_data [ i ]  <span style="color:#008000"><strong>for </strong></span> i  <span style="color:#aa22ff"><strong>in </strong></span> <span style="color:#008000"><strong>range </strong></span>( <span style="color:#008000"><strong>len </strong></span>( test_data ))  <span style="color:#008000"><strong>if </strong></span> test_labels [ i ]  <span style="color:#666666">== </span> 0 ]

图,  ax  <span style="color:#666666">= </span> plt <span style="color:#666666">。</span>subplots () 
xmin ,  xmax  <span style="color:#666666">= </span> <span style="color:#666666">- </span>0.2 ,  1.2 
X ,  Y  <span style="color:#666666">= </span> <span style="color:#008000"><strong>list </strong></span>( <span style="color:#008000"><strong>zip </strong></span>( <span style="color:#666666">* </span>ones )) 
ax <span style="color:#666666">。</span>scatter ( X ,  Y ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"g" </span>) 
X ,  Y  <span style="color:#666666">= </span> <span style="color:#008000"><strong>list </strong></span>( <span style="color:#008000"><strong>zip </strong></span>( <span style="color:#666666">* </span>zeroes )) 
ax <span style="color:#666666">。</span>散射( X , Y ,  color <span style="color:#666666">= </span><span style="color:#ba2121">"r" </span>) 
ax <span style="color:#666666">。</span>set_xlim ([ xmin ,  xmax ]) 
ax <span style="color:#666666">。</span>set_ylim ([ <span style="color:#666666">- </span>0.1 ,  1.1 ]) 
c  <span style="color:#666666">= </span> <span style="color:#666666">- </span>p <span style="color:#666666">。</span>权重[ 2 ]  <span style="color:#666666">/ </span> p <span style="color:#666666">。</span>权重[ 1 ] 
m  <span style="color:#666666">= </span> <span style="color:#666666">- </span>p <span style="color:#666666">。</span>权重[ 0 ]  <span style="color:#666666">/ </span> p <span style="color:#666666">。</span>权重[ 1 ] 
X  <span style="color:#666666">=</span> NP <span style="color:#666666">. </span>arange ( xmin ,  xmax ,  0.1 ) 
ax <span style="color:#666666">。</span>绘图（X ， m  <span style="color:#666666">* </span> X  <span style="color:#666666">+ </span> c ， 标签<span style="color:#666666">= </span><span style="color:#ba2121">“决策边界” </span>）
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：  </strong></span></span></h3> 
 <div> 
  <p><img alt="" height="248" src="https://images2.imgbox.com/03/96/RCq8XdaP_o.png" width="380"></p> 
  <span style="color:#000000">[&lt;matplotlib.lines.Line2D 在 0x7fba8a1fbac0&gt;]</span>
 </div> 
</div> 
<div> 
 <div style="margin-left:.4em"> 
  <pre><span style="color:#000000"><span style="background-color:#f2f5f1">p <span style="color:#666666">。</span>权重， 米
</span></span></pre> 
 </div> 
 <h3 style="margin-left:0"><span style="color:#000000"><span style="color:#d84315"><strong>输出：</strong></span></span></h3> 
 <div> 
  <pre style="margin-left:2em"><span style="color:#000000">(数组([ 2.22622234, -0.05588858, -0.9 ]), 39.83322163376969)</span></pre> 
 </div> 
</div> 
<p><span style="color:#000000"><code>m</code>在这种情况下，斜率必须越来越大。</span></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>