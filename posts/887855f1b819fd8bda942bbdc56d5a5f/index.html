<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>看完这篇文章保你面试稳操胜券 ——（必考题）javaScript 篇 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">看完这篇文章保你面试稳操胜券 ——（必考题）javaScript 篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <blockquote> 
 <p>✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          欢
         
         
          迎
         
         
          各
         
         
          位
         
         
          小
         
         
          伙
         
         
          伴
         
         
          ：
         
        
       
       
        textcolor{blue}{欢迎各位小伙伴：}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: blue">欢</span><span class="mord cjk_fallback" style="color: blue">迎</span><span class="mord cjk_fallback" style="color: blue">各</span><span class="mord cjk_fallback" style="color: blue">位</span><span class="mord cjk_fallback" style="color: blue">小</span><span class="mord cjk_fallback" style="color: blue">伙</span><span class="mord cjk_fallback" style="color: blue">伴</span><span class="mord cjk_fallback" style="color: blue">：</span></span></span></span></span> <br><br> ✨ 进大厂收藏这一系列就够了，全方位搜集总结，为大家归纳出这篇面试宝典，面试途中祝你一臂之力！，共分为四个系列 <br><br> ✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          包
         
         
          含
         
         
          V
         
         
          u
         
         
          e
         
         
          40
         
         
          道
         
         
          经
         
         
          典
         
         
          面
         
         
          试
         
         
          题
         
        
       
       
        textcolor{green}{包含Vue40道经典面试题}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: green">包</span><span class="mord cjk_fallback" style="color: green">含</span><span class="mord mathdefault" style="margin-right: 0.22222em;color: green">V</span><span class="mord mathdefault" style="color: green">u</span><span class="mord mathdefault" style="color: green">e</span><span class="mord" style="color: green">4</span><span class="mord" style="color: green">0</span><span class="mord cjk_fallback" style="color: green">道</span><span class="mord cjk_fallback" style="color: green">经</span><span class="mord cjk_fallback" style="color: green">典</span><span class="mord cjk_fallback" style="color: green">面</span><span class="mord cjk_fallback" style="color: green">试</span><span class="mord cjk_fallback" style="color: green">题</span></span></span></span></span> <br><br> ✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          包
         
         
          含
         
         
          r
         
         
          e
         
         
          a
         
         
          c
         
         
          t
         
         
          12
         
         
          道
         
         
          高
         
         
          并
         
         
          发
         
         
          面
         
         
          试
         
         
          题
         
        
       
       
        textcolor{green}{包含react12道高并发面试题}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: green">包</span><span class="mord cjk_fallback" style="color: green">含</span><span class="mord mathdefault" style="margin-right: 0.02778em;color: green">r</span><span class="mord mathdefault" style="color: green">e</span><span class="mord mathdefault" style="color: green">a</span><span class="mord mathdefault" style="color: green">c</span><span class="mord mathdefault" style="color: green">t</span><span class="mord" style="color: green">1</span><span class="mord" style="color: green">2</span><span class="mord cjk_fallback" style="color: green">道</span><span class="mord cjk_fallback" style="color: green">高</span><span class="mord cjk_fallback" style="color: green">并</span><span class="mord cjk_fallback" style="color: green">发</span><span class="mord cjk_fallback" style="color: green">面</span><span class="mord cjk_fallback" style="color: green">试</span><span class="mord cjk_fallback" style="color: green">题</span></span></span></span></span> <br><br> ✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          包
         
         
          含
         
         
          微
         
         
          信
         
         
          小
         
         
          程
         
         
          序
         
         
          34
         
         
          道
         
         
          必
         
         
          问
         
         
          面
         
         
          试
         
         
          题
         
        
       
       
        textcolor{green}{包含微信小程序34道必问面试题}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: green">包</span><span class="mord cjk_fallback" style="color: green">含</span><span class="mord cjk_fallback" style="color: green">微</span><span class="mord cjk_fallback" style="color: green">信</span><span class="mord cjk_fallback" style="color: green">小</span><span class="mord cjk_fallback" style="color: green">程</span><span class="mord cjk_fallback" style="color: green">序</span><span class="mord" style="color: green">3</span><span class="mord" style="color: green">4</span><span class="mord cjk_fallback" style="color: green">道</span><span class="mord cjk_fallback" style="color: green">必</span><span class="mord cjk_fallback" style="color: green">问</span><span class="mord cjk_fallback" style="color: green">面</span><span class="mord cjk_fallback" style="color: green">试</span><span class="mord cjk_fallback" style="color: green">题</span></span></span></span></span> <br><br> ✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          包
         
         
          含
         
         
          j
         
         
          a
         
         
          v
         
         
          a
         
         
          S
         
         
          c
         
         
          r
         
         
          i
         
         
          p
         
         
          t
         
         
          80
         
         
          道
         
         
          扩
         
         
          展
         
         
          面
         
         
          试
         
         
          题
         
        
       
       
        textcolor{green}{包含javaScript80道扩展面试题}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em;vertical-align: -0.19444em"></span><span class="mord cjk_fallback" style="color: green">包</span><span class="mord cjk_fallback" style="color: green">含</span><span class="mord mathdefault" style="margin-right: 0.05724em;color: green">j</span><span class="mord mathdefault" style="color: green">a</span><span class="mord mathdefault" style="margin-right: 0.03588em;color: green">v</span><span class="mord mathdefault" style="color: green">a</span><span class="mord mathdefault" style="margin-right: 0.05764em;color: green">S</span><span class="mord mathdefault" style="color: green">c</span><span class="mord mathdefault" style="margin-right: 0.02778em;color: green">r</span><span class="mord mathdefault" style="color: green">i</span><span class="mord mathdefault" style="color: green">p</span><span class="mord mathdefault" style="color: green">t</span><span class="mord" style="color: green">8</span><span class="mord" style="color: green">0</span><span class="mord cjk_fallback" style="color: green">道</span><span class="mord cjk_fallback" style="color: green">扩</span><span class="mord cjk_fallback" style="color: green">展</span><span class="mord cjk_fallback" style="color: green">面</span><span class="mord cjk_fallback" style="color: green">试</span><span class="mord cjk_fallback" style="color: green">题</span></span></span></span></span> <br><br> ✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          包
         
         
          含
         
         
          A
         
         
          P
         
         
          P
         
         
          10
         
         
          道
         
         
          装
         
         
          逼
         
         
          面
         
         
          试
         
         
          题
         
        
       
       
        textcolor{green}{包含APP10道装逼面试题}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: green">包</span><span class="mord cjk_fallback" style="color: green">含</span><span class="mord mathdefault" style="color: green">A</span><span class="mord mathdefault" style="margin-right: 0.13889em;color: green">P</span><span class="mord mathdefault" style="margin-right: 0.13889em;color: green">P</span><span class="mord" style="color: green">1</span><span class="mord" style="color: green">0</span><span class="mord cjk_fallback" style="color: green">道</span><span class="mord cjk_fallback" style="color: green">装</span><span class="mord cjk_fallback" style="color: green">逼</span><span class="mord cjk_fallback" style="color: green">面</span><span class="mord cjk_fallback" style="color: green">试</span><span class="mord cjk_fallback" style="color: green">题</span></span></span></span></span> <br><br> ✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          包
         
         
          含
         
         
          H
         
         
          T
         
         
          M
         
         
          L
         
         
          /
         
         
          C
         
         
          S
         
         
          S
         
         
          30
         
         
          道
         
         
          基
         
         
          础
         
         
          面
         
         
          试
         
         
          题
         
        
       
       
        textcolor{green}{包含HTML/CSS30道基础面试题}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mord cjk_fallback" style="color: green">包</span><span class="mord cjk_fallback" style="color: green">含</span><span class="mord mathdefault" style="margin-right: 0.08125em;color: green">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;color: green">T</span><span class="mord mathdefault" style="margin-right: 0.10903em;color: green">M</span><span class="mord mathdefault" style="color: green">L</span><span class="mord" style="color: green">/</span><span class="mord mathdefault" style="margin-right: 0.07153em;color: green">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;color: green">S</span><span class="mord mathdefault" style="margin-right: 0.05764em;color: green">S</span><span class="mord" style="color: green">3</span><span class="mord" style="color: green">0</span><span class="mord cjk_fallback" style="color: green">道</span><span class="mord cjk_fallback" style="color: green">基</span><span class="mord cjk_fallback" style="color: green">础</span><span class="mord cjk_fallback" style="color: green">面</span><span class="mord cjk_fallback" style="color: green">试</span><span class="mord cjk_fallback" style="color: green">题</span></span></span></span></span> <br><br> ✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          还
         
         
          包
         
         
          含
         
         
          G
         
         
          i
         
         
          t
         
         
          、
         
         
          前
         
         
          端
         
         
          优
         
         
          化
         
         
          、
         
         
          E
         
         
          S
         
         
          6
         
         
          、
         
         
          A
         
         
          x
         
         
          i
         
         
          o
         
         
          s
         
         
          面
         
         
          试
         
         
          题
         
        
       
       
        textcolor{green}{还包含Git、前端优化、ES6、Axios面试题}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: green">还</span><span class="mord cjk_fallback" style="color: green">包</span><span class="mord cjk_fallback" style="color: green">含</span><span class="mord mathdefault" style="color: green">G</span><span class="mord mathdefault" style="color: green">i</span><span class="mord mathdefault" style="color: green">t</span><span class="mord cjk_fallback" style="color: green">、</span><span class="mord cjk_fallback" style="color: green">前</span><span class="mord cjk_fallback" style="color: green">端</span><span class="mord cjk_fallback" style="color: green">优</span><span class="mord cjk_fallback" style="color: green">化</span><span class="mord cjk_fallback" style="color: green">、</span><span class="mord mathdefault" style="margin-right: 0.05764em;color: green">E</span><span class="mord mathdefault" style="margin-right: 0.05764em;color: green">S</span><span class="mord" style="color: green">6</span><span class="mord cjk_fallback" style="color: green">、</span><span class="mord mathdefault" style="color: green">A</span><span class="mord mathdefault" style="color: green">x</span><span class="mord mathdefault" style="color: green">i</span><span class="mord mathdefault" style="color: green">o</span><span class="mord mathdefault" style="color: green">s</span><span class="mord cjk_fallback" style="color: green">面</span><span class="mord cjk_fallback" style="color: green">试</span><span class="mord cjk_fallback" style="color: green">题</span></span></span></span></span> <br><br> ✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          接
         
         
          下
         
         
          来
         
         
          让
         
         
          我
         
         
          们
         
         
          饱
         
         
          享
         
         
          这
         
         
          顿
         
         
          美
         
         
          味
         
         
          吧
         
         
          。
         
         
          一
         
         
          起
         
         
          来
         
         
          学
         
         
          习
         
         
          吧
         
         
          ！
         
         
          ！
         
         
          ！
         
        
       
       
        textcolor{pink}{接下来让我们饱享这顿美味吧。一起来学习吧！！！}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: pink">接</span><span class="mord cjk_fallback" style="color: pink">下</span><span class="mord cjk_fallback" style="color: pink">来</span><span class="mord cjk_fallback" style="color: pink">让</span><span class="mord cjk_fallback" style="color: pink">我</span><span class="mord cjk_fallback" style="color: pink">们</span><span class="mord cjk_fallback" style="color: pink">饱</span><span class="mord cjk_fallback" style="color: pink">享</span><span class="mord cjk_fallback" style="color: pink">这</span><span class="mord cjk_fallback" style="color: pink">顿</span><span class="mord cjk_fallback" style="color: pink">美</span><span class="mord cjk_fallback" style="color: pink">味</span><span class="mord cjk_fallback" style="color: pink">吧</span><span class="mord cjk_fallback" style="color: pink">。</span><span class="mord cjk_fallback" style="color: pink">一</span><span class="mord cjk_fallback" style="color: pink">起</span><span class="mord cjk_fallback" style="color: pink">来</span><span class="mord cjk_fallback" style="color: pink">学</span><span class="mord cjk_fallback" style="color: pink">习</span><span class="mord cjk_fallback" style="color: pink">吧</span><span class="mord cjk_fallback" style="color: pink">！</span><span class="mord cjk_fallback" style="color: pink">！</span><span class="mord cjk_fallback" style="color: pink">！</span></span></span></span></span> <br><br> ✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          本
         
         
          篇
         
         
          为
         
         
          《
         
         
          看
         
         
          完
         
         
          这
         
         
          篇
         
         
          文
         
         
          章
         
         
          保
         
         
          你
         
         
          面
         
         
          试
         
         
          稳
         
         
          操
         
         
          胜
         
         
          券
         
         
          》
         
         
          第
         
         
          三
         
         
          篇
         
         
          （
         
         
          j
         
         
          a
         
         
          v
         
         
          a
         
         
          S
         
         
          c
         
         
          r
         
         
          i
         
         
          p
         
         
          t
         
         
          扩
         
         
          展
         
         
          篇
         
         
          ）
         
        
       
       
        textcolor{pink}{本篇为《看完这篇文章保你面试稳操胜券》第三篇（javaScript扩展篇）}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em;vertical-align: -0.19444em"></span><span class="mord cjk_fallback" style="color: pink">本</span><span class="mord cjk_fallback" style="color: pink">篇</span><span class="mord cjk_fallback" style="color: pink">为</span><span class="mord cjk_fallback" style="color: pink">《</span><span class="mord cjk_fallback" style="color: pink">看</span><span class="mord cjk_fallback" style="color: pink">完</span><span class="mord cjk_fallback" style="color: pink">这</span><span class="mord cjk_fallback" style="color: pink">篇</span><span class="mord cjk_fallback" style="color: pink">文</span><span class="mord cjk_fallback" style="color: pink">章</span><span class="mord cjk_fallback" style="color: pink">保</span><span class="mord cjk_fallback" style="color: pink">你</span><span class="mord cjk_fallback" style="color: pink">面</span><span class="mord cjk_fallback" style="color: pink">试</span><span class="mord cjk_fallback" style="color: pink">稳</span><span class="mord cjk_fallback" style="color: pink">操</span><span class="mord cjk_fallback" style="color: pink">胜</span><span class="mord cjk_fallback" style="color: pink">券</span><span class="mord cjk_fallback" style="color: pink">》</span><span class="mord cjk_fallback" style="color: pink">第</span><span class="mord cjk_fallback" style="color: pink">三</span><span class="mord cjk_fallback" style="color: pink">篇</span><span class="mord cjk_fallback" style="color: pink">（</span><span class="mord mathdefault" style="margin-right: 0.05724em;color: pink">j</span><span class="mord mathdefault" style="color: pink">a</span><span class="mord mathdefault" style="margin-right: 0.03588em;color: pink">v</span><span class="mord mathdefault" style="color: pink">a</span><span class="mord mathdefault" style="margin-right: 0.05764em;color: pink">S</span><span class="mord mathdefault" style="color: pink">c</span><span class="mord mathdefault" style="margin-right: 0.02778em;color: pink">r</span><span class="mord mathdefault" style="color: pink">i</span><span class="mord mathdefault" style="color: pink">p</span><span class="mord mathdefault" style="color: pink">t</span><span class="mord cjk_fallback" style="color: pink">扩</span><span class="mord cjk_fallback" style="color: pink">展</span><span class="mord cjk_fallback" style="color: pink">篇</span><span class="mord cjk_fallback" style="color: pink">）</span></span></span></span></span> <br></p> 
</blockquote> 
<h3>
<a id="javaScript_14"></a>javaScript</h3> 
<h4>
<a id="js_15"></a>原生js</h4> 
<h5>
<a id="_16"></a>数组方法</h5> 
<ol>
<li>push（）方法 可把参数指定的元素依次添加到数组的末尾，并返回添加元素后的数组长度</li>
<li>unshift () 方法 可把参数指定的元素依次添加到数组的前面，并返回添加元素后的数组长度。该方法必须至少有一个参数</li>
<li>pop() 方法可弹出（删除）数组最后一个元素，并返回弹出的元素。</li>
<li>shift() 方法可删除数组第一个元素，并返回删除的元素。</li>
<li>splic() 方法功能比较强，它可以实现删除指定数量的元素、替换指定元素以及在指定位置添加元素。</li>
<li>slice() 方法返回包含从数组对象中的第 index1～index2-1 之间的元素的数组。index2 参数可以省略，省略时表示返回从 index1 位置开始一直到最后位置的元素。需要注意的是，该方法只是读取指定的元素，并不会对原数组作任何修改。</li>
<li>sort() 方法用于按某种规则排序数组：当方法的参数为空时，按字典序（即元素的 Unicode 编码从小到大排序顺序）排序数组元素；当参数为一个匿名函数时，将按匿名函数指定的规则排序数组元素。</li>
<li>concat() 将参数指定的数组和当前数组连成一个新数组。</li>
<li>reverse() 方法可返回当前数组倒序排序形式。</li>
<li>join() 方法可将数组内各个元素按参数指定的分隔符连接成一个字符串。参数可以省略，省略参数时，分隔符默认为“逗号”。</li>
<li>forEach() 方法用于对数组的每个元素执行一次回调函数。</li>
<li>filter() 方法用于创建一个新的数组，其中的元素是指定数组中所有符合指定函数要求的元素。</li>
<li>map() 方法用于创建一个新的数组，其中的每个元素是指定数组的对应元素调用指定函数处理后的值。</li>
<li>reduce() 用于使用回调函数对数组中的每个元素进行处理，并将处理进行汇总返回。</li>
<li>find() 用于获取使回调函数值为 true 的第一个数组元素。如果没有符合条件的元素，将返回 undefined。</li>
</ol> 
<h5>
<a id="JavaScript__32"></a>JavaScript 有几种类型</h5> 
<p>基本数据类型：undefined、null、boolean、number、string、symbol(es6的新数据类型)<br> 引用数据类型：object、array、function(统称为object)</p> 
<h5>
<a id="_35"></a>数据类型检测</h5> 
<p>typeof<br> instanceof<br> Object.prototype.toString.call()</p> 
<h5>
<a id="_39"></a>深浅拷贝</h5> 
<p>浅拷贝<br> Object.assign()<br> 深拷贝<br> JSON.parse(JSON.stringify(obj))<br> 浅拷贝只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。<br> 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p> 
<h5>
<a id="_46"></a>闭包</h5> 
<p>闭包的原理就是作用域链，比如 函数F内部有一个函数G，函数 G可以访问到函数F中的变量，那么函数G就是闭包</p> 
<h5>
<a id="JS__48"></a>JS 如何实现一个类</h5> 
<p>构造函数法<br> ES6 语法糖 class<br> 一句话解析什么是原型链 遍历一个实列的属性时，先遍历实列对象上的属性，再遍历它的原型对象，一直遍历到Object</p> 
<h5>
<a id="Js_52"></a>Js如何实现继承？</h5> 
<p>构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</p> 
<h6>
<a id="new__54"></a>new 操作符具体干了什么？</h6> 
<p>首先是创建实例对象{}<br> this 变量引用该对象，同时还继承了构造函数的原型<br> 其次属性和方法被加入到 this 引用的对象中<br> 并且新创建的对象由 this 所引用，最后隐式的返回 this</p> 
<h5>
<a id="this__60"></a>this 对象的理解</h5> 
<p>普通函数<br> this 总是指向函数的直接调用者<br> 如果有 new 关键字，this 指向 new 出来的实例对象<br> 在事件中，this 指向触发这个事件的对象<br> IE 下 attachEvent 中的 this 总是指向全局对象 Window<br> 箭头函数中，函数体内的this对象，就是定义时所在作用域的对象，而不是使用时所在的作用域的对象。</p> 
<h5>
<a id="applycallbind_67"></a>apply、call、bind</h5> 
<p>call、apply和bind是Function对象自带的三个方法，都是为了改变函数体内部 this 的指向。<br> apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；<br> apply 、 call 、bind 三者都可以利用后续参数传参；<br> bind 是返回对应 函数，便于稍后调用；apply 、call 则是立即调用 。</p> 
<h5>
<a id="_72"></a>宏任务/微任务</h5> 
<p>macro-task(宏任务)：当前调用栈中执行的任务称为宏任务。包括：script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。<br> .micro-task(微任务)： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。包括：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver<br> 不同类型的任务会进入对应的Event Queue，宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</p> 
<h5>
<a id="typeof__76"></a>typeof 返回哪些类型？</h5> 
<p>值类型： undefined / string / number / boolean /symbol<br> 引用类型 ： object (注意：typeof null === ‘object’<br> 函数类型： function</p> 
<h5>
<a id="_80"></a>列举强制类型转换和隐式类型转换</h5> 
<p>强制类型转换：parseInt parseFloat toString<br> 隐式： if 逻辑运算 == +拼接字符串<br> [ ]中括号，表示一个数组，也可以理解为一个数组对象。<br> { } 大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数</p> 
<h5>
<a id="split__join__85"></a>split() 和 join() 的区别</h5> 
<p>‘1-2-3’.split(’-’) // [1,2,3]<br> [1,2,3].join(’-’) // ‘1-2-3’</p> 
<h5>
<a id="get_push__88"></a>get 和push 的区别</h5> 
<p>get 一般用于查询操作，post一般用于提交操作<br> get 参数拼接在url上，post放在请求体内（数据体积可更大）<br> post 比较安全</p> 
<h5>
<a id="foreachfor_infor_of_92"></a>foreach、for in、for of三者对比</h5> 
<ul>
<li>forEach 专门用来循环数组，可以直接取到元素，同时也可以取到 index 值，不能 break 终止循环，没有返回值，不能 return</li>
<li>for in一般循环遍历的都是对象的属性，遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性 key 会变成字符串类型</li>
<li>for of 是 ES6 引入的标准，一般情况下用于遍历数组，可以遍历数组内的值，与索引无关</li>
</ul> 
<h5>
<a id="cookie_96"></a>怎么设置cookie有效时间</h5> 
<p>Max-Age 指定从现在开始 Cookie 存在的秒数. 秒数过完则 cookie 过期</p> 
<h5>
<a id="_98"></a>防抖，节流</h5> 
<p>节流和防抖都是性能优化的方法</p> 
<ul><li> <p>防抖<br> 原理：事件触发时，不要马上执行动作，而是设定一个延迟时间（这个时间很短，比如 500ms）,在延迟时间内，再次触发事件，则重新计时<br> 适用场景：搜索联想，保证在输入完毕后才发送请求<br> <img src="https://images2.imgbox.com/1c/27/9R6IA6ft_o.png" alt="在这里插入图片描述"></p> <p>上面会在等待一定时间后才会执行，虽然这个等待时间以毫秒为单位<br> 如果希望事件触发后马上就执行，可以修改代码如下(有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行)</p> </li></ul> 
<p><img src="https://images2.imgbox.com/ec/c4/DZARHIRT_o.png" alt="在这里插入图片描述"></p> 
<ul><li>节流<br> 原理：事件触发后，规定在一个单位时间内，只能执行一次要执行的代码，如果在这个单位时间内多次触发函数，只有一次生效<br> 适用场景：如拖拽浏览器、上拉加载更多(web app 中)，因为都是高频触发，就需要节流进行控制。另外对于用户频繁点击登录按钮的情况，其实使用防抖和节流都是可以的。<br> 下面的代码使用定时器实现节流函数<br> <img src="https://images2.imgbox.com/3a/bf/HcjZ0JUk_o.png" alt="在这里插入图片描述">
</li></ul> 
<blockquote> 
 <p>另外，要想到对方可能问，某些使用节流函数的场景为什么不能使用防抖实现，比如上拉加载更多时为什么不能使用防抖。这个要结合具体业务来说，比如防抖是最后一次的操作才生效，而我们上拉加载更多是一个平滑的不间断的过程，我们希望在上拉过程中就加载数据，而不是停止滑动才加载</p> 
</blockquote> 
<h5>
<a id="_120"></a>什么是跨域？如何处理跨域？</h5> 
<p>1、jsonp跨域<br> 利用了 script 不受同源策略的限制<br> 2、CORS（Cross-Origin Resource Sharing），跨域资源共享 当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin； 后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-AllowOrigin；<br> 3、nginx反向代理<br> 4、PHP端修改header<br> 5、document.domain<br> 6、window.name<br> 7、postMessage</p> 
<h5>
<a id="_131"></a>重绘和回流</h5> 
<p>1）首先可以先说一下重绘和回流的概念<br> 回流：当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流<br> 仔细分析的话，就是上面的这些改变会影响到布局的改变，就会造成回流<br> 重绘：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。<br> 2）在说明基本概念后，可以根据实际情况决定是否聊一下关于性能的问题，以及浏览器是如何优化的<br> 回流比重绘的代价要更高<br> 有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流<br> 现代浏览器会对频繁的回流或重绘操作进行优化：<br> 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。<br> 下面不用说，但还是建议记几个，以防万一<br> <img src="https://images2.imgbox.com/33/be/1pyffd7r_o.png" alt="在这里插入图片描述"></p> 
<p>3）可以继续说一下，代码编写代码时，如何尽量避免重绘或者回流<br> CSS<br> • 避免使用table布局<br> • 尽可能在DOM树的最末端改变class<br> • 避免设置多层内联样式<br> • 将动画效果应用到position属性为absolute或fixed的元素上，因为这两种定位的元素脱离了文档流，其改变不会影响到文档<br> • 避免使用CSS表达式（例如：calc()）<br> JavaScript<br> • 避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性<br> • 避免频繁操作DOM创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中<br> • 也可以先为元素设置 display: none ，操作结束后再把它显示出来。因为在display属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘<br> • 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来<br> • 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流<br> 4. 附一些常用且会导致会回流的属性和方法，尽量记几个，万一面试中问到，就可以说一下<br> <img src="https://images2.imgbox.com/ad/53/qlywoomJ_o.png" alt="在这里插入图片描述"></p> 
<h5>
<a id="commit_message__160"></a>commit message 规范</h5> 
<p>在多人协作项目中，如果代码风格统一、代码提交信息的说明准确，那么在后期协作以及Bug处理时会 更加方便。Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。一般来 说，commit message 应该清晰明了，说明本次提交的目的。 Commit message 的作用<br> ● 提供更多的历史信息，方便快速浏览<br> ● 过滤某些commit（比如文档改动），便于快速查找信息<br> ● 直接从commit生成Change log<br> ● 可读性好，清晰，不必深入看代码即可了解当前commit的作用。<br> ● 为 Code Reviewing（代码审查）做准备<br> ● 方便跟踪工程历史<br> ● 提高项目的整体质量，提高个人工程素质</p> 
<h5>
<a id="git_flow__169"></a>git flow 工作流</h5> 
<p>Git Flow定义了一个项目发布的分支模型，为管理具有预定发布周期的大型项目提供了一个健壮的框 架。 流程</p> 
<ol>
<li>master分支存放所有正式发布的版本，可以作为项目历史版本记录分支，不直接提交代码。仅用 于保持一个对应线上运行代码的 code base。</li>
<li>develop分支为主开发分支，一般不直接提交代码</li>
<li>feature分支为新功能分支，feature分支都是基于develop创建的，开发完成后会合并到develop 分支上。同时存在多个</li>
<li>release分支基于最新develop分支创建，当新功能足够发布一个新版本(或者接近新版本发布的截 止日期)，从develop分支创建一个release分支作为新版本的起点，用于测试，所有的测试bug在这 个分支改。测试完成后合并到master并打上版本号，同时也合并到develop，更新最新开发分支。 (一旦打了release分支之后不要从develop分支上合并新的改动到release分支)，同一时间只有1 个，生命周期很短，只是为了发布。</li>
<li>hotfix分支基于master分支创建，对线上版本的bug进行修复，完成后直接合并到master分支和 develop分支，如果当前还有新功能release分支，也同步到release分支上。同一时间只有1个，生 命周期较短</li>
</ol> 
<h5>
<a id="Js_179"></a>Js延迟加载</h5> 
<p>这个题目首先要问情对方到底问的是什么，是想知道 js 延迟加载，还是想知道懒加载<br> 如果是前者的话，我觉得可以从一下几方面聊聊</p> 
<ol>
<li>首先要明白浏览器渲染页面的过程，也就是为什么需要 js 延迟加载<br> 浏览器渲染页面经过了构建 dom tree、构建 cssdom，构建 render tree 的过程，而且 JS 是单线程语言，所以其在 构建 dom 树的过程中，如果遇到了 script 标签，就会停止 dom 树的构建，先执行 js 代码，当 js 代码执行完毕后，才会从中断的地方继续构建 dom 树</li>
<li>js 延迟加载就是尽量先完成 dom 树的构建，然后再执行 js<br> 根据上面所描述的过程，如果 js 执行花费的时间较长，拖慢了 dom 树的构建过程，就会导致页面的渲染变慢，也就是咱们平常所说的页面打开较慢。所以尽量确保 dom 树构建完毕后，在执行 script 代码</li>
<li>具体措施有哪些<br> • 将 script 标签往后放，别放在 header 中，我们以前就推荐放到 body 的结束标签前面，因为这时已经确保 dom 树渲染完毕了<br> • 引入外部 js 文件时，向 script 标签中加入 async ，这样html 的解析(dom渲染)和 js 脚本下载和执行就会同时进行<br> • 引入外部 js 文件时，向 script 标签中加入 defer，这样，无论在页面的任何地方引入外部 js 文件，都会等到 html 解析完毕后，才会下载和执行 js 脚本<br> 4）最后可以分析一下这几种措施各自的特点以及应用场景<br> 将 js 脚本引入放在 body 结束标签前的问题在于只有在所有 HTML DOM 加载完成后才开始脚本的加载/解析过程。对于有大量 JavaScript 代码的大型网站，可能会带来显著的性能损耗<br> async 和 defer 就是用于解决这个问题的<br> 浏览器遇到 async 脚本时不会阻塞页面渲染，而是直接下载然后运行<br> 但如果脚本中某些代码依赖的某些 dom 元素还没有解析，就会出现问题，所以必须确保脚本无需等待页面解析，那么就可以使用 async<br> 另外，async 的另外一个缺点就是无法控制执行顺序，比如下面同时引入三个 js 文件，后面的 js 文件依赖前面的 jquery，使用 async 无法确保三个的执行顺序，可能就会出现问题<br> <img src="https://images2.imgbox.com/18/48/XrUVqR3S_o.png" alt="在这里插入图片描述">
</li>
</ol> 
<p>所以还要确保加载的多个脚本之间没有互相依赖，才可以使用 async</p> 
<p>如果脚本之间有依赖，希望按照顺序加载执行，可以将 async 改成 defer</p> 
<p>总结：<br> • 如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 async<br> • 如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML 中。</p> 
<p>上面就是对于 js 延迟加载的分析，面试时要根据实际情况整理成自己的语言回答</p> 
<h5>
<a id="dom_207"></a>虚拟dom</h5> 
<p>关于虚拟dom：首先先从我们的真是dom来描述，知道浏览器如何解析的真是dom 首先是html分析器去解析html元素 然后形成dom树，然后css分析器分析css样式 生成一个样式表 接着会将dom树和样式表关联起来 构建一颗render树 因为每个dom节点上都有attach方法来接受样式信息 结合后 返回一个render对象 这些对象 最终会被构建成一个render树 然后有个render树 浏览器来时找每个render的对应显示的精准坐标 然后会调用每个节点上的paint方法去绘制到页面中<br> 真实dom的弊端，因为原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。因为我们一般情况下 有时候我们改变一哥数据仅仅是影响的一个dom或者是一部分dom的变化 而真实dom会进行完整的更新和构建，所以就出现了虚拟dom，虚拟dom也就是一个js对象 就是他会将更新dom的的diff保存到js对象中 几次的dom操作变成了将操作转换成操作js对象 然后一次性的将js对象去attch到dom树上 交给浏览器去绘制</p> 
<h5>
<a id="new_211"></a>自己实现一个new方法</h5> 
<p><img src="https://images2.imgbox.com/aa/13/cu8HN78e_o.png" alt="在这里插入图片描述"></p> 
<h5>
<a id="_214"></a>自己写一个深浅克隆</h5> 
<p><img src="https://images2.imgbox.com/a3/a8/C9pzTKoR_o.png" alt="在这里插入图片描述"></p> 
<h5>
<a id="js__223"></a>微任务和宏任务(js 运行机制)</h5> 
<p>其实，无论对方问 微任务、宏任务、还是事件循环、栈、堆、队列等，都是对于 js 运行机制的考察<br> 所以，我们在这里对 js 运行机制做一个大概的梳理</p> 
<p>有几个点，给大家梳理一下<br> • 为什么 js 被设计为单线程语言？如果两个线程同时对一个节点进行操作，一个删除某个子节点，一个修改这个子节点，那么结果应该是什么呢？所以 js 被设计为单线程<br> • js 任务为什么分为同步和异步任务？有些 js 代码耗时较长，但后面的代码又不依赖于上面代码的运行结果，为了提升效率，提出了同步和异步的解决方案<br> • 浏览器是多进程的。js 虽然是单线程语言，但是运行宿主之一的浏览器被设计为多进程的（一个进程可以包含多个线程）。为什么？试想，我们打开一个 tab 选项卡听歌，再打开一个写博客，可能还打开一个挂着某个网页游戏，如果单线程，搞得定吗<br> • 浏览器有一个进程叫做 渲染进程，负责页面的渲染，js 执行，事件的循环。渲染进程中有多个线程。其中 GUI 渲染线程负责渲染浏览器界面，JS 引擎线程，负责 js 脚本执行，事件触发线程用来控制事件循环，管理者一个事件队列<br> • 宏任务和微任务： js 中的任务分为同步和异步任务，异步任务分为宏任务和微任务（整体 script 代码执行也是一个宏任务，却并不是异步的），宏任务和微任务不再一个事件队列。一个宏任务执行完毕后，判断当前执行栈上是否有微任务，有的话执行当前的所有微任务，然后渲染，没有微任务的话，直接渲染，渲染完毕后再次执行下一个宏任务<br> • 事件循环：js 代码执行时，分为同步任务和异步任务。同步任务直接进入主线程开始执行，异步任务分为宏任务和微任务。一个宏任务执行完毕后，判断当前执行栈上是否有微任务，有的话执行当前的所有微任务，然后渲染，没有微任务的话，直接渲染，渲染完毕后再次执行下一个宏任务。这个过程就是事件循环<br> <img src="https://images2.imgbox.com/85/9d/deDvvY4x_o.png" alt="在这里插入图片描述"></p> 
<p>• 常见宏任务<br> o 主代码块<br> o setTimeout<br> o setInterval<br> o setImmediate ()-Node<br> o requestAnimationFrame ()-浏览器</p> 
<p>• 常见微任务<br> o process.nextTick ()-Node<br> o Promise.then()<br> o catch<br> o finally<br> o Object.observe<br> o MutationObserver</p> 
<h5>
<a id="Http_252"></a>Http的几种请求方式</h5> 
<p>对于一般人来说，能记住的无非就是前5个，所以大家回答时，能打出前5个就好了，后面几个可以说隐约记得，还有个啥方法，但是干嘛用的想不起来了，这样显得真实<br> • get<br> • post<br> • put<br> • delete<br> • OPTIONS:OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略<br> • TRACE:TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量<br> • CONNECT:CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）<br> • HEAD:HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容</p> 
<h5>
<a id="Es6_264"></a>Es6箭头函数和普通函数区别</h5> 
<p>• 箭头函数是匿名函数，不能作为构造函数，不能使用new<br> <img src="https://images2.imgbox.com/58/85/xbmbb9Wf_o.png" alt="在这里插入图片描述"></p> 
<p>• 箭头函数内部不能使用 arguments</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> <span class="token function-variable function">B</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token constant">B</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">92</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError: arguments is not defined</span>
</code></pre> 
<p>• 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值<br> • 箭头函数没有原型属性<br> <img src="https://images2.imgbox.com/10/af/ziOqT1Ig_o.png" alt="在这里插入图片描述"></p> 
<h5>
<a id="Es6es5es6_281"></a>Es6相较于es5的优势，为什么喜欢使用es6</h5> 
<p>也可能会问， ES6 有哪些新特性，等等<br> 这个可以参考 ES6 入门教程 - ECMAScript 6入门 (ruanyifeng.com)<br> 找一些用的多的，说一说即可<br> 当然，这里的 ES6 就是 ES2015<br> 可以装逼的告诉面试官，自己认为的 ES6 是广义的 ES6，包含了 ES2015、2016、2017、2018、2019、2020、2021<br> 当然 ES2015 是变化最大的，后面的变化稍微小一些<br> 基于上面的认知，至少 模块化、解构赋值、Promise、async 和 await、新的创建类的方法、set 和 map 数据结构应该说出来</p> 
<h5>
<a id="vuereact___291"></a>使用vue/react 自己编写一个 页码组件</h5> 
<p>要求:</p> 
<ol>
<li>能实现上一页 下一页</li>
<li>选中是数字高亮</li>
<li>可以输入页码进行跳转</li>
<li>展示总页数</li>
<li>可以设置每一页的条数</li>
</ol> 
<p>这个说白了，就是仿一下 elementui 的分页组件，考察的是你的编写组件的能力<br> 其实在聊项目的时候，也可以说你觉得组件库（如 elementui) 的分页组件不好用，所以自己封装了一个分页组件，当然你要实际写写，想清楚这个组件的特点，有哪些功能是 elementui 的分页组件不具有的，或者比人家好的，这些事情要想清楚，吹牛之前要做足充分的准备</p> 
<h5>
<a id="_302"></a>前端开发的大体流程</h5> 
<p>通过这个问题，可以看出平时开发是否规范，而且也能看出你实际的开发经验<br> 对于这种问题，没有固定的回答，根据项目的规模、团队的配置（比如是否有测试、运维人员等）、技术负责人的能力，开发流程肯定是不一样的<br> 回答这类问题的时候，不要跟背书似的，而要老神在在，大概的回答可以这样：<br> 我们公司项目的开发流程大概是这样的<br> 首先大家坐在一起，研讨项目需求，这个一般前后端做到一起讨论，项目经历也参与（如果有的话）<br> 需求定下来之后，产品经理出原型(如果有产品经理的话，很多小企业都是后端或者前端兼了)<br> UI 同学出设计稿<br> 前端同学和 UI 同学开始撕逼，不好实现或者有兼容问题的地方让 UI 去改<br> 设计稿定下来后，前端同学出静态页面<br> 前端同学编写前端逻辑，调用后台接口，完成功能<br> 注：从需求定下来后，前端同学就需要跟后端同学不断的沟通接口的问题，这是一个持续的过程<br> 前后端联调，这基本要等到前后端功能，开发的都差不多的时候<br> 联调有问题，赶紧修改，没问题，推给测试人员测试，然后就是测试=》改bug=》测试=》改bug 这样循环，直到没有 bug 为止。（当然很多小企业没有专门的测试人员，所以这个步骤就是开发人员自己简单做一点功能测试即可）<br> 上线（谁上线？运维人员，前提是有运维的话，大多数小企业，都是后端或前端人员搞定了）<br> 后边项目有问题了就继续修改行了<br> 注意：公司规模不一样，人员配置不一样，上面的步骤就不一样，所以大家要先想清楚，自己原来公司的规模等等，没有意外的话，都是小公司，毕竟小地方来的嘛<br> <strong>记住一点 前后端开发 后端先行</strong></p> 
<h5>
<a id="_322"></a>发布订阅模式</h5> 
<p>发布订阅模式是设计模式中的一种<br> 发布-订阅模式其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知<br> 举个生活中的栗子，就是公众号，我们订阅了公众号后，公众号只要发布新的内容，我们就可以收到，这就是典型的发布订阅模式（一个公众号对应多个用户），公众号是发布者，我们是订阅者<br> 需要注意的是，在发布者和订阅者之间，还有一个调度中心，就是腾讯的服务，其负责将公众号发布的内容，通知给订阅者<br> 所以，当我们聊到发布订阅模式的时候，其实是由三个主体的：发布者、调度中心、订阅者，这与观察者模式稍有不同<br> 具体到代码层面，看下面代码，就是典型的发布订阅模式，body 的单击事件一旦触发，就相当于发布了内容，绑定的事件处理函数就会执行（相当于订阅者），调度中心很显然就是 js 引擎，负责将 body 的单击事件通知给事件处理函数<br> 而且我们为 body 单击事件添加了多个事件处理函数，就好比是多个订阅者<br> <img src="https://images2.imgbox.com/bb/71/AJGmYF11_o.png" alt="在这里插入图片描述"><br> 理解了上面的内容后，面试的时候可能会让你手写代码，演示发布订阅模式<br> <img src="https://images2.imgbox.com/32/e7/v5EI6DDl_o.png" alt="在这里插入图片描述"><br> 最后总是难免要聊一下 vue 中 发布订阅模式的应用<br> 在 vue 实例初始化时，Object.defineProperty 方法，为 data 函数中的对象中属性添加了订阅，同时会初始化一个 watcher(调度中心)，当对象属性发生改变时，向订阅者发送一个通知，然后订阅者执行 dom 操作，根据属性最新的只刷新视图</p> 
<h5>
<a id="_promise_336"></a>聊聊 promise</h5> 
<p>像这种问题，无非聊聊一下几点<br> ● Promise 是什么<br> ● Promise 解决了什么问题<br> ● Promise 有什么不足之处<br> ● 如果能手写一个 Promise 实现就更完美了</p> 
<p>其实，能说出前两个问题基本就及格了，如果能够说一说不足之处，就代表了你是仔细使用了的。如果人家有要求，你再能够手写一个 Promise 的实现，基本半小时就过去了，差不多也就过了</p> 
<p>Promise 是一个对象，它代表了一个异步操作的最终完成或者失败，这种书法太书面了，通俗点的说法如下<br> 一般我们都会在函数中使用 Promise ，更确切的说是返回一个 Promise，可以在这个 Promise 上绑定回调函数，常见的绑定回调函数的方式就是将成功的回调函数作为 resolve 方法的参数传入，将失败的回调函数作为 reject 方法的参数传入<br> <img src="https://images2.imgbox.com/20/6e/bP2tCoA9_o.png" alt="在这里插入图片描述"></p> 
<p>所以，第二个问题的答案就是，Promise 可以解决回调地狱的问题，当然并不是只有这一个作用，更详细的解答可以自行搜索</p> 
<p>至于缺点和手写 promise ，自行百度搜索</p> 
<h5>
<a id="_axios__355"></a>你是如何封装 axios 的</h5> 
<p>这是一个老生常谈的问题，对于 axios 的封装，大概如下几个方面<br> ● 编写请求拦截器，拦截去中主要工作是配置统一的后台请求基准地址；设置超时时间；向 header 中添加 token 等<br> ● 编写响应拦截器：拦截器中主要工作是配置统一的错误处理，比如 token 过期自动续命，统一显示错误信息等<br> ● 对于重复请求的处理，这个单说一下<br> 参考这篇文章 https://juejin.cn/post/6968630178163458084<br> 这里简单说下，取消重复请求，主要是为了减轻后端接口的压力，造成不必要的结果，比如，用户重复点击下单页面，如果不做重复请求的判断和处理，可能会造成重复下单问题，当然这个问题，后端一定也会判读处理，但是我们最好还是在前端处理一下<br> 处理的大概思路<br> 在相应拦截器中，拿到每次请求的接口信息，并将其存储到队列中，</p> 
<h5>
<a id="objectdefinedproperty_366"></a>object.definedproperty缺点</h5> 
<p>无法检测到对象属性的新增或删除<br> 由于js的动态性，可以为对象追加新的属性或者删除其中某个属性，这点对经过Object.defineProperty方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性和删除属性，这就需要另外处理。<br> 不能监听数组的变化<br> vue在实现数组的响应式时，它使用了一些hack，把无法监听数组的情况通过重写数组的部分方法来实现响应式，这也只限制在数组的push/pop/shift/unshift/splice/sort/reverse七个方法，其他数组方法及数组的使用则无法检测到，</p> 
<h5>
<a id="importrequire_373"></a>import和require区别</h5> 
<p>遵循规范 require 是 AMD规范引入方式 import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法 调用时间 require是运行时调用，所以require理论上可以运用在代码的任何地方 import是编译时调用，所以必须放在文件开头 本质 require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量 import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</p> 
<h5>
<a id="proptype__proto___378"></a>构造函数、proptype和__proto__的区别</h5> 
<p>所有构造函数的__proto__都指向Function.prototype，它是一个空函数（Empty function）</p> 
<p>还有些内置对象比如Math，JSON是以对象形式存在的，无需new。它们的__proto__是Object.prototype<br> 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法，如length、call、apply、bind（ES5）。<br> .prototype是一个对象的原型对象，而.__proto__则是对原型对象的引用！</p> 
<h5>
<a id="Vue__385"></a>Vue 如何清除浏览器缓存？</h5> 
<p>项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；<br> 在 html 文件中加入 meta 标签，content 属性设置为no-cache;<br> 在后端服务器中进行禁止缓存设置。</p> 
<h5>
<a id="Vuerouter__390"></a>Vue-router 路由有哪些模式？</h5> 
<p>一般有两种模式：</p> 
<p>hash 模式：后面的 hash 值的变化，浏览器既不会向服务器发出请求，浏览器也不会刷新，每次 hash 值的变化会触发 hashchange 事件。<br> history 模式：利用了 HTML5 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。<br> Vue-cli 项目中 assets 和 static 文件夹有什么区别？<br> 两者都是用于存放项目中所使用的静态资源文件的文件夹。其区别在于：<br> ** assets 中的文件在运行 npm run build 的时候会打包**，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到 static 中。static 中的文件则不会被打包。</p> 
<p>v-model的原理<br> v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。</p> 
<h5>
<a id="xmljson_402"></a>xml和json的区别</h5> 
<p>1、读取的方式不一样。XML是使用XML DOM来循环遍历文档，JSON可以通过JSON.parse方法将json字符串转化为JavaScript可解析的格式。<br> 2、格式不一样，XML的格式是对便签类似于HTML便签一样，而JSON是key/value的格式。</p> 
<h5>
<a id="ajax_405"></a>描述创建ajax的过程</h5> 
<p>step1. 创建XMLHttpRequest对象，也就是创建一个异步调用对象；<br> step2. 创建一个新的HTTP请求，并指定改HTTP请求的方法、URL以及验证信息；<br> step3. 设置响应HTTP状态变化的函数；<br> step4. 发送HTTP请求；<br> step5. 获取异步调用返回的数据；<br> step6. 使用javascript和DOM实现局部刷新；</p> 
<h5>
<a id="_412"></a>说说你对闭包的理解</h5> 
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p> 
<ol>
<li>可以在函数的外部访问到函数内部的局部变量。</li>
<li>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</li>
</ol> 
<h5>
<a id="strongembi_417"></a>分别描述<strong><em><b><i>标签</i></b></em></strong>
</h5> 
<h5>
<a id="deferasync_418"></a>defer和async的作用</h5> 
<p>defer：用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。<br> async：用于异步下载脚本文件，下载完毕立即解释执行代码。</p> 
<h5>
<a id="cookie_422"></a>cookie的过期时间</h5> 
<pre><code class="prism language-javascript">设置一分钟过期
<span class="token keyword">const</span> nextTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">1000</span>  <span class="token comment">//Date.now()是得到计算机开始的时间到现在的毫秒数，一毛1000毫秒</span>
 
<span class="token keyword">const</span> expiresTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>nextTime<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUTCString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//转成UTC格式的字符串</span>
 
res<span class="token punctuation">.</span><span class="token function">writeHeader</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
 
<span class="token string">"Content-Type"</span><span class="token operator">:</span><span class="token string">"text/html;charset=utf-8"</span><span class="token punctuation">;</span>
<span class="token string">"Set-cookie"</span><span class="token operator">:</span><span class="token punctuation">[</span>isvisit<span class="token operator">=</span>yes<span class="token punctuation">;</span>expires<span class="token operator">=</span><span class="token string">"+expiresTime "</span><span class="token punctuation">,</span>name<span class="token operator">=</span>zs<span class="token punctuation">]</span>
 
 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
 
 
isvisit<span class="token operator">=</span>yes
name<span class="token operator">=</span>zs
 
给哪一个设置到期时间哪个就起作用，不然的的话不起作用，这个写的只有isvisit<span class="token operator">=</span>yes起作用，name<span class="token operator">=</span>zs还是默认的，关闭浏览器消失
</code></pre> 
<h5>
<a id="LocalStorage__sessionStorage__444"></a>LocalStorage 和 sessionStorage 之间的区别</h5> 
<p>LocalStorage 使用 localStorage 存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据 <br> 使用 sessionStorage 存储数据，整个浏览器未关闭前，其数据一直都是存在的，若浏览器关闭数据消失 <br> 数组的方法</p> 
<h5>
<a id="js_449"></a>js数组递归求和</h5> 
<p>递归</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>常用循环</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        s <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5>
<a id="GETPOST_474"></a>GET和POST区别</h5> 
<p>（1） GET的参数携带在URL地址中，POST请求的参数在request body中。<br> （2） GET在浏览器回退时不会再次提交请求，POST在浏览器回退时，会再次提交。<br> （3） GET请求会被浏览器主动cache(缓存)，而POST不会。<br> （4） GET请求传递参数长度有限制，POST没有。<br> （5） GET比POST更不安全，因为参数暴露在URL中，POST不会。</p> 
<h5>
<a id="_480"></a>在客户端是如何进行加密的？</h5> 
<p>哈希“加密”<br> 结合验证码进行前端加密<br> 非对称加密</p> 
<h5>
<a id="_this__484"></a>如何改变 this 指向</h5> 
<p>call() <br> apply() <br> bind()</p> 
<h5>
<a id="JSdom_488"></a>JS获取dom方法：</h5> 
<pre><code>1.通过ID获取（getElementById）
</code></pre> 
<ol start="2"><li>通过类名（getElementsByClassName）<br> 3.通过name属性（getElementsByName）<br> 4.通过标签名（getElementsByTagName）<br> 5.获取html的方法（document.documentElement）<br> 6.获取body的方法（document.body）<br> 7.通过css选择器获取一个元素（querySelector）<br> 8.通过选择器获取一组元素（querySelectorAll）</li></ol> 
<h5>
<a id="%09_497"></a>怎样把录音传递给后端 客户端实现录音之后，</h5> 
<p>将压缩后的音频对象Blob传给服务器：<br> 在该页面会创建下载连接，并以录音日期为文件名，可以选择下载，同时也会将音频对象传到服务器。<br> 因为前端通过音频流文件上传到后台后，不再是保存为wav格式的音频，而是处理流的形式转为二进制数组，直接调用百度语音识别SDK方法，即可返回识别结果，不必编码后发给后端，后端然后再解码。<br> 将结果使用websocket传给前端，显示在标签内就可以了：</p> 
<h5>
<a id="http_502"></a>http</h5> 
<p>概念：超文本传输协议（HTTP）是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的传输层上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。RUDP——作为 UDP 的可靠化升级版本——是一种合适的替代选择<br> http特性：<br> 1.HTTP 是无连接无状态的</p> 
<p>2.HTTP 一般构建于 TCP/IP 协议之上，默认端口号是 80</p> 
<p>3.HTTP 可以分为两个部分，即请求和响应。</p> 
<p>http请求：<br> HTTP 定义了在与服务器交互的不同方式，最常用的方法有 4 种 分别是 GET，POST，PUT， DELETE。URL 全称为资源描述符，可以这么认为：一个 URL 地址 对应着一个网络上的资源，而 HTTP 中的 GET，POST，PUT，DELETE 就对应着对这个资源的查询，修改，增添，删除4个操作。<br> HTTP 请求由 3 个部分构成，分别是：状态行，请求头(Request Header)，请求正文。<br> HTTP 响应由 3 个部分构成，分别是：状态行，响应头(Response Header)，响应正文。<br> HTTP 响应中包含一个状态码，用来表示服务器对客户端响应的结果。 状态码一般由3位构成：<br> 1xx : 表示请求已经接受了，继续处理。 2xx : 表示请求已经处理掉了。 3xx : 重定向。 4xx : 一般表示客户端有错误，请求无法实现。 5xx : 一般为服务器端的错误。<br> 常见的状态码：<br> 200 OK 客户端请求成功。<br> 301 Moved Permanently 请求永久重定向。<br> 302 Moved Temporarily 请求临时重定向。<br> 304 Not Modified 文件未修改，可以直接使用缓存的文件。<br> 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。<br> 401 Unauthorized 请求未经授权，无法访问。<br> 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。<br> 404 Not Found 请求的资源不存在，比如输入了错误的URL。<br> 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。<br> 502 Bad Gateway 是一种HTTP协议的服务器端错误状态代码，它表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的<br> 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</p> 
<h5>
<a id="js_529"></a>js计算数组重复出现的次数</h5> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> sumObj <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span> 
<span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
obj<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token operator">++</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
obj<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> obj
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>for循环</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">getEleNums</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">var</span> map <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">var</span> key <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
         map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> map
<span class="token punctuation">}</span>
</code></pre> 
<h4>
<a id="Axios_557"></a>Axios</h4> 
<h5>
<a id="ajax_558"></a>ajax原理</h5> 
<p>AJAX 的核心是 XMLHttpRequest 对象。<br> Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎)，使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器。像—些数据验证和数据处理等都交给Ajax引擎自己来做,，只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p> 
<h5>
<a id="XMLHttpRequest__561"></a>XMLHttpRequest 对象的三个常用的属性</h5> 
<ol>
<li>onreadystatechange 属性<br> onreadystatechange 属性存有处理服务器响应的函数。</li>
<li>readyState 属性<br> readyState 属性存有服务器响应的状态信息。每当 readyState 改变时，<br> onreadystatechange 函数就会被执行</li>
<li>responseText 属性<br> 可以通过 responseText 属性来取回由服务器返回的数据。</li>
</ol> 
<h5>
<a id="xmlhttprequst_569"></a>xmlhttprequst的方法</h5> 
<p>open() 方法<br> send() 方法</p> 
<h5>
<a id="Ajax_572"></a>Ajax编程步骤</h5> 
<p>创建XMLHttpRequest对象。<br> 设置请求方式。<br> 调用回调函数。<br> 发送请求。</p> 
<h5>
<a id="_577"></a>接口回调的方法</h5> 
<p>原生ajax<br> 基于jQuery的ajax<br> fetch<br> axios</p> 
<h5>
<a id="_582"></a>前后端交互的方式</h5> 
<ol>
<li>HTML赋值</li>
<li>JS赋值</li>
<li>script填充JSON</li>
<li>AJAX获取JSON</li>
<li>WebSocket实时传输数据</li>
</ol> 
<h4>
<a id="ES6_589"></a>ES6</h4> 
<h5>
<a id="letconst_590"></a>let&amp;const</h5> 
<p>特性：<br> let 不能重复声明变量，var 可以重复声明变量；<br> 块级作用域，es5中存在全局作用域、函数作用域、eval作用域；es6中引入了块级作用域，let声明的变量在块级作用域{}内有效<br> let声明的变量不存在var的变量提升问题</p> 
<h5>
<a id="_595"></a>解构赋值</h5> 
<p>ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值</p> 
<h5>
<a id="_597"></a>模板字符串</h5> 
<pre><code class="prism language-javascript">特性：

<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">(</span>反引号<span class="token punctuation">)</span>内容中可以直接出现换行符，’ '和<span class="token string">" "</span>中则不可以，出现会报错
可以直接进行变量拼接
</code></pre> 
<h5>
<a id="_606"></a>简化对象写法</h5> 
<p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法<br> （在属性名和变量名相同的情况下），这样的书写更加简洁</p> 
<h5>
<a id="_609"></a>箭头函数</h5> 
<p>与function声明的区别：</p> 
<ol>
<li>箭头函数this是静态的。<br> 箭头函数内的this指向上层对象；始终指向函数声明时所在作用域下的this的值，无法被call改变<br> 普通函数内的this指向调用其函数的对象</li>
<li>箭头函数不能作为构造函数实例化对象</li>
<li>箭头函数不能使用arguments变量，但是可以使用…rest<br> 箭头函数的简写<br> ① 当形参有且只有一个的时候，可以省略()<br> ② 当代码体只有一条语句的时候，可以省略{}，此时return必须省略，而且语句的执行结果就是函数的返回值</li>
</ol> 
<h5>
<a id="rest_619"></a>rest参数</h5> 
<p>ES6引入rest参数，用于获取函数的实参，用来代替arguments</p> 
<h5>
<a id="_621"></a>扩展运算符</h5> 
<p>…能将「数组」转为逗号分隔的「参数序列」<br> 注：虽然形式与rest参数类似，但是rest参数是用在函数定义时的形参位置，扩展运算符是用在函数实际调用时的实参位置<br> 应用场景：<br> 1.数组的合并<br> 2.数组的克隆<br> 3.将伪数组转为真正的数组</p> 
<h5>
<a id="symbol_628"></a>symbol</h5> 
<p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。<br> 它是JavaScript语言的第7种数据类型，是一个类似字符串的数据类型<br> Symbol特点：<br> Symbol的值是唯一的，用来解决命名冲突的问题<br> Symbol值不能与其他数据进行运算，也不能与自己进行运算，譬如+、-、*、/、比较运算<br> Symbol定义的对象属性不能使用for…in遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名</p> 
<h5>
<a id="symbol_635"></a>symbol的使用场景</h5> 
<p>给对象添加属性和方法。<br> 由于Symbol值具有唯一性，所以可以很安全地把属性和方法加入对象中</p> 
<h5>
<a id="_638"></a>迭代器</h5> 
<p>迭代器（iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。<br> 任何数据结构只要部署iterator接口，就可以完成遍历操作</p> 
<h5>
<a id="_641"></a>生成器</h5> 
<p>生成器本身是一个特殊的函数，<br> 生成器函数是ES6提供的一种异步编程解决方案，<br> 语法行为与传统函数不同<br> 执行生成器函数，返回的是一个迭代器对象，通过iterator.next()调用执行函数内语句<br> yield是函数代码的分隔符，结合调用iterator.next()方法，实现函数gen1的语句的分段执行<br> 使用for…of遍历函数执行后返回的迭代器对象，每一次遍历的item为yield后的表达式或者自变量的值</p> 
<h5>
<a id="set_649"></a>set集合</h5> 
<p>ES6提供了新的数据结构set(集合)，本质上是一个对象。<br> 它类似于数组，但成员的值都是唯一的，集合实现了iterator接口<br> ，所以可以使用「扩展运算符」和for…of进行遍历<br> 集合的属性和方法：<br> size，返回集合的元素个数<br> add，增加一个新元素，返回当前集合<br> delete，删除元素，返回Boolean值<br> has，检测集合中是否包含某个元素，返回Boolean值</p> 
<h5>
<a id="set_659"></a>set的应用</h5> 
<pre><code class="prism language-javascript">数组去重
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token comment">// 数组去重</span>
        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, 4, 5]</span>

求交集   求并集    求差集
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">let</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>

        <span class="token comment">// 求交集</span>
        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 对arr去重并进行遍历</span>
            <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span> <span class="token comment">// 将arr2变为元素不重复的集合</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果元素存在s2中</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token boolean">false</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// [4, 5]</span>

        <span class="token comment">// 简化写法</span>
        <span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>



</code></pre> 
<h5>
<a id="map_691"></a>map</h5> 
<p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合，<br> 但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。<br> Map也实现了iterator接口，所以可以使用「扩展运算符」和for…of进行遍历</p> 
<p>Map的属性和方法：</p> 
<p>size，返回Map的元素个数<br> set，增加一个新元素，返回当前Map<br> get，返回键名对象的键值<br> has，检测Map中是否包含某个元素，返回Boolean值<br> clear，清空集合，返回undefined</p> 
<h5>
<a id="async___await_705"></a>async await</h5> 
<p>不使用它请求数据 则是同步，会出现堵塞。<br> async/await是什么<br> async/await 是ES7提出的基于Promise的解决异步的最终方案。</p> 
<p>async<br> async是一个加在函数前的修饰符，被async定义的函数会默认返回一个Promise对象resolve的值。因此对async函数可以直接then，返回值就是then方法传入的函数。<br> await<br> await 也是一个修饰符，只能放在async定义的函数内。可以理解为等待。</p> 
<p>await 修饰的如果是Promise对象：可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；</p> 
<p>如果不是Promise对象：把这个非promise的东西当做await表达式的结果</p> 
<h5>
<a id="150%09var_filled__new_Array100_719"></a>怎么不用循环输出1到50 var filled = new Array(100);</h5> 
<p>filled.fill(1)<br> var a = filled.map(function(val, index){<!-- --><br> return index+1;<br> });<br> console.log(a);</p> 
<h3>
<a id="_731"></a>写在最后</h3> 
<blockquote> 
 <p>? 周周有福利，周周有惊喜 <a href="https://blog.csdn.net/guorui_java/article/details/121278798"> 风火轮计划</a><br><br> ? 更多前端硬核技术 总结 分享 交流 前端技术交流社区诚邀各位加入讨论 <a href="https://bbs.csdn.net/forums/JHXL">前端技术交流社区</a></p> 
</blockquote> 
<blockquote> 
 <p>✨<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          原
         
         
          创
         
         
          不
         
         
          易
         
         
          ，
         
         
          还
         
         
          希
         
         
          望
         
         
          各
         
         
          位
         
         
          大
         
         
          佬
         
         
          支
         
         
          持
         
         
          一
         
         
          下
         
        
       
       
        textcolor{blue}{原创不易，还希望各位大佬支持一下}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: blue">原</span><span class="mord cjk_fallback" style="color: blue">创</span><span class="mord cjk_fallback" style="color: blue">不</span><span class="mord cjk_fallback" style="color: blue">易</span><span class="mord cjk_fallback" style="color: blue">，</span><span class="mord cjk_fallback" style="color: blue">还</span><span class="mord cjk_fallback" style="color: blue">希</span><span class="mord cjk_fallback" style="color: blue">望</span><span class="mord cjk_fallback" style="color: blue">各</span><span class="mord cjk_fallback" style="color: blue">位</span><span class="mord cjk_fallback" style="color: blue">大</span><span class="mord cjk_fallback" style="color: blue">佬</span><span class="mord cjk_fallback" style="color: blue">支</span><span class="mord cjk_fallback" style="color: blue">持</span><span class="mord cjk_fallback" style="color: blue">一</span><span class="mord cjk_fallback" style="color: blue">下</span></span></span></span></span> <br><br> ? <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          点
         
         
          赞
         
         
          ，
         
         
          你
         
         
          的
         
         
          认
         
         
          可
         
         
          是
         
         
          我
         
         
          创
         
         
          作
         
         
          的
         
         
          动
         
         
          力
         
         
          ！
         
        
       
       
        textcolor{green}{点赞，你的认可是我创作的动力！}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: green">点</span><span class="mord cjk_fallback" style="color: green">赞</span><span class="mord cjk_fallback" style="color: green">，</span><span class="mord cjk_fallback" style="color: green">你</span><span class="mord cjk_fallback" style="color: green">的</span><span class="mord cjk_fallback" style="color: green">认</span><span class="mord cjk_fallback" style="color: green">可</span><span class="mord cjk_fallback" style="color: green">是</span><span class="mord cjk_fallback" style="color: green">我</span><span class="mord cjk_fallback" style="color: green">创</span><span class="mord cjk_fallback" style="color: green">作</span><span class="mord cjk_fallback" style="color: green">的</span><span class="mord cjk_fallback" style="color: green">动</span><span class="mord cjk_fallback" style="color: green">力</span><span class="mord cjk_fallback" style="color: green">！</span></span></span></span></span> <br><br> ⭐️ <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          收
         
         
          藏
         
         
          ，
         
         
          你
         
         
          的
         
         
          青
         
         
          睐
         
         
          是
         
         
          我
         
         
          努
         
         
          力
         
         
          的
         
         
          方
         
         
          向
         
         
          ！
         
        
       
       
        textcolor{green}{收藏，你的青睐是我努力的方向！}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: green">收</span><span class="mord cjk_fallback" style="color: green">藏</span><span class="mord cjk_fallback" style="color: green">，</span><span class="mord cjk_fallback" style="color: green">你</span><span class="mord cjk_fallback" style="color: green">的</span><span class="mord cjk_fallback" style="color: green">青</span><span class="mord cjk_fallback" style="color: green">睐</span><span class="mord cjk_fallback" style="color: green">是</span><span class="mord cjk_fallback" style="color: green">我</span><span class="mord cjk_fallback" style="color: green">努</span><span class="mord cjk_fallback" style="color: green">力</span><span class="mord cjk_fallback" style="color: green">的</span><span class="mord cjk_fallback" style="color: green">方</span><span class="mord cjk_fallback" style="color: green">向</span><span class="mord cjk_fallback" style="color: green">！</span></span></span></span></span> <br><br> ✏️ <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          评
         
         
          论
         
         
          ，
         
         
          你
         
         
          的
         
         
          意
         
         
          见
         
         
          是
         
         
          我
         
         
          进
         
         
          步
         
         
          的
         
         
          财
         
         
          富
         
         
          ！
         
        
       
       
        textcolor{green}{评论，你的意见是我进步的财富！}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;vertical-align: 0em"></span><span class="mord cjk_fallback" style="color: green">评</span><span class="mord cjk_fallback" style="color: green">论</span><span class="mord cjk_fallback" style="color: green">，</span><span class="mord cjk_fallback" style="color: green">你</span><span class="mord cjk_fallback" style="color: green">的</span><span class="mord cjk_fallback" style="color: green">意</span><span class="mord cjk_fallback" style="color: green">见</span><span class="mord cjk_fallback" style="color: green">是</span><span class="mord cjk_fallback" style="color: green">我</span><span class="mord cjk_fallback" style="color: green">进</span><span class="mord cjk_fallback" style="color: green">步</span><span class="mord cjk_fallback" style="color: green">的</span><span class="mord cjk_fallback" style="color: green">财</span><span class="mord cjk_fallback" style="color: green">富</span><span class="mord cjk_fallback" style="color: green">！</span></span></span></span></span> <br></p> 
</blockquote>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>