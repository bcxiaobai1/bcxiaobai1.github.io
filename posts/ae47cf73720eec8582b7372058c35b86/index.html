<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Android之 WebView的使用 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android之 WebView的使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p><strong><span style="color:#0d0016">一 简介</span></strong></p> 
<p>1.1 WebView是用来展示网页的控件，底层是google的WebKit的引擎。</p> 
<p>比起苹果的WebView，webkit一些不足地方：</p> 
<blockquote> 
 <ul>
<li><span style="color:#494949">不能支持word等文件的预览</span></li>
<li><span style="color:#494949">纯标签加载，并不支持所有标签的加载</span></li>
<li><span style="color:#494949">不支持文件的下载，图片的放大，都要单独处理</span></li>
</ul> 
</blockquote> 
<p>1.2 其它Web引擎，腾讯的webx5，其功能比WebKit要强大些，支持常见文件格式的预览（word文档，excel表格等），还支持文件的下载。</p> 
<p>官方地址: https://x5.tencent.com/tbs/</p> 
<p>1.3 WebView大部分场合还是能满足需求的，用官方Webkit就可以了</p> 
<p><span style="color:#0d0016"><strong>二 WebView的使用</strong></span></p> 
<p>2.1 初始化webview组件</p> 
<p>xml里面初始化</p> 
<pre><code class="language-XML">&lt;WebView
   android:id="@+id/webview"
   android:layout_width="match_parent"
   android:layout_height="match_parent" /&gt;</code></pre> 
<p>获取动态初始化</p> 
<pre><code class="language-java">WebView webView = new WebView(this);
llWebview.addView(webView);</code></pre> 
<p>2.2 配置WebSettings</p> 
<pre><code class="language-java">//声明WebSettings子类
WebSettings webSettings = webView.getSettings();

//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript
webSettings.setJavaScriptEnabled(true);  

//支持插件
webSettings.setPluginsEnabled(true); 

//设置自适应屏幕，两者合用
webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小 
webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小

//缩放操作
webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。
webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放
webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件

//其他细节操作
webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存 
webSettings.setAllowFileAccess(true); //设置可以访问文件 
webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口 
webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片
webSettings.setDefaultTextEncodingName("utf-8");//设置编码格式</code></pre> 
<p>2.3 加载网页链接或加载标签</p> 
<p>加载网页链接</p> 
<pre><code class="language-java">//加载http链接：http://www.google.com/
//加载assets链接：file:///android_asset/test.html
//加载本地存储链接：http://www.google.com/
webView.loadUrl("http://www.google.com/");</code></pre> 
<p>加载标签</p> 
<pre><code class="language-java">String goods_content="&lt;p&gt;我的第一个段落。&lt;/p&gt;";
webView.loadDataWithBaseURL(null, WebUtil.getHtmlData(goods_content), "text/html", "utf-8", null);

public static String getHtmlData(String bodyHTML) {
	String head = "&lt;head&gt;" +
			"&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"&gt; " +
			"&lt;style&gt;div,p,img{max-width: 100%; width: 100% !important; height: auto !important;}" +
			"body {" +
			"margin-right:8px;" +//限定网页中的文字右边距为15px(可根据实际需要进行行管屏幕适配操作)
			"margin-left:8px;" +//限定网页中的文字左边距为15px(可根据实际需要进行行管屏幕适配操作)
			"margin-top:8px;" +//限定网页中的文字上边距为15px(可根据实际需要进行行管屏幕适配操作)
			"font-size:16px;" +//限定网页中文字的大小为40px,请务必根据各种屏幕分辨率进行适配更改
			"word-wrap:break-word;" +//允许自动换行(汉字网页应该不需要这一属性,这个用来强制英文单词换行,类似于word/wps中的西文换行)
			"}" +
			"p { margin: 0; }" +
			"&lt;/style&gt;" +
			"&lt;/head&gt;";


	return "&lt;html&gt;" + head + "&lt;body&gt;" + bodyHTML + "&lt;/body&gt;&lt;ml&gt;";
}</code></pre> 
<p>2.4 设置WebViewClient，来处理通知和请求事件</p> 
<p>常规用法，复写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示</p> 
<pre><code class="language-java">webView.setWebViewClient(new WebViewClient(){
      @Override
      public boolean shouldOverrideUrlLoading(WebView view, String url) {
          view.loadUrl(url);
      return true;
      }
});</code></pre> 
<p>完整用法</p> 
<pre><code class="language-java">webViewClient = new WebViewClient() {
     /**
	 * shouldOverrideUrlLoading
	 * &lt;p&gt;
	 * 当加载的网页需要重定向的时候就会回调这个函数告知我们应用程序是否需要接管控制网页加载，如果应用程序接管，
	 *并且return true意味着主程序接管网页加载，如果返回false让webview自己处理。
	 * &lt;/p&gt;
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param url
	 *            即将要被加载的url
	 * @return true 当前应用程序要自己处理这个url， 返回false则不处理。 注："post"请求方式不会调用这个回调函数
	 */
	@Override
	public boolean shouldOverrideUrlLoading(WebView view, String url) {
		if (Uri.parse(url).getHost().equals("www.baidu.com")) {
			Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
			context.startActivity(intent);
			return true;
		}
		return false;
	}
	
	/**
	 * onPageStarted 当内核开始加载访问的url时，会通知应用程序，对每个main frame
	 * 这个函数只会被调用一次，页面包含iframe或者framesets 不会另外调用一次onPageStarted，
     * 当网页内内嵌的frame 发生改变时也不会调用onPageStarted。
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param url
	 *            即将要被加载的url
	 * @param favicon
	 *            如果这个favicon已经存储在本地数据库中，则会返回这个网页的favicon，否则返回为null。
	 */
	@Override
	public void onPageStarted(WebView view, String url, Bitmap favicon) {
		// TODO Auto-generated method stub
		super.onPageStarted(view, url, favicon);
		Log.i(TAG, "onPageStarted:页面开始加载");
	}
	
	/**
	 * onPageFinished 当内核加载完当前页面时会通知我们的应用程序，这个函数只有在main
	 * frame情况下才会被调用，当调用这个函数之后，渲染的图片不会被更新，如果需要获得新图片的通知可以使用@link
	 * WebView.PictureListener#onNewPicture。 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param url
	 *            即将要被加载的url
	 */
	@Override
	public void onPageFinished(WebView view, String url) {
		// TODO Auto-generated method stub
		super.onPageFinished(view, url);
		Log.i(TAG, "onPageStarted:页面加载结束");
	}
	
	/**
	 * onLoadResource 通知应用程序WebView即将加载url 制定的资源
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param url
	 *            即将加载的url 资源
	 */
	@Override
	public void onLoadResource(WebView view, String url) {
		// TODO Auto-generated method stub
		super.onLoadResource(view, url);
		Log.i(TAG, "onLoadResource:加载资源指定的网址");
	}
	
	/**
	 * shouldInterceptRequest
	 * 通知应用程序内核即将加载url制定的资源，应用程序可以返回本地的资源提供给内核，若本地处理返回数据，内核不从网络上获取数据。
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param url
	 *            raw url 制定的资源
	 * @return 返回WebResourceResponse包含数据对象，或者返回null
	 */
	@Override
	public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
		// TODO Auto-generated method stub
		Log.i(TAG, "shouldInterceptRequest");
		return super.shouldInterceptRequest(view, url);
	}
	
	/**
	 * onReceivedError
	 * &lt;p&gt;
	 * 当浏览器访问制定的网址发生错误时会通知我们应用程序 参数说明：
	 * &lt;/p&gt;
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param errorCode
	 *            错误号可以在WebViewClient.ERROR_* 里面找到对应的错误名称。
	 * @param description
	 *            描述错误的信息
	 * @param failingUrl
	 *            当前访问失败的url，注意并不一定是我们主url
	 */
	@Override
	public void onReceivedError(WebView view, int errorCode,
			String description, String failingUrl) {
		// TODO Auto-generated method stub
		super.onReceivedError(view, errorCode, description, failingUrl);
		view.loadUrl("file:///android_asset/error.html");
		Log.i(TAG, "onReceivedError");
	}
	
	/**
	 * 如果浏览器需要重新发送POST请求，可以通过这个时机来处理。默认是不重新发送数据。 参数说明
	 * 
	 * @param view
	 *            接收WebViewClient的webview
	 * @param dontResend
	 *            浏览器不需要重新发送的参数
	 * @param resend
	 *            浏览器需要重新发送的参数
	 */
	@Override
	public void onFormResubmission(WebView view, Message dontResend,
			Message resend) {
		// TODO Auto-generated method stub
		super.onFormResubmission(view, dontResend, resend);
		Log.i(TAG, "onFormResubmission");
	}
	
	/**
	 * doUpdateVisitedHistory
	 * 通知应用程序可以将当前的url存储在数据库中，意味着当前的访问url已经生效并被记录在内核当中。这个函数在网页加载过程中只会被调用一次。
	 * 注意网页前进后退并不会回调这个函数。
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param url
	 *            当前正在访问的url
	 * @param isReload
	 *            如果是true 这个是正在被reload的url
	 */
	@Override
	public void doUpdateVisitedHistory(WebView view, String url,
			boolean isReload) {
		// TODO Auto-generated method stub
		super.doUpdateVisitedHistory(view, url, isReload);
		Log.i(TAG, "doUpdateVisitedHistory");
	}
	
	/**
	 * 当网页加载资源过程中发现SSL错误会调用此方法。我们应用程序必须做出响应，是取消请求handler.cancel(),还是继续请求handler.
	 * proceed();内核的默认行为是handler.cancel();
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param handler
	 *            处理用户请求的对象。
	 * @param error
	 *            SSL错误对象
	 * 
	 */
	@Override
	public void onReceivedSslError(WebView view, SslErrorHandler handler,
			SslError error) {
		// view.loadUrl("file:///android_asset/error.html");
		// TODO Auto-generated method stub
		super.onReceivedSslError(view, handler, error);
		Log.i(TAG, "onReceivedSslError");
	}
	
	/**
	 * onReceivedHttpAuthRequest 通知应用程序WebView接收到了一个Http
	 * auth的请求，应用程序可以使用supplied 设置webview的响应请求。默认行为是cancel 本次请求。
	 * 
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param handler
	 *            用来响应WebView请求的对象
	 * @param host
	 *            请求认证的host
	 * @param realm
	 *            认真请求所在的域
	 */
	@Override
	public void onReceivedHttpAuthRequest(WebView view,
			HttpAuthHandler handler, String host, String realm) {
		// TODO Auto-generated method stub
		super.onReceivedHttpAuthRequest(view, handler, host, realm);
		Log.i(TAG, "onReceivedHttpAuthRequest");
	}
	
	/**
	 * shouldOverrideKeyEvent
	 * 提供应用程序同步一个处理按键事件的机会，菜单快捷键需要被过滤掉。如果返回true，webview不处理该事件，如果返回false，
	 * webview会一直处理这个事件，因此在view 链上没有一个父类可以响应到这个事件。默认行为是return false；
	 * 
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param event
	 *            键盘事件名
	 * @return 如果返回true,应用程序处理该时间，返回false 交有webview处理。
	 */
	@Override
	public boolean shouldOverrideKeyEvent(WebView view, KeyEvent event) {
		Log.i(TAG, "shouldOverrideKeyEvent");
		// TODO Auto-generated method stub
		return super.shouldOverrideKeyEvent(view, event);
	}
	
	/**
	 * 通知应用程序webview 要被scale。应用程序可以处理改事件，比如调整适配屏幕。
	 */
	@Override
	public void onScaleChanged(WebView view, float oldScale, float newScale) {
		// TODO Auto-generated method stub
		super.onScaleChanged(view, oldScale, newScale);
		Log.i(TAG, "onScaleChanged");
	}
	
	/**
	 * onReceivedLoginRequest 通知应用程序有个自动登录的帐号过程
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            请求登陆的webview
	 * @param realm
	 *            账户的域名，用来查找账户。
	 * @param account
	 *            一个可选的账户，如果是null 需要和本地的账户进行check， 如果是一个可用的账户，则提供登录。
	 * @param args
	 *            验证制定参数的登录用户
	 */
	@Override
	public void onReceivedLoginRequest(WebView view, String realm,
			String account, String args) {
		// TODO Auto-generated method stub
		super.onReceivedLoginRequest(view, realm, account, args);
		Log.i(TAG, "onReceivedLoginRequest");
 
	}
});</code></pre> 
<p>2.5 设置WebChromeClient，辅助WebVlew处理/avascrlpt的对话框，网站图标，网站tltle，加载进度等</p> 
<p>常规用法，加载页面缓冲进度</p> 
<pre><code class="language-java">webView.setWebChromeClient(new WebChromeClient() {
	@Override
	public void onProgressChanged(WebView view, int newProgress) {

		if (newProgress &gt;=80) {
			llView.setVisibility(View.GONE);
		} else {
			llView.setVisibility(View.VISIBLE);
		}
		super.onProgressChanged(view, newProgress);
	}
});</code></pre> 
<p>完整用法</p> 
<pre><code class="language-java">webView.setWebChromeClient(new WebChromeClient() {
	/**
	 * onProgressChanged 通知应用程序当前网页加载的进度。
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebChromeClient的的webview实例
	 * @param newProgress
	 *            webview接受的进度
	 */
	@Override
	public void onProgressChanged(WebView view, int newProgress) {
		// TODO Auto-generated method stub
		super.onProgressChanged(view, newProgress);
		if (newProgress &lt;= 100) {
			Log.i(TAG, newProgress + "===onProgressChanged===");
		}
	}
	
	/**
	 * 当document 的title变化时，会通知应用程序
	 * 
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的webview实例
	 * @param title
	 *            document新的title
	 */
	@Override
	public void onReceivedTitle(WebView view, String title) {
		// TODO Auto-generated method stub
		super.onReceivedTitle(view, title);
		Message message = new Message();
		message.what = 100;
		message.obj = title;
		handler.sendMessage(message);
 
	}
	
	/**
	 * 当前页面有个新的favicon时候，会回调这个函数。 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param icon
	 *            当前页面的favicon 注：很多时间不会跳转到此回调函数，因为很多网站设置了icon，没有设置favicon，
	 */
	@Override
	public void onReceivedIcon(WebView view, Bitmap icon) {
		// TODO Auto-generated method stub
		super.onReceivedIcon(view, icon);
		Message message = new Message();
		message.what = 200;
		message.obj = icon;
		handler.sendMessage(message);
	}
	
	/**
	 * 通知应用程序 apple-touch-icon的 url
	 * 
	 * 参数说明：
	 * 
	 * @param view
	 *            接收WebViewClient的那个实例，前面看到webView.setWebViewClient(new
	 *            MyAndroidWebViewClient())，即是这个webview。
	 * @param url
	 *            apple-touch-icon 的服务端地址
	 * @param precomposed
	 *            如果precomposed 是true 则touch-icon是预先创建的
	 * 
	 *            Tips
	 * 
	 *            如果应用程序需要这个icon的话， 可以通过这个url获取得到 icon。
	 */
	@Override
	public void onReceivedTouchIconUrl(WebView view, String url,
			boolean precomposed) {
		// TODO Auto-generated method stub
		super.onReceivedTouchIconUrl(view, url, precomposed);
		Log.i(TAG, "====onReceivedTouchIconUrl====");
	}
	
	 
	/**
	 * webview请求得到focus，发生这个主要是当前webview不是前台状态，是后台webview。
	 */
	@Override
	public void onRequestFocus(WebView view) {
		// TODO Auto-generated method stub
		super.onRequestFocus(view);
		Log.i(TAG, "====onRequestFocus====");
	}
	
	/**
	 * 覆盖默认的window.alert展示界面，
	 */
	@Override
	public boolean onJsAlert(final WebView view, String url, String message,
			JsResult result) {
		final AlertDialog.Builder builder = new AlertDialog.Builder(
				view.getContext());
 
		builder.setTitle("对话框").setMessage(message)
				.setPositiveButton("确定", null);
		builder.setOnKeyListener(new OnKeyListener() {
			public boolean onKey(DialogInterface dialog, int keyCode,
					KeyEvent event) {
				Log.v("onJsAlert", "keyCode==" + keyCode + "event=" + event);
				return true;
			}
		});
		// 禁止响应按back键的事件
		builder.setCancelable(false);
		AlertDialog dialog = builder.create();
		dialog.show();
		result.confirm();// 因为没有绑定事件，需要强行confirm,否则页面会变黑显示不了内容。
		return true;
		// return super.onJsAlert(view, url, message, result);
	}
	
	/**
	 * 覆盖默认的window.confirm展示界面，
	 */
	@Override
	public boolean onJsConfirm(final WebView view, String url, String message,
			final JsResult result) {
		final AlertDialog.Builder builder = new AlertDialog.Builder(
				view.getContext());
		builder.setTitle("对话框").setMessage(message)
				.setPositiveButton("确定", new OnClickListener() {
					public void onClick(DialogInterface dialog, int which) {
						result.confirm();
					}
				}).setNeutralButton("取消", new OnClickListener() {
					public void onClick(DialogInterface dialog, int which) {
						result.cancel();
					}
				});
		builder.setOnCancelListener(new OnCancelListener() {
			@Override
			public void onCancel(DialogInterface dialog) {
				result.cancel();
			}
		});
 
		// 屏蔽keycode等于84之类的按键，避免按键后导致对话框消息而页面无法再弹出对话框的问题
		builder.setOnKeyListener(new OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode,
					KeyEvent event) {
				Log.v("onJsConfirm", "keyCode==" + keyCode + "event=" + event);
				return true;
			}
		});
		// 禁止响应按back键的事件
		// builder.setCancelable(false);
		AlertDialog dialog = builder.create();
		dialog.show();
		return true;
	}
	
	/**
	 * 覆盖默认的window.prompt展示界面，
	 */
	@Override
	public boolean onJsPrompt(WebView view, String url, String message,
			String defaultValue, final JsPromptResult result) {
		final AlertDialog.Builder builder = new AlertDialog.Builder(
				view.getContext());
 
		builder.setTitle("对话框").setMessage(message);
 
		final EditText et = new EditText(view.getContext());
		et.setSingleLine();
		et.setText(defaultValue);
		builder.setView(et).setPositiveButton("确定", new OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				result.confirm(et.getText().toString());
			}
 
		}).setNeutralButton("取消", new OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				result.cancel();
			}
		});
 
		// 屏蔽keycode等于84之类的按键，避免按键后导致对话框消息而页面无法再弹出对话框的问题
		builder.setOnKeyListener(new OnKeyListener() {
			public boolean onKey(DialogInterface dialog, int keyCode,
					KeyEvent event) {
				Log.v("onJsPrompt", "keyCode==" + keyCode + "event=" + event);
				return true;
			}
		});
 
		// 禁止响应按back键的事件
		// builder.setCancelable(false);
		AlertDialog dialog = builder.create();
		dialog.show();
		return true;
		// return super.onJsPrompt(view, url, message, defaultValue,
		// result);
	}
});</code></pre> 
<p>2.6 Android调用JS</p> 
<p>添加网络权限</p> 
<pre><code class="language-XML">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</code></pre> 
<p>编写html文件，放到assets文件里面</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="utf-8"&gt;
	&lt;/head&gt;
	&lt;body&gt;
		 &lt;div&gt;
			 function say(value){&lt;/br&gt;
			 &amp;nbsp;&amp;nbsp;callJS(value);&lt;/br&gt;
			 }
		 &lt;/div&gt;
	&lt;/body&gt;
	
	&lt;script&gt;
		function callJS(value){
			alert(value);
			return value;
		}
	&lt;/script&gt;
&lt;/html&gt;
</code></pre> 
<p>java文件，android调用js</p> 
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    private WebView webview;
    private TextView tvAndroid;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        webview = (WebView) findViewById(R.id.webview);
        tvAndroid = (TextView) findViewById(R.id.tv_android);
        tvAndroid.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //Android调用js方法
                //Android 4.4以下使用loadUrl，Android 4.4以上evaluateJavascript
                if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR2) {
                    webview.loadUrl("javascript:callJS('aaa')");
                } else {
                    webview.evaluateJavascript("javascript:callJS('aaa')", new ValueCallback&lt;String&gt;() {
                        @Override
                        public void onReceiveValue(String value) {
                            //此处为 js 返回的结果
                            Toast.makeText(MainActivity.this,value,Toast.LENGTH_SHORT).show();
                        }
                    });
                }
            }
        });
        
        initWebView();
    }


    public void initWebView() {
        //启用JS脚本
        webview.getSettings().setJavaScriptEnabled(true);
        // 设置允许JS弹窗
        webview.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);

        //加载网页
        webview.loadUrl("file:///android_asset/index.html");

        // 由于设置了弹窗检验调用结果,所以需要支持js对话框
        // webview只是载体，内容的渲染需要使用webviewChromClient类去实现
        // 通过设置WebChromeClient对象处理JavaScript的对话框
        //设置响应js 的Alert()函数
        webview.setWebChromeClient(new WebChromeClient(){
            @Override
            public boolean onJsAlert(WebView view, String url, String message, JsResult jsResult) {
                new AlertDialog.Builder(view.getContext()).setMessage(message).setPositiveButton(android.R.string.ok, new AlertDialog.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        jsResult.confirm();
                    }
                }).setCancelable(false).create().show();
                return true;
            }
        });

        //覆盖WebView默认使用第三方或系统默认浏览器打开网页的行为，使网页用WebView打开
        webview.setWebViewClient(new WebViewClient() {
            //override
            public void onReceivedHttpAuthRequest(WebView view, HttpAuthHandler handler, String host, String realm) {
                handler.proceed("admin", "sunlight");
                int d = Log.d("MyWebViewClient", "onReceivedHttpAuthRequest");
            }
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String uri) {
                // TODO Auto-generated method stub
                //返回值是true的时候控制去WebView打开，为false调用系统浏览器或第三方浏览器
                view.loadUrl(uri);
                return true;
            }
        });
    }
}</code></pre> 
<p>效果</p> 
<p><img alt="" height="667" src="https://images2.imgbox.com/65/85/ytFMwzTs_o.jpg" width="300"></p> 
<p></p> 
<p>注意：</p> 
<blockquote> 
 <ul>
<li><span style="color:#494949">启用JS脚本 webview.getSettings().setJavaScriptEnabled(true);</span></li>
<li><span style="color:#494949">设置允许JS弹窗webview.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);</span></li>
<li><span style="color:#494949">4.4以下通过​​WebView​​​的​​loadUrl()​，4.4以上通过​​WebView​​​的​​evaluateJavascript（）​​</span></li>
<li><span style="color:#494949">JS代码调用一定要在 ​​onPageFinished()​​ 回调之后才能调用，否则不会调用 </span></li>
</ul> 
</blockquote> 
<p>2.7 js调用android方法 </p> 
<p><span style="color:#fe2c24">方法一：</span>通过​​WebView​​​的​​addJavascriptInterface()​​进行对象映射</p> 
<p>html文件</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="utf-8"&gt;
	&lt;/head&gt;
	&lt;body&gt;
	  &lt;button style="width:100%;height:50px; margin-top: 100px;" onclick="aa.showToast('哈哈哈')"&gt;js调用Android方法&lt;/button&gt;
	&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
<p>java文件</p> 
<pre><code class="language-java">package com.serial.jsweview;

import android.os.Build;
import android.os.Bundle;
import android.view.View;
import android.webkit.JavascriptInterface;
import android.webkit.ValueCallback;
import android.webkit.WebView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

public class MainActivity2 extends AppCompatActivity {
    private WebView webview;
    private TextView tvAndroid;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main2);
        
        webview = (WebView) findViewById(R.id.webview);
        tvAndroid = (TextView) findViewById(R.id.tv_android);
        tvAndroid.setText("//继承自Object类，别名是aa,即在html可以直接用aa.showToast("哈哈哈")来调用android方法n" +
                "public class MyObject extends Object {n" +
                "    @JavascriptInterfacen" +
                "    public void showToast(String name){n" +
                "         Toast.makeText(MainActivity2.this, "您好!"+name, Toast.LENGTH_SHORT).show();n" +
                "    }n" +
                "}");
        
        initWebView();
    }


    public void initWebView() {
        // 设置与Js交互的权限
        webview.getSettings().setJavaScriptEnabled(true);

        //将java对象暴露给JavaScript脚本
        //参数1：java对象，里面定义了java方法
        //参数2：Java对象在js里的对象名，可以看作第一个参数的别名，可以随便取，即在html可以直接用aa.showToast("哈哈哈")来调用android方法
        webview.addJavascriptInterface(new MyObject(), "aa");//AndroidtoJS类对象映射到js的test对象

        //加载网页
        webview.loadUrl("file:///android_asset/index2.html");
    }

    //继承自Object类，别名是aa,即在html可以直接用aa.showToast("哈哈哈")来调用android方法
    public class MyObject extends Object {
        // 定义JS需要调用的方法
        // 被JS调用的方法必须加入@JavascriptInterface注解
        @JavascriptInterface
        public void showToast(String name){
            Toast.makeText(MainActivity2.this, "您好!"+name, Toast.LENGTH_SHORT).show();
        }
    }
}</code></pre> 
<p> <img alt="" height="667" src="https://images2.imgbox.com/42/df/rwtLbuvO_o.jpg" width="300"></p> 
<p></p> 
<p><span style="color:#fe2c24"> 方法二：</span>通过 ​​WebViewClient​​​ 的​​shouldOverrideUrlLoading ()​​方法回调拦截 url</p> 
<p>原理：</p> 
<blockquote> 
 <ul>
<li><span style="color:#494949">Android通过 ​​WebViewClient​​​ 的回调方法​​shouldOverrideUrlLoading ()​​拦截 url</span></li>
<li><span style="color:#494949">解析该 url 的协议</span></li>
<li><span style="color:#494949">如果检测到是预先约定好的协议，就调用相应方法</span></li>
</ul> 
</blockquote> 
<p>html文件</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="utf-8"&gt;
		&lt;script&gt;
			 function callAndroid(){
				/*约定的url协议*/
				document.location = "js://webview?arg1=111&amp;arg2=222";
			 }
		  &lt;/script&gt;
	&lt;/head&gt;

	&lt;body&gt;
		&lt;button style="width:100%;height:50px; margin-top: 100px;" onclick="callAndroid()"&gt;点击调用Android代码&lt;/button&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p> java文件</p> 
<pre><code class="language-java">public class MainActivity3 extends AppCompatActivity {
    private WebView webview;
    private TextView tvAndroid;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main2);
        
        webview = (WebView) findViewById(R.id.webview);
        tvAndroid = (TextView) findViewById(R.id.tv_android);

        
        initWebView();
    }


    public void initWebView() {
        // 设置与Js交互的权限
        webview.getSettings().setJavaScriptEnabled(true);
        // 设置允许JS弹窗
        webview.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);

        //步骤1：加载网页
        webview.loadUrl("file:///android_asset/index3.html");

        // 复写WebViewClient类的shouldOverrideUrlLoading方法
        webview.setWebViewClient(new WebViewClient() {
			  @Override
			  public boolean shouldOverrideUrlLoading(WebView view, String url) {
				  // 步骤2：根据协议的参数，判断是否是所需要的url
				  // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）
				  //假定传入进来的 url = "js://webview?arg1=111&amp;arg2=222"（同时也是约定好的需要拦截的）

				  Uri uri = Uri.parse(url);
				  // 如果url的协议 = 预先约定的 js 协议
				  // 就解析往下解析参数
				  if ( uri.getScheme().equals("js")) {
					  // 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议
					  // 所以拦截url,下面JS开始调用Android需要的方法
					  if (uri.getAuthority().equals("webview")) {

						  // 步骤3：
						  // 执行JS所需要调用的逻辑
						  Toast.makeText(MainActivity3.this, "您好!js调用了Android的方法", Toast.LENGTH_SHORT).show();
						  // 可以在协议上带有参数并传递到Android上
						  HashMap&lt;String, String&gt; params = new HashMap&lt;&gt;();
						  Set&lt;String&gt; collection = uri.getQueryParameterNames();

					  }

					  return true;
				  }
				  return super.shouldOverrideUrlLoading(view, url);
			  }
		    }
        );
    }
}</code></pre> 
<p>效果</p> 
<p> <img alt="" height="667" src="https://images2.imgbox.com/6a/b6/hPMpN2Gk_o.jpg" width="300"></p> 
<p></p> 
<p><span style="color:#fe2c24">方法三：</span>通过 ​​WebChromeClient​​​ 的​​onJsAlert()​​​、​​onJsConfirm()​​​、​​onJsPrompt()​​​方法回调拦截JS对话框​​alert()​​​、​​confirm()​​​、​​prompt()消息</p> 
<p>原理：</p> 
<blockquote> 
 <ul>
<li><span style="color:#494949">Android通过 ​​WebChromeClient​​​ 的​​onJsAlert()​​​、​​onJsConfirm()​​​、​​onJsPrompt（）​​​方法回调分别拦截JS对话框，得到他们的消息内容，然后解析即可。比如拦截 JS的输入框prompt()​​方法</span></li>
<li><span style="color:#494949">因为只有​​prompt()​​可以返回任意类型的值，操作最全面方便、更加灵活；</span></li>
<li><span style="color:#494949">而alert()对话框没有返回值；confirm()对话框只能返回两种状态（确定 / 取消）两个值</span></li>
</ul> 
</blockquote> 
<p>html文件</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="utf-8"&gt;

		&lt;script&gt;
			function clickprompt(){
				var result=prompt("js://demo?arg1=111&amp;arg2=222");
				alert("demo " + result);
	        }
		  &lt;/script&gt;
	&lt;/head&gt;

	&lt;body&gt;
	&lt;button   style="width:100%;height:50px; margin-top: 100px;" onclick="clickprompt()"&gt;点击调用Android代码&lt;/button&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<blockquote> 
 <p>当使用​​mWebView.loadUrl("file:///android_asset/javascript.html")​​​加载了上述JS代码后，就会触发回调​​onJsPrompt（）​​，具体如下：</p> 
 <p>如果是拦截警告框，即​​alert()​​​，则触发回调​​onJsAlert();<br> 如果是拦截确认框，即​​confirm()，则触发回调​​onJsConfirm();</p> 
</blockquote> 
<p>java文件</p> 
<pre><code class="language-java">package com.serial.jsweview;

import android.net.Uri;
import android.os.Bundle;
import android.webkit.JsPromptResult;
import android.webkit.JsResult;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.TextView;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

import java.util.HashMap;
import java.util.Set;

public class MainActivity4 extends AppCompatActivity {
    private WebView webview;
    private TextView tvAndroid;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main4);

        webview = (WebView) findViewById(R.id.webview);
        tvAndroid = (TextView) findViewById(R.id.tv_android);


        initWebView();
    }


    public void initWebView() {
        // 设置与Js交互的权限
        webview.getSettings().setJavaScriptEnabled(true);
        // 设置允许JS弹窗
        webview.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);

        webview.loadUrl("file:///android_asset/index4.html");

        webview.setWebChromeClient(new WebChromeClient() {
                // 拦截输入框(原理同方式2)
                // 参数message:代表promt()的内容（不是url）
                // 参数result:代表输入框的返回值
                @Override
                public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {
                    // 根据协议的参数，判断是否是所需要的url(原理同方式2)
                    // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）
                    //假定传入进来的 url = "js://webview?arg1=111&amp;arg2=222"（同时也是约定好的需要拦截的）

                    Uri uri = Uri.parse(message);
                    // 如果url的协议 = 预先约定的 js 协议
                    // 就解析往下解析参数
                    if (uri.getScheme().equals("js")) {

                        // 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议
                        // 所以拦截url,下面JS开始调用Android需要的方法
                        if (uri.getAuthority().equals("webview")) {

                            //
                            // 执行JS所需要调用的逻辑
                            System.out.println("js调用了Android的方法");
                            // 可以在协议上带有参数并传递到Android上
                            HashMap&lt;String, String&gt; params = new HashMap&lt;&gt;();
                            Set&lt;String&gt; collection = uri.getQueryParameterNames();

                            //参数result:代表消息框的返回值(输入值)
                            result.confirm("js调用了Android的方法成功啦");
                        }
                        return true;
                    }
                    return super.onJsPrompt(view, url, message, defaultValue, result);
                }


                // 拦截JS的警告框
                @Override
                public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
                    return super.onJsAlert(view, url, message, result);
                }

                // 拦截JS的确认框
                @Override
                public boolean onJsConfirm(WebView view, String url, String message, JsResult result) {
                    return super.onJsConfirm(view, url, message, result);
                }
            }
        );
    }
}</code></pre> 
<p>效果</p> 
<p><img alt="" height="667" src="https://images2.imgbox.com/9f/ff/AzJmx7ml_o.jpg" width="300"></p> 
<p></p> 
<p>总结：</p> 
<blockquote> 
 <p>JS调用Android代码的方法有3种：</p> 
 <ol>
<li><span style="color:#494949">通过​​WebView​​​的​​addJavascriptInterface()​​进行对象映射，存在安全漏洞</span></li>
<li><span style="color:#494949">通过 ​​WebViewClient​​​ 的​​shouldOverrideUrlLoading ()​​方法回调拦截 url，不存在1的漏洞，但JS获取Android方法的返回值复杂</span></li>
<li><span style="color:#494949">通过 ​​WebChromeClient​​​ 的​​onJsAlert()​​​、​​onJsConfirm()​​​、​​onJsPrompt()​​​方法回调拦截JS对话框​​alert()​​​、​​confirm()​​​、​​prompt()​​ 消息。不存在漏洞，需要协议的约定</span></li>
</ol> 
</blockquote> 
<p>2.8  页面返回</p> 
<pre><code class="language-java">@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; myWebView.canGoBack()) {
        myWebView.goBack();
        return true;
    }
    return super.onKeyDown(keyCode, event);
}</code></pre> 
<p>2.9 缓存的配置</p> 
<pre><code class="language-java">WebSettings webSettings = mWebView.getSettings();
//优先使用缓存
webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); 
//只在缓存中读取
webSettings.setCacheMode(WebSettings.LOAD_CACHE_ONLY);
/不使用缓存
WwebSettings.setCacheMode(WebSettings.LOAD_NO_CACHE);</code></pre> 
<p>2.10 清除缓存</p> 
<pre><code class="language-java">//清除网页访问留下的缓存，由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.
webview.clearCache(true);
//清除当前webview访问的历史记录，只会webview访问历史记录里的所有记录除了当前访问记录.
webview.clearHistory (); 
//这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据。
webview.clearFormData ();</code></pre> 
<p>2.10 webview生命周期</p> 
<blockquote> 
 <p>onResume()<br> WebView为活跃状态时回调，可以正常执行网页的响应。</p> 
 <p></p> 
 <p>onPause()<br> WebView被切换到后台时回调, 页面被失去焦点, 变成不可见状态，onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。</p> 
 <p></p> 
 <p>pauseTimers()<br> 当应用程序被切换到后台时回调，该方法针对全应用程序的WebView，它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。</p> 
 <p></p> 
 <p>resumeTimers()<br> 恢复pauseTimers时的动作。</p> 
 <p></p> 
 <p>destroy()<br> 关闭了Activity时回调, WebView调用destory时, WebView仍绑定在Activity上.这是由于自定义WebView构建时传入了该Activity的context对象, 因此需要先从父<br> 容器中移除WebView, 然后再销毁webview。<br> mRootLayout.removeView(webView);  <br> mWebView.destroy();</p> 
</blockquote> 
<p>跟随Activity的生命周期</p> 
<pre><code class="language-java">@Override
protected void onResume() {
    super.onResume();
    //恢复webview的状态（不靠谱）
    webView.resumeTimers();
    //激活webView的状态，能正常加载网页
    webView.onResume();
}

@Override
protected void onPause() {
    super.onPause();
    //当页面被失去焦点被切换到后台不可见状态，需要执行onPause
    //通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。
    webView.onPause();

    //当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview
    //它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。（不靠谱）
    webView.pauseTimers();
}

@Override
protected void onDestroy() {
	super.onDestroy();
	//在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview
	//但是注意：webview调用destory时,webview仍绑定在Activity上
	//这是由于自定义webview构建时传入了该Activity的context对象
	//因此需要先从父容器中移除webview,然后再销毁webview:
	ViewGroup parent = findViewById(R.id.container);
	parent.removeView(webView);
	webView.destroy();
}
</code></pre> 
<p><span style="color:#0d0016"><strong>三 防止内存泄漏的注意点</strong></span></p> 
<p>3.1 在需要的时候在 Activity 中创建，并且使用 getApplicationgContext()，而不要在xml注册。</p> 
<pre><code class="language-java">//mWebView=new WebView(this);
mWebView=new WebView(getApplicationContext());
LinearLayout linearLayout  = findViewById(R.id.xxx);
linearLayout.addView(mWebView);</code></pre> 
<p>3.2 并且Activity退出的时候，需要手动释放webview内存</p> 
<pre><code class="language-java">@Override
protected void onDestroy() {
    if (mWebView != null) {
        mWebView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null);
        mWebView.clearHistory();

        ((ViewGroup) mWebView.getParent()).removeView(mWebView);
        mWebView.destroy();
        mWebView = null;
    }
    super.onDestroy();
}
</code></pre> 
<p>3.3 尽量不要在webview里面开启新进程 </p> 
<p>比如下面这种</p> 
<pre><code class="language-java">&lt;activity android:name=".WebviewActivity"
   android:process=":webview"/&gt;</code></pre> 
<p><strong><span style="color:#0d0016">四 其它web框架的选择</span></strong></p> 
<p>4.1 webview大部分场合是没问题的，但涉及到文件下载，文档浏览等只能自己写js交互，处理相对麻烦。所以也有其它web框架供我们选择</p> 
<p>4.2 第一个就是开头提过的腾讯webx5，相对来说比较强大，但可能个别手机会出现兼容问题</p> 
<p>官方网址：https://x5.tencent.com/tbs/</p> 
<p>4.3 还有github常用的webview库，内置文件的处理功能，和加载缓冲样式，也可以直接代替webview</p> 
<p>项目地址：<a href="https://github.com/Justson/AgentWeb" title="https://github.com/Justson/AgentWeb">https://github.com/Justson/AgentWeb</a></p> 
<p>4.4 还有专门处理JS交互的一个库DSBridge，分为webx5内核版本和webkit内核版本</p> 
<p>项目地址：<a href="https://github.com/wendux/DSBridge-Android" title="https://github.com/wendux/DSBridge-Android">https://github.com/wendux/DSBridge-Android</a></p> 
<p>使用中webx5内核版本由于规则定义不符合我们要求，而且不能改，就换用了webkit内核版本，目前没出现什么问题</p> 
<p><strong><span style="color:#0d0016">五  手机加载网页空白问题解决方案</span></strong></p> 
<p>5.1 网页加载空白原因有很多，遇到的可以尝试下面方案，第一个就是联网权限没配置，配置下权限</p> 
<pre><code class="language-XML">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</code></pre> 
<p>5.2 https的ssl证书问题</p> 
<pre><code class="language-java">WebView().setWebViewClient(new WebViewClient(){
	@Override
	public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
		handler.proceed();
	}
});</code></pre> 
<p>5.3  尝试加载DOM缓存</p> 
<pre><code class="language-java">webView.getSettings().setDomStorageEnabled(true);</code></pre> 
<p>5.4  Android5.0以上允许加载http和https混合的页面</p> 
<pre><code class="language-java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
  webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);
}
</code></pre> 
<p>5.5 如果上面尝试都不行，那就有可能不是Webview配置问题，可能是内核版本较低，对于高版本的Web或者JS语法不支持。</p> 
<p>如ES6经过尝试在Androd6.0系统上会空白，而且切换腾讯Webx5内核也不行。这时候只能让Web前端es6转为es5了</p> 
<p>即可以尝试h5做低版本适配，ES6转化为ES5的方案</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>