<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Data Structure, Algorithm,and Applications in C&#43;&#43; - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Data Structure, Algorithm,and Applications in C&#43;&#43;</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p></p> 
<p class="img-center"><img alt="" height="705" src="https://images2.imgbox.com/7b/62/piDDsiUJ_o.jpg" width="500"></p> 
<p>在学习这本书进阶内容之前，我们可以跟着它的第一章部分再巩固和复习。本书由Sartaj Sahni撰写，由王立柱和刘志红翻译。全书通俗易懂，内容丰富，是巩固C++内容的不二选择。希望本文对各位有所帮助。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%82%E6%95%B0-toc" style="margin-left:0px"><a href="#1.%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%82%E6%95%B0">1.函数与参数</a></p> 
<p id="1.1.%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0-toc" style="margin-left:40px"><a href="#1.1.%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0">1.1.传值参数</a></p> 
<p id="1.2.%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#1.2.%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0">1.2.模板函数</a></p> 
<p id="1.3.%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0-toc" style="margin-left:40px"><a href="#1.3.%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">1.3.引用参数</a></p> 
<p id="1.4.%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0-toc" style="margin-left:40px"><a href="#1.4.%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">1.4.常量引用参数</a></p> 
<p id="1.5.%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:40px"><a href="#1.5.%E8%BF%94%E5%9B%9E%E5%80%BC">1.5.返回值</a></p> 
<p id="1.6.%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#1.6.%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0">1.6.重载函数</a></p> 
<p id="1.7.%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px"><a href="#1.7.%E7%BB%83%E4%B9%A0">1.7.练习</a></p> 
<p id="2.%E5%BC%82%E5%B8%B8-toc" style="margin-left:0px"><a href="#2.%E5%BC%82%E5%B8%B8">2.异常</a></p> 
<p id="2.1.%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px"><a href="#2.1.%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8">2.1.抛出异常</a></p> 
<p id="2.2.%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px"><a href="#2.2.%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">2.2.处理异常</a></p> 
<p id="2.3.%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px"><a href="#2.3.%E7%BB%83%E4%B9%A0">2.3.练习</a></p> 
<p id="3.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D-toc" style="margin-left:0px"><a href="#3.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D">3.动态内存空间分配</a></p> 
<p id="3.1.%E6%93%8D%E4%BD%9C%E7%AC%A6new-toc" style="margin-left:40px"><a href="#3.1.%E6%93%8D%E4%BD%9C%E7%AC%A6new">3.1.操作符new</a></p> 
<p id="3.2.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#3.2.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">3.2.一维数组</a></p> 
<p id="3.3.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc" style="margin-left:40px"><a href="#3.3.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">3.3.异常处理</a></p> 
<p id="3.4.%E6%93%8D%E4%BD%9C%E7%AC%A6delete-toc" style="margin-left:40px"><a href="#3.4.%E6%93%8D%E4%BD%9C%E7%AC%A6delete">3.4.操作符delete</a></p> 
<p id="3.5.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#3.5.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">3.5.二维数组</a></p> 
<p id="4.%E8%87%AA%E6%9C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px"><a href="#4.%E8%87%AA%E6%9C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4.自有数据类型</a></p> 
<p id="4.1.%E7%B1%BB%20currency-toc" style="margin-left:40px"><a href="#4.1.%E7%B1%BB%20currency">4.1.类 currency</a></p> 
<p id="4.2.%E4%B8%80%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px"><a href="#4.2.%E4%B8%80%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95">4.2.一种不同的描述方法</a></p> 
<p id="4.3.%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px"><a href="#4.3.%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD">4.3.操作符重载</a></p> 
<p id="4.4.%E5%8F%8B%E5%85%83%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%80%A7%E7%B1%BB%E6%88%90%E5%91%98-toc" style="margin-left:40px"><a href="#4.4.%E5%8F%8B%E5%85%83%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%80%A7%E7%B1%BB%E6%88%90%E5%91%98">4.4.友元和保护性类成员</a></p> 
<p id="4.5.%E5%A2%9E%E5%8A%A0%23ifndef%E3%80%81%23define%E5%92%8C%23endif%E8%AF%AD%E5%8F%A5-toc" style="margin-left:40px"><a href="#4.5.%E5%A2%9E%E5%8A%A0%23ifndef%E3%80%81%23define%E5%92%8C%23endif%E8%AF%AD%E5%8F%A5">4.5.增加#ifndef、#define和#endif语句</a></p> 
<p id="5.%E5%BC%82%E5%B8%B8%E7%B1%BBillegalParameterValue-toc" style="margin-left:0px"><a href="#5.%E5%BC%82%E5%B8%B8%E7%B1%BBillegalParameterValue">5.异常类illegalParameterValue</a></p> 
<p id="6.%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0-toc" style="margin-left:0px"><a href="#6.%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">6.递归函数</a></p> 
<p id="6.1.%E9%80%92%E5%BD%92%E7%9A%84%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#6.1.%E9%80%92%E5%BD%92%E7%9A%84%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0">6.1.递归的数学函数</a></p> 
<p id="6.2.%E5%BD%92%E7%BA%B3-toc" style="margin-left:40px"><a href="#6.2.%E5%BD%92%E7%BA%B3">6.2.归纳</a></p> 
<p id="6.3.C%2B%2B%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0-toc" style="margin-left:40px"><a href="#6.3.C%2B%2B%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">6.3.C++递归函数</a></p> 
<p id="7.%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93-toc" style="margin-left:0px"><a href="#7.%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93">7.标准模板库</a></p> 
<p id="7.1.accumulate-toc" style="margin-left:40px"><a href="#7.1.accumulate">7.1.accumulate</a></p> 
<p id="7.2.copy%E5%92%8Cnext_permutation-toc" style="margin-left:40px"><a href="#7.2.copy%E5%92%8Cnext_permutation">7.2.copy和next_permutation</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h1 id="1.%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%82%E6%95%B0">1.函数与参数</h1> 
<h2 id="1.1.%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0">1.1.传值参数</h2> 
<p>对于普通的传值参数，我们已经司空见惯了我们一般只要对相应的函数体传入形参，在执行的main函数主体中传入实参就可以调用相应的内容。在运行时，函数体在执行前，把实参复制给形参，复制的过程是由形参类型的复制<strong>构造函数</strong>来完成的。如果实参和形参的类型不一致，那么就必须进行类型转换，把实参转化为形参的类型，前提也很明确，那就是该类型转换是允许的。在函数结束，系统会调用形参类型的<strong>析构函数</strong>来释放形式参数。当函数运行结束以后，那么形参的只就不会复制到实参当中去。因此，也就是我们所说的单向值传递。当然，在我们所学习的类与对象板块中，我们也知道了类内的方法就很类似于我们的函数，而且我们还能自己进行编写构造函数和析构函数。</p> 
<h2 id="1.2.%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0">1.2.模板函数</h2> 
<blockquote> 
 <pre>float abc(float a, float b, float c)
{
    return a + b * c;
}</pre> 
</blockquote> 
<p>这种形式过于拘泥，被数据类型限制了，所以我们可以使用模板，对相应的形参进行替换，当我们调用同一个方法的时候，我们就无须再多虑它的数据类型了。</p> 
<blockquote> 
 <pre>template&lt;class T&gt;
T abc(T a, T b, T c)
{
    return a + b * c;
}</pre> 
</blockquote> 
<h2 id="1.3.%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">1.3.引用参数</h2> 
<p>在使用上面的模板函数时，会增加不少时间开销，这实际上就是因为要重新开辟空间复制形参的原因。而且传入的数据越多，它的负担也就越大，也就导致了相应的时间、空间双重损失。这时候，我们就要是使用引用来减少这种时间和空间上的损失。</p> 
<blockquote> 
 <pre>template&lt;class T&gt;
T abc(T&amp; a, T&amp; b, T&amp; c)
{
    return a + b * c;
}</pre> 
</blockquote> 
<p>引用的好处就是将原来的形参复制形式转变为了实参直接调用，当然这个函数返回时，也就不会调用析构函数。</p> 
<h2 id="1.4.%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">1.4.常量引用参数</h2> 
<p>C++还提供另外一种参数传递模式——<strong>常量引用</strong>。这种模式指明的引用参数不能被函数修改。这个名字实际上就已经暗示了这一点了，之前我们遇到的常变量、常量指针，都是使用了const，是相应的数值转变为一个不可更改的左值。</p> 
<blockquote> 
 <pre>template&lt;class T&gt;
T abc(const T&amp; a, const T&amp; b, const T&amp; c)
{
    return a + b * c;
}</pre> 
</blockquote> 
<p>用关键字const来指明函数不可修改的引用参数，在软件工程上具有重要的意义。函数头会告诉用户该函数是不能修改实参的。</p> 
<p>改成更通用的版本就是：</p> 
<blockquote> 
 <pre>template&lt;class Ta, class Tb, class Tc&gt;
T abc(const Ta&amp; a, const Tb&amp; b, const Tc&amp; c)
{
    return a + b * c;
}</pre> 
</blockquote> 
<h2 id="1.5.%E8%BF%94%E5%9B%9E%E5%80%BC">1.5.返回值</h2> 
<p>一个函数可以返回一个值、一个引用或者一个常量引用。在这种情况下，返回的值会被复制到调用环境中去，也就是我们获得了我们调用函数之后想要得到的那个结果。</p> 
<h2 id="1.6.%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0">1.6.重载函数</h2> 
<p>一个函数的<strong>签名</strong>是由这个函数的形参类型以及形参个数所确定的。C++可以定义两个或多个同名函数，但是两个同名函数不能有相同的签名。定义多个同名函数的机制，就是我们所说的函数重载。</p> 
<blockquote> 
 <pre>int abc(int a, int b, int c)
{
    return a + b * c;
}
​
float abc(float a, float b, float c)
{
    return a + b * c;
}
​
int abc(int a, int b)
{
    return a + b;
}</pre> 
</blockquote> 
<h2 id="1.7.%E7%BB%83%E4%B9%A0">1.7.练习</h2> 
<p><strong>练习1</strong>：交换函数为什么失败，这是因为这是单向值传递，形参复制了实参，但是无法对实参进行修改，函数运行结束，该形参也被回收了。</p> 
<p><strong>练习2</strong>：编写一个模板函数count，返回值是数组a[0:n-1]中value出现的次数。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#define N 20
template&lt;class Ta, class Tb, class Tc&gt;
    
int count(Ta&amp; arr, Tb&amp; n, Tc&amp; value)
{
    int count = 0;
    for(int i = 0;i &lt; n; i++)
    {
        if(arr[i] == value)
        {
            count++;
        }
    }
    return count;
}
​
void menu()
{
    cout &lt;&lt; "使用int 类型————1" &lt;&lt; endl;
    cout &lt;&lt; "使用char类型————2" &lt;&lt; endl;
}
​
int main()
{
    int n, arr[N];
    char arr1[N];
    cout &lt;&lt; "输入个数为：";
    cin &gt;&gt; n;
    int value;
    char value1;
    int number;
    menu();
    cout &lt;&lt; "输入类型：";
    while(1)
    {
        int val;
        cin &gt;&gt; val;
        if(val == 1)
        {
            for(int i = 0;i &lt; n; i++)
            {
                cin &gt;&gt; arr[i];
            }
            cout &lt;&lt; "要查询的值：";
            cin &gt;&gt; value;
            number = count(arr, n, value);
            break;
        }
        else if(val == 2)
        {
            for(int i = 0;i &lt; n; i++)
            {
                cin &gt;&gt; arr1[i];
            }
            cout &lt;&lt; "要查询的值：";
            cin &gt;&gt; value1;
            number = count(arr1, n, value1);
            break;
        }
        else 
        {
            cout &lt;&lt; "输入错误，请重新输入：";
        }
    }
    cout &lt;&lt; "该值个数为：" &lt;&lt; number &lt;&lt; endl;
    return 0;
}</code></pre> 
<p><strong>练习3</strong>：编写一个模板函数fill，给数组a[start:end-1]赋值value</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#define N 20
template &lt;class Ta, class Tb, class Tc&gt;
void fill(Ta&amp; arr, Tb&amp; start, Tb&amp; n, Tc&amp; value)
{
    for(int i = start;i &lt; n; i++)
    {
        arr[i] = value;
    }
}
​
int main()
{
    int arr[N];
    int n;
    cout &lt;&lt; "输入个数：";
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n; i++)
    {
        arr[i] = i;
    }
    int start;
    while(1)
    {
        cout &lt;&lt; "输入起始位置：";
        cin &gt;&gt; start;
        if(start &gt;= 0 &amp;&amp; start &lt; n)
        {
            break;
        }
    }
    int value;
    cout &lt;&lt; "复制的内容为：";
    cin &gt;&gt; value;
    fill(arr, start, n, value);
    cout &lt;&lt; "复制后的代码：" &lt;&lt; endl;
    for(int i = 0;i &lt; n; i++)
    {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    return 0;
}</code></pre> 
<p>此处可以将主函数中的int arr[N]改为char arr[N]之类的类型从而实现类型的差异，或者说也可以像上面的那道题一样准备多个选项进行实现内容。</p> 
<p><strong>练习4</strong>：编写一个模板函数inner_product，返回值是a[i]*b[i]的总和。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#define N 20
​
template &lt;class T&gt;
T inner_product(T&amp; a, T&amp; b)
{
    return a * b;
}
​
void test()
{
    int a[N],b[N];
    int n;
    int Count = 0;
    cout &lt;&lt; "请输入数据个数：";
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n; i++)
    {
        cout &lt;&lt; "输入a数组的值：";
        cin &gt;&gt; a[i];
    }
    for(int i = 0;i &lt; n; i++)
    {
        cout &lt;&lt; "输入b数组的值：";
        cin &gt;&gt; b[i];
    }
    
    for(int i = 0;i &lt; n; i++)
    {
        Count += inner_product(a[i], b[i]); 
    }
    
    cout &lt;&lt; "Sum的数据：" &lt;&lt; Count &lt;&lt; endl;
}
​
int main()
{
    test();
    return 0;
}</code></pre> 
<p><strong>练习5</strong>：编写一个模板函数iota，使a[i]=value+i，0≤i＜n。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#define N 20
​
template&lt;class Ta, class Tb&gt;
Ta iota(Ta&amp; i, Tb&amp; value)
{
    return i + value;
}
​
void test()
{
    int a[N];
    int n, value;
    cout &lt;&lt; "请输入个数：";
    cin &gt;&gt; n;
    cout &lt;&lt; "请输入value值：";
    cin &gt;&gt; value;
    for(int i = 0;i &lt; n; i++)
    {
        a[i] = iota(i, value);
    }
    
    for(int i = 0;i &lt; n; i++)
    {
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}
​
int main()
{
    test();
    return 0;
}</code></pre> 
<p><strong>练习6</strong>：编写一个模板函数is_sorted，当且仅当a[0:n-1]有序时，返回值是true。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#define N 20
​
template&lt;class Ta, class Tb&gt;
bool is_sorted(Ta&amp; a, Tb&amp; n)
{
    for(int i = 1;i &lt; n; i++)
    {
        if(a[i] &lt; a[i-1])
            return false;
    }
    return true;
}
​
void test()
{
    int a[N];
    int n;
    cout &lt;&lt; "输入个数：";
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n; i++)
    {
        cout &lt;&lt; "输入数据：";
        cin &gt;&gt; a[i];
    }
    bool j = is_sorted(a, n);
    if(j == true) cout &lt;&lt; "从小到大升序排列" &lt;&lt; endl;
    else cout &lt;&lt; "非升序排列" &lt;&lt; endl;
}
​
int main()
{
    test();
    return 0;
}</code></pre> 
<p><strong>练习7</strong>：编写一个模板函数mismatch，返回值是使不等式a[i]不等于b[i]成立的最小的索引i，i在0到n之间。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#define N 20
template&lt;class Ta, class Tb&gt;
​
int mismatch(Ta&amp; a, Ta&amp; b, Tb&amp; n)
{
    for(int i = 0;i &lt; n; i++)
    {
        if(a[i] != b[i])
            return i;
    }
    return -1;
}
​
int main()
{
    int a[N], b[N];
    int n;
    cout &lt;&lt; "输入个数：";
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n; i++)
    {
        cout &lt;&lt; "输入a数组：";
        cin &gt;&gt; a[i];
    }
    for(int i = 0;i &lt; n; i++)
    {
        cout &lt;&lt; "输入b数组：";
        cin &gt;&gt; b[i];
    }
    int num = mismatch(a, b, n);
    if(num == -1) cout &lt;&lt; "ab数组完全相等" &lt;&lt; endl;
    else cout &lt;&lt; "第一个不相同的下标是：" &lt;&lt; num &lt;&lt; endl;
    return 0;
}</code></pre> 
<h1 id="2.%E5%BC%82%E5%B8%B8">2.异常</h1> 
<h2 id="2.1.%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8">2.1.抛出异常</h2> 
<p>异常是表示程序出现错误的信息。比如说b/c，当c=0时，这就是一个错误。对于这个错误，C++检查不出来，但是硬件会检查出来，并抛出一个异常。同样的，当我们学习Python的时候已经接触过它的异常，并做了一些预防措施和代码。</p> 
<p>我们可以编写这样的C++程序，它可以对一些异常的情况进行检查，而且当查出一个异常的时候，就抛出这个异常。就如下面的代码一样，程序函数abc可以定义，仅当三个参数都大于0时才进行，只要有一个或多个为0的值，就可以抛出异常，而这个程序抛出的异常类型是char*。</p> 
<blockquote> 
 <pre>int abc(int a, int b, int c)
{
    if(a &lt;= 0 || b &lt;= 0 || c &lt;= 0)
    {
        throw "All parameters should be &gt; 0";
    }
    return a + b * c;
}</pre> 
</blockquote> 
<p>程序可能抛出的异常有很多，比如0除数、非法参数值、非法输入值、数组下标越界等。如果对每一种类型异常都定义一个异常类，那么异常的处理就有很大灵活性。</p> 
<h2 id="2.2.%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">2.2.处理异常</h2> 
<p>一段代码抛出的异常由包含这段代码的try块来处理。紧跟在try之后的是catch块。每一个catch块都有一个参数，参数的类型决定了这个catch块要捕捉的异常类型。</p> 
<blockquote> 
 <pre>//块
catch(char * e){}
//捕捉的异常类型是char*，而块
catch(bad_alloc e){}
//捕捉的异常类型是bad_alloc
catch(exception &amp; e){}
//捕捉的异常类型是基类型exception以及所有从exception派生的类型（例如bad_alloc和bad_typeid）
catch(...){}</pre> 
</blockquote> 
<p>catch块一般包含异常改正之后所恢复的代码。如果不能恢复，那么catch块的代码输出错误的信息。</p> 
<blockquote> 
 <pre>int main()
{
    try {cout &lt;&lt; abc(2,0,5) &lt;&lt; endl};
    catch(char* e)
    {
        cout &lt;&lt; "The parameters to abc were 2, 0, and 5" &lt;&lt; endl;
        cout &lt;&lt; "An exception has been throw" &lt;&lt; endl;
        cout &lt;&lt; e &lt;&lt; endl;
        return 1;
    }
    return 0;
}
​
//输出结果：
The parameters to abc were 2, 0, and 5
An exception has been throw
All parameters should be &gt; 0</pre> 
</blockquote> 
<p>abc函数抛出一个类型为char*的异常。这个异常使函数abc还没有计算表达式的值就停止了。块try也立即停止了，其中的cout语句没有执行完。因为抛出的异常与catch块的参数e是同一种类型，所以异常被这个catch块捕捉，e的赋值是抛出的异常，然后进入catch块。</p> 
<h2 id="2.3.%E7%BB%83%E4%B9%A0">2.3.练习</h2> 
<p><strong>练习1</strong>：修改上面的程序，使抛出的异常类型是整型。如果a、b、c都小于0，那么抛出的异常值是1；如果a、b、c都等于0，那么抛出的异常值为2；否则没有异常。编写一个主函数，应用修改后的代码；若有异常抛出，则捕捉异常，根据异常值输出信息。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
​
int panduan(int a, int b, int c)
{
    if(a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0)
        return 2;
    else if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; c &lt; 0)
        return 1;
    else return 0;
}
​
int main()
{
    int a, b, c;
    cout &lt;&lt; "依次输入a、b、c：";
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    int flag = panduan(a, b, c);
    catch(flag)
    return 0;
}</code></pre> 
<p></p> 
<h1 id="3.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D">3.动态内存空间分配</h1> 
<h2 id="3.1.%E6%93%8D%E4%BD%9C%E7%AC%A6new">3.1.操作符new</h2> 
<p>C++操作符new用来进行动态存储分配或者运行时存储分配，它的值是一个指针，指向所分配的空间.</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    int * y = new int;
    *y = 10;
    
    //或者可以用如下方式直接进行操作
    int * x = new int(10);
    
    //或者第三种方式
    int * z;
    z = new int
    return 0;
}</code></pre> 
<h2 id="3.2.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">3.2.一维数组</h2> 
<p>许多函数中都要用到一维和二维数组，这些数组的大小在编译的时侯可能还是未知的，它们随着函数的调用的变化而变化，因此对这些数组只能进行动态存储分配。</p> 
<p>为了在运行时创建一个一维浮点数组，必须把x声明为一个浮点型指针，然后为数组分配充足的空间</p> 
<blockquote> 
 <pre>#include&lt;iostream&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    float * x = new float[n];
    return 0;
}</pre> 
</blockquote> 
<p>使用操作符new为n个浮点数分配了存储空间，并返回第一个浮点数空间的指针。对每个数组的元素的访问都可以使用x[0]，x[1]，x[2]，......，x[n-1]的形式。</p> 
<h2 id="3.3.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">3.3.异常处理</h2> 
<blockquote> 
 <pre>#include&lt;iostream&gt;
using namespace std;
int main()
{
    float * x;
    try{x = new float [n]};
    catch(bad_alloc e)
    {
        cerr &lt;&lt; "Out of Memory" &lt;&lt; endl;
        exit(1);
    }
    return 0;
}</pre> 
</blockquote> 
<p>如果计算机没有充足空间对float数组进行分配时，就会捕捉到异常，主动弹出异常问题，抛出一个bad_alloc的异常，并终止程序利用<code>try-catch</code>结构进行相应的操作</p> 
<h2 id="3.4.%E6%93%8D%E4%BD%9C%E7%AC%A6delete">3.4.操作符delete</h2> 
<p>动态内存的存储空间不再需要时相应的需要进行空间释放，释放的空间可以重新用来动态分配，C++操作符delete用来释放操作符new所分配的空间。</p> 
<blockquote> 
 <pre>#include&lt;iostream&gt;
using namespace std;
int main()
{
    int * x = new int(10);
    
    delete x;
    return 0;
}</pre> 
</blockquote> 
<h2 id="3.5.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">3.5.二维数组</h2> 
<p>虽然C++采用多种机制来说明二维数组，但这些机制大多数要求在编译阶段就知道而二维数组的大小。具体来说，使用这些机制很难编写出相应的函数，它的形参是一个第二维大小未知的二维数组。这是因为当形参是二维数组时，必须指定第二维的大小。例如，<code>a[][10]</code>是一个合法的定义，但是<code>a[][]</code>不合法。</p> 
<p>而克服这一问题的最佳方法就是采用动态内存分配的形式。</p> 
<blockquote> 
 <pre>#include&lt;iostream&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    char(*c)[5];
    try{c = new char[n][5];}
    catch(bad_alloc)
    {
        cerr &lt;&lt; "Out of Memory" &lt;&lt; endl;
        exxit(1);
    }
    return 0;
}</pre> 
</blockquote> 
<p>在运行时，行数n要么是用户自行输入的，要么就是通过计算确定的，如果数组1的列数在编译阶段是未知的话，那么就不能只调用一次new就能创建二维数组（即使数组的行数是已知的）。要构建这样的二维数组，可以把它看做是由若干行所构成的结构，每一行都是一个能用new来创建的一维数组。指向每一行的指针保存在另外一个一位数组之中。</p> 
<p>一个3*4的数组：</p> 
<p></p> 
<p>x[0]、x[1]、x[2]分别指向第0行、第1行、第2行的首元素，如归x是一个字符数组，那么x[0:2]是指向字符的指针，而x本身就是一个指向指针的指针，x的声明语法：<code>char **x;</code></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
template &lt;class T&gt;
bool makeArray(T ** &amp;x, int numberOfRows, int numberOfColumns)
{
    //创建一个二维数组
    try{
        //创建行指针
        x = new T * [numberOfRows];
        //为每一行分配空间
        for(int i = 0;i &lt; numberOfRows; i++)
        {
            x[i] = new int [numberOfColumns];
        }
        return true;
    }
    catch (bad_alloc) {return false};
}
​
​
int main()
{
    int numberOfRows, numberOfColumns;
    cout &lt;&lt; "输入行：";
    cin &gt;&gt; numberOfRows;
    cout &lt;&lt; "输入列：";
    cin &gt;&gt; numberOfColumns;
    char ** x;
    makeArray(x, numberOfRows, numberOfColumns);
    
    //释放空间
    void deleteArray()
    return 0;
}</code></pre> 
<p>创建一个类型为T的二维数组。这个数组的行数是<code>numberOfRows</code>，列数是<code>numberOfColumns</code>。程序首先为指针x[0]，......，<code>x[numberOfRows-1]</code>申请空间，然后为数组的每一行申请空间。在程序中操作符new被调用了<code>numberOfRows+1</code>次。如果new的某一次调用发生了异常，程序控制将转移到<code>catch</code>块，并返回<code>false</code>。而每一次<code>new</code>的调用都没有任何问题的话，那么数组就创建成功。函数返回<code>true</code>。对于创建的数组x，每个元素都可以使用标准的下标法<code>x[i][j]</code>来引用。<code>0≤i＜numberOfRows, 0≤j＜numberOfColumns</code>。</p> 
<p>我们分两步来释放这个二维数组空间首先释放放在for循环中为每一行所分配的空间，然后释放为行指针所分配的空间。x被指为NULL，防止用户继续访问已经释放的空间。</p> 
<blockquote> 
 <pre>template &lt;class T&gt;
void deleteArray(T ** &amp;x, int numberOfRows)
{
    //删除二维数组x
    for(int i = 0;i &lt; numberOfRows; i++)
    {
        delete [] x[i];
    }
    
    delete [] x;
    x = NULL;
}</pre> 
</blockquote> 
<h1 id="4.%E8%87%AA%E6%9C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4.自有数据类型</h1> 
<h2 id="4.1.%E7%B1%BB%20currency">4.1.类 currency</h2> 
<p>C++语言支持诸如int、float、和char这样的数据类型。而书本上的许多应用的数据类型是C++不支持的，需要自己定义。定义自有数据类型最灵活的方式就是使用C++的类（class）结构。</p> 
<p>假设你想处理货币类型currency的对象（也称实例），这种对象有三个成员：符号+-、美元和美分。对于这些对象我们想要执行的操作如下：</p> 
<ol>
<li> <p>给成员赋值</p> </li>
<li> <p>确定成员值（即符号、美元数和美分数）</p> </li>
<li> <p>两个对象相加</p> </li>
<li> <p>增加成员值</p> </li>
<li> <p>输出</p> </li>
</ol> 
<p><strong>currency类声明</strong>：</p> 
<blockquote> 
 <pre>class currency
{
public:
    //构造函数
    currency(signType theSign = plus,
            unsigned long theDollar = 0,
            unsigned int theCents = 0);
    //析构函数
    ~currency(){};
    void setValue(signType, unsigned long, unsigned int);
    void setValue(double);
    signType getSign() const {return sign;}
    unsigned long getDollars() const {return dollars;}
    unsigned int getCents() const {return cents;}
    currency add(const currency&amp;) const;
    currency&amp; increment(const currency&amp;);
    void output() const;
private:
    signType sign;//符号
    unsigned long dollars;//美元
    unsigned int cents;//美分
};</pre> 
</blockquote> 
<p>类的成员声明有两个部分：公有（public）和私有（private），其实还有一个保护（protect）。公有部分所声明的是用来操作类对象（或实例）的成员函数（又称方法）。对类的用户是可见的，是用户与类对象进行交互的唯一手段。私有部分所声明的是用户不可见的数据成员（如简单变量、数组及其他可赋值的结构）和成员函数。通过公有和私有以及保护部分，我们可以让用户只看到他们所看到的部分，同时把其余的部分隐藏起来，这部分通常是与实现细节有关内容。</p> 
<p>尽管C++语法可以在公有部分声明数据成员，但是优秀的软件设计者不会这样做。</p> 
<p>上面代码中，公有部分的第一个成员函数与类名相同，这种名称与类名相同的成员函数称为<strong>构造函数</strong>（construction）。构造函数指明了创建一个类对象的方法，而且没有返回值。~加上类名的这种成员函数被称为<strong>析构函数</strong>（destructor），每当一个类对象超出作用域的时候，析构函数就会自动调用来删除这个对象。</p> 
<p>在创建一个class类对象，如果没有构造函数，系统会自动调用空的构造函数，同理，如果没有析构函数，那么也会自动调用回收的系统析构函数。</p> 
<p>创建currency类对象的方式有如下两种：</p> 
<blockquote> 
 <pre>currency f, g(plus, 3, 45), h(minus, 10);
currency *m = new currency(plus, 8, 12);</pre> 
</blockquote> 
<p>调用成员函数的方式有：</p> 
<blockquote> 
 <pre>g.setValue(minus, 33, 0);
h.setValue(20.52);</pre> 
</blockquote> 
<p>其中的g和h是currency的类对象，也是函数的赋值对象。而所定义的类对象的关键字const是指这些函数值不会改变调用对象的值。我们把这种成员函数叫做<strong>常量函数</strong>（constant function）。</p> 
<p>当然这里<strong>复制构造函数</strong>（copy constructor）没有在代码中实现。C++将使用缺省复制构造函数，仅仅复制数据成员。对于这个currency类而言，缺省复制构造函数已经足够了，但是对于很大一部分类，我们最好还是在堆上空间进行开辟空间，也就是自己去定义一个复制构造函数来进行复制数据，缺省复制构造函数已经无法满足程序需要了。</p> 
<p><strong>currency的构造函数</strong>：</p> 
<blockquote> 
 <pre>currency::currency(signType theSign, unsigned long theDollars, unsigned int theCents)
{
    //创建一个currency类对象
    setValue(theSign, theDollars, theCents);
}</pre> 
</blockquote> 
<p>成员函数如果不在类声明体内部实现，而在外部实现，就必须要使用作用域说明符（scope resolution operator）<code>::</code>以指明该函数是currency类的成员函数。因此<code>currency::currency</code>表示currency类的构造函数，而<code>currency::output</code>这表示currency类的output成员函数。</p> 
<p><strong>给私有数据成员赋值</strong>：</p> 
<blockquote> 
 <pre>void currency::setValue(signType theSign, unsigned long theDollars, unsigned int theCents)
{
    //给调用对象的数据成员赋值
    if(theCent &gt; 99)
        throw illegalParameterValue("Cents should be &lt; 100");
    
    sign = theSign;
    dollars = theDollars;
    cents = theCents;
}
​
void currency::setValue(double theAmount)
{
    //给调用对象的数据成员赋值
    if(theAmount &lt; 0)
    {
        sign = minus;
        theAmount = -theAmount;
    }
    else sign = plus;
    dollars = (unsigned long) theAmount;//提取整数
    cents = (unsigned int) ((theAmount + 0.001 - dollars) * 100);//提取两位小数
}</pre> 
</blockquote> 
<p>这是两个成员函数setValue的代码。第一个成员函数验证参数值的合法性，只有当参数合法了，才能拿来给调用函数的私有数据成员赋值。如果参数不合法，就抛出一个类型为illeaglParametervalue的异常。第二个函数参数不验证参数值的合法性，仅用小数点后面头两位数字。</p> 
<p>但是我们知道，用计算机来表示一些小数是不够精确的，比如说，5.29用计算机表示是5.2899，那么加上0.001，在通过强制转换，把它转换为整型，那么再通过*100的操作就可以拿到相应的数据啦。</p> 
<p><strong>把两个currency对象的值相加</strong>：</p> 
<blockquote> 
 <pre>currency currency::add(const currency&amp; x) const
{
    //把x和*this相加
    long a1, a2, a3;
    currency result;
    //把调用对象转化为符号整数
    a1 = dollars * 100 + cents;
    if(sign == minus) a1 = -a1;
    
    //把x转化为符号整数
    a2 = x.dollars * 100 + x.cents;
    if(x.sign == minus) a2 = -a2;
    
    a3 = a1 + a2;
    
    //转换为currency对象的表达式
    if(a3 &lt; 0)
    {
        result.sign = minus;
        a3 = -a3;
    }
    else result.sign = plus;
    result.dollars = a3 / 100;
    result.cents = a3 - result.dollars * 100;
    
    return result;
}</pre> 
</blockquote> 
<p>上述程序是方法add的代码，它首先把要相加的两个对象转化为整数，如$2.32转换为232。引用调用对象的数据成员与引用对象x的数据成员在语法上是有区别的。x.dollars指的是x的数据成员，而前面没有对象名称的dollars指的是调用对象的数据成员。当方法add终止时，局部变量a1、a2、a3和ans被析构函数删除，它们的空间也均被释放。</p> 
<p><strong>函数increment和output</strong>：</p> 
<blockquote> 
 <pre>currency&amp; currency::increment(const currency&amp; x)
{
    //增加x
    *this = add(x);
    return *this;
}
​
void currency::output() const
{
    //输出调用对象的值
    if(sign == minus) cout &lt;&lt; '-';
    cout &lt;&lt; '$' &lt;&lt; dollars &lt;&lt; '.';
    if(cents &lt; 10) cout &lt;&lt; '0';
    cout &lt;&lt; cents;
}</pre> 
</blockquote> 
<p>在C++中，保留关键字this指向调用对象，*this就是调用对象。以调用语句g.increment(h)为例，方法increment第一行语句调用公有函数add，它把x（即h）与调用对象g相加，然后把相加的结果作为返回值，赋值给 *this，而 *this就是g。我们使用了返回引用，这样就省略返回值的复制过程。</p> 
<p>类currency的数据成员已经设为私有（private），类的用户不能直接访问这些成员。因此，用户通过下列的语句可以直接改变私有数据成员的值：</p> 
<blockquote> 
 <pre>h.cents = 20;
h.dollars = 100;
h.sign = plus;</pre> 
</blockquote> 
<p>如果数据成员在处理之前是有效的，而且经过成员函数处理之后仍然是有效的，那么我们就能保证它们在经过用户程序处理之后依然是有效的，因为用户程序是通过成员函数来处理数据成员的。构造函数和成员函数setValue的代码在使用数据之前都要验证它的有效性。而其余的函数特性是：如果数据在处理之前有效，那么在处理之后仍然是有效的。</p> 
<p><strong>类currency的应用</strong>：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include"currency.h"
using namespace std;
​
int main()
{
    currency g, h(plus, 3, 50), i, j;
    
    //使用两种形式的setValue来赋值
    g.setValue(minus, 2, 25);
    i.setValue(-6.45);
    
    //调用成员函数add和output
    j = h.add(g);
    h.output();
    cout &lt;&lt; " + ";
    g.output();
    cout &lt;&lt; " = ";
    j.output();
    cout &lt;&lt; endl;
    
    //连续调用两次成员函数add
    j = i.add(g).add(h);//省略了输出语句
    
    //测试异常
    cout &lt;&lt; "Attempting to initalize with cents = 152" &lt;&lt; endl;
    try{
        i.setValue(plus, 3, 152);
    }
    catch(illegalParameterValue e)
    {
        cout &lt;&lt; "Caught thrown exception" &lt;&lt; endl;
        e.outputMessage();
    }
    return 0;
}</code></pre> 
<p>这段代码假定类声明和类实现都在文件currency.h之中，但是这种分置对后续章节要引入的大量模板函数和模板类是行不通的。</p> 
<h2 id="4.2.%E4%B8%80%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95">4.2.一种不同的描述方法</h2> 
<p>假设已经有很多应用程序采用我们上面的currency类的形式，现在我们想要修改对currency类对象的数据描述，是应用最多的两个成员函数add和increment运行更快，进而提高应用程序的执行速度。因为用户仅仅通过公有部分所提供的的接口与currency类进行交互，所以对私有部分的修改不会影响应用程序的正确性。因此，私有部分修改，而应用程序不用改。</p> 
<p><strong>类currency的新声明</strong>：</p> 
<blockquote> 
 <pre>class currency
{
public:
    //构造函数
    currency(signType theSign = plus,
            unsigned long theDollars = 0,
            unsigned int theCents = 0);
    //析构函数
    ~currency(){}
    void setValue(signType, unsigned long, unsigned int);
    void setValue(double);
    signType getSign() const
    {
        if(amount &lt; 0) return minus;
        else return plus;
    }
    unsigned long getDollars() const
    {
        if(amount &lt; 0) return (-amount) / 100;
        else return amount / 100;
    }
    unsigned int getCents() const
    {
        if(amount &lt; 0) return -amount - getDollars() * 100;
        else retrun amount - getDollars() * 100;
    }
    currency add(const currency&amp;) const;
    currency&amp; increment(const currency&amp; x)
    {
        amount += x.amount;
        return *this;
    }
    void output() const;
private:
    long amount;
};</pre> 
</blockquote> 
<p><strong>构造函数和成员函数setValue的新代码</strong>：</p> 
<blockquote> 
 <pre>currency::currency(sigeType theSign, unsigned long theDollars, unsigned int theCents)
{
    //创建一个currency类对象
    setValue(theSign, theDollars, theCents);
}
​
void currency::setValue(signType theSign, unsigned long theDollars, unsigened int theCents)
{
    //给调用对象赋值
    if(theCents &gt; 99)
        //美分值太大
        throw illegalParamenterValue("Cents should be &lt; 100");
    amount = theDollars * 100 + theCents;
    if(theSign == minus) amount = -amount;
}
​
void currency::setValue(double theAmount)
{
    //给调用对象赋值
    if(theAmount &lt; 0)
        amount = (long) ((theAmount - 0.001) * 100);
    else
        amount = (long) ((theAmount + 0.001) * 100);//取两个十位数
}</pre> 
</blockquote> 
<p><strong>成员函数add和output的新代码</strong>：</p> 
<pre><code class="language-cpp">currency currency::add(const currency&amp; x) const
{
    //把x和*this相加
    currency y;
    y.amount = amount + x.amount;
    return y;
}
​
void currency::output() const
{
    //输出调用对象的值
    long theAmount = amount;
    if(theAmount &lt; 0)
    {
        cout &lt;&lt; '-';
        theAmount = -theAmount;
    }
    long dollars = theAmount / 100;
    cout &lt;&lt; '$' &lt;&lt; dollars &lt;&lt; '.';
    int cents = theAmount - dollars * 100;
    if(cents &lt; 10) cout &lt;&lt; '0';
    cout &lt;&lt; cents &lt;&lt; endl;
}</code></pre> 
<h2 id="4.3.%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD">4.3.操作符重载</h2> 
<p>类currency有若干成员函数和C++标准操作符类似。例如，add实施的是+操作，increment实施的是+=操作。使用这些标准的C++操作符比定义新的诸如add和increment的成员函数要自然多得多。为了使用这些操作符+和+=，我们进行<strong>操作符重载</strong>（operator overloading），它可以扩大C++操作符的应用范围，使其操作新的数据类型或类。</p> 
<p><strong>包含操作符重载的类声明</strong>：</p> 
<pre><code class="language-cpp">class currency
{
public:
    //构造函数
    currency(signType theSign = plus,
            unsigned long theDollars = 0,
            unsigned int theCents = 0);
    //析构函数
    ~currency(){};
    void setValue(signType, unsigned long, unsigned int);
    void setValue(double);
    signType getSign() const
    {
        if(amount &gt; 0) return (-amount) / 100;
        else return amount / 100;
    } 
    unsigned int getCents() const
    {
        if(amount &lt; 0) return -amount - getDollars() * 100;
        else return amount - getDollars() * 100;
    }
    currency operator+(const currency&amp;) const;
    currency&amp; operator+=(const currency&amp; x)
    {
        amount += x.amount;
        return *this;
    }
    void output(ostream&amp;) const;
private:
    long amount;
};</code></pre> 
<p>上述代码的类声明分别用操作符+和+=替代了add和increment。成员函数output用一个输入流的名字作为参数。</p> 
<p><strong>+、output和&lt;&lt;的代码</strong>：</p> 
<pre><code class="language-cpp">currency currency::operator+(const currency&amp; x) const
{
    //把参数对象x和调用函数*this相加
    currency result;
    result.amount = amount + x.amount;
    return result;
}
​
void currency::output(ostream&amp; out) const
{
    //把货币值插入流out
    long theAmount = amount;
    if(theAmount &lt; 0)
    {
        out &lt;&lt; '-';
        theAmount = -theAmount;
    }
    long dollars = theAmount / 100;
    out &lt;&lt; '$' &lt;&lt; dollars * 100;
    int cents = theAmount - dollars * 100;
    if(cents &lt; 10) out &lt;&lt; '0';
    out &lt;&lt; cents;
}
​
//重载 &lt;&lt;
ostream&amp; operator&lt;&lt;(ostream&amp; out, const currency&amp; x)
{
    x.output(out);
    return out;
}</code></pre> 
<p>上述程序给定add和output的新代码，以及重载的C++流插入操作符&lt;&lt;的代码。</p> 
<p>注意，我们重载流插入操作符，但没有把它声明为类的成员函数，而是把重载+和+=声明为类的成员函数。同样，我们也可以重载流提取操作符&gt;&gt;，而没有把它声明为类的成员函数。还要注意，使用成员函数output有助于对流插入操作符&lt;&lt;的重载。因为非成员函数不能访问currency对象的私有成员（重载的&lt;&lt;不是成员函数，而重载的+是），所以重载&lt;&lt;的代码不能直接引用要插入到输出流的对象x的私有成员。</p> 
<p><strong>使用重载操作符</strong>：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include"currencyOverload.h"
using namespace std;
​
int main()
{
    currency g, h(plus, 3, 50), i, j;
    
    //使用两种形式的setValue来赋值
    g.setValue(minus, 2, 25);
    i.setValue(-6.45);
    
    //调用成员函数add和output
    j = h + g;
    
    cout &lt;&lt; h &lt;&lt; " + " &lt;&lt; g &lt;&lt; " = " &lt;&lt; j  &lt;&lt; endl;
    
    //连续两次调用成员函数add
    j = i + g + h;
    cout &lt;&lt; i &lt;&lt; " + " &lt;&lt; g &lt;&lt; " + " &lt;&lt; " and then add " &lt;&lt; h &lt;&lt; endl;
    
    //调用成员函数increment和add
    cout &lt;&lt; "Incement " &lt;&lt; i &lt;&lt; " by " &lt;&lt; g &lt;&lt; " and then add " &lt;&lt; h &lt;&lt; endl;
    j = (i += h) + h;
    cout &lt;&lt; "Result is " &lt;&lt; j &lt;&lt; endl;
    cout &lt;&lt; "Incemented object is " &lt;&lt; i &lt;&lt; endl;
    
    //测试异常
    cout &lt;&lt; "Attempting to iniitialize with cents = 152" &lt;&lt; endl;
    try{i.setValue(plus, 3, 152);}
    catch(illegalParameterValue e)
    {
        cout &lt;&lt; "Caught throw exception" &lt;&lt; endl;
        e.outputMessage();
    }
    return 0;
}</code></pre> 
<h2 id="4.4.%E5%8F%8B%E5%85%83%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%80%A7%E7%B1%BB%E6%88%90%E5%91%98">4.4.友元和保护性类成员</h2> 
<p>对一个类的私有成员，仅有类的成员函数才能直接访问。我们必须给予别的类和函数直接访问该类私有成员的权利。这就需要这些类和函数声明为该类的友元（friend）。</p> 
<p><strong>重载友元操作符&lt;&lt;</strong>：</p> 
<pre><code class="language-cpp">class currency
{
    friend ostream&amp; operator&lt;&lt;(ostream&amp;, const currency&amp;);
    public:
};
​
//重载
ostream&amp; operator&lt;&lt;(ostream&amp; out, const currency&amp; x)
{
    //把货币值插入流out
    long theAmount = x.amount;
    if(theAmount &lt; 0)
    {
        out &lt;&lt; '-';
        theAmount = -theAmount;
    }
    
    long dollars = theAmount / 100;
    out &lt;&lt; '$' &lt;&lt; dollars &lt;&lt; '.';
    int cents = theAmount - dollars * 100;
    if(cents &lt; 10) out &lt;&lt; '0';
    out &lt;&lt; cents;
    return out;
}</code></pre> 
<p>当我们把ostream&amp; operator&lt;&lt;声明为currency类的友元，它就可以直接访问currency类的所有成员（私有和公有），这时也就不用另外定义成员函数output了。为了建立友元，我们在currency类的描述中引入了friend语句。</p> 
<p>一个类A从另外一个类B派生，A是<strong>派生类</strong>（derived class），B是<strong>基类</strong>（base class）。派生类需要访问基类的部分或所有成员，为此，C++提供了第三方类成员——保护性类成员（protected）。保护性成员类似于私有成员，区别于派生类函数可以访问基类的保护性成员。</p> 
<p>用户应用程序可以访问的类成员应该是公开的。数据成员永远不要出现在公有部分，但是他们可以定义为保护性成员或者私有成员。优秀的软件工程师设计原则要求数据成员是私有的。通过成员函数，派生类可以间接访问基类的私有数据成员，同时，修改基类的实现代码时不用修改它的派生类。</p> 
<h2 id="4.5.%E5%A2%9E%E5%8A%A0%23ifndef%E3%80%81%23define%E5%92%8C%23endif%E8%AF%AD%E5%8F%A5">4.5.增加#ifndef、#define和#endif语句</h2> 
<p>在上面的文件currency.h（或者currencyOverload.h）包含了currency类的声明和实现细节。在文件头加上以下的语句：</p> 
<blockquote> 
 <pre>#ifndef Currency_
#define CUrrency_</pre> 
</blockquote> 
<p>在文件尾添加上：</p> 
<blockquote> 
 <pre>#endif</pre> 
</blockquote> 
<p>包含在这组语句之内的代码只能编译一次。</p> 
<h1 id="5.%E5%BC%82%E5%B8%B8%E7%B1%BBillegalParameterValue">5.异常类illegalParameterValue</h1> 
<p><strong>定义一个异常类</strong>：</p> 
<pre><code class="language-cpp">class illegalParameterValue
{
public:
    illegalParameterValue():
        message("Illegal parameter value"){}
    illegalParameterValue(char* theMessage)
    {
        message = theMessage;
    }
    void outputMessage()
    {
        cout &lt;&lt; message &lt;&lt; endl;
    }
private:
    string message;
};</code></pre> 
<p><strong>抛出illegalParameterValue类型的异常</strong>：</p> 
<blockquote> 
 <pre>int abc(int a, int b, int c)
{
    if(a &lt;= 0 || b &lt;= 0 || c &lt;= 0)
        throw illegalParameterValue("All parameters should be &gt; 0");
    return a + b * c;
}</pre> 
</blockquote> 
<p><strong>捕捉illegalParameterValue类型的异常</strong>：</p> 
<blockquote> 
 <pre>int main()
{
    try {cout &lt;&lt; abc(2, 0, 4) &lt;&lt; endl;}
    catch(illegalParameterValue e)
    {
        cout &lt;&lt; "The parameters to abc were 2, 0, and 4" &lt;&lt; endl;
        cout &lt;&lt; "illegalParameterValue exeception throw" &lt;&lt; endl;
        e.outputMessage();
        return 1;
    }
    return 0;
}</pre> 
</blockquote> 
<h1 id="6.%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">6.递归函数</h1> 
<p><strong>递归函数</strong>（recursive function）或方法自己调用自己。在直接调用<strong>直接递归</strong>（direct recursion）中，递归函数f的代码包含了调用f的语句，而在<strong>间接递归</strong>中，递归函数f调用了函数g，g有调用了函数h，如此下去，直到有调用了f。在深入探讨C++递归函数之前，我们来看看两个相关的数学概念——数学函数的递归定义和归纳证明。</p> 
<h2 id="6.1.%E9%80%92%E5%BD%92%E7%9A%84%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0">6.1.递归的数学函数</h2> 
<p>数学中经常有这样的函数，它自己定义自己。</p> 
<p>在一个基础部分（base component），它包含n的一个或多个值，对这些值，f(n)是直接定的；在递归调用部分（recursive component），右侧f有一个参数小于n，因此重复应用递归部分可以把右侧f的表达式转换为基础部分。</p> 
<p>比如说：递归定义的斐波那契数列：</p> 
<p>F0 = 0, F1 = 1, Fn = Fn-1 + Fn-2 (n&gt;1)</p> 
<p><strong>Fibonacci-斐波那契数列问题</strong>：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
​
int m;//定义要求的第m项斐波那契数列的项
​
int fib(int i)
{
    if(i == 0) return 0;
    if(i == 1) return 1;
    return (fib(i - 1) + fib(i - 2));//递归公式
}
​
int main()
{
    cout &lt;&lt; "请输出fib的项数：";
    cin &gt;&gt; m;
    cout &lt;&lt; endl;
    cout &lt;&lt; "第" &lt;&lt; m &lt;&lt; "项的fibonacci = " &lt;&lt; fib(m) &lt;&lt; endl;
    return 0;
}</code></pre> 
<h2 id="6.2.%E5%BD%92%E7%BA%B3">6.2.归纳</h2> 
<p>现在我们把注意力转移到与递归函数有关的第二个概念——归纳证明。</p> 
<p>一般，证明的方法是，首先检验，对n的一个或者多个基础值（一般n=0就可以），公式成立。然后假设当n从0到m时公式成立，其中m是任意一个大于或等于最大基础值的整数。最后，根据这个假设证明，当n等于m+1时公式成立。这种证明方法有三个部分——<strong>归纳基础</strong>（induction）、<strong>归纳假设</strong>（induction hypothesis）和<strong>归纳步骤</strong>（induction step）。</p> 
<p>在归纳假设中，假设n≤m时，公式均成立，其中m是任意大于或等于0的整数（假设n=m时，公式成立亦可）。在归纳步骤阶段，要证明当n=m+1时公式成立。</p> 
<p>乍一看，归纳证明好像是一个循环证明——因为我们给出的是一个假设为正确的结论，其实不然。就像递归定义并不是循环定义一样。每一个正确的归纳证明都有一个归纳基础部分，它与递归定义的基础部分相似。归纳步骤使用的是在归纳基础部分已经检验的正确结果。反复应用归纳步骤，把证明部分转化为基础部分所具有的形式。</p> 
<h2 id="6.3.C%2B%2B%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">6.3.C++递归函数</h2> 
<p>使用C++可以编写递归函数。正确的递归函数必须包含基础部分。每一次递归调用，其参数值都比上一次的参数值要小，从而重复调用递归函数使参数值达到基础部分的值。</p> 
<p><strong>计算n!的递归函数</strong>：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int n;
​
int factorial(int i)
{
    //计算n!
    if(i &lt;= 1) return 1;
    else return i * factorial(i - 1);
}
​
int main()
{
    scanf("%d", &amp;n);
    printf("%d!的递归值：%d", n, factorial(n));
    return 0;
}</code></pre> 
<p>阶乘程序是一个典型的C++递归函数，它利用相应的数学公式来计算阶乘n!。基础部分是n≤1.考虑到factorial(2)的计算过程。将factorial(2)挂起来，然后调用factorial(1)。程序状态（即局部变量和传值形参的值、与引用形参绑定的值、代码执行位置等）被保留在递归栈中。当factorial(1)的计算结束时，程序状态恢复。</p> 
<p><strong>累加数组元素a[0:n-1]</strong>：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#define N 1000
using namespace std;
​
template&lt;class T&gt;
T sum(T a[], int n)
{
    //返回值为数组元素a[0:n-1]的和
    T theSum = 0;
    for(int i = 0;i &lt; n; i++)
    {
        theSum += a[i];
    }
    return theSum;
}
​
int main()
{
    int n, q[N];
    scanf("%d", &amp;n);
    for(int i = 0;i &lt; n; i++)
    {
        scanf("%d", &amp;q[i]);
    }
    
    int total = sum(q, n);
    
    printf("%d", total);
    return 0;
}</code></pre> 
<p>模板函数sum对数组元素a[0]至a[n-1]求和，当n=0时，函数返回值是0。</p> 
<p>当然累加数组元素也能使用递归代码</p> 
<blockquote> 
 <pre>template&lt;class T&gt;
T rSum(T a[], int n)
{
    //返回值为数组元素a[0:n-1]的和
    if(n &gt; 0)
    {
        return rSum(a, n-1) + a[n-1];
    }
    return 0;
}</pre> 
</blockquote> 
<p><strong>排列</strong>：</p> 
<p>我们常常要从n个不同元素的所有排列中确定一个最佳的排列。例如，a、b和c的排列，就有abc、acb、bac、bca、cab和cba。n个元素的排列个数是n!。</p> 
<p>为了输出n个元素的所有排列，编写非递归的C++函数比较困难，但是编写递归函数就没有那么困难了。设E={e1, ..., en}是n个元素的集合，求E的元素的所有排列。令Ei表示从E中去除第i个元素ei以后的集合，令perm(X)的表示集合X所有元素所组成的所有排列，令ei.perm(X)表示在perm(X)中的每个排列加上前缀.ei之后的排列表。</p> 
<p>当n=1时，是递归的基础部分。这时的集合E只有一个元素e，因此只有一个排列：perm(E)=(e)。当n&gt;1时，perm(E)是一个表。</p> 
<p><strong>使用递归函数生成排列</strong>：</p> 
<blockquote> 
 <pre>template&lt;class T&gt;
void permytations(T list[], int k, int m)
{
    //生成list[k:m]的所有排列
    if(k == m)
    {
        //list[k:m]仅有一个排列，输出它
        copy(list, list+m+1,
            ostream_iterator&lt;T&gt;(cout, ""));
        cout &lt;&lt; endl;
    }
    else//list[k:m]有多于一个的排列，递归的生成这些排列
        for(int i = k;i &lt;= m; i++)
        {
            swap(list[k], list[i]);
            permytations(list, k+1, m);
            swap(list[k], list[i]);
        }
}</pre> 
</blockquote> 
<h1 id="7.%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93">7.标准模板库</h1> 
<p>C++标准模板库（STL）是一个容器、适配器、迭代器、函数对象（也称仿函数）和算法的集合。有效的使用STL，应用程序的设计会简单许多。本书首先使用基本的C++语言结构解决一个问题，以说明求解问题的方法。然后利用STL说明如何使用更简单的方法解决同样的问题。</p> 
<h2 id="7.1.accumulate">7.1.accumulate</h2> 
<p>STL有一个算法accumulate是对顺序表元素顺序累计求和。</p> 
<p>它的语法<code>accumulate(start, end, initialValue)</code></p> 
<p>其中的start指向首元素，end指向尾元素的下一个位置，因此要累计求和的元素范围是[start, end]，调用的语句也就是<code>accumulate(a, a+n, theSum);</code></p> 
<p>其中一个a是一维数组。返回值：<code>initialValue+a[i]的和</code></p> 
<p><strong>利用STl的算法accumulate</strong></p> 
<blockquote> 
 <pre>template&lt;class T&gt;
T sum(T a[], int n)
{
    //返回数组a[0:n-1]的累计和
    T thsSum = 0;
    return accumulate(a, a + n, theSum);
}</pre> 
</blockquote> 
<p>STL的算法accumulate利用操作符++，从start开始，到end结束，相继访问要累计求和的顺序表元素。因此，对于任意一个序列，如果他的元素可以通过重复应用操作符++来访问。一维数组和STl的vector容器都是这种顺序表的实例。</p> 
<p>STL算法accumulate还有一个更加通用的形式<code>accumulate(start , end, initialValue, operator)</code></p> 
<p>其中，operator是一个函数，它规定了在累计过程中的操作。</p> 
<p><strong>计算数组元素a[0:n-1]的乘法</strong></p> 
<blockquote> 
 <pre>template&lt;class T&gt;
T product(T a[], int n)
{
    //返回数组a[0:n-1]的累计和
    T theProduct = 1;
    return accumulate(a, a+n, theProduct, multiplies&lt;T&gt;());
}</pre> 
</blockquote> 
<h2 id="7.2.copy%E5%92%8Cnext_permutation">7.2.copy和next_permutation</h2> 
<p>算法copy是把一个顺序表的元素从一个位置复制到另一个位置上去。语法：<code>copy(start, end, to);</code>其中to给出了第一个元素要复制到的位置。因此，元素从位置start,start+1, ...,end-1依次复制到位置to, to+1,...,to+end-start。</p> 
<p>算法next_permutation，其语法为：<code>next_permutation</code></p> 
<p>对范围[start, end)内的元素，按字典顺序，产生下一个更大的排列。当且仅当这个排列存在时，返回true。</p> 
<p><strong>使用STL算法next_permutation求排列</strong></p> 
<blockquote> 
 <pre>template&lt;class T&gt;
void permutation(T list[], int k, int m)
{
    //生成list[k:m]的所有排列
    //假设k≤m
    //将排序逐个输出
    do
    {
        copy(list, listm+1,
            ostream_iterator&lt;T&gt;(cout, ""));
        cout &lt;&lt; endl;
    }while(next_permutation(list, list+m+1));
}</pre> 
</blockquote> 
<p>next_permutation算法具有更一般的形式，它带有第三个参数compare。而compare函数用来判定一个排列是否比另一个排序小。</p> 
<p style="text-align:center"><img alt="" height="474" src="https://images2.imgbox.com/f8/09/Yh3aTkyZ_o.jpg" width="474"></p> 
<p> </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>