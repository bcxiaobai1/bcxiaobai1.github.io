<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Unity ECS实例：制作俯视角射击游戏！ - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity ECS实例：制作俯视角射击游戏！</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%88%9B%E5%BB%BA%E4%B8%BB%E8%A7%92-toc" style="margin-left:0px"><a href="#%E5%88%9B%E5%BB%BA%E4%B8%BB%E8%A7%92">创建主角</a></p> 
<p id="3%EF%BC%9A%E4%B8%BB%E8%A7%92%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F-toc" style="margin-left:0px"><a href="#3%EF%BC%9A%E4%B8%BB%E8%A7%92%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F">3：主角移动和摄像机跟随</a></p> 
<p id="4%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%8C%E4%BA%BA%E8%A7%92%E8%89%B2-toc" style="margin-left:0px"><a href="#4%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%8C%E4%BA%BA%E8%A7%92%E8%89%B2">4：实现敌人角色</a></p> 
<p id="5%EF%BC%9A%E5%AD%90%E5%BC%B9%EF%BC%8C%E6%AD%BB%E4%BA%A1%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA-toc" style="margin-left:0px"><a href="#5%EF%BC%9A%E5%AD%90%E5%BC%B9%EF%BC%8C%E6%AD%BB%E4%BA%A1%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA">5：子弹，死亡，机器人</a></p> 
<p id="6%EF%BC%9A%E7%B2%92%E5%AD%90%E4%B8%8E%E9%9F%B3%E6%95%88-toc" style="margin-left:0px"><a href="#6%EF%BC%9A%E7%B2%92%E5%AD%90%E4%B8%8E%E9%9F%B3%E6%95%88">6：粒子与音效</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<p>这次我们来使用Unity ECS系统制作一个俯视角度的射击游戏。虽然现在网上有不少ECS的资料和项目，但是制作时又和实际游戏需求有较大差距。在制作这个小游戏的过程中我遇到了很多ECS特有的问题，也给出了还可以的解决方案，相信能通过实例让大家了解到ECS的优缺点是什么。</p> 
<p>（文章不会再解释Unity DOTS的一些基本概念，感兴趣的朋友可以查阅文档了解）。</p> 
<p>本游戏具体玩法如下：</p> 
<p>1：完全使用键盘控制，WASD键控制角色方向移动，j 键控制射击。（这样做主要为了简化游戏输入逻辑）</p> 
<p>2：玩家有手枪和霰弹枪两种武器形态，按Q切换。</p> 
<p>3：当敌人低于一定量，会在玩家一定距离周围生成敌人。敌人会朝玩家移动并射击玩家。</p> 
<p>4：玩家和敌人都有生命值，中弹后生命减少，减为0的时候死亡</p> 
<p>这里放下Unity和相关Package版本，以免误导后来者：</p> 
<p>Unity 版本：Unity2020.3.3f1，Universal Render Pipeline</p> 
<p>Hybrid Renderer： Version 0.11.0-preview.44</p> 
<p>Unity Physics： Version 0.6.0-preview.3</p> 
<p>Jobs:  Version 0.8.0-preview.23</p> 
<p>Entities: 0.17.0-preview.41</p> 
<h1 id="%E5%88%9B%E5%BB%BA%E4%B8%BB%E8%A7%92">创建主角</h1> 
<p>先简单搭建场景，再创建主角。</p> 
<p>首先建一个平面，扔上贴图，再建个圆圆胖胖的主角，添加物理组件Physics Shape 和Physics Body： </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/63/79/SzIHuT8x_o.png"></p> 
<p>Physic Shape的碰撞框同样可以在场景中进行编辑，你也可以点击Fit to Enabled Meshs来直接适配：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a7/a0/j0pWkfp8_o.png"></p> 
<p>以及实体转换组件，Convert To Entity：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/67/d6/djY1zf0X_o.png"></p> 
<p>我们需要其中主角能被敌人的子弹打中并获取碰撞事件，所以点击Collision Response，选择Raise Trigger Event （ 开启触发器事件），并点击PhysicBody的Motion Type，选择Kinematic ：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a8/5d/4igxYkyB_o.png"></p> 
<h1 id="3%EF%BC%9A%E4%B8%BB%E8%A7%92%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F">3：主角移动和摄像机跟随</h1> 
<p>首先为主角创建一个Component，包含初始速度：</p> 
<p>using Unity.Entities;</p> 
<p>[GenerateAuthoringComponent]<br> public struct Character :IComponentData<br> {<!-- --><br>     public float speed;<br> }</p> 
<p><br> 将组件挂到主角身上，speed设为10，再单独创建一个System，控制主角移动：</p> 
<p>using Unity.Entities;<br> using Unity.Jobs;<br> using Unity.Transforms;<br> using Unity.Mathematics;<br> using UnityEngine;</p> 
<p>public class CharacterSystem : SystemBase<br> {<!-- --><br>     protected override void OnUpdate()<br>     {<!-- --><br>         float deltaTime = Time.DeltaTime;<br>         float3 input;<br>         string h = "Horizontal";<br>         string v = "Vertical";</p> 
<p>        Entities.<br>             WithoutBurst().<br>             WithName("Player").<br>             ForEach((ref Translation translation, ref Rotation rotation, in Character character) =&gt;<br>             {<!-- --><br>                 input.x = Input.GetAxis(h);<br>                 input.y = 0;<br>                 input.z = Input.GetAxis(v);<br>                 var dir = character.speed * deltaTime * input;<br>                 dir.y = 0;<br>                 //令角色前方和移动方向一致<br>                 if (math.length(input) &gt; 0.1f)<br>                 {<!-- --><br>                     //Debug.Log("Dir " + dir);<br>                     rotation.Value = quaternion.LookRotation(math.normalize(dir), math.up());<br>                 }<br>                 translation.Value += dir;<br>             }).Run();<br>     }<br> }</p> 
<p><br> 相机不支持转换为Entity，所以我们还是用老办法做一个跟随脚本，通过查找包含CharacterComponent的Entity，获取其Translation，得到主角位置，进行跟随，代码如下：</p> 
<p>using UnityEngine;<br> using Unity.Entities;<br> using Unity.Mathematics;<br> using Unity.Transforms;<br> using Unity.Collections;</p> 
<p>public class CameraController : MonoBehaviour<br> {<!-- --><br>     [SerializeField] private Vector3 offset;//相机相对于玩家的位置</p> 
<p>    private Vector3 pos;<br>     public float speed;</p> 
<p>    private EntityManager _manager;<br>     private float3 tempPos;<br>     public Entity targetEntity;<br>     void Start()<br>     {<!-- --><br>         _manager = World.DefaultGameObjectInjectionWorld.EntityManager;<br>         //定义一个查询 ：查询实体必须包含Character组件和Translation组件<br>         var queryDescription = new EntityQueryDesc<br>         {<!-- --><br>             None = new ComponentType[] { },<br>             All = new ComponentType[] { ComponentType.ReadOnly&lt;Character&gt;(), ComponentType.ReadOnly&lt;Translation&gt;() }<br>         };</p> 
<p>        EntityQuery players = _manager.CreateEntityQuery(queryDescription);<br>         //场景中只有主角有Character组件，所以直接获取引用<br>         if (players.CalculateEntityCount() != 0)<br>         {<!-- --><br>             NativeArray&lt;Entity&gt; temp = new NativeArray&lt;Entity&gt;(1, Allocator.Temp);<br>             temp = players.ToEntityArray(Allocator.Temp);<br>             targetEntity = temp[0];<br>             temp.Dispose();<br>         }<br>         players.Dispose();</p> 
<p>    }</p> 
<p>    void Update()<br>     {<!-- --><br>         if (targetEntity != Entity.Null)<br>         {<!-- --><br>             if (_manager.HasComponent&lt;Translation&gt;(targetEntity))<br>             {<!-- --><br>                 tempPos = _manager.GetComponentData&lt;Translation&gt;(targetEntity).Value;<br>             }<br>         }</p> 
<p>        transform.position = Vector3.Lerp(transform.position, (Vector3)tempPos + offset, speed * Time.deltaTime);//调整相机与玩家之间的距离<br>     }<br> }</p> 
<p><br> 最后给主角手里整把枪，OK，现在主角已经能跑了：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ff/3f/3XLASrK3_o.gif"></p> 
<h1 id="4%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%8C%E4%BA%BA%E8%A7%92%E8%89%B2">4：实现敌人角色</h1> 
<p>敌人造型和玩家基本一致，由于玩家需要随时找到并攻击玩家角色，所以需要在定义它的Componnet 中存一个玩家Entity的引用:</p> 
<p>using Unity.Entities;</p> 
<p>[GenerateAuthoringComponent]<br> public struct Enemy : IComponentData<br> {<!-- --><br>     public float speed;<br>     //追踪目标<br>     public Entity targetEntity;<br> }</p> 
<p><br> 首先我们需要在主角身旁一定范围外生成这些这些敌人，方便起见，我们可以在场景中创建一个管理类，存一个已经转换成实体的的敌人预制体，每次生成的时候直接按照这个模版生成即可，代码如下：</p> 
<p>using UnityEngine;<br> using Unity.Entities;<br> using Unity.Mathematics;<br> using Unity.Transforms;</p> 
<p>public class FPSGameManager : MonoBehaviour<br> {<!-- --><br>     public static FPSGameManager instance;<br>     public GameObject enemyprefab;</p> 
<p>    private EntityManager _manager;<br>     //blobAssetStore是一个提供缓存的类，缓存能让你对象创建时更快。<br>     private BlobAssetStore _blobAssetStore;<br>     private GameObjectConversionSettings _settings;</p> 
<p>    public Entity enemyEntity;</p> 
<p>    void Start()<br>     {<!-- --><br>         instance = this;<br>         _manager = World.DefaultGameObjectInjectionWorld.EntityManager;<br>         _blobAssetStore = new BlobAssetStore();<br>         _settings = GameObjectConversionSettings.FromWorld(World.DefaultGameObjectInjectionWorld, _blobAssetStore);<br>         enemyEntity = GameObjectConversionUtility.ConvertGameObjectHierarchy(enemyprefab, _settings);<br>         Translation translation = new Translation<br>         {<!-- --><br>             Value = float3.zero<br>         };<br>         _manager.SetComponentData(test, translation);<br>     }</p> 
<p>    private void OnDestroy()<br>     {<!-- --><br>         _blobAssetStore.Dispose();<br>     }<br> ｝</p> 
<p><br> EnemySystem负责控制敌人追踪主角，并在敌人数量少于一定量时生成新的敌人：</p> 
<p>using Unity.Entities;<br> using Unity.Jobs;<br> using Unity.Transforms;<br> using Unity.Mathematics;<br> using UnityEngine;</p> 
<p>public class EnemySystem : SystemBase<br> {<!-- --><br>     EndSimulationEntityCommandBufferSystem endSimulationEcbSystem;<br>     //保存筛选出来的敌人的对象<br>     private EntityQuery query;<br>     private uint seed = 1;</p> 
<p>    protected override void OnCreate()<br>     {<!-- --><br>         base.OnCreate();<br>         endSimulationEcbSystem = World.GetOrCreateSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();<br>     }<br>     protected override void OnUpdate()<br>     {<!-- --><br>         Unity.Mathematics.Random random = new Unity.Mathematics.Random(seed++);</p> 
<p>        float deltaTime = Time.DeltaTime;</p> 
<p>        EntityCommandBuffer ecb = endSimulationEcbSystem.CreateCommandBuffer();<br>         Entity template = FPSGameManager.instance.enemyEntity;<br>         //对所有敌人操作<br>         Entities.<br>             WithStoreEntityQueryInField(ref query).<br>             ForEach((Entity entity, ref Translation translation, ref Rotation rotation, ref Enemy enemy) =&gt;<br>         {<!-- --><br>             if (HasComponent&lt;LocalToWorld&gt;(enemy.targetEntity))<br>                 {<!-- --><br>                     //追踪主角<br>                     LocalToWorld targetl2w = GetComponent&lt;LocalToWorld&gt;(enemy.targetEntity);<br>                     float3 targetPos = targetl2w.Position;<br>                     translation.Value = Vector3.MoveTowards(translation.Value, targetPos, enemy.speed * deltaTime);</p> 
<p>                    var targetDir = targetPos - translation.Value;<br>                     quaternion temp1 = quaternion.LookRotation(targetDir, math.up());<br>                     rotation.Value = temp1;<br>                 }<br>         }).Run();</p> 
<p>        //敌人数量少于6,在主角周围新生成6个敌人<br>         if (query.CalculateEntityCount() &lt; 6)<br>         {<!-- --><br>             Entity characterEntity = GetSingletonEntity&lt;Character&gt;();<br>             float3 characterPos=float3.zero;<br>             if (characterEntity!=Entity.Null)<br>             {<!-- --><br>                 if (HasComponent&lt;Translation&gt;(characterEntity))<br>                 {<!-- --><br>                     Translation translation = GetComponent&lt;Translation&gt;(characterEntity);<br>                     characterPos = translation.Value;<br>                 }<br>             }</p> 
<p>            for (int i = 0; i &lt; 6; i++)<br>             {<!-- --><br>                 Entity temp = ecb.Instantiate(template);</p> 
<p>                #region 随机位置生成敌人<br>                  //略。。。详见工程<br>                 #endregion</p> 
<p>                Translation translation = new Translation<br>                 {<!-- --><br>                     Value=new float3(x,characterPos.y,z)<br>                 };<br>                 //这里可能有疑问为何预制体组件已经有enemy的数据了，这里为何要重新赋值？<br>                 //这是因为场景中的主角预制体要在场景运行后才能转换为Entity，并且转换时间不确定，所以等待其生成后重新赋值<br>                 Enemy enemy = new Enemy<br>                 {<!-- --><br>                     speed=5f ,<br>                     targetEntity=characterEntity<br>                 };</p> 
<p>                ecb.SetComponent(temp, translation);<br>                 ecb.SetComponent(temp, enemy);<br>             }<br>         }<br>     }<br> }</p> 
<p><br> 点击运行，敌人也生成出来并开始工作了：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/23/77/qLjG3qJb_o.gif"></p> 
<h1 id="5%EF%BC%9A%E5%AD%90%E5%BC%B9%EF%BC%8C%E6%AD%BB%E4%BA%A1%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA">5：子弹，死亡，机器人</h1> 
<p>接下来我们要定义武器和子弹。虽然Convert to Entity会把面板的物体的子物体也转换为Entity，并在Entity Debugger中可以看到，但目前GameObject 方便的父子关系还不能在Unity ECS中使用，所以我们需要先记录枪口的位置。</p> 
<p>首先定义武器：</p> 
<p>using Unity.Entities;</p> 
<p>//手枪，霰弹枪，自动模式<br> public enum WeaponType<br> {<!-- --><br>     gun,<br>     shotgun,<br>     gunAutoshot<br> }<br> [GenerateAuthoringComponent]<br> public struct  Weapon : IComponentData<br> {<!-- --><br>     //枪口位置<br>     public Entity gunPoint;<br>     //武器类型<br>     public WeaponType weaponType;<br>     //是否允许切换武器<br>     public bool canSwitch;<br>     //开枪间隔<br>     public float firingInterval;<br>     //用来记录每次开枪的时间<br>     public float shotTime;<br> }</p> 
<p><br> 接着定义子弹组件，制作子弹预制体的流程和上文一样，这里就不赘述了：</p> 
<p>using Unity.Entities;</p> 
<p>[GenerateAuthoringComponent]<br> public struct Bullet: IComponentData<br> {<!-- --><br>     public float flySpeed;<br> }</p> 
<p><br> 再定义一个作删除标签功能的组件：DeleteTag，为了尽量避免频繁的结构性变化（增删组件等），我们需要在可以被删除的物体的预制件上添加这个组件，并将其lifeTime设置为1 :</p> 
<p>using Unity.Entities;</p> 
<p>[GenerateAuthoringComponent]<br> public struct DeleteTag :IComponentData<br> {<!-- --><br>     public float lifeTime;<br> }</p> 
<p><br> 这样的话，我们就可以定下规则，当物体身上DeleteTag组件的lifeTime&lt;=0时，系统会将其删除：</p> 
<p>using Unity.Entities;<br> using Unity.Jobs;</p> 
<p>public class DeleteSystem : SystemBase<br> {<!-- --><br>     EndSimulationEntityCommandBufferSystem endSimulationEcbSystem;<br>     protected override void OnCreate()<br>     {<!-- --><br>         base.OnCreate();<br>         endSimulationEcbSystem = World.GetOrCreateSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();<br>     }<br>     protected override void OnUpdate()<br>     {<!-- --><br>          // 请求一个ECS并且转换成可并行的<br>         var ecb = endSimulationEcbSystem.CreateCommandBuffer().AsParallelWriter();<br>         Entities<br>            .ForEach((Entity entity, int entityInQueryIndex, in DeleteTag deleteTag) =&gt;<br>       {<!-- --><br>           if (deleteTag.lifeTime &lt;=0f)<br>           {<!-- --><br>               ecb.DestroyEntity(entityInQueryIndex, entity);<br>           }<br>       }).ScheduleParallel();<br>         // 保证ECB system依赖当前这个Job<br>         endSimulationEcbSystem.AddJobHandleForProducer(this.Dependency);<br>     }<br> }</p> 
<p><br> 子弹的生命会不断减少，所以BulletSystem中需要自行对lifeTime 做减法：</p> 
<p>using Unity.Entities;<br> using Unity.Jobs;<br> using Unity.Transforms;<br> using Unity.Mathematics;</p> 
<p>public class BulletSystem : SystemBase<br> {<!-- --><br>     EndSimulationEntityCommandBufferSystem endSimulationEcbSystem;<br>     protected override void OnCreate()<br>     {<!-- --><br>         base.OnCreate();<br>         endSimulationEcbSystem = World.GetOrCreateSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();<br>     }<br>     protected override void OnUpdate()<br>     {<!-- --><br>         float deltaTime = Time.DeltaTime;<br>         var ecb = endSimulationEcbSystem.CreateCommandBuffer();<br>         Entities.<br>         ForEach(( ref Translation translation, ref DeleteTag deleteTag, in Rotation rot, in Bullet bullet) =&gt;<br>         {<!-- --><br>             //子弹向前飞行<br>             translation.Value += bullet.flySpeed * deltaTime * math.forward(rot.Value);<br>             //生命不断减少<br>             deleteTag.lifeTime-= deltaTime;</p> 
<p>        }).Run();<br>     }<br> }</p> 
<p><br> WeaponSystem，不同枪械的子弹生命周期也不同，手枪子弹为1s，霰弹枪0.5f：</p> 
<p>using Unity.Entities;<br> using Unity.Jobs;<br> using Unity.Transforms;<br> using Unity.Mathematics;<br> using UnityEngine;<br> public class WeaponSystem : SystemBase<br> {<!-- --><br>     EndSimulationEntityCommandBufferSystem endSimulationEcbSystem;<br>     protected override void OnCreate()<br>     {<!-- --><br>         base.OnCreate();<br>         endSimulationEcbSystem = World.GetOrCreateSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();</p> 
<p>    }<br>     protected override void OnUpdate()<br>     {<!-- --><br>         float deltaTime = Time.DeltaTime;<br>         float time = UnityEngine.Time.time;<br>         EntityCommandBuffer ecb = endSimulationEcbSystem.CreateCommandBuffer();<br>         Entities.<br>             WithoutBurst().<br>             ForEach((ref Weapon weapon, in Rotation rotation) =&gt;<br>         {<!-- --></p> 
<p>            if (weapon.weaponType == WeaponType.gunAutoshot)<br>             {<!-- --></p> 
<p>                if (weapon.shotTime == -1f)<br>                 {<!-- --><br>                     weapon.shotTime = time;<br>                 }</p> 
<p>                //  Debug.Log("当前时间" + time);<br>                 if (time - weapon.shotTime &gt;= weapon.firingInterval)<br>                 {<!-- --><br>                     weapon.shotTime = time;<br>                     float3 pos = new float3();<br>                     LocalToWorld gunPointL2w = new LocalToWorld();</p> 
<p>                    if (HasComponent&lt;LocalToWorld&gt;(weapon.gunPoint))<br>                     {<!-- --><br>                         gunPointL2w = GetComponent&lt;LocalToWorld&gt;(weapon.gunPoint);</p> 
<p>                        Entity tempBullet = ecb.Instantiate(FPSGameManager.instance.bulletEntity);</p> 
<p>                        Translation translation = new Translation<br>                         {<!-- --><br>                             Value = gunPointL2w.Position<br>                         };<br>                         Rotation rot = new Rotation<br>                         {<!-- --><br>                             Value = rotation.Value<br>                         };<br>                         Bullet bullet = new Bullet<br>                         {<!-- --><br>                             lifetime = 2,<br>                             flySpeed = 20,<br>                         };</p> 
<p>                        ecb.SetComponent(tempBullet, translation);<br>                         ecb.SetComponent(tempBullet, rot);<br>                         ecb.SetComponent(tempBullet, bullet);<br>                         FPSGameManager.instance.PlayShoot();<br>                     }<br>                 }<br>                 return;<br>             }</p> 
<p>            if (weapon.canSwitch)<br>             {<!-- --><br>              //武器切换逻辑，按Q修改武器类型，详见工程<br>             }</p> 
<p>            #region 开枪<br>             if (Input.GetKeyDown(KeyCode.J))<br>             {<!-- --><br>                 float3 pos = new float3();<br>                 LocalToWorld gunPointL2w = new LocalToWorld();</p> 
<p>                if (HasComponent&lt;LocalToWorld&gt;(weapon.gunPoint))<br>                 {<!-- --><br>                     gunPointL2w = GetComponent&lt;LocalToWorld&gt;(weapon.gunPoint);<br>                     pos = gunPointL2w.Position;<br>                 }</p> 
<p>                switch (weapon.weaponType)<br>                 {<!-- --><br>                     case WeaponType.gun:<br>                         #region 手枪<br>                         Entity tempBullet = ecb.Instantiate(FPSGameManager.instance.bulletEntity);</p> 
<p>                        //=====初始化手枪组件并赋给Entity，和上文初始化子弹逻辑相同，略========</p> 
<p>                        //播放射击音效<br>                         FPSGameManager.instance.PlayShoot();<br>                         #endregion<br>                         break;<br>                     case WeaponType.shotgun:<br>                         #region  霰弹枪</p> 
<p>                        // ====初始化子弹的translation2和bullet组件，略======</p> 
<p>                        for (int i = -5; i &lt; 5; i++)<br>                         {<!-- --><br>                             Entity tempBullet2 = ecb.Instantiate(FPSGameManager.instance.bulletEntity);</p> 
<p>                            #region 传统写法<br>                             //Quaternion q = rotation.Value;<br>                             //Quaternion tempRot = Quaternion.Euler(0, q.eulerAngles.y + i * 7, 0);<br>                             #endregion</p> 
<p>                            //使用Unity.Mathematics库写法，这里默认按照弧度旋转<br>                             quaternion temp = math.mul( quaternion.EulerXYZ(0, i *0.1f, 0), rotation.Value) ;<br>                             Rotation rotation2 = new Rotation<br>                             {<!-- --><br>                                 Value = temp<br>                             };<br>                             ecb.SetComponent(tempBullet2, translation2);<br>                             ecb.SetComponent(tempBullet2, rotation2);<br>                             ecb.SetComponent(tempBullet2, bullet1);<br>                         }</p> 
<p>                        FPSGameManager.instance.PlayShoot();<br>                         #endregion<br>                         break;<br>                     default:<br>                         break;<br>                 }</p> 
<p>            }<br>             #endregion</p> 
<p>        }).Run();<br>     }<br> }</p> 
<p><br> 在主角和敌人身上分别挂上Weapon组件，主角便可以使用两种武器了，敌人也能自动发射子弹了：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8b/ef/qf20U7U7_o.gif"></p> 
<p>接下来就要用到ECS中新版的物理组件了，我们先在组件中设置子弹和敌人的碰撞层级，保证同类物体不会触发碰撞事件，只有子弹和敌人碰撞会触发事件：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/95/06/9lubpqM0_o.png"></p> 
<p>这里搜索资料后发现比较简单的做法是去定义一个Job继承ITriggerEventsJob接口，去接收事件，但由于Job中是并行处理数据，遇到了新的问题，由于代码比较长，上部分伪代码来说明：</p> 
<p>[BurstCompile]<br>     private struct TriggerJob :ITriggerEventsJob<br>     {<!-- --><br>         #region 传递进来的各类group数据<br>         #endregion<br>         public void Execute(TriggerEvent triggerEvent)<br>         {<!-- --><br>             //triggerEvent包含两个碰撞实体，需要我们自行判断他们属于哪个ComponentGroup<br>             if (EnemyGroup.HasComponent(triggerEvent.EntityA))<br>             {<!-- --><br>                 //敌人与主角碰撞效果<br>                 if (!BulletGroup.HasComponent(triggerEvent.EntityB) &amp;&amp; BeatBackGroup.HasComponent(triggerEvent.EntityB))<br>                 {<!-- --><br>                     #region 击退<br>                     #endregion<br>                     return;<br>                 }<br>                 isbehit[0] = true;</p> 
<p>                #region 删除子弹<br>                 #endregion</p> 
<p>                #region 子弹击退敌人效果<br>                 #endregion</p> 
<p>                #region 扣血并生成爆炸粒子实体<br>                 #endregion<br>             }<br>             if (EnemyGroup.HasComponent(triggerEvent.EntityB)){}<br>         }<br>     }<br> }</p> 
<p><br> 图中代码的意思大概是这样：当接收到世界中发生的碰撞事件后，首先Job会判断碰撞物属于哪个ComponentGroup，如果Enemy，扣一滴血；包含Bullet，则直接销毁子弹实体，但实际上写完运行确遇到了这样的问题：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/49/9b/iWGwWJiE_o.gif"></p> 
<p>删除子弹实体的操作并非立即执行，同时删除子弹实体的操作和TriggerJob也是并行的（不在同一线程，两者先后顺序不确定），所以可能会出现图中的状况(箭头长度代表时间长度)：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/30/26/CD01iiZH_o.png"></p> 
<p>为了解决这个问题，我首先的思路是为子弹增加一个bool值记录它的状态，如果接触到敌人，再次触发碰撞事件时会直接返回，代码如下：</p> 
<p>if (EnemyGroup.HasComponent(triggerEvent.EntityA))<br>    {<!-- --><br>            //A是敌人，自然EntityB是子弹<br>            if (BulletGroup[triggerEvent.EntityB].isDestory)<br>            {<!-- --><br>                 Debug.Log("子弹已被删除");<br>                 return;<br>            }</p> 
<p>           Bullet a = BulletGroup[triggerEvent.EntityB];<br>            a.isDestory = true;<br>            BulletGroup[triggerEvent.EntityB] = a;<br>    ｝</p> 
<p><br> 结果连续触发碰撞事件时，直接报错The entity does not exist，bullet Group 中并不包含这个引发碰撞的子弹： </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b0/58/EgV5Dyb1_o.gif"></p> 
<p> </p> 
<p>造成这个的原因也比较好猜，当我们执行删除子弹实体的代码时，子弹实体并不会立即删除，而是要等到EntityCommandBufferSystem回放命令时统一调度，所以已经子弹可能已经被系统标记为空，自然不在BulletGroup中了，自然也找不到该实体。</p> 
<p>解决问题思路还有很多，我们当然可以在代码中修改Collision Filter，或是关闭子弹的碰撞事件来达成效果。。但实际上这两种操作都非常麻烦，目前Dots还没有这么的自由。</p> 
<p>在尝试过上述做法后，我所想到的一个简单的思路：在发生碰撞时，将子弹挪到一个看不见位置去，这样就不会造成多次触发碰撞事件；</p> 
<p>同时每个子弹都有自己的生命周期，所以也可能发生子弹生命到了，被标记删除，但又刚好触发碰撞的情况。为了避免这样的冲突，我们需要在每个Group中都对子弹进行HasComponent判定，子弹删除代码如下：</p> 
<p>if (EnemyGroup.HasComponent(triggerEvent.EntityA))<br>    {<!-- --><br>             //A是敌人，自然EntityB是子弹<br>             if (TranslationGroup.HasComponent(triggerEvent.EntityB))<br>                {<!-- --><br>                    Translation temp = TranslationGroup[triggerEvent.EntityB];<br>                    //将子弹移到天上去<br>                    temp.Value = new float3(0, 100, 0);<br>                    TranslationGroup[triggerEvent.EntityB] = temp;</p> 
<p>                   if (DeleteGroup.HasComponent(triggerEvent.EntityB))<br>                    {<!-- --><br>                       DeleteTag temp1 = DeleteGroup[triggerEvent.EntityB];<br>                       temp1.lifeTime = 0f;<br>                       DeleteGroup[triggerEvent.EntityB] = temp1;<br>                    }<br>                }<br>    ｝</p> 
<p><br> 最后再做个敌人被击退的效果，给敌人添加BeatBack组件，每次被子弹击中时，敌人都会获得一个持续衰减的速度，被连续击中时，获得的加速度也会逐渐衰减：</p> 
<p>using Unity.Entities;<br> using Unity.Transforms;</p> 
<p>[GenerateAuthoringComponent]<br> public struct BeatBack : IComponentData<br> {<!-- --><br>     public float velocity;<br>     public float curVelocity;<br>     public Rotation rotation;<br>     public float timer;<br> }</p> 
<p><br> BeatBackSystem ：</p> 
<p>using Unity.Entities;<br> using Unity.Jobs;<br> using Unity.Transforms;<br> using Unity.Mathematics;</p> 
<p>public class BeatBackSystem : SystemBase<br> {<!-- --><br>     protected override void OnUpdate()<br>     {<!-- --><br>         float deltaTime = Time.DeltaTime;<br>         Entities.<br>             ForEach((ref BeatBack beatBack,ref Translation translation ) =&gt;<br>         {<!-- --><br>             if (beatBack.velocity &lt;0.1f)<br>             {<!-- --><br>                 beatBack.velocity = 0;<br>                 beatBack.timer = 0;<br>                 beatBack.curVelocity = 0;<br>                 return;<br>             }<br>             float temp = beatBack.velocity;<br>             beatBack.timer += 2*deltaTime;</p> 
<p>            temp = math.lerp(beatBack.velocity, 0,beatBack.timer);<br>             if (temp &lt; 0.1f)<br>             {<!-- --><br>                 beatBack.velocity = 0;<br>             }<br>             beatBack.curVelocity = temp;<br>             translation.Value += beatBack.velocity * deltaTime * math.forward(beatBack.rotation.Value);<br>         }).Run();<br>     }<br> } </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/e8/S81x0z3D_o.gif"></p> 
<p>完整TriggerEventSystem代码如下：</p> 
<p>using Unity.Entities;<br> using Unity.Jobs;<br> using Unity.Transforms;<br> using Unity.Mathematics;<br> using Unity.Collections;<br> using Unity.Physics.Systems;<br> using Unity.Physics;<br> using Unity.Burst;</p> 
<p>[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]</p> 
<p>public class TriggerEventSystem : SystemBase<br> {<!-- --><br>     private BuildPhysicsWorld buildPhysicsWorld;<br>     private StepPhysicsWorld stepPhysicsWorld;<br>     EndSimulationEntityCommandBufferSystem endSimulationEcbSystem;</p> 
<p>    protected override void OnCreate()<br>     {<!-- --><br>         buildPhysicsWorld = World.GetOrCreateSystem&lt;BuildPhysicsWorld&gt;();<br>         stepPhysicsWorld = World.GetOrCreateSystem&lt;StepPhysicsWorld&gt;();<br>         endSimulationEcbSystem = World.GetOrCreateSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();<br>     }</p> 
<p>    protected override void OnUpdate()<br>     {<!-- --><br>         var ecb = endSimulationEcbSystem.CreateCommandBuffer();<br>         //传入两个bool值，用来判断是否播放被击中或者被击杀的音效<br>         NativeArray&lt;bool&gt; isbehit = new NativeArray&lt;bool&gt;(2, Allocator.TempJob);</p> 
<p>        TriggerJob triggerJob = new TriggerJob<br>         {<!-- --><br>             PhysicVelocityGroup = GetComponentDataFromEntity&lt;PhysicsVelocity&gt;(),<br>             EnemyGroup = GetComponentDataFromEntity&lt;Enemy&gt;(),<br>             BeatBackGroup = GetComponentDataFromEntity&lt;BeatBack&gt;(),<br>             RotationGroup = GetComponentDataFromEntity&lt;Rotation&gt;(),<br>             HpGroup = GetComponentDataFromEntity&lt;Hp&gt;(),<br>             BulletGroup = GetComponentDataFromEntity&lt;Bullet&gt;(),<br>             DeleteGroup = GetComponentDataFromEntity&lt;DeleteTag&gt;(),<br>             TranslationGroup = GetComponentDataFromEntity&lt;Translation&gt;(),<br>             ecb = ecb,<br>             PhysicsColliderGroup = GetComponentDataFromEntity&lt;PhysicsCollider&gt;(),<br>             CharacterGroup = GetComponentDataFromEntity&lt;Character&gt;(),<br>             boom = FPSGameManager.instance.boomEntity,<br>             isbehit = isbehit,</p> 
<p>        };<br>         Dependency = triggerJob.Schedule(stepPhysicsWorld.Simulation, ref buildPhysicsWorld.PhysicsWorld,this.Dependency );<br>         Dependency.Complete();</p> 
<p>        if (isbehit[0])<br>         {<!-- --><br>             isbehit[0] = false;<br>             FPSGameManager.instance.PlayBehit();<br>         }</p> 
<p>        if (isbehit[1])<br>         {<!-- --><br>             isbehit[1] = false;<br>             FPSGameManager.instance.PlayBoom();<br>         }<br>         isbehit.Dispose();<br>     }</p> 
<p>    [BurstCompile]<br>     private struct TriggerJob :ITriggerEventsJob<br>     {<!-- --><br>         public ComponentDataFromEntity&lt;PhysicsVelocity&gt; PhysicVelocityGroup;<br>         //初始化数据略</p> 
<p>        public void Execute(TriggerEvent triggerEvent)<br>         {<!-- --></p> 
<p>            if (EnemyGroup.HasComponent(triggerEvent.EntityA))<br>             {<!-- --><br>                 //敌人与主角碰撞效果<br>                 if (!BulletGroup.HasComponent(triggerEvent.EntityB) &amp;&amp; BeatBackGroup.HasComponent(triggerEvent.EntityB))<br>                 {<!-- --><br>                     #region 击退<br>                     BeatBack beatBack1 = BeatBackGroup[triggerEvent.EntityB];<br>                     if (beatBack1.curVelocity &gt; 0.1f)<br>                     {<!-- --><br>                         beatBack1.velocity += (5f - beatBack1.curVelocity) * 0.1f;<br>                     }<br>                     else<br>                     {<!-- --><br>                         beatBack1.velocity = 5f;<br>                     }<br>                     if (RotationGroup.HasComponent(triggerEvent.EntityB))<br>                     {<!-- --><br>                         Rotation rotation = RotationGroup[triggerEvent.EntityB];<br>                         beatBack1.rotation = rotation;<br>                     }<br>                     BeatBackGroup[triggerEvent.EntityB] = beatBack1;<br>                     #endregion<br>                     return;<br>                 }<br>                 isbehit[0] = true;</p> 
<p>                #region 删除子弹</p> 
<p>                float3 boomPos = float3.zero;<br>                 if (TranslationGroup.HasComponent(triggerEvent.EntityB))<br>                 {<!-- --><br>                     Translation temp = TranslationGroup[triggerEvent.EntityB];<br>                     boomPos = temp.Value;<br>                     temp.Value = new float3(0, 100, 0);<br>                     TranslationGroup[triggerEvent.EntityB] = temp;<br>                     if (DeleteGroup.HasComponent(triggerEvent.EntityB))<br>                     {<!-- --><br>                        DeleteTag temp1 = DeleteGroup[triggerEvent.EntityB];<br>                        temp1.lifeTime = 0f;<br>                         DeleteGroup[triggerEvent.EntityB] = temp1;<br>                     }<br>                 }<br>                 #endregion</p> 
<p>                #region 子弹击退敌人效果<br>                 //略<br>                 #endregion</p> 
<p>                #region 扣血并生成爆炸粒子实体<br>                 if (HpGroup.HasComponent(triggerEvent.EntityA))<br>                 {<!-- --><br>                     Hp hp = HpGroup[triggerEvent.EntityA];<br>                     hp.HpValue--;<br>                     HpGroup[triggerEvent.EntityA] = hp;<br>                     if (hp.HpValue == 0)<br>                     {<!-- --><br>                         //播放死亡音效<br>                         isbehit[1] = true;<br>                         Entity boomEntity = ecb.Instantiate(boom);<br>                         Translation translation = new Translation<br>                         {<!-- --><br>                             Value = boomPos<br>                         };<br>                         ecb.SetComponent(boomEntity, translation);<br>                     }<br>                 }<br>                 #endregion<br>             }</p> 
<p>            if (EnemyGroup.HasComponent(triggerEvent.EntityB))<br>            ｛<br>                //与A逻辑相同，略<br>             ｝</p> 
<p>        }<br>     }</p> 
<p>}</p> 
<h1 id="6%EF%BC%9A%E7%B2%92%E5%AD%90%E4%B8%8E%E9%9F%B3%E6%95%88">
<br> 6：粒子与音效</h1> 
<p>目前Particle System 也能正常的转换为Entity ,但和physic shape等组件一样，它们还并没有那么方便使用，所以这里采用了和子弹组件一样的策略，写了一个粒子生命周期的组件，在单独的系统去处理，也不过多赘述了。</p> 
<p>至于声音，没必要转换为实体，正常使用就好了~</p> 
<p>工程地址：</p> 
<p>https://github.com/ydwj/Unity-ECS-FpsGame</p> 
<p>ps：工程里面下的商店的免费素材有点大~</p> 
<p> </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>