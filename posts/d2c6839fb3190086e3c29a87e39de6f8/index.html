<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>《Neural Machine Translation: Challenges, Progress and Future》译文分享 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《Neural Machine Translation: Challenges, Progress and Future》译文分享</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p><mark>2020年 <strong>张家俊</strong> 和 <strong>宗成庆</strong> 神经机器翻译 超经典综述</mark></p> 
<p></p>
<div class="toc">
 <h3>神经机器翻译：挑战、进展与未来</h3>
 <ul>
<li><a href="#_5">摘要：</a></li>
<li><a href="#1_9">1.介绍</a></li>
<li><a href="#2_14">2.神经机器翻译</a></li>
<li>
<ul>
<li><a href="#21_15">2.1编解码器框架</a></li>
<li><a href="#22_Transformer_31">2.2 Transformer</a></li>
<li><a href="#3_44">3.具有挑战性的关键研究任务</a></li>
</ul>
  </li>
<li><a href="#4_54">4.文档级神经机器翻译</a></li>
<li><a href="#5__63">5 非自回归译码与双向推理</a></li>
<li>
<ul>
<li><a href="#51__65">5.1 非自回归译码</a></li>
<li><a href="#52__75">5.2 双向推理</a></li>
</ul>
  </li>
<li><a href="#6_87">6.低资源翻译</a></li>
<li>
<ul>
<li><a href="#61__90">6.1 多语言神经机器翻译</a></li>
<li><a href="#62__105">6.2 半监督神经机器翻译</a></li>
<li><a href="#63__114">6.3 无监督神经机器翻译</a></li>
</ul>
  </li>
<li><a href="#7_117">7.多模态神经机器翻译</a></li>
<li>
<ul>
<li><a href="#71__121">7.1 图文翻译</a></li>
<li><a href="#73__133">7.3 离线语音-文本翻译</a></li>
<li><a href="#74__144">7.4 同声机器翻译</a></li>
</ul>
  </li>
<li><a href="#8__148">8 讨论和今后的研究任务</a></li>
<li>
<ul>
<li><a href="#81_NMT_149">8.1 NMT对人类</a></li>
<li><a href="#82__151">8.2 今后的研究任务</a></li>
<li>
<ul>
<li><a href="#1_153">1.有效的文档级翻译和评估</a></li>
<li><a href="#2NMT_156">2.有效的NMT推理</a></li>
<li><a href="#3_158">3.充分利用多语种和单语种数据</a></li>
<li><a href="#4NMT_160">4.在NMT中更好地开发多模态</a></li>
<li><a href="#5NMT_162">5.带背景建模的NMT</a></li>
<li><a href="#6NMT_164">6.在NMT中引入先验知识</a></li>
<li><a href="#7_166">7.更好的领域自适应模型</a></li>
<li><a href="#8_170">8.弥合训练与推理之间的鸿沟</a></li>
<li><a href="#9NMT_172">9.设计可解释的鲁棒NMT</a></li>
<li><a href="#10NMT_174">10.新的NMT体系结构</a></li>
</ul>
  </li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<h1>
<a id="_5"></a>摘要：</h1> 
<p>机器翻译(MT)是一种利用计算机自动翻译人类语言的技术。目前，神经机器翻译(NMT)以深度神经网络建模源语与目标语之间的直接映射，在翻译性能上取得了重大突破，成为机器翻译的实际范式。本文回顾了NMT的框架，讨论了NMT面临的挑战，介绍了一些令人兴奋的最新进展，最后展望了一些潜在的未来研究趋势。此外，我们在网站https://github.com/znlp/sota-mt上维护各种NMT任务的最新方法。<br> 神经机器翻译，变换器，多模态翻译，低资源翻译，文档翻译</p> 
<h1>
<a id="1_9"></a>1.介绍</h1> 
<p>机器翻译(MT)的概念是由Warren Weaver[138]于1949年正式提出的，他认为使用现代计算机自动翻译人类语言是可能的。从那时起，机器翻译就成为自然语言处理和人工智能领域最具挑战性的课题之一。几代人中的许多重新搜索者致力于重新实现机器翻译的梦想。<br> 从方法学的角度来看，机器翻译的方法主要有两大类：基于规则的方法和数据驱动的方法。在2000年代以前，基于规则的方法占主导地位，更可取。在这种方法中，双语语言专家负责为源语分析、源语转换和目标语生成设计特定的规则。由于基于规则的系统是一个非常复杂和劳动密集型的系统，当规则不能覆盖那些看不见的语言现象时，它就很难扩展，而且很脆弱。相比之下，数据驱动的方法旨在学习如何从大量人工翻译的平行句对（平行语料库）中进行翻译。数据驱动方法的研究经历了三个时期。20世纪80年代中期，[93]提出了基于例句的机器翻译，通过检索人译句对中的相似例句来翻译句子。<br> 从20世纪90年代初开始，统计机器翻译(SMT)被提出，它可以使用概率模型从平行语料库中自动学习词或短语级别的翻译规则[16,27,70]。随着越来越多的平行语料库的出现，复杂的概率模型如噪声信道模型和对数线性模型取得了越来越好的翻译效果。许多公司（如谷歌、微软和百度）开发了在线SMT系统，使用户受益匪浅。然而，由于多个人工设计的组件如翻译模型、拉格朗日模型和重排序模型的复杂集成，SMT不能充分利用大规模的平行语料库，翻译质量也不尽如人意。10多年未实现突破直到深度学习引入MT。自2014年以来，基于深度神经网络（deep neural Networks）的神经机器翻译(NMT)迅速发展起来[8,45,116,122]。2016年，通过对各种语言对的广泛实验，[65，143]证明了NMT相比SMT有了很大的突破和显著的提高，甚至接近人类水平的翻译质量[55]。本文对NMT框架进行了回顾，讨论了NMT中一些具有挑战性的研究任务，指出了一些令人振奋的进展，并对未来的研究方向进行了展望。</p> 
<h1>
<a id="2_14"></a>2.神经机器翻译</h1> 
<h2>
<a id="21_15"></a>2.1编解码器框架</h2> 
<p>神经机器翻译是遵循编码器-解码器框架的端到端模型，通常包括两个神经网络，分别用于编码器和解码器 [8,45,116,122]。 如图 1 所示，编码器网络首先将源语言句子的每个输入标记映射为低维实值向量（也称为词嵌入），然后将向量序列编码为分布式语义表示，从 解码器网络通过token 1）从左到右生成目标语言句子token。</p> 
<p>从概率的角度来看，NMT 对目标语言句子 y =y0，···，yi，···，yI 的条件概率建模，给定源语言句子 x =x0，···，xj，··· , xJ 作为令牌级翻译概率的乘积。</p> 
<p><img src="https://images2.imgbox.com/02/70/x19BqdCL_o.png" alt="在这里插入图片描述"><br> 图 1 用于神经机器翻译的编码器-解码器框架。 这编码器将输入序列 x0 x1 x2 x3 x4 x5 编码为分布式语义表示，解码器在此基础上生成输出序列y0y1y2y3y4。<br> <img src="https://images2.imgbox.com/e4/57/6fIbzwYw_o.png" alt="在这里插入图片描述"><br> 其中 y&lt;i = y0, · · · , yi−1 是目前已经生成的部分平移。 x0, y0 和 xJ, yI 通常是特殊符号 &lt; s &gt; 和 &lt; /s &gt;，分别表示句子的开头和结尾。</p> 
<p>令牌级别的翻译概率可以定义如下：<br> <img src="https://images2.imgbox.com/cb/f3/32xxXULH_o.png" alt="在这里插入图片描述"><br> 其中 V 表示目标语言的词汇表，g(·) 是一个非线性函数，它根据输入 x 计算预测 yi 的实值分数，部分平移 y&lt; i &gt; 和模型参数 θ。 非线性函数g(·)是通过编码器和解码器网络实现的。 输入句子 x 通过多个编码器层被抽象为隐藏的语义表示 h。 Y&lt; i &gt;被总结为目标端历史上下文表示z，解码器网络进一步结合h和z，使用注意机制来预测yi的分数。<br> 可以优化网络参数 θ 以最大化双语训练数据上的对数似然。<br> <img src="https://images2.imgbox.com/36/ed/9BERTqBX_o.png" alt="在这里插入图片描述"><br> 这些年来见证了编码器-解码器网络的快速发展，从循环神经网络 [8, 116] 到卷积神经网络 [45]，再到基于自我注意的神经网络 Transformer [122]。 目前，Transformer 在质量和效率方面都是最先进的。</p> 
<h2>
<a id="22_Transformer_31"></a>2.2 Transformer</h2> 
<p><img src="https://images2.imgbox.com/f4/04/1wp1zUwa_o.png" alt="在这里插入图片描述"><br> 图 2 Transformer 架构，其中注意力机制是编码器和解码器网络的核心。 右移意味着上一个时间步的预测将作为输入上下文右移以预测下一个输出标记。</p> 
<p>在 Transformer 中，编码器包括 N 个相同的层，每层由两个子层组成：自注意力子层和前馈子层，如图 2 左侧所示。 self-attention 子层通过关注同一层中的所有邻居，计算该令牌与所有邻居之间的相关性得分，最后将所有邻居的表示结合起来，从而计算一个令牌的输出表示和它自己。第 N 个编码层的输出是源端语义表示 h。图 2 右侧所示的解码器也由 N 个相同的层组成。每层有三个子层。第一个是总结部分预测历史的掩码自注意力机制。第二个是编码器-解码器注意子层，确定当前预测的动态源端上下文，第三个是前馈子层。在编码器和解码器中为每个子层执行残差连接和层归一化。很容易注意到注意力机制是关键组件。注意力机制有编码器自注意力、解码器掩蔽自注意力和编码器-解码器注意力三种。它们可以形式化为相同的公式。<br> <img src="https://images2.imgbox.com/a2/9d/DhzjdwUa_o.png" alt="在这里插入图片描述"><br> 其中 q、K 和 V 分别代表查询、键列表和值列表。 dk 是键的维度。 对于编码器自注意，查询、键和值来自同一层。 例如，考虑我们在位置计算编码器中第一层的输出，设 xj 为输入令牌嵌入和位置嵌入的和向量。 查询是向量 xj 。 键和值相同，都是嵌入矩阵 x = [x0···xJ]。 然后，提出了多头注意力来计算不同子空间中的注意力。<br> <img src="https://images2.imgbox.com/ca/08/1WQ0WWKc_o.png" alt="在这里插入图片描述"><br> 其中 WiQ, WiK, WiV 和 WO 表示投影参数矩阵。<br> 使用公式 5，然后连接、层归一化和前馈网络，我们可以得到第二层的表示。 在 N 层之后，我们得到输入上下文 C = [h0,····,hJ]。<br> 解码器掩码自注意力与编码器相似，只是第 i 个位置的查询只能关注 i 之前的位置，因为第 i 个位置之后的预测在自回归 left-to- 中不可用。 正确的单向推理。<br> <img src="https://images2.imgbox.com/a7/42/5qENtK8w_o.png" alt="在这里插入图片描述"><br> 编码器-解码器注意机制是计算源端动态上下文，负责预测当前目标语言标记。 查询是掩码自注意力子层 zi 的输出。 键和值是相同的编码器上下文 C。然后应用住宅连接、层归一化和前馈子层以产生整个层的输出。 在 N 个这样的层之后，我们获得了最终的隐藏状态 zi。 然后使用 Softmax 函数来预测输出 yi，如图 2 的右上部分所示。</p> 
<h2>
<a id="3_44"></a>3.具有挑战性的关键研究任务</h2> 
<p>尽管Transformer极大地推动了神经机器翻译的发展，但仍有许多挑战有待解决。显然，设计更好的NMT框架一定是最重要的挑战。然而，自变压器技术革新以来，几乎没有提出更有效的NMT体系结构。[22]提出了一种可供选择的编解码器框架RNMT+，该框架综合了基于RNN和基于变压器的编解码器的优点来进行翻译。[129，150]研究了如何设计更深的变压器模型，[78]提出了一个改造器模型，使编码器和解码器之间能够进行丰富的交互。[141]试图用动态的回旋来代替自我注意。[112]提出了基于神经结构搜索的进化Trans-former。[83]旨在从多粒子动力学系统的角度研究变压器。请注意，这些模型不会对NMT体系结构带来很大的变化。追求设计新颖有效的NMT框架任重而道远。在这一节中，我们分析和讨论了NMT面临的主要挑战3）从它的制定。<br> 从SEC的介绍。2.1，NMT被形式化地定义为一个序列到序列的预测任务，其中默认隐藏了四个假设。首先，输入是一种感觉，而不是段落和文档。第二，以从左到右的自回归方式生成输出序列。第三，在Bilin-Gual训练数据上对NMT模型进行优化，该训练数据应包含大规模的平行句子，以学习良好的网络参数。第四，NMT的处理对象不是语音和视频，而是纯文本（代币、单词和句子）。同样，四个关键挑战可归纳如下：<br> 1.文档神经机器翻译。在NMT建模中，句子是建模的基本输入。然而，句子中的一些词是歧义的，意义只能通过周围的意义或段落的上下文来消歧。在翻译文档时，我们需要保证不同句子中相同的术语导致相同的翻译，而独立地逐句翻译是不能达到这一目的的。此外，许多语篇现象，如共指、缺语和连贯等，都不能在缺乏文献信息的情况下处理。在神经机器翻译中，如何充分利用句子以外的上下文是一个很大的挑战。<br> 2.非自回归译码和双向推断。一个令牌一个令牌地从左到右解码遵循一种看似自然的Au-toregressive风格[69，80，156]也讨论了各种挑战。它也很容易进行培训和推理。然而，它有几个缺点。一方面，解码效率非常有限，因为只有在所有先前的i-1预测已经生成之后才能预测第i个翻译令牌。另一方面，预测第i令牌只能访问先前的历史预判，而不能以自回归的方式利用未来的语境信息，导致翻译质量低下。因此，如何打破自回归推理的约束是一个挑战。从效率和质量的角度来看，非自回归译码和二次推理分别是两种解决方案。<br> 3.低资源翻译。世界上有数以千计的胡人语言，丰富的位元仅存在于英德、英法、英汉等少数几种语言对中。即使在资源丰富的语言对中，由于大多数位元主要存在于几个领域（如新闻和专利），并行数据也是不平衡的。也就是说，缺乏平行训练语料库在大多数语言和领域中都是非常普遍的。众所周知，对于高度重复的事件（NMT训练数据中频繁的词/短语转换对），神经网络参数可以很好地选择，而对于低资源的语言对，标准的NMT模型将很难学习。因此，如何充分利用其他语言的并行数据（基于枢轴的翻译和多语言翻译）和如何充分利用非并行数据（半监督翻译和无监督翻译）是NMT面临的两个挑战。<br> 4.多模态神经机器翻译。从直觉上看，人类的语言不仅仅是文本，理解一种语言的含义可能需要其他模态的帮助，如语音、图像和视频。关于在翻译句子“他去了银行”时决定词库意义的众所周知的例子，如果给我们一个形象，其中一个人正在接近一条河，它就会被正确地翻译。此外，在许多Scenar-IOS中，我们需要翻译演讲或视频。此外，在各种会议或国际现场活动中，同声传译越来越受到人们的重视。因此，如何在编解码器结构下进行多模态翻译是NMT的一大挑战。如何在多模态翻译中充分利用不同的模态，以及如何在同时进行的语音翻译中平衡质量和时延是两个具体的挑战。<br> 在以下几节中，我们将简要介绍每个挑战的最新进展。<br> <img src="https://images2.imgbox.com/3e/00/mabQc947_o.png" alt="在这里插入图片描述"><br> 图 3 说明了两个 docNMT 模型。 左侧部分显示了 [153] 提出的级联注意模型，其中首先利用先前的源语句来增强当前源语句的表示，然后在解码器中再次使用。 右侧部分说明了 [146] 提出的两遍 docNMT 模型，其中句子级 NMT fifirst 为每个句子生成初步翻译，然后使用 fifirst-pass 翻译与源端句子一起生成最终翻译结果 .</p> 
<h1>
<a id="4_54"></a>4.文档级神经机器翻译</h1> 
<p>就像我们在SEC讨论的那样。3独立地按句翻译会带来一些风险。一个歧义词如果没有周围的同文句中的必要信息，可能无法正确翻译。同一文件中不同句子中的同一术语可能导致翻译不一致。此外，许多语篇现象，如共指、省略、跨句关系等也不能得到很好的处理。总之，句子层次的翻译如果忽视了语篇之间的联系和语义之间的关系，就会损害译文的衔接和连贯。<br> 通常，文档级机器翻译(docMT)的目的是挖掘有用的文档级信息（围绕当前句子或整个文档的多个句子），以提高当前句子的翻译质量和翻译文档的连贯和衔接。在统计机器翻译(SMT)时代，docMT已经得到了广泛的研究，大多数研究者主要针对某些特定的语篇现象提出显式模型，如词汇衔接和一致性[46,144,145]、连贯[15]和共指[104]。由于SMT中多组件的复杂集成，这些建模方法并没有带来很大的改进。在分布式向量空间中处理语义和翻译的NMT模型方便了wider和编码器-解码器框架下的深度文档级信息。它不需要像在SMT中那样对特定的偏离现象进行显式建模。根据所使用文档信息的类型，文档级神经网络翻译可大致分为动态翻译记忆[71，120]、周围句子[61，90，125，128，146，148，153]和整个文档[87,88,117]。[120]提出了一种动态的类似高速缓存的存储器来维护先前翻译的单词的隐藏表示。存储器包含固定数目的单元，每个单元是三个单元(ct，st，yt)，其中yt是第t步的预测，ct是由关注模型计算的源侧上下文表示，st是对应的解码器状态。在推理过程中，当对测试句进行第i次预测时，首先通过注意模型得到ci，然后根据它们之间的相似性计算概率p（ctci）。然后，通过将所有值st与p（ctci）线性组合来计算内存上下文表示mi。这种类似于cache的记忆机制可以鼓励相似语境中的词共享相似的翻译，从而在一定程度上增强衔接。整个文档的使用与周围句子的使用最大的区别在于作为上下文的句子的数量。本文主要介绍了DOCNMT环境语句的开发方法。Rel-Evant实验进一步表明，右边的后续句子对CUR的翻译质量贡献很小。因此，最近的大部分工作都旨在充分探索前文句子，以增强DOCNMT。这些方法可以分为两类。一个只是利用前面的源端句子[61，119，128，153]。另一个使用以前的源句以及它们的tar-get翻译[90，146]。如果仅利用先前的源端语句，则先前的语句可以与当前的感知连接起来作为NMT模型的输入[119]或可以用分层神经网络[128]编码到汇总的源端上下文中。[153]提出了一种级联AT-tention模型，以充分利用已有的源感知。如图3的左侧部分所示，先前的感知首先被编码为文档级上下文表示。在对当前句子进行编码时，每个单词都将关注文档级上下文，并获得上下文增强的源表示。在计算跨语言注意的过程中，译码器利用当前源语句和文档级上下文来预测目标词。在给定当前句子和先前上下文句子的情况下，转换句的概率表述如下：<br> <img src="https://images2.imgbox.com/53/35/fo5Wj8YL_o.png" alt="在这里插入图片描述"><br> 其中 docx 表示源端文档级上下文，即前面的句子。<br> 如果同时使用先前的源语句及其翻译，则两遍解码更适合 docNMT 模型 [146]。 如图 3 右侧所示，句子级 NMT 模型可以在首遍解码中为每个句子生成初步翻译。 然后，第二遍模型将在源句及其初步翻译结果的帮助下产生最终翻译。 第二遍中目标句子的概率可以写为<br> <img src="https://images2.imgbox.com/29/63/irWBgOem_o.png" alt="在这里插入图片描述"><br> 其中docy表示docx的第一遍翻译。<br> 由于 docNMT 的大多数方法旨在提高整体翻译质量（例如 BLEU 分数），因此这些方法是否确实能够很好地处理语篇现象仍然是一个大问题。 为了解决这个问题，[10] 对 docNMT 模型对处理各种话语现象的性能进行了实证研究，例如共指、凝聚力和连贯性。 他们的研究结果表明，仅探索源端先前句子的多编码器模型在处理语篇现象方面表现不佳，而同时利用源句子和目标翻译导致最佳性能。 因此，[123, 124] 最近专注于设计更好的文档级 NMT，以改进特定的话语现象，例如英语-俄语翻译的指示语、省略号和词汇衔接。</p> 
<h1>
<a id="5__63"></a>5 非自回归译码与双向推理</h1> 
<p>大多数NMT模型遵循自回归生成风格，即从左到右逐字生成输出。就像SEC一样。3讨论，这个范例必须等待I-1个时间步骤，然后才开始预测第i个目标词。此外，从左到右的自回归解码不能利用目标端的未来上下文（第i个单词后的未来预测）。近年来，许多研究工作试图打破这种解释范式。提出了非自回归转换器(NAT)[49],通过同时发出所有目标词来显著降低时延；引入双向推理[161,172],通过充分利用历史和未来语境来提高翻译质量。</p> 
<h2>
<a id="51__65"></a>5.1 非自回归译码</h2> 
<p>非自回归变压器(NAT)的目标是并行地产生整个目标输出。与Autore-gressive Transformer模型(AT)在发出句末令牌（/s）时终止解码不同，NAT在并行解码之前必须知道应该生成多少目标词。因此，NAT计算给定源句子x的翻译y的condi-tional概率如下：<br> <img src="https://images2.imgbox.com/7c/26/LmlETAmo_o.png" alt="在这里插入图片描述"><br> （J=0）（.）来确定输出长度，[49]提出使用生育率模型来预测每个源词应该翻译的目标词的数量。我们可以在双语训练数据上进行按形式的词对齐，以获得每个句子对的黄金受精。然后，生育率模型可以与翻译模型一起训练。对于每个源词xj，假设预测生育率为Φ(xj)，输出长度为I=jΦ(xj)。<br> 另一个问题仍然是，AT让先前产生的输出YI-1是下一个时间步的输入，以预测第i个目标字，但NAT在解码器网络中没有这样的输入。[49]发现翻译质量特别差，如果省略 NAT 中的解码器输入。 为了解决这个问题，他们再次求助于生育力模型，并将每个源词复制到其生育力 Φ(xj) 的次数到解码器输入中。 经验实验表明，与 AT 相比，NAT 可以将解码效率显着提高 15 倍。 然而，NAT 的准确性严重下降。<br> <img src="https://images2.imgbox.com/ae/d4/SpYVBZ0F_o.png" alt="在这里插入图片描述"><br> 图 4 自回归 NMT 模型和各种非自回归 NMT 模型的图示。AT 表示传统的自回归 NMT 范式，其中第 i 个预测可以充分利用 i-1 个单词的部分翻译。 NAT 表示同时生成所有目标词的非自回归 NMT 模型。 SAT 是 NAT 的一种变体，它每次都会产生一个 ngram。 NAT-EDI 表示具有增强解码器输入的非自回归 NMT 模型，它是通过检索短语表生成的。<br> 翻译质量低可能是由于NAT的至少两个关键问题。首先，尽管在自然语言生成中词的依赖是普遍存在的，但tar-get词之间并不存在依赖关系。其次，译码器的输入是复制的源词，这些源词与目标词位于不同的语义空间。近年来，针对原有NAT模型的不足，人们提出了几种方法来提高NAT的翻译质量，同时保持NAT的效率[54,75,110,127,137,139]。<br> [127]提出了一种半自回归变压器模型(SAT)来结合AT和NAT的优点。SAT在global中保留自回归属性，但在LO-CAL中执行NAT。如图4所示，SAT在每个时间步并行地生成K个连续的tar-get字。如果K=1，则SAT正好在。如果K=i，则会变成NAT。通过选择一个AP专有的K，可以很好地建模片段间的依赖关系，在降低效率的情况下提高翻译质量。<br> 为了模拟AT模型中的译码器输入，[54]介绍了一种简单而有效的方法，即利用SMT中的核心部件短语表将源词转换为目标词。具体地说，他们首先贪婪地将源句组合成匹配度最大的短语算法。假设短语表中最长的短语包含K个单词。x0:k-1是一个短语，如果它匹配短语表中的一个条目。否则，它们迭代地检查x0:k-2、x0:k-3，以此类推。如果x0:h是一个短语，那么他们开始检查xh+1:h+k。在分割之后，每个源短语被映射成目标翻译，这些翻译被串联在一起作为新的解码器输入，如图4所示。由于译码器输入采用了一种高效的模型化策略，在译码速度比基线NAT更快的同时，译码质量得到了显著提高。</p> 
<h2>
<a id="52__75"></a>5.2 双向推理</h2> 
<p>从提高翻译质量的角度出发，可以通过探索未来的右侧文本来加强自动递进模式。除了用各种模型预测和估计未来的上下文[151,169,171]，再搜索者发现从左到右(L2R)和从右到左(R2L)的自回归模型可以产生互补的翻译[57,79,161,172]。例如，在汉译英中，实验表明L2R能产生更好的前缀，而R2L擅长产生后缀。从直观上看，结合双向推理的优点，充分利用目标方的历史和未来背景，是一个很有前途的方向。<br> 为了达到这个目的，许多研究者都在探索二语译码，以充分利用L2R和R2L推理的优势。这些方法主要有四个方面:1、提高L2R和R2L预测的一致性[79,164]；2,用双向de重新路由编码[79,106,107]；3、异步双向解码和4、同步双向译码。<br> <img src="https://images2.imgbox.com/6f/ff/72c132QJ_o.png" alt="在这里插入图片描述"><br> 理想情况下，L2R译码应该产生与R2L译码相同的翻译。在这个合理的假设下，[79，164]在训练过程中引入了L2R和R2L预测之间的一致性约束或正则化。然后，可以改进L2R推理。<br> R2L模型可以从另一个参数空间为L2R翻译质量提供一个估计分数[79,106,107]。具体来说，L2R首先生成一个N最佳翻译列表。然后利用R2L模型来强制对每个翻译进行解编码，从而得到一个新的分数。最后根据新的分数选出最佳译文。<br> [115, 161] 提出了一种异步双向解码模型 (ASBD)，该模型首先获得 R2L 输出，并基于源输入和 R2L 输出优化 L2R 推理模型。 具体来说，[161] 首先用双语训练数据训练了一个 R2L 模型。 然后，<br> 优化的 R2L 解码器翻译每个句子对的源输入并产生输出（隐藏状态），这些输出在优化 L2R 推理模型时用作 L2R 预测的附加上下文。 由于明确使用右侧未来上下文，ASBD 模型显着提高了翻译质量。 但是这些方法仍然存在两个问题。 一方面，他们必须分别为 L2R 和 R2L 推理训练两个独立的 NMT 模型。 并且两遍解码策略使得延迟大大增加。 另一方面，两个模型在推理过程中不能相互交互，这限制了性能提升的潜力。<br> [172] 提出了一种同步双向解码模型（SBD），该模型同时交互地使用 L2R 和 R2L 解码产生输出。 具体来说，提出了一种新的同步注意力模型来进行 L2R 和 R2L 推理之间的交互。 图 5 的顶部给出了所提出的同步双向推理模型的简单说明。 目标侧的彩色虚线箭头是 SBD 模型的核心。 推理中的 L2R 和 R2L 以虚线箭头所示的隐式方式相互交互。 所有箭头表示信息传递流程。 实线箭头显示了传统的历史上下文依赖性，而虚线箭头介绍了未来上下文对另一个推理方向的依赖性。 例如，除了过去的预测外，翻译的条件概率可以写成如下：<br> <img src="https://images2.imgbox.com/93/ce/4rPhDFpV_o.png" alt="在这里插入图片描述"><br> 为了同时适应 L2R 和 R2L 推理，他们引入了一种新颖的波束搜索算法。 如图 5 的右下角所示，在解码期间的每个时间步长，每个半波束分别保持 L2R 和 R2L 解码的假设，并且每个假设都是通过利用来自两个方向的已预测输出来生成的。 最后，根据翻译概率从 L2R 和 R2L 结果中选择最终翻译。<br> 得益于适当的丰富交互，SBD 模型大幅提升了翻译质量，而解码速度仅降低了 10%。 [173] 进一步注意到 L2R 和 R2L 并不是产生整个翻译句子所必需的。 他们让 L2R 产生左半边翻译，让 R2L 产生右半边，然后将两半拼接起来形成最终的翻译。 他们使用适当的训练算法，通过广泛的实验证明，与基线 Transformer 模型相比，翻译质量和解码效率都可以显着提高。</p> 
<h1>
<a id="6_87"></a>6.低资源翻译</h1> 
<p>大多数NMT模型都假设有足够的双语训练数据，这在现实生活中是罕见的。对于一个低资源的语言对，一个自然的问题可能会出现，什么样的知识可以转移，以建立一个较好的NMT系统。本节将讨论三种方法。一种是试图从其他资源丰富的语言对中分享翻译知识，其中枢轴翻译和多语言翻译是两个关键技术。枢轴转换假设对于低资源对A和B，存在一种语言C，它分别具有与A和B的丰富位元[26,142]。本节主要讨论第一类中的多语言翻译技巧。第二类方法采用半监督的训练方法，充分利用了有限的双语训练数据和丰富的单语训练数据。最后一种是只需要单语数据的Lever-Ages无监督算法。</p> 
<h2>
<a id="61__90"></a>6.1 多语言神经机器翻译</h2> 
<p>让我们首先简单回顾一下基于编解码器框架的NMT模型。编码器负责将源语言语句映射成分布式的Se-Mantic表示。译码器是将源端分布的语义表示转换为目标语言句子。显然，编码器和解码器（排除跨语言注意成分）只是单语言依赖的。直观地说，同一源语言在不同的翻译系统中（如汉译英、汉译印地语）可以共用同一个编码器，同一目标语言可以共用同一个译码器（如汉译英、印地语译英）。多语言神经网络翻译是一个框架，旨在通过参数共享和知识转移建立一个能够翻译多种语言的统一的神经网络模型。<br> [36]是第一个设计了一个多任务学习方法，共享同一个编码器用于一对多翻译（一种源语言转换为多种目标语言）。[176]提出了共享译码器的多对一翻译（多个源语言到一个目标语言）。[43,44]提出了多对多翻译（多源语言转换为多目标语言）的注意共享机制。尽管低资源语言的性能有所提高，但这些方法需要为每种语言设计特定的编码器或解码器，这阻碍了它们在处理多种语言时的可伸缩性。<br> [64]更进一步，让所有源语言共享同一个编码器，所有目标语言共享同一个解码器。他们成功地训练了一个用于多语言翻译的单一编码器-解码器NMT模型。最大的问题是解码器不知道在测试阶段应该翻译成哪种目标语言。为此，[64]引入了一个简单的策略，在源句的开头添加了一个特殊的标记（如2en和2zh)。通过这样做，低资源语言有最大的机会从其他资源丰富的语言分享翻译知识。只要在多语言NMT模型中使用两种语言作为源和目标，它还可以实现零镜头转换。此外，这个统一的多语言NMT具有很好的可伸缩性，理想情况下可以在一个模型中跨延所有语言。然而，前人发现，即使使用翻译方向指示器，输出的语言有时也是多种语言的混合。此外，这一范式强制不同的源/目的语言共享相同的语义空间，而不考虑不同语言之间的结构差异。其结果是，与单独训练的双语翻译相比，基于单一模型的多语言NMT产生了较差的翻译性能。目前的研究工作主要集中在设计更好的模型，以平衡与语言无关的参数共享和语言敏感的模块设计。<br> [13]用特定于语言的信号增强了译码器中的注意机制。[134]提出使用语言敏感位置和语言依赖的隐藏表示来进行一对多翻译。[98]设计了生成语言特定参数的算法。[118]设计了一种语言聚类方法，并强制同一聚类中的语言共享同一语义空间中的参数。<br> [135]试图通过共享编码器参数来同时交互地生成两种语言。[136]提出了一个简洁的语言敏感的多语言翻译模型，该模型试图在保持语言区分的同时共享大部分参数。<br> 如图6所示，[136]与基于单模型的多语言NMT相比，在Transformer框架中设计了四个新的模块。首先，他们引入了一个表征来重新通过共享自关注块、前馈块和归一化块的权重参数来放置编码器和解码器两者（图6中的中间部分）。它使多语言NMT模型尽可能紧凑，并最大限度地实现了不同语言之间的知识共享。<br> <img src="https://images2.imgbox.com/da/25/rovgPh6P_o.png" alt="在这里插入图片描述"><br> 图 6 说明了一个紧凑且对语言敏感的多语言 NMT 模型。 通过在编码器和解码器之间共享参数（表示为表示器）来确保紧凑性。 语言敏感容量由三个组件实现：语言敏感嵌入（底部）、语言敏感交叉注意力（中）和语言鉴别器（顶部）。<br> 然而，代表人进一步降低了区分不同语言的能力。为了解决这个问题，他们引入了三个语言敏感模块。<br> 1.语言敏感嵌入（图6中的底部部分）：他们比较了四类嵌入共享模式，即基于语言的模式（不同的语言有各自的输入嵌入）、基于方向的模式（源端和目标端的语言有不同的输入嵌入）、基于表示的模式（所有语言共享的输入嵌入）和[101]提出的三向权重绑定模式，其中目标端的输出嵌入是<br> 也共享除了基于表示的共享。<br> 2.语言敏感注意（图6中）：这种机制允许模型选择跨语言的注意参数根据具体的翻译任务动态地进行。<br> <img src="https://images2.imgbox.com/6b/83/ZF1oTUHh_o.png" alt="在这里插入图片描述"><br> 将上述四个想法结合在一起，他们通过大量实验表明，新方法在一对多、多对多和零样本场景下显着提高了多语言 NMT，在大多数情况下优于双语对应方法。 这表明低资源语言翻译可以极大地受益于这种多语言 NMT，零资源语言翻译也是如此。</p> 
<h2>
<a id="62__105"></a>6.2 半监督神经机器翻译</h2> 
<p>单语数据在SMT中扮演着非常重要的角色，目标方的单语语料库被用来训练语言模型(LM)来衡量译码过程中候选译文的流畅性[27,68,70]。在NMT中使用Monolin-Gual数据作为语言模型并不简单，因为它需要修改NMT模型的体系结构。[52,53]通过将NMT和LM模型的隐状态结合起来，使模型变得更加复杂。<br> 对于利用目标方的单语数据，文献[108]提出的反向翻译(BT)可能是目前最好的解决方案之一。BT易于使用，因为它对NMT框架是模型无关的[38，58]。它只需要训练一个目标到源的翻译系统，将目标方的单语句子转换回源语。将源译文及其对应的tar-get语句作为伪比特配对，并与原始双语训练数据相结合，对源-目标NMT系统进行训练。它已被证明在低资源翻译中特别有用[66]。[38]进行了深入的分析，以理解BT，研究合成源句生成的各种方法。[131]提出了对合成双语句子的置信度进行度量，以滤除噪声。<br> 为了利用源端的单语数据，[157]提出了两种方法：正向翻译和多任务学习。正向翻译类似于BT，多任务学习方法执行源对目标翻译任务和源语句通过共享相同的编码器重新排序任务。<br> 许多研究者在NMT中同时使用了双方的单语数据[25,56,163,170]。我们在图7中总结了两种方法：基于自动编码器的半监督学习方法[25]和对偶学习方法[56]。对于源方单语句子x，[25]使用源到目标翻译作为编码器来生成潜在变量y，并利用目标到源翻译作为解码器来重建导致XJ的输入。它们通过最大化重建概率来优化参数，如图7(a)所示。目标侧单语数据以对称方式使用。图7(b)示出了用于对偶学习方法的目标函数。[56]把源语对目标语的翻译作为首要任务，把目标语对源语的翻译作为双重任务。Agent A通过原始任务向Agent发送源单语句子的翻译<br> B.B负责用语言模型和双重任务来评估译文的质量。利用输入值x与重构值xj的相似度以及两个语言模型的得分LM(y)和LM(xj)来优化源到目标和目标到源NMT模型的网络参数。同样，目标侧单语数据在对偶学习中以对称的方式使用。<br> [163]提出了一种迭代反译算法，利用EM优化方法同时利用源和目标单语数据。[170]提出了镜像生成的NMT模型，通过统一源到目标的NMT模型、目标到源的NMT模型和两种语言模型来探索单语数据。与反译、ITER反译和双重学习相比，它们可以获得更好的效果。<br> <img src="https://images2.imgbox.com/39/40/VvL9dgir_o.png" alt="在这里插入图片描述"><br> 图 7 说明了探索单语数据的两种方法。 如果训练参数以最大化（a）的目标函数，则它是基于自动编码器的方法。 如果使用如（b）所示的奖励，它是对偶学习方法。 请注意，为简单起见，此图仅演示了源端单语数据的使用。 目标端单语数据的使用是对称的。</p> 
<h2>
<a id="63__114"></a>6.3 无监督神经机器翻译</h2> 
<p>无监督神经机器翻译解决了一个非常具有挑战性的场景，在这个场景中，我们需要仅使用大量源端单语来构建NMT模型数据Dx={x(lx)}lx和目标侧单语数据无监督机器翻译可以追溯到在SMT中，使用破译方法从单语数据中学习单词翻译[37,96,102]或从单语数据中提取双语短语对并估计其概率[67,155]。<br> 自从[91]发现通过一些种子翻译对可以映射两个词的词嵌入以来，双语词嵌入学习或双语词典导入受到了越来越多的关注[4,21,31,41,158，159][4]和[31]应用线性嵌入映射和对抗性训练来学习分布层中的词对匹配，并对相似语言实现了有希望的准确性。双语词典归纳法极大地推动了句子层面上无监督NMT的研究。其中去噪、自动编码器和回译两项技术使无监督NMT成为可能。其关键思想是在两种语言之间找到一个共同的潜在空间。[5]和[72]都优化了源对目标和目标对源翻译的双重任务。[5]使用共享编码器将两种语言强迫到同一个语义空间，并使用两种依赖于语言的解码器。相反，[72]确保两种语言共享相同的编码器和解码器，依赖于标识符来指示类似于基于单模型的多语言NMT[64]的特定语言。体系结构和训练目标函数如图8所示。图8中的顶部显示了去噪自动编码器的使用。编码器将输入x的噪声版本编码为HID-DEN表示zsrc，用于与解码器重建输入。重构xj和输入x之间的距离（自动编码器损耗Lauto）应尽可能小。为了保证源语言和目标语言共享相同的语义空间，引入了对抗性损失Ladv来欺骗语言标识符。图8中的底部示出了反平移的使用。目标句y首先使用旧的target-to-source NMT模型（上一次迭代优化的模型，初始模型是基于双语词归纳的逐词翻译模型）。 然后，翻译 x∗ 的噪声版本被编码为 zsrc，然后被翻译回目标句子 y0。 新的 NMT 模型（编码器和解码器）经过优化以最小化翻译损失 Ltrans，即翻译 y0 和原始目标输入 y 之间的距离。 类似地，在编码器模块中采用了对抗性损失。 这个过程迭代直到算法收敛。 最后，编码器和解码器可用于执行双重翻译任务。</p> 
<h1>
<a id="7_117"></a>7.多模态神经机器翻译</h1> 
<p>我们知道，人类在一个多模式的环境中相互交流，在这个环境中，我们可以看到、听到、闻到等等。自然，借助文本、语音和图像来执行机器翻译是理想的。不幸的是，包含平行文本、语音和图像的视频语料库<br> 因为机器翻译目前还没有公开可用。最近，IWSLT-20204)组织了第一次关于VE-DIO翻译的评估，其中注释视频数据仅用于验证和测试集。<br> 近年来，图文配对翻译、离线语音对文本翻译和同声传译越来越流行。</p> 
<h2>
<a id="71__121"></a>7.1 图文翻译</h2> 
<p>以图像及其文本描述为源语言，图像-文本翻译的任务是将源语言中的文字翻译成目标语言，翻译过程可以由图像配对信息来支持。它是一项需要语言处理和计算机视觉相结合的任务。WMT5)在2016年完成了第一个图像-文本翻译（他们称之为多模态翻译）的评估任务，并发布了广泛使用的数据集Multi30K，每个数据集都有一个英文描述和德语、法语和捷克语的翻译，此后提出了几种有效的方法，这些方法主要是在图像信息的使用上有所不同，本节主要讨论其中的四种。<br> [59]提出了利用卷积神经网络将图像编码为一个分布式向量表示或一系列向量表示的方法。然后，他们将向量表示与句子一起填充，作为NMT模型的最终输入，该模型不需要修改以适应。其核心思想是他们在模型设计中没有区分图像和文本。<br> <img src="https://images2.imgbox.com/14/cf/e4OMTE1L_o.png" alt="在这里插入图片描述"><br> 图 9 双注意力模型和图像想象模型在图文翻译中的对比。 在双重注意力模型中，图像被编码为额外的输入特征。 而在图像想象模型中，图像是从源语句中解码输出的。<br> [19]提出了一种用于图像-文本翻译任务的双重注意解码器。与[59]的主要区别在于，他们分别设计了文本编码器和视觉编码器，并采用两个独立的注意模型来平衡预测过程中文本和图像的相互影响。<br> [39]提出了一种多任务学习框架，用于每形式的图像-文本翻译。他们相信，只要有源语言的句子，人们就可以对图像进行记忆。基于这个假设，他们在一个多任务学习框架中使用了一个编码器和两个解码器。编码器首先将源语句编码成分布式语义表示。一个解码器从源方表示产生目标语言句子。需要另一个解码器来重建给定的图像。很容易看出，这些图像只在训练阶段使用，而在测试过程中不需要。从这个角度来看，多任务学习框架可以适用于更实际的场景。<br> [20]进一步提出了图文翻译的潜变量模型。与以往的方法不同的是，它们建立了一个生成模型，其中一个潜在变量负责生成源语言和目标语言的语义以及图像。<br> （M=1）图9示出了双注意模型与图像想象模型之间的比较，假设配对训练数据为D={(x(m)，y(m)，IM(m))}m，其中IM表示图像，双注意模型的目标函数可表述如下：<br> <img src="https://images2.imgbox.com/89/eb/2e15VjaL_o.png" alt="在这里插入图片描述"><br> 以上方法均被证明能显著提高翻译质量。但图像何时以及如何帮助文本翻译仍然是一个自然的问题。[18]在翻译vi-sual和非视觉术语时进行了详细的错误分析。他们发现，在使用图像作为附加语境后，几乎所有类型的翻译错误（不仅是视觉联系强的术语）都有所减少。<br> 另外，[17]试图回答图文翻译中何时需要视觉信息。他们设计了一种输入降级方法来掩盖源句子中的关键信息（如掩盖颜色词或实体），以观察配对图像是否能弥补翻译过程中丢失的信息。他们发现，当图像的视觉信息对文本情态是互补的而不是多余的时，它是有帮助的。</p> 
<h2>
<a id="73__133"></a>7.3 离线语音-文本翻译</h2> 
<p>语音到文本翻译，简称语音翻译(ST)是将原语（如英语）中的语音自动转换为目标语（如汉语）中的文本的任务。离线语音翻译指的是在我们开始翻译之前给出完整的语音（如一个句子或一段时间内的片断）。通常，ST由两个级联组件完成。首先使用自动语音识别(ASR)系统将源语言转录成源语言文本。然后，用神经机器翻译系统将转录文本翻译成目标语言文本。在实际应用中，它仍然是ST的主流方法。在这种范式中，ASR和NMT不耦合，可以直接优化。<br> 然而，管道方法有两个缺点。一方面，错误通过管道传播，在翻译过程中ASR错误难以弥补。另一方面，由于采用两相工艺，效率有限。[175]早年相信，随着技术、计算能力和表达模型的发展，端到端的语音翻译是可能的。基于分布式表示的深度学习为语音翻译的端到端建模提供了便利。[12]提出了一种在编码器-解码器框架下不使用任何源语言脚本的端到端模型。与流水线范式不同，端到端模型应该在由实例（源语音、目标文本）组成的训练数据上进行优化。我们在表中列出了一些最近使用的数据集。1,包括IWSLT7)、Aughended Librispeech8)、Fisher and Callhome9)、MuST-C10)和TED-Corpus11)。<br> 从表中很容易发现，端到端ST的训练数据比ASR和MT少得多。因此，目前的研究主要集中在充分利用ASR和NMT的数据或模型来提高ST的性能。多任务学习[2,11,140]，知识提炼<br> [63,81]和预训练[9,126]是三个主要的研究方向。<br> 在多任务学习框架中，ST模型与ASR和MT模型联合训练。由于ASR和MT模型是在大量训练数据上进行优化的，所以通过与ASR模型共享编码器，与MT模型共享解码器，可以大大改善ST模型。<br> [140]表明在多任务学习下可以取得很大的改进。而[11]则证明了多任务学习除了能提高翻译质量外，还能加快收敛速度。<br> 与多任务学习框架相比，该预训练方法首先对ASR模型或MT模型进行预训练，然后利用ASR的编码器或MT的解码器直接初始化ST模型的组成部分。<br> [9]尝试用ASR数据对ST模型进行预训练，以促进声学模型的发展，并表明在一种语言上对语音编码器进行预训练可以促进翻译<br> <img src="https://images2.imgbox.com/88/09/oL9VJEpr_o.png" alt="在这里插入图片描述"><br> 图 10 ST 的知识蒸馏模型示意图。 右边是一个MT模型，是一个老师。 左边是ST模型，是student。 ST 模型的输入是原始语音，MT 模型的输入是语音的转录。 顶部的蒸馏损失使学生模型从教师模型中学习输出概率分布（模仿教师的行为）。</p> 
<h2>
<a id="74__144"></a>7.4 同声机器翻译</h2> 
<p>同声机器翻译(SimMT)的目的是在源语说话者说话的同时进行翻译。它解决了在接收源语语音的同时，需要逐步地进行翻译的问题。这项技术对现场活动和实时视频通话翻译非常有帮助。近日，百度和脸书分别在ACL-202012)和IWSLT-202013)上组织了关于SimMT的首次评测任务。<br> <img src="https://images2.imgbox.com/84/07/mCWKS2Eb_o.png" alt="在这里插入图片描述"><br> 图 12 说明了同时机器翻译的三种策略。 顶部是传统的序列到序列 MT 模型，它在看到整个源语句后开始翻译。 中间的一个演示了在翻译前等待 k 个单词的 wait-k 策略。 底部显示了在每个时间步预测输出令牌的自适应策略的示例。 如果输出是一个特殊的记号 h εi ，则表示再读一个源词。</p> 
<h1>
<a id="8__148"></a>8 讨论和今后的研究任务</h1> 
<h2>
<a id="81_NMT_149"></a>8.1 NMT对人类</h2> 
<p>从第4-7节可以看出，神经机器翻译已经取得了很大的进展。当然，我们可能会怀疑当前强大的NMT系统是否能与人类翻译器媲美或更好。2018年，[55]报道了令人兴奋的消息，他们在汉英新闻翻译上实现了人机对等，他们发现他们的机器翻译输出和专业的人工翻译之间的人工评分没有显著差异。此外，[99]提交给WMT 2018的最佳英捷翻译系统也被发现性能明显优于人工生成的参考翻译[14]。令人鼓舞的是，NMT在某些特定的场景下可以实现非常好的翻译，似乎NMT已经达到了人类水平的翻译质量。然而，我们不能过于乐观，因为机器翻译技术远不能令人满意。一方面，在有大量平行语料库的情况下，只在特定的语言对上进行新闻领域的比较。目前，NMT在许多领域和对域上的性能都很差，尤其是在低资源的情况下，如中印地语翻译。另一方面，[55]提出的人机对等评估的评估方法，如[73]所指出的，应进一步改进。根据[73]的综合调查，如果使用更好的评分技术，如选择专业译者作为评分者，评价文档而不是单个句子，利用原文而不是译入语的原文，人工翻译比机器翻译更受欢迎。目前的NMT系统仍然存在着严重的误译词或命名实体、省略和语序错误等翻译问题。显然，NMT还有很大的改进空间，我们在下一节提出了一些潜在的研究方向。</p> 
<h2>
<a id="82__151"></a>8.2 今后的研究任务</h2> 
<p>在这一节中，我们讨论了神经机器翻译的一些潜在的研究方向。</p> 
<h3>
<a id="1_153"></a>1.有效的文档级翻译和评估</h3> 
<p>文献翻译的重要性是众所周知的，而目前的研究成果并不是很好。目前还不清楚所需文档上下文的最佳范围是什么<br> 翻译一个句子。从第一句到最后句的翻译是否合理仍然是一个问题。基于句群的翻译可能是一个值得研究的课题，它是多对多翻译的模型。另外，文档级评估与文档级MT方法同样重要，是MT技术的助推器。[55]认为，在具体的新闻测试中，如果用感觉来评价句子，机器翻译就可以在汉英翻译中实现人的对等。然而，正如我们在前一节中讨论的那样，[73，74]表明，当在文档级别而不是句子级别上进行评估时，更倾向于人类而不是机器翻译。因此，除了BLEU[97]之外，如何自动评价文档翻译质量仍然是一个悬而未决的问题，尽管一些研究者引入了几个测试集来研究某些特定的语篇现象[92]。</p> 
<h3>
<a id="2NMT_156"></a>2.有效的NMT推理</h3> 
<p>人们更喜欢既有高精度又有实际应用价值的模型。尽管有显著的加速，但在大多数情况下，非回归NMT引起的质量下降是不可容忍的。改进繁殖力模型、译码器输入的词序和输出的依赖关系，使NAT在翻译质量上接近AT是值得研究的问题。同步双向译码由于对历史和未来环境的良好建模，值得深入研究。此外，一些研究人员开始设计自由阶[40，50，114]的解码algo-rithm,这可能是研究人类语言生成本质的一个很好的方法。</p> 
<h3>
<a id="3_158"></a>3.充分利用多语种和单语种数据</h3> 
<p>由于大多数自然语言缺乏丰富的双语数据，低资源翻译一直是研究的热点。多语言NMT的潜力还没有被充分发掘，一些问题仍然悬而未决。对于多语言NMT中普遍存在的数据不平衡问题，如何处理？如何建立一个良好的增量式多语言NMT模型，以适应新的网络环境？半监督NMT在实际应用中更实用，但有效的反译算法非常耗时。因此，需要设计一个高效的半监督NMT模型，以便于部署。基于NMT的深度光栅预训练方法对半监督或无监督学习框架有很好的改进作用，[62，174]已经显示出一些很好的改进。无监督机器翻译在相似语言对（如英德、英法）中的研究成果使我们非常乐观。然而，[76]表明，无监督MT在距离较远的语言对上表现不佳，大多数情况下获得的BLEU分数不超过10分。然而，设计更好的无监督MT具有挑战性</p> 
<h3>
<a id="4NMT_160"></a>4.在NMT中更好地开发多模态</h3> 
<p>在多模态神经机器翻译中，何时以及如何充分利用不同的模态仍然是一个悬而未决的问题。图文翻译只能翻译即时消息字幕，难以在实际应用中得到广泛应用。寻找翻译过程中意象不可分的恰当情景是一个很好的研究课题。在语音转换方面，尽管端到端框架有了很大的改进，但在许多情况下，尤其是在训练数据有限的情况下，端到端框架仍然不能与级联方法媲美[82]。除了扩大训练数据外，弥合ST、ASR和MT不同语义空间之间的差距是进一步探索的方向。至于同声传译，目前还处于研究的初级阶段，许多实际问题，如重复和纠正，都没有得到解决。此外，将摘要与翻译相结合可能是一个很好的研究方向，它能以低延迟的方式为听众提供演讲者的演讲要旨。</p> 
<h3>
<a id="5NMT_162"></a>5.带背景建模的NMT</h3> 
<p>在许多情况下，机器翻译不是文本、语音和图像，而是与文化、环境、历史等密切相关，因此，需要一个新的模型来捕捉这些背景信息，指导机器翻译生成符合背景的译文。</p> 
<h3>
<a id="6NMT_164"></a>6.在NMT中引入先验知识</h3> 
<p>注意，由于篇幅所限，本AR-ticle中没有提到一些研究主题。例如，如何将先验知识（如对齐、双语词典、短语表和知识图）集成到NMT框架中是一个困难而又实用的问题。尽管已经取得了一些进展，但由于目前还不清楚如何将基于离散符号的知识和基于分布式表示的NMT连接起来，这仍然是一个有趣而重要的研究方向[42,84,89,121,132,133,152,165,166]。</p> 
<h3>
<a id="7_166"></a>7.更好的领域自适应模型</h3> 
<p>领域适应一直是一个研究热点，吸引了众多研究者的关注[28,29,77,85,<br> 与SMT中使用的方法不同，NMT中的域适应通常与PA高度相关-<br> rameter微调。如何解决未知的测试域和域外术语翻译问题仍然是一个挑战。</p> 
<h3>
<a id="8_170"></a>8.弥合训练与推理之间的鸿沟</h3> 
<p>训练与推理（或推断）之间的不一致性是除神经机器翻译外，大多数序列生成任务中的一个关键问题。这个问题在机器翻译界得到了很好的解决[111，160]，但它仍然值得探索，特别是在方法的效率。</p> 
<h3>
<a id="9NMT_172"></a>9.设计可解释的鲁棒NMT</h3> 
<p>到目前为止，NMT模型仍然是一个黑箱，在许多需要知道翻译结果是如何以及为什么得到的场景中使用它是非常危险的。[35]试图可视化每个输入对输出转换的贡献。然而，深入研究NMT模型的解释或设计一个可解释的MT体系结构将是非常重要的。此外，现有的NMT系统很容易通过干扰输入进行攻击。[23,24]提出了新的鲁棒NMT模型来处理噪声输入。然而，真实的输入噪声很难预测，如何设计鲁棒的NMT模型仍然是一个很大的挑战。</p> 
<h3>
<a id="10NMT_174"></a>10.新的NMT体系结构</h3> 
<p>最后，设计超越Trans-former的更好的NMT架构，尽管存在分歧，但一定是非常令人兴奋的探索。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>