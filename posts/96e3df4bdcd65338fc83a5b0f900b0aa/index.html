<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Unity游戏开发之游戏存档方式 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity游戏开发之游戏存档方式</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.Unity%E8%87%AA%E5%B8%A6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8FPlayerPrefs-toc" style="margin-left:40px"><a href="#1.Unity%E8%87%AA%E5%B8%A6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8FPlayerPrefs">1.Unity自带存储方式PlayerPrefs</a></p> 
<p id="2.XML%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px"><a href="#2.XML%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">2.XML存储方式</a></p> 
<p id="3.Json%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px"><a href="#3.Json%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">3.Json类型存储方式</a></p> 
<p id="1.Unity%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98-toc" style="margin-left:80px"><a href="#1.Unity%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98">1.Unity的序列化问题</a></p> 
<p id="2.Unity%E4%B8%AD%E6%94%AF%E6%8C%81%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%B1%BB-toc" style="margin-left:80px"><a href="#2.Unity%E4%B8%AD%E6%94%AF%E6%8C%81%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%B1%BB">2.Unity中支持序列化的类</a></p> 
<p id="3.Unity%E4%B8%ADJson%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:80px"><a href="#3.Unity%E4%B8%ADJson%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">3.Unity中Json的使用方法</a></p> 
<p id="%C2%A04.SQLite-toc" style="margin-left:40px"><a href="#%C2%A04.SQLite"> 4.SQLite</a></p> 
<p id="1.SQLite%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%EF%BC%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px"><a href="#1.SQLite%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%EF%BC%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3%EF%BC%89">1.SQLite的一些基础（简单介绍，不会深入讲解）</a></p> 
<p id="2.%E5%9C%A8Unity%E4%B8%AD%E4%BD%BF%E7%94%A8SQLite-toc" style="margin-left:80px"><a href="#2.%E5%9C%A8Unity%E4%B8%AD%E4%BD%BF%E7%94%A8SQLite">2.在Unity中使用SQLite</a></p> 
<p id="3.SQLite%E7%9A%84%E4%BC%98%E5%8A%A3-toc" style="margin-left:80px"><a href="#3.SQLite%E7%9A%84%E4%BC%98%E5%8A%A3">3.SQLite的优劣</a></p> 
<p id="%E7%BB%93%E8%AF%AD-toc" style="margin-left:40px"><a href="#%E7%BB%93%E8%AF%AD">结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.Unity%E8%87%AA%E5%B8%A6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8FPlayerPrefs">1.Unity自带存储方式PlayerPrefs</h2> 
<p>        属于unity自带的数据存储方法，其形式类似于字典的存储形式，里面的存储元素按照键值对（key:value)形式存在；key键的数据类型必须为string字符类型，而value值的数据类型可以为int，float，bool等简单的数据类型。</p> 
<pre><code class="language-cs">// &lt;T&gt;表示数据类型
//Save
PlayerPrefs.Set&lt;T&gt;(key,value);
//Load
&lt;T&gt; element=PlayerPrefs.Get&lt;T&gt;(key);
//判断是否存在key
playerPrefs.HasKey(key);</code></pre> 
<p>        因为使用该方法的存储数据的类型有限，而且当需要存储的数据类型较为复杂时，该方法就难以实现（或者实现的过程过于复杂），因此，不推荐将此存储方式作为项目的主要存储方式，但是可以用该方式去存储一些简单的值，例如：</p> 
<p>        游戏的一些设置：音量大小（int/float），某些设置是否开启（bool）</p> 
<p>        一些少量物品的状态设置：某个区域的传送门是否可用（bool），某个区域是否已经开启（bool）</p> 
<p>        等等。   </p> 
<h2 id="2.XML%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">2.XML存储方式</h2> 
<p>        说到XML，可能有很多学过或者接触过计算机的通知会想到前端的HTML，其实我是觉得这两种形式类似的，其文件形式相近，只不过XML中没有HTML里面那些绚丽的CSS/JavaScript那些样式或者逻辑，XML只是单纯用于存放一些类以及其属性、子类的文件，形式如下：</p> 
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;//固定开头，当你在代码中写入下方内容是，保存文件会自动添加

&lt;Root&gt;//根元素

    &lt;Child1  属性1 = Value1 属性2 = value2  ......&gt;
    //子元素，元素中可以包含属性，属性之间空格隔开

        &lt;element1&gt;inertext1&lt;/element1&gt;//元素中可以放置内容，为string类型

        &lt;element2&gt;inertext2&lt;/element2&gt;

        &lt;element2&gt;inertext3&lt;/element3&gt;
        &lt;element4/&gt;//如果元素之中没有东西，可以直接在开始时跟 / 终结符

    &lt;/child1&gt;

&lt;/Root&gt;</code></pre> 
<p>        其中涉及的变量名仅仅只是方便理解，实际中可以按照自己的需求来进行命名。</p> 
<p>        使用XML来存储数据的方法：</p> 
<pre><code class="language-cs">public class XMLSaveManager : MonoBehaviour
{
    public string filePath;
    public SkillBag SkillBag;

    public void Awake()
    {
        filePath = Application.dataPath + @"GameData.xml";
    }

    //只存储人物的基础信息
    public void SaveData()
    {
        if (File.Exists(filePath))
        {
//第一步，一定要先创建XmlDocument，才可以对XML文件进行写入保存的操作
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(filePath);
//获得根元素（singleNode，唯一节点则为根节点）下的所有子元素
            XmlNodeList nodeLise = xmlDoc.SelectSingleNode("PlayerInfo").ChildNodes;
//遍历第一个子元素下的所有元素
            foreach (XmlElement item in nodeLise[0].ChildNodes)
            {
//用元素的名称来区分，便于下面的操作
                switch (item.Name)
                {
                    case "Name":
                        item.InnerText=PlayerContorller.instance.playerNameText.text;
                        break;
                    case "Level":
                        item.InnerText = PlayerContorller.instance.levelText.text;
                        break;
                    case "CoinValue":
                        item.InnerText = PlayerContorller.instance.ShowCoinValue.ToString();
//这里是因为ShowCoinValue为int，不用过多考虑改例子的内容
                        break ;
                    default:
                        break;
                }
            }
//每次进行操作完成之后都要进行save操作，否则操作内容只会存储在临时，不会写入磁盘
            xmlDoc.Save(filePath);
            Debug.Log("Save succeeful!");
        }
        else
        {
//一些首次创建XML文件时执行的操作
            XmlDocument xmlDoc = new XmlDocument();
            XmlElement rootElement = xmlDoc.CreateElement("PlayerInfo");
            XmlElement xmlElement = xmlDoc.CreateElement("Player");
            xmlElement.SetAttribute("Id", "001");

            XmlElement nameEl = xmlDoc.CreateElement("Name");
            nameEl.InnerText = PlayerContorller.instance.playerNameText.text;
            XmlElement levelEl = xmlDoc.CreateElement("Level");
            levelEl.InnerText = PlayerContorller.instance.levelText.text;
            XmlElement coinEl = xmlDoc.CreateElement("CoinValue");
            coinEl.InnerText = PlayerContorller.instance.coinValueText.text;
//注意，一定要分清楚每个Element之间的关系
            xmlElement.AppendChild(nameEl);
            xmlElement.AppendChild(levelEl);
            xmlElement.AppendChild(coinEl);
            rootElement.AppendChild(xmlElement);
            xmlDoc.AppendChild(rootElement);

            xmlDoc.Save(filePath);
            Debug.Log("Save succeeful!");
        }
    }

    public void LoadData()
    {
        if (File.Exists(filePath))
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(filePath);
            XmlNodeList nodeLise = xmlDoc.SelectSingleNode("PlayerInfo").ChildNodes;
            foreach (XmlElement item in nodeLise[0].ChildNodes)
            {
                switch (item.Name)
                {
                    case "Name":
                        PlayerContorller.instance.playerNameText.text = item.InnerText;
                        break;
                    case "Level":
                        PlayerContorller.instance.levelText.text = item.InnerText;
                        break;
                    case "CoinValue":
                        PlayerContorller.instance.ShowCoinValue = int.Parse(item.InnerText);
                        break;
                    default:
                        break;
                }
            }

            Debug.Log("Load sueeccful!");
            return;
        }
        Debug.LogWarning("Data file do not exit!");
    }
}</code></pre> 
<p>       使用时需要引用命名空间：</p> 
<pre><code class="language-cs">using System.IO;
using System.XML;</code></pre> 
<p>        本例子只展示了XML存储的基本使用方式，更详细的使用方式可以参考Unity官方手册。</p> 
<p>        对于XML文档存储形式，优点在于：</p> 
<p>        可读性高：以开始/终结元素名包裹着被存储的数据，容易理解数据的含义；</p> 
<p>        易于实现：使用XML文档存储数据并没有涵括太多的编程内容，容易实现</p> 
<p>        但是，XML文档也有它的局限性：</p> 
<p>        编程”麻烦“：为什么会麻烦呢？优点里不是有 易于实现 吗？这个麻烦其实是指”每一个元素的创建以及起inertext的赋值都需要独立完成“，如何理解呢？简单来说就是，你要保存一个物体的信息（包含长、宽、高），那么你就要依次创建每个属性对应的元素，然后再依次对元素的inertext进行赋值；那么问题来了，倘若一个物体的属性非常的复杂，有十几个属性甚至包含一些数组属性，那么你要怎么去实现XML存储呢？还是一个一个去进行创建跟赋值，那样做的话效率太低，而且重复性代码太多，因此才是”麻烦“。</p> 
<p>        可存储的数据类型有限：XML文档时不支持存储数组类型或者一些复杂的数据类型的，但如果你执意要用XML形式去存储一些复杂的数据类型，那么你就需要就复杂的数据类型进行拆分，拆解成为基础（简单）的数据类型进行存储，但如果这样的话，你读取数据的时候又需要重新将这些数据进行组合。这样子做的代码量的庞大的。</p> 
<h2 id="3.Json%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">3.Json类型存储方式</h2> 
<p>        接下来要介绍的就是当前环境下最广泛应用的存储方式：将可序列化的数据转置为Json格式进行存储。</p> 
<p>        首先要讲的是”什么是可序列化呢？“简单来讲，就是可以将整个数据转换为string字符类型的数据，或者再简单来说，可以在Unity的Editor中的Inspector窗口中显示的数据类型。</p> 
<p>        接下来我们简单讲解一下Unity中的可序列化问题。</p> 
<h3 id="1.Unity%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98">1.Unity的序列化问题</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:550px">
<caption>
   Unity序列化问题 
 </caption>
<thead><tr>
<th>不支持Unity序列化的字段</th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td></td>
<td>静态字段（static fields）</td>
</tr>
<tr>
<td></td>
<td>只读字段（readonly fields）</td>
</tr>
<tr>
<td></td>
<td>常量（const fields）</td>
</tr>
<tr>
<td></td>
<td>未带有[field:SerializeField]特性的属性</td>
</tr>
<tr>
<td><strong>支持Unity序列化的字段</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td>公有的 非静态的非只读的非常量 字段</td>
</tr>
<tr>
<td></td>
<td>带有[SerializeField]特性的非静态的 非只读的 非常量 字段</td>
</tr>
<tr>
<td></td>
<td>带有[field:SerializeField]特性的属性</td>
</tr>
</tbody>
</table> 
<p>        很多人可能对支持中的2有疑问，其实就是在私有化变量（privaite）前添加[SerializeField]特性即可将其序列化。</p> 
<h3 id="2.Unity%E4%B8%AD%E6%94%AF%E6%8C%81%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%B1%BB">2.Unity中支持序列化的类</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr>
<td>一些继承自Object的类</td>
<td>MonBaviour以及继承自它的类</td>
</tr>
<tr>
<td> <p>枚举类（Enums）</p> </td>
<td></td>
</tr>
<tr>
<td>结构类（Structs）</td>
<td></td>
</tr>
<tr>
<td>原始数据类型</td>
<td>int,float,bool,etc.....</td>
</tr>
<tr>
<td>其所包含的元素的类型是支持序列化类型的一维数组</td>
<td></td>
</tr>
<tr>
<td>其所包含的元素的类型是支持序列化类型的列表</td>
<td></td>
</tr>
<tr>
<td>Unity引擎内置的一些类</td>
<td>Vector3，Quaternion，Color，etc.......</td>
</tr>
</tbody></table> 
<h3 id="3.Unity%E4%B8%ADJson%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">3.Unity中Json的使用方法</h3> 
<p>        首先，新版的Unity引擎中已经支持Json的一些语法编写，不需要再去下载第三方的库也可以正常使用了，只需要引用命名空间：</p> 
<pre><code class="language-cs">using Systeam.IO;</code></pre> 
<p>        先讲解一下Json存储以及读取数据的一些思路：</p> 
<p>        首先，存储数据时，先将可序列化的对象类型转化为Json字符串类型，再将Json字符串写入文件之中；读取数据时，是先将文件中的Json字符串读取出来，在进行反序列化，反序列化过程中需要指定反序列化的数据类型。</p> 
<p><strong>JsonUtility.ToJson(object obj,[bool prettyPrint])</strong></p> 
<p>        该方法是将可序列化对象obj转换为Json字符串，返回的是string类型，第二个参数默认值是flase，表示是否将Json文件变为更方便阅读的文本格式（同志们自己尝试，这里就不做演示）。</p> 
<pre><code class="language-cs">public string filePath = "GameData.json";


    public void SaveData(object saveObj)
    {
        //无需判断文件是否存在，存在则覆盖，不存在则新建
        FileStream fileStream = new FileStream(filePath, FileMode.Create);

        var json = JsonUtility.ToJson(saveObj);

        StreamWriter streamWriter = new StreamWriter(fileStream);

        streamWriter.Write(json);
        Debug.Log("json Save");
        streamWriter.Close();
        fileStream.Close();
    }</code></pre> 
<blockquote> 
 <p>关于FileStream的详细使用信息，建议参考  <a class="has-card" href="http://t.csdn.cn/z81Vb" title="http://t.csdn.cn/z81Vb"><span class="link-card-box"><span class="link-title">http://t.csdn.cn/z81Vb</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/57/66/8WBNNVIr_o.png">http://t.csdn.cn/z81Vb</span></span></a></p> 
</blockquote> 
<p>         而Stream流，在此的应用中我们仅需要学会使用StreamWirter与StreamReader即可。</p> 
<p><strong>JsonUtility.FromJson(string json) / JsonUtility.FromJsonOverWirte(string json,object obj)</strong></p> 
<p>        这两种方法都是将Json文件读取并反序列化的操作，但不同的是前一种方法需要指定反序列化生成的数据类型，然后返回一个对应数据类型的实例；而后一种方法是直接对已存在的实例进行重写。</p> 
<pre><code class="language-cs">//两种方式指定反序列化的类型
/*该方法只支持普通类和结构；不支持派生自 UnityEngine.Object 的类（如 MonoBehaviour 或 ScriptableObject）*/
JsonUtility.FromJson(String Json,Type T)
JsonUtility.FromJson&lt;T&gt;(String Json)


//若要读取的Json中存储的是一些派生自UnityEngine.Object 的类，推荐使用方法二进行数据重写
JsonUtility.FromJsonOverWirte(String Json,Obejct obj)
</code></pre> 
<p>例子参考：</p> 
<pre><code class="language-cs">public void LoadData(object loadObj)
    {
        if (File.Exists(filePath))
        {
            FileStream fileStream = new FileStream(filePath, FileMode.Open);

            StreamReader streamReader = new StreamReader(fileStream);
            string jsonString = streamReader.ReadToEnd();

            JsonUtility.FromJsonOverwrite(jsonString, loadObj);   
            Debug.Log("json Load");
            streamReader.Close();
            fileStream.Close();
        }
        else
        {
            Debug.Log("Do not found");
        }
    }</code></pre> 
<p>        为什么我要在这里详细的（对比前两种方法）介绍Json的存储方式呢，因为Json存储方式是目前我所接触到的存储方式中，最适合游戏存档的方式：</p> 
<p>        方便人类阅读以及编写；</p> 
<p>        应用范围广泛，跨平台跨语言；</p> 
<p>        虽然存储后的文本格式与XML类似，但是Json文件更加轻便，因此在网络传输过程中，同等信息的传输上会更加迅速</p> 
<p>        Json十分符合当前的形式，将逐渐成为游戏存档的主流形式。</p> 
<p>        虽然Json很好用，但也并非完美：</p> 
<p>        支持的数据类型有限（这里仅指 unity自带的JsonUtility所实现的系统所支持的数据类型有限，开发过程中可以通过导入第三方库来进行扩展）</p> 
<p>        数据安全性较低（因为可读性高，因此容易被篡改存档的内容）</p> 
<h2 id="%C2%A04.SQLite"> 4.SQLite</h2> 
<p>        先来介绍一下SQLite：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr><td>SQLite是一款轻型的针对本地化存储的数据库(native database)，它是一种关系型数据库管理系统。</td></tr>
<tr><td>SQLite的底层由C语言函数库组成，以嵌入式作为设计目标，在占用资源非常少的情况下实现强大的数据库级的数据存储。</td></tr>
<tr><td>SQLite支持Windows/Linux/Unix/Android/IOS等等主流的操作系统，同时能够使用我们熟悉的C、C++、Ruby、Python、C#、PHP、Java等主流编程语言来编写其代码。</td></tr>
<tr><td>SQLite是一个以文件形式存在的关系型数据库，作为一个轻量级的嵌入式数据库，它不需要系统提供服务支持，通过SDK直接操作文件就可以了使用了。</td></tr>
</tbody></table> 
<p>        简单概括一下，SQLite是一个轻量级的、可跨平台跨语言使用的一种数据库。（常用于本地存储，服务端存储很少或者基本没有使用）</p> 
<p>        使用SQLite来作为Unity游戏开发中的数据存储需要具备一定的Sql语言以及数据库操作基础，因为在存储中设计到在代码中使用sql语言来对数据库进行一些基础的增、删、改、查的操作，所以，如果还完全不了解数据库以及数据库操作的同学，建议先花点事件去了解并学习这方面的知识（但如果你说在以后的这门行业里自己绝对不会用到这方面的知识，那我也无言以对）。</p> 
<h3 id="1.SQLite%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%EF%BC%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3%EF%BC%89">1.SQLite的一些基础（简单介绍，不会深入讲解）</h3> 
<p><strong>SQL的数据类型</strong><br> (1)NULL，值是一个 NULL 值。<br> (2)INTEGER，值是一个带符号的整数，根据值的大小存储在1、2、3、4、6或8字节中。<br> (3)REAL，值是一个浮点值，存储为8字节的IEEE浮点数字。<br> (4)TEXT，值是一个文本字符串，使用UTF-8或UTF-16存储。<br> (5)BLOB，值是一个blob数据，完全根据它的输入存储。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px">
<caption>
   特别需要注意的数据类型 
 </caption>
<tbody>
<tr>
<td>Bool数据类型</td>
<td>SQLite没有单独的Bool类型。使用整数0（false）和 1（true）来代替bool值。</td>
</tr>
<tr>
<td>Date与Time数据类型</td>
<td>SQLite没有单独的日期或时间类型，可以使用TEXT、REAL或 INTEGER来代替。<br> TEXT表示时间，格式为"YYYY-MM-DD HH:MM:SS.SSS"的日期。<br> REAL表示时间，从公元前4714年11月24日格林尼治时间的正午开始算起的天数。<br> INTEGER表示时间，从1970-01-01 00:00:00UTC算起的秒数。</td>
</tr>
</tbody>
</table> 
<p><strong>SQL语句</strong></p> 
<p><strong>      </strong>  关于使用SQL语句对数据库进行SELECT、INSERT、UPDATE、DELETE、ALTER、DROP等操作，在此不作详细说明，感兴趣的小伙伴可以上网搜索相关内容，本篇着重讲解SQLite在Unity中的使用。</p> 
<h3 id="2.%E5%9C%A8Unity%E4%B8%AD%E4%BD%BF%E7%94%A8SQLite"><strong>2.在Unity中使用SQLite</strong></h3> 
<p>        首先，想要在Unity中使用SQLite，我们需要几个依赖包：sqlite3.dll、System.Data.dll以及Mono.Data.Sqlite.dll。第一个依赖包可以在slqite的官网进行下载(https://www.sqlite.org/download.html)，根据所需要的版本及内容进行下载。</p> 
<p><img alt="" height="718" src="https://images2.imgbox.com/b6/10/H3uH6k0b_o.png" width="749"></p> 
<p>         另外两个依赖是在你安装Unity的时候自动下载好了，只需要你找出来即可，在你安装Unity的目录下找到：EditorDataMonolibmono2.0，在2.0的文件夹下分别找到System.Data.dll以及Mono.Data.Sqlite.dll。三个文件都齐全之后，将其复制一份并一起放入正在开发的Unity项目中的Plugins文件夹中，然后就可以正常使用了。</p> 
<p><strong>使用SQLite</strong></p> 
<p><strong>        </strong>想要正常使用SQLite，需要引入的命名空间：</p> 
<pre><code class="language-cs">using UnityEngine;
using System;
using Mono.Data.Sqlite;</code></pre> 
<p>        使用SQLite的三部曲：连接数据库，创建并使用SQL命令，获得SQL命令结果（有些操作可能会返回读取数据结果）</p> 
<pre><code class="language-cs">    //数据库连接定义
    private SqliteConnection dbConnection;
    //SQL命令定义
    private SqliteCommand dbCommand;
    //查询记录数据读取器定义
    private SqliteDataReader dataReader;</code></pre> 
<p>        创建数据库连接</p> 
<pre><code class="language-cs">//构造函数，负责构建数据库连接
    public SQLiteDataHelper(string dbName)
    {
        try
        {
            //拼接数据库连接字符串
            string connectString = "data source=" + Application.dataPath + "/" + dbName + ".db";
            //构造数据库连接对象
            dbConnection = new SqliteConnection(connectString);
            //打开这个数据库
            dbConnection.Open();
            Debug.Log("数据库打开成功!");
        }
        catch(Exception e)
        {
            Debug.Log("数据库打开失败:" + e.Message);
        }
    }</code></pre> 
<p>注意：其中的connectString为固定形式，一定是"data source="开头，跟着数据库的位置，".db"结尾。</p> 
<p>        SQL操作</p> 
<pre><code class="language-cs">//执行SQL命令，使用SQL语句字符串
    public SqliteDataReader ExecuteQuery(string queryString)
    {
        //创建命令
        dbCommand = dbConnection.CreateCommand();
        //设置要执行的SQL语句
        dbCommand.CommandText = queryString;
        //执行命令并返回结果
        dataReader = dbCommand.ExecuteReader();
        return dataReader;
    }</code></pre> 
<p>        一般的执行方式就是传入一段SQL语言的String类型的变量，然后创建Command，执行Command后返回数据读取记录。</p> 
<p>        但是，很多同学应该也想到这个实现方法的弊端，传入的变量是SQL语言的String，那么在实现功能的过程中，就要花费大量时间在c#脚本中编写SQL语言，这是我们不想看到的，因此，我们可以将SQL的常用语言抽象成方法，需要使用的时候就不需要传入完整的SQL语言，而是传入一些比较重要的变量部分。</p> 
<p>        </p> 
<pre><code class="language-cs">//创建数据库表
    public SqliteDataReader CreateTable(string tableName, string[] colNames, string[] colTypes)
    {
        //判断字段个数与类型是否一致
        if(colNames.Length != colTypes.Length)
        {
            Debug.Log("创建表失败:字段个数与类型个数不一致!");
            return null;
        }
        //拼接创建表SQL语句
        string queryString = "CREATE TABLE " + tableName + "(" + colNames[0] + " " + colTypes[0];
        for(int i = 1; i &lt; colNames.Length; i++)
        {
            queryString += "," + colNames[i] + " " + colTypes[i];
        }
        queryString += ")";
        Debug.Log("创建表:" + tableName + "成功!");
        //执行SQL语句的命令并返回结果
        return ExecuteQuery(queryString);
    }

    //读取整张数据表的所有数据
    public SqliteDataReader ReadFullTable(string tableName)
    {
        //获取所有记录
        string queryString = "SELECT * FROM " + tableName;
        //执行并返回
        return ExecuteQuery(queryString);
    }

    //向指定的数据库表中插入数据
    public SqliteDataReader InsertValues(string tableName, string[] values)
    {
        //获取数据库表中字段的个数
        int fieldCount = ReadFullTable(tableName).FieldCount;
        //判断插入的数据值的个数是否与字段个数一致
        if(values.Length != fieldCount)
        {
            Debug.Log("向表" + tableName + "中插入数据失败，值与字段个数不相符!");
            return null;
        }
        //拼接插入SQL语句字符串
        string queryString = "INSERT INTO " + tableName + " VALUES(" + values[0];
        for(int i = 1; i &lt; values.Length; i++)
        {
            queryString += "," + values[i];
        }
        queryString += ")";
        Debug.Log("向表" + tableName + "中插入记录成功!");
        //执行命令并返回结果
        return ExecuteQuery(queryString);
    }

    //更新指定数据表中的记录
    public SqliteDataReader UpdateValues(string tableName, string[] colNames, string[] colValues,
                                                                        string key, string operation, string value)
    {
        //判断字段个数与值的个数是否一致
        if (colNames.Length != colValues.Length)
        {
            Debug.Log("更新表" + tableName + "失败:字段个数与值的个数不一致!");
            return null;
        }
        //拼接更新SQL语句字符串
        string queryString = "UPDATE " + tableName + " SET " + colNames[0] + "=" + colValues[0];
        for(int i = 1; i &lt; colValues.Length; i++)
        {
            queryString += "," + colNames[i] + "=" + colValues[i];
        }
        queryString += " WHERE " + key + operation + value;
        Debug.Log("更新数据表" + tableName + "中的记录成功!");
        //执行命令并返回结果
        return ExecuteQuery(queryString);
    }

    //删除指定数据表中的记录
    private SqliteDataReader DeleteValues(string tableName, string[] colNames, string[] operations,
                                                                        string[] colValues, string delMode)
    {
        //判断字段个数与关系运算个数与值的个数是否一致
        if(colNames.Length != operations.Length || operations.Length != colValues.Length)
        {
            Debug.Log("删除数据表:" + tableName + "中的数据失败!字段，运算符，值的个数不一致!");
            return null;
        }
        //拼接SQL删除语句字符串
        string queryString = "DELETE FROM " + tableName + " WHERE " + colNames[0] + operations[0] + colValues[0];
        for(int i = 1; i &lt; colValues.Length; i++)
        {
            queryString += " " + delMode + " " + colNames[i] + operations[i] + colValues[i];
        }
        Debug.Log("删除数据表" + tableName + "中的记录成功!");
        //执行SQL命令并返回结果
        return ExecuteQuery(queryString);
    }

    //删除指定数据表中的记录，条件之间使用AND逻辑与操作
    public SqliteDataReader DeleteValuesAnd(string tableName, string[] colNames, string[] operations,
                                                                        string[] colValues)
    {
        return DeleteValues(tableName, colNames, operations, colValues, "AND");
    }

    //删除指定数据表中的记录，条件之间使用OR逻辑与操作
    public SqliteDataReader DeleteValuesOr(string tableName, string[] colNames, string[] operations,
                                                                        string[] colValues)
    {
        return DeleteValues(tableName, colNames, operations, colValues, "OR");
    }</code></pre> 
<p>        以上实现的方法都是传入一些简单的变量之后进行SQL语句的缝合，这样做哪怕你不是很了解SQL语言的编写，只要你理清楚你这一步对数据库操作想达到什么效果，继而传入对应所需的变量以及操作符，就可以完成操作。（注意：以上实现的只是数据库的一些简单的操作，如果你想要使用更加复杂、更加自由的操作，那么则需要你自己去实现了。）</p> 
<p>        最后，当你执行完全部对数据库的操作之后，不需要再使用了，那么请将数据库以及有关数据库的一些东西给关闭掉，以节省不必要的开支。</p> 
<pre><code class="language-cs">    //关闭数据库连接，释放系统资源
    public void CloseConnection()
    {
        //销毁Command
        if(dbCommand != null)
        {
            dbCommand.Cancel();
            dbCommand = null;
        }

        //销毁Reader
        if(dataReader != null)
        {
            dataReader.Close();
            dataReader = null;
        }

        //销毁Connection
        if(dbConnection != null)
        {
            dbConnection.Close();
            dbConnection = null;
        }
        Debug.Log("数据库已经被关闭!");
    }</code></pre> 
<h3 id="3.SQLite%E7%9A%84%E4%BC%98%E5%8A%A3">3.SQLite的优劣</h3> 
<p>        前面也讲到了，SQLite是一种轻量级的数据库，因此它对比与其他例如Oracle、MySQL、SQLServer等大型数据库，对于一些使用的电脑性能不是很好的同学更加友好，除外还有：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr><td>ACID事务，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</td></tr>
<tr><td>零配置，即无需安装和管理配置</td></tr>
<tr><td>储存在单一磁盘文件中的一个完整的数据库</td></tr>
<tr><td>读写效率很高，比大型数据库要快很多</td></tr>
<tr><td>独立，没有额外依赖</td></tr>
<tr><td>项目源码完全的开源, 你可以将其用于任何商业用途, 包括出售它</td></tr>
</tbody></table> 
<p>        但是，毕竟SQLite对于之学习过Unity的同学来说，可能相当于另外一个全新的领域，因此需要花费额外的时间去学习并掌握使用方式；而且，由于SQLite的轻量级的性质，它所搭载的方法以及可实现的功能可能就没有一些大型数据库那么齐全，并且SQLite并不适合用于存储庞大的数据，它只是一个本地的数据库。</p> 
<h2 id="%E7%BB%93%E8%AF%AD">结语</h2> 
<p>        至此，关于Unity游戏开发的游戏存档方式的介绍到此结束。</p> 
<p>        以上的方法各有优劣，并不存在什么这种方法就一定是高人一等的说法，根据游戏数据存储的需求来选择合适的方法，比盲目的使用一种方法的效率更高，而往往一个游戏项目中的存储形式不会单一，因此，学会如何去判断当前游戏数据的更优（更便利）的存储形式尤为重要。</p> 
<p>        祝诸君，武运昌隆。</p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>