<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【Web UI自动化测试】Web UI自动化测试之框架篇（全网最全） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Web UI自动化测试】Web UI自动化测试之框架篇（全网最全）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p><strong>本文大纲截图：</strong></p> 
<ul><li> <p><strong>UnitTest框架：</strong></p> </li></ul> 
<p class="img-center"><img alt="" height="337" src="https://images2.imgbox.com/d8/db/OkU8PD9m_o.png" width="518"></p> 
<ul><li> <p><strong>PyTest框架：</strong></p> </li></ul> 
<p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/44/cd/IT0KpWF2_o.png" width="449"></p> 
<p>框架： 框架英文单词 framework，为解决一类事情的功能的集合。需要按照框架的规定（套路）去书写代码。</p> 
<h1>一、UnitTest框架介绍【文末分享自动化测试学习资源】</h1> 
<h2>1、什么是UnitTest框架？</h2> 
<ul>
<li> <p>概念：UnitTest是python自带的一个单元测试框架，用它来做单元测试</p> </li>
<li> <p>自带的框架：不需要单独按照，只要安装了 python就可以用</p> </li>
<li> <p>第三方框架：想要使用 需要先安装后使用（如：pytest）</p> </li>
<li> <p>单元测试框架：主要用来做单元测试，一般单元测试是开发做的。对于测试来说，UnitTest 框架的作用是自动化脚本（用例代码）执行框架（使用UnitTest框架来管理 运行多个测试用例的）</p> </li>
</ul> 
<h2>2、为什么使用UnitTest框架？</h2> 
<ul>
<li> <p>1）能够组织多个用例去执行</p> </li>
<li> <p>2）提供丰富的断言方法（让程序代码代替人工自动的判断预期结果和实际结果是否相符）</p> </li>
<li> <p>3）能够生成测试报告</p> </li>
<li> <p>4）UnitTest框架对于测试来说的作用是：自动化脚本执行框架（使用 UnitTest框架来管理运行多个测试用例的脚本）</p> </li>
</ul> 
<h2>3、UnitTest框架核心组成要素</h2> 
<p>1）TestCase【最核心的模块】</p> 
<ul>
<li> <p>TestCase（测试用例），这个测试用例是UnitTest框架的组成部分，不是手工和自动化中所说的用例（Test Case）</p> </li>
<li> <p>主要作用：每个TestCase（测试用例）都是一个代码文件，在这个代码文件中 来书写 真正的用例代码</p> </li>
</ul> 
<p>2）TestSuite</p> 
<ul><li> <p>TestSuite（测试套件），用来 管理、组装（打包）多个 TestCase（测试用例）的</p> </li></ul> 
<p>3）TestRunner</p> 
<ul><li> <p>TestRunner（测试执行，测试运行），用来 执行 TestSuite（测试套件）的</p> </li></ul> 
<p>4）TestLoader</p> 
<ul><li> <p>TestLoader（测试加载），功能是对 TestSuite（测试套件）功能的补充，管理、组装（打包）多个 TestCase（测试用例）的</p> </li></ul> 
<p>5）Fixture</p> 
<ul>
<li> <p>Fixture（测试夹具），书写在TestCase（测试用例）代码中，是一个代码结构，可以在每个方法执行前后都会执行的内容</p> </li>
<li> <p>每个用例中重复的代码就可以写在 Fixture 代码结构中，只写一遍，但每次用例方法的执行，都会执行Fixture中的代码</p> </li>
<li> <p>举例：登录的测试用例</p> 
  <ul>
<li> <p>1、打开浏览器</p> </li>
<li> <p>2、输入网址</p> </li>
</ul>
</li>
</ul> 
<h2>4、UnitTest框架实践</h2> 
<h3>4.1 TestCase（测试用例）</h3> 
<p>介绍：</p> 
<ul>
<li> <p>1）每个 TestCase（测试用例）都是一个代码文件，在这个代码文件中 来书写真正的用例代码</p> </li>
<li> <p>2）代码文件的名称必须按照标识符的规则来书写（可以将代码的作用在文件的开头又多行注释说明）</p> </li>
</ul> 
<p>注意：</p> 
<ul>
<li> <p>1）代码文件的命名规范</p> 
  <ul>
<li> <p>1&gt;代码文件名字不能以数字开头</p> </li>
<li> <p>2&gt;代码文件名字中不能有空格</p> </li>
<li> <p>3&gt;代码文件名字不能有中文</p> </li>
<li> <p>4&gt;代码文件名字由字母、数字、下划线组成，且不能以数字开头</p> </li>
</ul>
</li>
<li> <p>2）代码运行没结果</p> 
  <ul>
<li> <p>原因：右键运行没有 <code>unittest for xxx</code> 的提示 而出现的问题</p> </li>
<li> <p>解决方案1：重新建一个代码文件，将写好的代码复制进去</p> </li>
<li> <p>解决方案2：删除已有的运行方式</p> </li>
</ul>
</li>
<li> <p>3）没有找到用例：测试方法中不是以 test_ 开头的，或者单词写错了</p> </li>
</ul> 
<p>步骤：</p> 
<ul>
<li> <p>1）导包 import unittest</p> </li>
<li> <p>2）自定义测试类</p> </li>
<li> <p>3）在测试类中书写测试方法</p> </li>
<li> <p>4）执行用例</p> </li>
</ul> 
<p>代码：</p> 
<pre><code># 1、导包
import unittest

# 2、新建测试类，需要继承 unittest 模块中的 TestCase类 即可
class TestDemo1(unittest.TestCase):
    # 3、书写测试方法（即 用例代码，目前没有真正的用例代码，使用 print 代替）
    # 注意：书写要求；测试方法 必须以 test_ 开头（本质以 test 开头）
    def test_method1(self):
        print("测试方法1")

    def test_method2(self):
        print("测试方法2")

class TestDemo2(unittest.TestCase):
    def test_method3(self):
        print("测试方法3")

    def test_method4(self):
        print("测试方法4")

# 4、执行用例（方法）
# 4.1 将光标放在 类名后边 运行，会执行类中的 所有测试方法
# 4.2 将光标放在 方法名后边 运行，只执行当前的方法
</code></pre> 
<h3>4.2 TestSuite &amp; TestRunner（测试套件&amp;运行）</h3> 
<p>介绍：</p> 
<ul>
<li> <p>1）TestSuite(测试套件)：管理、打包、组装 多个 TestCase(测试用例) 文件</p> </li>
<li> <p>2）TestRunner(测试执行)：执行 TestSuite(测试套件)</p> </li>
</ul> 
<p>步骤：</p> 
<ul>
<li> <p>1）导包 import unittest</p> </li>
<li> <p>2）实例化套件对象（创建套件对象）</p> </li>
<li> <p>3）使用套件对象 添加 用例方法</p> </li>
<li> <p>4）实例化运行对象（创建运行对象）</p> </li>
<li> <p>5）使用运行对象 去执行 套件对象</p> </li>
</ul> 
<p>实例化套件对象并添加测试用例:</p> 
<pre><code># 导包
import unittest
from UnitTest_study.hm01_unittest import TestDemo

# 实例化套件对象
suite = unittest.TestSuite()
# 方法1：单个添加测试用例（需要导包TestDemo）
suite.addTest(TestDemo('test_001'))
suite.addTest(TestDemo('test_002'))
# 方法2：批量添加测试用例（需要导包TestDemo）
suite.addTest(unittest.makeSuite(TestDemo))
</code></pre> 
<p>实例化运行对象:</p> 
<pre><code># 导包
import unittest
# 实例化运行对象
runner = unittest.TextTestRunner()
# 运行测试套件
runner.run(suite)
</code></pre> 
<p>查看测试执行结果的方法:</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bc/4c/pKpLcbbs_o.png"></p> 
<ul><li> <p>说明： <code>.</code>运行通过；<code>F</code>用例不通过；<code>E</code>用例代码有问题</p> </li></ul> 
<p>代码：</p> 
<p>方法一：使用套件对象单个（单个方法）添加用例并运行</p> 
<ul>
<li> <p>添加用例基本格式：<code>unittest.TestSuite().addTest(类名('方法名'))</code></p> </li>
<li> <p>特点：逐条添加测试用例</p> </li>
<li> <p>运行用例基本格式：<code>unittest.TextTestRunner().run(测试用例集)</code></p> </li>
</ul> 
<pre><code># 1、导包
import unittest
from unittest_testcase import TestDemo1, TestDemo2

# 2、实例化套件对象（创建套件对象）
suite = unittest.TestSuite()

# 3、使用套件对象 添加 用例方法
suite.addTest(TestDemo1('test_method1'))
suite.addTest(TestDemo1('test_method2'))
suite.addTest(TestDemo2('test_method1'))
suite.addTest(TestDemo2('test_method2'))
# 4、实例化运行对象（创建运行对象）
runner = unittest.TextTestRunner()
# 5、使用运行对象 去执行 套件对象
# 格式：运行对象.run(套件对象)
runner.run(suite)
</code></pre> 
<p>方法二：使用套件对象批量（单个类）添加用例并运行</p> 
<ul>
<li> <p>添加用例基本格式：<code>unittest.TestSuite().addTest(unittest.makeSuite(类名))</code></p> </li>
<li> <p>特点：批量添加测试用例</p> </li>
<li> <p>运行用例基本格式：<code>unittest.TextTestRunner().run(测试用例集)</code></p> </li>
</ul> 
<pre><code># 1、导包
import unittest
from unittest_testcase import TestDemo1, TestDemo2

# 2、实例化套件对象（创建套件对象）
suite = unittest.TestSuite()

# 3、使用套件对象 添加 用例方法
suite.addTest(unittest.makeSuite(TestDemo1))
suite.addTest(unittest.makeSuite(TestDemo2))
# 4、实例化运行对象（创建运行对象）
runner = unittest.TextTestRunner()
# 5、使用运行对象 去执行 套件对象
# 格式：运行对象.run(套件对象)
runner.run(suite)
</code></pre> 
<h3>4.3 TestLoader（测试加载）</h3> 
<p>介绍： TestLoader(测试加载)，和 TestSuite 的作用一样，是对 TestSuite 功能的补充，用来管理组装（打包）多个 TestCase。在一个项目中 TestCase(测试用例)的代码，一般放在一个单独的目录（case）中</p> 
<p>步骤</p> 
<ul>
<li> <p>1）导包 import unittest</p> </li>
<li> <p>2）实例化测试加载对象并添加用例（得到的是 suite 对象）</p> </li>
<li> <p>3）实例化 运行对象</p> </li>
<li> <p>4）运行对象执行套件对象</p> </li>
</ul> 
<p>代码:</p> 
<ul>
<li> <p>基本格式一：<code>suite = unittest.TestLoader().discover('case', 'test_*.py')</code></p> </li>
<li> <p>基本格式二：<code>suite = unittest.defaultTestLoader.discover('case', 'test_*.py')</code></p> </li>
</ul> 
<pre><code># 导包
import unittest

# 方法1：实例化对象并添加测试用例
suite = unittest.TestLoader().discover('case', 'test_*.py')
# 方法2：实例化对象并添加测试用例(说明：插件代码中有一句：defaultTestLoader = TestLoader()，所以有了方法2)
suite = unittest.defaultTestLoader.discover('case', 'test_*.py')
# 运行测试套件
unittest.TextTestRunner().run(suite)
</code></pre> 
<h3>4.4 Fixture（测试夹具）</h3> 
<p>介绍： Fixture(测试夹具)是一个代码结构，书写在 TestCase代码中，可以在每个方法执行前后都会执行的内容（在某些特定情况下会自动执行）。Fixture是一个概述，对一个测试用例环境的初始化和销毁就是一个Fixture。</p> 
<p>Fixture控制级别： 方法级别、类级别、模块级别</p> 
<p>方法级别【掌握】</p> 
<ul>
<li> <p>作用：在每个测试方法（用例代码）执行前后都会自动调用的结构</p> </li>
<li> <p>关键字：<code>setUp</code>、<code>tearDown</code></p> </li>
<li> <p>格式：</p> </li>
</ul> 
<pre><code>class TestDemo(object):
    """测试示例类"""

    def setUp(self):
        """每个方法执行之前都会执行"""
        print("方法 -&gt; 开始")

    def tearDown(self):
        """每个方法执行之后都会执行"""
        print("方法 -&gt; 结束")
</code></pre> 
<p>类级别【掌握】</p> 
<ul>
<li> <p>作用：在每个测试类中所有方法执行前后 都会自动调用的结构（在整个类中 执行之前执行之后各一次）</p> </li>
<li> <p>说明：类级别的fixture 是一个 类方法，要用<code>@classmethod</code>来装饰</p> </li>
<li> <p>关键字：<code>setUpClass</code>、<code>tearDownClass</code></p> </li>
<li> <p>格式：</p> </li>
</ul> 
<pre><code>class TestDemo(object):
    """测试示例类"""

    @classmethod
    def setUpClass(cls):
        """每个方法执行之前都会执行"""
        print("类 -&gt; 开始")

    @classmethod
    def tearDownClass(cls):
        """每个方法执行之后都会执行"""
        print("类 -&gt; 结束")
</code></pre> 
<p>模块级别【了解】</p> 
<ul>
<li> <p>作用：在每个模块（代码文件）执行前后执行的代码结构</p> </li>
<li> <p>关键字：<code>setUpModule</code>、<code>tearDownModule</code></p> </li>
<li> <p>格式：</p> </li>
</ul> 
<pre><code># 模块级别的需要写在类的外边，直接定义函数即可
def setUpModule(self):
    """每个方法执行之前都会执行"""
    print("模块 -&gt; 开始")

def tearDownModule(self):
    """每个方法执行之后都会执行"""
    print("模块 -&gt; 结束")


class TestDemo(object):
    """测试示例类"""
</code></pre> 
<p>代码：</p> 
<pre><code>import unittest


class TestLogin(unittest.TestCase):
    def setUp(self) -&gt; None:
        """每个测试方法执行之前都会先调用的方法"""
        print('输入网址...')

    def tearDown(self) -&gt; None:
        """每个测试方法执行之后都会调用的方法"""
        print('关闭当前页面...')

    @classmethod
    def setUpClass(cls) -&gt; None:
        print('1、打开浏览器...')

    @classmethod
    def tearDownClass(cls) -&gt; None:
        print('...5、关闭浏览器')

    def test_01(self):
        print('输入正确用户名密码验证码，点击登录')

    def test_02(self):
        print('输入错误用户名密码验证码，点击登录')
</code></pre> 
<h3>4.5 跳过</h3> 
<p>介绍：</p> 
<ul>
<li> <p>使用场景：对于一些未完成的或者不满足测试条件的测试函数和测试类，不想执行，可以使用跳过</p> </li>
<li> <p>使用方法：利用装饰器来完成，代码书写在 TestCase 文件中</p> </li>
<li> <p>格式一：直接将测试函数标记成跳过</p> 
  <ul><li> <p><code>@unittest.skip('跳过原因')</code></p> </li></ul>
</li>
<li> <p>格式二：根据条件判断测试函数是否跳过，判断条件成立则跳过</p> 
  <ul><li> <p><code>@unittest.skipIf(判断条件, '跳过原因')</code></p> </li></ul>
</li>
</ul> 
<p>代码：</p> 
<pre><code>import unittest

# version = 30
version = 29


class TestDemo(unittest.TestCase):
    @unittest.skip('没有什么原因，就是不想执行')
    def test_01(self):
        print('测试方法01')

    @unittest.skipIf(version &gt;= 30, '版本大于 30，不用测试')
    def test_02(self):
        print('测试方法02')

    def test_03(self):
        print('测试方法03')
</code></pre> 
<h3>4.6 断言</h3> 
<p>介绍：</p> 
<ul>
<li> <p>概念：让程序代替人为判断测试程序执行结果是否符合预期结果的过程</p> </li>
<li> <p>作用：</p> 
  <ul>
<li> <p>1）提高写实效率</p> </li>
<li> <p>2）实现自动化测试（让脚本在无人值守状态下运行）</p> </li>
</ul>
</li>
<li> <p>断言结果：</p> 
  <ul>
<li> <p>True，用例通过</p> </li>
<li> <p>False，代码抛出异常，用例不通过</p> </li>
</ul>
</li>
<li> <p>说明：</p> 
  <ul>
<li> <p>1）UnitTest中提供了非常丰富的断言方法</p> </li>
<li> <p>2）复杂的断言方法在自动化测试中几乎使用不到，所以掌握几个常用的即可</p> </li>
<li> <p>3）在unittest中使用断言，都需要通过 self.断言方法 来使用</p> </li>
</ul>
</li>
</ul> 
<p>UnitTest断言方法：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c2/b8/vI7deEQA_o.png"></p> 
<p>self.assertEqual(预期结果, 实际结果)</p> 
<ul>
<li> <p>含义：判断预期结果和实际结果 是否相等</p> </li>
<li> <p>返回结果：如果相等，用例通过；如果不相等，用例不通过，抛出异常。</p> </li>
</ul> 
<p>self.assertIn(预期结果, 实际结果)</p> 
<ul>
<li> <p>含义：判断预期结果 是否包含 在实际结果中</p> </li>
<li> <p>结果：包含，用例通过；不包含，用例不通过，抛出异常。</p> </li>
</ul> 
<p>代码：</p> 
<pre><code>import unittest

from UnitTest_study.hm07_login import login


class TestLogin(unittest.TestCase):

    def test_uername_password_ok(self):
        """正确用户名和密码：admin，123456，登录成功"""
        self.assertEqual('登录成功', login('admin', '123456'))
</code></pre> 
<h3>4.7 参数化</h3> 
<p>介绍：</p> 
<ul>
<li> <p>好处：相似代码不需要多次书写</p> </li>
<li> <p>说明：</p> 
  <ul>
<li> <p>1）在测试方法中，使用 变量 来代替具体的测试数据，然后使用传参的方法将测试数据传递给方法的变量</p> </li>
<li> <p>2）unittest框架本身不支持 参数化，要使用参数化需要安装插件来完成</p> </li>
</ul>
</li>
<li> <p>场景：</p> 
  <ul>
<li> <p>1）测试数据一般放在 json 文件中</p> </li>
<li> <p>2）使用代码读取 json 文件，提取出符合要求格式的数据—&gt;&gt;<code>[(), ()]</code> 或 <code>[[], []]</code></p> </li>
</ul>
</li>
<li> <p>安装：<code>pip install parameterized</code></p> </li>
<li> <p>步骤：</p> 
  <ul>
<li> <p>1）导包 unittest，parameterized</p> </li>
<li> <p>2）定义测试类</p> </li>
<li> <p>3）书写测试方法（用到的测试数据使用变量代替）</p> </li>
<li> <p>4）组织测试数据并传参</p> </li>
</ul>
</li>
<li> <p>测试数据：</p> 
  <ul>
<li> <p>1）测试数据放在 json 文件中</p> </li>
<li> <p>2）新建函数读取 json文件中的 测试数据，读取的数据格式：<code>[(), (), ()] </code>或 <code>[[], [], []]</code></p> </li>
</ul>
</li>
</ul> 
<pre><code># 组织测试数据 [(), (), ()]
def build_data():
    with open('data.json', encoding='utf-8') as f:
        result = json.load(f)  # [{}, {}, {}]
        data = []
        for i in result:  # i -&gt; {}
            data.append((i.get('username'), i.get('password'), i.get('expect')))  # [(), (), ()]

    return data
</code></pre> 
<ul>
<li> <p>3）利用装饰器给函数变量传递数据</p> </li>
<li> <p><code>@parameterized.expand(build_data())</code></p> </li>
</ul> 
<p>代码示例1：</p> 
<pre><code>import unittest
from parameterized import parameterized
from UnitTest_study.hm07_login import login


# 组织测试数据 [(), (), ()]
data = [
    ('admin', '123456', '登录成功'),
    ('root', '123456', '登录失败'),
    ('admin', '123123', '登录失败')
]


# 定义测试类
class TestLogin(unittest.TestCase):

    # 书写测试方法（用到的测试数据使用变量代替）
    # 组织测试数据并传参（装饰器 @）
    @parameterized.expand(data)
    def test_login(self, username, password, expect):
        """正确用户名和密码：admin，123456，登录成功"""
        self.assertEqual(expect, login(username, password))
</code></pre> 
<p>代码示例2：</p> 
<p>测试数据文件： data.json</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/19/75/yThcaXDc_o.png"></p> 
<p>代码：</p> 
<pre><code>import json
import unittest
from parameterized import parameterized
from UnitTest_study.hm07_login import login


# 组织测试数据 [(), (), ()]
def build_data():
    with open('data.json', encoding='utf-8') as f:
        result = json.load(f)  # [{}, {}, {}]
        data = []
        for i in result:  # i -&gt; {}
            data.append((i.get('username'), i.get('password'), i.get('expect')))  # [(), (), ()]

    return data


# 定义测试类
class TestLogin(unittest.TestCase):

    # 书写测试方法（用到的测试数据使用变量代替）
    # 组织测试数据并传参（装饰器 @）
    @parameterized.expand(build_data())
    def test_login(self, username, password, expect):
        """正确用户名和密码：admin，123456，登录成功"""
        self.assertEqual(expect, login(username, password))
</code></pre> 
<h3>4.8 测试报告插件</h3> 
<p>自带的测试报告：</p> 
<p>只有单独运行 TestCase 的代码时，才会生成测试报告；位置在控制台左侧区域的右上角</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fb/dc/kMOofVs6_o.png"></p> 
<p>第三方测试报告：</p> 
<ul>
<li> <p>1）获取第三方的 测试运行类模块，并将其放在代码目录中</p> </li>
<li> <p>2）导包 unittest、HTMLTestRunner、HTMLTestReportCN</p> </li>
<li> <p>3）实例化 套件对象，并使用 加载套件加载用例</p> </li>
<li> <p>4）实例化 第三方的运行对象，运行 套件对象，并生成测试报告</p> </li>
</ul> 
<p>HTMLTestRunner 插件：</p> 
<ul><li> <p>HTMLTestRunner</p> </li></ul> 
<pre><code># 导包
import unittest
from UnitTest_study.HTMLTestRunner import HTMLTestRunner


suite = unittest.defaultTestLoader.discover('.', 'hm08_parameterized1.py')
file = 'report.html'
with open(file, 'wb') as f:
    runner = HTMLTestRunner(f, 2, '测试报告', 'python 3.7')
    runner.run(suite)
</code></pre> 
<ul><li> <p>HTMLTestRunnerCN</p> </li></ul> 
<pre><code># 导包
import unittest
from UnitTest_study.HTMLTestRunnerCN import HTMLTestReportCN


suite = unittest.defaultTestLoader.discover('.', 'hm08_parameterized1.py')

with open('report_CN.html', 'wb') as f:
    HTMLTestReportCN(f).run(suite)
</code></pre> 
<h3>4.9 总结</h3> 
<p>1）TestCase（测试用例）：组织用例文件（TestCase）里面，书写 跳过、断言、参数化，使用Fixture夹具；单个测试文件直接运行，可以得到测试报告；有多个测试文件运行，则需要组装运行生成测试报告。</p> 
<p>2、添加测试用例 到 测试套件中</p> 
<ul><li> <p>TestSuite（测试套件）：套件对象组装测试用例</p> </li></ul> 
<pre><code># 导包
import unittest
from UnitTest_study.hm01_unittest import TestDemo

# 实例化套件对象
suite = unittest.TestSuite()
# 方法1：单个添加测试用例（需要导包TestDemo）
suite.addTest(TestDemo('test_001'))
suite.addTest(TestDemo('test_002'))
# 方法2：批量添加测试用例（需要导包TestDemo）
suite.addTest(unittest.makeSuite(TestDemo))
</code></pre> 
<ul><li> <p>TestLoader（测试加载）：默认加载对象加载测试用例</p> </li></ul> 
<pre><code># 导包
import unittest

# 方法1：实例化对象并添加测试用例
suite = unittest.TestLoader().discover('case', 'hm*.py')
#  方法2：实例化对象并添加测试用例
suite = unittest.defaultTestLoader.discover('case', 'hm*.py')
# 运行测试套件
unittest.TextTestRunner().run(suite)
</code></pre> 
<p>3、实例化运行对象 运行 测试条件</p> 
<ul><li> <p>TestRunner（运行对象）</p> </li></ul> 
<pre><code># 导包
import unittest
# 实例化运行对象
runner = unittest.TextTestRunner()
# 运行测试套件
runner.run(suite)
</code></pre> 
<ul>
<li> <p>运行并生成测试报告</p> </li>
<li> <p>基本格式：</p> 
  <ul>
<li> <p><code>with open('./report.html', 'wb') as f:</code></p> </li>
<li> <p><code># 实例化第三方运行对象</code></p> </li>
<li> <p><code>第三方运行对象 = 第三方运行类(f)</code></p> </li>
<li> <p><code>第三方运行对象.run(套件对象)</code></p> </li>
</ul>
</li>
<li> <p>第三方运行类（文件对象(打开文件需要使用 wb 方式)）</p> 
  <ul><li> <p>HTMLTestRunner</p> </li></ul>
</li>
</ul> 
<pre><code>import unittest
from UnitTest_study.HTMLTestRunner import HTMLTestRunner


suite = unittest.defaultTestLoader.discover('.', 'hm08_parameterized1.py')
file = 'report.html'
with open(file, 'wb') as f:
    runner = HTMLTestRunner(f, 2, '测试报告', 'python 3.7')
    runner.run(suite)
</code></pre> 
<ul><li> <p>HTMLTestRunnerCN</p> </li></ul> 
<pre><code>import unittest
from UnitTest_study.HTMLTestRunnerCN import HTMLTestReportCN


suite = unittest.defaultTestLoader.discover('.', 'hm08_parameterized1.py')

with open('report_CN.html', 'wb') as f:
    runner = HTMLTestReportCN(f)
    runner.run(suite)
</code></pre> 
<h1>二、PyTest框架介绍</h1> 
<h2>1、什么是PyTest框架？</h2> 
<p>PyTest是python中一种单元测试框架，同自带的UnitTest测试框架类似，相比于UnitTest框架使用起来更简洁，效率更高。在自动化测试中充当测试执行的功能，并可以与UnitTest互换。</p> 
<h2>2、为什么使用PyTest框架？</h2> 
<ul>
<li> <p>1）非常容易上手，入门简单，文档丰富，文档中有很多实例可以参考，官方文档：<code>https://docs.pytest.org/en/6.2.x/</code></p> </li>
<li> <p>2）支持简单的单元测试和复杂的功能测试</p> </li>
<li> <p>3）支持参数化，UnitTest需要通过插件扩展参数化功能</p> </li>
<li> <p>4）执行测试过程中可以将某些测试跳过，或者对某些预期失败的Case标记成失败</p> </li>
<li> <p>5）支持重复执行失败的Case：通过安装插件实现</p> </li>
<li> <p>6）支持运行由Nose，UnitTest编写的测试Case。注：pytest框架的脚本在UnitTest下无法执行</p> </li>
<li> <p>7）具有很多第三方插件，并且可以自定义扩展。插件获取：<code>https://docs.pytest.org/en/latest/reference/plugin_list.html</code></p> </li>
<li> <p>8）方便的和持续集成工具集成</p> </li>
</ul> 
<h2>3、PyTest框架安装与基本使用</h2> 
<p>与UnitTest不同的是，pytest需要先安装才能使用。注意：如果pytest命令无法使用，则需要以管理员身份重新安装pytest。</p> 
<p>安装步骤：</p> 
<ul>
<li> <p>打开cmd窗口，输入命令：</p> </li>
<li> <p>安装：<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pytest</code></p> </li>
<li> <p>确认版本：<code>pytest --version</code></p> </li>
<li> <p>查看：<code>pip show pytest</code></p> </li>
</ul> 
<p>测试形式：</p> 
<ul>
<li> <p>测试函数形式</p> 
  <ul>
<li> <p>1）新建hm01.py文件，文件中编写函数名以test开头的测试函数</p> </li>
<li> <p>2）打开<code>Terminal</code>，切换到.py文件路径下，输入<code>pytest -s hm01.py</code></p> </li>
<li> <p>3）控制台查看执行结果</p> </li>
</ul>
</li>
<li> <p>测试类形式：</p> 
  <ul>
<li> <p>1）新建hm02.py文件，文件中编写类名以Test开头的测试类，测试方法名必须以 test 开头</p> </li>
<li> <p>2）打开<code>Terminal</code>，切换到.py文件路径下，输入<code>pytest -s hm02.py</code></p> </li>
<li> <p>3）控制台查看执行结果</p> </li>
</ul>
</li>
</ul> 
<p>运行方式：</p> 
<ul>
<li> <p>命令行模式【建议】</p> 
  <ul>
<li> <p>命令行中执行：<code>pytest -s 测试脚本文件</code></p> </li>
<li> <p>如：<code>pytest -s test_login.py</code></p> </li>
</ul>
</li>
<li> <p>主函数模式</p> 
  <ul><li> <p>在 测试脚本文件中增加主函数：</p> </li></ul>
</li>
</ul> 
<pre><code># 主函数模式基本格式：
if __name__ = '__main__':
    pytest.main(["-s", "文件名.py"])
#举例：在 test_login.py 文件中增加主函数：
if __name__ = '__main__':
    pytest.main(["-s", "test_login.py"])
</code></pre> 
<ul><li> <p>说明：</p> 
  <ul>
<li> <p>1）-s 表示支持控制台打印，如果不加，print不会出现任何内容</p> </li>
<li> <p>2）主函数模式需要导包 import pytest</p> </li>
</ul>
</li></ul> 
<h2>4、PyTest框架实践</h2> 
<h3>4.1 配置文件</h3> 
<p>介绍：</p> 
<ul><li> <p>场景：使用配置文件后可以快速的使用配置的项来选择执行哪些测试模块</p> </li></ul> 
<p>步骤：</p> 
<ul>
<li> <p>1）项目下新建scripts模块</p> </li>
<li> <p>2）将测试脚本文件放到scripts中</p> </li>
<li> <p>3）pytest的配置文件放在自动化项目目录下</p> </li>
<li> <p>4）名称为pytest.ini</p> </li>
<li> <p>5）命令行运行时会使用该配置文件中的配置</p> </li>
<li> <p>6）第一行内容为<code>[pytest]</code></p> </li>
</ul> 
<p>示例：</p> 
<ul>
<li> <p><code>[pytest]</code>  # 告知系统该文件的例行</p> </li>
<li> <p><code>testpaths = ./case</code>  # testpaths指定测试用例存放位置</p> </li>
<li> <p><code>addopts = -s</code>  # 添加pytest命令选项</p> </li>
<li> <p><code>python_files = test*.py</code>  # 指定测试脚本文件名前缀</p> </li>
<li> <p><code>python_classes = Test*</code>  # 指定测试类名前缀</p> </li>
<li> <p><code>python_functions = test*</code>  # 指定测试函数/测试方法名前缀</p> </li>
</ul> 
<p>注意：</p> 
<ul>
<li> <p>1、在Windows系统下，pytest配置文件中，不允许写注释信息</p> </li>
<li> <p>2、一个工程内只需要一个 <code>pytest.ini</code> 配置文件，并且需要保证文件名正确</p> </li>
<li> <p>3、一般情况，只需要将 pytest.ini 配置文件 置于工程根目录下</p> </li>
<li> <p>4、配置有 pytest.ini 配置文件的工程，只需要打开命令行输入 pytest 命令，即可执行测试（注意：必须要cd切换到和配置文件同一级的目录下输入pytest）</p> </li>
</ul> 
<p>默认配置：</p> 
<ul>
<li> <p>说明：测试用例文件名/测试类名/测试方法名均为 <code>Test/test开头</code>（没有配置文件的默认规则）</p> </li>
<li> <p>代码：</p> </li>
<li> <p><code>[pytest]</code></p> </li>
<li> <p><code>testpaths = ./case</code></p> </li>
<li> <p><code>addopts = -s</code></p> </li>
<li> <p><code>python_files = test*.py</code></p> </li>
<li> <p><code>python_classes = Test*</code></p> </li>
<li> <p><code>python_functions = test*</code></p> </li>
</ul> 
<p>自定义规则：</p> 
<ul>
<li> <p>说明：测试用例文件名/测试类名/测试方法名，需要根据具体项目进行设置，以下以Hm/hm为例</p> </li>
<li> <p>扩展：指定单个文件/类/方法执行，只需要在配置文件中写死即可</p> </li>
<li> <p>代码：</p> 
  <ul>
<li> <p><code>[pytest]</code></p> </li>
<li> <p><code>testpaths = ./case</code></p> </li>
<li> <p><code>addopts = -s</code></p> </li>
<li> <p><code>python_files = hm*.py</code></p> </li>
<li> <p><code>python_classes = Hm*</code></p> </li>
<li> <p><code>python_functions = hm*</code></p> </li>
</ul>
</li>
</ul> 
<h3>4.2 特殊方法</h3> 
<p>函数级别方法： <code>setup</code>和<code>teardown</code></p> 
<p>介绍：</p> 
<ul>
<li> <p>场景:</p> 
  <ul>
<li> <p>pytest在运行自动化脚本的前后会执行两个特殊的方法，分别setup和teardown。</p> </li>
<li> <p>在执行脚本之前会执行setup方法，在执行脚本之后会执行teardown方法。</p> </li>
<li> <p>有了这两个方法，我们可以在setup中进行获取驱动对象的操作，在teardown中进行关闭驱动对象的操作。</p> </li>
</ul>
</li>
<li> <p>说明：特殊方法名写法固定，没有代码提示，需要手写。</p> </li>
</ul> 
<p>代码格式：</p> 
<pre><code>import pytest


class TestDemo(object):
    """测试示例类"""

    def setup(self):
        """开始方法"""
        print("方法 -&gt; 开始")

    def teardown(self):
        """结束方法"""
        print("方法 -&gt; 结束")

    """
</code></pre> 
<p>举例：函数级别 <code>setup</code>、<code>teardown</code></p> 
<pre><code>"""
import pytest


class TestDemo(object):
    """测试示例类"""
    # 说明：特殊方法名写法固定，没有代码提示，需要手写。

    def setup(self):
        """开始方法"""
        print("函数 -&gt; 开始")

    def teardown(self):
        """结束方法"""
        print("函数 -&gt; 结束")

    def test_method1(self):
        """示例测试方法"""
        print("测试方法1")

    def test_method2(self):
        """示例测试方法"""
        print("测试方法2")


if __name__ == '__main__':
    pytest.main(['-s', 'hm05_pytest.py'])
</code></pre> 
<p>类级别方法： <code>setup_class</code>和<code>teardown_class</code></p> 
<p>介绍： 运行于测试类的始末，在一个测试内只运行一次setup_class和teardown_class，不关心测试类内有多少个测试函数</p> 
<p>代码格式：</p> 
<pre><code>import pytest


class TestDemo(object):
    """测试示例类"""

    def setup_class(self):
        """开始方法"""
        print("类 -&gt; 开始")

    def teardown_class(self):
        """结束方法"""
        print("类 -&gt; 结束")

    """
</code></pre> 
<p>举例：类级别 <code>setup_class</code>、<code>teardown_class</code></p> 
<pre><code>"""
import pytest


class TestDemo(object):
    """测试示例类"""
    # 说明：特殊方法名写法固定，没有代码提示，需要手写。

    def setup_class(self):
        """开始方法"""
        print("类 -&gt; 开始")

    def teardown_class(self):
        """结束方法"""
        print("类 -&gt; 结束")

    def test_method1(self):
        """示例测试方法"""
        print("测试方法1")

    def test_method2(self):
        """示例测试方法"""
        print("测试方法2")


if __name__ == '__main__':
    pytest.main(['-s', 'hm06_pytest.py'])
</code></pre> 
<p>举例：函数级别和类级别同时使用</p> 
<pre><code>"""
特殊方法：函数级别和类级别同时使用
"""
import pytest


class TestDemo(object):
    """测试示例类"""
    # 执行顺序：1 -&gt;3 -&gt;5 -&gt;4 -&gt;3 -&gt;6 -&gt;4 -&gt;2

    def setup_class(self):  # 1
        print("类级别 -&gt;&gt; 开始")

    def teardown_class(self):  # 2
        print("类级别 -&gt;&gt; 结束")

    def setup(self):  # 3
        print("函数级别 -&gt; 开始")

    def teardown(self):  # 4
        print("函数级别 -&gt; 结束")

    def test_method1(self):  # 5
        """示例测试方法"""
        print("测试方法1")

    def test_method2(self):  # 6
        """示例测试方法"""
        print("测试方法2")


if __name__ == '__main__':
    pytest.main(['-s', 'hm07_pytest.py'])
</code></pre> 
<h3>4.3 执行顺序插件</h3> 
<p>介绍：</p> 
<ul>
<li> <p>场景：现实生活中，如果想下订单，必须先登录，我们可以通过插件的形式来控制函数执行的顺序。</p> </li>
<li> <p>安装：<code>pip3 install pytest-ordering</code></p> </li>
<li> <p>使用：</p> 
  <ul>
<li> <p>1）标记于被测试函数，<code>@pytest.mark.run(order=x)</code></p> </li>
<li> <p>2）根据order传入的参数来解决运行顺序</p> </li>
<li> <p>3）order值全为正数或全为负数时，运行顺序：值越小，优先级越高</p> </li>
<li> <p>4）正数和负数同时存在：正数优先级高</p> </li>
<li> <p>5）控制方法执行顺序对测试类同样有效，使用方法一样</p> </li>
</ul>
</li>
<li> <p>格式：<code>@pytest.mark.run(order=x)</code></p> </li>
</ul> 
<p>代码：</p> 
<pre><code>"""
pytest 控制方法执行顺序插件
"""
import pytest

@pytest.mark.run(order=2)
class TestDemo1(object):
    """测试示例类"""

    # 语法：@pytest.mark.run(order=序号)
    # 注意：run(order=序号)没有代码提示，需要手写

    @pytest.mark.run(order=3)
    def test_method1(self):
        """示例测试方法"""
        print("测试方法1")

    @pytest.mark.run(order=1)
    def test_method2(self):
        """示例测试方法"""
        print("测试方法2")

    @pytest.mark.run(order=2)
    def test_method3(self):
        """示例测试方法"""
        print("测试方法3")

# 扩展：序号支持正数和负数，以及正负混合
# 1、纯正数：数越小，优先级越高【掌握】
# 2、纯负数：数越小，优先级越高【了解】
# 3、正负混合：正数先按照顺序执行，负数最后执行【了解】

# 注意：控制方法执行顺序对测试类同样有效
@pytest.mark.run(order=1)
class TestDemo2(object):
    """测试示例类"""

    def test_method(self):
        """示例测试方法"""
        print("测试类2 -&gt; 测试方法")


if __name__ == '__main__':
    pytest.main(['-s', 'hm08_pytest.py'])
</code></pre> 
<h3>4.4 失败重试插件</h3> 
<p>介绍：</p> 
<ul>
<li> <p>场景：自动化测试脚本可能会使用到网络，如果网络不好可能最终会使脚本不通过。像这种情况可能并不是脚本本身的问题，仅仅是因为网络忽快忽慢，那么我们可以使用失败重试的插件，当失败后尝试再次运行。一般情况最终成功可以视为成功，但最好进行排查看是否是脚本问题。</p> </li>
<li> <p>安装：<code>pip3 install pytest-rerunfailures</code></p> </li>
<li> <p>使用：在配置文件中的命令行参数中增加 <code>--reruns n</code></p> 
  <ul>
<li> <p><code>n</code>：为失败重试几次</p> </li>
<li> <p>如：<code>addopts = -s --html=./report/test_report.html --self-contained-html --reruns 3</code></p> </li>
</ul>
</li>
<li> <p>说明：</p> 
  <ul>
<li> <p>1）正式脚本一般设置不超过3次，测试脚本设置1次即可</p> </li>
<li> <p>2）当脚本执行报错时，会自动重新执行设置次数</p> </li>
</ul>
</li>
<li> <p>格式：<code>addopts = -s --reruns 3</code></p> </li>
</ul> 
<p>代码： 配置文件</p> 
<ul>
<li> <p><code>[pytest]</code></p> </li>
<li> <p><code>testpaths = ./case</code></p> </li>
<li> <p><code>addopts = -s --reruns 3</code></p> </li>
<li> <p><code>python_files = test*.py</code></p> </li>
<li> <p><code>python_classes = Test*</code></p> </li>
<li> <p><code>python_functions = test*</code></p> </li>
</ul> 
<h3>4.5 跳过</h3> 
<p>介绍:</p> 
<ul>
<li> <p>场景：同一个软件在不同的设备上可能会有不同的效果，比如，iOS的3d touch操作是需要6s以上设备支持的，6和6s都可以安装同一款应用，如果设备不支持，那根本没有必要去测试这个功能，此时，可以让这种函数进行跳过。</p> </li>
<li> <p>说明：同样支持跳过测试类，使用方式一样</p> </li>
<li> <p>格式：<code>@pytest.mark.skipif(condition, reason=None)</code></p> 
  <ul>
<li> <p>在需要跳过的测试脚本之上加上装饰器</p> </li>
<li> <p><code>condition</code> 跳过的条件，必传参数；</p> </li>
<li> <p><code>reason</code> 标注原因，必传参数</p> </li>
<li> <p>注意：<code>reason=</code> 不能省略，否则会报错！</p> </li>
</ul>
</li>
</ul> 
<p>代码：</p> 
<pre><code>@pytest.mark.skipif(condition, reason='xxx')
  """
pytest 跳过测试
"""
import pytest

version = 25  # 模拟软件版本号


class TestDemo(object):
    """测试示例类"""

    def test_method1(self):
        """示例测试方法"""
        print("测试方法1")

    # 注意：reason= 不能省略，否则会报错！
    @pytest.mark.skipif(version &gt;= 25, reason='当前版本不执行')
    def test_method2(self):
        """示例测试方法"""
        print("测试方法2")

    def test_method3(self):
        """示例测试方法"""
        print("测试方法3")


# 说明：同样可以跳过测试类
@pytest.mark.skipif(version &gt;= 25, reason='当前版本不执行')
class TestDemo2(object):
    """测试示例类"""

    def test_method(self):
        """示例测试方法"""
        print("测试类2-&gt;测试方法")


if __name__ == '__main__':
    pytest.main(['-s', 'hm09_pytest.py'])
</code></pre> 
<h3>4.6 断言</h3> 
<p>Python自带断言：</p> 
<ul>
<li> <p>预期相等：<code>assert 1 == 1</code></p> </li>
<li> <p>预期包含：<code>assert 'admin' in '欢迎 admin 归来！'</code></p> </li>
</ul> 
<p>代码：</p> 
<pre><code>import pytest


def add_func(num1, num2):
    """加法函数"""
    return num1 + num2


class TestDemo(object):
    """示例测试类"""
    # 调用被测函数
    result = add_func(1, 2)
    # 断言判断结果
    assert 3 == result
</code></pre> 
<h3>4.7 参数化</h3> 
<p>介绍：</p> 
<ul>
<li> <p>应用场景：登录功能都是输入用户名，输入密码，点击登录。但登录的用户名和密码如果想测试多个值是没有办法用普通的操作实现的。数据参数化可以帮我实现这样的效果。</p> </li>
<li> <p>格式：<code>@pytest.mark.parametrize(argnames, argvalues, indirect, ids=None, scope=None)</code></p> 
  <ul>
<li> <p>在需要参数化的测试脚本之上加上装饰器</p> </li>
<li> <p><code>argnames</code>：参数名</p> </li>
<li> <p><code>argvalues</code>：参数对应值，类型必须为可迭代类型，一般使用list</p> </li>
</ul>
</li>
</ul> 
<p>单个参数：</p> 
<ul>
<li> <p>介绍：</p> 
  <ul>
<li> <p>1）argnames为字符串类型，根据需求决定合适的参数名</p> </li>
<li> <p>2）argvalues为列表类型，根据需求决定列表元素中的内容</p> </li>
<li> <p>3）在测试脚本中，参数名字与argnames保持一致</p> </li>
<li> <p>4）在测试脚本中正常使用</p> </li>
</ul>
</li>
<li> <p>格式：<code>@pytest.mark.parametrize('参数变量', ['数值1', '数值2', ...])</code></p> </li>
<li> <p>代码：</p> </li>
</ul> 
<pre><code>"""
pytest 参数化功能：单个参数
"""
import pytest


class TestDemo(object):
    """示例测试类"""

    # @pytest.mark.parametrize('参数变量', ['数值1', '数值2', ...])
    @pytest.mark.parametrize('name', ['小米', '小新'])
    def test_method1(self, name):
        """示例测试方法"""
        print("获取的名字是：", name)


if __name__ == '__main__':
    pytest.main(['-s', 'hm10_pytest.py'])
</code></pre> 
<p>多个参数：</p> 
<ul>
<li> <p>介绍：</p> 
  <ul>
<li> <p>1）多个参数必须置于同一个字符串内！</p> </li>
<li> <p>2）数据格式必须是：<code>[(),()]</code>或者<code>[[], []]</code></p> </li>
</ul>
</li>
<li> <p>格式一：<code>@pytest.mark.parametrize('参数1, 参数n', [('数值1-1', '数值2-2'), ('数值2-1', '数值2-2'), ...])</code></p> </li>
<li> <p>格式二：<code>@pytest.mark.parametrize(('参数1', '参数n'), [('数值1-1', '数值2-2'), ('数值2-1', '数值2-2'), ...])</code></p> </li>
</ul> 
<p>代码示例1：</p> 
<pre><code>"""
pytest 参数化功能：多个参数
"""
import pytest


class TestDemo(object):
    """示例测试类"""
    @pytest.mark.parametrize('name, pwd', [('admin', 123456), ('test', 654321)])
    def test_method1(self, name, pwd):
        """示例测试方法"""
        print("账号：{} 的秘密是：{}".format(name, pwd))


if __name__ == '__main__':
    pytest.main(['-s', 'hm11_pytest.py'])
</code></pre> 
<p>代码示例2：</p> 
<pre><code>import pytest


def build_test_data():
    """构造测试数据函数"""
    # 中间代码略
    return [('admin', 123456), ('test', 654321), ('xxx', 'yyy')]


class TestDemo(object):
    """示例测试类"""

    # 通过方法引入数据，pytest中必须带小括号
    @pytest.mark.parametrize('name, pwd', build_test_data())
    def test_method1(self, name, pwd):
        """示例测试方法"""
        print("账号：{} 的秘密是：{}".format(name, pwd))
</code></pre> 
<h3>4.8 测试报告插件</h3> 
<p>介绍:</p> 
<ul>
<li> <p>应用场景：自动化测试脚本最终执行是通过还是不通过，需要通过测试报告进行体现。</p> </li>
<li> <p>安装:<code>pip3 install pytest-html</code></p> </li>
<li> <p>使用:在配置文件中的命令行参数中增加 <code>--html=用户路径/report.html</code></p> </li>
<li> <p>扩展：在 <code>--html</code> 后面加上 <code>--self-contained-html</code>，可以把CSS样式内嵌到html报告文件中（防止分享报告时丢失样式）</p> </li>
<li> <p>示例:</p> 
  <ul>
<li> <p><code>addopts = -s --html=./report/test_report.html</code></p> </li>
<li> <p><code>addopts = -s --html=./report/test_report.html --self-contained-html</code></p> </li>
</ul>
</li>
<li> <p>格式：<code>addopts = -s --html=./report/test_report.html --self-contained-html</code></p> </li>
</ul> 
<p>代码： 配置文件</p> 
<ul>
<li> <p><code>[pytest]</code></p> </li>
<li> <p><code>testpaths = ./case</code></p> </li>
<li> <p><code>addopts = -s --html=./report/test_report.html --self-contained-html</code></p> </li>
<li> <p><code>python_files = test*.py</code></p> </li>
<li> <p><code>python_classes = Test*</code></p> </li>
<li> <p><code>python_functions = test*</code></p> </li>
</ul> 
<h3>4.9 PyTest框架运行UnitTest的TestCase</h3> 
<p>在配置文件中把python_files的名字修改为TestCase测试用例的文件名(xxx.py)即可。</p> 
<h3>4.10 总结</h3> 
<p>配置文件：</p> 
<ul>
<li> <p>位置：<code>项目/pytest.ini</code></p> </li>
<li> <p>内容：</p> 
  <ul>
<li> <p><code>[pytest]</code></p> </li>
<li> <p><code>testpaths = ./case</code></p> </li>
<li> <p><code>addopts = -s --html=./report/test_report.html --self-contained-html --reruns 3</code></p> </li>
<li> <p><code>python_files = test*.py</code></p> </li>
<li> <p><code>python_classes = Test*</code></p> </li>
<li> <p><code>python_functions = test*</code></p> </li>
</ul>
</li>
</ul> 
<hr> 
<h1> 【最后可能给予你助力的自动化教程】</h1> 
<p><strong>最后感谢每一个认真阅读我文章的人，看着粉丝一路的上涨和关注，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走</strong><img alt="" height="541" src="https://images2.imgbox.com/f0/a3/3Qknyuz7_o.png" width="704"></p> 
<p></p> 
<h1>面试资料</h1> 
<p>我们学习软件测试必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。<img alt="" height="357" src="https://images2.imgbox.com/19/f3/EA5otsg0_o.png" width="720"></p> 
<p>上面是我整理的配套资源，这些资源对于软件测试的的朋友来说应该是最全面最完整的备战仓库，为了更好地整理每个模块，我也参考了很多网上的优质博文和项目，力求不漏掉每一个知识点，很多朋友靠着这些内容进行复习，拿到了BATJ等大厂的offer，这个仓库也已经帮助了很多的软件测试的学习者，希望也能帮助到你。</p> 
<p class="img-center"><img alt="" height="151" src="https://images2.imgbox.com/6b/45/bvQOCxK8_o.png" width="451"></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>