<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C语言详解 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h2 id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><a id="_0"></a></h2> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>这里是我对学C语言的一些总结，对于这几个月的学习进行一个复盘，共计1.2w字，希望对大家的学习能有帮助。</p> 
<div> 
 <ul>
<li>一<a href="#pandas_22">、</a>C语言入门</li>
<li>1.C语言的具体结构</li>
<li>2.程序的——注释</li>
<li>3.标识符</li>
<li>4.变量及赋值</li>
<li>
<a href="#_26">二、</a>C语言数据类型 
   <ul>
<li>
<a href="#1_27">1.</a>基本数据类型</li>
<li>
<a href="#2_41">2.</a>构造类型</li>
<li>3.指针类型</li>
<li>4.void类型</li>
</ul>
</li>
<li>三、C语言函数类型及指针2.0</li>
<li>1.函数的作用&amp;无参函数</li>
<li>2.有参函数</li>
<li>3.函数指针</li>
<li>4.指针函数</li>
<li>5.数组指针</li>
<li>6.指针数组</li>
<li>7.二级指针</li>
<li>8.void指针</li>
<li>9.静态链表</li>
<li>10.动态链表</li>
<li>四、各个关键字的用法</li>
<li>1.break</li>
<li>2.continue</li>
<li>3.static</li>
<li>4.extern</li>
<li>5,malloc</li>
<li>6.typedef</li>
<li>7.const</li>
<li>五、预编译&amp;条件编译</li>
<li>1.#define 无参</li>
<li>2.#define 有参</li>
<li>3.#if 条件编译</li>
<li>六、冒泡排序</li>
</ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_12"></a></h2> 
<h2 id="%E4%B8%80%E3%80%81pandas%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
<a id="pandas_22"></a>一、C语言入门</h2> 
<p>C语言的特点灵活方便，执行效率高，可移植性好，可以用来开发应用软件、驱动、操作系统等。</p> 
<h4><strong>1.C语言的具体结构</strong></h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    printf("Hallo World");
    
}</code></pre> 
<p>#include &lt;stdio.h&gt; 包含输入输出头文件，因为你要用到printf、scanf等这些函数，所以你要包含对应的头文件才能使用，否则会编译出错。</p> 
<p>void main()  main()是主函数，void是这个函数的类型<strong>，c程序代码的入口就是从main()开始执行的，也是c语言执行代码唯一的入口，是c程序中必不可少的存在</strong>。</p> 
<h4><strong>2.程序的——注释</strong></h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{

    //printf("Hallo World");
}</code></pre> 
<p>//表示注释这一行，在//后面的内容都不会执行，是写给程序员看的</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void mian()
{
    /*

        2021.12.26---------2022.6.21

    */
    
    printf("Hallo World");


}</code></pre> 
<p>  /*这里面的内容都不会被执行，也是写给程序员看的，可以一次性注释多行*/ </p> 
<h4><strong>3.标识符命名</strong></h4> 
<p></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int a  = 10;//给变量取名字也就是（标识符）
    int a1 = 10;//标识符只能用数字，字符，下划线组成
    int_a  = 10;//其中开头只能用字符和下划线


}</code></pre> 
<h4><strong>4.变量与赋值</strong></h4> 
<p>变量就是可以变化的量，每个变量都有一个（数据类型），变量会在内存中占据一定的存储单元，<strong>使用变量之前先定义所使用的数据类型，</strong>， 变量的名字可以自己取（不能取关键字等），变量的数据类型必须依靠c语言已有的来取。</p> 
<pre><code class="language-cpp">void main()
{

    int a          = 20;//定义了一个整型变量，同时给它赋值了一个20；
    float b        = 22;//定义了一个实型（单精度）变量，同时给它赋值了一个22；
    double c       = 6; //定义了一个实型（双精度）变量，同时给它赋值了一个6
    char   d       = '2';//定义了一个字符型型变量，同时给它赋值了一个字符2；
    unsigned int e = 1; //定义了一个无符号整型.....
    
}</code></pre> 
<p><strong>变量定义的一般形式：数据类型 变量名；</strong></p> 
<p><strong>一次性定义多个变量：数据类型 变量名，变量名...;</strong></p> 
<p><strong> 赋值分为两种：</strong></p> 
<p>1.先定义，在赋值</p> 
<p>2.定义同时一起赋值</p> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">
<a id="_26"></a>二、C语言数据类型</h2> 
<h3><strong>1.基本数据类型</strong></h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int     a; //int是整型，只能存放整数
    float   a1://float是实型，只能存放小数
    double  a2'//double是实型，只能存放小数
    char    a3;//char是字符型，只能存放字符以及字符串

}</code></pre> 
<p>int 用于存放整数，占4个字节（编译器不同可能也不一样）</p> 
<p>float 和 double 都是用于存放小数，float占4个字节，doule占8个字节</p> 
<p>char 用于存放字符，占1个字节</p> 
<h3><strong>2.构造数据类型</strong></h3> 
<h4><strong>数组类型</strong></h4> 
<p>数组从语义上说就是存放数据的一个集合。</p> 
<p>元素是数组内存里面存放的数据。</p> 
<p>下标是对应数组元素所在数组的位置。</p> 
<p>访问超过数组下标的元素，就越界了；</p> 
<p><strong><u>一维数组遍历</u></strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{

    int a[6] = {1,2,3,4,5,6};//a是数组的首地址也是第一个元素的地址也是数组名
                            //[6]表示数组存放元素的长度
    int _a[6] = {1,2,3};    //如果我数组长度写的6个，但是我赋值只有3个，那未初始化的数据就是0
    int i;

    for(i = 0;i &lt; 6;++i)
    {
        printf("%d",a[i]);
    }                        


}</code></pre> 
<p><strong><u>二维数组遍历</u></strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{

    int a[2][3]={<!-- -->{1,2,3},{4,5,6}};
    int i,j;    
    int *p ;
    p = a;

    for(i = 0;i &lt; 2;++i)
    {
        for(j = 0;j &lt; 3;++j)
        {
            printf("%d",a[i][j]);
        }                                                        
     }
}</code></pre> 
<h4> 结构体类型</h4> 
<p><strong>数组只能存放类型相同的数据的集合，而结构体就是可以存放类型不同的数据的一个集合</strong></p> 
<p><strong>结构体定义 ：struct 结构体名字{变量；变量；...}结构体变量；</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;//因为要用到strcpy

struct student      //struct表示这是个结构体 student是结构体名字 struct student组合起来就是一个新的数据类型 a是这个结构体的变量
{
    int num;     //定义结构体成员
    char score;
    char project[20];
}a;//定义结构体变量


void main()
{
    
  //struct student b;//也可以在这里定义结构体变量
  a.num  = 10;//给结构体成员赋值
  a.score = 'c';    
  strcpy(a.project,"李建华");

  printf("%d",a.num);//输出结构体num的数值
  printf("%c",a.score);
  printf("%s",a.project);

}</code></pre> 
<p><strong>typedf定义：typedf struct 结构体名字{变量；变量；...}typedf新的类型；p 结构体变量；</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;//因为要用到strcpy

typedef struct student      
{
    int num;     //定义结构体成员
    char score;
    char project[20];
}p;//struct student 是数据类型，typedf 数据类型 p，p就是（struct student）只是重新修改了而已


void main()
{
    
  p a;//在这里定义结构体变量
  a.num  = 10;//给结构体成员赋值
  a.score = 'c';    
  strcpy(a.project,"李建华");

  printf("%d",a.num);//输出结构体num的数值
  printf("%c",a.score);
  printf("%s",a.project);
}</code></pre> 
<p><strong>嵌套定义结构体</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

struct max1
{
    int num;

};


struct student      
{
  struct max1 b;//定义结构体变量 

}a;


void main()
{
    a.b.num = 100;
    printf("%d",a.b.num);
 
}</code></pre> 
<p><strong>结构体数组</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;



struct student      
{
    int num;

}a[2];//定义了一个结构体数组 每个元素都包含了一个成员项


void main()
{
    int i;
    a[0].num = 100;
    a[1].num = 200;
   

  for(i = 0;i &lt; 2;++i)
 {
    printf("%d",a[i].num);
 }
 
}</code></pre> 
<p><strong>怎样计算结构体所占的内存 </strong></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/91/86/2azSQhzJ_o.png" width="802"></p> 
<p>大家是不是以为，char+int+char =1+4+1 = 6，应该是6个字节，为什么是12呢？</p> 
<p>因为结构体内存讲究对齐法则</p> 
<p><img alt="" height="459" src="https://images2.imgbox.com/7b/b3/WTFbaMDN_o.jpg" width="669"></p> 
<p><strong>共用体类型</strong></p> 
<p><strong>为什么需要共用体？</strong>因为在以前的电脑内存是十分有限的，用结构体占用的内存太多了<strong>，用共用体可以节约内存，</strong>但是因为共用体里面的成员都用一块内存，所以共用体成员谁占的字节多，就用那块内存，你给共用体里面的成员都赋值，它也只会输出最后赋值的那个变量，因为前面赋的值都被后面赋的值给覆盖了。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

union job //union表示这是一个共用体 job共用体名字  
{
    int a ;     //共用体成员 
    short int b; 
        
};//也可以在这里定义共用体变量 



void main()
{
    union job p;//定义共用体变量 

    p . b = 100;//给共用体赋值 
    p . a = 1000; 

    printf("%d  ",p.a);//因为它们共用一块内存 前面赋的值 被后面赋的值覆盖了 它只会输出最后被赋值的变量  
  

}

//输出结果是：1000</code></pre> 
<p>注意：union 也是可以用typedef来定义；</p> 
<p><strong>枚举类型</strong></p> 
<p><strong>枚举用什么作用？</strong>通过枚举我们可以灵活定义成员里面的数据，用的时候方便取，也好调整成员里面的数据 ，<strong>#define一次性定义一个常量 enum可以一次性定义多个，大大提高了程序的可读性</strong>。</p> 
<p>输出枚举成员：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

enum Day{a,b,c,d}p;//enum表示这是个枚举类型 Day表示这是枚举的名字 p是枚举变量 
				  //里面存放的是枚举成员的常量 没有被赋值 第一个成员= 0，后面依次加1 
				 

void main()
{
	
	printf("%d",a);	//因为枚举成员是常量，所以可以直接拿出来输出
	printf("%d",b);	
	printf("%d",c);	
	printf("%d",d);		
	
	
}
  //输出结果:0 1 2 3</code></pre> 
<p><strong>既然可以直接输出枚举成员，那要枚举变量有什么用？</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
void main( ) 
{ 
	enum weekday {sun ,mon,tue,wed,thu,fri,sat} day; 
	
	int k; 
	printf("input a number(0--6)"); 
	scanf("%d",&amp;k);
	day=(enum weekday)k; //给enum变量赋值必须用强制转换  
	
	switch(day) //可以用于判断... 
	{ 
	case sun: printf("sunday/n");break; 
	case mon: printf("monday/n");break; 
	case tue: printf("tuesday/n");break; 
	case wed: printf("wednesday/n");break; 
	case thu: printf("thursday/n");break; 
	case fri: printf("friday/n");break;
	case sat: printf("satday/n");break; 
	default: printf("input error/n");break; 
	} 
} </code></pre> 
<p><strong>注意：enum里面定义的成员是用','隔开，而不是用分号 </strong></p> 
<p></p> 
<p></p> 
<h3><strong>3.指针类型</strong></h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int  a = 5;//定义了一个整型
    int *p;    //定义了一个指针变量，它所指向的数据是一个整型
              //int 是它所指向的类型，p是一个变量，*p是告诉编译器它是一个指针变量，用于存放地址
    p = &amp;a;   //p保持了a的地址，此时p指向a，*p就可以取a的值了


}</code></pre> 
<p><strong>注意：int* 、float*、 double* 、char*都是属于指针类型 </strong></p> 
<p>同时指针也可以指向数组</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int a[3] ={1,2,3};
    int i;
    int *p;
    p = a; //p保存了a的地址

   for(i = 0;i &lt; 3;++i)
   {
     printf("%d",*(p + i));//p保存了a的地址，p+1表示它指向下个地址，指向了a[1]，*(p+1)取a[1]的值
   }                      //因为数组存放地址是连续的，所以p+1就可以指向下个元素的地址
   

}</code></pre> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{

    int a[2][3]={<!-- -->{1,2,3},{4,5,6}};
    int i,j;    
    int *p ;
    p = a;

    for(i = 0;i &lt; 2;++i)
    {
        for(j = 0;j &lt; 3;++j)
        {
            printf("%d",*(*(p + i)+j));//行就是列的首地址，p保存了行的地址，*(p+i)是行的值也是列的首地址 (*(p+i)+j)就是第0行0列的地址，*(*(p+i)+j)就是第0行0列的数值
        }                                                        
     }
}</code></pre> 
<h4>结构体指针 </h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;//因为要用到strcpy

struct student      
{
    int num;     
    char score;
    char project[20];
}a,*p;


void main()
{
  p = &amp;a;//p指向这个地址  可以p-&gt;num访问 也可以 (*p).num
  a.num  = 10;
  a.score = 'c';    
  strcpy(a.project,"李建华");

  printf("%d",(*p).num);
  printf("%c",p-&gt;score);
  printf("%s",p-&gt;project);
}
</code></pre> 
<h3><strong>4.void类型 </strong></h3> 
<p><strong>C语言中的void类型，代表任意类型，而不是空的意思，而是说它的类型是未知的，是还没指定的。<br> void * 是void类型的指针。void类型的指针的含义是：这是一个指针变量，该指针指向一个<br> void类型的数。void类型的数就是说这个数有可能是int，也有可能是float，也有可能是个结构体，哪种类型都有可能，只是我当前不知道。</strong><br>  </p> 
<h2>三、C语言函数类型及指针2.0</h2> 
<p><strong>1.函数的作用&amp;无参函数</strong></p> 
<p><strong>函数有什么作用，我们来看代码来了解</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{

    int a,b,sum;
     
    a = 2;
    b = 3;    
    sum = a + b;
    printf("sum = %d",sum);
    


}</code></pre> 
<p>例如这段代码，我求的是2和3的和，要是我求其他数的和那我不得修改a和b的值，很麻烦，我们可以用函数来做，可以把函数的作用理解为，<strong>可以使程序模块化，避免了重复性操作。</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
	void p(int a,int b);//函数声明
    int a,b,sum;
    p(2,3);//调用这个函数并给他传2，3这两个数据
     
}

void p(int a,int b)//void表示函数的返回类型是没有指定的也就是无返回类型 p是函数名字 (int a,int b)这是函数的形参 用于接收实参的数据
{
    int sum;
    sum = a+b;
    printf("sum = %d",sum);
    
} 


//输出结果：5
</code></pre> 
<p><strong>函数可以嵌套调用， 但不可以嵌套定义 </strong></p> 
<h4><strong>2.有参函数</strong></h4> 
<p><strong>有参函数是可以返回数据，也可以选择不返回数据的，当然函数返回可以是表达式、变量、也可以是地址；</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

 main()
{
	int p(int a,int b);
    int a,b,sum;
    sum=p(2,3);
    printf("sum = %d",sum);
     
}

int p(int a,int b)//函数返回类型是int型，所以只能返回int类型的数据
{
    int sum;
    sum = a+b;
    
    //printf("sum = %d",sum);//有参函数，我可以返回，也可以不返回
    return sum;//把sum这个值返回调用的那里去
    
}

//输出结果; 5 

</code></pre> 
<h4>3. 函数指针</h4> 
<p>void （*p）(int a,int b);<strong>函数指针的本质其实就是一个指针，只不过这个指针指向的是一个函数</strong>，它通过指向了这个函数的地址，就可以实现调用这个函数。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    void f(int a,int b);
    void (*p)(int a,int b);//定义一下函数指针

    p = f;//p指向了函数的首地址，因为函数名就是函数首地址，所以加不加&amp;都可以
    (*p)(2,3);//*p调用这个地址，也可以直接用p调用
    

}        

void f(int a,int b)
{
    int sum;
    sum = a + b;
    printf("%d",sum);
    
        
}    

//输出结果：5                                                </code></pre> 
<h4>4.指针函数 </h4> 
<p>int *p(int *a,int *b);<strong>指针函数本质上就是一个函数，只不过这个函数返回类型是一个指针而已</strong>，我们可以通过指针来改写实参的地址。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int *f(int *a,int* b);
    int a,b;
    int* p;//定义一个指针用来接收返回的地址
    a = 2;
    b = 3;
    p =f(&amp;a,&amp;b);

    printf("%d",*p);
    
    
    

}        

int* f(int *a,int* b)
{
    int *p,*p1,*max;
    p = a;
    p1 = b;
    
    if(*p &gt; *p1)
    {
    	max = p;
	}
	else
	{
		max= p1;
	}
    
    
    return max;//返回最大的那个数 返回的类型是int型的
    
        
} 

//输出结果：3                                                   </code></pre> 
<h4> 5.数组指针</h4> 
<p>int (*a)[6];<strong>数组指针实际上就是一个指针，只不过这个指针指向的是数组</strong>， 一般多用于二维数组。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int b[2][3] = {1,2,3,4,5,6};
    int (*p)[3]; //[3]数组最大的元素长度 二维数组一般看列的长度 一维数组看行的长度 
    int i,j;  //用于输出二维数组 
    p =b;

    for(i = 0;i &lt; 2;++i)
    {
        for(j = 0;j &lt; 3;++j)
        {
            printf("%d",*(*(p+i)+j));//p保存了行的地址 
        }        
    }

  
}

//输出结果：1 2 3 4 5 6</code></pre> 
<h4>6.指针数组 </h4> 
<p>int* p[3];<strong>指针数组本质上就是一个数组，只不过这个数组存放的元素是指针</strong>。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
   int a,b,c;
   int*p[3];//定义了一个指针数组
   a = 2;
   b = 3;
   c = 4;
   p[0] = &amp;a;//数组里面的元素指向一个地址
   p[1] = &amp;b;
   p[2] = &amp;c;

	printf("%d",*p[0]); //输出指向地址的值
	printf("%d",*p[1]); 
	printf("%d",*p[2]); 
  
}</code></pre> 
<h4>7.二级指针 </h4> 
<p>int **p;二级指针，<strong>也就是指向指针的指针</strong>。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int a = 5;
    int *p =&amp;a;
    int**p1 = &amp;p;//指向这个指针 
    
    printf("%pn",p1);//p1的地址 
    printf("%pn",*p1);//a的地址 
    printf("%pn",&amp;a);//a的地址 
    printf("%dn",**p1);//a的值 
}</code></pre> 
<h4>8.void指针 </h4> 
<p>void *p;<strong>这个指针它所指向的数据类型是不确定的，但是你仍然可以让他指向一个地址</strong>，你要输出这个地址的值，就必须用强制转换成你要输出数据类型的指针。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int a = 5;
    void *p;
    p = &amp;a;//p指向这个地址 
    
    printf("%dn",*(int *)p);//因为这个数据是int类型的，所以要强制转换成对应类型的指针 
  
    
}

//输出结果：5</code></pre> 
<h4>9.静态链表 </h4> 
<h4>静态链表指的就是用一个头指针指向第一个地址、第一个地址保存下一个地址.....如图：</h4> 
<p><img alt="" height="352" src="https://images2.imgbox.com/cc/f4/E0KSYa9q_o.jpg" width="1200"></p> 
<p>1.head保存a的地址，<strong>a里面有两个数，一个是数据，一个是指针也称节点</strong>，a的节点保存b的数据，b的节点保存c的数据，c的节点保存d的数据，d的节点没有了也就是保存的null。<br> 2.为啥和数组一个功能都是指针指向一个地址再输出元素，数组不更好用吗？<br><strong>数组的地址是连续的，链表的地址不是连续的，是自己指针分配的，所以也叫静态链表</strong>。<br> 3.静态链表用法：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

typedef struct student
{
    int score;
    struct student *next;//创建一个节点 
}p;//重新定义了struct student这个类型 

void main()
{
  p a,b,c,d,*head; 
  a.score = 10;//给结构体变量赋值 
  b.score = 20;
  c.score = 30;
  d.score = 40;

  head = &amp;a;//头指针保存a的地址 
  a.next = &amp;b;//a的节点保存结构体变量b的地址 
  b.next = &amp;c;//b的节点保存结构体变量c的地址
  c.next = &amp;d;//c的节点保存结构体变量d的地址
  d.next = 'A';//给最后一个节点写个内容 用于判断节点是否已经遍历完成 

  while(head != 'A')//头指针如果没有保存最后一个节点的内容 就一直遍历 
    {
        printf("%d  ",head-&gt;score);//遍历score 
        head = head-&gt;next;//指向下一个节点 
    }       

}

//输出结果;10 20 30 40</code></pre> 
<h4>10.动态链表 </h4> 
<h2>
<strong>动态链表用来节约内存，用多少创建多少</strong>，把一些不连续的内存进行合好的利用，弥补了不联系内存的浪费。</h2> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

struct student
{
	int data;//数据 
	struct student *next;//节点 
	
 } ;
 
 
 struct student *Chuangjian()//创建节点函数 
 {
 	int a;//用于给数据赋值 
 	struct student *head,*last,*new;//定义头指针，尾指针，和创建新节点的指针 
 	head = (struct student *)malloc(sizeof(struct student));//头指针指向第一个节点 
 	last = head;//尾指针始终指向新的节点 
 	
 	scanf("%d",&amp;a);//给数据赋值 
 	
 	while(a != -1)//用于判断是否创建新的节点 ==-1是不创建新的节点 
 	{
 		new = (struct student*)malloc(sizeof(struct student));//创建新的节点 
 		new -&gt;data = a;//把刚刚的数据赋给data 
 		last -&gt; next = new;//第一个节点的next指向下一个节点的地址 
 		last = new;//last始终指向新的节点，用作于判断是否遍历完成 
 		
 		scanf("%d",&amp;a); 
	 }
	 
	 last -&gt; next = NULL;//用作于判断是否遍历完成
	 
 	return head;//返回头指针 
 }
 
 void print(struct student *p)//接收头指针 
 {
 	struct student *head;//创建一个指针用于接收头指针 
 	
 	head = p -&gt;next; //指向下一个地址，因为第一个地址只有next，没有数据 
 	
 	if (head == NULL )
 	{
 		printf("你还没有创建节点n");
	 }
 	
 	while(head != NULL)
 	{
 		printf("%d ",head-&gt;data);
 		head = head-&gt;next;
 		
	 }
 	
 	
 }
 
 
 
 
 void main()
 {
 	struct student *head =Chuangjian();//接收头指针 
	print(head); 
	 
 }
 void print(struct student *p)//接收头指针 
 {
 	struct student *head;//创建一个指针用于接收头指针 
 	
 	head = p -&gt;next;
 	
 	if (head == NULL )
 	{
 		printf("你还没有创建节点n");
	 }
 	
 	while(head != NULL)
 	{
 		printf("%d ",head-&gt;data);
 		head = head-&gt;next;
 		
	 }
 	
 	
 }
 
 
 
 
 void main()
 {
 	struct student *head =Chuangjian();//接收头指针 
	print(head);  //遍历头指针 
 }</code></pre> 
<h2>四、关键字的用法</h2> 
<p>1.break</p> 
<p>break<strong>用于打断循环，也就是执行到break，直接跳出循环，</strong>可以打断for，switch，while，do..while。</p> 
<p>break可以跳出for，但是如果用一个以上的for，则是打断离它最近的for</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int a =0;
    int sum = 0;
    int i;

    for(i =0 ;i &lt; 11;++i)
    {
        if(i ==11) //如果i==11 就跳出循环 
        {
           break;

        }
        
        sum =sum +i;
    }

	printf("%d",sum); 
}

//输出结果;55</code></pre> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int a =0;
    int sum = 0;
    int i,j;

    for(i =1 ;i &lt; 2;++i)
    {
    	 
        for(j = 0;j &lt; 11;++j) 
    	{
			 
           break;//只打破离break最近的for 
		   sum =sum +j;

	   }
 
 		sum = sum +i;
  }	

	printf("%d ",sum); 
}

输出结果：1</code></pre> 
<p>用于 switch的时候</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int a;
    
    printf("请输入你的楼层号：n");
	scanf("%d",&amp;a);
	
	switch(a)
	{
		case -1:
			printf("您已经到达-1层");//如果没有break，你输入1，后面所有楼层都会输出 
			break;
		case 1:
			printf("您已经到达1层");
			break;
		case 2:
			printf("您已经到达2层");
			break;
		case 3:
			printf("您已经到达3层");
			break;
		default :
		    printf("还未盖起来");
			break;
			 	
	 } 
    


}</code></pre> 
<p> 用于while&amp;&amp;do..while的时候</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int a = 2;
    
	while(a ) 
	{
	
	printf("hallo worldn");
	break;//本来可以执行两次hallo world，第一次输出后 就被打破了 所以就循环了一次 
	
	--a;
	}

}

输出结果:hallo world</code></pre> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
    int a = 2;
    
	do//do..while默认就执行一次 
	{
		printf("Hallo worldn");	
		break; 
		
	} while(a--);

}</code></pre> 
<p></p> 
<p>2.continue </p> 
<p>continue<strong>用于跳出本次循环，不是退出循环，而是只跳出本次的循环</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{
	int i = 1;
	 
	 for (i = 1; i &lt; 10; i++)
	 {
		  if (i == 5)
	  {
		   continue;//当i = 5的时候跳出本次循环，不执行 
	  }
		  printf("%d ", i);
	 }
	
	 
}



输出结果:1 2 3 4 6 7 8 9</code></pre> 
<p>3.static的用法</p> 
<p>static就两个作用：</p> 
<p>1.修饰全局变量，如果static修饰了全局变量，那只能在本工程使用，其他工程就不能调用了，</p> 
<p>2.修饰局部变量，它是存储在静态存储区的，用static修饰过后，就是函数执行结束，值依然在，如果static未被赋值，默认值就是 0；</p> 
<p>3.static修饰函数，函数也只能在本工程使用，其他工程不可调用。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void main()
{

	int a ; 
	a = f();
	
	printf("%dn",a);//a = 1 
	
	a = f();//第二次调用这个函数，i的值并没有消失 ，因为通过static修饰过后，i存在了静态存储器 
	
	printf("%dn",a);//a = 2 

	a = f();
	
	printf("%dn",a);//a = 3
	
	
 }
 
 int  f(int a)
 {
 	static int i  = 0;

	i++;
	
	return i;
  } 

输出结果:1 2 3 </code></pre> 
<h4>4.extern</h4> 
<p>extern 用来扩宽作用域的，可以通过extern来使用全局变量，也可以用于访问另一个工程。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
 
// 函数外定义变量 x 和 y
int x;
int y;
int addtwonum()
{
    // 函数内声明变量 x 和 y 为外部变量
    extern int x;
    extern int y;//本来用不到全局变量x,y，通过extern扩宽了作用域，使得能访问外部变量了 
    x = 1;
    y = 2;
    
    return x+y;
}
 
int main()
{
    int result;
    // 调用函数 addtwonum
    result = addtwonum();
    
    printf("result 为: %d",result);
    return 0;
}


输出结果:3</code></pre> 
<h4><strong>5.malloc</strong></h4> 
<p><strong>malloc可以手动分配动态内存，避免了内存的浪费，可以以用malloc手动分配地址。</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void main()
{
	int *p;
	int i;
	p = (int *)malloc(8);//给指针p分配了8g字节，也就是两个int 
	
	*(p+0) = 20;//给第一个4个字节赋值 
	*(p+1) = 30;//给第二个4个字节赋值  因为malloc分配的地址是连续的 
	
	printf("%d",*(p+1));
    printf("%d",*(p));
	  
}

输出结果:30 20</code></pre> 
<h4><strong>6.typedef</strong></h4> 
<p><strong>C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。起别名的目的不是为了提高程序运行效率，而是为了编码方便。</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void main()
{
	typedef int a;//把int这个数据类型，改写成了a
	a b = 2; 
	
	printf("%d",b); 
	  
}

输出结果: 2</code></pre> 
<h4>7.const </h4> 
<p>1.<strong>对变量声明只读特性，保护变量值以防被修改</strong></p> 
<p>2.<strong>节省空间，避免不必要的内存分配</strong>。const修饰的变量在程序运行过程中只有一份拷贝。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;


void main()
{
	int b = 4;
	const int a = 5;//const修饰了a这个变量，所以只能读，不能被改写，const无视数据类型，int consst a = 5 ;== const int a =5; 
	//a = 10;//error
	
	//const int*p =&amp;a;//const 修饰了*p   == int const *p =&amp;a 
	//p = &amp;b;   //可以继续指向地址，但是不能改写地址的内容 
	//*p = 4;  //error
	
	//int*const p =&amp;b;
	//*p = 4; //可以改写它内容里面的值，但是不能让他重新指向地址了
    //p = &amp;a; //error
    
    const int * const p =&amp;b;//p不能指向其他地址，*p也不能改写内存的数值 
	
	
	  
}</code></pre> 
<p></p> 
<h4></h4> 
<h2>五、预编译&amp;条件编译</h2> 
<h4>1.#define 无参</h4> 
<p>#define <strong>既不是定义，也不是声明，所以是不分配内存的</strong>，#define说白了就是替换的意思。</p> 
<p><strong>#define 宏名 字符串</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#define N 52

void main()
{
    int a;
	a = N; 
	
	printf("%d",a); 
	  
}

输出结果:52</code></pre> 
<h4>2.#define 有参</h4> 
<p>带参就是跟函数一样可以代替一些操作。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#define N(y) ((y)*(y)) //如果不带括号结果就是160

void main()
{
    int a;
	a = 160/N(2);//为什么结果不是40，而是160？这里计算过程 160/2*2 因为没有括号是先除在乘的 
	
	printf("%d",a); 
	  
}

输出结果:40</code></pre> 
<h4>3.#if条件编译</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#define N 1

void main()
{
	
	#if N  //如果是真就执行下面的语句， 
	
	printf("李建华");
	
	#else //不满足真就执行下面的语句， 
	
	printf("李珍");
	
	#endif//条件编译结束的意思 没有这个if else 不成立 
	
	printf("iverson"); 
	  
}</code></pre> 
<blockquote> 
 <p>运行结果：只要是1，李建华就会一直在</p> 
</blockquote> 
<h3 id="2.%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE">
<a id="2_41"></a>六、冒泡排序</h3> 
<p>代码如下（示例）：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt; 

void main()
{
	 int n[10] = { 25,35,68,79,21,13,98,7,16,62 };//定义一个大小为10的数组
	 int i, j, temp;
	 
	 for (i = 1; i &lt;= 9; i++)//外层循环是比较的轮数，数组内有10个数，那么就应该比较10-1=9轮
	 {
	  
	  for (j = 0; j &lt;= 9 - i; j++)//内层循环比较的是当前一轮的比较次数，例如：第一轮比较9-1=8次，第二轮比较9-2=7次
	  {
	   
	   if (n[j] &gt; n[j + 1])//相邻两个数如果逆序，则交换位置
	   {
	    temp = n[j];
	    n[j] = n[j + 1];
	    n[j + 1] = temp;
	   
	   }
	  
	  }
	
	 }
	
	 printf("排序过后的数顺序:n");
	 for (i = 0; i &lt; 10; i++)
	 printf("%4d", n[i]);
	
}


</code></pre> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_55"></a></h2>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>