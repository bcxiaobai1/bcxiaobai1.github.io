<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>字节跳动面试官：请你实现一个大文件上传和断点续传 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">字节跳动面试官：请你实现一个大文件上传和断点续传</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <h1>前言</h1> 
<p>这段时间面试官都挺忙的，频频出现在博客文章标题，虽然我不是特别想蹭热度，但是实在想不到好的标题了-。-，蹭蹭就蹭蹭 :)</p> 
<p>事实上我在面试的时候确实被问到了这个问题，而且是一道在线 coding 的编程题，当时虽然思路正确，可惜最终也并不算完全答对</p> 
<p>结束后花了一段时间整理了下思路，那么究竟该如何实现一个大文件上传，以及在上传中如何实现断点续传的功能呢？</p> 
<p>本文将从零搭建前端和服务端，实现一个大文件上传和断点续传</p> 
<p>前端：<code>Vue@2</code> + <a href="https://link.juejin.cn?target=https%3A%2F%2Felement.eleme.io%2F%23%2Fen-US" title="Element-ui">Element-ui</a></p> 
<p>服务端：<code>Nodejs@14</code> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fmultiparty" title="multiparty">multiparty</a></p> 
<h1>大文件上传</h1> 
<h2>整体思路</h2> 
<h3>前端</h3> 
<p>前端大文件上传网上的大部分文章已经给出了解决方案，核心是<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">利用 Blob.prototype.slice</span></code></span> 方法，和数组的 slice 方法相似，文件的 slice 方法可以返回<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">原文件的某个切片</span></code></span></p> 
<p>预先定义好单个切片大小，将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片。这样从原本传一个大文件，变成了<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">并发</span></code></span>传多个小的文件切片，可以大大减少上传时间</p> 
<p>另外由于是并发，传输到服务端的顺序可能会发生变化，因此我们还需要给每个切片记录顺序</p> 
<h3>服务端</h3> 
<p>服务端负责接受前端传输的切片，并在接收到所有切片后<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">合并</span></code></span>所有切片</p> 
<p>这里又引伸出两个问题</p> 
<ol>
<li>何时合并切片，即切片什么时候传输完成</li>
<li>如何合并切片</li>
</ol>
<p>第一个问题需要前端配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并。或者也可以额外发一个请求，主动通知服务端进行切片的合并</p> 
<p>第二个问题，具体如何合并切片呢？这里可以使用 Nodejs 的 读写流（readStream/writeStream），将所有切片的流传输到最终文件的流里</p> 
<p><span style="color:#fe2c24"><code><span style="background-color:#fef2f0">talk is cheap,show me the code</span></code></span>，接着我们用代码实现上面的思路</p> 
<h2>前端部分</h2> 
<p>前端使用 Vue 作为开发框架，对界面没有太大要求，原生也可以，考虑到美观使用 Element-ui 作为 UI 框架</p> 
<h3>上传控件</h3> 
<p>首先创建选择文件的控件并监听 change 事件，另外就是上传按钮</p> 
<pre><code class="language-html">&lt;template&gt;
   &lt;div&gt;
    &lt;input type="file" @change="handleFileChange" /&gt;
    &lt;el-button @click="handleUpload"&gt;upload&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
export default {
  data: () =&gt; ({
    container: {
      file: null
    }
  }),
  methods: {
     handleFileChange(e) {
      const [file] = e.target.files;
      if (!file) return;
      Object.assign(this.$data, this.$options.data());
      this.container.file = file;
    },
    async handleUpload() {}
  }
};
&lt;/script&gt;
</code></pre> 
<p><img alt="" height="79" src="https://images2.imgbox.com/96/dd/LM4z71QP_o.png" width="190"></p> 
<p> </p> 
<h3>请求逻辑</h3> 
<p>考虑到通用性，这里没有用第三方的请求库，而是用原生 XMLHttpRequest 做一层简单的封装来发请求</p> 
<pre><code class="language-javascript">request({
      url,
      method = "post",
      data,
      headers = {},
      requestList
    }) {
      return new Promise(resolve =&gt; {
        const xhr = new XMLHttpRequest();
        xhr.open(method, url);
        Object.keys(headers).forEach(key =&gt;
          xhr.setRequestHeader(key, headers[key])
        );
        xhr.send(data);
        xhr.onload = e =&gt; {
          resolve({
            data: e.target.response
          });
        };
      });
    }
</code></pre> 
<h3>上传切片</h3> 
<p>接着实现比较重要的上传功能，上传需要做两件事</p> 
<ul>
<li>对文件进行切片</li>
<li>将切片传输给服务端</li>
</ul>
<p> </p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;input type="file" @change="handleFileChange" /&gt;
    &lt;el-button @click="handleUpload"&gt;上传&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
+ // 切片大小
+ // the chunk size
+ const SIZE = 10 * 1024 * 1024; 
​
export default {
  data: () =&gt; ({
    container: {
      file: null
    }，
+   data: []
  }),
  methods: {
    request() {},
    handleFileChange() {},
+    // 生成文件切片
+    createFileChunk(file, size = SIZE) {
+     const fileChunkList = [];
+      let cur = 0;
+      while (cur &lt; file.size) {
+        fileChunkList.push({ file: file.slice(cur, cur + size) });
+        cur += size;
+      }
+      return fileChunkList;
+    },
+   // 上传切片
+    async uploadChunks() {
+      const requestList = this.data
+        .map(({ chunk，hash }) =&gt; {
+          const formData = new FormData();
+          formData.append("chunk", chunk);
+          formData.append("hash", hash);
+          formData.append("filename", this.container.file.name);
+          return { formData };
+        })
+        .map(({ formData }) =&gt;
+          this.request({
+            url: "http://localhost:3000",
+            data: formData
+          })
+        );
+      // 并发请求
+      await Promise.all(requestList); 
+    },
+    async handleUpload() {
+      if (!this.container.file) return;
+      const fileChunkList = this.createFileChunk(this.container.file);
+      this.data = fileChunkList.map(({ file }，index) =&gt; ({
+        chunk: file,
+        // 文件名 + 数组下标
+        hash: this.container.file.name + "-" + index
+      }));
+      await this.uploadChunks();
+    }
  }
};
&lt;/script&gt;
</code></pre> 
<p>当点击上传按钮时，调用 <span style="color:#fe2c24"><code><span style="background-color:#fef2f0">createFileChunk</span></code><span style="background-color:#fef2f0"> </span></span>将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说一个 100 MB 的文件会被分成 10 个 10MB 的切片</p> 
<p>createFileChunk 内使用 while 循环和 slice 方法将切片放入 <span style="color:#fe2c24"><code><span style="background-color:#fef2f0">fileChunkList</span></code><span style="background-color:#fef2f0"> </span></span>数组中返回</p> 
<p>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">文件名 + 下标</span></code></span>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片</p> 
<p>随后调用 <span style="color:#fe2c24"><code><span style="background-color:#fef2f0">uploadChunks</span></code><span style="background-color:#fef2f0"> </span></span>上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 formData 中，再调用上一步的 <span style="color:#fe2c24"><code><span style="background-color:#fef2f0">request</span></code><span style="background-color:#fef2f0"> </span></span>函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片</p> 
<h3>发送合并请求</h3> 
<p>使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并</p> 
<p>前端发送额外的合并请求，服务端接受到请求时合并切片</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;input type="file" @change="handleFileChange" /&gt;
    &lt;el-button @click="handleUpload"&gt;upload&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
export default {
  data: () =&gt; ({
    container: {
      file: null
    },
    data: []
  }),
  methods: {
    request() {},
    handleFileChange() {},
    createFileChunk() {},
    async uploadChunks() {
      const requestList = this.data
        .map(({ chunk，hash }) =&gt; {
          const formData = new FormData();
          formData.append("chunk", chunk);
          formData.append("hash", hash);
          formData.append("filename", this.container.file.name);
          return { formData };
        })
        .map(({ formData }) =&gt;
          this.request({
            url: "http://localhost:3000",
            data: formData
          })
        );
      await Promise.all(requestList);
+     // 合并切片
+     await this.mergeRequest();
    },
+    async mergeRequest() {
+      await this.request({
+        url: "http://localhost:3000/merge",
+        headers: {
+          "content-type": "application/json"
+        },
+        data: JSON.stringify({
+          filename: this.container.file.name
+        })
+      });
+    },    
    async handleUpload() {}
  }
};
&lt;/script&gt;
</code></pre> 
<p> </p> 
<h2>服务端部分</h2> 
<p>使用 http 模块搭建一个简单服务端</p> 
<pre><code class="language-javascript">const http = require("http");
const server = http.createServer();
​
server.on("request", async (req, res) =&gt; {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "*");
  if (req.method === "OPTIONS") {
    res.status = 200;
    res.end();
    return;
  }
});
​
server.listen(3000, () =&gt; console.log("listening port 3000"));
</code></pre> 
<h3>接受切片</h3> 
<p>使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fmultiparty" title="multiparty">multiparty</a> 处理前端传来的 formData</p> 
<p>在 multiparty.parse 的回调中，files 参数保存了 formData 中文件，fields 参数保存了 formData 中非文件的字段</p> 
<pre><code class="language-javascript">const http = require("http");
const path = require("path");
+ const fse = require("fs-extra");
+ const multiparty = require("multiparty");
​
const server = http.createServer();
+ // 大文件存储目录
+ const UPLOAD_DIR = path.resolve(__dirname, "..", "target");
​
server.on("request", async (req, res) =&gt; {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "*");
  if (req.method === "OPTIONS") {
    res.status = 200;
    res.end();
    return;
  }
​
+  const multipart = new multiparty.Form();
​
+  multipart.parse(req, async (err, fields, files) =&gt; {
+    if (err) {
+      return;
+    }
+    const [chunk] = files.chunk;
+    const [hash] = fields.hash;
+    const [filename] = fields.filename;
+    // 创建临时文件夹用于临时存储 chunk
+    // 添加 chunkDir 前缀与文件名做区分
+    const chunkDir = path.resolve(UPLOAD_DIR, 'chunkDir' + filename);
​
+    if (!fse.existsSync(chunkDir)) {
+      await fse.mkdirs(chunkDir);
+    }
​
+    // fs-extra 的 rename 方法 windows 平台会有权限问题
+    // @see https://github.com/meteor/meteor/issues/7852#issuecomment-255767835
+    await fse.move(chunk.path, `${chunkDir}/${hash}`);
+    res.end("received file chunk");
+  });
});
​
server.listen(3000, () =&gt; console.log("listening port 3000"));
</code></pre> 
<p> <img alt="" height="161" src="https://images2.imgbox.com/41/b0/e4mK04SY_o.png" width="847"></p> 
<p> </p> 
<p>查看 multiparty 处理后的 chunk 对象，path 是存储临时文件的路径，size 是临时文件大小，在 multiparty 文档中提到可以使用 fs.rename（这里换成了 fs.remove, 因为 fs-extra 的 rename 方法在 windows 平台<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmeteor%2Fmeteor%2Fissues%2F7852%23issuecomment-255767835" title="存在权限问题">存在权限问题</a>）</p> 
<p>在接受文件切片时，需要先创建临时存储切片的文件夹，以 chunkDir 作为前缀，文件名作为后缀</p> 
<p>由于前端在发送每个切片时额外携带了唯一值 hash，所以以 hash 作为文件名，将切片从临时路径移动切片文件夹中，最后的结果如下</p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/31/d4/D9vVZWvM_o.png" width="696"></p> 
<p> </p> 
<h3>合并切片</h3> 
<p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p> 
<pre><code class="language-javascript">const http = require("http");
const path = require("path");
const fse = require("fs-extra");
​
const server = http.createServer();
const UPLOAD_DIR = path.resolve(__dirname, "..", "target");
​
+ const resolvePost = req =&gt;
+   new Promise(resolve =&gt; {
+     let chunk = "";
+     req.on("data", data =&gt; {
+       chunk += data;
+     });
+     req.on("end", () =&gt; {
+       resolve(JSON.parse(chunk));
+     });
+   });
​
+ // 写入文件流
+ const pipeStream = (path, writeStream) =&gt;
+  new Promise(resolve =&gt; {
+    const readStream = fse.createReadStream(path);
+    readStream.on("end", () =&gt; {
+      fse.unlinkSync(path);
+      resolve();
+    });
+    readStream.pipe(writeStream);
+  });
​
// 合并切片
+ const mergeFileChunk = async (filePath, filename, size) =&gt; {
+   const chunkDir = path.resolve(UPLOAD_DIR, 'chunkDir' + filename);
+   const chunkPaths = await fse.readdir(chunkDir);
+   // 根据切片下标进行排序
+   // 否则直接读取目录的获得的顺序会错乱
+   chunkPaths.sort((a, b) =&gt; a.split("-")[1] - b.split("-")[1]);
+   // 并发写入文件
+   await Promise.all(
+     chunkPaths.map((chunkPath, index) =&gt;
+       pipeStream(
+         path.resolve(chunkDir, chunkPath),
+         // 根据 size 在指定位置创建可写流
+         fse.createWriteStream(filePath, {
+           start: index * size,
+         })
+       )
+     )
+  );
+  // 合并后删除保存切片的目录
+  fse.rmdirSync(chunkDir);
+};
​
server.on("request", async (req, res) =&gt; {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "*");
  if (req.method === "OPTIONS") {
    res.status = 200;
    res.end();
    return;
  }
​
+   if (req.url === "/merge") {
+     const data = await resolvePost(req);
+     const { filename,size } = data;
+     const filePath = path.resolve(UPLOAD_DIR, `${filename}`);
+     await mergeFileChunk(filePath, filename);
+     res.end(
+       JSON.stringify({
+         code: 0,
+         message: "file merged success"
+       })
+     );
+   }
​
});
​
server.listen(3000, () =&gt; console.log("listening port 3000"));
</code></pre> 
<p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹</p> 
<p>接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是上传时的文件名</p> 
<p>随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中</p> 
<p>值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start 控制的，目的是能够并发合并多个可读流至可写流中，这样即使并发时流的顺序不同，也能传输到正确的位置</p> 
<p>所以还需要让前端在请求的时候提供之前设定好的 size 给服务端，服务端根据 size 指定可读流的起始位置</p> 
<pre><code class="language-javascript">   async mergeRequest() {
      await this.request({
        url: "http://localhost:3000/merge",
        headers: {
          "content-type": "application/json"
        },
        data: JSON.stringify({
+         size: SIZE,
          filename: this.container.file.name
        })
      });
    },
</code></pre> 
<p><img alt="" height="132" src="https://images2.imgbox.com/4e/47/1BDDzxeu_o.png" width="573"></p> 
<p> </p> 
<p>其实也可以等上一个切片合并完后再合并下个切片，这样就不需要指定位置，但传输速度会降低，所以使用了并发合并的手段</p> 
<p>接着只要保证每次合并完成后删除这个切片，等所有切片都合并完毕后最后删除切片文件夹即可</p> 
<p><img alt="" height="119" src="https://images2.imgbox.com/1e/c1/X8bfB3GR_o.png" width="437"></p> 
<p> </p> 
<p>至此一个简单的大文件上传就完成了，接下来我们再此基础上扩展一些额外的功能</p> 
<h2>显示上传进度条</h2> 
<p>上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现单个切片的进度条</p> 
<h3>单个切片进度条</h3> 
<p>XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件</p> 
<pre><code class="language-javascript"> // xhr
    request({
      url,
      method = "post",
      data,
      headers = {},
+     onProgress = e =&gt; e,
      requestList
    }) {
      return new Promise(resolve =&gt; {
        const xhr = new XMLHttpRequest();
+       xhr.upload.onprogress = onProgress;
        xhr.open(method, url);
        Object.keys(headers).forEach(key =&gt;
          xhr.setRequestHeader(key, headers[key])
        );
        xhr.send(data);
        xhr.onload = e =&gt; {
          resolve({
            data: e.target.response
          });
        };
      });
    }
</code></pre> 
<p>由于每个切片都需要触发独立的监听事件，所以需要一个工厂函数，根据传入的切片返回不同的监听函数</p> 
<p>在原先的前端上传逻辑中新增监听函数部分</p> 
<pre><code class="language-javascript">    // 上传切片，同时过滤已上传的切片
    async uploadChunks(uploadedList = []) {
      const requestList = this.data
+       .map(({ chunk,hash,index }) =&gt; {
          const formData = new FormData();
          formData.append("chunk", chunk);
          formData.append("hash", hash);
          formData.append("filename", this.container.file.name);
+         return { formData,index };
        })
+       .map(({ formData,index }) =&gt;
          this.request({
            url: "http://localhost:3000",
            data: formData，
+           onProgress: this.createProgressHandler(this.data[index]),
          })
        );
      await Promise.all(requestList);
      await this.mergeRequest();
    },
    async handleUpload() {
      if (!this.container.file) return;
      const fileChunkList = this.createFileChunk(this.container.file);
      this.data = fileChunkList.map(({ file }，index) =&gt; ({
        chunk: file,
+       index,
        hash: this.container.file.name + "-" + index
+       percentage:0
      }));
      await this.uploadChunks();
    }    
+   createProgressHandler(item) {
+      return e =&gt; {
+        item.percentage = parseInt(String((e.loaded / e.total) * 100));
+      };
+   }
</code></pre> 
<p>每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可</p> 
<h3>总进度条</h3> 
<p>将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 的计算属性</p> 
<pre><code class="language-javascript">  computed: {
       uploadPercentage() {
          if (!this.container.file || !this.data.length) return 0;
          const loaded = this.data
            .map(item =&gt; item.size * item.percentage)
            .reduce((acc, cur) =&gt; acc + cur);
          return parseInt((loaded / this.container.file.size).toFixed(2));
        }
 }
</code></pre> 
<p>最终展示如下</p> 
<p><img alt="" height="312" src="https://images2.imgbox.com/1e/10/vNbbpVgz_o.png" width="933"></p> 
<p> </p> 
<h1>断点续传</h1> 
<p>断点续传的原理在于前端/服务端需要<span style="color:#fe2c24"><strong><code>记住</code></strong></span>已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</p> 
<ul>
<li>前端使用 localStorage 记录已上传的切片 hash</li>
<li>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片</li>
</ul>
<p>第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选后者</p> 
<h2>生成 hash</h2> 
<p>无论是前端还是服务端，都必须要生成文件和切片的 hash，<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">之前我们使用文件名 + 切片下标作为切片 hash</span></code></span>，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">根据文件内容生成 hash</span></code></span>，所以我们修改一下 hash 的生成规则</p> 
<blockquote> 
 <p>webpack 的产物 contenthash 也是基于这个思路实现的</p> 
</blockquote> 
<p>这里用到另一个库 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fspark-md5" title="spark-md5">spark-md5</a>，它可以根据文件内容计算出文件的 hash 值</p> 
<p>另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">引起 UI 的阻塞</span></code></span>，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互</p> 
<p>由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">importScripts</span></code><span style="background-color:#fef2f0"> </span></span>函数用于导入外部脚本，通过它导入 spark-md5</p> 
<pre><code class="language-javascript">// /public/hash.js
​
// 导入脚本
self.importScripts("/spark-md5.min.js");
​
// 生成文件 hash
self.onmessage = e =&gt; {
  const { fileChunkList } = e.data;
  const spark = new self.SparkMD5.ArrayBuffer();
  let percentage = 0;
  let count = 0;
  const loadNext = index =&gt; {
    const reader = new FileReader();
    reader.readAsArrayBuffer(fileChunkList[index].file);
    reader.onload = e =&gt; {
      count++;
      spark.append(e.target.result);
      if (count === fileChunkList.length) {
        self.postMessage({
          percentage: 100,
          hash: spark.end()
        });
        self.close();
      } else {
        percentage += 100 / fileChunkList.length;
        self.postMessage({
          percentage
        });
        // calculate recursively
        loadNext(count);
      }
    };
  };
  loadNext(0);
};
</code></pre> 
<p>在 worker 线程中，接受文件切片 fileChunkList，利用 fileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程</p> 
<blockquote> 
 <p>spark-md5 文档中要求传入所有切片并算出 hash 值，不能直接将整个文件放入计算，否则即使不同文件也会有相同的 hash</p> 
</blockquote> 
<p>接着编写主线程与 worker 线程通讯的逻辑</p> 
<pre><code class="language-javascript">+    // 生成文件 hash（web-worker）
+    calculateHash(fileChunkList) {
+      return new Promise(resolve =&gt; {
+        // 添加 worker 属性
+        this.container.worker = new Worker("/hash.js");
+        this.container.worker.postMessage({ fileChunkList });
+        this.container.worker.onmessage = e =&gt; {
+          const { percentage, hash } = e.data;
+          this.hashPercentage = percentage;
+          if (hash) {
+            resolve(hash);
+          }
+        };
+      });
    },
    async handleUpload() {
      if (!this.container.file) return;
      const fileChunkList = this.createFileChunk(this.container.file);
+     this.container.hash = await this.calculateHash(fileChunkList);
      this.data = fileChunkList.map(({ file }，index) =&gt; ({
+       fileHash: this.container.hash,
        chunk: file,
        hash: this.container.file.name + "-" + index,
        percentage:0
      }));
      await this.uploadChunks();
    }   
</code></pre> 
<p>主线程使用 <span style="color:#fe2c24"><code><span style="background-color:#fef2f0">postMessage</span></code><span style="background-color:#fef2f0"> </span></span>给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 postMessage 事件拿到文件 hash</p> 
<p>加上显示计算 hash 的进度条，看起来像这样</p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/df/13/JLqYipF5_o.png" width="809"> 至此前端需要将之前用文件名作为 hash 的地方改写为 worker 返回的 hash</p> 
<p> <img alt="" height="359" src="https://images2.imgbox.com/6c/76/NhBaDej0_o.png" width="865"></p> 
<p> 服务端则使用固定前缀 + hash 作为切片文件夹名，hash + 下标作为切片名，hash + 扩展名作为文件名<img alt="" height="479" src="https://images2.imgbox.com/b0/20/czm0zSw4_o.png" width="685"></p> 
<p><img alt="" height="106" src="https://images2.imgbox.com/80/b6/gTuCmhRM_o.png" width="727"> </p> 
<h2>文件秒传</h2> 
<p>在实现断点续传前先简单介绍一下文件秒传</p> 
<p>所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">再次上传</span></code></span>时会直接提示上传成功</p> 
<p>文件秒传需要依赖上一步生成的 hash，即在<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">上传前</span></code></span>，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p> 
<pre><code class="language-javascript">+    async verifyUpload(filename, fileHash) {
+       const { data } = await this.request({
+         url: "http://localhost:3000/verify",
+         headers: {
+           "content-type": "application/json"
+         },
+         data: JSON.stringify({
+           filename,
+           fileHash
+         })
+       });
+       return JSON.parse(data);
+     },
   async handleUpload() {
      if (!this.container.file) return;
      const fileChunkList = this.createFileChunk(this.container.file);
      this.container.hash = await this.calculateHash(fileChunkList);
+     const { shouldUpload } = await this.verifyUpload(
+       this.container.file.name,
+       this.container.hash
+     );
+     if (!shouldUpload) {
+       this.$message.success("skip upload：file upload success");
+       return;
+    }
     this.data = fileChunkList.map(({ file }, index) =&gt; ({
        fileHash: this.container.hash,
        index,
        hash: this.container.hash + "-" + index,
        chunk: file,
        percentage: 0
      }));
      await this.uploadChunks();
    }   
</code></pre> 
<p> 秒传其实就是给用户看的障眼法，实质上根本没有上传</p> 
<p> <img alt="" height="94" src="https://images2.imgbox.com/9c/e4/CYlh5do2_o.png" width="536"></p> 
<p>服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可 </p> 
<p> </p> 
<pre><code class="language-javascript">+ // 提取后缀名
+ const extractExt = filename =&gt;
+  filename.slice(filename.lastIndexOf("."), filename.length);
const UPLOAD_DIR = path.resolve(__dirname, "..", "target");
​
const resolvePost = req =&gt;
  new Promise(resolve =&gt; {
    let chunk = "";
    req.on("data", data =&gt; {
      chunk += data;
    });
    req.on("end", () =&gt; {
      resolve(JSON.parse(chunk));
    });
  });
​
server.on("request", async (req, res) =&gt; {
  if (req.url === "/verify") {
+    const data = await resolvePost(req);
+    const { fileHash, filename } = data;
+    const ext = extractExt(filename);
+    const filePath = path.resolve(UPLOAD_DIR, `${fileHash}${ext}`);
+    if (fse.existsSync(filePath)) {
+      res.end(
+        JSON.stringify({
+          shouldUpload: false
+        })
+      );
+    } else {
+      res.end(
+        JSON.stringify({
+          shouldUpload: true
+        })
+      );
+    }
  }
});
​
server.listen(3000, () =&gt; console.log("listening port 3000"));
</code></pre> 
<p> </p> 
<h2>暂停上传</h2> 
<p>讲完了生成 hash 和文件秒传，回到断点续传</p> 
<p>断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传</p> 
<p>原理是使用 XMLHttpRequest 的 <span style="color:#fe2c24"><code><span style="background-color:#fef2f0">abort</span></code><span style="background-color:#fef2f0"> </span></span>方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p> 
<pre><code class="language-javascript">   request({
      url,
      method = "post",
      data,
      headers = {},
      onProgress = e =&gt; e,
+     requestList
    }) {
      return new Promise(resolve =&gt; {
        const xhr = new XMLHttpRequest();
        xhr.upload.onprogress = onProgress;
        xhr.open(method, url);
        Object.keys(headers).forEach(key =&gt;
          xhr.setRequestHeader(key, headers[key])
        );
        xhr.send(data);
        xhr.onload = e =&gt; {
+          // 将请求成功的 xhr 从列表中删除
+          if (requestList) {
+            const xhrIndex = requestList.findIndex(item =&gt; item === xhr);
+            requestList.splice(xhrIndex, 1);
+          }
          resolve({
            data: e.target.response
          });
        };
+        // 暴露当前 xhr 给外部
+        requestList?.push(xhr);
      });
    },
</code></pre> 
<p>这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了</p> 
<p><img alt="" height="791" src="https://images2.imgbox.com/8b/f6/M2eaKW8F_o.png" width="748"> </p> 
<p> </p> 
<p>每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">正在上传切片的 xhr</span></code></span></p> 
<p>之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片</p> 
<pre><code class="language-javascript"> handlePause() {
    this.requestList.forEach(xhr =&gt; xhr?.abort());
    this.requestList = [];
}
</code></pre> 
<p><img alt="" height="71" src="https://images2.imgbox.com/0e/12/Unjjpftg_o.png" width="248"></p> 
<p> 点击暂停按钮可以看到 xhr 都被取消了<img alt="" height="229" src="https://images2.imgbox.com/d8/e3/GaDKr827_o.png" width="738"></p> 
<h2>恢复上传</h2> 
<p>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传</p> 
<p>由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果</p> 
<p>而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p> 
<ul>
<li>服务端已存在该文件，不需要再次上传</li>
<li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把<strong>已上传</strong>的文件切片返回给前端</li>
</ul>
<p>所以我们改造一下之前文件秒传的服务端验证接口</p> 
<pre><code class="language-javascript">const extractExt = filename =&gt;
  filename.slice(filename.lastIndexOf("."), filename.length);
const UPLOAD_DIR = path.resolve(__dirname, "..", "target");
​
const resolvePost = req =&gt;
  new Promise(resolve =&gt; {
    let chunk = "";
    req.on("data", data =&gt; {
      chunk += data;
    });
    req.on("end", () =&gt; {
      resolve(JSON.parse(chunk));
    });
  });
  
+ // 返回已上传的所有切片名
+ const createUploadedList = async fileHash =&gt;
+   fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))
+    ? await fse.readdir(path.resolve(UPLOAD_DIR, fileHash))
+    : [];
​
server.on("request", async (req, res) =&gt; {
  if (req.url === "/verify") {
    const data = await resolvePost(req);
    const { fileHash, filename } = data;
    const ext = extractExt(filename);
    const filePath = path.resolve(UPLOAD_DIR, `${fileHash}${ext}`);
    if (fse.existsSync(filePath)) {
      res.end(
        JSON.stringify({
          shouldUpload: false
        })
      );
    } else {
      res.end(
        JSON.stringify({
          shouldUpload: true，
+         uploadedList: await createUploadedList(fileHash)
        })
      );
    }
  }
});
​
server.listen(3000, () =&gt; console.log("listening port 3000"));
</code></pre> 
<p> </p> 
<p>接着回到前端，前端有两个地方需要调用验证的接口</p> 
<ul>
<li>点击上传时，检查是否需要上传和已上传的切片</li>
<li>点击暂停后的恢复上传，返回已上传的切片</li>
</ul>
<p>新增恢复按钮并改造原来上传切片的逻辑</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div id="app"&gt;
      &lt;input
        type="file"
        @change="handleFileChange"
      /&gt;
       &lt;el-button @click="handleUpload"&gt;upload&lt;/el-button&gt;
       &lt;el-button @click="handlePause" v-if="isPaused"&gt;pause&lt;/el-button&gt;
+      &lt;el-button @click="handleResume" v-else&gt;resume&lt;/el-button&gt;
      //...
    &lt;/div&gt;
&lt;/template&gt;
​
+   async handleResume() {
+      const { uploadedList } = await this.verifyUpload(
+        this.container.file.name,
+        this.container.hash
+      );
+      await this.uploadChunks(uploadedList);
    },
    async handleUpload() {
      if (!this.container.file) return;
      const fileChunkList = this.createFileChunk(this.container.file);
      this.container.hash = await this.calculateHash(fileChunkList);
+     const { shouldUpload, uploadedList } = await this.verifyUpload(
+       this.container.file.name,
+       this.container.hash
+     );
+     if (!shouldUpload) {
+       this.$message.success("skip upload：file upload success");
+       return;
+     }
      this.data = fileChunkList.map(({ file }, index) =&gt; ({
        fileHash: this.container.hash,
        index,
        hash: this.container.hash + "-" + index,
        chunk: file，
        percentage: 0
      }));
+      await this.uploadChunks(uploadedList);
    },
    // 上传切片，同时过滤已上传的切片
+   async uploadChunks(uploadedList = []) {
      const requestList = this.data
+       .filter(({ hash }) =&gt; !uploadedList.includes(hash))
        .map(({ chunk, hash, index }) =&gt; {
          const formData = new FormData();
          formData.append("chunk", chunk);
          formData.append("hash", hash);
          formData.append("filename", this.container.file.name);
          formData.append("fileHash", this.container.hash);
          return { formData, index };
        })
        .map(({ formData, index }) =&gt;
          this.request({
            url: "http://localhost:3000",
            data: formData,
            onProgress: this.createProgressHandler(this.data[index]),
            requestList: this.requestList
          })
        );
      await Promise.all(requestList);
+     // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时合并切片
+     if (uploadedList.length + requestList.length === this.data.length) {
         await this.mergeRequest();
+     }
    }
</code></pre> 
<p><img alt="" height="58" src="https://images2.imgbox.com/47/f2/hpagtdo1_o.png" width="294"> </p> 
<p> </p> 
<p>这里给原来上传切片的函数新增 uploadedList 参数，即上图中服务端返回的切片名列表，通过 filter 过滤掉已上传的切片，并且由于新增了已上传的部分，所以之前合并接口的触发条件做了一些改动</p> 
<p>到这里断点续传的功能基本完成了</p> 
<h2>进度条改进</h2> 
<p>虽然实现了断点续传，但还需要修改一下进度条的显示规则，否则在暂停上传/接收到已上传切片时的进度条会出现偏差</p> 
<h3>单个切片进度条</h3> 
<p>由于在点击上传/恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100%</p> 
<pre><code class="language-javascript">   async handleUpload() {
      if (!this.container.file) return;
      const fileChunkList = this.createFileChunk(this.container.file);
      this.container.hash = await this.calculateHash(fileChunkList);
      const { shouldUpload, uploadedList } = await this.verifyUpload(
        this.container.file.name,
        this.container.hash
      );
      if (!shouldUpload) {
        this.$message.success("skip upload：file upload success");
        return;
      }
      this.data = fileChunkList.map(({ file }, index) =&gt; ({
        fileHash: this.container.hash,
        index,
        hash: this.container.hash + "-" + index,
        chunk: file,
+       percentage: uploadedList.includes(index) ? 100 : 0
      }));
      await this.uploadChunks(uploadedList);
    },
</code></pre> 
<p> </p> 
<p>uploadedList 会返回已上传的切片，在遍历所有切片时判断当前切片是否在已上传列表里即可</p> 
<h3>总进度条</h3> 
<p>之前说到总进度条是一个计算属性，根据所有切片的上传进度计算而来，这就遇到了一个问题</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/e6/41/5hW5lwV1_o.png" width="870"> </p> 
<p>点击暂停会取消并清空切片的 xhr 请求，此时如果已经上传了一部分，就会发现文件进度条有<span style="color:#fe2c24"><code><span style="background-color:#fef2f0">倒退</span></code></span>的现象 <img alt="" height="274" src="https://images2.imgbox.com/e7/38/0M9gdVdu_o.png" width="875"></p> 
<p>当点击恢复时，由于重新创建了 xhr 导致切片进度清零，所以总进度条就会倒退</p> 
<p>解决方案是创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条</p> 
<p>这里我们使用 Vue 的监听属性</p> 
<pre><code class="language-javascript">  data: () =&gt; ({
+    fakeUploadPercentage: 0
  }),
  computed: {
    uploadPercentage() {
      if (!this.container.file || !this.data.length) return 0;
      const loaded = this.data
        .map(item =&gt; item.size * item.percentage)
        .reduce((acc, cur) =&gt; acc + cur);
      return parseInt((loaded / this.container.file.size).toFixed(2));
    }
  },  
  watch: {
+    uploadPercentage(now) {
+      if (now &gt; this.fakeUploadPercentage) {
+        this.fakeUploadPercentage = now;
+      }
    }
  },
</code></pre> 
<p> </p> 
<p>当 uploadPercentage 即真的文件进度条增加时，fakeUploadPercentage 也增加，一旦文件进度条后退，假的进度条只需停止即可</p> 
<p>至此一个大文件上传 + 断点续传的解决方案就完成了</p> 
<h1>总结</h1> 
<p>大文件上传</p> 
<ul>
<li>前端上传大文件时使用 Blob.prototype.slice 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li>
<li>服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件</li>
<li>原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听</li>
<li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</li>
</ul>
<p>断点续传</p> 
<ul>
<li>使用 spark-md5 根据文件内容算出文件 hash</li>
<li>通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）</li>
<li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传</li>
<li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传</li>
</ul>
<h1>源代码</h1> 
<p>源代码增加了一些按钮的状态，交互更加友好，文章表达比较晦涩的地方可以跳转到源代码查看</p> 
<p><span style="color:#fe2c24"><strong>file-upload 源码</strong></span></p> 
<p><a class="link-info has-card" href="https://download.csdn.net/download/weixin_42232156/85465685" title="file-upload"><span class="link-card-box"><span class="link-title">file-upload</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/01/48/wCanvK1o_o.png" alt="icon-default.png?t=M4AD">https://download.csdn.net/download/weixin_42232156/85465685</span></span></a></p> 
<p></p> 
<p>谢谢观看 :)</p> 
<p> </p> 
<p> </p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>