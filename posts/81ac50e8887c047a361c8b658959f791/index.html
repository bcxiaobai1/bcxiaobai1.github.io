<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Java后端面试八股文汇总 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java后端面试八股文汇总</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h2>
<a id="Java_0"></a>一、Java基础</h2> 
<h3>
<a id="1Java_1"></a>1.Java语言具有那些特点？</h3> 
<ol>
<li>Java为纯面向对象的语言。它能够直接反映现实生活中的对象</li>
<li>具有平台无关性。java利用Java虚拟机运行字节码，无论是在Windows、linux还是MacOS等其他平台对Java程序进行编译，编译后的程序可以在其他平台运行</li>
<li>Java为解释性语言，编码器把Java代码编译成平台无关的中间代码，然后在JVM上解释运行，具有很好的可移植性</li>
<li>Java提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器</li>
<li>Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制，去除了C++中难以理解的指针特性</li>
<li>Java语言提供了对Web应用开发的支持</li>
</ol> 
<h3>
<a id="2_9"></a>2.面向对象的三大特性？</h3> 
<ol>
<li>继承：一个新类可以从现有的类中派生，派生类可以从它的基类那里继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。</li>
<li>封装：将客观事务抽象成类，每个类可以把自身的数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏</li>
<li>多态：指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为。且上转型后子类方法覆盖父类方法呈现多态。</li>
</ol> 
<h3>
<a id="3Java_14"></a>3.字节序定义以及Java属于哪种字节序？</h3> 
<p>字节序是指多字节数据在计算机内存中存储或网络传输时各字节的存储顺序。通常由小端和大端两种方式。</p> 
<ol>
<li>小端：低位字节存放在内存的低地址端，高位字节存放在内存的高地址端</li>
<li>大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端</li>
</ol> 
<p>Java语言的字节序是大端</p> 
<h3>
<a id="4JDKJRE_21"></a>4.JDK与JRE有什么区别？</h3> 
<p>JDK：Java开发工具包（Java Development Kit），提供了Java的开发环境和运行环境<br> JRE：Java运行环境（Java Runtime Environment），提供了Java运行所需的环境</p> 
<p>JDK包含了JRE。如果只运行Java程序，安装JRE即可。要编写Java程序需安装JDK</p> 
<h3>
<a id="5Java_27"></a>5.简述Java访问修饰符</h3> 
<p>default：默认访问修饰符，在同一包内可见<br> private：在同一类内可见，不能修饰类<br> protected：对同一包内的类和所有子类可见，不能修饰类<br> public：对所有类可见</p> 
<h3>
<a id="6_33"></a>6.构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？</h3> 
<p>先后顺序：静态成员变量、成员变量、构造方法<br> 详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数</p> 
<h3>
<a id="7_37"></a>7.接口和抽象类的相同点和区别？</h3> 
<p>相同点：<br> 1.都不能被实例化<br> 2.接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化</p> 
<p>不同点：<br> 1.接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现<br> 2.实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但只能继承一个抽象类<br> 3.当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法。</p> 
<h3>
<a id="8Java_47"></a>8.为什么Java语言不支持多重继承？</h3> 
<ol>
<li>为了程序的结构能够更加清晰从而便于维护。假设Java语言支持多重继承，类C继承自类A和类B，如果类A和B都有自定义的成员方法f(),那么当代码中调用类C的f()会产生二义性。Java语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类C继承接口A与接口B时即使他们都有方法f()，也不能直接调用方法，需实现具体的f()方法才能调用，不会产生二义性。</li>
<li>多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。</li>
</ol> 
<h3>
<a id="9Java_51"></a>9.Java提供的多态机制？</h3> 
<p>Java提供了两种用于多态的机制，分别是重载与覆盖<br> 1.重载：重载是指同一个类中有多个同名的方法，但这些方法有着不同的参数，因此在编译时就可以确定到底调用哪个方法，它是一种编译时多态。重载可以被看作一个类中的方法多态性。<br> 2.覆盖：子类可以覆盖父类的方法，因此同样的方法会在父类与子类中有着不同的表现形式。在 Java 语言中，基类的引用变量不仅可以指向基类的实例对象，也可以指向其子类的实例对象。同样，接口的引用变量也可以指向其实现类的实例对象，而程序调用的方法在运行期才动态绑定(绑定指的是将一个方法调用和一个方法主体连接到一起)，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。通过这种动态绑定的方法实现了多态。由于只有在运行时才能确定调用哪个方法，因此通过方法覆盖实现的多态也可以被称为运行时多态。</p> 
<h3>
<a id="10_56"></a>10.重载与覆盖的区别？</h3> 
<ol>
<li>覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系</li>
<li>覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系</li>
<li>覆盖要求参数列表相同；重载要求参数列表不同</li>
<li>覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体</li>
<li>重载方法可以改变返回值的类型；覆盖方法不能改变返回值的类型</li>
</ol> 
<h3>
<a id="11finalfinallyfinalize_63"></a>11.final、finally和finalize的区别是什么？</h3> 
<ol>
<li>final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。</li>
<li>finally作为异常处理的一部分，只能在try/catch语句中使用，finally附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。</li>
<li>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。</li>
</ol> 
<h3>
<a id="12Javafinally_68"></a>12.出现在Java程序中的finally代码块是否一定会执行？</h3> 
<p>当遇到下面情况不会执行。<br> 1.当程序在进入try语句块之前就出现异常时会直接结束。<br> 2.当程序在try块中强制退出时，如使用System.exit(0)，也不会执行finally块中的代码。</p> 
<p>其它情况下，在try/catch/finally语句执行的时候，try块先执行，当有异常发生，catch和finally进行处理后程序就结束了，当没有异常发生，在执行完finally中的代码后，后面代码会继续执行。值得注意的是，当try/catch语句块中有return时，finally语句块中的代码会在return之前执行。如果try/catch/finally块中都有return语句，finally块中的return语句会覆盖try/catch模块中的return语句。</p> 
<h3>
<a id="13Javastatic_75"></a>13.Java语言中关键字static的作用是什么？</h3> 
<p>static的主要作用有两个：<br> 1.为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。<br> 2.使得某个方法或属性与类关联在一起而不是对象，在不创建对象的情况下可通过类直接调用方法或使用类的属性。</p> 
<p>具体而言static又可分为4种使用方式：<br> 1.修饰成员变量。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用’‘类.静态变量’‘和’‘对象.静态变量’'的方法使用。<br> 2.修饰成员方法。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法。<br> 3.修饰代码块。JVM在加载类的时候会执行static代码块。static代码块常用于初始化静态变量。static代码块只会被执行一次。<br> 4.修饰内部类。static内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。</p> 
<h3>
<a id="14Java_86"></a>14.Java代码块执行顺序</h3> 
<ol>
<li>父类静态代码块（只执行一次）</li>
<li>子类静态代码块（只执行一次）</li>
<li>父类构造代码块</li>
<li>父类构造函数</li>
<li>子类构造代码块</li>
<li>子类构造函数</li>
<li>普通代码块</li>
</ol> 
<h3>
<a id="15Java_95"></a>15.Java中一维数组和二维数组的声明方式？</h3> 
<p>一维数组的声明方式：<br> 1.type arrayName[]<br> 2.type[] arrayName</p> 
<p>二维数组的声明方式：<br> 1.type arrayName[][]<br> 2.type[][] arrayName<br> 3.type[] arrayName[]</p> 
<p>其中type为基本数据类型或类，arrayName为数组名字</p> 
<h3>
<a id="16StringStringBuffer_107"></a>16.String和StringBuffer有什么区别？</h3> 
<p>String用于字符串操作，属于不可变类。String对象一旦被创建，其值将不能被改变。而StringBuffer是可变类，当对象创建后，仍然可以对其值进行修改。</p> 
<h3>
<a id="17equals_110"></a>17.判等运算符==与equals的区别？</h3> 
<p>== 比较的是引用，equals比较的是内容。</p> 
<ol>
<li>如果变量是基础数据类型，== 用于比较其对应值是否相等。如果变量指向的是对象,== 用于比较两个对象是否指向同一块存储空间。</li>
<li>equals是Object类提供的方法之一，每个Java类都继承自Object类，所以每个对象都具有equals这个方法。Object类中定义的equals方法内部是直接调用 == 比较对象的。但通过覆盖的方法可以让它不是比较引用而是比较数据内容。需保证equals方法相同对应的对象hashCode也相同。</li>
</ol> 
<h3>
<a id="18String_116"></a>18.为什么要把String设计为不变量？</h3> 
<ol>
<li>节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。</li>
<li>提高效率:String会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。</li>
<li>安全：String常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。</li>
</ol> 
<h3>
<a id="19_121"></a>19.序列化是什么？</h3> 
<p>序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象。</p> 
<h3>
<a id="20JavaClass_124"></a>20.简述Java中Class对象</h3> 
<p>java中对象可以分为实例对象和Class对象，每一个类都有一个Class对象，其包含了与该类有关的信息。<br> 获取Class对象的方法：</p> 
<ul>
<li>Class.forName(“类的全限定名”)</li>
<li>实例对象.getClass()</li>
<li>类名.class</li>
</ul> 
<h3>
<a id="21Java_131"></a>21.Java反射机制是什么？</h3> 
<p>Java反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。反射机制使得Java具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射API。</p> 
<ul>
<li>Class类：可获得类属性方法</li>
<li>Field类：获得类的成员变量</li>
<li>Method类：获取类的方法信息</li>
<li>Construct类：获取类的构造方法等信息</li>
</ul> 
<h3>
<a id="22_138"></a>22.简述注解</h3> 
<p>Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。<br> 其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理相应代码，做对应操作。</p> 
<h3>
<a id="23_142"></a>23.简述元注解</h3> 
<p>元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：</p> 
<ul>
<li>@Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM中运行）。</li>
<li>@Target：表示注解作用的范围。</li>
<li>@Documented：将注解中的元素包含到 Javadoc 中去。</li>
<li>@Inherited：一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。</li>
<li>@Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</li>
</ul> 
<h3>
<a id="24Java_150"></a>24.简述Java异常的分类</h3> 
<p>Java异常分为Error（程序无法处理的错误），和Exception（程序本身可以处理的异常）。这两个类均继承Throwable。<br> Error常见的有StackOverFlowError,OutOfMemoryError等等。<br> Exception可分为运行时异常和非运行时异常。对于运行时异常，可以利用try catch的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。</p> 
<h3>
<a id="25throwthrows_155"></a>25.简述throw与throws的区别</h3> 
<p>throw一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。<br> throws一般用于方法声明上，代表该方法可能会抛出的异常列表。</p> 
<h3>
<a id="26_159"></a>26.简述泛型</h3> 
<p>泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。</p> 
<h3>
<a id="27_162"></a>27.简述泛型擦除</h3> 
<p>Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理时被擦除，这个过程被称为泛型擦除。</p> 
<h3>
<a id="28Java_165"></a>28.简述Java基本数据类型</h3> 
<ul>
<li>byte: 占用1个字节，取值范围-128 ~ 127</li>
<li>short: 占用2个字节，取值范围-215 ~ 215-1</li>
<li>int：占用4个字节，取值范围-2^31 ~ 2^31-1</li>
<li>long：占用8个字节</li>
<li>float：占用4个字节</li>
<li>double：占用8个字节</li>
<li>char: 占用2个字节</li>
<li>boolean：占用大小根据实现虚拟机不同有所差异</li>
</ul> 
<h3>
<a id="29_175"></a>29.简述自动装箱拆箱</h3> 
<p>对于Java基本数据类型，均对应一个包装类。<br> 装箱就是自动将基本数据类型转换为包装器类型，如int-&gt;Integer<br> 拆箱就是自动将包装器类型转换为基本数据类型，如Integer-&gt;int</p> 
<h3>
<a id="30_180"></a>30.简述重载与重写的区别</h3> 
<p>重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。<br> 重载即在一个类中，方法名相同，参数类型或数量不同。</p> 
<h3>
<a id="31java_184"></a>31.简述java的多态</h3> 
<p>Java多态可以分为编译时多态和运行时多态。<br> 编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。<br> 运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。</p> 
<p>运行时多态的实现：主要依靠方法表，方法表中最先存放的是Object类的方法，接下来是该类的父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。因此可以实现运行时多态。</p> 
<h3>
<a id="32_191"></a>32.简述抽象类与接口的区别</h3> 
<p>抽象类：体现的是is-a的关系，如对于man is a person，就可以将person定义为抽象类。<br> 接口：体现的是can的关系。是作为模板实现的。如设置接口fly，plane类和bird类均可实现该接口。<br> 一个类只能继承一个抽象类，但可以实现多个接口。</p> 
<h3>
<a id="33Object_196"></a>33.简述Object类常用方法</h3> 
<ol>
<li>hashCode：通过对象计算出的散列码。用于map型或equals方法。需要保证同一个对象多次调用该方法，总返回相同的整型值。</li>
<li>equals：判断两个对象是否一致。需保证equals方法相同对应的对象hashCode也相同。</li>
<li>toString: 用字符串表示该对象</li>
<li>clone:深拷贝一个对象</li>
</ol> 
<h3>
<a id="34_202"></a>34.简述内部类及其作用</h3> 
<ul>
<li>成员内部类：作为成员对象的内部类。可以访问private及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问private修饰的内部类属性。</li>
<li>局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的final变量。</li>
<li>匿名内部类：只能使用一次，没有类名，只能访问外部类的final变量。</li>
<li>静态内部类：类似类的静态成员变量。</li>
</ul> 
<h3>
<a id="35StringStringBufferStringBuilder_208"></a>35.简述String/StringBuffer与StringBuilder</h3> 
<p>String类采用利用final修饰的字符数组进行字符串保存，因此不可变。如果对String类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去。<br> StringBuilder，采用无final修饰的字符数组进行保存，因此可变。但线程不安全。<br> StringBuffer，采用无final修饰的字符数组进行保存，可理解为实现线程安全的StringBuilder。</p> 
<h3>
<a id="36Java_213"></a>36.简述Java序列化与反序列化的实现</h3> 
<p>序列化：将java对象转化为字节序列，由此可以通过网络对象进行传输。<br> 反序列化：将字节序列转化为java对象。<br> 具体实现：实现Serializable接口，或实现Externalizable接口中的writeExternal()与readExternal()方法。</p> 
<h3>
<a id="37JAVAList_218"></a>37.简述JAVA的List</h3> 
<p>List是一个有序队列，在JAVA中有两种实现方式:<br> ArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，把原有数组复制到新数组。<br> LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。</p> 
<h3>
<a id="38Java_223"></a>38.Java中线程安全的基本数据结构有哪些</h3> 
<p>HashTable: 哈希表的线程安全版，效率低<br> ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代HashTable<br> Vector：线程安全版Arraylist<br> Stack：线程安全版栈<br> BlockingQueue及其子类：线程安全版队列</p> 
<h3>
<a id="39JAVASet_230"></a>39.简述JAVA的Set</h3> 
<p>Set 即集合，该数据结构不允许元素重复且无序。JAVA对Set有三种实现方式：<br> 1.HashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value系统自定义一个名为PRESENT 的 Object 类型常量。判断元素是否相同时，先比较hashCode，相同后再利用equals比较，查询O(1)<br> 2.LinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。<br> 3.TreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。查询O(logn)</p> 
<h3>
<a id="40JAVAHashMap_236"></a>40.简述JAVA的HashMap</h3> 
<p>JDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的table 数组、元素数量 size、加载因子 loadFactor。<br> HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的hash 值一样，就会发生哈希冲突，被放到同一个链表上。<br> table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。在JDK8后链表超过8会转化为红黑树。</p> 
<p>若当前数据/总数据容量&gt;负载因子，Hashmap将执行扩容操作。<br> 默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。</p> 
<h3>
<a id="41HashMap_244"></a>41.为何HashMap线程不安全</h3> 
<p>在JDK1.7中，HashMap采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。<br> 虽然JDK1.8采用了尾插法解决了这个问题，但是并发下的put操作也会使前一个key被后一个key覆盖。由于HashMap有扩容机制存在，也存在A线程进行扩容后，B线程执行get方法出现失误的情况。</p> 
<h3>
<a id="42javaTreeMap_248"></a>42.简述java的TreeMap</h3> 
<p>TreeMap是底层利用红黑树实现的Map结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出。</p> 
<h3>
<a id="43CollectionCollections_251"></a>43.Collection和Collections有什么区别？</h3> 
<ol>
<li>Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口，所有集合都是它的子类，比如List、Set等。</li>
<li>Collections是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法：<br> Collections.sort(list);提供的反转方法：Collections.reverse(list)。</li>
</ol> 
<h3>
<a id="44ArrayListVectorLinkedList_256"></a>44.ArrayList、Vector和LinkedList有什么共同点与区别？</h3> 
<ol>
<li>ArrayList、Vector和LinkedList都是可伸缩的数组，即可以动态改变长度的数组。</li>
<li>ArrayList和Vector都是基于存储元素的Object[] array来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。当存储元素超过容器的初始化容量大小，ArrayList与Vector均会进行扩容。</li>
<li>Vector是线程安全的，其大部分方法是直接或间接同步的。ArrayList不是线程安全的，其方法不具有同步性质。LinkedList也不是线程安全的。</li>
<li>LinkedList采用双向链表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入元素的时候不需要对数据进行移动，插入效率较高。</li>
</ol> 
<h3>
<a id="45HashMapHashtable_262"></a>45.HashMap和Hashtable有什么区别？</h3> 
<ol>
<li>HashMap是Hashtable的轻量级实现，HashMap允许key和value为null，但最多允许一条记录的key为null.而HashTable不允许。</li>
<li>HashTable中的方法是线程安全的，而HashMap不是。在多线程访问HashMap需要提供额外的同步机制。</li>
<li>Hashtable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。</li>
</ol> 
<h3>
<a id="46HashMapTreeMap_267"></a>46.如何决定使用HashMap还是TreeMap?</h3> 
<p>如果对Map进行插入、删除或定位一个元素的操作更频繁，HashMap是更好的选择。如果需要对key集合进行有序的遍历，TreeMap是更好的选择。</p> 
<h3>
<a id="47failfastfailsafe_270"></a>47.fail-fast和fail-safe迭代器的区别是什么？</h3> 
<ol>
<li>fail-fast直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出ConcurrentModificationException异常从而导致遍历失败。常见的使用fail-fast方式的容器有HashMap和ArrayList等。</li>
<li>fail-safe这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用fail-safe方式遍历的容器有ConcurrentHashMap和CopyOnWriteArrayList。</li>
</ol> 
<h3>
<a id="48HashSetequalshashCode_274"></a>48.HashSet中，equals与hashCode之间的关系？</h3> 
<p>equals和hashCode这两个方法都是从object类中继承过来的,equals主要用于判断对象的内存地址引用是否是同一个地址；hashCode根据定义的哈希规则将对象的内存地址转换为一个哈希码。HashSet中存储的元素是不能重复的，主要通过hashCode与equals两个方法来判断存储的对象是否相同：<br> 1.如果两个对象的hashCode值不同，说明两个对象不相同。<br> 2.如果两个对象的hashCode值相同，接着会调用对象的equals方法，如果equlas方法的返回结果为true，那么说明两个对象相同，否则不相同。</p> 
<h3>
<a id="50_279"></a>50.拆箱装箱原理</h3> 
<p>装箱过程是通过调用包装器的valueOf方法实现的，将原值赋给对应类。<br> 拆箱过程是通过调用包装器的 intValue/doubleValue等方法实现，返回基本的数据类型。</p> 
<h3>
<a id="51java_283"></a>51.java反射原理</h3> 
<p>Java会在编译期装载所有的类，并将其元信息保存至Class类对象中。<br> 因此可以设计x.class/x.getClass()/Class.forName()等方法获取Class对象。所以在反射调用Field/Method/Constructor对象时，可根据Class类对象进行进一步操作。</p> 
<h3>
<a id="52ComparatorComparable_287"></a>52.Comparator和Comparable的区别</h3> 
<p>Comparable 是一个接口，用于对象内部的比较方式，该接口需要实现的方法是：</p> 
<pre><code>public interface Comparable&lt;T&gt; {
    public int compareTo(T o);
}
</code></pre> 
<p>Comparator 也是一个接口，该接口有个compare方法，该接口需要实现的方法是：</p> 
<pre><code>public interface Comparator&lt;T&gt; {
    int compare(T o1, T o2);
}
</code></pre> 
<p>除该方法外，comparator还可以实现其他方法。</p> 
<h3>
<a id="53_303"></a>53.动态代理实现方式</h3> 
<ol>
<li>利用JDK反射机制，实现代理接口</li>
<li>利用CGLib，对指定类生成子类，进行代理。</li>
</ol> 
<h3>
<a id="54OOMout_of_memory_307"></a>54.简述OOM（out of memory）</h3> 
<p>当JVM分配内存不够会抛出out of memory异常</p> 
<h3>
<a id="55StackOverFlowError_310"></a>55.简述StackOverFlowError</h3> 
<p>调用栈深度超过限制产生的异常。<br> 一般会在递归调用时出现。</p> 
<h3>
<a id="Java_314"></a>二、Java多线程</h3> 
<h3>
<a id="1javaJMM_315"></a>1.简述java内存模型（JMM）</h3> 
<p>java内存模型定义了程序中各种变量的访问规则。其规定所有变量都存储在主内存，线程均有自己的工作内存。<br> 工作内存中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。</p> 
<h3>
<a id="2asifserial_319"></a>2.简述as-if-serial</h3> 
<p>编译器等会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果和用户原始程序输出预定结果一致。</p> 
<h3>
<a id="3happensbefore_322"></a>3.简述happens-before八大原则</h3> 
<ol>
<li>程序顺序原则。即在一个线程内必须保证语义的串行性（as-if-serial），也就是说按照代码顺序执行；</li>
<li>锁原则。解锁（unlock）操作必然发生在后续的同一个锁的加锁（lock）之前，也就是说，在一个锁被解锁后，再加锁，那么加锁的动作必须在解锁动作之后（操作同一个锁）；</li>
<li>volatile原则。volatile变量的写，发生于读之前，这样保证了volatile变量的可见性。简单理解就是volatile变量在每次被线程访问时，都强迫于从主内存中读取该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时候，不同的线程总能看到该变量的最新值；</li>
<li>线程启动原则。线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见；</li>
<li>传递性原则。A先于B，B先于C，那么A必然先于C；</li>
<li>线程终止原则。线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B在终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见；</li>
<li>线程中断原则。对线程interrupt()方法的调用先发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断；</li>
<li>对象的终结原则。对象的构造函数执行，结束先于finalize方法。</li>
</ol> 
<h3>
<a id="4asifserial__happensbefore__332"></a>4.as-if-serial 和 happens-before 的区别</h3> 
<p>as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。</p> 
<h3>
<a id="5_335"></a>5.简述原子性操作</h3> 
<p>一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。</p> 
<h3>
<a id="6_338"></a>6.简述线程的可见性</h3> 
<p>可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile,synchronized,final都能保证可见性。</p> 
<h3>
<a id="7_341"></a>7.简述有序性</h3> 
<p>即虽然多线程存在并发和指令优化等操作，在本线程内观察该线程的所有执行操作是有序的。</p> 
<h3>
<a id="8javavolatile_344"></a>8.简述java中volatile关键字作用</h3> 
<ol>
<li> <p>保证变量对所有线程的可见性。<br> 当一条线程修改了变量值，新值对于其他线程来说是立即可以得知的。</p> </li>
<li> <p>禁止指令重排序优化。使用 volatile 变量进行写操作，汇编指令带有 lock 前缀，相当于一个内存屏障，编译器不会将后面的指令重排到内存屏障之前。</p> </li>
</ol> 
<h3>
<a id="9java_350"></a>9.java线程的实现方式</h3> 
<ol>
<li>实现Runnable接口</li>
<li>继承Thread类。</li>
<li>实现Callable接口</li>
</ol> 
<h3>
<a id="10java_355"></a>10.简述java线程的状态</h3> 
<p>线程状态有New, RUNNABLE, BLOCK, WAITING, TIMED_WAITING, THERMINATED</p> 
<p>NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。<br> RUNNABLE: 运行状态。其表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU。<br> BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。<br> WAITING: 等待状态。线程内run方法运行完语句Object.wait()/Thread.join()进入该状态。<br> TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用Thread.sleep(long) Object.wait(long)<br> Thread.join(long)进入状态。其中这些参数代表等待的时间。<br> TERMINATED：结束状态。线程调用完run方法进入该状态。</p> 
<h3>
<a id="11_366"></a>11.简述线程通信的方式</h3> 
<ol>
<li>volatile 关键词修饰变量，保证所有线程对变量访问的可见性。</li>
<li>synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。</li>
<li>wait/notify方法</li>
<li>IO通信</li>
</ol> 
<h3>
<a id="12_372"></a>12.简述线程池</h3> 
<p>没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后执行接下来任务，复用已创建的线程，降低开销、控制最大并发数。<br> 线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。<br> 将任务派发给线程池时，会出现以下几种情况<br> 1.核心线程池未满，创建一个新的线程执行任务。<br> 2.如果核心线程池已满，工作队列未满，将线程存储在工作队列。<br> 3.如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。<br> 4.如果超过最大线程数，按照拒绝策略来处理任务。</p> 
<h3>
<a id="13_381"></a>13.线程池参数</h3> 
<ol>
<li>corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。</li>
<li>maximumPoolSize：线程池能够容纳同时执行的线程最大数。</li>
<li>keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。</li>
<li>workQueue：工作队列。</li>
<li>threadFactory：线程工厂，用来生产一组相同任务的线程。</li>
<li>handler：拒绝策略。有以下几种拒绝策略：</li>
</ol> 
<ul>
<li>AbortPolicy：丢弃任务并抛出异常</li>
<li>CallerRunsPolicy： 重新尝试提交该任务</li>
<li>DiscardOldestPolicy：抛弃队列里等待最久的任务并把当前任务加入队列</li>
<li>DiscardPolicy：表示直接抛弃当前任务但不抛出异常。</li>
</ul> 
<h3>
<a id="14_393"></a>14.线程池创建方法</h3> 
<ol>
<li>newFixedThreadPool，创建固定大小的线程池。</li>
<li>newSingleThreadExecutor，使用单线程线程池。</li>
<li>newCachedThreadPool，maximumPoolSize 设置为 Integer 最大值，工作完成后会回收工作线程</li>
<li>newScheduledThreadPool：支持定期及周期性任务执行，不回收工作线程。</li>
<li>newWorkStealingPool：一个拥有多个任务队列的线程池。</li>
</ol> 
<h3>
<a id="15Executor_400"></a>15.简述Executor框架</h3> 
<p>Executor框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor框架实现类的Execute方法就可以提交任务。产生线程池的函数ThreadPoolExecutor也是Executor的具体实现类。</p> 
<h3>
<a id="16Executor_403"></a>16.简述Executor的继承关系</h3> 
<ul>
<li>Executor：一个接口，其定义了一个接收Runnable对象的方法executor，该方法接收一个Runable实例执行这个任务。</li>
<li>ExecutorService：Executor的子类接口，其定义了一个接收Callable对象的方法，返回 Future 对象，同时提供execute方法。</li>
<li>ScheduledExecutorService：ExecutorService的子类接口，支持定期执行任务。</li>
<li>AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现。</li>
<li>Executors：实现ExecutorService接口的静态工厂类，提供了一系列工厂方法用于创建线程池。</li>
<li>ThreadPoolExecutor：继承AbstractExecutorService，用于创建线程池。</li>
<li>ForkJoinPool: 继承AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于map reduce。</li>
<li>ScheduledThreadPoolExecutor：继承ThreadPoolExecutor，实现ScheduledExecutorService，用于创建带定时任务的线程池。</li>
</ul> 
<h3>
<a id="17_413"></a>17.简述线程池的状态</h3> 
<ul>
<li>Running：能接受新提交的任务，也可以处理阻塞队列的任务。</li>
<li>Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于running时调用shutdown方法，会进入该状态。</li>
<li>Stop：不接受新任务，不处理存量任务，调用shutdownnow进入该状态。</li>
<li>Tidying：所有任务已经终止了，worker_count（有效线程数）为0。</li>
<li>Terminated：线程池彻底终止。在tidying模式下调用terminated方法会进入该状态。</li>
</ul> 
<h3>
<a id="18_420"></a>18.简述阻塞队列</h3> 
<p>阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有：</p> 
<ul>
<li>ArrayBlockingQueue：底层是由数组组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：底层是由链表组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue：阻塞优先队列。</li>
<li>DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作</li>
<li>LinkedTransferQueue：与LinkedBlockingQueue相比多一个transfer方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者。</li>
<li>LinkedBlockingDeque：双向阻塞队列。</li>
</ul> 
<h3>
<a id="19ThreadLocal_430"></a>19.谈一谈ThreadLocal</h3> 
<p>ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。</p> 
<ul>
<li>set 给ThreadLocalMap设置值。</li>
<li>get 获取ThreadLocalMap。</li>
<li>remove 删除ThreadLocalMap类型的对象。</li>
</ul> 
<p>存在的问题</p> 
<ol>
<li>对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。</li>
<li>内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。</li>
</ol> 
<h3>
<a id="20javaunsafe_440"></a>20.聊聊你对java并发包下unsafe类的理解</h3> 
<p>对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。<br> Java 有个类叫 Unsafe 类，这个类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。</p> 
<h3>
<a id="21JAVACAS_444"></a>21.JAVA中的乐观锁与CAS算法</h3> 
<p>对于乐观锁，开发者认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。<br> 到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。<br> 乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。<br> CAS 算法的思路如下：</p> 
<ol>
<li>该算法认为不同线程对变量的操作时产生竞争的情况比较少。</li>
<li>该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。</li>
<li>如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。</li>
<li>如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。</li>
</ol> 
<h3>
<a id="22ABA_454"></a>22.ABA问题及解决方法简述</h3> 
<p>CAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。<br> juc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。</p> 
<h3>
<a id="23Atomic_458"></a>23.简述常见的Atomic类</h3> 
<p>在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者–方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。<br> 基本数据类型的原子类有：</p> 
<ul>
<li>AtomicInteger 原子更新整形</li>
<li>AtomicLong 原子更新长整型</li>
<li>AtomicBoolean 原子更新布尔类型</li>
</ul> 
<p>Atomic数组类型有：</p> 
<ul>
<li>AtomicIntegerArray 原子更新整形数组里的元素</li>
<li>AtomicLongArray 原子更新长整型数组里的元素</li>
<li>AtomicReferenceArray 原子更新引用类型数组里的元素。</li>
</ul> 
<p>Atomic引用类型有:</p> 
<ul>
<li>AtomicReference 原子更新引用类型</li>
<li>AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记</li>
<li>AtomicStampedReference 原子更新带有版本号的引用类型</li>
</ul> 
<p>FieldUpdater类型：</p> 
<ul>
<li>AtomicIntegerFieldUpdater 原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater 原子更新长整形字段的更新器</li>
<li>AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器</li>
</ul> 
<h3>
<a id="24Atomic_480"></a>24.简述Atomic类基本实现原理</h3> 
<p>以AtomicIntger 为例：<br> 方法getAndIncrement：以原子方式将当前的值加1，具体实现为：</p> 
<ol>
<li>在 for 死循环中取得 AtomicInteger 里存储的数值</li>
<li>对 AtomicInteger 当前的值加 1</li>
<li>调用 compareAndSet 方法进行原子更新</li>
<li>先检查当前数值是否等于 expect</li>
<li>如果等于则说明当前值没有被其他线程修改，则将值更新为 next，</li>
<li>如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。</li>
</ol> 
<h3>
<a id="25CountDownLatch_490"></a>25.简述CountDownLatch</h3> 
<p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。<br> 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用countDown方法，计数器的值就减1，当计数器的值为0时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。<br> 只能一次性使用，不能reset。</p> 
<h3>
<a id="26CyclicBarrier_495"></a>26.简述CyclicBarrier</h3> 
<p>CyclicBarrier 主要功能和countDownLatch类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。</p> 
<h3>
<a id="27Semaphore_498"></a>27.简述Semaphore</h3> 
<p>Semaphore即信号量。<br> Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为0,线程进入休眠。</p> 
<h3>
<a id="28Exchanger_502"></a>28.简述Exchanger</h3> 
<p>Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。线程通过exchange 方法交换数据，第一个线程执行 exchanger 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。</p> 
<h3>
<a id="29ConcurrentHashMap_505"></a>29.简述ConcurrentHashMap</h3> 
<p>JDK7采用锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。</p> 
<p>get 除读到空值不需要加锁。该方法先经过一次再散列，再用这个散列值通过散列运算定位到Segment，最后通过散列算法定位到元素。<br> put 须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。</p> 
<p>JDK8的改进</p> 
<ol>
<li>取消分段锁机制，采用CAS算法进行值的设置，如果CAS失败再使用 synchronized 加锁添加元素</li>
<li>引入红黑树结构，当某个槽内的元素个数超过8且 Node数组 容量大于 64 时，链表转为红黑树。</li>
<li>使用了更加优化的方式统计集合内的元素数量。</li>
</ol> 
<h3>
<a id="30Synchronized_516"></a>30.Synchronized底层实现原理</h3> 
<p>Java 对象底层都关联一个的 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。</p> 
<p>synchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是synchronized 括号里的对象。</p> 
<p>执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。</p> 
<h3>
<a id="31Synchronized_523"></a>31.Synchronized关键词使用方法</h3> 
<ol>
<li>直接修饰某个实例方法</li>
<li>直接修饰某个静态方法</li>
<li>修饰代码块</li>
</ol> 
<h3>
<a id="32java_528"></a>32.简述java偏向锁</h3> 
<p>JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。</p> 
<p>其申请流程为：</p> 
<ol>
<li>首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；</li>
<li>判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤4；</li>
<li>判断是否需要重偏向。如果不用的话，直接获得偏向锁；</li>
<li>利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。</li>
</ol> 
<h3>
<a id="33_537"></a>33.简述轻量级锁</h3> 
<p>轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。</p> 
<p>其申请流程为：</p> 
<ol>
<li>如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前Mark Word 的拷贝。</li>
<li>虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针</li>
<li>如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。</li>
<li>如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧</li>
<li>如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行</li>
<li>如果不是则说明锁对象已经被其他线程抢占。</li>
<li>如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。</li>
</ol> 
<h3>
<a id="34_549"></a>34.简述锁优化策略</h3> 
<p>即自适应自旋、锁消除、锁粗化、锁升级等策（略偏）。</p> 
<h3>
<a id="35java_552"></a>35.简述java的自旋锁</h3> 
<p>线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试，这种操作也称为自旋锁。</p> 
<h3>
<a id="36_555"></a>36.简述自适应自旋锁</h3> 
<p>自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。</p> 
<h3>
<a id="37_558"></a>37.简述锁粗化</h3> 
<p>锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。</p> 
<h3>
<a id="38_561"></a>38.简述锁消除</h3> 
<p>锁消除是一种更为彻底的优化，在编译时，java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。</p> 
<h3>
<a id="39LockReentrantLock_564"></a>39.简述Lock与ReentrantLock</h3> 
<p>Lock 是 java并发包的顶层接口。<br> 可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。</p> 
<h3>
<a id="40AQS_568"></a>40.简述AQS</h3> 
<p>AQS（AbstractQueuedSynchronizer）抽象的队列式同步器。<br> AQS是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。<br> AQS是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。<br> 子类通过继承同步器并实现它的抽象方法getState、setState 和 compareAndSetState对同步状态进行更改。</p> 
<h3>
<a id="41AQS_574"></a>41.AQS获取独占锁/释放独占锁原理</h3> 
<p>获取：（acquire）</p> 
<ol>
<li>调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过addWaiter 方法加入到同步队列的尾部，在队列中自旋。</li>
<li>调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞。</li>
</ol> 
<p>释放：（release）</p> 
<ol>
<li>调用 tryRelease 方法释放同步状态</li>
<li>调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。</li>
</ol> 
<h3>
<a id="42AQS_583"></a>42.AQS获取共享锁/释放共享锁原理</h3> 
<p>获取锁（acquireShared）</p> 
<ol><li>调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于 0 表示能获取同步状态。</li></ol> 
<p>释放（releaseShared）</p> 
<ol><li>释放，并唤醒后续处于等待状态的节点。</li></ol> 
<h3>
<a id="43_590"></a>43.线程池类型</h3> 
<ol>
<li>newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲1分钟后自动销毁。</li>
<li>newFixedThreadPool 指定工作线程数量线程池。</li>
<li>newSingleThreadExecutor 单线程Executor。</li>
<li>newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。</li>
<li>newSingleThreadScheduledExecutor 支持定时任务的单线程Executor。</li>
</ol> 
<h3>
<a id="44synchronized_597"></a>44.synchronized关键字作用</h3> 
<p>保证只有一个线程可以获取对象的锁,并执行代码块,其他线程不能在该线程执行代码块时执行。</p> 
<h3>
<a id="45_600"></a>45.简述三色标记法</h3> 
<p>三色标记法是垃圾收集器CMS和G1使用的标记方法，该方法把对象分为三种颜色：</p> 
<ol>
<li>白色，该对象尚被未访问。</li>
<li>灰色，该对象已被访问，但该对象引用的其他对象并没有被访问。</li>
<li>黑色，该对象和引用的其他对象均被访问。</li>
</ol> 
<p>因此，对三色标记法来说，所有对象都可以看作由白色集合，黑色集合，灰色集合组成。通过这种标记方法的访问过程如下：<br> 4. 初始所有对象均在白色集合<br> 5. 将GC root直接引用的对象移动至灰色集合。<br> 6. 从灰色集合中取出一个对象，将该对象引用的白色集合对象，移动至灰色集合<br> 7. 移动完成后，将该对象移动至黑色集合<br> 8. 重复3-4操作。</p> 
<h2>
<a id="Java_613"></a>三、Java虚拟机</h2> 
<h3>
<a id="1JVM_614"></a>1.简述JVM内存模型</h3> 
<p>线程私有的运行时数据区: 程序计数器、Java 虚拟机栈、本地方法栈。<br> 线程共享的运行时数据区: Java 堆、方法区。</p> 
<h3>
<a id="2_618"></a>2.简述程序计数器</h3> 
<p>程序计数器表示当前线程所执行的字节码的行号指示器。<br> 程序计数器不会产生StackOverflowError和OutOfMemoryError。</p> 
<h3>
<a id="3_622"></a>3.简述虚拟机栈</h3> 
<p>Java 虚拟机栈用来描述 Java 方法执行的内存模型。线程创建时就会分配一个栈空间，线程结束后栈空间被回收。</p> 
<p>栈中元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、操作栈、动态链接和返回地址等信息。</p> 
<p>虚拟机栈会产生两类异常：<br> StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。<br> OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。</p> 
<h3>
<a id="4_631"></a>4.简述本地方法栈</h3> 
<p>本地方法栈与虚拟机栈作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为本地方法服务。可以将虚拟机栈看作普通的java函数对应的内存模型，本地方法栈看作由native关键词修饰的函数对应的内存模型。</p> 
<p>本地方法栈会产生两类异常：<br> StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。<br> OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。</p> 
<h3>
<a id="5JVM_638"></a>5.简述JVM中的堆</h3> 
<p>堆主要作用是存放对象实例，Java 里几乎所有对象实例都在堆分配内存，堆也是内存管理中最大的一块。Java的垃圾回收主要就是针对堆这一区域进行。</p> 
<p>可通过 -Xms 和 -Xmx 设置堆的最小和最大容量。</p> 
<p>堆会抛出 OutOfMemoryError异常。</p> 
<h3>
<a id="6_645"></a>6.简述方法区</h3> 
<p>方法区用于存储被虚拟机加载的类信息、常量、静态变量等数据。</p> 
<p>JDK6之前使用永久代实现方法区，容易内存溢出。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中抛弃永久代，改用在本地内存中实现的元空间来实现方法区，把 JDK 7 中永久代内容移到元空间。</p> 
<h3>
<a id="7_650"></a>7.简述运行时常量池</h3> 
<p>运行时常量池存放常量池表，用于存放编译器生成的各种字面量与符号引用。一般除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。除此之外，也会存放字符串基本类型。</p> 
<p>JDK8之前，放在方法区，大小受限于方法区。JDK8将运行时常量池存放堆中。</p> 
<h3>
<a id="8_655"></a>8.简述直接内存</h3> 
<p>直接内存也称为堆外内存，就是把内存对象分配在JVM堆外的内存区域。这部分内存不是虚拟机管理，而是由操作系统来管理。</p> 
<p>Java通过DriectByteBuffer对其进行操作，避免了在 Java 堆和 Native堆来回复制数据。</p> 
<h3>
<a id="9java_660"></a>9.简述java创建对象的过程</h3> 
<ol>
<li>检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析和初始化，如果没有就先执行类加载。</li>
<li>检查通过后虚拟机将为新生对象分配内存。</li>
<li>完成内存分配后虚拟机将成员变量设为零值</li>
<li>设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。</li>
<li>执行 init 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</li>
</ol> 
<h3>
<a id="10JVM_667"></a>10.简述JVM给对象分配内存的策略</h3> 
<ol>
<li>指针碰撞： 这种方式在内存中放一个指针作为分界指示器将使用过的内存放在一边，空闲的放在另一边，通过指针挪动完成分配。</li>
<li>空闲列表： 对于 Java 堆内存不规整的情况，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。</li>
</ol> 
<h3>
<a id="11java_671"></a>11.java对象内存分配是如何保证线程安全的</h3> 
<ol>
<li>对分配内存空间采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。</li>
<li>每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块"私有"内存中分配。一般采用这种策略。</li>
</ol> 
<h3>
<a id="12_675"></a>12.简述对象的内存布局</h3> 
<p>对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。</p> 
<p>对象头主要包含两部分数据： MarkWord、类型指针。MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。</p> 
<p>类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据。</p> 
<p>实例数据存储代码中所定义的各种类型的字段信息。</p> 
<p>对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。</p> 
<h3>
<a id="13_686"></a>13.如何判断对象是否是垃圾</h3> 
<p>引用计数法：设置引用计数器，对象被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。会存在对象间循环引用的问题，一般不使用这种方法。</p> 
<p>可达性分析：通过 GC Roots 的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，如果某个对象没有被搜到，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。</p> 
<h3>
<a id="14java_691"></a>14.简述java的引用类型</h3> 
<p>强引用： 被强引用关联的对象不会被回收。一般采用 new 方法创建强引用。</p> 
<p>软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。一般采用 SoftReference 类来创建软引用。</p> 
<p>弱引用：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。一般采用WeakReference 类来创建弱引用。</p> 
<p>虚引用： 无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用。</p> 
<h3>
<a id="15_700"></a>15.简述标记清除算法、标记整理算法和标记复制算法</h3> 
<p>标记清除算法：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。</p> 
<p>标记整理算法：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存</p> 
<p>标记复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。</p> 
<h3>
<a id="16_707"></a>16.简述分代收集算法</h3> 
<p>根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。<br> 一般将堆分为新生代和老年代，对这两块采用不同的算法。</p> 
<p>新生代使用：标记复制算法<br> 老年代使用：标记清除或者标记整理算法</p> 
<h3>
<a id="17Serial_714"></a>17.简述Serial垃圾收集器</h3> 
<p>单线程串行收集器。垃圾回收的时候，必须暂停其他所有线程。新生代使用标记复制算法，老年代使用标记整理算法。简单高效。</p> 
<h3>
<a id="18ParNew_717"></a>18.简述ParNew垃圾收集器</h3> 
<p>可以看作Serial垃圾收集器的多线程版本，新生代使用标记复制算法，老年代使用标记整理算法。</p> 
<h3>
<a id="19Parallel_Scavenge_720"></a>19.简述Parallel Scavenge垃圾收集器</h3> 
<p>注重吞吐量，即cpu运行代码时间/cpu耗时总时间（cpu运行代码时间+ 垃圾回收时间）。新生代使用标记复制算法，老年代使用标记整理算法。</p> 
<h3>
<a id="20CMS_723"></a>20.简述CMS垃圾收集器</h3> 
<p>注重最短时间停顿。CMS垃圾收集器为最早提出的并发收集器，垃圾收集线程与用户线程同时工作。采用标记清除算法。该收集器分为初始标记、并发标记、并发预清理、并发清除、并发重置这么几个步骤。</p> 
<p>初始标记：暂停其他线程(stop the world)，标记与GC roots直接关联的对象。</p> 
<p>并发标记：可达性分析过程(程序不会停顿)。</p> 
<p>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象，重新标记，暂停虚拟机（stop theworld）扫描CMS堆中剩余对象。</p> 
<p>并发清除：清理垃圾对象(程序不会停顿)。</p> 
<p>并发重置：重置CMS收集器的数据结构。</p> 
<h3>
<a id="21G1_736"></a>21.简述G1垃圾收集器</h3> 
<p>和之前收集器不同，该垃圾收集器把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。</p> 
<p>初始标记：标记与GC roots直接关联的对象。</p> 
<p>并发标记：可达性分析。</p> 
<p>最终标记：对并发标记过程中，用户线程修改的对象再次标记一下。</p> 
<p>筛选回收：对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间制定回收计划并回收。</p> 
<h3>
<a id="22Minor_GC_747"></a>22.简述Minor GC</h3> 
<p>Minor GC指发生在新生代的垃圾收集，因为 Java 对象大多存活时间短，所以 Minor GC 非常频繁，一般回收速度也比较快。</p> 
<h3>
<a id="23Full_GC_750"></a>23.简述Full GC</h3> 
<p>Full GC 是清理整个堆空间—包括年轻代和永久代。调用System.gc(),老年代空间不足，空间分配担保失败，永生代空间不足会产生full gc。</p> 
<h3>
<a id="24_753"></a>24.常见内存分配策略</h3> 
<p>大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。</p> 
<p>大对象需要大量连续内存空间，直接进入老年代区分配。</p> 
<p>如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1，并且每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。</p> 
<p>如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。</p> 
<p>空间分配担保。MinorGC 前虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。如果不，JVM会查看HandlePromotionFailure 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将Minor GC，否则改成一次 FullGC。</p> 
<h3>
<a id="25JVM_764"></a>25.简述JVM类加载过程</h3> 
<p>加载：</p> 
<ol>
<li>通过全类名获取类的二进制字节流.</li>
<li>将类的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成类的Class对象，作为方法区数据的入口。</li>
</ol> 
<p>验证：对文件格式，元数据，字节码，符号引用等验证正确性。<br> 准备：在方法区内为类变量分配内存并设置为0值。<br> 解析：将符号引用转化为直接引用。<br> 初始化：执行类构造器clinit方法，真正初始化。</p> 
<h3>
<a id="26JVM_775"></a>26.简述JVM中的类加载器</h3> 
<p>BootstrapClassLoader启动类加载器：加载/lib下的jar包和类。C++编写。<br> ExtensionClassLoader扩展类加载器： /lib/ext目录下的jar包和类。java编写。<br> AppClassLoader应用类加载器，加载当前classPath下的jar包和类。java编写。</p> 
<h3>
<a id="27_780"></a>27.简述双亲委派机制</h3> 
<p>一个类加载器收到类加载请求之后，首先判断当前类是否被加载过。已经被加载的类会直接返回，如果没有被加载，首先将类加载请求转发给父类加载器，一直转发到启动类加载器，只有当父类加载器无法完成时才尝试自己加载。</p> 
<p>加载类顺序：BootstrapClassLoader-&gt;ExtensionClassLoader-&gt;AppClassLoader-&gt;CustomClassLoader</p> 
<p>检查类是否加载顺序：<br> CustomClassLoader-&gt;AppClassLoader-&gt;ExtensionClassLoader-&gt;BootstrapClassLoader</p> 
<h3>
<a id="28_788"></a>28.双亲委派机制的优点</h3> 
<ol>
<li>避免类的重复加载。相同的类被不同的类加载器加载会产生不同的类，双亲委派保证了java程序的稳定运行。</li>
<li>保证核心API不被修改。</li>
</ol> 
<h3>
<a id="29_792"></a>29.如何破坏双亲委派机制</h3> 
<p>重载loadClass()方法，即自定义类加载器。</p> 
<h3>
<a id="30_795"></a>30.如何构建自定义类加载器</h3> 
<ol>
<li>新建自定义类继承自java.lang.ClassLoader</li>
<li>重写findClass、loadClass、defineClass方法</li>
</ol> 
<h3>
<a id="31JVM_799"></a>31.JVM常见调优参数</h3> 
<ul>
<li>-Xms 初始堆大小</li>
<li>-Xmx 最大堆大小</li>
<li>-XX:NewSize 年轻代大小</li>
<li>-XX:MaxNewSize 年轻代最大值</li>
<li>-XX:PermSize 永生代初始值</li>
<li>-XX:MaxPermSize 永生代最大值</li>
<li>-XX:NewRatio 新生代与老年代的比例</li>
</ul> 
<h3>
<a id="32systemgc_808"></a>32.调用system.gc()一定会发生垃圾收集吗？为什么？</h3> 
<p>调用System.gc()的时候，其实并不会马上进行垃圾回收,只会把这次gc请求记录下来。需配合System.runFinalization()才会进行真正回收</p> 
<h3>
<a id="33_811"></a>33.静态变量存储位置</h3> 
<p>在1.8以前，静态成员变量存在方法区，在1.8后，由于JDK8取消永生代，静态变量存储到了堆中</p> 
<h2>
<a id="Redis_814"></a>四、Redis</h2> 
<h3>
<a id="1Redis_815"></a>1.Redis单线程原理</h3> 
<p>首先必须明确，Redis单线程指的是网络请求模块使用了一个线程，其他模块仍用了多个线程。并不是一个线程完成了所有功能。<br> 原理上，其采用了epoll的多路复用特性，因此可以采用单线程处理其网络请求。</p> 
<h3>
<a id="2Redis_819"></a>2.Redis数据类型</h3> 
<p>String：字符串类型，最简单的类型<br> Hash：类似于Map的一种结构。<br> List：有序列表。<br> Set:无序集合。<br> ZSet：带权值的无序集合，即每个ZSet元素还另有一个数字代表权值，集合通过权值进行排序。</p> 
<h3>
<a id="3redis_826"></a>3.什么情况下使用redis</h3> 
<ol>
<li>针对热点数据进行缓存</li>
<li>对于特定限时数据的存放</li>
<li>针对带热点权值数据的排序list</li>
<li>分布式锁</li>
</ol> 
<h3>
<a id="4redismemcache_832"></a>4.redis与memcache的区别</h3> 
<ol>
<li>redis处理网络请求采用单线程模型，而memcache采用多线程异步IO的方式</li>
<li>redis支持数据持久化，memcache不支持</li>
<li>redis支持的数据格式比memcache更多</li>
</ol> 
<h3>
<a id="5_837"></a>5.简述缓存穿透</h3> 
<p>缓存穿透指缓存和数据库均没有需要查询的数据，攻击者不断发送这种请求，使数据库压力过大。</p> 
<h3>
<a id="6_840"></a>6.简述缓存穿透的解决方法</h3> 
<ol>
<li>在数据库操作访问前进行校验，对不合法请求直接返回。</li>
<li>对于经常被访问的，并且数据库没有的键，缓存层记录键=null。</li>
</ol> 
<h3>
<a id="7_844"></a>7.简述缓存击穿</h3> 
<p>缓存击穿指缓存中没有数据，但数据库中有该数据。一般这种情况指特定数据的缓存时间到期，但由于并发用户访问该数据特别多，因此去数据库去取数据，引起数据库访问压力过大</p> 
<h3>
<a id="8_847"></a>8.简述缓存穿透的解决方法</h3> 
<ol>
<li>设置热点数据永远不过期。</li>
<li>对并发读数据设置并发锁，降低并发性</li>
</ol> 
<h3>
<a id="9_851"></a>9.简述缓存雪崩</h3> 
<p>缓存雪崩指缓存中一大批数据到过期时间，而从缓存中删除。但该批数据查询数据量巨大，查询全部走数据库，造成数据库压力过大。</p> 
<h3>
<a id="10_854"></a>10.简述缓存雪崩的解决方法</h3> 
<ol>
<li>缓存数据设置随机过期时间，防止同一时间大量数据过期。</li>
<li>设置热点数据永远不过期。</li>
<li>对于集群部署的情况，将热点数据均匀分布在不同缓存中。</li>
</ol> 
<h3>
<a id="11Redis_859"></a>11.Redis有哪些集群部署方式</h3> 
<ol>
<li>主从复制</li>
<li>哨兵模式</li>
<li>Cluster集群模式</li>
</ol> 
<h3>
<a id="12_864"></a>12.简述主从复制模式</h3> 
<p>在主从复制中，有主库（Master）节点和从库（Slave）节点两个角色。<br> 从节点服务启动会连接主库，并向主库发送SYNC命令。</p> 
<p>主节点收到同步命令，启动持久化工作，工作执行完成后，主节点将传送整个数据库文件到从库，从节点接收到数据库文件数据之后将数据进行加载。此后，主节点继续将所有已经收集到的修改命令，和新的修改命令依次传送给从节点，从节点依次执行，从而达到最终的数据同步。</p> 
<p>通过这种方式，可以使写操作作用于主库，而读操作作用于从库，从而达到读写分离。</p> 
<h3>
<a id="13_872"></a>13.简述哨兵模式</h3> 
<p>哨兵模式监控redis集群中Master的工作的状态。在Master主服务器宕机时，从slave中选择新机器当作master，保证系统高可用。</p> 
<p>每个哨兵每10秒向主服务器，slave和其他哨兵发送ping。<br> 客户端通过哨兵，由哨兵提供可供服务的redis master节点。<br> 哨兵只需要配master节点，会自动寻找其对应的slave节点。<br> 监控同一master节点的哨兵会自动互联，组成哨兵网络，当任一哨兵发现master连接不上，即开会投票，投票半数以上决定Master下线，并从slave节点中选取master节点。</p> 
<h3>
<a id="14cluster_880"></a>14.cluster集群</h3> 
<p>cluster提出了虚拟槽的概念。</p> 
<ol>
<li>redis cluster默认有16384个槽，在集群搭建的时候，需要给节点分配哈希槽尽可能相同数量虚拟槽。</li>
<li>如果目前redis执行get操作，redis先对这个key经过CRC16 hash运算，并把结果对16384取余，得到槽编号。</li>
<li>根据槽编号，寻找到其对应的redis节点，在节点上执行hash命令。</li>
<li>如果此时执行set操作，节点先验证该key对应的槽编号是不是归本节点管，如果是则保存数据。如果不是，则发送正确节点编号给客户端。</li>
</ol> 
<h3>
<a id="15RedisRDB_887"></a>15.简述Redis的RDB</h3> 
<p>RDB即将当前数据生成快照，并保存于硬盘中。可以通过手动命令，也可以设置自动触发。</p> 
<h3>
<a id="16Redissave_890"></a>16.简述Redis的save命令</h3> 
<p>save命令是redis手动触发RDB过程的命令。使用该命令后，服务器阻塞，直到RDB过程完成后终止。该过程占用内存较多。</p> 
<h3>
<a id="17Redisbgsave_893"></a>17.简述Redis的bgsave命令</h3> 
<p>bgsave命令不阻塞主进程（严格意义上也不是完全不阻塞，详看下面过程），该命令fork一个子进程用于执行RDB过程。其具体过程为：</p> 
<ol>
<li>判断此时有没有子进程用于RDB，有的话直接返回。</li>
<li>redis进行fork子进程过程，此时父进程处于阻塞状态。</li>
<li>子进程创建RDB文件，完成后返回给父进程</li>
</ol> 
<h3>
<a id="18RedisRDB_899"></a>18.简述Redis自动触发RDB机制</h3> 
<ol>
<li>通过配置文件，设置一定时间后自动执行RDB</li>
<li>如采用主从复制过程，会自动执行RDB</li>
<li>Redis执行shutdown时，在未开启AOF后会执行RDB</li>
</ol> 
<h3>
<a id="19RedisAOF_904"></a>19.简述Redis的AOF</h3> 
<p>AOF通过日志，对数据的写入修改操作进行记录。这种持久化方式实时性更好。通过配置文件打开AOF。</p> 
<h3>
<a id="20AOF_907"></a>20.简述AOF的持久化策略</h3> 
<ol>
<li>always。每执行一次数据修改命令就将其命令写入到磁盘日志文件上。</li>
<li>everysec。每秒将命令写入到磁盘日志文件上。</li>
<li>no。不主动设置，由操作系统决定什么时候写入到磁盘日志文件上。</li>
</ol> 
<h3>
<a id="21AOF_912"></a>21.简述AOF的重写</h3> 
<p>随着客户端不断进行操作，AOF对应的文件也越来越大。redis提供了bgrewriteaof函数，针对目前数据库中数据，在不读取原有AOF文件的基础上，重写了一个新的AOF文件，减少文件大小。</p> 
<h3>
<a id="22RDBAOF_915"></a>22.RDB与AOF优缺点比较</h3> 
<p>AOF占用的文件体积比RDB大。一般来说利用AOF备份对系统的消耗比RDB低。对于备份时出现系统故障，RDB数据可能会全丢，但AOF只会损失一部分。<br> RDB恢复速度比AOF快。</p> 
<h3>
<a id="23Redis_919"></a>23.简述Redis淘汰机制</h3> 
<ol>
<li>noeviction：默认禁止驱逐数据。内存不够使用时，对申请内存的命令报错。</li>
<li>volatile-lru：从设置了过期时间的数据集中淘汰最近没使用的数据。</li>
<li>volatile-ttl：从设置了过期时间的数据集中淘汰即将要过期的数据。</li>
<li>volatile-random：从设置了过期时间的数据中随机淘汰数据。</li>
<li>allkeys-lru：淘汰最近没使用的数据。</li>
<li>allkeys-random：随机淘汰数据。</li>
</ol> 
<h3>
<a id="24MySQLRedis_927"></a>24.MySQL与Redis区别</h3> 
<p>mysql是关系型数据库，并且其将数据存储在硬盘中，读取速度较慢。<br> redis是非关系型数据库，并且其将数据存储在内存中，读取速度较快。</p> 
<h3>
<a id="25Redis_931"></a>25.简述Redis过期策略</h3> 
<ol>
<li>定期删除，redis默认是每100ms就随机抽取一些设置了过期时间的key，并检查其是否过期，如果过期就删除。因此该删除策略并不会删除所有的过期key。</li>
<li>惰性删除，在客户端需要获取某个key时，redis将首先进行检查，若该key设置了过期时间并已经过期就会删除。<br> 实际上redis结合上述两种手段结合起来，保证删除过期的key。</li>
</ol> 
<h3>
<a id="26Redis_936"></a>26.Redis基本数据类型实现原理</h3> 
<p>字符串：采用类似数组的形式存储<br> list：采用双向链表进行具体实现<br> hash:采用hashtable或者ziplist进行具体实现<br> 集合：采用intset或hashtable存储<br> 有序集合：采用ziplist或skiplist+hashtable实现</p> 
<h3>
<a id="27Redis_943"></a>27.Redis快的原因</h3> 
<ol>
<li>redis是基于内存的数据库，内存数据读取存储效率远高于硬盘型</li>
<li>redis采用多路复用技术通过采用epoll的非阻塞IO，提升了效率</li>
</ol> 
<h2>
<a id="_947"></a>五、设计模式</h2> 
<p>1.简述设计模式七大原则<br> 开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。<br> 单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。<br> 依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。<br> 接口隔离原则：将不同功能定义在不同接口中实现接口隔离。<br> 里氏替换原则：任何基类可以出现的地方，子类一定可以出现。<br> 迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。<br> 合成复用原则：尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</p> 
<p>2.简述设计模式的分类<br> 创建型模式：在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p> 
<p>结构型模式：通过类和接口间的继承和引用实现创建复杂结构的对象。有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p> 
<p>行为型模式：通过类之间不同通信方式实现不同行为。有策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p> 
<p>3.简述简单工厂模式<br> 简单工厂模式指由一个工厂对象来创建实例,适用于工厂类负责创建对象较少的情况。例子：Spring 中的 BeanFactory 使用简单工厂模式，产生 Bean 对象。</p> 
<p>4.简述工厂模式<br> 工厂方法模式指定义一个创建对象的接口，让接口的实现类决定创建哪种对象，让类的实例化推迟到子类中进行。例子：Spring 的 FactoryBean 接口的 getObject 方法也是工厂方法。</p> 
<p>5.简述抽象工厂模式<br> 抽象工厂模式指提供一个创建一系列相关或相互依赖对象的接口，无需指定它们的具体类。例子：java.sql.Connection 接口。</p> 
<p>6.简述单例模式<br> 一个单例类在任何情况下都只存在一个实例。</p> 
<p>饿汉式实现</p> 
<p>public class Singleton {<!-- --><br> private Singleton(){}<br> private static Singleton instance = new Singleton();</p> 
<pre><code>public static Singleton getInstance() {
    return instance;
}
</code></pre> 
<p>}<br> 懒汉式实现</p> 
<p>public class Singleton {<!-- --><br> private DoubleCheckSingleton(){}<br> private volatile static Singleton instance;</p> 
<pre><code>public static Singleton getInstance() {
    if(instance == null) {
        synchronized (Singleton.class) {
            if (instance == null) {
                instance = new Singleton();
            }
        }
    }
    return instance;
}
</code></pre> 
<p>}<br> 7.简述代理模式<br> 代理模式为其他对象提供一种代理以控制对这个对象的访问。优点是可以增强目标对象的功能，降低代码耦合度，扩展性好。缺点是在客户端和目标对象之间增加代理对象会导致请求处理速度变慢，增加系统复杂度。</p> 
<p>静态代理：在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p> 
<p>动态代理：程序运行期间动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</p> 
<p>8.简述适配器模式<br> 适配器模式将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。</p> 
<p>9.简述模板模式<br> 模板模式定义了一个操作中的算法的骨架，并将一些步骤延迟到子类，适用于抽取子类重复代码到公共父类。<br> 可以封装固定不变的部分，扩展可变的部分。但每一个不同实现都需要一个子类维护，会增加类的数量。</p> 
<p>10.简述装饰器模式<br> 装饰器模式可以动态地给对象添加一些额外的属性或行为，即需要修改原有的功能，但又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。</p> 
<p>11.简述观察者模式<br> 观察者模式表示的是一种对象与对象之间具有依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p> 
<h2>
<a id="_1023"></a>六、数据结构与算法</h2> 
<h3>
<a id="1_1024"></a>1.简述数据结构栈</h3> 
<p>栈是一种线性表，其限制只能在表尾进行插入或删除操作。由于该特性又称为后进先出的线性表。</p> 
<h3>
<a id="2_1027"></a>2.简述数据结构队列</h3> 
<p>队列是一种先进先出的线性表。其限制只能在线性表的一端进行插入，而在另一端删除元素。</p> 
<h3>
<a id="3_1030"></a>3.简述二叉树</h3> 
<p>二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成。</p> 
<h3>
<a id="4_1033"></a>4.简述满二叉树</h3> 
<p>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树</p> 
<h3>
<a id="5_1036"></a>5.简述完全二叉树</h3> 
<p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p> 
<h3>
<a id="6_1039"></a>6.简述二叉树的前中后序遍历算法</h3> 
<p>前序遍历：若二叉树为空树，则执行空逻辑，否则：</p> 
<ol>
<li>访问根节点</li>
<li>递归前序遍历左子树</li>
<li>递归前序遍历右子树</li>
</ol> 
<p>中序遍历：若二叉树为空树，则执行空逻辑，否则：</p> 
<ol>
<li>递归中序遍历左子树</li>
<li>访问根节点</li>
<li>递归中序遍历右子树</li>
</ol> 
<p>后序遍历：若二叉树为空树，则执行空逻辑，否则：</p> 
<ol>
<li>递归后序遍历左子树</li>
<li>递归后序遍历右子树</li>
<li>访问根节点</li>
</ol> 
<h3>
<a id="7Hash_1055"></a>7.简述解决Hash冲突的方法</h3> 
<p>开放定址法：当发生哈希冲突时，如果哈希表未被装满，那么可以把这个值存放到冲突位置中的下一个空位置中去</p> 
<p>链地址法：对相同的哈希地址，设置一个单链表，单链表内放的都是哈希冲突元素。</p> 
<h3>
<a id="8AVL_1060"></a>8.简述AVL树</h3> 
<p>AVL树是一种改进版的搜索二叉树，其引入平衡因子（左子支高度与右子支高度之差的绝对值），通过旋转使其尽量保持平衡。<br> 任何一个节点的左子支高度与右子支高度之差的绝对值不超过1。</p> 
<h3>
<a id="9_1064"></a>9.简述红黑树</h3> 
<p>红黑树本身是有2-3树发展而来，红黑树是保持平衡的二叉树，其查找会比AVL树慢一点，添加和删除元素会比AVL树快一点。增删改查统计性能上讲，红黑树更优。<br> 红黑树主要特征是在每个节点上增加一个属性表示节点颜色，可以红色或黑色。红黑树和 AVL 树类似，都是在进行插入和删除时通过旋转保持自身平衡，从而获得较高的查找性能。红黑树保证从根节点到叶尾的最长路径不超过最短路径的 2 倍，所以最差时间复杂度是 O(logn)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除之后的自平衡调整。</p> 
<h3>
<a id="10_1068"></a>10.简述稳定排序和非稳定排序的区别</h3> 
<p>稳定排序：排序前后两个相等的数相对位置不变，则算法稳定<br> 非稳定排序：排序前后两个相等的数相对位置发生了变化，则算法不稳定</p> 
<h3>
<a id="11_1072"></a>11.常见的稳定排序算法有哪些</h3> 
<p>插入排序、冒泡排序、归并排序</p> 
<h3>
<a id="12_1075"></a>12.常见的不稳定排序算法有哪些</h3> 
<p>希尔排序、直接选择排序、堆排序、快速排序</p> 
<h3>
<a id="13_1078"></a>13.简述插入排序</h3> 
<p>插入排序：每一趟将一个待排序记录按其关键字的大小插入到已排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。<br> 排序算法稳定。时间复杂度 O(n²)，空间复杂度 O(1)。</p> 
<h3>
<a id="14_1082"></a>14.简述希尔排序</h3> 
<p>希尔排序：把记录按下标的一定增量分组，对每组进行直接插入排序，每次排序后减小增量，当增量减至 1 时排序完毕。<br> 排序算法不稳定。时间复杂度 O(nlogn)，空间复杂度 O(1)。</p> 
<h3>
<a id="15_1086"></a>15.简述直接选择排序</h3> 
<p>直接选择排序：每次在未排序序列中找到最小元素，和未排序序列的第一个元素交换位置，再在剩余未排序序列中重复该操作直到所有元素排序完毕。<br> 排序算法不稳定。时间复杂度 O(n²)，空间复杂度 O(1)。</p> 
<h3>
<a id="16_1090"></a>16.简述堆排序</h3> 
<p>堆排序：将待排序数组看作一个树状数组，建立一个二叉树堆。通过对这种数据结构进行每个元素的插入，完成排序工作。<br> 排序算法不稳定，时间复杂度 O(nlogn)，空间复杂度 O(1)。</p> 
<h3>
<a id="17_1094"></a>17.简述冒泡排序</h3> 
<p>冒泡排序：比较相邻的元素，如果第一个比第二个大就进行交换，对每一对相邻元素做同样的工作。<br> 排序算法稳定，时间复杂度 O(n²)，空间复杂度 O(1)。</p> 
<h3>
<a id="18_1098"></a>18.简述快速排序</h3> 
<p>快速排序：随机选择一个基准元素，通过一趟排序将要排序的数据分割成独立的两部分，一部分全部小于等于基准元素，一部分全部大于等于基准元素，再按此方法递归对这两部分数据进行快速排序。<br> 排序算法不稳定，时间复杂度 O(nlogn)，空间复杂度 O(logn)。</p> 
<h3>
<a id="19_1102"></a>19.简述归并排序</h3> 
<p>归并排序：将待排序序列分成两部分，然后对两部分分别递归排序，最后进行合并。<br> 排序算法稳定，时间复杂度都为 O(nlogn)，空间复杂度为 O(n)。</p> 
<h3>
<a id="20_1106"></a>20.简述图</h3> 
<p>图是由顶点集合和顶点之间的边集合组成的一种数据结构，分为有向图和无向图。<br> 有向图：边具有方向性<br> 无向图：边不具有方向性</p> 
<h3>
<a id="21_1111"></a>21.简述邻接矩阵</h3> 
<p>用一个二维数组存放图顶点间关系的数据，这个二维数组称为邻接矩阵。<br> 对于无向图，邻接矩阵是对称矩阵</p> 
<h3>
<a id="22_1115"></a>22.简述邻接表</h3> 
<p>邻接表是通过链表表示图连接关系的一种方。对于表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。</p> 
<h3>
<a id="23DFS_1118"></a>23.简述图的深度优先搜索DFS</h3> 
<p>将图中每个顶点的访问标志设为 FALSE, 之后搜索图中每个顶点，如果未被访问，则以该顶点V0为起始点出发，访问此顶点，然后依次从V0的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和V0有路径相通的顶点都被访问到。</p> 
<h3>
<a id="24_1121"></a>24.简述图的广度优先搜索</h3> 
<p>从图中的某个顶点V0出发，并在访问此顶点之后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访问到。</p> 
<h3>
<a id="25_1124"></a>25.简述最小生成树和其对应的算法</h3> 
<p>对于有 n 个结点的原图，生成原图的极小连通子图，其包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p> 
<p>普里姆算法：取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n-1 个顶点为止。</p> 
<p>克鲁斯卡尔算法：先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止。</p> 
<h3>
<a id="26_1131"></a>26.简述最短路径算法</h3> 
<p>Dijkstral算法为求解一个点到其余各点最小路径的方法，其算法为：<br> 假设我们求解的是顶点v到其余各个点的最短距离。n次循环至n个顶点全部遍历：</p> 
<ol>
<li>从权值数组中找到权值最小的，标记该边端点k</li>
<li>打印该路径及权值</li>
<li>如果存在经过顶点k到顶点i的边比v-&gt;i的权值小</li>
<li>更新权值数组及对应路径</li>
</ol> 
<h3>
<a id="27_1139"></a>27.简述堆</h3> 
<p>堆是一种完全二叉树形式，其可分为最大值堆和最小值堆。<br> 最大值堆：子节点均小于父节点，根节点是树中最大的节点。<br> 最小值堆：子节点均大于父节点，根节点是树中最小的节点。</p> 
<h3>
<a id="28set_1144"></a>28.简述set</h3> 
<p>Set是一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。</p> 
<h3>
<a id="29_1147"></a>29.说一下对于树的理解</h3> 
<p>数据结构树是一种由有限节点组成的层次关系的集合。其特点如下：</p> 
<ol>
<li>每个节点有零个或多个子节点；</li>
<li>只有一个节点没有父节点，该节点称为根节点；</li>
<li>除根节点外，每个节点有且只有一个父节点；</li>
</ol> 
<h3>
<a id="30_1153"></a>30.简述二叉查找树</h3> 
<ol>
<li>二叉查找树的左子树若不为空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>二叉查找树的右子树若不为空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>二叉查找树的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的结点。</li>
</ol> 
<h2>
<a id="_1159"></a>七、操作系统</h2> 
<h3>
<a id="1_1160"></a>1.什么是操作系统？请简要概述一下</h3> 
<p>操作系统是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。<br> 向上对用户程序提供接口，向下接管硬件资源。<br> 操作系统本质上也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。</p> 
<h3>
<a id="2_1165"></a>2.操作系统有哪些分类？</h3> 
<p>操作系统常规可分为批处理操作系统、分时操作系统、实时操作系统。<br> 若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统。<br> 常见的通用操作系统有：Windows、Linux、MacOS等。</p> 
<h3>
<a id="3_1170"></a>3.什么是内核态和用户态？</h3> 
<p>为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。</p> 
<p>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</p> 
<p>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。</p> 
<p>用户程序运行在用户态,操作系统内核运行在内核态。</p> 
<h3>
<a id="4_1179"></a>4.如何实现内核态和用户态的切换？</h3> 
<p>处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。</p> 
<ol>
<li>系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。</li>
<li>异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。</li>
<li>外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。</li>
</ol> 
<h3>
<a id="5_1185"></a>5.并发和并行的区别</h3> 
<ol>
<li> <p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，指令之间交错执行，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。</p> </li>
<li> <p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p> </li>
</ol> 
<h3>
<a id="6_1190"></a>6.什么是进程？</h3> 
<p>进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。</p> 
<p>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。</p> 
<p>上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它是栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p> 
<p>进程一般由以下的部分组成：</p> 
<ol>
<li>进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区（用于进程切换），占有的资源清单等。</li>
<li>程序段</li>
<li>数据段</li>
</ol> 
<h3>
<a id="7_1202"></a>7.进程的基本操作</h3> 
<p>以Unix系统举例：</p> 
<ol>
<li> <p>进程的创建：fork()。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。fork函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明 确的方法来分辨程序是在父进程还是在子进程中执行。<br> pid_t fork(void);</p> </li>
<li> <p>回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用waitpid 函数来等待它的子进程终止或者停止。<br> pid_t waitpid(pid_t pid, int *statusp, int options);</p> </li>
<li> <p>加载并运行程序：execve 函数在当前进程的上下文中加载并运行一个新程序。<br> int execve(const char *filename, const char *argv[], const char *envp[]);</p> </li>
<li> <p>进程终止：<br> void exit(int status);</p> </li>
</ol> 
<h3>
<a id="8_1216"></a>8.简述进程间通信方法</h3> 
<p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p> 
<p>不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。</p> 
<p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p> 
<h3>
<a id="9_1223"></a>9.进程如何通过管道进行通信</h3> 
<p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p> 
<ol>
<li>其本质是一个伪文件(实为内核缓冲区)</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端。</li>
<li>规定数据从管道的写端流入管道，从读端流出。</li>
</ol> 
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区实现。</p> 
<p>管道的局限性：</p> 
<ol>
<li>数据自己读不能自己写。</li>
<li>数据一旦被读走，便不在管道中存在，不可反复读取。</li>
<li>由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</li>
<li>只能在有公共祖先的进程间使用管道。</li>
</ol> 
<h3>
<a id="10_1237"></a>10.进程如何通过共享内存通信？</h3> 
<p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p> 
<p>特点：</p> 
<ol>
<li>共享内存是最快的一种IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。</li>
<li>因为多个进程可以同时操作，所以需要进行同步处理。</li>
<li>信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li>
</ol> 
<h3>
<a id="11_1245"></a>11.什么是信号</h3> 
<p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。</p> 
<ol>
<li>发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送<br> 信号可以有如下两种原因： 
  <ul>
<li>内核检测到一个系统事件，比如除零错误或者子进程终止。</li>
<li>一个进程调用了kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li>
</ul> </li>
<li>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。</li>
</ol> 
<h3>
<a id="12_1254"></a>12.如何编写正确且安全的信号处理函数</h3> 
<ol>
<li> <p>处理程序要尽可能简单。 避免麻烦的最好方法是保持处理程序尽可能小和简单。<br> 例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查(并重置)这个标志。</p> </li>
<li> <p>在处理程序中只调用异步信号安全的函数。<br> 所谓异步信号安全的函数(或简称安全的函数)能够被信号处理程序安全地调用，原因有二：要么它是可重入的(例如只访问局部变量），要么它不能被信号处理程序中断。</p> </li>
<li> <p>保存和恢复errno。<br> 许多Linux 异步信号安全的函数都会在出错返回时设置errno在处理程序中调用这样的函数可能会干扰主程序中其他依赖。解决方法是在进人处理程序时把errno 保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用_exit终止该进程，那么就不需要这样做了。</p> </li>
<li> <p>阻塞所有的信号，保护对共享全局数据结构的访问。<br> 如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构d 通常需要一系列的指令，如果指令序列被访问d 的处理程序中断，那么处理程序可能会发现d 的状态不一致，得到不可预知的结果。在访问d时暂时阻塞信号保证了处理程序不会中断该指令序列。</p> </li>
<li> <p>用volatile 声明全局变量。<br> 考虑一个处理程序和一个main 函数，它们共享一个全局变量g 。处理程序更新g，main 周期性地读g， 对于一个优化编译器而言，main 中g的值看上去从来没有变化过，因此使用缓存在寄存器中g 的副本来满足对g 的每次引用是很安全的。如果这样，main 函数可能永远都无法看到处理程序更新过的值。可以用volatile 类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如：volatile 限定符强迫编译器毎次在代码中引用g时，都要从内存中读取g的值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。<br> volatile int g;</p> </li>
<li> <p>用sig_atomic_t声明标志。<br> 在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供一种整型数据类型sig_atomic_t对它的读和写保证会是原子的（不可中断的）。</p> </li>
<li> <p>信号的一个与直觉不符的方面是未处理的信号是不排队的。<br> 因为 pending 位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了。</p> </li>
</ol> 
<h3>
<a id="13_1277"></a>13.进程调度的时机</h3> 
<ol>
<li>当前运行的进程运行结束。</li>
<li>当前运行的进程由于某种原因阻塞。</li>
<li>执行完系统调用等系统程序后返回用户进程。</li>
<li>在使用抢占调度的系统中，具有更高优先级的进程就绪时。</li>
<li>分时系统中，分给当前进程的时间片用完。</li>
</ol> 
<h3>
<a id="14_1284"></a>14.不能进行进程调度的情况</h3> 
<ol>
<li>在中断处理程序执行时。</li>
<li>在操作系统的内核程序临界区内。</li>
<li>其它需要完全屏蔽中断的原子操作过程中。</li>
</ol> 
<h3>
<a id="15_1289"></a>15.进程的调度策略</h3> 
<ol>
<li>先到先服务调度算法</li>
<li>短作业优先调度算法</li>
<li>优先级调度算法</li>
<li>时间片轮转调度算法</li>
<li>高响应比优先调度算法</li>
<li>多级队列调度算法</li>
<li>多级反馈队列调度算法</li>
</ol> 
<h3>
<a id="16_1298"></a>16.进程调度策略的基本设计指标</h3> 
<ol>
<li>CPU利用率</li>
<li>系统吞吐率，即单位时间内CPU完成的作业的数量。</li>
<li>响应时间。</li>
<li>周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键 
  <ul>
<li>平均周转时间</li>
<li>带权周转时间</li>
<li>平均带权周转时间</li>
</ul> </li>
</ol> 
<h3>
<a id="17_1307"></a>17.进程的状态与状态转换</h3> 
<p>进程在运行时有三种基本状态：就绪态、运行态和阻塞态。</p> 
<ol><li>运行（running）态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。</li></ol> 
<p>2.就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p> 
<p>3.阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。</p> 
<p>各状态之间的转换：</p> 
<ol>
<li>就绪→执行 处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。</li>
<li>执行→就绪 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。</li>
<li>执行→阻塞 正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。</li>
<li>阻塞→就绪 处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。</li>
</ol> 
<h3>
<a id="18_1322"></a>18.什么是孤儿进程？僵尸进程?</h3> 
<ol>
<li>孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。</li>
<li>僵尸进程： 进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。</li>
</ol> 
<h3>
<a id="19_1326"></a>19.什么是线程？</h3> 
<ol>
<li>线程是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保证程序的实时性，实现进程内部的并发。</li>
<li>线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。</li>
<li>每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</li>
</ol> 
<h3>
<a id="20_1331"></a>20.为什么需要线程？</h3> 
<p>线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；<br> 但是其具有一些缺点：</p> 
<ol>
<li>进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。</li>
<li>进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。</li>
</ol> 
<p>引入线程就是为了解决以上进程的不足，线程具有以下的优点：</p> 
<ol>
<li>从资源上来讲，开辟一个线程所需要的资源要远小于一个进程。</li>
<li>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间（这种时间的差异主要由于缓存的大量未命中导致）。</li>
<li>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其它线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。</li>
</ol> 
<h3>
<a id="21_1342"></a>21.简述线程和进程的区别和联系</h3> 
<ol>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li>
<li>进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</li>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位。</li>
<li>通信：由于同一进程中的多个线程具有相同的地址空间，使它们之间的同步和通信的实现，也变得比较容易。进程间通信 IPC ，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法，以保证数据的一致性）。</li>
<li>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</li>
<li>进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。</li>
<li>进程适应于多核、多机分布；线程适用于多核。</li>
</ol> 
<h3>
<a id="22API_1351"></a>22.进程和线程的基本API</h3> 
<p>进程API以Unix系统为例，线程相关的API属于Posix线程(Pthreads)标准接口</p> 
<table>
<thead><tr>
<th>进程源语</th>
<th>线程源语</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>fork</td>
<td>pthread_create</td>
<td>创建新的控制流</td>
</tr>
<tr>
<td>exit</td>
<td>pthread_exit</td>
<td>从现有的控制流中退出</td>
</tr>
<tr>
<td>waitpid</td>
<td>pthread_join</td>
<td>从控制流中得到退出状态</td>
</tr>
<tr>
<td>atexit</td>
<td>pthread_cancel_push</td>
<td>注册在退出控制流时调用的函数</td>
</tr>
<tr>
<td>getpid</td>
<td>pthread_self</td>
<td>获取控制流的ID</td>
</tr>
<tr>
<td>abort</td>
<td>pthread_cancel</td>
<td>请求控制流的非正常退出</td>
</tr>
</tbody>
</table>
<h3>
<a id="23_1362"></a>23.多线程模型</h3> 
<ol>
<li>多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。</li>
<li>一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux和Windows操作系统家族都是使用一对一模型。</li>
<li>多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。</li>
</ol> 
<h3>
<a id="24_1367"></a>24.进程同步的方法</h3> 
<p>操作系统中，进程是具有不同的地址空间的，两个进程是不能感知到对方的存在的。有时候，需要多个进程来协同完成一些任务。</p> 
<p>当多个进程需要对同一个内核资源进行操作时，这些进程便是竞争的关系，操作系统必须协调各个进程对资源的占用，进程的互斥是解决进程间竞争关系的方法。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。</p> 
<p>当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程的同步问题。需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。进程互斥本质上也是一种进程同步。</p> 
<p>进程的同步方法：</p> 
<ol>
<li>互斥锁</li>
<li>读写锁</li>
<li>条件变量</li>
<li>记录锁(record locking)</li>
<li>信号量</li>
<li>屏障（barrier）</li>
</ol> 
<h3>
<a id="25_1382"></a>25.线程同步的方法</h3> 
<p>操作系统中，属于同一进程的线程之间具有相同的地址空间，线程之间共享数据变得简单高效。遇到竞争的线程同时修改同一数据或是协作的线程设置同步点的问题时，需要使用一些线程同步的方法来解决这些问题。</p> 
<p>线程同步的方法：</p> 
<ol>
<li>互斥锁</li>
<li>读写锁</li>
<li>条件变量</li>
<li>信号量</li>
<li>自旋锁</li>
<li>屏障（barrier）</li>
</ol> 
<h3>
<a id="26_1393"></a>26.进程同步与线程同步有什么区别</h3> 
<p>进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。</p> 
<h3>
<a id="27_1396"></a>27.死锁是怎样产生的？</h3> 
<p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待的现象。</p> 
<p>产生死锁需要满足下面四个条件：</p> 
<ol>
<li>互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。</li>
<li>占有并等待条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。</li>
<li>非抢占条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。</li>
<li>循环等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链。</li>
</ol> 
<h3>
<a id="28_1405"></a>28.如何解决死锁问题？</h3> 
<p>解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下:</p> 
<ol>
<li>资源一次性分配，这样就不会再有请求了（破坏请求条件）。</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有并等待条件）。</li>
<li>可抢占资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。</li>
<li>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</li>
</ol> 
<h3>
<a id="29_1412"></a>29.什么是虚拟地址，什么是物理地址？</h3> 
<p>地址空间是一个非负整数地址的有序集合。</p> 
<p>在一个带虚拟内存的系统中，CPU 从一个有N=pow(2,n)个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space）,现代系统通常支持 32 位或者 64 位虚拟地址空间。</p> 
<p>一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的M 个字节。</p> 
<p>地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。</p> 
<p>一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。</p> 
<p>主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p> 
<h3>
<a id="30_1425"></a>30.什么是虚拟内存？</h3> 
<p>为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：</p> 
<ol>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。</li>
<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>它保护了每个进程的地址空间不被其他进程破坏。</li>
</ol> 
<h3>
<a id="31_1431"></a>31.为什么要引入虚拟内存？</h3> 
<ol>
<li> <p>虚拟内存作为缓存的工具</p> 
  <ul>
<li>虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。</li>
<li>虚拟内存利用DRAM缓存来自通常更大的虚拟地址空间的页面。</li>
</ul> </li>
<li> <p>虚拟内存作为内存管理的工具。操作系统为每个进程提供了一个独立的页表，也就是独立的虚拟地址空间。多个虚拟页面可以映射到同一个物理页面上。</p> 
  <ul>
<li>简化链接： 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。 
    <ul><li>例如：一个给定的 linux 系统上的每个进程都是用类似的内存格式，对于64为地址空间，代码段总是从虚拟地址） 0x400000 开始，数据段，代码段，栈，堆等等。</li></ul> </li>
<li>简化加载： 虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页VP，把他们标记为无效（未被缓存） ，将页表条目指向目标文件的起始位置。 
    <ul><li>加载器从不在磁盘到内存实际复制任何数据，在每个页初次被引用时，虚拟内存系统会按照需要自动的调入数据页。</li></ul> </li>
<li>简化共享： 独立地址空间为OS提供了一个管理用户进程和操作系统自身之间共享的一致机制。 
    <ul>
<li>一般：每个进程有各自私有的代码，数据，堆栈，是不和其他进程共享的，这样OS创建页表，将虚拟页映射到不连续的物理页面。</li>
<li>某些情况下，需要进程来共享代码和数据。例如每个进程调用相同的操作系统内核代码，或者C标准库函数。OS会把不同进程中适当的虚拟页面映射到相同的物理页面。</li>
</ul> </li>
<li>简化内存分配： 虚拟内存向用户提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如 malloc ），OS分配一个适当k大小个连续的虚拟内存页面，并且将他们映射到物理内存中任意位置的k个任意物理页面，因此操作系统没有必要分配k个连续的物理内存页面，页面可以随机的分散在物理内存中。</li>
</ul> </li>
</ol> 
<p>虚拟内存作为内存保护的工具。不应该允许一个用户进程修改它的只读段，也不允许它修改任何内核代码和数据结构，不允许读写其他进程的私有内存，不允许修改任何与其他进程共享的虚拟页面。每次CPU生成一个地址时， MMU 会读一个 PTE ，通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。</p> 
<h3>
<a id="32_1448"></a>32.常见的页面置换算法</h3> 
<p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p> 
<ul>
<li> <p>先进先出(FIFO)算法：</p> 
  <ul>
<li>思路：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。</li>
<li>实现：按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</li>
<li>特点：实现简单；性能较差，调出的页面可能是经常访问的</li>
</ul> </li>
<li> <p>最近最少使用（ LRU ）算法:</p> 
  <ul>
<li>思路： 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</li>
<li>实现：缺页时，计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面</li>
<li>特点：可能达到最优的效果，维护这样的访问链表开销比较大<br> 当前最常采用的就是 LRU 算法。</li>
</ul> </li>
<li> <p>最不常用算法（ Least Frequently Used, LFU ）</p> 
  <ul>
<li>思路：缺页时，置换访问次数最少的页面</li>
<li>实现：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面</li>
<li>特点：算法开销大，开始时频繁使用，但以后不使用的页面很难置换</li>
</ul> </li>
</ul> 
<h3>
<a id="33_1466"></a>33.请说一下什么是写时复制？</h3> 
<ol>
<li>写时复制是指：在并发访问的情景下，当需要修改JAVA中Containers的元素时，不直接修改该容器，而是先复制一份副本，在副本上进行修改。修改完成之后，将指向原来容器的引用指向新的容器(副本容器)。</li>
<li>写时复制带来的影响<br> ①由于不会修改原始容器，只修改副本容器。因此，可以对原始容器进行并发地读。其次，实现了读操作与写操作的分离，读操作发生在原始容器上，写操作发生在副本容器上。<br> ②数据一致性问题：读操作的线程可能不会立即读取到新修改的数据，因为修改操作发生在副本上。但最终修改操作会完成并更新容器，因此这是最终一致性。</li>
</ol> 
<h3>
<a id="34_1472"></a>34.实时操作系统的概念</h3> 
<p>实时操作系统（Real-time operating system, RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。 实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</p> 
<h3>
<a id="35_1475"></a>35.优先级反转是什么？如何解决</h3> 
<p>由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转(Priority Inversion)。其实,优先级反转是在高优级(假设为A)的任务要访问一个被低优先级任务(假设为C)占有的资源时,被阻塞.而此时又有优先级高于占有资源的任务©而低于被阻塞的任务(A)的优先级的任务(假设为B)时,于是,占有资源的任务就被挂起(占有的资源仍为它占有),因为占有资源的任务优先级很低,所以,它可能一直被另外的任务挂起.而它占有的资源也就一直不能释放,这样,引起任务A一直没办法执行.而比它优先低的任务却可以执行。</p> 
<p>目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承(priority inheritance)；另一种被称作优先级极限(priority ceilings)。</p> 
<ol>
<li>优先级继承(priority inheritance) 优先级继承是指将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升。</li>
<li>优先级天花板(priority ceilings)优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级.(这个优先级称为该资源的优先级天花板)。</li>
</ol> 
<h3>
<a id="36_select_1482"></a>36.简述 select</h3> 
<p>select是一种多路复用技术。其收到所有输入的文件描述符，返回哪些文件有新数据。<br> 其可以设置为阻塞或者非阻塞状态，底层采用1024位bitmap做实现，因此有文件描述符上限数。</p> 
<h3>
<a id="37poll_1486"></a>37.简述poll</h3> 
<p>poll是一种多路复用技术。其收到所有输入的文件描述符，返回哪些文件有新数据。<br> 其通过链表代替了之前select的数据结构，使得其没有上限限制。</p> 
<h3>
<a id="38epoll_1490"></a>38.简述epoll</h3> 
<p>epoll是一种多路复用技术。其采用一个文件描述符管理多个输入的文件描述符，采用事件回调的方式，提高了程序运行效率。</p> 
<h3>
<a id="39_1493"></a>39.简述虚拟地址到物理地址转化过程</h3> 
<p>虚拟地址由虚拟页号和页偏移两部分组成。<br> 通过虚拟地址的页面号，首先在快表中查询是否有该映射，查询不成功，在页表中找到该页对应的物理地址。<br> 然后通过页物理地址+页偏移，得到真实的物理地址</p> 
<h3>
<a id="40_1498"></a>40.简述页表</h3> 
<p>页表用于存储虚拟地址中的虚拟页面号和物理页面号的映射关系。<br> 除此之外，有些页的读写有限制，页表也通过其他存储位，标记该页访问位，是否在内存中（可能被页面置换出去了）等等。</p> 
<h3>
<a id="41_1502"></a>41.简述多级页表</h3> 
<p>多级页表用于减少内存的占用。以二级页表为例，虚拟地址被分为DIR,PAGE和offset三部分，通过顶级页表和DIR，寻找到该二级页表的起始位置，再通过二级页表的起始位置和PAGE，找到页物理地址，最后加上页偏移，即可得到最终的物理地址。</p> 
<h3>
<a id="42_1505"></a>42.简述快表</h3> 
<p>快表也称为页表高速缓存。其会存储一定数量的页表项，以此加快虚拟地址到物理地址的映射速度。</p> 
<h3>
<a id="43MMU_1508"></a>43.简述MMU</h3> 
<p>MMU即内存管理单元，该硬件负责处理虚拟地址到物理地址的转化工作。快表也存储在MMU上。</p> 
<h3>
<a id="44_1511"></a>44.进程调度算法</h3> 
<p>先来先服务调度算法：创建一个任务队列，一旦有新任务就加入这个队列，CPU完成一个任务后就从队列取任务。</p> 
<p>短作业(进程)优先调度算法：针对较短的作业，优先调给CPU工作。</p> 
<p>时间片轮转算法：每个时间片依次执行一个任务，时间片结束后将该任务放回任务队列。</p> 
<p>多级反馈队列：也按时间片轮转算法执行任务，设置n个队列，当第一个队列任务为空，才执行第二个队列，依次类推。如果在i队列的任务在该时间片执行后没有完成，即插入i+1号队列</p> 
<h2>
<a id="_1520"></a>八、计算机网络</h2> 
<h3>
<a id="1OSI_1521"></a>1.简述OSI七层协议</h3> 
<p>OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层</p> 
<h3>
<a id="2TCPIP_1524"></a>2.简述TCP/IP五层协议</h3> 
<p>TCP/IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层</p> 
<h3>
<a id="3_1527"></a>3.物理层有什么作用</h3> 
<p>主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。</p> 
<h3>
<a id="4_1530"></a>4.数据链路层有什么作用</h3> 
<p>在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。</p> 
<h3>
<a id="5_1533"></a>5.网络层有什么作用</h3> 
<p>将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。</p> 
<h3>
<a id="6_1536"></a>6.传输层有什么作用</h3> 
<p>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p> 
<h3>
<a id="7_1539"></a>7.会话层有什么作用</h3> 
<p>建立会话：身份验证，权限鉴定等；<br> 保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输数据；<br> 断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。</p> 
<h3>
<a id="8_1544"></a>8.表示层有什么作用</h3> 
<p>对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</p> 
<h3>
<a id="9_1547"></a>9.应用层有什么作用</h3> 
<p>提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。</p> 
<h3>
<a id="10TCPUDP_1550"></a>10.TCP与UDP区别</h3> 
<p>TCP作为面向流的协议，提供可靠的、面向连接的运输服务，并且提供点对点通信<br> UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播</p> 
<h3>
<a id="11TCP_1554"></a>11.为何TCP可靠</h3> 
<p>TCP有三次握手建立连接，四次挥手关闭连接的机制。<br> 除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。<br> 对于每份报文也存在校验，保证每份报文可靠性。</p> 
<h3>
<a id="12UDP_1559"></a>12.为何UDP不可靠</h3> 
<p>UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。<br> 仅仅在IP数据报头部加入校验和复用。<br> UDP没有服务器和客户端的概念。<br> UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。</p> 
<h3>
<a id="13TCP_1565"></a>13.简述TCP粘包现象</h3> 
<p>TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。<br> 可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。</p> 
<h3>
<a id="14TCP_1569"></a>14.TCP粘包现象处理方法</h3> 
<p>固定发送信息长度，或在两个信息之间加入分隔符。</p> 
<h3>
<a id="15TCP_1572"></a>15.简述TCP协议的滑动窗口</h3> 
<p>滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。</p> 
<h3>
<a id="16TCP_1575"></a>16.简述TCP协议的拥塞控制</h3> 
<p>拥塞是指一个或者多个交换点的数据报超载，TCP又会有重传机制，导致过载。<br> 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量.</p> 
<p>当cwnd &lt; ssthresh 时，使用慢开始算法。<br> 当cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br> 当cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</p> 
<p>慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd指数增加。</p> 
<p>拥塞避免：cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。</p> 
<p>快恢复之前的策略：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。</p> 
<p>快恢复：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并把cwnd设置为ssthresh的一半，之后进行拥塞避免。</p> 
<h3>
<a id="17_1591"></a>17.简述快重传</h3> 
<p>如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。</p> 
<h3>
<a id="18TCP_1594"></a>18.TCP三次握手过程</h3> 
<ol>
<li>第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端进入syn_sent状态，等待服务端确认。</li>
<li>第二次握手:服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。</li>
<li>第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输数据了</li>
</ol> 
<h3>
<a id="19TCP_1599"></a>19.为什么TCP握手需要三次，两次行不行？</h3> 
<p>不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值。</p> 
<p>如果只是两次握手， 至多只有客户端的起始序列号能被确认， 服务器端的序列号则得不到确认。</p> 
<h3>
<a id="20_1604"></a>20.简述半连接队列</h3> 
<p>TCP握手中，当服务器处于SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。</p> 
<h3>
<a id="21SYN_1607"></a>21.简述SYN攻击</h3> 
<p>SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。</p> 
<p>优化方式：</p> 
<ol>
<li>缩短SYN Timeout时间</li>
<li>记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。</li>
</ol> 
<h3>
<a id="22TCP_1614"></a>22.TCP四次挥手过程</h3> 
<ol>
<li>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。</li>
<li>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li>
<li>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。</li>
<li>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。</li>
</ol> 
<h3>
<a id="23TCP4_1620"></a>23.为什么TCP挥手需要4次</h3> 
<p>主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。<br> 所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN包后发送 ACK 确认断开信息给服务端。</p> 
<h3>
<a id="242MSL_1624"></a>24.为什么四次挥手释放连接时需要等待2MSL</h3> 
<p>MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。</p> 
<h3>
<a id="25DNS_1627"></a>25.简述DNS协议</h3> 
<p>DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。</p> 
<h3>
<a id="26DNS_1630"></a>26.简述DNS解析过程</h3> 
<ol>
<li>客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器</li>
<li>本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找</li>
<li>本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器</li>
<li>根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址</li>
<li>客户机的dns服务器根据返回的信息接着访问下一级的dns服务器</li>
<li>这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息</li>
<li>客户机的本地的dns服务器会将查询结果返回给我们的客户</li>
</ol> 
<h3>
<a id="27HTTP_1639"></a>27.简述HTTP协议</h3> 
<p>http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。</p> 
<h3>
<a id="28cookie_1642"></a>28.简述cookie</h3> 
<p>HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP/1.1 引入 Cookie 来保存状态信息。</p> 
<p>Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。</p> 
<h3>
<a id="29session_1647"></a>29.简述session</h3> 
<p>session用于标记特定客户端信息，存在在服务器的一个文件里。<br> 一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。</p> 
<h3>
<a id="30http_1651"></a>30.简述http状态码和对应的信息</h3> 
<p>1XX：接收的信息正在处理<br> 2XX：请求正常处理完毕<br> 3XX：重定向<br> 4XX：客户端错误<br> 5XX：服务端错误<br> 常见错误码：<br> 301：永久重定向<br> 302：临时重定向<br> 304：资源没修改，用之前缓存就行<br> 400：客户端请求的报文有错误<br> 403：表示服务器禁止访问资源<br> 404：表示请求的资源在服务器上不存在或未找到</p> 
<h3>
<a id="31_1665"></a>31.转发和重定向的区别</h3> 
<p>转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p> 
<p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p> 
<h3>
<a id="32http10_1670"></a>32.简述http1.0</h3> 
<p>规定了请求头和请求尾，响应头和响应尾（get post）<br> 每一个请求都是一个单独的连接，做不到连接的复用</p> 
<h3>
<a id="33http11_1674"></a>33.简述http1.1的改进</h3> 
<p>HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。<br> 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。<br> 服务端无法主动push</p> 
<h3>
<a id="34HTTP_1679"></a>34.简述HTTP短连接与长连接区别</h3> 
<p>HTTP中的长连接短连接指HTTP底层TCP的连接。<br> 短连接： 客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。<br> 长连接：如果HTTP头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。</p> 
<h3>
<a id="35http20_1684"></a>35.简述http2.0的改进</h3> 
<p>提出多路复用。多路复用前，文件是串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。<br> 引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。</p> 
<h3>
<a id="36httphttps_1688"></a>36.http与https的区别</h3> 
<p>http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。<br> https具有安全性的ssl加密传输协议，加密采用对称加密，<br> https协议需要到ca申请证书，一般免费证书很少，需要交费。</p> 
<h3>
<a id="37TLSSSL_HTTP_HTTPS_1693"></a>37.简述TLS/SSL, HTTP, HTTPS的关系</h3> 
<p>SSL全称为Secure Sockets Layer即安全套接层，其继任为TLS（Transport Layer Security）传输层安全协议，均用于在传输层为数据通讯提供安全支持。<br> 可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL</p> 
<h3>
<a id="38https_1697"></a>38.https的连接过程</h3> 
<ol>
<li>浏览器将支持的加密算法信息发给服务器</li>
<li>服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器</li>
<li>客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为clientkey，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。</li>
<li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器</li>
<li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li>
<li>服务器将加密后的密文发送给客户端</li>
<li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成</li>
</ol> 
<h3>
<a id="39GetPost_1706"></a>39.Get与Post区别</h3> 
<p>Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。<br> Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。</p> 
<h3>
<a id="40Get_1710"></a>40.Get方法参数有大小限制吗</h3> 
<p>一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。</p> 
<h3>
<a id="41REST_API_1713"></a>41.了解REST API吗</h3> 
<p>REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：<br> Create ： POST<br> Read ： GET<br> Update ： PUT/PATCH<br> Delete： DELETE</p> 
<h3>
<a id="42_1720"></a>42.浏览器中输入一个网址后，具体发生了什么</h3> 
<ol>
<li>进行DNS解析操作，根据DNS解析的结果查到服务器IP地址</li>
<li>通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接</li>
<li>浏览器生成HTTP报文，发送HTTP请求，等待服务器响应</li>
<li>服务器处理请求，并返回给浏览器</li>
<li>根据HTTP是否开启长连接，进行TCP的挥手过程</li>
<li>浏览器根据收到的静态资源进行页面渲染</li>
</ol> 
<h3>
<a id="43http_1728"></a>43.http请求包含了什么</h3> 
<p>包含：请求方法字段、URL字段、HTTP协议版本<br> 产生请求的浏览器类型，请求数据，主机地址。</p> 
<h3>
<a id="44PutDelete_1732"></a>44.Put与Delete区别</h3> 
<p>Put规定默认为更新某一资源，和Post一样，一般该操作会对服务器资源进行改变<br> Delete规定默认为删除某一资源，和Post一样，一般该操作会对服务器资源进行改变</p> 
<h3>
<a id="45DNS_1736"></a>45.简述DNS劫持</h3> 
<p>DNS是指将网页域名翻译为对应的IP的一种方法。DNS劫持指攻击者篡改结果，使用户对域名的解析IP变成了另一个IP</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>