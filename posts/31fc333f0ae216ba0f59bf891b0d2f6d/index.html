<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>ChatGPT作者John Schulman：我们成功的秘密武器 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ChatGPT作者John Schulman：我们成功的秘密武器</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p><img alt="840436629be9a6ca0aed492ac8f74532.png" height="445" src="https://images2.imgbox.com/1d/77/LWgGroII_o.png" width="678"></p> 
 <p><strong>来源｜TalkRL</strong></p> 
 <p><strong>OneFlow编译<br> 翻译｜杨婷、徐佳渝、贾川</strong></p> 
 <p>除了OpenAI，外界可能很少有人知道ChatGPT模型成功的真正原因，实际上，OpenAI也会对ChatGPT拥有的巨大影响力感到不可思议。这种困惑和惊喜就像工程师们解bug时获得的意外成功：We don't know why, but it works.</p> 
 <p>一种普遍的看法是，ChatGPT没有任何革命性技术，正如Meta 首席AI科学家Yann LeCun所说，“只是一些巧妙的技术组合而已”。当然，听到这话的围观群众不免调侃LeCun这种同行评议是“吃不到葡萄说葡萄酸”，不过，从ChatGPT的缔造者们后续的表态来看，恐怕也不会否认他的“酸话”。</p> 
 <p>早在2022年1月，OpenAI发布了另一款GPT-3.5微调版本InstructGPT，这是ChatGPT的“兄弟模型”，如果用标准基准来评估它们的原始技术能力，两个模型之间并没有实质性不同。根据OpenAI科学家们的说法，ChatGPT用的微调方法稍有不同，并且添加了一些对话数据，这让ChatGPT更易上手和易用，由此产生了很大的正面影响。</p> 
 <p>新增的对话数据固然重要，不过，<strong>让ChatGPT更容易推断出用户的意图，产生质变的根本原因是已在InstructGPT使用的“人类反馈的强化学习（RLHF）”技术</strong>，OpenAI联合创始人、研究科学家John Schulman认为，<strong>RLHF才是ChatGPT的秘密武器（secret sauce）。</strong></p> 
 <p>简单来说，强化学习是让研究者像训练狗一样训练AI智能体，并为其做出的正确响应提供奖励，而RLHF的基本思路是，<strong>教会大型语言模型学习人类用户真正喜欢的回答偏好来进一步调整模型的响应。</strong></p> 
 <p>RLHF技术背后的其中一个作者正是John Schulman，很多人不知道的是，<strong>他也是ChatGPT项目的主要负责人。</strong></p> 
 <p>作为强化学习大牛，John在这一领域作出过许多重大贡献，例如发明了TRPO算法（信赖域策略优化，Trust Region Policy Optimization）、GAE（广义优势估计，Generalized Advantage Estimation）以及TRPO的后代近端策略优化（ Proximal Policy Optimization），也称PPO算法。值得一提的是，其博士导师是强化学习领域的开拓者Pieter Abbeel，并且也在OpenAI创立初期工作过一段时间。</p> 
 <p>在ChatGPT发布前一个月，John Schulman在Robin Ranjit Singh Chauhan主持的TalkRL播客节目中，详细介绍了RLHF想法的产生源头，InstructGPT以WebGPT的主要思想，并阐述了AI对齐以及对AGI实现的看法。从中，我们也可以看到ChatGPT技术演进的脉络和不曾在论文中被描述的细节，以及OpenAI团队的下一步研究方向。</p> 
 <p style="text-align:left">（以下内容经授权后由OneFlow编译发布，译文转载请联系OneFlow获得授权。来源：https://www.talkrl.com/episodes/john-schulman）</p> 
 <h2></h2> 
 <p style="text-align:center"><strong>1</strong></p> 
 <p style="text-align:center"><strong>为什么要关注RLHF</strong></p> 
 <p><strong>Robin Chauhan：作为深度强化学习的早期开拓者之一，你为什么去关注“人类反馈的强化学习（RLHF）”？</strong></p> 
 <p><strong>John Schulman：</strong>GPT-3训练完成后，它的智能程度让我十分吃惊。我意识到AI领域的下一个前沿在于真正发挥语言模型的作用。我仍然对RL非常感兴趣，但解决RL基准测试并不是我们的最终目的。</p> 
 <p>要使用RL算法，必须通过奖励函数，但是奖励函数从何而来？在RL基准测试中，我们可以自己编写奖励函数，但这种方法必须要在模拟环境（simulator environment）中才行得通。所以在现实世界用例中，我们必须要人工监督AI的行为，以分辨好坏。所以如何定义奖励是一件极具挑战性且至关重要的问题，尤其是在任务评估难度逐渐加深的情况下。</p> 
 <p>另一方面，虽然现在语言模型非常聪明，但却难以将它们用在有价值的事情上。因为它们不会按照我们的意愿去工作，只是在单纯地模仿训练语料库，但这也说明只要给语言模型一个正确的目标，它们就很有可能改进上述问题，也就是说，我们可以在语言模型中应用强化学习，使用人类反馈去定义奖励。</p> 
 <p><strong>Robin Chauhan：相比合成奖励（synthetic reward），人工反馈是否更难，或者说这两者之间在一定程度上大有不同？</strong></p> 
 <p><strong>John Schulman：</strong>使用人工反馈会遇到很多新问题。现在，我们必须要动态收集数据集，所以要花很多时间去建立人类偏好的数据集，相比各种算法细节，数据集的质量更加重要。另外我们还要考虑如何将任务分配给人工训练师等问题，如果有程序化的奖励函数，这些问题我们本不用考虑。</p> 
 <p><strong>Robin Chauhan：人工评分员之间的差异或奖励信号的噪音是否会造成问题？</strong></p> 
 <p><strong>John Schulman：</strong>实际上，噪音并不是我最担心的问题，比较而言，我更担心人们的惯有偏见。例如，在问题回答或模型编写文本等设置中，人们通常更偏向于较长的答案，这会导致模型给出的答案日渐冗长。所以我们要注意指导人工评分员，让他们奖励简洁的答案，如果对这一问题不加注意，可能会激励模型的错误行为。</p> 
 <p style="text-align:center"><strong>2</strong></p> 
 <h2></h2> 
 <p style="text-align:center"><strong>用RLHF实现指令跟随模型InstructGPT</strong></p> 
 <p><strong>Robin <strong>Chauhan</strong>：2022年3月，你与Long Ouyang、Jeff Wu等人发表了论文《Training language models to follow instructions with human feedback》，你能简要介绍下InstructGPT的主要思想吗？</strong></p> 
 <p><strong>John Schulman：</strong>InstructGPT是一种经过微调以遵循指令的语言模型。OpenAI的官网上有一个大文本框，在文本框中输入内容后点击提交就可以完成一个指令。语言模型非常有用，只需输入提示词就可以使其来完成自己想做的事情。</p> 
 <p>比如你可以先在文本框中输入问答示例，然后你提出另外一个问题，InstructGPT就可以相同的方式予以回答，人们可以让语言模型通过提示来做一些很棒的事情。但“提示”本身也是一门艺术，很难做到准确无误，模型也不一定能完美识别提示的内涵。如果你只是采用原始模型与之对话，那么你得到的答案可能就有点不尽如人意了。</p> 
 <p>通过InstructGPT，我们发现要对语言模型进行一些小的改动，就可以使它们更容易使用。具体来说，我们要对它们进行训练，以便当你的一段文本包含指令时，模型可以尽力按照指令进行操作。几乎任何东西都可以作为指令。例如，指令可以是继续聊天，对这段文本进行总结，或者是提供一份销售某个小部件公司的名单。</p> 
 <p>这就是指令跟随模型（instruction following model），可以执行任何你给定的指令。不过我并不是这项工作的核心贡献者，我主要参与了强化学习基础设施和完成强化学习的训练细节。</p> 
 <p>在这个项目中我们所做的就是：<strong>在指令跟随设置中运行了RLHF中的整套方法论</strong>。所以我们进行了有监督微调（supervised fine tuning），收集偏好数据，训练了一个奖励模型（reward model），然后根据该奖励模型进行了强化学习。</p> 
 <p>在训练之初，我们使用的数据是由外包商收集的。但后来我们有了API和官网上的Playground（一个大文本框，可以在其中使用模型），我们就使用在Playground中收集到的指令来进行训练（用户在使用之时就会收到提示：你的指令可能会用于训练）。这样既可以收集偏好数据，又可以进行强化学习。同时需要注意：训练时不能存储prompt中的任何信息。我们有一套相当复杂的流程来确保没有私人信息泄露到模型中。</p> 
 <p>结果表明，这种方法非常有效。<strong>原始的语言模型通常很难按照指令执行。但是，通过强化学习训练后的指令跟随模型要好得多。</strong>如果仅从改进程度来看，那么几乎能媲美比这大100倍的模型。这是相当大的一个进步。</p> 
 <p><strong>Robin <strong>Chauhan</strong>：看来你想要得到可信任的模型，这是你的标准之一吗？</strong></p> 
 <p><strong>John Schulman：</strong>对于一个大型语言模型来说，真实性是重要标准之一。但是，这个模型是如何通过示例学习真实性的？难道真实性在模型内部被表示了吗？因为模型没有外部参考来确认某些东西是真实的还是虚假的，那么它如何知道什么是真实的？</p> 
 <p><strong>某种程度上，模型内部是有真实性表示的。</strong>我们可以将语言模型看作是对整个互联网的模仿，而互联网是由许多不同的人编写的，包含各种类型的内容，从小说到非小说，到技术文献、笑话以及论坛帖子等。因此，该模型实际上是由所有这些编写内容的人组成的“合奏团”。</p> 
 <p><strong>当我们输入一个prompt时，模型在内部必须要做的就是确定prompt是由谁编写的，并试图以该风格继续生成文本。</strong>比如，如果它认为正在阅读的内容是华尔街交易论坛上的东西，那么就继续以这种风格生成文本。但是如果它认为正在阅读纽约时报的内容，它又会以不同的方式写作。</p> 
 <p>因此，模型必须在某个地方进行计算，例如计算当前的风格是什么，或者正在模仿哪种较为小众的风格集合。<strong>至少，在进行监督微调或完全基于人类反馈的训练时，我们可以缩小模型生成的文本风格范围，尝试模仿训练集中最好的人或最好的风格。</strong></p> 
 <p>当然，“最好”会有很大的差异，最终得到的内容将取决于我们的指令。如果我们要求模型生成内容时不要太过于有争议，又要“企业化（corporate）”一点，那么生成的内容也就是这样。因此，我们至少可以将模型限定到一个特定的风格，而不是互联网上所有的风格。</p> 
 <p>但我认为，这里面可能还有更多的内容。<strong>模型不仅仅是在学习文本风格，模型内部可能还在试图确定一些语句是否正确。</strong>当然，我上面所说的是关于原始预训练模型。我认为“预测下一个token”的目标会为我们提供很多信息，这将迫使模型确定语句是否正确。</p> 
 <p>对于强化学习微调而言，我认为还会<strong>赋予模型更多的潜力去生成可信任的东西，而不是仅仅模仿某种风格</strong>，但现在还很难确定模型是否在这样做。现在还是prompt在引导着模型去获取互联网上那些我们想要的东西，模仿我们想模仿的内容。而我们想使InstructGPT更多地关注互联网上那些更可信任的东西。</p> 
 <h3></h3> 
 <h2></h2> 
 <p style="text-align:center"><strong><strong>3</strong></strong></p> 
 <p style="text-align:center"><strong>语言模型的泛化能力</strong></p> 
 <p><strong>Robin <strong>Chauhan</strong>：无论如何，我们应该模仿出互联网上最真实的一面。你能否谈一下泛化，以及这种模型在分布外（out of distribution）的表现如何？</strong></p> 
 <p><strong>John Schulman：</strong>总的来说，<strong>语言模型整体上具有惊人的泛化能力。</strong>我认为，像这些在互联网上受过多元化数据训练的预训练模型，它们通常泛化得相当好。至少对于那些在机器学习早期就接触过这些技术的人来说，这很令人惊讶。例如，即使是用其他语言，甚至是一种相对罕见的语言提供指令，模型通常也能够很好地遵循，即使整个训练过程中没有任何数据是用该语言编写的指令。这就是从预训练中延续下来的能力。</p> 
 <p>这实际是一个关于奖励模型的问题，举个例子：如果问题有点不同于它所接受的训练，比如在奖励模型的训练数据中稍微偏离一点，那么会发生什么呢？</p> 
 <p>我认为，<strong>RLHF的一个棘手问题是：对奖励模型进行训练时，也就是在训练policy以获得高奖励，意味着这会利用奖励模型中的错误。</strong>它最终会找到针对奖励模型的对抗示例，但这比正常的分布外行为（out of distribution behavior）更糟糕。因此，在将奖励模型尽可能地泛化到训练集之外确实存在一些挑战。</p> 
 <p>当这些类型的Agent遇到某些难题时会提醒它不知道吗？我认为，如果你问一个模型知识核心的问题，它会知道答案，而且它也知道自己知道答案（这里指的是Instruct类的模型）。但如果你问它关于其知识边缘的问题，那可能回答起来会有困难，必然会出现不准确的情况。有几篇论文还讨论过这个问题，比如Anthropic发表的Language Models, mostly know what they know，OpenAI发表的Teaching Models to Express Their Uncertainty in Words。这些语言模型以及机器学习中许多其他模型都是为了最大化可能性而进行训练的。</p> 
 <p>鉴于已经训练过Agent始终预测输出的分布（distribution of outputs），因此，对于语言模型，只要给定前缀，它就会预测下一个token的分布，而且通常预测的相当准确。如果它在预测某项任务有80%的概率，而且每次都是80%，那么它的正确率就为80%。</p> 
 <p>这只是训练目标的结果。训练目标鼓励对模型进行校准，这是因为模型校准可以提高不确定性估计的准确性。</p> 
 <p>因此，对于单个token级别，模型肯定经过校准。问题是，模型校准是否准确？校准后的模型是否能应用于多个token输出的情境中？又或是它们是否可以判断多个token语句的正确性？</p> 
 <p>因为模型通过单个token级别进行校准，所以我认为它们在不同环境中需要校准的信息确实不同。这就是我认为模型不难准确表达出校准信息的原因，或者至少让模型像人一样很好地表达不确定信息，这个问题也并非无法解决，但在实践中，需要解决一些实际的困难。</p> 
 <h2></h2> 
 <h2></h2> 
 <p style="text-align:center"><strong><strong>4</strong></strong></p> 
 <p style="text-align:center"><strong>AI对齐工作进入第二阶段</strong></p> 
 <p><strong>Robin Chauhan：人们对于“AI对齐（ AI alignment）”有不同的理解方式，你如何看待RLHF方面的对齐工作？</strong></p> 
 <p><strong>John Schulman：</strong>在我看来，<strong>AI对齐的主要目标是让模型通过训练知道人类的意图，并在执行任务时做出符合人类期望的行为。</strong>因此，我们需要分辨模型的能力。例如，当我们给一个原始语言模型提出一个问题时，它可能并不知道我们希望它给出一个完美的答案。相反，它可能会假设我们只是希望得到一个符合语法和语义规则的回答。</p> 
 <p><strong>Robin Chauhan：OpenAI的一篇博客讨论了对齐序列（sequence in alignment），一共包括三个阶段：第一阶段是使用人类反馈训练AI系统，第二阶段是训练AI系统协助人类反馈，第三阶段是训练AI系统进行对齐研究。所以你目前的工作主要是使用人类反馈训练AI系统，那何时以及如何才能进入其他阶段？</strong></p> 
 <p><strong>John Schulman：</strong>我现在正在做第二阶段的工作，即训练AI系统以协助人类反馈。当我们开始尝试让系统解决更具挑战性的问题时，第二阶段的工作就变得越来越重要。当模型的性能远低于人类水平或在某些任务上达到人类水平时，监督它们非常容易。但是，当模型处理的任务非常困难，需要大量不同的技术知识时，就很难提供有效的监督信号。</p> 
 <p>为了解决这个问题，我们可以采取一些措施，比如利用两个模型：<strong>针对某个问题，一个模型给出相应的答案，然后另一个模型对该答案提出批评意见，指出不足之处</strong>。这样，人们在看完批评意见后，就只需要判断答案是否正确，批评有助于人类更准确地评估答案。这一想法十分重要，我和同事们正在探索。此外，OpenAI也正在做一些工作来协助对齐研究，不过完成这项工作任重而道远。</p> 
 <p><strong>Robin Chauhan：Stuart Russell是OpenAI博士委员会的成员之一，我非常喜欢他的《人类兼容性（Human Compatible）》一书。他指出，标准强化学习框架通常是基于固定奖励信号的，而这种框架存在一定的问题。针对该问题，我们需要培养强大的Agent，使其尝试做我们想做的事情，同时对我们的意图保持一种怀疑态度，因为确定的Agent会存在一定问题。你如何看待这一观点？</strong></p> 
 <p><strong>John Schulman：</strong>我完全赞同Stuart Russell的观点。首先，编写一个简单的奖励函数来捕捉我们的意图是非常困难的。我们希望Agent能够理解我们的意图，并以最好的方式来实现这些意图，而不是盲目地追求某些极端的结果。</p> 
 <p>在构建Agent时，<strong>我们应该确保它们保持一种怀疑态度，以便更好地理解我们的意图和目标。</strong>这也可以帮助Agent更加谨慎地采取行动，以确保它们在实现目标的同时也考虑到其他重要的因素。</p> 
 <p>Stuart Russell提出了一个很好的问题定义，即让AI与人类共同玩一个游戏，该游戏的目标是让AI尝试理解人类的意图，并采取行动尝试满足这一意图，同时保持一定的怀疑态度。</p> 
 <p>我认为，如果我们开始思考如何将Russell所描述的目标应用到实践中，就会发现实际上这与OpenAI以及其他组织正在进行的RLHF研究非常相似。我们正在努力实现这一目标。</p> 
 <p style="text-align:center"><strong><strong>5</strong></strong></p> 
 <h2></h2> 
 <p style="text-align:center"><strong>WebGPT的想法从何而来</strong></p> 
 <p><strong>Robin Chauhan：2021年，你和Nakano等人共同发表论文《WebGPT：基于人类反馈的浏览器辅助问答》，能解释下WebGPT主要想解决的问题吗？</strong></p> 
 <p><strong>John Schulman：</strong>在WebGPT中，我们将语言模型与网络浏览器相连，以便从网络中检索信息。这些语言模型可以通过总结网络上的相关信息来写答案，这样一来，如果你对时事热点提问，或者询问一些需要详细科学或技术知识的问题，AI就可以在网络上查找答案，并详细引用其来源。</p> 
 <p>在文中，我们主要探讨了两个问题。<strong>首先，我们曾试图将语言模型变成一种Agent</strong>，人们在网络上编写了很多不同类型的文本数据，但关于如何实际执行多步骤过程的数据却很少，因此，我们不确定语言模型是否可以实际执行某些迭代过程，我们有很多数据，但这些数据基本上都和写论文、聊天等相关，这是我们在论文中探讨的第一个问题。</p> 
 <p>对于这个问题，我认为答案是肯定的。在这种情况下，我们可以让Agent使用我们提供的工具，比如说搜索、滚动、单击链接等浏览命令。</p> 
 <p><strong>其次，我们还探讨了信息的真实性问题，这是语言模型面临的一大难题。</strong>虽然语言模型掌握着海量知识，但如果我们向模型中输入错误的提示，它们可能会输出很多似是而非的废话。在语言模型领域，如何解决这一问题很值得研究，问题的解决与否也关系着语言模型的发展。</p> 
 <p>这个问题很有挑战性，<strong>最重要的是，我们要让模型检索、编写带有引用的答案，同时要确保引用来源的可信度。</strong>这样人们就不必再花时间去寻找模型答案的来源，他们可以直接点击引用链接，查看模型答案是否可信。</p> 
 <p>在WebGPT中，我们试图弄清楚如果我们确实给语言模型提供了灵活的Web界面，它能否在引用的帮助下如实回答问题，搞清楚这一点非常重要。人们搜索的问题五花八门，这些问题可能与科学、历史、时事等相关，人工评分员不一定具备这些问题的相关知识，但他们需要判断细节信息，如果没有引用，这就会成为一件难事。所以，在一定程度上，我们证明了在引用的帮助下可以在艰深领域内获得良好反馈。</p> 
 <h3></h3> 
 <p><strong>Robin Chauhan：WebGPT的想法从何而来？是深思熟虑之后的结果，还是在论文发表前突然冒出来的？结果怎么样？</strong></p> 
 <p><strong>John Schulman：</strong>这个想法其实由来已久。很久以前，我们在OpenAI有一个叫作World of Bits的项目（译者注：OpenAI Universe项目的前身）。<strong>在那时，我们想要控制Web浏览器来执行涉及互联网的任务</strong>，不过当时还为时过早，所以这个想法搁置了几年。</p> 
 <p>我们尝试过完整的视觉输入，那时的想法是给Agent输入类似“找出大楼地址”等指示，然后Agent会通过Web、谷歌地图等方法寻找答案，当时我们试图以像素的方式来完成这一切，但显然这种方式并不好，现在我们可以用大型语言模型来处理这些文本信息。</p> 
 <p>我们可以从网页中提取文本以获取大部分信息，但暂时还不能与动态网站进行真正地交互，因为这些网站中有大量JavaScript和图片等内容，除了这些内容之外，我们可以很顺畅地浏览和阅读文本。因为我们的模型足够好，所以重新考虑将互联网作为环境来使用。</p> 
 <p>另一个动机是，<strong>在开始使用GPT-3进行尝试之后，我们注意到它在事实准确性和提供的信息可靠性方面存在问题。</strong>因此，我们又开始研究如何使语言模型更具真实性。我们先进行了头脑风暴，最终决定尝试使用网络进行问答，查找网络上的知识来协助回答问题。</p> 
 <p>该项目的原始版本实际上使用了一些常见的问答数据集，例如Trivia QA（其中包含一些基本的常识问题）。<strong>我们在该数据集上进行了一些尝试，试图通过给模型提供网络搜索来提高模型的准确性。</strong>工作开展得很顺利，所以我们又转向了长篇问答，使该项目的工作更进一步。</p> 
 <p><strong>Robin Ranjit：看起来WebGPT想让语言模型能访问外部知识。问题是，你认为哪些东西是语言模型可以知道或者允许搜索到的？哪些东西又不能让语言模型访问？这之间有明确的界限吗？</strong></p> 
 <p><strong>John Schulman：</strong>有人提倡使用只包含语言的小型模型，我认为这种立场有点极端；还有人建议允许使语言模型知道一切东西，但不能授权其获得外部知识的途径。我认为，很难将知识、事实性知识与理解区分开来。人类记不住所有东西，但在需要用到某项知识时，我们可以去查询。</p> 
 <p>对于特定领域的工作者来说，进行事实内化是很有用的，这样可以在需要用时快速调用，并在脑海中将其进行组合。</p> 
 <p>所以这两种说法我都不赞同，我认为，检索至少对当前事务很有用，而且我们也没想过要使神经网络涵盖人类所有的知识。</p> 
 <p>另一方面，人类很幸运，已经扩大了模型。随着吸收的事实知识越来越多，模型在推理和其他事情上也会做得越来越好。截止目前，我还没有看到任何微型模型可以做大量检索并保存所有权重以进行推理。</p> 
 <p style="text-align:center"><strong><strong>6</strong></strong></p> 
 <h2></h2> 
 <p style="text-align:center"><strong>行为克隆、奖励模型、强化学习和拒绝采样</strong></p> 
 <p><strong>Robin Chauhan：在这个项目中，你好像使用了多个不同的数据集和不同的训练方法，包括行为克隆（behavior cloning）、奖励模型（reward modeling）、强化学习（reinforcement learning）和拒绝采样（rejection sampling）。</strong></p> 
 <p><strong>John Schulman：</strong>我们使用的是一种相当标准的方法，该方法实际上是从以前的RLHF工作中改编而来的。具体流程是，首先使用监督学习来训练一个模型，在这个过程中，人类演示者展示如何完成任务，例如如何从观察映射到动作。这个过程就是所谓的监督学习或者行为克隆。</p> 
 <p>接下来，我们就会训练一个奖励模型或偏好模型。它会比较两个动作或两条轨迹，然后决定哪一个更好。在问答的情境下，我们会比较两个答案并判断哪一个更好。我们使用这个模型来训练一个奖励模型，该模型会给回答打分，回答的好，分就高，反之则低。</p> 
 <p>然后我们根据这个奖励函数进行强化学习。当然，在进行少量的强化学习之后，你可以迭代执行最后两个步骤。如此一来，就可以利用奖励模型中的一些缺陷或噪声。如果新数据分布不准确，就需要重新收集更多的样本对，并重新拟合这个偏好模型。然后再进行一轮强化学习。这就是完整的RLHF的流水线。</p> 
 <p>另外还有一个叫做拒绝采样或者最优端采样（best of end sampling）的想法。一般来说，你也可以进行其他类型的搜索。当有了奖励模型后，你可以对一堆样本进行重新排序，并选择最好的做法。</p> 
 <p><strong>Robin Chauhan：这有点像MPC（Model Predictive Control，模型预测控制）?</strong></p> 
 <p><strong>John Schulman：</strong>是的。这取决于我们所处的环境以及所做的事情。如果处于交互式环境中，就必须模拟环境动态，这一点和MPC很像。在我们的案例中，唯一需要学习的模型是人类偏好。比如在问答环境中，我们可以轻易地对一堆操作（actions）进行采样，其中每个操作都是一个完整的答案，并且可以将它们重新排名或搜索答案。</p> 
 <p><strong>Robin Chauhan：就动作空间（action space）而言，它是否只是命令列表？还是说它仍然像常规生成模型一样生成tokens？</strong></p> 
 <p><strong>John Schulman：</strong>我们正在生成tokens。在我们的RL任务中，每一回合都有两个阶段。首先是浏览阶段，模型会搜索、点击并引用相关信息。比如模型在网页上看到了有用的信息，就会使用quote命令对信息进行引用。</p> 
 <p>浏览完成后，模型会发出结束浏览的命令，这都会用token来表示。但是，我们将这个过程整合到了大的RL任务中，一个大的回合（episode）包含了浏览网页和给出答案两个阶段。</p> 
 <p><strong>Robin Chauhan：这种方法的效果如何？</strong></p> 
 <p><strong>John Schulman：</strong>最开始我们不知道它是否会成功。在我们用Trivia QA做了最初的实验后，很快就开始运行了，很明显浏览部分起了作用，另外如果给模型一些可以引用的文本片段，它们就可以生成优质的长文本。</p> 
 <p style="text-align:center"><strong><strong>7</strong></strong></p> 
 <h2></h2> 
 <p style="text-align:center"><strong>为什么不能使用外部反馈</strong></p> 
 <p><strong>Robin Chauhan：人工评分员的任务非常复杂，有很长的评分指南和多种类型的反馈。但是论文最后表示只有最终评级才有用。我想知道为什么模型不能使用外部反馈，是因为外部反馈太多了还是因为样本不够？</strong></p> 
 <p><strong>John Schulman：</strong>是的，这一发现确实让人沮丧。在对比一组答案时，评分员的每次对比都要经历一个很长的过程，但是我们只会用到整个过程中的小部分信息，而这一小部分信息的对比时间可能长达半小时左右。</p> 
 <p>如果我们能提取出更多信息，了解更多他们得出答案的过程，那么可能会更好一点。所以我们收集了各种其他信息，比如不同维度给出的评分、连贯性和事实准确性等。</p> 
 <p>因此，我觉得应该还能做得更好。但不幸的是，这种看似有点愚蠢的方法其实很难超越。人们已经尝试了各种办法，比如以人类反馈来代替偏好分数。此外还有其他的事情可以做，比如可以让模型进行批判性写作或编辑回答。</p> 
 <p><strong>Robin Ranjit：是的，我认为其中一些事情也有可能实现，而且这种收集偏好数据的方法很有效。</strong></p> 
 <p><strong>John Schulman：</strong>是的，我认为这仍然是一个开放的研究领域。</p> 
 <p><strong>Robin Ranjit：再谈谈那些冗长的指令吧。</strong></p> 
 <p><strong>John Schulman：</strong>在完成任何任务时，都需要遵循许多微妙的规则和细节。因此，在编写指南时，我们不断添加了更多细节，比如你在这种情况下会做什么？在另一种情况下又会怎么做？然而，随着细节的不断增加，这些指令变得非常冗长。</p> 
 <p>不过，这个问题还是有办法解决。DeepMind发表了相关文章，使用Sparrow将任务分解成更小的部分并进行训练，人们一次只关注一个部分，以便更好地理解和掌握每个部分的细节和规则。此外，研究者还训练了多个规则，特定的奖励模型，以更好地捕捉任务的不同方面和细节，并在最后进行合并。</p> 
 <p style="text-align:center"><strong><strong>8</strong></strong></p> 
 <h2></h2> 
 <p style="text-align:center"><strong>强化学习与AGI的未来</strong></p> 
 <p><strong>Robin Chauhan：自从你发布TRPO和PPO算法以来，强化学习领域取得了哪些重要的进展？</strong></p> 
 <p><strong>John Schulman：</strong>在PPO算法之后，出现了基于价值的TD3和SAC算法，这些算法都表现出了相当高的可靠性。MuZero和Efficient Zero是有效的强化学习算法，Efficient Zero的样本效率表现令人印象深刻，它能够在使用更少样本的情况下达到很好的效果。这些算法可能在一些简单的任务（toy task）或基准测试中表现较好，也开始被应用到一些实际问题中，这是非常有意思的。</p> 
 <p>近来，离线强化学习（offline RL）备受关注。我认为，<strong>RLHF就是一种离线强化学习。</strong>因为在训练过程中，它使用的是预先收集的数据集和奖励模型数据集，而无需实时与环境进行交互。</p> 
 <p><strong>Robin Chauhan：RLHF和传统的离线强化学习算法确实有些相似，但是其方法和技术有所不同。传统的离线强化学习算法通常使用Off-policy算法，而基于RLHF算法通常使用On-policy算法和一种奖励模型。这些差异是否影响了正在执行的任务？</strong></p> 
 <p><strong>John Schulman：</strong><strong>我们正在做一项类似基于模型的强化学习（model-based RL）的任务</strong><strong>，而奖励模型就是对系统的未知部分的建模。</strong>我们需要考虑到人类因素的影响，而不是仅仅关注机器的输出结果。</p> 
 <p>这项任务也类似于使用环境的动力学模型（dynamics model of the environment），并运行一些策略评估算法（policy grading algorithm）来评估模型的效果。虽然对抗机器学习模型的在线算法已经是一种成熟的想法，但之前的研究所处的情境与现在已经大不同。现在我们可以利用训练好的预训练模型，只需进行一些小幅度的策略更新即可实现目标，而不必进行大规模的模型更改。因此，我们采用了这些在线算法，这也与我们一直在研究上下文赌博机（contextual bandit）的问题有关。</p> 
 <p>由于只有一个时间步，例如，收到一个查询并输出一个响应，然后该响应会获得奖励。因此，在多步骤（multi-step）过程中，不能立即获得奖励分配。对话就是一个例子，其中涉及到多个步骤，不能在每个步骤中对其进行奖励分配。相反，必须在对话结束后才能分配奖励。</p> 
 <p>另外，当模型与一些难以模拟的真实世界系统进行交互时，不能完全使用相同的方法来解决问题。为了提高方法的采样效率，可能需要采用一些略有不同的方法。例如，可以训练一个Q函数或类似的函数来解决问题。</p> 
 <p>我们即将开始探索上述问题。然而，到目前为止，在我所关注的领域中，尚未发现需要采用该方法的情况。<strong>但据我估计，这种方法在未来会变得十分重要。</strong></p> 
 <p><strong>Robin Chauhan：AGI、RL及大型语言模型之间的关系是什么？它们又是如何相互配合的？</strong></p> 
 <p><strong>John Schulman：</strong>强化学习（RL）是训练人工通用智能（AGI）关键方法之一，它可以用来优化Agent的行为，以达到某种目标。在强化学习中，任何目标通常被视为Agent行为函数的一部分。与语言模型预训练类似，强化学习也需要选择一个目标并利用大量的训练数据（如互联网文本）来优化Agent的行为。</p> 
 <p>此外，我们会选择最大似然目标函数（maximum likelihood objective）来作为Agent的训练目标，虽然还有其他的目标函数可供选择，但最大似然目标函数是明智之选。如果真的想通过优化Agent行为以达到特定目标，那么强化学习是最适合的框架。</p> 
 <p><strong>Robin Chauhan：AGI是一种抽象目标吗？还是说我们有望在某一天看到AGI模型问世？模型问世之时，人们会惊叹，“这是首个AGI模型”。那么，人们对该模型的评价又会如何？</strong></p> 
 <p><strong>John Schulman：</strong>我认为当AGI真正问世的时候，经过多次试用，人们会意识到它并非完全符合我们的预期。虽然我们可能会看到很多模型在某些领域或某类任务上超越人类，但它们仍然存在一些失效模式和弱点。例如，可能会出现多个自称AGI的模型，但只有在与其交互一段时间后，人们才会发现它们无法完全达到AGI的水平。</p> 
 <p><strong>Robin Chauhan：据你估计，AGI还有多久问世？</strong></p> 
 <p><strong>John Schulman：</strong>距AGI的问世不会太遥远，不过过程中肯定会出现许多误判。<strong>预计在未来的五年时间里，AI能够在大多数人类目前从事的工作上表现得比人类更好。</strong>当然，并非所有工作都会被AI取代，人类仍然会在某些领域享有控制权。因此，在未来的10到15年中，我们会见证AI逐步推进的整个过程。</p> 
 <p>相关参考链接</p> 
 <p style="text-align:left">1. https://www-technologyreview-com.cdn.ampproject.org/c/s/www.technologyreview.com/2023/03/03/1069311/inside-story-oral-history-how-chatgpt-built-openai/amp/</p> 
 <p style="text-align:left">2. WebGPT: https://arxiv.org/abs/2112.09332</p> 
 <p style="text-align:left">3. InstructGPT：https://arxiv.org/abs/2203.02155</p> 
 <p style="text-align:left">4. Our approach to alignment research, OpenAI 2022</p> 
 <p style="text-align:left">5. Training Verifiers to Solve Math Word Problems, Cobbe et al 2021</p> 
 <p style="text-align:left">6. UC Berkeley Deep RL Bootcamp Lecture 6: Nuts and Bolts of Deep RL Experimentation, John Schulman 2017</p> 
 <p style="text-align:left">7. Proximal Policy Optimization Algorithms, Schulman 2017</p> 
 <p style="text-align:left">8. Optimizing Expectations: From Deep Reinforcement Learning to Stochastic Computation Graphs, Schulman 2016</p> 
 <h3></h3> 
 <p style="text-align:left">其他人都在看</p> 
 <ul>
<li> <p><a href="">GPT-3/ChatGPT复现的经验教训</a></p> </li>
<li> <p><a href="">超越ChatGPT：大模型的智能极限</a></p> </li>
<li> <p><a href="">Jasper狂飙：AIGC现象级应用的增长秘笈</a></p> </li>
<li> <p><a href="">适配PyTorch FX，OneFlow让量化感知更简单</a></p> </li>
<li> <p><a href="">比快更快，开源Stable Diffusion刷新作图速度</a></p> </li>
<li> <p><a href="">OneEmbedding:单卡</a><a href="">训练TB级推荐模型不是梦</a></p> </li>
<li> <p><a href="">GLM训练加速：性能最高提升3倍，显存节省1/3</a></p> </li>
</ul>
 <p><strong>欢迎Star、试用OneFlow新版本：</strong><a class="has-card" href="https://github.com/Oneflow-Inc/oneflow/" title="GitHub - Oneflow-Inc/oneflow: OneFlow is a deep learning framework designed to be user-friendly, scalable and efficient."><span class="link-card-box"><span class="link-title">GitHub - Oneflow-Inc/oneflow: OneFlow is a deep learning framework designed to be user-friendly, scalable and efficient.</span><span class="link-desc">OneFlow is a deep learning framework designed to be user-friendly, scalable and efficient. - GitHub - Oneflow-Inc/oneflow: OneFlow is a deep learning framework designed to be user-friendly, scalable and efficient.</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/95/2b/RJqKUH44_o.png">https://github.com/Oneflow-Inc/oneflow/</span></span></a></p> 
</div> Disable checkingPremium suggestions
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>