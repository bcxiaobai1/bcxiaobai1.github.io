<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Shell全解析(一)：Shell脚本 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Shell全解析(一)：Shell脚本</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#_1">一、前言</a></li>
<li><a href="#Shell_4">二、Shell脚本</a></li>
<li>
<ul>
<li><a href="#21_ShellShell_5">2.1 从Shell到Shell脚本</a></li>
<li><a href="#22_Shell_15">2.2 编写Shell脚本</a></li>
<li><a href="#23_Shell_30">2.3 执行Shell脚本</a></li>
</ul>
  </li>
<li><a href="#Shell_47">三、Shell脚本内对参数的操作</a></li>
<li><a href="#Shell_74">四、Shell脚本中常见命令</a></li>
<li>
<ul>
<li><a href="#41_Shell_echo_76">4.1 Shell echo命令</a></li>
<li>
<ul>
<li><a href="#411_echo_80">4.1.1 echo中直接输出普通字符串</a></li>
<li><a href="#412_echo_91">4.1.2 echo中显示转义字符</a></li>
<li><a href="#413_echo_104">4.1.3 echo中读取输入</a></li>
<li><a href="#414_echo_128">4.1.4 echo换行操作</a></li>
<li>
<ul>
<li><a href="#4141_echo_130">4.1.4.1 默认每一个echo占一行的</a></li>
<li><a href="#4142__134">4.1.4.2 输出中增加一个换行</a></li>
<li><a href="#4143__158">4.1.4.3 输出中去掉原有换行</a></li>
</ul>
    </li>
<li><a href="#415_echo_176">4.1.5 将echo结果定向至文件</a></li>
<li><a href="#416_echo_195">4.1.6 echo中原样输出字符串，不进行转义或取变量(用单引号)</a></li>
<li><a href="#417_echo_204">4.1.7 echo中显示命令执行结果</a></li>
</ul>
   </li>
<li><a href="#42_Shell_printf_215">4.2 Shell printf命令</a></li>
<li>
<ul>
<li><a href="#421_printf_226">4.2.1 printf命令默认不会自动添加换行符</a></li>
<li><a href="#422_printf_236">4.2.2 printf命令格式化字符串输出</a></li>
<li><a href="#423_printf_265">4.2.3 printf的转义序列</a></li>
</ul>
   </li>
<li><a href="#43_Shell_test_290">4.3 Shell test命令</a></li>
<li>
<ul>
<li><a href="#431__294">4.3.1 数值测试</a></li>
<li><a href="#432__347">4.3.2 字符串测试</a></li>
<li><a href="#433__376">4.3.3 文件测试</a></li>
</ul>
  </li>
</ul>
  </li>
<li><a href="#Shell_428">五、Shell脚本中的三种括号</a></li>
<li>
<ul>
<li><a href="#51__433">5.1 小括号(圆括号)</a></li>
<li>
<ul>
<li><a href="#511__435">5.1.1 单小括号</a></li>
<li><a href="#512__443">5.1.2 双小括号</a></li>
</ul>
   </li>
<li><a href="#52__453">5.2 中括号(方括号)</a></li>
<li>
<ul>
<li><a href="#521__455">5.2.1 单中括号</a></li>
<li><a href="#522__464">5.2.2 双中括号</a></li>
</ul>
   </li>
<li><a href="#53__488">5.3 大括号(花括号)</a></li>
<li>
<ul>
<li><a href="#531__491">5.3.1 常规用法</a></li>
<li><a href="#532__506">5.3.2 几种特殊的替换结构</a></li>
<li><a href="#533__521">5.3.3 四种模式匹配替换结构</a></li>
<li><a href="#534__564">5.3.4 字符串提取和替换</a></li>
</ul>
   </li>
<li><a href="#54__597">5.4 符号$后的括号</a></li>
<li><a href="#55__605">5.5 多条命令执行</a></li>
</ul>
  </li>
<li><a href="#_613">六、尾声</a></li>
</ul>
</div>
<p></p> 
<h1>
<a id="_1"></a>一、前言</h1> 
<p>全文介绍了Shell脚本定义、Shell脚本中对参数的操作、Shell脚本中常见命令、Shell脚本中的三种括号。</p> 
<h1>
<a id="Shell_4"></a>二、Shell脚本</h1> 
<h2>
<a id="21_ShellShell_5"></a>2.1 从Shell到Shell脚本</h2> 
<p>问题1：什么是Shell？<br> 回答1：Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p> 
<p>问题2：什么是Shell脚本？<br> 回答2：Shell 脚本就是 Shell script，是一种为 shell 编写的脚本程序。</p> 
<p>小结：业界所说的 shell 通常都是指 shell 脚本，但是其实 shell 和 shell script 是两个不同的概念。</p> 
<h2>
<a id="22_Shell_15"></a>2.2 编写Shell脚本</h2> 
<p>打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell）。</p> 
<p>输入一些代码，第一行一般是这样：</p> 
<pre><code class="prism language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Hello World !"</span>
</code></pre> 
<p>第一行：#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。<br> 第二行：echo 命令用于向窗口输出文本。</p> 
<h2>
<a id="23_Shell_30"></a>2.3 执行Shell脚本</h2> 
<p>假如想要执行一个Shell脚本，分为两步，先使用chmod加上执行权限，然后在当前目录下执行</p> 
<pre><code class="prism language-bash"><span class="token function">chmod</span> +x ./test.sh  <span class="token comment">#使脚本具有执行权限</span>
./test.sh  <span class="token comment">#执行脚本</span>
</code></pre> 
<p>注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p> 
<p>小结：<br> <code>./xxx.sh</code> <code>./</code>表示当前目录，<code>xxx.sh</code>表示执行xxx.sh脚本，合在一起的意思就是在当前目录下执行xxx.sh脚本；<br> <code>xxx.sh</code> 表示在linux的 PATH 里面去找到xxx.sh并执行，如果这样，必须将 xxx.sh 所在目录配置到 PATH 中去，否则会找不到。</p> 
<h1>
<a id="Shell_47"></a>三、Shell脚本内对参数的操作</h1> 
<p>shell需要取某个变量的值使用美元符号 <code>$</code> ，当给 <code>.sh</code> 脚本传递参数的时候，因为参数也是变量，所以要打印接收到的实参也是用使用美元符号 <code>$</code>，关于这个美元符号 <code>$</code> ，有这些用法</p> 
<table>
<thead><tr>
<th>符号</th>
<th>含义</th>
</tr></thead>
<tbody>
<tr>
<td>$n</td>
<td>传递到脚本的具体某个参数值，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数</td>
</tr>
<tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数。如"$*“用「”」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。如"$@“用「”」括起来的情况、以"$1" “<span class="katex--inline"><span class="katex"><span class="katex-mathml">
       
        
         
          
           2
          
          
           "
          
          
           …
          
          
           "
          
         
         
          2" … "
         
        
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em;vertical-align: 0em"></span><span class="mord">2</span><span class="mord">"</span><span class="mspace" style="margin-right: 0.166667em"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em"></span><span class="mord">"</span></span></span></span></span>n” 的形式输出所有参数。</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
<p>辨析类似命令</p> 
<p>问题：<code>$n</code> 与 <code>$#</code> 有什么不同？<br> 回答：<br> (1) <code>$n</code> 表示的是传递到脚本的具体某个参数值，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数<br> (2) <code>$#</code> 表示的是传递到脚本的参数个数</p> 
<p>问题：<code>$*</code> 与 <code>$@</code> 有什么不同？<br> 回答：<br> 相同点：都是引用所有参数。<br> 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）</p> 
<h1>
<a id="Shell_74"></a>四、Shell脚本中常见命令</h1> 
<h2>
<a id="41_Shell_echo_76"></a>4.1 Shell echo命令</h2> 
<p>Shell echo命令用于字符串的输出。命令格式：<code>echo string</code>，您可以使用echo实现更复杂的输出格式控制。</p> 
<h3>
<a id="411_echo_80"></a>4.1.1 echo中直接输出普通字符串</h3> 
<p>需求：直接输出普通字符串<br> 输入(带双引号)：<code>echo "It is a test"</code><br> 输入(不带引号)：<code>echo It is a test</code><br> 输入(带单引号)：<code>echo 'It is a test'</code><br> 输出：<code>It is a test</code><br> 三种方式都可以，都可以表示字符串。<br> <img src="https://images2.imgbox.com/92/f2/jPDB8daq_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="412_echo_91"></a>4.1.2 echo中显示转义字符</h3> 
<p>需求：显示转义字符</p> 
<p>输入(带双引号)：<code>echo ""It is a test""</code><br> 输入(不带引号)：<code>echo "It is a test"</code><br> 输出：<code>"It is a test"</code></p> 
<p>两种方式都可以，但是单引号不可以，如下：</p> 
<p>输入(带单引号)：<code>echo '"It is a test"'</code><br> 输出：<code>"It is a test"</code> （因为单引号里面所有的内容都会变成字符串，所以转义字符不会生效）<br> <img src="https://images2.imgbox.com/4d/9a/NezmONJx_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="413_echo_104"></a>4.1.3 echo中读取输入</h3> 
<p>需求：read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量，让echo输出</p> 
<p>输入：编写test.sh脚本，name 接收标准输入的变量</p> 
<pre><code class="prism language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token builtin class-name">read</span> name 
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$name</span> It is a test"</span>
</code></pre> 
<p>输出：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># sh test.sh</span>
OK                     <span class="token comment">#标准输入</span>
OK It is a <span class="token builtin class-name">test</span>        <span class="token comment">#输出</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/44/ae/CTpIUoTx_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="414_echo_128"></a>4.1.4 echo换行操作</h3> 
<h4>
<a id="4141_echo_130"></a>4.1.4.1 默认每一个echo占一行的</h4> 
<p>默认每一个echo占一行的，即自动在末尾添加换行符，如下：<br> <img src="https://images2.imgbox.com/4d/8e/hPCqWXA3_o.png" alt="在这里插入图片描述"></p> 
<h4>
<a id="4142__134"></a>4.1.4.2 输出中增加一个换行</h4> 
<p>需求：输出中显示换行<br> 输入：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> -e <span class="token string">"OK! <span class="token entity" title="n">n</span>"</span> <span class="token comment"># -e 开启转义 同时使用 n 表示换行</span>
<span class="token builtin class-name">echo</span> <span class="token string">"It is a test"</span>
</code></pre> 
<p>输出：</p> 
<pre><code class="prism language-bash">OK<span class="token operator">!</span>

It is a <span class="token builtin class-name">test</span>
</code></pre> 
<p>需要同时 <code>-e</code> 开启换行和 <code>n</code> 换行符才能实现换行，如下：<br> <img src="https://images2.imgbox.com/70/ee/ivWLSSCb_o.png" alt="在这里插入图片描述"><br> <code>n</code> 放在双引号里面，配置 <code>-e</code> 换行符才生效，如下：<br> <img src="https://images2.imgbox.com/f8/82/SDw2c9BN_o.png" alt="在这里插入图片描述"><br> 不用引号无法处理反斜杠，单引号包裹 n 反斜杠配合 -e 开启换行符也可以让换行生效，但是最好使用双引号，如下：<br> <img src="https://images2.imgbox.com/fc/5b/U0QdScri_o.png" alt="在这里插入图片描述"></p> 
<h4>
<a id="4143__158"></a>4.1.4.3 输出中去掉原有换行</h4> 
<p>需求：输出中去掉原有换行<br> 输入：</p> 
<pre><code class="prism language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token builtin class-name">echo</span> -e <span class="token string">"OK! <span class="token entity" title="c">c</span>"</span> <span class="token comment"># -e 开启转义 但是使用 c 表示去掉换行</span>
<span class="token builtin class-name">echo</span> <span class="token string">"It is a test"</span>
</code></pre> 
<p>输出：</p> 
<pre><code class="prism language-bash">OK<span class="token operator">!</span> It is a <span class="token builtin class-name">test</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3a/d7/mahsGGjR_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="415_echo_176"></a>4.1.5 将echo结果定向至文件</h3> 
<p>需求：将echo结果定向至文件<br> 输入：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"It is a test"</span> <span class="token operator">&gt;</span> myfile
<span class="token function">cat</span> myfile
</code></pre> 
<p>输出：</p> 
<pre><code class="prism language-bash">It is a <span class="token builtin class-name">test</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/cd/ee/1Mm9O7hL_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="416_echo_195"></a>4.1.6 echo中原样输出字符串，不进行转义或取变量(用单引号)</h3> 
<p>需求：原样输出字符串，不进行转义或取变量<br> 思考：不使用引号和使用双引号都会取到 <code>$name</code> 里面的内容，要想不取到 <code>$name</code> 里面的内容，必须使用单引号<br> 输入：<code>echo '$name"'</code><br> 输出：<code>$name"</code></p> 
<p><img src="https://images2.imgbox.com/92/9c/htHG9Rl6_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="417_echo_204"></a>4.1.7 echo中显示命令执行结果</h3> 
<p>需求：显示命令执行结果<br> 输入：echo <code>date</code><br> 输出：<code>Thu Jul 24 10:08:46 CST 2014</code></p> 
<p><img src="https://images2.imgbox.com/62/29/v06tQPXK_o.png" alt="在这里插入图片描述"></p> 
<p>注意： 如果是带执行的命令的话，必须使用反引号 `, 其他的无论是不用引号、单引号、双引号都会被date解释为一个字符串，而不是date命令</p> 
<h2>
<a id="42_Shell_printf_215"></a>4.2 Shell printf命令</h2> 
<p>printf 命令模仿 C 程序库（library）里的 printf() 程序，学习这个命令的时候，可以认为它的语法和C语言中的printf()函数相同。printf命令和echo命令都是输出，但是关于printf命令，需要注意两点：</p> 
<p>(1) 默认不会自动添加换行符：默认的 printf 不会像 echo 自动添加换行符，我们可以手动添加 n。<br> (2) 格式化字符串输出：printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。</p> 
<p>printf 命令的语法：<code>printf format-string [arguments...]</code><br> 参数说明：<br> format-string: 为格式控制字符串<br> arguments: 为参数列表。</p> 
<h3>
<a id="421_printf_226"></a>4.2.1 printf命令默认不会自动添加换行符</h3> 
<pre><code class="prism language-bash"><span class="token builtin class-name">printf</span> <span class="token string">"hello,shell printf<span class="token entity" title="n">n</span>"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"hello,shell echo"</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/bb/5b/1P4QPkJF_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="422_printf_236"></a>4.2.2 printf命令格式化字符串输出</h3> 
<p>我来用一个脚本来体现 printf 的强大功能，格式化输出，和C语言的printf函数语法一样，如下：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">printf</span> <span class="token string">"%-10s %-8s %-4s<span class="token entity" title="n">n</span>"</span> 姓名 性别 体重kg  
<span class="token builtin class-name">printf</span> <span class="token string">"%-10s %-8s %-4.2f<span class="token entity" title="n">n</span>"</span> 郭靖 男 <span class="token number">66.1234</span>
<span class="token builtin class-name">printf</span> <span class="token string">"%-10s %-8s %-4.2f<span class="token entity" title="n">n</span>"</span> 杨过 男 <span class="token number">48.6543</span>
<span class="token builtin class-name">printf</span> <span class="token string">"%-10s %-8s %-4.2f<span class="token entity" title="n">n</span>"</span> 郭芙 女 <span class="token number">47.9876</span>
</code></pre> 
<p>执行脚本，输出结果如下所示：</p> 
<p>姓名 性别 体重kg<br> 郭靖 男 66.12<br> 杨过 男 48.65<br> 郭芙 女 47.99</p> 
<p>解释：</p> 
<p>(1) 数据类型：%s %c %d %f 都是格式替代符，％s 输出一个字符串，％d 整型输出，％c 输出一个字符，％f 输出实数，以小数形式输出。</p> 
<p>(2) 左对齐与右对齐：%-10s 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p> 
<p>(3) 浮点型小数位数：%-4.2f 指格式化为小数，其中 .2 指保留2位小数。</p> 
<p><img src="https://images2.imgbox.com/cc/d8/GBYQ1bxw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9f/08/nr05fsj8_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="423_printf_265"></a>4.2.3 printf的转义序列</h3> 
<p>printf 的转义序列，如下：</p> 
<table>
<thead><tr>
<th>序列</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>a</td>
<td>警告字符，通常为ASCII的BEL字符</td>
</tr>
<tr>
<td>b</td>
<td>后退</td>
</tr>
<tr>
<td>c</td>
<td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
</tr>
<tr>
<td>f</td>
<td>换页（formfeed）</td>
</tr>
<tr>
<td>n</td>
<td>换行</td>
</tr>
<tr>
<td>r</td>
<td>回车（Carriage return）</td>
</tr>
<tr>
<td>t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td></td>
<td>一个字面上的反斜杠字符</td>
</tr>
<tr>
<td>ddd</td>
<td>表示1到3位数八进制值的字符。仅在格式字符串中有效</td>
</tr>
<tr>
<td>ddd</td>
<td>表示1到3位的八进制值字符</td>
</tr>
</tbody>
</table>
<p>只看第一个，<code>a</code> 警告字符，通常为ASCII的BEL字符，这个命令是不会换行的</p> 
<pre><code class="prism language-bash">$ <span class="token builtin class-name">printf</span> <span class="token string">"www.runoob.com <span class="token entity" title="a">a</span>"</span>
www.runoob.com $                  <span class="token comment">#不换行</span>
</code></pre> 
<h2>
<a id="43_Shell_test_290"></a>4.3 Shell test命令</h2> 
<p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p> 
<h3>
<a id="431__294"></a>4.3.1 数值测试</h3> 
<p>数值测试就是判断两个数值是否等于、大于、小于，包括如下六个命令：</p> 
<table>
<thead><tr>
<th>参数</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>-eq</td>
<td>等于则为真（equals）</td>
</tr>
<tr>
<td>-ne</td>
<td>不等于则为真（not equals）</td>
</tr>
<tr>
<td>-gt</td>
<td>大于则为真（greter）</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于则为真（greter equals）</td>
</tr>
<tr>
<td>-lt</td>
<td>小于则为真（lower）</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于则为真（lower equals）</td>
</tr>
</tbody>
</table>
<blockquote> 
 <p>注意：shell中，数值是否相同需要使用 -eq -ne 来判断，而不是通过 = != 来判断，而且这个判断放在 if 条件中，前面要么加上test关键字，要么这个条件使用中括号。</p> 
</blockquote> 
<p>实例：</p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">num1</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token assign-left variable">num2</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token keyword">if</span> <span class="token builtin class-name">test</span> $<span class="token punctuation">[</span>num1<span class="token punctuation">]</span> -eq $<span class="token punctuation">[</span>num2<span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'两个数相等！'</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'两个数不相等！'</span>
<span class="token keyword">fi</span>
</code></pre> 
<p>输出结果：</p> 
<pre><code class="prism language-bash">两个数相等！
</code></pre> 
<p>代码中的 [] 执行基本的算数运算，如：</p> 
<p>实例</p> 
<pre><code class="prism language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">5</span>
<span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">6</span>

<span class="token assign-left variable">result</span><span class="token operator">=</span>$<span class="token punctuation">[</span>a+b<span class="token punctuation">]</span> <span class="token comment"># 注意赋值号两边不能有空格</span>
<span class="token builtin class-name">echo</span> <span class="token string">"result 为： <span class="token variable">$result</span>"</span>
</code></pre> 
<p>结果为:</p> 
<pre><code class="prism language-bash">result 为： <span class="token number">11</span>
</code></pre> 
<h3>
<a id="432__347"></a>4.3.2 字符串测试</h3> 
<p>字符串测试的需求包括 判断两个字符串是否内容相等、判断某个字符串是否长度为零，如下四个命令：</p> 
<table>
<thead><tr>
<th>参数</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>=</td>
<td>等于则为真</td>
</tr>
<tr>
<td>!=</td>
<td>不相等则为真</td>
</tr>
<tr>
<td>-z 字符串</td>
<td>字符串的长度为零则为真（zero）</td>
</tr>
<tr>
<td>-n 字符串</td>
<td>字符串的长度不为零则为真（not zero）</td>
</tr>
</tbody>
</table>
<p>实例</p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">num1</span><span class="token operator">=</span><span class="token string">"ru1noob"</span>
<span class="token assign-left variable">num2</span><span class="token operator">=</span><span class="token string">"runoob"</span>
<span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token variable">$num1</span> <span class="token operator">=</span> <span class="token variable">$num2</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'两个字符串相等!'</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'两个字符串不相等!'</span>
<span class="token keyword">fi</span>
</code></pre> 
<p>输出结果：</p> 
<pre><code class="prism language-bash">两个字符串不相等<span class="token operator">!</span>
</code></pre> 
<h3>
<a id="433__376"></a>4.3.3 文件测试</h3> 
<table>
<thead><tr>
<th>参数</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>-e 文件名</td>
<td>如果文件存在则为真（exist）</td>
</tr>
<tr>
<td>-r 文件名</td>
<td>如果文件存在且可读则为真（exist + read）</td>
</tr>
<tr>
<td>-w 文件名</td>
<td>如果文件存在且可写则为真（exist + write）</td>
</tr>
<tr>
<td>-x 文件名</td>
<td>如果文件存在且可执行则为真（exist + execute）</td>
</tr>
<tr>
<td>-s 文件名</td>
<td>如果文件存在且至少有一个字符则为真（exist + string(no empty)）</td>
</tr>
<tr>
<td>-d 文件名</td>
<td>如果文件存在且为目录则为真（exist + directory）</td>
</tr>
<tr>
<td>-f 文件名</td>
<td>如果文件存在且为普通文件则为真（exist + file）</td>
</tr>
<tr>
<td>-c 文件名</td>
<td>如果文件存在且为字符型特殊文件则为真（exist + char）</td>
</tr>
<tr>
<td>-b 文件名</td>
<td>如果文件存在且为块特殊文件则为真（exist + block）</td>
</tr>
</tbody>
</table>
<p>实例</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /bin
<span class="token keyword">if</span> <span class="token builtin class-name">test</span> -e ./bash
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'文件已存在!'</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'文件不存在!'</span>
<span class="token keyword">fi</span>
</code></pre> 
<p>输出结果：</p> 
<pre><code class="prism language-bash">文件已存在<span class="token operator">!</span>
</code></pre> 
<p>另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低。例如：</p> 
<p>实例</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /bin
<span class="token keyword">if</span> <span class="token builtin class-name">test</span> -e ./notFile -o -e ./bash
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'至少有一个文件存在!'</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'两个文件都不存在'</span>
<span class="token keyword">fi</span>
</code></pre> 
<p>输出结果：</p> 
<pre><code class="prism language-bash">至少有一个文件存在<span class="token operator">!</span>
</code></pre> 
<h1>
<a id="Shell_428"></a>五、Shell脚本中的三种括号</h1> 
<p>Shell脚本中的三种括号，语法非常多，学习的时候建议不是死记，作为开发只有能看懂别人写的Shell脚本，自己会写简单的Shell脚本满足业务需求就可以了，其实三种括号都不是必须的，都是可选的，用得最多的反而是中括号/方括号，在查看和编写Shell脚本的时候，只要知道方括号等效于test命令，一般使用在 if 条件判断和 while 循环出口判断里面，并且可以熟练使用方括号就可以了，数值判断和文件判断一般使用单方括号，字符串判断一般使用双方括号。至于小括号/圆括号和大括号/花括号，不熟悉的话可以不使用，毕竟用自己最熟悉的写出的代码才是最稳的。</p> 
<p>博客作为基本API介绍，所以对各种括号的使用总结的比较全面。</p> 
<h2>
<a id="51__433"></a>5.1 小括号(圆括号)</h2> 
<h3>
<a id="511__435"></a>5.1.1 单小括号</h3> 
<p>①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。</p> 
<p>②命令替换。等同于<code>cmd</code>，shell扫描一遍命令行，发现了<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        c
       
       
        m
       
       
        d
       
       
        )
       
       
        结
       
       
        构
       
       
        ，
       
       
        便
       
       
        将
       
      
      
       (cmd)结构，便将
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em;vertical-align: -0.25em"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">构</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">便</span><span class="mord cjk_fallback">将</span></span></span></span></span>(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</p> 
<p>③用于初始化数组。如：array=(a b c d)</p> 
<h3>
<a id="512__443"></a>5.1.2 双小括号</h3> 
<p>①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。</p> 
<p>②只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)</p> 
<p>③单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6</p> 
<p>④常用于算术运算比较，双括号中的变量可以不使用<code>$</code>符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用<code>for((i=0;i&lt;5;i++))</code>, 如果不使用双括号, 则为for i in <code>seq 0 4</code>或者for i in {0…4}。再如可以直接使用if (($i&lt;5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。</p> 
<h2>
<a id="52__453"></a>5.2 中括号(方括号)</h2> 
<h3>
<a id="521__455"></a>5.2.1 单中括号</h3> 
<p>①bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</p> 
<p>②Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</p> 
<p>③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</p> 
<p>④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</p> 
<h3>
<a id="522__464"></a>5.2.2 双中括号</h3> 
<p>①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</p> 
<p>②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</p> 
<p>③使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 &amp;&amp; $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] &amp;&amp; [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。</p> 
<p>④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</p> 
<p>例子：</p> 
<pre><code class="prism language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">)</span> 
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -lt <span class="token number">5</span> <span class="token punctuation">]</span> 
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> -ne <span class="token number">1</span> -a <span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token number">2</span> <span class="token punctuation">]</span> 
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> -ne <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token number">2</span> <span class="token punctuation">]</span> 
<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token number">2</span> <span class="token punctuation">]</span><span class="token punctuation">]</span> 
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">0</span> <span class="token number">4</span><span class="token variable">)</span></span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token variable">$i</span><span class="token punctuation">;</span><span class="token keyword">done</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">seq</span> <span class="token number">0</span> <span class="token number">4</span><span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token variable">$i</span><span class="token punctuation">;</span><span class="token keyword">done</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token variable">$i</span><span class="token punctuation">;</span><span class="token keyword">done</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token variable">$i</span><span class="token punctuation">;</span><span class="token keyword">done</span>
</code></pre> 
<h2>
<a id="53__488"></a>5.3 大括号(花括号)</h2> 
<h3>
<a id="531__491"></a>5.3.1 常规用法</h3> 
<p>①大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（…）分割的顺序文件列表起拓展作用，如：touch {a…d}.txt 结果为a.txt b.txt c.txt d.txt</p> 
<pre><code class="prism language-bash"><span class="token comment"># ls {ex1,ex2}.sh </span>
ex1.sh ex2.sh 
<span class="token comment"># ls {ex{1..3},ex4}.sh </span>
ex1.sh ex2.sh ex3.sh ex4.sh 
<span class="token comment"># ls {ex[1-3],ex4}.sh </span>
ex1.sh ex2.sh ex3.sh ex4.sh
</code></pre> 
<p>②代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</p> 
<h3>
<a id="532__506"></a>5.3.2 几种特殊的替换结构</h3> 
<pre><code class="prism language-bash"><span class="token variable">${var<span class="token operator">:-</span>string}</span>,<span class="token variable">${var<span class="token operator">:+</span>string}</span>,<span class="token variable">${var<span class="token operator">:=</span>string}</span>,<span class="token variable">${var<span class="token operator">:?</span>string}</span>
</code></pre> 
<p>①<code>${var:-string}</code>和<code>${var:=string}:</code>若变量var为空，则用在命令行中用string来替换<code>${var:-string}</code>，否则变量var不为空时，则用变量var的值来替换<code>${var:-string}</code>；对于<code>${var:=string}</code>的替换规则和<code>${var:-string}</code>是一样的，所不同之处是<code>${var:=string}</code>若var为空时，用string替换<code>${var:=string}</code>的同时，把string赋给变量var： <code>${var:=string}</code>很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</p> 
<p>② <code>${var:+string}</code>的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)</p> 
<p>③<code>${var:?string}</code>替换规则为：若变量var不为空，则用变量var的值来替换<code>${var:?string}</code>；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。</p> 
<blockquote> 
 <p>注意：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p> 
</blockquote> 
<h3>
<a id="533__521"></a>5.3.3 四种模式匹配替换结构</h3> 
<p>模式匹配记忆方法：<br> <code>#</code> 是去掉左边(在键盘上<code>#</code>在<code>$</code>之左边)<br> <code>%</code> 是去掉右边(在键盘上<code>%</code>在<code>$</code>之右边)<br> <code>#</code>和<code>%</code>中的单一符号是最小匹配，两个相同符号是最大匹配。</p> 
<pre><code class="prism language-bash"><span class="token variable">${var<span class="token operator">%</span>pattern}</span>,<span class="token variable">${var<span class="token operator">%%</span>pattern}</span>,<span class="token variable">${var<span class="token operator">#</span>pattern}</span>,<span class="token variable">${var<span class="token operator">##</span>pattern}</span>
</code></pre> 
<p>第一种模式：<code>${variable%pattern}</code>，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式</p> 
<p>第二种模式： <code>${variable%%pattern}</code>，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</p> 
<p>第三种模式：<code>${variable#pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式</p> 
<p>第四种模式： <code>${variable##pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</p> 
<p>这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!..]表示不匹配中括号里面的字符。</p> 
<pre><code class="prism language-bash"><span class="token comment"># var=testcase </span>
<span class="token comment"># echo $var </span>
testcase 
<span class="token comment"># echo ${var%s*e} </span>
testca 
<span class="token comment"># echo $var </span>
testcase 
<span class="token comment"># echo ${var%%s*e} </span>
te 
<span class="token comment"># echo ${var#?e} </span>
stcase 
<span class="token comment"># echo ${var##?e} </span>
stcase 
<span class="token comment"># echo ${var##*e}</span>
<span class="token comment"># echo ${var##*s} </span>
e 
<span class="token comment"># echo ${var##test} </span>
<span class="token keyword">case</span>
</code></pre> 
<h3>
<a id="534__564"></a>5.3.4 字符串提取和替换</h3> 
<pre><code class="prism language-bash"><span class="token variable">${var<span class="token operator">:</span>num}</span>,<span class="token variable">${var<span class="token operator">:</span>num1<span class="token operator">:</span>num2}</span>,<span class="token variable">${var<span class="token operator">/</span>pattern<span class="token operator">/</span>pattern}</span>,<span class="token variable">${var<span class="token operator">/</span><span class="token operator">/</span>pattern<span class="token operator">/</span>pattern}</span>
</code></pre> 
<p>第一种模式：<code>${var:num}</code>，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如<code>${var: -2}</code>、<code>${var:1-3}</code>或<code>${var:(-2)}</code>。</p> 
<p>第二种模式：<code>${var:num1:num2}</code>，num1是位置，num2是长度。表示从<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        v
       
       
        a
       
       
        r
       
       
        字
       
       
        符
       
       
        串
       
       
        的
       
       
        第
       
      
      
       var字符串的第
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em;vertical-align: 0em"></span><span class="mord mathdefault" style="margin-right: 0.03588em">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.02778em">r</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">第</span></span></span></span></span>num1个位置开始提取长度为$num2的子串。不能为负数。</p> 
<p>第三种模式：<code>${var/pattern/pattern}</code>表示将var字符串的第一个匹配的pattern替换为另一个pattern。</p> 
<p>第四种模式：<code>${var//pattern/pattern}</code>表示将var字符串中的所有能匹配的pattern替换为另一个pattern。</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@centos ~<span class="token punctuation">]</span><span class="token comment"># var=/home/centos </span>
<span class="token punctuation">[</span>root@centos ~<span class="token punctuation">]</span><span class="token comment"># echo $var </span>
/home/centos 
<span class="token punctuation">[</span>root@centos ~<span class="token punctuation">]</span><span class="token comment"># echo ${var:5} </span>
/centos 
<span class="token punctuation">[</span>root@centos ~<span class="token punctuation">]</span><span class="token comment"># echo ${var: -6} </span>
centos 
<span class="token punctuation">[</span>root@centos ~<span class="token punctuation">]</span><span class="token comment"># echo ${var:(-6)} </span>
centos 
<span class="token punctuation">[</span>root@centos ~<span class="token punctuation">]</span><span class="token comment"># echo ${var:1:4} </span>
home 
<span class="token punctuation">[</span>root@centos ~<span class="token punctuation">]</span><span class="token comment"># echo ${var/o/h} </span>
/hhme/centos 
<span class="token punctuation">[</span>root@centos ~<span class="token punctuation">]</span><span class="token comment"># echo ${var//o/h} </span>
/hhme/cenths
</code></pre> 
<h2>
<a id="54__597"></a>5.4 符号$后的括号</h2> 
<p>（1）<code>${a}</code> 变量a的值, 在不引起歧义的情况下可以省略大括号。</p> 
<p>（2）<code>$(cmd)</code> 命令替换，和<code>cmd</code>效果相同，结果为shell命令cmd的输，过某些Shell版本不支持<code>$()</code>形式的命令替换, 如tcsh。</p> 
<p>（3）<code>$((expression))</code> 和<code>exprexpression</code>效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。</p> 
<h2>
<a id="55__605"></a>5.5 多条命令执行</h2> 
<p>（1）单小括号，(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。</p> 
<p>（2）单大括号，{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。</p> 
<p>对{}和()而言, 括号中的重定向符只影响该条命令， 而括号外的重定向符影响到括号中的所有命令。</p> 
<h1>
<a id="_613"></a>六、尾声</h1> 
<p>全文介绍了Shell脚本定义、Shell脚本中对参数的操作、Shell脚本中常见命令、Shell脚本中的三种括号。</p> 
<p>天天打码，天天进步！！</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>