<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【前端领域高频笔试面试】—— Vue相关 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【前端领域高频笔试面试】—— Vue相关</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.v-if%20%E5%92%8C%20v-show%20%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px"><a href="#1.v-if%20%E5%92%8C%20v-show%20%E5%8C%BA%E5%88%AB" title="1.v-if 和 v-show 区别">1.v-if 和 v-show 区别</a></p> 
<p id="2.vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F-toc" style="margin-left:80px"><a href="#2.vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F" title="2.vue常用的修饰符">2.vue常用的修饰符</a></p> 
<p id="3.vue%E4%B8%AD%20key%20%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F-toc" style="margin-left:80px"><a href="#3.vue%E4%B8%AD%20key%20%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F" title="3.vue中 key 值的作用">3.vue中 key 值的作用</a></p> 
<p id="4.vue%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%88SPA%EF%BC%89%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px"><a href="#4.vue%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%88SPA%EF%BC%89%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" title="4.vue的单页面应用（SPA）的优缺点">4.vue的单页面应用（SPA）的优缺点</a></p> 
<p id="5.Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:80px"><a href="#5.Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" title="5.Vue的生命周期">5.Vue的生命周期</a></p> 
<p id="6.Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-toc" style="margin-left:80px"><a href="#6.Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" title="6.Vue组件间的参数传递">6.Vue组件间的参数传递</a></p> 
<p id="7.%E4%B8%BA%E4%BB%80%E4%B9%88vue%E4%B8%ADdata%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F-toc" style="margin-left:80px"><a href="#7.%E4%B8%BA%E4%BB%80%E4%B9%88vue%E4%B8%ADdata%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F" title="7.为什么vue中data必须是一个函数？">7.为什么vue中data必须是一个函数？</a></p> 
<p id="8.%E5%AF%B9MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:80px"><a href="#8.%E5%AF%B9MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3" title="8.对MVVM模式的理解">8.对MVVM模式的理解</a></p> 
<p id="9.%20vue-router%20%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%3F-toc" style="margin-left:80px"><a href="#9.%20vue-router%20%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%3F" title="9. vue-router 有哪几种导航钩子?">9. vue-router 有哪几种导航钩子?</a></p> 
<p id="10.%E8%B7%AF%E7%94%B1%E5%B5%8C%E5%A5%97-toc" style="margin-left:80px"><a href="#10.%E8%B7%AF%E7%94%B1%E5%B5%8C%E5%A5%97" title="10.路由嵌套">10.路由嵌套</a></p> 
<p id="11.axios%E7%9A%84%E7%89%B9%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:80px"><a href="#11.axios%E7%9A%84%E7%89%B9%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" title="11.axios的特点有哪些">11.axios的特点有哪些</a></p> 
<p id="12.%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0vuex%E8%A2%AB%E6%B8%85%E7%A9%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F-toc" style="margin-left:80px"><a href="#12.%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0vuex%E8%A2%AB%E6%B8%85%E7%A9%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F" title="12.页面刷新vuex被清空时的解决办法">12.页面刷新vuex被清空时的解决办法</a></p> 
<p id="13.vue%E4%B8%AD%E7%9A%84%20ref%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px"><a href="#13.vue%E4%B8%AD%E7%9A%84%20ref%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" title="13.vue中的 ref 是什么">13.vue中的 ref 是什么</a></p> 
<p id="14.Promise%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px"><a href="#14.Promise%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" title="14.Promise对象是什么">14.Promise对象是什么</a></p> 
<p id="15.%E4%BB%80%E4%B9%88%E6%98%AFjs%E7%9A%84%E5%86%92%E6%B3%A1%EF%BC%9FVue%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%EF%BC%9F-toc" style="margin-left:80px"><a href="#15.%E4%BB%80%E4%B9%88%E6%98%AFjs%E7%9A%84%E5%86%92%E6%B3%A1%EF%BC%9FVue%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%EF%BC%9F" title="15.什么是js的冒泡？Vue中如何阻止冒泡事件">15.什么是js的冒泡？Vue中如何阻止冒泡事件</a></p> 
<p id="16.%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F-toc" style="margin-left:80px"><a href="#16.%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F" title="16.指令周期">16.指令周期</a></p> 
<p id="17.%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96SPA%E5%BA%94%E7%94%A8%E7%9A%84%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F-toc" style="margin-left:80px"><a href="#17.%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96SPA%E5%BA%94%E7%94%A8%E7%9A%84%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F" title="17.如何优化SPA应用的首屏加载速度慢的问题？">17.如何优化SPA应用的首屏加载速度慢的问题？</a></p> 
<p id="18.%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bvuex%EF%BC%9F-toc" style="margin-left:80px"><a href="#18.%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bvuex%EF%BC%9F" title="18.解释一下vuex">18.解释一下vuex</a></p> 
<p id="19.%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%914%E7%A7%8Dvue%E5%BD%93%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E5%92%8C%E5%AE%83%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9F-toc" style="margin-left:80px"><a href="#19.%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%914%E7%A7%8Dvue%E5%BD%93%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E5%92%8C%E5%AE%83%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9F" title="19.说出至少4种vue当中的指令和它的用法？">19.说出至少4种vue当中的指令和它的用法？</a></p> 
<p id="20.vue.cli%E4%B8%AD%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%EF%BC%9F%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F-toc" style="margin-left:80px"><a href="#20.vue.cli%E4%B8%AD%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%EF%BC%9F%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F" title="20.vue.cli中怎样使用自定义组件？有遇到过哪些问题吗？">20.vue.cli中怎样使用自定义组件？有遇到过哪些问题吗？</a></p> 
<p id="21.vuex%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B1%9E%E6%80%A7%EF%BC%9F-toc" style="margin-left:80px"><a href="#21.vuex%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B1%9E%E6%80%A7%EF%BC%9F" title="21.vuex有哪几种属性？">21.vuex有哪几种属性？</a></p> 
<p id="22.%E4%B8%8D%E7%94%A8Vuex%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F-toc" style="margin-left:80px"><a href="#22.%E4%B8%8D%E7%94%A8Vuex%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F" title="22.不用Vuex会带来什么问题？">22.不用Vuex会带来什么问题？</a></p> 
<p id="23.Vue%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6-toc" style="margin-left:80px"><a href="#23.Vue%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6" title="23.Vue前端实现购物车">23.Vue前端实现购物车</a></p> 
<p id="24.methods%E3%80%81computed%E3%80%81watch%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px"><a href="#24.methods%E3%80%81computed%E3%80%81watch%E7%9A%84%E5%8C%BA%E5%88%AB" title="24.methods、computed、watch的区别">24.methods、computed、watch的区别</a></p> 
<p id="25.%E7%AE%80%E8%BF%B0vuex%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px"><a href="#25.%E7%AE%80%E8%BF%B0vuex%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B" title="25.简述vuex的数据传递流程">25.简述vuex的数据传递流程</a></p> 
<p id="26.%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99%20name%20%E9%80%89%E9%A1%B9%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-toc" style="margin-left:80px"><a href="#26.%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99%20name%20%E9%80%89%E9%A1%B9%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F" title="26.组件中写 name 选项有什么作用？">26.组件中写 name 选项有什么作用？</a></p> 
<p id="27.%3Ckeep-alive%3E%3C%2Fkeep-alive%3E%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:80px"><a href="#27.%3Ckeep-alive%3E%3C%2Fkeep-alive%3E%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%3F" title="27.的作用是什么？">27.的作用是什么？</a></p> 
<p id="28.mint-ui%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%91%E4%B8%89%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F-toc" style="margin-left:80px"><a href="#28.mint-ui%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%91%E4%B8%89%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F" title="28.mint-ui是什么？怎么使用？说出至少三个组件使用方法">28.mint-ui是什么？怎么使用？说出至少三个组件使用方法</a></p> 
<p id="29.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8D%20v-if%20%E5%92%8C%20v-for%20%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%9F-toc" style="margin-left:80px"><a href="#29.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8D%20v-if%20%E5%92%8C%20v-for%20%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%9F" title="29.为什么避免 v-if 和 v-for 用在一起？">29.为什么避免 v-if 和 v-for 用在一起？</a></p> 
<p id="30.%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3%20Vue%20%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9F-toc" style="margin-left:80px"><a href="#30.%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3%20Vue%20%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9F" title="30.怎样理解 Vue 的单向数据流？">30.怎样理解 Vue 的单向数据流？</a></p> 
<p id="31.Vue%20%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F-toc" style="margin-left:80px"><a href="#31.Vue%20%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F" title="31.Vue 的父组件和子组件生命周期钩子函数执行顺序？">31.Vue 的父组件和子组件生命周期钩子函数执行顺序？</a></p> 
<p id="32.%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%EF%BC%9F-toc" style="margin-left:80px"><a href="#32.%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%EF%BC%9F" title="32.在哪个生命周期内调用异步请求？">32.在哪个生命周期内调用异步请求？</a></p> 
<p id="33.%E4%BD%A0%E6%9C%89%E5%AF%B9%20Vue%20%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F-toc" style="margin-left:80px"><a href="#33.%E4%BD%A0%E6%9C%89%E5%AF%B9%20Vue%20%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F" title="33.你有对 Vue 项目进行哪些优化？">33.你有对 Vue 项目进行哪些优化？</a></p> 
<p id="34.%E8%99%9A%E6%8B%9F%20DOM%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F-toc" style="margin-left:80px"><a href="#34.%E8%99%9A%E6%8B%9F%20DOM%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F" title="34.虚拟 DOM 的优缺点">34.虚拟 DOM 的优缺点</a></p> 
<p id="35.%E8%99%9A%E6%8B%9F%20DOM%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:80px"><a href="#35.%E8%99%9A%E6%8B%9F%20DOM%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" title="35.虚拟 DOM 实现原理">35.虚拟 DOM 实现原理</a></p> 
<p id="36.%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%EF%BC%8CVue%20%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F-toc" style="margin-left:80px"><a href="#36.%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%EF%BC%8CVue%20%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F" title="36.直接给一个数组项赋值，Vue 能检测到变化吗？">36.直接给一个数组项赋值，Vue 能检测到变化吗？</a></p> 
<p id="37%E3%80%81%E5%9C%A8Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%80%E4%B9%88%E9%98%B6%E6%AE%B5%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9CDOM%EF%BC%9F-toc" style="margin-left:80px"><a href="#37%E3%80%81%E5%9C%A8Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%80%E4%B9%88%E9%98%B6%E6%AE%B5%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9CDOM%EF%BC%9F" title="37.在Vue生命周期什么阶段才能访问操作DOM？">37.在Vue生命周期什么阶段才能访问操作DOM？</a></p> 
<p id="38%E3%80%81Vue-router%20%E5%8E%9F%E7%90%86-toc" style="margin-left:80px"><a href="#38%E3%80%81Vue-router%20%E5%8E%9F%E7%90%86" title="38.Vue-router 原理">38.Vue-router 原理</a></p> 
<p id="39%E3%80%81router-link%20%E5%92%8C%20%24router.push%20%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:80px"><a href="#39%E3%80%81router-link%20%E5%92%8C%20%24router.push%20%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%8E%9F%E7%90%86" title="39.router-link 和 $router.push 实现跳转的原理">39.router-link 和 $router.push 实现跳转的原理</a></p> 
<p id="40%E3%80%81promise%20%E5%92%8C%20await%2Fasync%20%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px"><a href="#40%E3%80%81promise%20%E5%92%8C%20await%2Fasync%20%E5%8C%BA%E5%88%AB" title="40.promise 和 await/async 区别">40.promise 和 await/async 区别</a></p> 
<p id="41%E3%80%81v-if%20%E5%92%8C%20v-show%20%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px"><a href="#41%E3%80%81v-if%20%E5%92%8C%20v-show%20%E7%9A%84%E5%8C%BA%E5%88%AB" title="41.v-if 和 v-show 的区别">41.v-if 和 v-show 的区别</a></p> 
<p id="42%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8-toc" style="margin-left:80px"><a href="#42%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8" title="42.什么是单页应用？">42.什么是单页应用？</a></p> 
<p id="43%E3%80%81Vue%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-toc" style="margin-left:80px"><a href="#43%E3%80%81Vue%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86" title="43.Vue的权限管理">43.Vue的权限管理</a></p> 
<p id="44%E3%80%81vue%20%E7%9A%84%20watch%20%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84-toc" style="margin-left:80px"><a href="#44%E3%80%81vue%20%E7%9A%84%20watch%20%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84" title="44.vue 的 watch 是否可以监听数组">44.vue 的 watch 是否可以监听数组</a></p> 
<p id="45%E3%80%81%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88-toc" style="margin-left:80px"><a href="#45%E3%80%81%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88" title="45.前端的优化方案">45.前端的优化方案</a></p> 
<hr id="hr-toc">
<h3 id="1.v-if%20%E5%92%8C%20v-show%20%E5%8C%BA%E5%88%AB" style="margin-left:0px;text-align:justify">
<strong><span style="background-color:#ffffff">1.v-if </span></strong><strong><span style="background-color:#ffffff">和 v-show 区别</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify">（1）<strong>手段：</strong>v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</p> 
 <p style="margin-left:0;text-align:justify">（2）<strong>编译过程：</strong>v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</p> 
 <p style="margin-left:0;text-align:justify">（3）<strong>编译条件：</strong>v-if是惰性的，如果初始条件为假则什么也不做，只有在条件第一次变为真时才开始局部编译；v-show是在任何条件下都被编译，然后被缓存，而且DOM元素保留；</p> 
 <p style="margin-left:0;text-align:justify">（4）<strong>性能消耗：</strong>v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</p> 
 <p style="margin-left:0;text-align:justify">（5）<strong>使用场景：</strong>v-if适合运营条件不大可能改变；v-show适合频繁切换。</p> 
</blockquote> 
<h3 id="2.vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F" style="margin-left:0px;text-align:justify">
<strong><span style="background-color:#ffffff">2.vue</span></strong><strong><span style="background-color:#ffffff">常用的修饰符</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify">.prevent: 提交事件不再重载页面；</p> 
 <p style="margin-left:0;text-align:justify">.stop: 阻止单击事件冒泡；</p> 
 <p style="margin-left:0;text-align:justify">.self: 当事件发生在该元素本身而不是子元素的时候会触发；</p> 
 <p style="margin-left:0;text-align:justify">.capture: 事件侦听，事件发生的时候会调用。</p> 
</blockquote> 
<h3 id="3.vue%E4%B8%AD%20key%20%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F" style="margin-left:0px;text-align:justify">
<strong><span style="background-color:#ffffff">3.vue</span></strong><strong><span style="background-color:#ffffff">中 key 值的作用</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify">        当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，默认用“就地复用”策略，如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。<span style="color:#fe2c24">key的作用主要是为了高效的更新虚拟DOM。</span></p> 
</blockquote> 
<h3 id="4.vue%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%88SPA%EF%BC%89%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" style="margin-left:0px;text-align:justify">
<strong><span style="background-color:#ffffff">4.vue的</span></strong><strong><span style="background-color:#ffffff">单页面应用（SPA）的优缺点</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0px;text-align:justify">        优点：Vue是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统；组件化开发、轻量、简洁、高效、快速、模块友好。</p> 
 <p style="margin-left:0px;text-align:justify">        缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。</p> 
</blockquote> 
<h3 id="5.Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" style="margin-left:0px;text-align:justify">
<strong><span style="background-color:#ffffff">5.Vue</span></strong><strong><span style="background-color:#ffffff">的生命周期</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify"><strong>（1）生命周期是什么？</strong></p> 
 <p style="margin-left:0;text-align:justify">        Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom 渲染 更新 渲染 卸载等一系列过程，我们称这是 Vue 的生命周期。</p> 
 <p style="margin-left:0;text-align:justify"><strong>（2）生命周期的各个阶段作用</strong></p> 
 <p style="margin-left:0;text-align:justify"><strong>        </strong><span style="color:#fe2c24"><strong>beforeCreate</strong></span>（创建前）数据观测和初始化事件还未开始；</p> 
 <p style="margin-left:0;text-align:justify"><strong>        </strong><span style="color:#fe2c24"><strong>created</strong></span>（创建后）完成数据观测，属性和方法的运算，初始化事件，$el属性还未显示出来；</p> 
 <p style="margin-left:0;text-align:justify"><strong>        </strong><span style="color:#fe2c24"><strong>beforeMount</strong></span>（挂载前）在挂载开始之前被调用，相关的render函数首次被调用，实例已完成以下的配置：编译模板，把data里面的数据和模板生成html；注意此时还没有挂载html到页面上；</p> 
 <p style="margin-left:0;text-align:justify"><strong>        </strong><span style="color:#fe2c24"><strong>mounted</strong></span>（挂载后）el被新创建的 vm.$el 替换，并挂载到实例上去调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</p> 
 <p style="margin-left:0;text-align:justify"><strong>       </strong><span style="color:#fe2c24"><strong> beforeUpdate</strong></span>（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程；</p> 
 <p style="margin-left:0;text-align:justify"><strong>        </strong><span style="color:#fe2c24"><strong>updated</strong></span>（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用；</p> 
 <p style="margin-left:0;text-align:justify"><strong>        </strong><span style="color:#fe2c24"><strong>beforeDestroy</strong></span>（销毁前） 在实例销毁之前调用，实例仍然完全可用；</p> 
 <p style="margin-left:0;text-align:justify"><strong>        </strong><span style="color:#fe2c24"><strong>destroyed</strong></span>（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p> 
</blockquote> 
<h3 id="6.Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" style="margin-left:0px;text-align:justify"><strong><span style="background-color:#ffffff">6.Vue组件间的参数传递</span></strong></h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify"><strong><span style="color:#fe2c24">父子组件间传参   </span></strong></p> 
 <p style="margin-left:0;text-align:justify">        父给子传参（父：自定义属性传递变量；子：用Props['父元素自定义属性']接受）  </p> 
 <p style="margin-left:0;text-align:justify">        子给父传参（子：this.$emit(父元素自定义事件，传递的值) ；父：自定义事件用参数去接收传递来 的值）   </p> 
 <p style="margin-left:0;text-align:justify"><strong><span style="color:#fe2c24">兄弟间传参</span></strong>（除了以下方式也可直接用Vuex）</p> 
 <p style="margin-left:0;text-align:justify">        通过给eventbus注册事件，别的组件触发事件，实现通信。</p> 
 <p style="margin-left:0;text-align:justify">        ①创建一个eventbus对象，即创造一个vue对象，用作传递信息。</p> 
 <p style="margin-left:0;text-align:justify">        ②接收信息的一方将事件通过vm.$on(“事件名”,事件处理函数)添加在eventbus对象上。</p> 
 <p style="margin-left:0;text-align:justify">        ③发送数据的一方，通过vm.$emit(“事件名”,传递的数据)触发事件，将数据传递。</p> 
 <p style="margin-left:0;text-align:justify"><strong><span style="color:#fe2c24">路由传参</span></strong></p> 
 <p style="margin-left:0;text-align:justify">a.通过params   </p> 
 <pre><code class="language-javascript">//需要在router的path后跟上参数
{
   path: "/two",
   name: "two",
   component: two
}

//跳转时
   this.$router.push({
      path: `/two` //直接把数据拼接在path后面
   })

//接收时
   this.$route.params</code></pre> 
 <p style="margin-left:0;text-align:justify"> b.通过query </p> 
 <pre><code class="language-javascript">//跳转时
this.$router.push({
    path: `/two`,
    query: { id: this.message, data: 456 }
});    

//接收时            
    this.$route.query</code></pre> 
 <p style="margin-left:0;text-align:justify">        params 和 query 都是传递参数的，params不会在url上面出现，并且params参数是路由的一部分，是一定要存在的 , query是我们通常看到的url后面的跟在 ？后面的显示参数。</p> 
</blockquote> 
<h3 id="7.%E4%B8%BA%E4%BB%80%E4%B9%88vue%E4%B8%ADdata%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F" style="margin-left:0px;text-align:justify"><strong><span style="background-color:#ffffff">7.为什么vue中data必须是一个函数？</span></strong></h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify">        对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</p> 
</blockquote> 
<h3 id="8.%E5%AF%B9MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3" style="margin-left:0px;text-align:justify"><strong>8.对MVVM模式的理解</strong></h3> 
<blockquote> 
 <p style="margin-left:0cm">        MVVM 是 Model-View-ViewModel 的缩写；</p> 
 <p style="margin-left:0cm">        <span style="color:#fe2c24">Model </span>代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；</p> 
 <p style="margin-left:0cm">       <span style="color:#fe2c24"> View</span> 代表UI组件，负责将数据模型转化成UI展现出来；</p> 
 <p style="margin-left:0cm;text-align:justify">       <span style="color:#fe2c24"> ViewModel</span> 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。</p> 
 <p style="margin-left:0cm;text-align:justify">        在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p> 
 <p style="margin-left:0cm;text-align:justify">        ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 统一管理。</p> 
</blockquote> 
<h3 id="9.%20vue-router%20%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%3F" style="margin-left:0cm"><strong>9. vue-router 有哪几种导航钩子?</strong></h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr>
<td style="text-align:center;width:199px">全局导航钩子</td>
<td style="width:300px"> <p style="margin-left:0cm">router.beforeEach(to, from, next),</p> <p style="margin-left:0cm">router.beforeResolve(to, from, next),</p> <p style="margin-left:0cm">router.afterEach(to, from ,next)</p> </td>
</tr>
<tr>
<td style="text-align:center;width:199px">组件内钩子</td>
<td style="width:300px"> <p style="margin-left:0cm">beforeRouteEnter,</p> <p style="margin-left:0cm">beforeRouteUpdate,</p> <p style="margin-left:0cm">beforeRouteLeave</p> </td>
</tr>
<tr>
<td style="text-align:center;width:199px">单独路由独享组件</td>
<td style="width:300px">beforeEnter</td>
</tr>
</tbody></table>
<h3 id="10.%E8%B7%AF%E7%94%B1%E5%B5%8C%E5%A5%97" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">10.</span></strong><strong><span style="background-color:#ffffff">路由嵌套</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转；</p> 
 <p style="margin-left:0cm">        router-view本身就是将组件渲染到该位置，想要进行页面跳转，就要将页面渲染到根组件，在起始配置路由时候写：</p> 
 <pre><code class="language-javascript">var App = Vue.extend({ root });

router.start(App,'#app');</code></pre> 
</blockquote> 
<h3 id="11.axios%E7%9A%84%E7%89%B9%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" style="margin-left:0cm"><strong>11.axios的特点有哪些</strong></h3> 
<blockquote> 
 <p style="margin-left:0cm">（1）axios是一个基于promise的HTTP库，支持promise的所有API；</p> 
 <p style="margin-left:0cm">（2）它可以拦截请求和响应；</p> 
 <p style="margin-left:0cm">（3）它可以转换请求数据和响应数据，并对响应回来的内容自动转换为json类型的数据；</p> 
 <p style="margin-left:0cm">（4）它安全性更高，客户端支持防御XSRF。</p> 
</blockquote> 
<h3 id="12.%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0vuex%E8%A2%AB%E6%B8%85%E7%A9%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">12.</span></strong><strong><span style="background-color:#ffffff">页面刷新vuex被清空时的解决办法</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">（1）localStorage 存储到本地再回去；</p> 
 <p style="margin-left:0cm">（2）重新获取接口获取数据。</p> 
</blockquote> 
<h3 id="13.vue%E4%B8%AD%E7%9A%84%20ref%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">13.vue</span></strong><strong><span style="background-color:#ffffff">中的 ref 是什么</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上；如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。</p> 
</blockquote> 
<h3 id="14.Promise%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">14.Promise</span></strong><strong><span style="background-color:#ffffff">对象是什么</span></strong>
</h3> 
<blockquote> 
 <p>        Promise是异步编程的一种解决方案，它是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，可以获取异步操作的消息；Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理；promise对象是一个构造函数，用来生成Promise实例；</p> 
 <p>        promise的特点是对象状态不受外界影响且一旦状态改变，就不会再变，任何时候都可以得到结果。Promise有三种状态：</p> 
 <p><span style="color:#fe2c24">        pending：初始状态，不是成功或失败状态。</span></p> 
 <p><span style="color:#fe2c24">        fulfilled：意味着操作成功完成。</span></p> 
 <p><span style="color:#fe2c24">        rejected：意味着操作失败。 </span></p> 
 <p>        优点是将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数，避免回调地狱。Promise 对象提供统一的接口，使得控制异步操作更加容易。</p> 
 <p>        缺点是无法取消 Promise，一旦新建它就会立即执行，无法中途取消，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。 当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p> 
</blockquote> 
<h3 id="15.%E4%BB%80%E4%B9%88%E6%98%AFjs%E7%9A%84%E5%86%92%E6%B3%A1%EF%BC%9FVue%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">15.</span></strong><strong><span style="background-color:#ffffff">什么是js的冒泡？Vue中如何阻止冒泡事件</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        js冒泡概念：当父元素内多级子元素绑定了同一个事件，js会依次从内往外或者从外往内执行每个元素的该事件，从而引发冒泡。</p> 
 <p style="margin-left:0cm">        js解决冒泡：event.stopPropagation();</p> 
 <p style="margin-left:0cm">        vue解决冒泡： 事件.stop,例如：@click.stop="" <a href="mailto:,@mouseover.stop=%22%22" title='、@mouseover.stop=""'>、@mouseover.stop=""</a></p> 
</blockquote> 
<h3 id="16.%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">16.</span></strong><strong><span style="background-color:#ffffff">指令周期</span></strong>
</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr>
<td style="width:163px"> <p style="margin-left:0cm;text-align:center">Bind</p> </td>
<td style="width:336px">一次初始化调用  </td>
</tr>
<tr>
<td style="text-align:center;width:163px">inserted</td>
<td style="width:336px">被绑定元素插入父节点调用</td>
</tr>
<tr>
<td style="text-align:center;width:163px">Update</td>
<td style="width:336px">模板更新调用 </td>
</tr>
<tr>
<td style="text-align:center;width:163px">unbind</td>
<td style="width:336px">指令与元素解绑时调用</td>
</tr>
<tr>
<td style="text-align:center;width:163px">Vue.nextTick</td>
<td style="width:336px">在dom更新后执行，一般用于dom操作</td>
</tr>
<tr>
<td style="text-align:center;width:163px">Vue.$nextTick</td>
<td style="width:336px">一直到真实的dom渲染结束后执行</td>
</tr>
</tbody></table>
<h3 id="17.%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96SPA%E5%BA%94%E7%94%A8%E7%9A%84%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">17.</span></strong><strong><span style="background-color:#ffffff">如何优化SPA应用的首屏加载速度慢的问题？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</p> 
 <p style="margin-left:0cm">        在配置路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</p> 
 <p style="margin-left:0cm">        加一个首屏 loading 图，提升用户体验；</p> 
</blockquote> 
<h3 id="18.%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bvuex%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">18.</span></strong><strong><span style="background-color:#ffffff">解释一下vuex</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        vuex是用来做状态管理的，有五个常用属性state, getter, actions, mutations, modules；</p> 
 <p style="margin-left:0cm">        <span style="color:#fe2c24">state</span>是数据源，类似vue中的data，我们可以通过两种方式来获取它，mapStates, mapGerters。<strong>获取state必须放到computed中，这样才能保证state发生改变的时候该组件中用到state的地方都发生变化</strong>。</p> 
 <p style="margin-left:0cm">        <span style="color:#fe2c24">getters</span>：相当于计算属性；</p> 
 <p style="margin-left:0cm">        <span style="color:#fe2c24">mutation</span>：同步操作, 修改数据；</p> 
 <p style="margin-left:0cm">       <span style="color:#fe2c24"> action</span>：异步操作；</p> 
 <p style="margin-left:0cm">        <span style="color:#fe2c24">modules</span>：模块化</p> 
 <p style="margin-left:0cm"><strong>补充：如何获取vuex的state对象中的属性？</strong></p> 
 <p style="margin-left:0cm">        方法1：直接从store实例中取值 <strong><span style="color:#1c7331">this.$store.state.属性</span></strong>；</p> 
 <p style="margin-left:0cm"><strong>       </strong> 方法2：利用vuex的<span style="color:#1c7331"><strong>mapState</strong></span>方法来获取vuex的state对象中属性；</p> 
 <pre><code class="language-javascript">//先在组件中引入vuex的mapState方法
import { mapState } from 'vuex'

//在computed中
        computed:{
            ...mapState({
                count:state =&gt; state.count   //使用ES6的箭头函数来给count赋值
            })

        }
//在computed中也可写成数组格式
        computed:
            ...mapState(['count'])
        }
</code></pre> 
 <p style="margin-left:0cm"></p> 
</blockquote> 
<h3 id="19.%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%914%E7%A7%8Dvue%E5%BD%93%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E5%92%8C%E5%AE%83%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">19.</span></strong><strong><span style="background-color:#ffffff">说出至少4种vue当中的指令和它的用法？</span></strong>
</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody>
<tr>
<td style="width:98px"> <p style="margin-left:0cm;text-align:center"><strong>v-if</strong></p> </td>
<td style="width:401px">判断是否隐藏；</td>
</tr>
<tr>
<td style="text-align:center;width:98px"><strong>v-for</strong></td>
<td style="width:401px">连续生成一组结构相同，但是内容不同的HTML元素；</td>
</tr>
<tr>
<td style="text-align:center;width:98px"><strong>v-bind</strong></td>
<td style="width:401px">元素的属性值可能随程序自动变化，用v-bind绑定；</td>
</tr>
<tr>
<td style="text-align:center;width:98px"><strong>v-model</strong></td>
<td style="width:401px">实现双向绑定；</td>
</tr>
<tr>
<td style="text-align:center;width:98px"><strong>v-on</strong></td>
<td style="width:401px">为元素绑定事件，可简写为@；</td>
</tr>
<tr>
<td style="text-align:center;width:98px"><strong>v-html</strong></td>
<td style="width:401px">绑定一段HTML代码片段到页面上；</td>
</tr>
<tr>
<td style="width:98px"> <p style="text-align:center"><strong>v-once</strong></p> </td>
<td style="width:401px">一个元素的内容，只会在首次加载时绑定一次，之后几乎不会改变时，都用v-once标记；</td>
</tr>
<tr>
<td style="width:98px"> <p style="text-align:center"><strong>v-pre</strong></p> </td>
<td style="width:401px">正文中包含了不希望被vue编译的{<!-- -->{ }}时，采用v-pre保护。</td>
</tr>
</tbody></table>
<blockquote> 
 <p>补充：v-for为什么必须加<strong>:</strong>key</p> 
 <p>        a.为每个元素添加唯一标识；</p> 
 <p>        b.避免重建整个列表；</p> 
 <p>        c.提高修改的效率。</p> 
</blockquote> 
<h3 id="20.vue.cli%E4%B8%AD%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%EF%BC%9F%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">20.vue.cli</span></strong><strong><span style="background-color:#ffffff">中怎样使用自定义组件？有遇到过哪些问题吗？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        第一步：在components目录新建组件文件（smithButton.vue），在组件文件中的script代码中一定要用 export default 将组件导出；</p> 
 <p style="margin-left:0cm">        第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’；</p> 
 <p style="margin-left:0cm;text-align:justify">        第三步：注入到vue的子组件的components属性上面,components:{smithButton}；</p> 
 <p style="margin-left:0cm;text-align:justify">        第四步：在template视图view中使用，&lt;smith-button&gt; &lt;/smith-button&gt;</p> 
 <p style="margin-left:0cm">        问题：smithButton命名，使用的时候则smith-button（HTML不认识大写字母）。</p> 
</blockquote> 
<h3 id="21.vuex%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B1%9E%E6%80%A7%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">21.vuex</span></strong><strong><span style="background-color:#ffffff">有哪几种属性？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        有五种，分别是 State、Getter、Mutation 、Action、Module；</p> 
 <p style="margin-left:0cm">        <span style="color:#fe2c24"><strong>state</strong></span>为单一状态树，在state中需要定义我们所需要管理的数组、对象、字符串等等，只有在这里定义了，在vue.js的组件中才能获取定义对象的状态；</p> 
 <p style="margin-left:0cm">       <span style="color:#fe2c24"><strong> getter</strong></span>类似vue.js的计算属性，当我们需要从store的state中派生出一些状态时，就需要使用getter，getter会接收state作为第一个参数，而且getter的返回值会根据它的依赖被缓存起来，只有getter中的依赖值（state中的某个需要派生状态的值）发生改变的时候才会被重新计算；</p> 
 <p style="margin-left:0cm">        更改store中state状态的唯一方法就是提交<span style="color:#fe2c24"><strong>mutation</strong></span>，每个mutation都有一个字符串类型的事件类型和一个回调函数，我们需要改变state的值就要在回调函数中改变，要执行这个回调函数，就需要执行一个相应的调用方法：store.commit；</p> 
 <p style="margin-left:0cm">       <strong><span style="color:#fe2c24"> action</span></strong>可以提交mutation，在action中可以执行store.commit，而且action中可以有任何的异步操作。在页面中如果我们要用这个action，就需要执行store.dispatch；</p> 
 <p style="margin-left:0cm">        当state中很复杂臃肿的时候，<span style="color:#fe2c24"><strong>module</strong></span>可以将store分割成模块，每个模块中拥有自己的state、mutation、action和getter。</p> 
</blockquote> 
<h3 id="22.%E4%B8%8D%E7%94%A8Vuex%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">22.</span></strong><strong><span style="background-color:#ffffff">不用Vuex会带来什么问题？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">（1）可维护性会下降，要想修改数据，得维护三个地方；</p> 
 <p style="margin-left:0cm">（2）可读性会下降，因为一个组件里的数据，看不出来是从哪来；</p> 
 <p style="margin-left:0cm">（3）增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。</p> 
</blockquote> 
<h3 id="23.Vue%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">23.Vue</span></strong><strong><span style="background-color:#ffffff">前端实现购物车</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">利用vuex + vant 实现购物车功能，概括有以下步骤：</p> 
 <p style="margin-left:0cm">（1）mock模拟数据；</p> 
 <p style="margin-left:0cm">（2）利用veux操作商品的选中状态；</p> 
 <p style="margin-left:0cm">（3）全选与取消全选；</p> 
 <p style="margin-left:0cm">（4）动态reduce计算价格；</p> 
 <p style="margin-left:0cm">（5）结算取出商品id；</p> 
 <p style="margin-left:0cm">（6）利用manageStatus判断管理状态，管理删除商品；</p> 
 <p style="margin-left:0cm">（7）未删除商品的状态存储。</p> 
</blockquote> 
<h3 id="24.methods%E3%80%81computed%E3%80%81watch%E7%9A%84%E5%8C%BA%E5%88%AB" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">24.methods</span></strong><strong><span style="background-color:#ffffff">、computed、watch的区别</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        methods是个方法，执行的时候需要事件进行触发；</p> 
 <p style="margin-left:0cm;text-align:justify">        computed是一个计算属性，是实时响应的，只要data中的属性发生了变化那么就会触发computed，计算属性是基于属性的依赖进行缓存的，methods调用的时候需要加()，而computed调用的时候不需要加()；</p> 
 <p style="margin-left:0cm;text-align:justify">        watch用来监听属性的变化，当值发生变化的时候来执行特定的函数，watch监听属性的时候会有2个参数newVal和oldVal一个新值一个旧值。</p> 
</blockquote> 
<h3 id="25.%E7%AE%80%E8%BF%B0vuex%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">25.</span></strong><strong><span style="background-color:#ffffff">简述vuex的数据传递流程</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        当组件进行数据修改的时候我们需要调用dispatch来触发actions里面的方法，actions里面的每个方法中都会 有一个commit方法，当方法执行的时候会通过commit来触发mutations里面的方法进行数据的修改，mutations里面的每个函数都会有一个state参数，这样就可以在mutations里面进行state的数据修改 ，当数据修改完毕后，会传导给页面，页面的数据也会发生改变。</p> 
</blockquote> 
<h3 id="26.%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99%20name%20%E9%80%89%E9%A1%B9%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">26.</span></strong><strong><span style="background-color:#ffffff">组件中写 name 选项有什么作用？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">（1）项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤；</p> 
 <p style="margin-left:0cm">（2）DOM 做递归组件时需要调用自身 name；</p> 
 <p style="margin-left:0cm">（3）vue-devtools 调试工具里显示的组见名称是由vue中组件name决定的。</p> 
</blockquote> 
<h3 id="27.%3Ckeep-alive%3E%3C%2Fkeep-alive%3E%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%3F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">27.&lt;keep-alive&gt;&lt;/keep-alive&gt;</span></strong><strong><span style="background-color:#ffffff">的作用是什么？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        &lt;keep-alive&gt;&lt;/keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。</p> 
</blockquote> 
<h3 id="28.mint-ui%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%91%E4%B8%89%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">28.mint-ui</span></strong><strong><span style="background-color:#ffffff">是什么？怎么使用？说出至少三个组件使用方法</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        基于vue的前端组件库。先npm安装，然后import引入样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。</p> 
 <p style="margin-left:0cm">        组件一：Toast(‘登录成功’)；</p> 
 <p style="margin-left:0cm">        组件二：mint-header；</p> 
 <p style="margin-left:0cm">        组件三：mint-swiper</p> 
</blockquote> 
<h3 id="29.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8D%20v-if%20%E5%92%8C%20v-for%20%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">29.</span></strong><strong><span style="background-color:#ffffff">为什么避免 v-if 和 v-for 用在一起？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm;text-align:justify">        当 Vue 处理指令时，<span style="color:#fe2c24">v-for 比 v-if 具有更高的优先级</span>，通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</p> 
</blockquote> 
<h3 id="30.%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3%20Vue%20%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">30.</span></strong><strong><span style="background-color:#ffffff">怎样理解 Vue 的单向数据流？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行；</p> 
 <p style="margin-left:0cm">        这样会防止从子组件意外改变父级组件的状态，从而导致应用的数据流向难以理解；</p> 
 <p style="margin-left:0cm">        除此之外，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值，</p> 
 <p style="margin-left:0cm">所以不应该在一个子组件内部改变 prop，如果你这样做了，Vue 会在浏览器的控制台中发出警告；</p> 
 <p style="margin-left:0cm">        子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件来修改。</p> 
</blockquote> 
<h3 id="31.Vue%20%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">31.Vue </span></strong><strong><span style="background-color:#ffffff">的父组件和子组件生命周期钩子函数执行顺序？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p> 
 <p style="margin-left:0cm"><strong>加载渲染过程</strong></p> 
 <p style="margin-left:0cm">父 beforeCreate --&gt; 父 created --&gt; 父 beforeMount --&gt; 子 beforeCreate --&gt; 子 created --&gt; 子 beforeMount --&gt; 子 mounted --&gt; 父 mounted</p> 
 <p style="margin-left:0cm"><strong>子组件更新过程</strong></p> 
 <p style="margin-left:0cm">父 beforeUpdate --&gt; 子 beforeUpdate --&gt; 子 updated --&gt; 父 updated</p> 
 <p style="margin-left:0cm"><strong>父组件更新过程</strong></p> 
 <p style="margin-left:0cm">父 beforeUpdate --&gt; 父 updated</p> 
 <p style="margin-left:0cm"><strong>销毁过程</strong></p> 
 <p style="margin-left:0cm">父 beforeDestroy --&gt; 子 beforeDestroy --&gt; 子 destroyed --&gt; 父 destroyed</p> 
</blockquote> 
<h3 id="32.%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">32.</span></strong><strong><span style="background-color:#ffffff">在哪个生命周期内调用异步请求？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是<span style="color:#fe2c24">更推荐在 created 钩子函数中调用异步请求</span>，因为在 created 钩子函数中调用异步请求有以下优点：</p> 
 <p style="margin-left:0cm">        （1）能更快获取到服务端数据，减少页面 loading 时间；</p> 
 <p style="margin-left:0cm">        （2）ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</p> 
</blockquote> 
<h3 id="33.%E4%BD%A0%E6%9C%89%E5%AF%B9%20Vue%20%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">33.</span></strong><strong><span style="background-color:#ffffff">你有对 Vue 项目进行哪些优化？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm"><strong>（1）代码层面的优化</strong></p> 
 <p style="margin-left:0cm">        v-if 和 v-show 区分使用场景；</p> 
 <p style="margin-left:0cm">        computed 和 watch 区分使用场景；</p> 
 <p style="margin-left:0cm">        v-for 遍历必须为 item 添加 key，且避免同时使用 v-if；</p> 
 <p style="margin-left:0cm">        长列表性能优化；</p> 
 <p style="margin-left:0cm">        事件的销毁；</p> 
 <p style="margin-left:0cm">        图片资源懒加载；</p> 
 <p style="margin-left:0cm">        路由懒加载；</p> 
 <p style="margin-left:0cm">        第三方插件的按需引入；</p> 
 <p style="margin-left:0cm">        优化无限列表性能；</p> 
 <p style="margin-left:0cm">        服务端渲染 SSR or 预渲染；</p> 
 <p style="margin-left:0cm"><strong>（2）Webpack 层面的优化</strong></p> 
 <p style="margin-left:0cm">        Webpack 对图片进行压缩；</p> 
 <p style="margin-left:0cm">        减少 ES6 转为 ES5 的冗余代码；</p> 
 <p style="margin-left:0cm">        提取公共代码；</p> 
 <p style="margin-left:0cm">        模板预编译；</p> 
 <p style="margin-left:0cm">        提取组件的 CSS；</p> 
 <p style="margin-left:0cm">        优化 SourceMap；</p> 
 <p style="margin-left:0cm">        构建结果输出分析；</p> 
 <p style="margin-left:0cm">        Vue 项目的编译优化；</p> 
 <p style="margin-left:0cm"><strong>（3）基础的 Web 技术的优化</strong></p> 
 <p style="margin-left:0cm">        开启 gzip 压缩；</p> 
 <p style="margin-left:0cm">        浏览器缓存；</p> 
 <p style="margin-left:0cm">        CDN 的使用；</p> 
 <p style="margin-left:0cm">        使用 Chrome Performance 查找性能瓶颈；</p> 
</blockquote> 
<h3 id="34.%E8%99%9A%E6%8B%9F%20DOM%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">34.</span></strong><strong><span style="background-color:#ffffff">虚拟 DOM 的优缺点</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm"><strong>优点：</strong></p> 
 <p style="margin-left:0cm">        <strong>保证性能下限</strong>： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</p> 
 <p style="margin-left:0cm">        <strong>无需手动操作 DOM</strong>： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</p> 
 <p style="margin-left:0cm">        <strong>跨平台</strong>： 虚拟 DOM 本质上是 JavaScript 对象，而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</p> 
 <p style="margin-left:0cm"><strong>缺点：</strong></p> 
 <p style="margin-left:0cm">        <strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</p> 
</blockquote> 
<h3 id="35.%E8%99%9A%E6%8B%9F%20DOM%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">35.</span></strong><strong><span style="background-color:#ffffff">虚拟 DOM 实现原理</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">虚拟 DOM 的实现原理主要包括以下 3 部分：</p> 
 <p style="margin-left:0cm">（1）用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</p> 
 <p style="margin-left:0cm">（2）diff 算法 — 比较两棵虚拟 DOM 树的差异；</p> 
 <p style="margin-left:0cm">（3）pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</p> 
</blockquote> 
<h3 id="36.%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%EF%BC%8CVue%20%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">36.</span></strong><strong><span style="background-color:#ffffff">直接给一个数组项赋值，Vue 能检测到变化吗？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p> 
 <p style="margin-left:0cm">（1）利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p> 
 <p style="margin-left:0cm">（2）当你修改数组的长度时，例如：vm.items.length = newLength</p> 
 <p style="margin-left:0cm">为了解决第一个问题，Vue 提供了以下操作方法：</p> 
 <pre><code class="language-javascript">// Vue.set
Vue.set(vm.items, indexOfItem, newValue)

// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)

// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)</code></pre> 
 <p style="margin-left:0cm">为了解决第二个问题，Vue 提供了以下操作方法：</p> 
 <pre><code class="language-javascript">// Array.prototype.splice
vm.items.splice(newLength)</code></pre> 
</blockquote> 
<h3 id="37%E3%80%81%E5%9C%A8Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%80%E4%B9%88%E9%98%B6%E6%AE%B5%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9CDOM%EF%BC%9F" style="margin-left:0cm">
<strong><span style="background-color:#ffffff">37</span></strong><strong><span style="background-color:#ffffff">.在Vue生命周期什么阶段才能访问操作DOM？</span></strong>
</h3> 
<blockquote> 
 <p style="margin-left:0cm">        在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。</p> 
</blockquote> 
<h3 id="38%E3%80%81Vue-router%20%E5%8E%9F%E7%90%86">38.Vue-router 原理</h3> 
<blockquote> 
 <p>        vue-router通过hash与history两种方式实现前端路由；更新视图但不重新请求页面是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：</p> 
 <p><strong>（1）hash：</strong>利用 URL 中的 hash. 形式上会多个# ；如下，</p> 
 <pre><code>http://localhost:8080/#/login</code></pre> 
 <p>        hash("#") 的作用是加载 URL 中指示网页中的位置； # 本身以及它后面的字符称之为 hash，可通过 window.location.hash 获取；</p> 
 <p>        hash 虽然出现在 url 中，但不会被包括在 http 请求中，它是用来指导浏览器动作的，对服务器端完全无用，因此改变 hash 不会重新加载页面， 每一次改变 hash(window.localtion.hash)都会在浏览器访问历史中增加一个记录。 利用 hash 的以上特点，就可以来实现前端路由"更新视图但不重新请求页面"的功能了。</p> 
 <p><strong>（2）history：</strong>html5 中新增的方法，形式上比 hash更好看；如下，</p> 
 <pre><code>http://localhost:8080/login</code></pre> 
 <p>        History interface 是浏览器历史记录栈提供的接口，通过back()、forward()、go()等方法，可以读取浏览器历史记录栈的信息，进行各种跳转操作。</p> 
 <p>        从 HTML5开始，History interface 提供了2个新的方法：pushState()、replaceState() 使得我们 可以对浏览器历史记录栈进行修改，这2个方法有个共同的特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。</p> 
</blockquote> 
<h3 id="39%E3%80%81router-link%20%E5%92%8C%20%24router.push%20%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%8E%9F%E7%90%86">39.router-link 和 $router.push 实现跳转的原理</h3> 
<blockquote> 
 <p><span style="color:#fe2c24">router-link</span></p> 
 <p>        默认会渲染为 a 标签，可以通过 tag 属性修改为其他标签，自动为 a 标签添加 click 事件，然后执行 $router.push() 实现跳转；</p> 
 <p><span style="color:#fe2c24">$router.push</span></p> 
 <p>        根据路由配置的 mode 确定使用 HTML5History 还是 HashHistory 实现跳转；</p> 
 <p>        HTML5History：调用 window.history.pushState() 跳转；</p> 
 <p>        HashHistory：调用 HashHistory.push() 跳转。</p> 
</blockquote> 
<h3 id="40%E3%80%81promise%20%E5%92%8C%20await%2Fasync%20%E5%8C%BA%E5%88%AB">40.promise 和 await/async 区别</h3> 
<blockquote> 
 <p>区别主要在于按顺序调用多个异步函数时的写法和报错获取，</p> 
 <p>Promise方式</p> 
 <pre><code class="language-javascript">ajax().then(func1).then(func2).then(func3).then(func4)</code></pre> 
 <p>await/async方式</p> 
 <pre><code class="language-javascript">async function demo(){
 await res = ajax();
 await res = func1(res);
 await res = func2(res);
 await res = func3(res);
 await res = func4(res);
}
</code></pre> 
 <p>        当遇到多个异步函数时 Promise 方式需要很多 .then，这样会导致代码不易读且结构复杂；await/async 方式让异步代码的格式与同步代码一样更易读。</p> 
 <p>        报错读取 Promise 使用 .catch 抓取报错，await/async 使用 try...catch... 方式抓取报错。</p> 
</blockquote> 
<h3 id="41%E3%80%81v-if%20%E5%92%8C%20v-show%20%E7%9A%84%E5%8C%BA%E5%88%AB">41.v-if 和 v-show 的区别</h3> 
<blockquote> 
 <table border="1" cellpadding="1" cellspacing="1" style="width:600px"><tbody>
<tr>
<td style="text-align:center"><strong><span style="color:#fe2c24">v-if</span></strong></td>
<td> <p>通过删除DOM元素实现元素的隐藏；</p> <p>惰性：只有条件为真时, 才会加载元素到DOM；</p> </td>
</tr>
<tr>
<td style="text-align:center"><strong><span style="color:#fe2c24">v-show</span></strong></td>
<td> <p>通过设置元素的css样式 display:none 实现元素的隐藏, 不操作DOM；</p> <p>非惰性：不管条件真与假, 都会加载元素到 DOM；</p> </td>
</tr>
</tbody></table>
 <p>        v-if 的开销比 v-show 更大，v-show 有更高的初始化渲染消耗；</p> 
 <p>        一个元素频繁进行隐藏和显示操作时使用 v-show 更加合适；一个元素不频繁进行隐藏和显示操作时使用 v-if 更合适。</p> 
</blockquote> 
<h3 id="42%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8">42.什么是单页应用？</h3> 
<blockquote> 
 <p>        单页应用的全称是 Single Page Application，简称 SPA，通过路由的变更，局部切换网页内容取代整个页面的刷新操作；</p> 
 <p>        三大框架 React、Vue、Angular 均采用单页应用模式；</p> 
 <p>        优点：用户操作体验好，用户不用刷新页面；局部更新, 对服务器压力小；良好的前后端分离，后端不再负责页面渲染和输出工作。</p> 
 <p>        缺点：首次加载耗时长, 速度慢；SEO不友好, 需要采用 prerender 服务进行完善。</p> 
</blockquote> 
<h3 id="43%E3%80%81Vue%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">43.Vue的权限管理</h3> 
<blockquote> 
 <p><strong>整体思路：</strong></p> 
 <p>        后端返回用户权限，前端根据用户权限处理得到左侧菜单；所有路由在前端定义好，根据后端返回的用户权限筛 选出需要挂载的路由，然后使用 addRoutes 动态挂载路由。</p> 
 <p><strong>具体思路：</strong></p> 
 <p>（1）路由定义，分为初始路由和动态路由，一般来说初始路由只有 login，其他路由都挂载在 home 路由之下 需要动态挂载；</p> 
 <p>（2）用户登录，登录成功之后得到 token，保存在 sessionStorage，跳转到 home，此时会进入路由拦截根 据 token 获取用户权限列表；</p> 
 <p>（3）全局路由拦截，根据当前用户有没有 token 和 权限列表进行相应的判断和跳转，当没有 token 时跳到 login，当有 token 而没有权限列表时去发请求获取权限等等逻辑；</p> 
 <p>（4）使用 Vuex 管理路由表, 根据 Vuex 动态渲染侧边栏组件。</p> 
</blockquote> 
<h3 id="44%E3%80%81vue%20%E7%9A%84%20watch%20%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84">44.vue 的 watch 是否可以监听数组</h3> 
<blockquote> 
 <p>能监听</p> 
 <p>        数组的元素增删：例如 push 和 splice 操作；</p> 
 <p>        数组元素内部的变化：必须手动开启 deep:true 配置, 才能监听到。</p> 
 <p>不能监听</p> 
 <p>        数组中已有值的替换。</p> 
</blockquote> 
<h3 id="45%E3%80%81%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88">45.前端的优化方案</h3> 
<blockquote> 
 <p>（1）尽量减少闭包的使用；</p> 
 <p>（2）进行 js 和 css 文件的合并，减少http请求次数，进行可能讲文件压缩，减少请求大小；</p> 
 <p>（3）使用字体图标和svg图标，代替传统的png格式；</p> 
 <p>（4）减少DOM操作，主要减少DOM的重绘和重排；</p> 
 <p>（5）采用图片懒加载，加快页面启动速度，加载页面时先不加载图片，使用一张背景图占位，等页面加载完毕后再加载图片；</p> 
 <p>（6）尽可能使用事件委托来处理绑定操作，减少DOM的频繁操作（事件委托：为父元素添加事件, 利用冒泡机制，让父元素处理所有子元素的事件）；</p> 
 <p>（7）减少 css 表达式的使用；</p> 
 <p>（8）减少 css 标签选择器的使用；</p> 
 <p>（9）页面数据获取方式采用异步和延迟分批加载。</p> 
</blockquote>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>