<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>二、小程序框架 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二、小程序框架</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A1%86%E6%9E%B6-toc" style="margin-left:0px"><a href="#%E6%A1%86%E6%9E%B6">框架</a></p> 
<p id="%E4%B8%80%E3%80%81%E5%93%8D%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81%E5%93%8D%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">一、响应的数据绑定</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86">二、页面管理</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6">三、基础组件</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%B8%B0%E5%AF%8C%E7%9A%84API-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81%E4%B8%B0%E5%AF%8C%E7%9A%84API">四、丰富的API</a></p> 
<p id="%E6%A8%A1%E5%9D%97%E5%8C%96-toc" style="margin-left:0px"><a href="#%E6%A8%A1%E5%9D%97%E5%8C%96">模块化</a></p> 
<p id="%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96">一、模块化</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F">二、文件作用域</a></p> 
<p id="%E4%B8%89%E3%80%81API-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81API">三、API</a></p> 
<p id="%E8%A7%86%E5%9B%BE%E5%B1%82%20View-toc" style="margin-left:0px"><a href="#%E8%A7%86%E5%9B%BE%E5%B1%82%20View">视图层 View</a></p> 
<p id="%E4%B8%80%E3%80%81WXML-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81WXML">一、WXML</a></p> 
<p id="%E4%BA%8B%E4%BB%B6-toc" style="margin-left:0px"><a href="#%E4%BA%8B%E4%BB%B6">事件</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6-toc" style="margin-left:40px"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6">什么是事件</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px"><a href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">事件的使用方式</a></p> 
<p id="%E4%BD%BF%E7%94%A8%20WXS%20%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6-toc" style="margin-left:40px"><a href="#%E4%BD%BF%E7%94%A8%20WXS%20%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6">使用 WXS 函数响应事件</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3-toc" style="margin-left:40px"><a href="#%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3">事件详解</a></p> 
<hr>
<p id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5-toc" style="margin-left:80px"></p> 
<h1><span style="color:#fe2c24">框架</span></h1> 
<p><strong>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</strong></p> 
<blockquote> 
 <p>整个小程序框架系统分为两部分：<strong><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/" title="逻辑层">逻辑层</a></strong>（App Service）和 <strong><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/" title="视图层">视图层</a></strong>（View）。小程序提供了自己的视图层描述语言 <code>WXML</code> 和 <code>WXSS</code>，以及基于 <code>JavaScript</code> 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。</p> 
</blockquote> 
<h1 id="%E4%B8%80%E3%80%81%E5%93%8D%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">一、响应的数据绑定</h1> 
<blockquote> 
 <p>框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。</p> 
</blockquote> 
<pre><code class="language-javascript">&lt;!-- This is our View --&gt;
&lt;view&gt; Hello {<!-- -->{name}}! &lt;/view&gt;
&lt;button bindtap="changeName"&gt; Click me! &lt;/button&gt;
// This is our App Service.
// This is our data.
var helloData = {
  name: 'Weixin'
}

// Register a Page.
Page({
  data: helloData,
  changeName: function(e) {
    // sent data change to view
    this.setData({
      name: 'MINA'
    })
  }
})</code></pre> 
<blockquote> 
 <ul>
<li> <p>开发者通过框架将逻辑层数据中的 <code>name</code> 与视图层的 <code>name</code> 进行了绑定，所以在页面一打开的时候会显示 <code>Hello Weixin!</code>；</p> </li>
<li> <p>当点击按钮的时候，视图层会发送 <code>changeName</code> 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；</p> </li>
<li> <p>回调函数触发后，逻辑层执行 <code>setData</code> 的操作，将 <code>data</code> 中的 <code>name</code> 从 <code>Weixin</code> 变为 <code>MINA</code>，因为该数据和视图层已经绑定了，从而视图层会自动改变为 <code>Hello MINA!</code>。</p> </li>
</ul>
</blockquote> 
<h1 id="%E4%BA%8C%E3%80%81%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86">二、页面管理</h1> 
<blockquote> 
 <p>框架 管理了整个<strong>小程序</strong>的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册到框架中，其他的一切复杂的操作都交由框架处理。</p> 
</blockquote> 
<h1 id="%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6">三、基础组件</h1> 
<blockquote> 
 <p>框架 提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的<strong>微信小程序</strong> 。</p> 
</blockquote> 
<h1 id="%E5%9B%9B%E3%80%81%E4%B8%B0%E5%AF%8C%E7%9A%84API">四、丰富的API</h1> 
<blockquote> 
 <p>框架 提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p> 
</blockquote> 
<h1 id="%E9%80%BB%E8%BE%91%E5%B1%82%20App%20Service"><span style="color:#fe2c24">逻辑层 App Service</span></h1> 
<p>小程序开发框架的逻辑层使用 <code>JavaScript</code> 引擎为小程序提供开发者 <code>JavaScript</code> 代码的运行环境以及微信小程序的特有功能。</p> 
<h3 id="%E9%80%BB%E8%BE%91%E5%B1%82%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E5%90%8E%E5%8F%91%E9%80%81%E7%BB%99%E8%A7%86%E5%9B%BE%E5%B1%82%EF%BC%8C%E5%90%8C%E6%97%B6%E6%8E%A5%E5%8F%97%E8%A7%86%E5%9B%BE%E5%B1%82%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%8F%8D%E9%A6%88%E3%80%82"><span style="color:#fe2c24">逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</span></h3> 
<blockquote> 
 <p>开发者写的所有代码最终将会打包成一份 <code>JavaScript</code> 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" title="ServiceWorker">ServiceWorker</a>，所以逻辑层也称之为 App Service。</p> 
</blockquote> 
<blockquote> 
 <p>在 <code>JavaScript</code> 的基础上，我们增加了一些功能，以方便小程序的开发：</p> 
 <ul>
<li> <p>增加 <code>App</code> 和 <code>Page</code> 方法，进行<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html" title="程序注册">程序注册</a>和<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html" title="页面注册">页面注册</a>。</p> </li>
<li> <p>增加 <code>getApp</code> 和 <code>getCurrentPages</code> 方法，分别用来获取 <code>App</code> 实例和当前页面栈。</p> </li>
<li> <p>提供丰富的 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html" title="API">API</a>，如微信用户数据，扫一扫，支付等微信特有能力。</p> </li>
<li> <p>提供<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%A8%A1%E5%9D%97%E5%8C%96" title="模块化">模块化</a>能力，每个页面有独立的<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F" title="作用域">作用域</a>。</p> </li>
</ul>
 <p><strong>注意：小程序框架的逻辑层并非运行在浏览器中，因此 <code>JavaScript</code> 在 web 中一些能力都无法使用，如 <code>window</code>，<code>document</code> 等</strong></p> 
</blockquote> 
<h1 id="%E4%B8%80%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">一、小程序生命周期</h1> 
<blockquote> 
 <p>每个小程序都需要在 <code>app.js</code> 中调用 <code>App</code> 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。</p> 
 <p>详细的参数含义和使用请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html" title="App 参考文档">App 参考文档</a> </p> 
</blockquote> 
<pre><code class="language-javascript">// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})</code></pre> 
<blockquote> 
 <p>整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 <code>getApp</code> 方法获取到全局唯一的 App 实例，获取 App 上的数据或调用开发者注册在 <code>App</code> 上的函数。</p> 
</blockquote> 
<pre><code class="language-javascript">// xxx.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data</code></pre> 
<blockquote> 
 <p>前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。</p> 
 <p>只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p> 
 <p><strong>注意：</strong></p> 
 <p>1.不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。</p> 
 <p>2.不要在 onLaunch 的时候调用 getCurrentPage()，此时 page 还没有生成。</p> 
 <p>3.通过 getApp() 获取实例之后，不要私自调用生命周期函数。</p> 
</blockquote> 
<h1 id="%E4%BA%8C%E3%80%81%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2">二、注册页面</h1> 
<blockquote> 
 <p>对于小程序中的每个页面，都需要在页面对应的 <code>js</code> 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。</p> 
</blockquote> 
<h1 id="%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8Page%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20Page()%20%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0%E3%80%82">三、使用Page构造器注册页面简单的页面可以使用 <code style="font-size:16px;font-weight:normal">Page()</code><span style="background-color:#eef0f4;font-size:16px;font-weight:normal"> 进行构造。</span>
</h1> 
<pre><code class="language-javascript">//index.js
Page({
  data: {
    text: "This is page data."
  },
  onLoad: function(options) {
    // 页面创建时执行
  },
  onShow: function() {
    // 页面出现在前台时执行
  },
  onReady: function() {
    // 页面首次渲染完毕时执行
  },
  onHide: function() {
    // 页面从前台变为后台时执行
  },
  onUnload: function() {
    // 页面销毁时执行
  },
  onPullDownRefresh: function() {
    // 触发下拉刷新时执行
  },
  onReachBottom: function() {
    // 页面触底时执行
  },
  onShareAppMessage: function () {
    // 页面被用户分享时执行
  },
  onPageScroll: function() {
    // 页面滚动时执行
  },
  onResize: function() {
    // 页面尺寸变化时执行
  },
  onTabItemTap(item) {
    // tab 点击时执行
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  },
  // 事件响应函数
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    }, function() {
      // this is setData callback
    })
  },
  // 自由数据
  customData: {
    hi: 'MINA'
  }
})</code></pre> 
<h1 id="%E5%9B%9B%E3%80%81%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%20behaviors">四、在页面中使用 behaviors</h1> 
<blockquote> 
 <blockquote> 
  <p>基础库 2.9.2 开始支持，低版本需做<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="兼容处理">兼容处理</a>。</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <p>页面可以引用 behaviors 。 behaviors 可以用来让多个页面有相同的数据字段和方法。</p> 
</blockquote> 
<pre><code class="language-javascript">// my-behavior.js
module.exports = Behavior({
  data: {
    sharedText: 'This is a piece of data shared between pages.'
  },
  methods: {
    sharedMethod: function() {
      this.data.sharedText === 'This is a piece of data shared between pages.'
    }
  }
})
// page-a.js
var myBehavior = require('./my-behavior.js')
Page({
  behaviors: [myBehavior],
  onLoad: function() {
    this.data.sharedText === 'This is a piece of data shared between pages.'
  }
})</code></pre> 
<h1 id="%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8%20Component%20%E6%9E%84%E9%80%A0%E5%99%A8%E6%9E%84%E9%80%A0%E9%A1%B5%E9%9D%A2">五、使用 Component 构造器构造页面</h1> 
<blockquote> 
 <p>基础库 1.6.3 开始支持，低版本需做<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="兼容处理">兼容处理</a>。</p> 
</blockquote> 
<blockquote> 
 <p><code>Page</code> 构造器适用于简单的页面。但对于复杂的页面， <code>Page</code> 构造器可能并不好用。</p> 
 <p>此时，可以使用 <code>Component</code> 构造器来构造页面。 <code>Component</code> 构造器的主要区别是：方法需要放在 <code>methods: { }</code> 里面。</p> 
</blockquote> 
<pre><code class="language-javascript">Component({
  data: {
    text: "This is page data."
  },
  methods: {
    onLoad: function(options) {
      // 页面创建时执行
    },
    onPullDownRefresh: function() {
      // 下拉刷新时执行
    },
    // 事件响应函数
    viewTap: function() {
      // ...
    }
  }
})</code></pre> 
<blockquote> 
 <p>这种创建方式非常类似于 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/" title="自定义组件">自定义组件</a> ，可以像自定义组件一样使用 <code>behaviors</code> 等高级特性。</p> 
 <p>具体细节请阅读 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html" title="Component 构造器">Component 构造器</a> 章节。</p> 
</blockquote> 
<h1 id="%E5%85%AD%E3%80%81%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">六、页面的生命周期</h1> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/7e/67/wgDnVYLH_o.png"></p> 
<blockquote> 
 <p> </p> 
 <p>写微信小程序，他的生命周期不能不知道，不知道小程序就会出现各种bug而无法解决。</p> 
 <p>小程序由两大线程组成：负责界面的线程（view thread）和服务线程（appservice thread），各司其职由互相配合。</p> 
</blockquote> 
<h1 id="%E4%B8%83%E3%80%81%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1">七、页面路由</h1> 
<blockquote> 
 <p>在小程序中所有页面的路由全部由框架进行管理。</p> 
</blockquote> 
<h1 id="%E5%85%AB%E3%80%81%E9%A1%B5%E9%9D%A2%E6%A0%88">八、页面栈</h1> 
<p>框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：</p> 
<table>
<thead><tr>
<th>路由方式</th>
<th>页面栈表现</th>
</tr></thead>
<tbody>
<tr>
<td>初始化</td>
<td>新页面入栈</td>
</tr>
<tr>
<td>打开新页面</td>
<td>新页面入栈</td>
</tr>
<tr>
<td>页面重定向</td>
<td>当前页面出栈，新页面入栈</td>
</tr>
<tr>
<td>页面返回</td>
<td>页面不断出栈，直到目标返回页</td>
</tr>
<tr>
<td>Tab 切换</td>
<td>页面全部出栈，只留下新的 Tab 页面</td>
</tr>
<tr>
<td>重加载</td>
<td>页面全部出栈，只留下新的页面</td>
</tr>
</tbody>
</table>
<p>开发者可以使用 <code>getCurrentPages()</code> 函数获取当前页面栈。</p> 
<h1 id="%E4%B9%9D%E3%80%81%E8%B7%AF%E7%94%B1%E6%96%B9%E5%BC%8F">九、路由方式</h1> 
<p>对于路由的触发方式以及页面生命周期函数如下：</p> 
<table>
<thead><tr>
<th>路由方式</th>
<th>触发时机</th>
<th>路由前页面</th>
<th>路由后页面</th>
</tr></thead>
<tbody>
<tr>
<td>初始化</td>
<td>小程序打开的第一个页面</td>
<td></td>
<td>onLoad, onShow</td>
</tr>
<tr>
<td>打开新页面</td>
<td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html" title="wx.navigateTo">wx.navigateTo</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" title="``  ">``</a>
</td>
<td>onHide</td>
<td>onLoad, onShow</td>
</tr>
<tr>
<td>页面重定向</td>
<td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html" title="wx.redirectTo">wx.redirectTo</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" title="``  ">``</a>
</td>
<td>onUnload</td>
<td>onLoad, onShow</td>
</tr>
<tr>
<td>页面返回</td>
<td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html" title="wx.navigateBack">wx.navigateBack</a> 使用组件<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" title="``  ">``</a> 用户按左上角返回按钮</td>
<td>onUnload</td>
<td>onShow</td>
</tr>
<tr>
<td>Tab 切换</td>
<td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html" title="wx.switchTab">wx.switchTab</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" title="``  ">``</a> 用户切换 Tab</td>
<td></td>
<td>各种情况请参考下表</td>
</tr>
<tr>
<td>重启动</td>
<td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html" title="wx.reLaunch">wx.reLaunch</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" title="``  ">``</a>
</td>
<td>onUnload</td>
<td>onLoad, onShow</td>
</tr>
</tbody>
</table>
<p>Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：</p> 
<table>
<thead><tr>
<th>当前页面</th>
<th>路由后页面</th>
<th>触发的生命周期（按顺序）</th>
</tr></thead>
<tbody>
<tr>
<td>A</td>
<td>A</td>
<td>Nothing happend</td>
</tr>
<tr>
<td>A</td>
<td>B</td>
<td>A.onHide(), B.onLoad(), B.onShow(),B.onReady()</td>
</tr>
<tr>
<td>A</td>
<td>B（再次打开）</td>
<td>A.onHide(), B.onShow()</td>
</tr>
<tr>
<td>C</td>
<td>A</td>
<td>C.onUnload(), A.onShow()</td>
</tr>
<tr>
<td>C</td>
<td>B</td>
<td>C.onUnload(), B.onLoad(), B.onShow()</td>
</tr>
<tr>
<td>D</td>
<td>B</td>
<td>D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()</td>
</tr>
<tr>
<td>D（从转发进入）</td>
<td>A</td>
<td>D.onUnload(), A.onLoad(), A.onShow()</td>
</tr>
<tr>
<td>D（从转发进入）</td>
<td>B</td>
<td>D.onUnload(), B.onLoad(), B.onShow()</td>
</tr>
</tbody>
</table>
<h1 id="%E5%8D%81%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">十、注意事项</h1> 
<blockquote> 
 <ul>
<li> <p><code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</p> 
   <ul><li> <p>a--navigateTo--c, c--&gt;redirectTo--&gt;d</p> </li></ul>
</li>
<li> <p><code>switchTab</code> 只能打开 tabBar 页面。</p> </li>
<li> <p><code>reLaunch</code> 可以打开任意页面。</p> </li>
<li> <p>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</p> </li>
<li> <p>调用页面路由带的参数可以在目标页面的<code>onLoad</code>中获取。</p> </li>
</ul>
</blockquote> 
<h1 id="%E6%A8%A1%E5%9D%97%E5%8C%96"><span style="color:#fe2c24">模块化</span></h1> 
<h1 id="%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96">一、模块化</h1> 
<blockquote> 
 <p>可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html" title="module.exports">module.exports</a> 或者 <code>exports</code> 才能对外暴露接口。</p> 
</blockquote> 
<blockquote> 
 <p>注意：</p> 
 <ul>
<li> <p><code>exports</code> 是 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html" title="module.exports">module.exports</a> 的一个引用，因此在模块里边随意更改 <code>exports</code> 的指向会造成未知的错误。所以更推荐开发者采用 <code>module.exports</code> 来暴露模块接口，除非你已经清晰知道这两者的关系。</p> </li>
<li> <p>小程序目前不支持直接引入 <code>node_modules</code> , 开发者需要使用到 <code>node_modules</code> 时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html" title="npm">npm</a> 功能。</p> </li>
</ul>
</blockquote> 
<pre><code class="language-javascript">// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye</code></pre> 
<p>在需要使用这些模块的文件中，使用 <code>require</code> 将公共代码引入;也可以使用import导入</p> 
<pre><code class="language-javascript">var common = require('common.js')
Page({
  helloMINA: function() {
    common.sayHello('MINA')
  },
  goodbyeMINA: function() {
    common.sayGoodbye('MINA')
  }
})</code></pre> 
<h1 id="%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F">二、文件作用域</h1> 
<blockquote> 
 <p>在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。</p> 
 <p>通过全局函数 <code>getApp</code> 可以获取全局的应用实例，如果需要全局的数据可以在 <code>App()</code> 中设置，如</p> 
</blockquote> 
<pre><code class="language-javascript">// app.js
App({
  globalData: 1
})
// a.js
// The localValue can only be used in file a.js.
var localValue = 'a'
// Get the app instance.
var app = getApp()
// Get the global data and change it.
app.globalData++
// b.js
// You can redefine localValue in file b.js, without interference with the localValue in a.js.
var localValue = 'b'
// If a.js it run before b.js, now the globalData shoule be 2.
console.log(getApp().globalData)</code></pre> 
<h1 id="%E4%B8%89%E3%80%81API">三、API</h1> 
<blockquote> 
 <p>小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/index.html" title="API 文档">API 文档</a>。</p> 
</blockquote> 
<h3 id="%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%20API">事件监听 API</h3> 
<blockquote> 
 <p>我们约定，以 <code>on</code> 开头的 API 用来监听某个事件是否触发，如：<a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/websocket/wx.onSocketOpen.html" title="wx.onSocketOpen">wx.onSocketOpen</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/device/compass/wx.onCompassChange.html" title="wx.onCompassChange">wx.onCompassChange</a> 等。</p> 
 <p>这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入.</p> 
</blockquote> 
<pre><code class="language-javascript">wx.onCompassChange(function (res) {
  console.log(res.direction)
})</code></pre> 
<h3 id="%E5%90%8C%E6%AD%A5%20API">同步 API</h3> 
<blockquote> 
 <p>我们约定，以 <code>Sync</code> 结尾的 API 都是同步 API， 如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorageSync.html" title="wx.setStorageSync">wx.setStorageSync</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSystemInfoSync.html" title="wx.getSystemInfoSync">wx.getSystemInfoSync</a> 等。此外，也有一些其他的同步 API，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/worker/wx.createWorker.html" title="wx.createWorker">wx.createWorker</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html" title="wx.getBackgroundAudioManager">wx.getBackgroundAudioManager</a> 等，详情参见 API 文档中的说明。</p> 
 <p>同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。</p> 
</blockquote> 
<p></p> 
<pre><code class="language-javascript">try {
  wx.setStorageSync('key', 'value')
} catch (e) {
  console.error(e)
}</code></pre> 
<h3 id="%E5%BC%82%E6%AD%A5%20API">异步 API</h3> 
<blockquote> 
 <p>大多数 API 都是异步 API，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html" title="wx.request">wx.request</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html" title="wx.login">wx.login</a> 等。这类 API 接口通常都接受一个 <code>Object</code> 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：</p> 
</blockquote> 
<p><strong>Object 参数说明</strong></p> 
<table>
<thead><tr>
<th>参数名</th>
<th>类型</th>
<th>必填</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>success</td>
<td>function</td>
<td>否</td>
<td>接口调用成功的回调函数</td>
</tr>
<tr>
<td>fail</td>
<td>function</td>
<td>否</td>
<td>接口调用失败的回调函数</td>
</tr>
<tr>
<td>complete</td>
<td>function</td>
<td>否</td>
<td>接口调用结束的回调函数（调用成功、失败都会执行）</td>
</tr>
<tr>
<td>其他</td>
<td>Any</td>
<td>-</td>
<td>接口定义的其他参数</td>
</tr>
</tbody>
</table>
<p><strong>回调函数的参数</strong></p> 
<p><code>success</code>，<code>fail</code>，<code>complete</code> 函数调用时会传入一个 <code>Object</code> 类型参数，包含以下字段：</p> 
<table>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>errMsg</td>
<td>string</td>
<td>错误信息，如果调用成功返回 <code>${apiName}:ok</code>
</td>
</tr>
<tr>
<td>errCode</td>
<td>number</td>
<td>错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 <code>0</code>。</td>
</tr>
<tr>
<td>其他</td>
<td>Any</td>
<td>接口返回的其他数据</td>
</tr>
</tbody>
</table>
<blockquote> 
 <p>异步 API 的执行结果需要通过 <code>Object</code> 类型的参数中传入的对应回调函数获取。部分异步 API 也会有返回值，可以用来实现更丰富的功能，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html" title="wx.request">wx.request</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/websocket/wx.connectSocket.html" title="wx.connectSocket">wx.connectSocket</a> 等。</p> 
</blockquote> 
<pre><code class="language-javascript">wx.login({
  success(res) {
    console.log(res.code)
  }
})</code></pre> 
<h3 id="%E5%BC%82%E6%AD%A5%20API%20%E8%BF%94%E5%9B%9E%20Promise">异步 API 返回 Promise</h3> 
<blockquote> 
 <p>基础库 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="2.10.2">2.10.2</a> 版本起，异步 API 支持 callback &amp; promise 两种调用方式。当接口参数 Object 对象中不包含 success/fail/complete 时将默认返回 promise，否则仍按回调方式执行，无返回值。</p> 
</blockquote> 
<blockquote> 
 <p>注意事项</p> 
 <ol>
<li> <p>部分接口如 <code>downloadFile</code>, <code>request</code>, <code>uploadFile</code>, <code>connectSocket</code>, <code>createCamera</code>（小游戏）本身就有返回值， 它们的 promisify 需要开发者自行封装。</p> </li>
<li> <p>当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 <code>Uncaught (in promise)</code>，开发者可通过 catch 来进行捕获。</p> </li>
<li> <p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onUnhandledRejection.html" title="wx.onUnhandledRejection">wx.onUnhandledRejection</a> 可以监听未处理的 Promise 拒绝事件。</p> </li>
</ol>
</blockquote> 
<pre><code class="language-javascript">// callback 形式调用
wx.chooseImage({
  success(res) {
    console.log('res:', res)
  }
})

// promise 形式调用
wx.chooseImage().then(res =&gt; console.log('res: ', res))</code></pre> 
<h1 id="%E8%A7%86%E5%9B%BE%E5%B1%82%20View"><span style="color:#fe2c24">视图层 View</span></h1> 
<blockquote> 
 <p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。</p> 
 <p>将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。</p> 
 <p>WXML(WeiXin Markup language) 用于描述页面的结构。</p> 
 <p>WXS(WeiXin Script) 是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p> 
 <p>WXSS(WeiXin Style Sheet) 用于描述页面的样式。</p> 
 <p>组件(Component)是视图的基本组成单元.</p> 
</blockquote> 
<h1 id="%E4%B8%80%E3%80%81WXML">一、WXML</h1> 
<blockquote> 
 <p>WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合<a href="https://developers.weixin.qq.com/miniprogram/dev/component/" title="基础组件">基础组件</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html" title="事件系统">事件系统</a>，可以构建出页面的结构。</p> 
 <p>要完整了解 WXML 语法，请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/" title="WXML 语法参考">WXML 语法参考</a>.</p> 
</blockquote> 
<h3 id="%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">数据绑定</h3> 
<pre><code class="language-javascript">&lt;!--wxml--&gt;
&lt;view&gt; {<!-- -->{message}} &lt;/view&gt;
// page.js
Page({
  data: {
    message: 'Hello MINA!'
  }
})</code></pre> 
<h3 id="%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93">列表渲染</h3> 
<pre><code class="language-javascript">&lt;!--wxml--&gt;
&lt;view wx:for="{<!-- -->{array}}"&gt; {<!-- -->{item}} &lt;/view&gt;
// page.js
Page({
  data: {
    array: [1, 2, 3, 4, 5]
  }
})</code></pre> 
<h3 id="%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93">条件渲染</h3> 
<pre><code class="language-javascript">&lt;!--wxml--&gt;
&lt;view wx:if="{<!-- -->{view == 'WEBVIEW'}}"&gt; WEBVIEW &lt;/view&gt;
&lt;view wx:elif="{<!-- -->{view == 'APP'}}"&gt; APP &lt;/view&gt;
&lt;view wx:else="{<!-- -->{view == 'MINA'}}"&gt; MINA &lt;/view&gt;
// page.js
Page({
  data: {
    view: 'MINA'
  }
})</code></pre> 
<h3 id="%E6%A8%A1%E6%9D%BF">模板</h3> 
<pre><code class="language-javascript">&lt;!--wxml--&gt;
&lt;template name="staffName"&gt;
  &lt;view&gt;
    FirstName: {<!-- -->{firstName}}, LastName: {<!-- -->{lastName}}
  &lt;/view&gt;
&lt;/template&gt;

&lt;template is="staffName" data="{<!-- -->{...staffA}}"&gt;&lt;/template&gt;
&lt;template is="staffName" data="{<!-- -->{...staffB}}"&gt;&lt;/template&gt;
&lt;template is="staffName" data="{<!-- -->{...staffC}}"&gt;&lt;/template&gt;
// page.js
Page({
  data: {
    staffA: {firstName: 'Hulk', lastName: 'Hu'},
    staffB: {firstName: 'Shang', lastName: 'You'},
    staffC: {firstName: 'Gideon', lastName: 'Lin'}
  }
})</code></pre> 
<blockquote> 
 <p>具体的能力以及使用方式在以下章节查看：</p> 
 <p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/data.html" title="数据绑定">数据绑定</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html" title="列表渲染">列表渲染</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html" title="条件渲染">条件渲染</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/template.html" title="模板">模板</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/import.html" title="引用">引用</a></p> 
</blockquote> 
<h2 id="WXSS">WXSS</h2> 
<blockquote> 
 <p>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。</p> 
 <p>WXSS 用来决定 WXML 的组件应该怎么显示。</p> 
 <p>为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。</p> 
 <p>与 CSS 相比，WXSS 扩展的特性有：</p> 
 <ul>
<li> <p>尺寸单位</p> </li>
<li> <p>样式导入</p> </li>
</ul>
</blockquote> 
<h3 id="%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D">尺寸单位</h3> 
<blockquote> 
 <p>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p> 
</blockquote> 
<table>
<thead><tr>
<th>设备</th>
<th>rpx换算px (屏幕宽度/750)</th>
<th>px换算rpx (750/屏幕宽度)</th>
</tr></thead>
<tbody>
<tr>
<td>iPhone5</td>
<td>1rpx = 0.42px</td>
<td>1px = 2.34rpx</td>
</tr>
<tr>
<td>iPhone6</td>
<td>1rpx = 0.5px</td>
<td>1px = 2rpx</td>
</tr>
<tr>
<td>iPhone6 Plus</td>
<td>1rpx = 0.552px</td>
<td>1px = 1.81rpx</td>
</tr>
</tbody>
</table>
<blockquote> 
 <p><strong>建议：</strong> 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。</p> 
 <p><strong>注意：</strong> 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p> 
</blockquote> 
<h3 id="%E6%A0%B7%E5%BC%8F%E5%AF%BC%E5%85%A5">样式导入</h3> 
<blockquote> 
 <p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束。</p> 
</blockquote> 
<pre><code class="language-javascript">/** common.wxss **/
.small-p {
  padding:5px;
}
/** app.wxss **/
@import "common.wxss";
.middle-p {
  padding:15px;
}</code></pre> 
<h3 id="%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F">内联样式</h3> 
<blockquote> 
 <p>框架组件上支持使用 style、class 属性来控制组件的样式。</p> 
 <ul><li> <p>style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。</p> </li></ul>
 <pre>&lt;view style="color:{<!-- -->{color}};" /&gt;</pre> 
 <ul>
<li> <p>class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上<code>.</code>，样式类名之间用空格分隔。</p> </li>
<li> <p>&lt;view class="normal_view" /&gt;</p> </li>
</ul>
</blockquote> 
<h3 id="%E9%80%89%E6%8B%A9%E5%99%A8">选择器</h3> 
<p>目前支持的选择器有：</p> 
<table>
<thead><tr>
<th>选择器</th>
<th>样例</th>
<th>样例描述</th>
</tr></thead>
<tbody>
<tr>
<td>.class</td>
<td><code>.intro</code></td>
<td>选择所有拥有 class="intro" 的组件</td>
</tr>
<tr>
<td>#id</td>
<td><code>#firstname</code></td>
<td>选择拥有 id="firstname" 的组件</td>
</tr>
<tr>
<td>element</td>
<td><code>view</code></td>
<td>选择所有 view 组件</td>
</tr>
<tr>
<td>element, element</td>
<td><code>view, checkbox</code></td>
<td>选择所有文档的 view 组件和所有的 checkbox 组件</td>
</tr>
<tr>
<td>::after</td>
<td><code>view::after</code></td>
<td>在 view 组件后边插入内容</td>
</tr>
<tr>
<td>::before</td>
<td><code>view::before</code></td>
<td>在 view 组件前边插入内容</td>
</tr>
</tbody>
</table>
<h3 id="%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F">全局样式与局部样式</h3> 
<blockquote> 
 <p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。</p> 
</blockquote> 
<h2 id="WXS">WXS</h2> 
<blockquote> 
 <p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p> 
</blockquote> 
<h3 id="%E7%A4%BA%E4%BE%8B">示例</h3> 
<ul><li> <p>新建一个wxs文件</p> </li></ul>
<pre><code class="language-javascript">var toDecimal2 = function (x) {
    var f = parseFloat(x);
    if (isNaN(f)) {
      return '0.00'
    }
    var f = Math.round(x * 100) / 100;
    var s = f.toString();
    var rs = s.indexOf('.');
    if (rs &lt; 0) {
      rs = s.length;
      s += '.';
    }
    while (s.length &lt;= rs + 2) {
      s += '0';
    }
    return s;
  }
  //module.exports = toDecimal2
module.exports = {
    toDecimal2:toDecimal2
}</code></pre> 
<pre> </pre> 
<ul><li> <p>在wxml中使用</p> </li></ul>
<pre><code class="language-javascript">&lt;!--pages/c/c.wxml--&gt;
&lt;wxs src="../../wxs/PageUtils.wxs" module="PageUtils"&gt;&lt;/wxs&gt;
&lt;wxs module="m1"&gt;
var msg = "hello world";
​
module.exports.message = msg;
&lt;/wxs&gt;
&lt;view&gt;
    &lt;text&gt;pages/c/c.wxml,&lt;/text&gt;
    &lt;text&gt;{<!-- -->{m1.message}}&lt;/text&gt;
    &lt;view&gt;
        &lt;text&gt;{<!-- -->{PageUtils.toDecimal2(123.453)}}&lt;/text&gt;
    &lt;/view&gt;
    &lt;view&gt;
        &lt;button type="primary" bindtap="jump"&gt;跳转到D页面&lt;/button&gt;
    &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<h3 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</h3> 
<blockquote> 
 <ol>
<li> <p>WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。</p> </li>
<li> <p>WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。</p> </li>
<li> <p>WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。</p> </li>
<li> <p>WXS 函数不能作为组件的事件回调。</p> </li>
<li> <p>由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。</p> </li>
</ol>
</blockquote> 
<p>以下是一些使用 WXS 的简单示例，要完整了解 WXS 语法，请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/" title="WXS 语法参考">WXS 语法参考</a>。</p> 
<h3 id="%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93">页面渲染</h3> 
<pre><code class="language-javascript">&lt;!--wxml--&gt;
&lt;wxs module="m1"&gt;
var msg = "hello world";
​
module.exports.message = msg;
&lt;/wxs&gt;
​
&lt;view&gt; {<!-- -->{m1.message}} &lt;/view&gt;</code></pre> 
<p>页面输出：</p> 
<blockquote> 
 <pre>hello world</pre> 
</blockquote> 
<h3 id="%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">数据处理</h3> 
<pre><code class="language-javascript">// page.js
Page({
  data: {
    array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
  }
})
&lt;!--wxml--&gt;
&lt;!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 --&gt;
&lt;wxs module="m1"&gt;
var getMax = function(array) {
  var max = undefined;
  for (var i = 0; i &lt; array.length; ++i) {
    max = max === undefined ?
      array[i] :
      (max &gt;= array[i] ? max : array[i]);
  }
  return max;
}

module.exports.getMax = getMax;
&lt;/wxs&gt;

&lt;!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array --&gt;
&lt;view&gt; {<!-- -->{m1.getMax(array)}} &lt;/view&gt;</code></pre> 
<p>页面输出：</p> 
<blockquote> 
 <pre>5</pre> 
</blockquote> 
<h1 id="%E4%BA%8B%E4%BB%B6">事件</h1> 
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6">什么是事件</h2> 
<blockquote> 
 <ul>
<li> <p>事件是视图层到逻辑层的通讯方式。</p> </li>
<li> <p>事件可以将用户的行为反馈到逻辑层进行处理。</p> </li>
<li> <p>事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。</p> </li>
<li> <p>事件对象可以携带额外信息，如 id, dataset, touches。</p> </li>
</ul>
</blockquote> 
<h2 id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">事件的使用方式</h2> 
<blockquote> 
 <ul><li> <p>在组件中绑定一个事件处理函数。</p> </li></ul>
 <p>如<code>bindtap</code>，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。</p> 
 <pre>&lt;view id="tapTest" data-hi="Weixin" bindtap="tapName"&gt; Click me! &lt;/view&gt;</pre> 
</blockquote> 
<ul><li> <p>在相应的 Page 定义中写上相应的事件处理函数，参数是event。</p> </li></ul>
<pre><code class="language-javascript">Page({
  tapName: function(event) {
    console.log(event)
  }
})</code></pre> 
<ul><li> <p>可以看到 log 出来的信息大致如下：</p> </li></ul>
<pre><code class="language-javascript">{
  "type":"tap",
  "timeStamp":895,
  "target": {
    "id": "tapTest",
    "dataset":  {
      "hi":"Weixin"
    }
  },
  "currentTarget":  {
    "id": "tapTest",
    "dataset": {
      "hi":"Weixin"
    }
  },
  "detail": {
    "x":53,
    "y":14
  },
  "touches":[{
    "identifier":0,
    "pageX":53,
    "pageY":14,
    "clientX":53,
    "clientY":14
  }],
  "changedTouches":[{
    "identifier":0,
    "pageX":53,
    "pageY":14,
    "clientX":53,
    "clientY":14
  }]
}</code></pre> 
<h2 id="%E4%BD%BF%E7%94%A8%20WXS%20%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6">使用 WXS 函数响应事件</h2> 
<blockquote> 
 <p>基础库 2.4.4 开始支持，低版本需做<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="兼容处理">兼容处理</a>。</p> 
</blockquote> 
<blockquote> 
 <p>从基础库版本<code>2.4.4</code>开始，支持使用 WXS 函数绑定事件，WXS函数接受2个参数，第一个是event，在原有的 event 的基础上加了<code>event.instance</code>对象，第二个参数是<code>ownerInstance</code>，和<code>event.instance</code>一样是一个<code>ComponentDescriptor</code>对象。具体使用如下：</p> 
</blockquote> 
<ul><li> <p>在组件中绑定和注册事件处理的 WXS 函数。</p> </li></ul>
<blockquote> 
 <pre>&lt;wxs module="wxs" src="./test.wxs"&gt;&lt;/wxs&gt;
&lt;view id="tapTest" data-hi="Weixin" bindtap="{<!-- -->{wxs.tapName}}"&gt; Click me! &lt;/view&gt;
**注：绑定的 WXS 函数必须用{<!-- -->{}}括起来**</pre> 
</blockquote> 
<ul><li> <p>test.wxs文件实现 tapName 函数</p> </li></ul>
<pre><code class="language-javascript">function tapName(event, ownerInstance) {
  console.log('tap Weixin', JSON.stringify(event))
}
module.exports = {
  tapName: tapName
}</code></pre> 
<blockquote> 
 <p><code>ownerInstance</code>包含了一些方法，可以设置组件的样式和class，具体包含的方法以及为什么要用 WXS 函数响应事件，请<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html" title="点击查看详情">点击查看详情</a>。</p> 
</blockquote> 
<h2 id="%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3">事件详解</h2> 
<h3 id="%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB">事件分类</h3> 
<blockquote> 
 <p>事件分为冒泡事件和非冒泡事件：</p> 
 <ol>
<li> <p>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</p> </li>
<li> <p>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</p> </li>
</ol>
</blockquote> 
<p>WXML的冒泡事件列表：</p> 
<table>
<thead><tr>
<th>类型</th>
<th>触发条件</th>
<th>最低版本</th>
</tr></thead>
<tbody>
<tr>
<td>touchstart</td>
<td>手指触摸动作开始</td>
<td></td>
</tr>
<tr>
<td>touchmove</td>
<td>手指触摸后移动</td>
<td></td>
</tr>
<tr>
<td>touchcancel</td>
<td>手指触摸动作被打断，如来电提醒，弹窗</td>
<td></td>
</tr>
<tr>
<td>touchend</td>
<td>手指触摸动作结束</td>
<td></td>
</tr>
<tr>
<td>tap</td>
<td>手指触摸后马上离开</td>
<td></td>
</tr>
<tr>
<td>longpress</td>
<td>手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="1.5.0">1.5.0</a></td>
</tr>
<tr>
<td>longtap</td>
<td>手指触摸后，超过350ms再离开（推荐使用 longpress 事件代替）</td>
<td></td>
</tr>
<tr>
<td>transitionend</td>
<td>会在 WXSS transition 或 wx.createAnimation 动画结束后触发</td>
<td></td>
</tr>
<tr>
<td>animationstart</td>
<td>会在一个 WXSS animation 动画开始时触发</td>
<td></td>
</tr>
<tr>
<td>animationiteration</td>
<td>会在一个 WXSS animation 一次迭代结束时触发</td>
<td></td>
</tr>
<tr>
<td>animationend</td>
<td>会在一个 WXSS animation 动画完成时触发</td>
<td></td>
</tr>
<tr>
<td>touchforcechange</td>
<td>在支持 3D Touch 的 iPhone 设备，重按时会触发</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="1.9.90">1.9.90</a></td>
</tr>
</tbody>
</table>
<blockquote> 
 <p><strong>注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/form.html" title="form">form</a> 的<code>submit</code>事件，<a href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html" title="input">input</a> 的<code>input</code>事件，<a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html" title="scroll-view">scroll-view</a> 的<code>scroll</code>事件，(详见各个<a href="https://developers.weixin.qq.com/miniprogram/dev/component/" title="组件">组件</a>)</strong></p> 
</blockquote> 
<h3 id="%E6%99%AE%E9%80%9A%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A">普通事件绑定</h3> 
<blockquote> 
 <p>事件绑定的写法类似于组件的属性，如：</p> 
</blockquote> 
<blockquote> 
 <pre>&lt;view bindtap="handleTap"&gt;
    Click here!
&lt;/view&gt;</pre> 
</blockquote> 
<blockquote> 
 <p>如果用户点击这个 view ，则页面的 <code>handleTap</code> 会被调用。</p> 
 <p>事件绑定函数可以是一个数据绑定，如：</p> 
</blockquote> 
<blockquote> 
 <pre>&lt;view bindtap="{<!-- -->{ handlerName }}"&gt;
    Click here!
&lt;/view&gt;</pre> 
</blockquote> 
<blockquote> 
 <p>此时，页面的 <code>this.data.handlerName</code> 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。</p> 
 <p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="1.5.0">1.5.0</a> 起，在大多数组件和自定义组件中， <code>bind</code> 后可以紧跟一个冒号，其含义不变，如 <code>bind:tap</code> 。基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="2.8.1">2.8.1</a> 起，在所有组件中开始提供这个支持。</p> 
</blockquote> 
<h3 id="%E7%BB%91%E5%AE%9A%E5%B9%B6%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1">绑定并阻止事件冒泡</h3> 
<blockquote> 
 <p>除 <code>bind</code> 外，也可以用 <code>catch</code> 来绑定事件。与 <code>bind</code> 不同， <code>catch</code> 会阻止事件向上冒泡。</p> 
 <p>例如在下边这个例子中，点击 inner view 会先后调用<code>handleTap3</code>和<code>handleTap2</code>(因为 tap 事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发<code>handleTap2</code>，点击 outer view 会触发<code>handleTap1</code>。</p> 
</blockquote> 
<pre><code class="language-javascript">&lt;view id="outer" bindtap="handleTap1"&gt;
  outer view
  &lt;view id="middle" catchtap="handleTap2"&gt;
    middle view
    &lt;view id="inner" bindtap="handleTap3"&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<h3 id="%E4%BA%92%E6%96%A5%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A">互斥事件绑定</h3> 
<blockquote> 
 <p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="2.8.2">2.8.2</a> 起，除 <code>bind</code> 和 <code>catch</code> 外，还可以使用 <code>mut-bind</code> 来绑定事件。一个 <code>mut-bind</code> 触发后，如果事件冒泡到其他节点上，其他节点上的 <code>mut-bind</code> 绑定函数不会被触发，但 <code>bind</code> 绑定函数和 <code>catch</code> 绑定函数依旧会被触发。</p> 
 <p>换而言之，所有 <code>mut-bind</code> 是“互斥”的，只会有其中一个绑定函数被触发。同时，它完全不影响 <code>bind</code> 和 <code>catch</code> 的绑定效果。</p> 
</blockquote> 
<blockquote> 
 <p>例如在下边这个例子中，点击 inner view 会先后调用 <code>handleTap3</code> 和 <code>handleTap2</code> ，点击 middle view 会调用 <code>handleTap2</code> 和 <code>handleTap1</code> 。</p> 
</blockquote> 
<pre><code class="language-javascript">&lt;view id="outer" mut-bind:tap="handleTap1"&gt;
  outer view
  &lt;view id="middle" bindtap="handleTap2"&gt;
    middle view
    &lt;view id="inner" mut-bind:tap="handleTap3"&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<h3 id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5">事件的捕获阶段</h3> 
<blockquote> 
 <p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="1.5.0">1.5.0</a> 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用<code>capture-bind</code>、<code>capture-catch</code>关键字，后者将中断捕获阶段和取消冒泡阶段。</p> 
</blockquote> 
<p>在下面的代码中，点击 inner view 会先后调用<code>handleTap2</code>、<code>handleTap4</code>、<code>handleTap3</code>、<code>handleTap1</code>。</p> 
<pre><code class="language-javascript">&lt;view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2"&gt;
  outer view
  &lt;view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4"&gt;
    inner view
  &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<p>如果将上面代码中的第一个<code>capture-bind</code>改为<code>capture-catch</code>，将只触发<code>handleTap2</code>。</p> 
<pre><code class="language-javascript">&lt;view id="outer" bind:touchstart="handleTap1" capture-catch:touchstart="handleTap2"&gt;
  outer view
  &lt;view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4"&gt;
    inner view
  &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<h3 id="%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1">事件对象</h3> 
<p>如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p> 
<p><strong>BaseEvent 基础事件对象属性列表：</strong></p> 
<table>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
<th>基础库版本</th>
</tr></thead>
<tbody>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#type" title="type">type</a></td>
<td>String</td>
<td>事件类型</td>
<td></td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#timeStamp" title="timeStamp">timeStamp</a></td>
<td>Integer</td>
<td>事件生成时的时间戳</td>
<td></td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#target" title="target">target</a></td>
<td>Object</td>
<td>触发事件的组件的一些属性值集合</td>
<td></td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#currenttarget" title="currentTarget">currentTarget</a></td>
<td>Object</td>
<td>当前组件的一些属性值集合</td>
<td></td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#mark" title="mark">mark</a></td>
<td>Object</td>
<td>事件标记数据</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="2.7.1">2.7.1</a></td>
</tr>
</tbody>
</table>
<p><strong>CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：</strong></p> 
<table>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr></thead>
<tbody><tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#detail" title="detail">detail</a></td>
<td>Object</td>
<td>额外的信息</td>
</tr></tbody>
</table>
<p><strong>TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：</strong></p> 
<table>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#touches" title="touches">touches</a></td>
<td>Array</td>
<td>触摸事件，当前停留在屏幕中的触摸点信息的数组</td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#changedTouches" title="changedTouches">changedTouches</a></td>
<td>Array</td>
<td>触摸事件，当前变化的触摸点信息的数组</td>
</tr>
</tbody>
</table>
<p><strong>特殊事件： <a href="https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html" title="canvas">canvas</a> 中的触摸事件不可冒泡，所以没有 currentTarget。</strong></p> 
<h3 id="type">type</h3> 
<p>代表事件的类型。</p> 
<h3 id="timeStamp">timeStamp</h3> 
<p>页面打开到触发事件所经过的毫秒数。</p> 
<h3 id="target">target</h3> 
<p>触发事件的源组件。</p> 
<table>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>id</td>
<td>String</td>
<td>事件源组件的id</td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset" title="dataset">dataset</a></td>
<td>Object</td>
<td>事件源组件上由<code>data-</code>开头的自定义属性组成的集合</td>
</tr>
</tbody>
</table>
<h3 id="currentTarget">currentTarget</h3> 
<p>事件绑定的当前组件。</p> 
<table>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>id</td>
<td>String</td>
<td>当前组件的id</td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset" title="dataset">dataset</a></td>
<td>Object</td>
<td>当前组件上由<code>data-</code>开头的自定义属性组成的集合</td>
</tr>
</tbody>
</table>
<blockquote> 
 <p><strong>说明： target 和 currentTarget 可以参考上例中，点击 inner view 时，<code>handleTap3</code> 收到的事件对象 target 和 currentTarget 都是 inner，而 <code>handleTap2</code> 收到的事件对象 target 就是 inner，currentTarget 就是 middle。</strong></p> 
</blockquote> 
<h3 id="dataset">dataset</h3> 
<blockquote> 
 <p>在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。</p> 
</blockquote> 
<p>在 WXML 中，这些自定义数据以 <code>data-</code> 开头，多个单词由连字符 <code>-</code> 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：</p> 
<ul>
<li> <p><code>data-element-type</code> ，最终会呈现为 <code>event.currentTarget.dataset.elementType</code> ；</p> </li>
<li> <p><code>data-elementType</code> ，最终会呈现为 <code>event.currentTarget.dataset.elementtype</code> 。</p> </li>
</ul>
<p><strong>示例：</strong></p> 
<pre><code class="language-javascript">&lt;view data-alpha-beta="1" data-alphaBeta="2" bindtap="bindViewTap"&gt; DataSet Test &lt;/view&gt;
Page({
  bindViewTap:function(event){
    event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法
    event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写
  }
})</code></pre> 
<h3 id="mark">mark</h3> 
<blockquote> 
 <p>在基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" title="2.7.1">2.7.1</a> 以上，可以使用 <code>mark</code> 来识别具体触发事件的 target 节点。此外， <code>mark</code> 还可以用于承载一些自定义数据（类似于 <code>dataset</code> ）。</p> 
</blockquote> 
<blockquote> 
 <p>当事件触发时，事件冒泡路径上所有的 <code>mark</code> 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 <code>mark</code> 。）</p> 
</blockquote> 
<p><strong>代码示例：</strong></p> 
<p><a href="https://developers.weixin.qq.com/s/7LwTKvmi7woT" title="在开发者工具中预览效果">在开发者工具中预览效果</a></p> 
<pre><code class="language-javascript">&lt;view mark:myMark="last" bindtap="bindViewTap"&gt;
  &lt;button mark:anotherMark="leaf" bindtap="bindButtonTap"&gt;按钮&lt;/button&gt;
&lt;/view&gt;</code></pre> 
<blockquote> 
 <p>在上述 WXML 中，如果按钮被点击，将触发 <code>bindViewTap</code> 和 <code>bindButtonTap</code> 两个事件，事件携带的 <code>event.mark</code> 将包含 <code>myMark</code> 和 <code>anotherMark</code> 两项。</p> 
</blockquote> 
<pre><code class="language-javascript">Page({
  bindViewTap: function(e) {
    e.mark.myMark === "last" // true
    e.mark.anotherMark === "leaf" // true
  }
})</code></pre> 
<blockquote> 
 <p><code>mark</code> 和 <code>dataset</code> 很相似，主要区别在于： <code>mark</code> 会包含从触发事件的节点到根节点上所有的 <code>mark:</code> 属性值；而 <code>dataset</code> 仅包含一个节点的 <code>data-</code> 属性值。</p> 
 <p>细节注意事项：</p> 
 <ul>
<li> <p>如果存在同名的 <code>mark</code> ，父节点的 <code>mark</code> 会被子节点覆盖。</p> </li>
<li> <p>在自定义组件中接收事件时， <code>mark</code> 不包含自定义组件外的节点的 <code>mark</code> 。</p> </li>
<li> <p>不同于 <code>dataset</code> ，节点的 <code>mark</code> 不会做连字符和大小写转换。</p> </li>
</ul>
</blockquote> 
<h3 id="touches">touches</h3> 
<blockquote> 
 <p>touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。</p> 
</blockquote> 
<p>Touch 对象</p> 
<table>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>identifier</td>
<td>Number</td>
<td>触摸点的标识符</td>
</tr>
<tr>
<td>pageX, pageY</td>
<td>Number</td>
<td>距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴</td>
</tr>
<tr>
<td>clientX, clientY</td>
<td>Number</td>
<td>距离页面可显示区域（屏幕除去导航条）左上角距离，横向为 X 轴，纵向为 Y 轴</td>
</tr>
</tbody>
</table>
<p>CanvasTouch 对象</p> 
<table>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
<th>特殊说明</th>
</tr></thead>
<tbody>
<tr>
<td>identifier</td>
<td>Number</td>
<td>触摸点的标识符</td>
<td></td>
</tr>
<tr>
<td>x, y</td>
<td>Number</td>
<td>距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为 X 轴，纵向为 Y 轴</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="changedTouches">changedTouches</h3> 
<blockquote> 
 <p>changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。</p> 
</blockquote> 
<h3 id="detail">detail</h3> 
<blockquote> 
 <p>自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见<a href="https://developers.weixin.qq.com/miniprogram/dev/component" title="组件">组件</a>定义中各个事件的定义。</p> 
 <p>点击事件的<code>detail</code> 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。</p> 
</blockquote> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>