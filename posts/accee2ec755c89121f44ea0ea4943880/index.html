<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C语言】深度理解指针（中） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】深度理解指针（中）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <div class="kdocs-document">
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0"><h2>前言✈</h2></li></ol>
 <p style="text-indent:1.4em">上回说到，我们学习了一些与指针相关的数据类型，如指针数组，数组指针，函数指针等等，我们还学习了转移表的基本概念，学会了如何利用转移表来实现一个简易计算器。详情请点击传送门：<a class="kdocs-link" style="color:#0A6CFF" href="http://t.csdn.cn/Okb35" target="_blank" rel="noopener noreferrer">【C语言】深度理解指针（上）</a></p>
 <blockquote class="kdocs-blockquote">
  本期我们将继续指针的话题，学习有关回调函数的相关内容，以及分析一些与指针相关的常见笔试题。
  <br>事不宜迟，让我们进入今天的第一个主题----回调函数。
 </blockquote>
 <h2>2. 回调函数?</h2>
 <h3 style="text-indent:1.4em">2.1 定义</h3>
 <p style="text-indent:1.4em">首先，回调函数是什么意思呢？?</p>
 <blockquote class="kdocs-blockquote">
  <span class="kdocs-color" style="color:#DA326B">回调函数</span>就是一个
  <span class="kdocs-color" style="background-color:#FBF5B3">通过函数指针调用的函数</span>。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
  <span class="kdocs-color" style="background-color:#FBF5B3">回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的</span>，用于对该事件或条件进行响应。
 </blockquote>
 <h3 style="text-indent:1.4em">2.2 qsort函数</h3>
 <p style="text-indent:1.4em">在<span class="kdocs-color" style="color:#DA326B">stdlib.h头文件</span>中有个函数叫qsort，它的用途是用来进行快速排序。它有个特点，就是我们通过它<span class="kdocs-color" style="background-color:#FBF5B3">可以排序任何类型的数据</span>，这便是使用了回调函数的思想，我们来看看它的函数原型：</p>
 <div class="kdocs-line-container">
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:1415px;justify-content:center;align-items:center;height:auto">
   <div class="kdocs-img" style="padding-top:37.102474%;height:0">
    <img src="https://images2.imgbox.com/ac/81/UwqeanxP_o.png" style="margin-left:;width:1415px;margin-top:-37.102474%;height:auto">
   </div>
  </div>
 </div>
 <div>
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1"><tbody>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:121px;vertical-align:middle;height:51px"><p style="text-align:center">参数</p></td>
<td class="kdocs-tableCell" style="width:608px;vertical-align:top;height:51px"><p style="text-align:center">作用</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:121px;vertical-align:middle;height:51px"><p style="text-align:center">base</p></td>
<td class="kdocs-tableCell" style="width:608px;vertical-align:top;height:51px"><p>用于接收需要排序数组的首元素地址，由于不知道传入类型，类型为void*</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:121px;vertical-align:middle;height:51px"><p style="text-align:center">num</p></td>
<td class="kdocs-tableCell" style="width:608px;vertical-align:top;height:51px"><p>表示数组共有几个元素，用于确定循环的次数</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:121px;vertical-align:middle;height:51px"><p style="text-align:center">width</p></td>
<td class="kdocs-tableCell" style="width:608px;vertical-align:top;height:51px"><p>表示数组每个元素所占的字节数，用于确定指针移动的步长，指向相应元素进行比较</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:121px;vertical-align:middle;height:51px"><p style="text-align:center">compare</p></td>
<td class="kdocs-tableCell" style="width:608px;vertical-align:top;height:51px"><p>函数指针，即回调函数。指向用户外部设计的比较函数，调用函数对数组元素进行比较，然后排序。</p></td>
</tr>
</tbody></table>
 </div>
 <blockquote class="kdocs-blockquote">
  在使用qsort时，
  <span class="kdocs-color" style="background-color:#FBF5B3">我们用户只需要设计compare指向的回调函数即可</span>。由于用户知道要排序什么类型的数据，因此可以设计对应的比较函数以供qsort函数内部进行回调。这就是为什么qsort可以排序任意类型数据的原因。其关系如下：
 </blockquote>
 <div class="kdocs-line-container">
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:1222px;justify-content:center;align-items:center;height:auto">
   <div class="kdocs-img" style="padding-top:42.22586%;height:0">
    <img src="https://images2.imgbox.com/7b/7a/t0UvRkTL_o.png" style="margin-left:;width:1222px;margin-top:-42.22586%;height:auto">
   </div>
  </div>
 </div>
 <p></p>
 <p>例如，我们可以使用它排序整形数据：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
//递增
int cmp_int1(const void* p1, const void* p2) //比较函数，参数要与qsort中的函数指针指向函数类型一致
{
    return *((int*)p1) - *((int*)p2);   //p1大于p2,返回正数，小于返回负数，等于返回0
}
int main()
{
    int arr[10] = { 8,5,4,6,4,7,8,1,9,4 };
    int sz = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, sz, sizeof(arr[0]), cmp_int1);
    //打印
    for (int i = 0; i &lt; sz; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}</code></pre>
 <div class="kdocs-line-container">
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:1091px;justify-content:center;align-items:center;height:auto">
   <div class="kdocs-img" style="padding-top:21.72319%;height:0">
    <img src="https://images2.imgbox.com/00/8d/Gn777ZW1_o.png" style="margin-left:;width:1091px;margin-top:-21.72319%;height:auto">
   </div>
  </div>
 </div>
 <p>这是升序排列，那么如果我们需要进行<span class="kdocs-color" style="color:#DA326B">降序排序</span>呢？很简单，<span class="kdocs-color" style="background-color:#FBF5B3">将p1与p2对调</span>即可(这是因为qsort当回调函数返回正数时会进行操作)：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">//递减
int cmp_int2(const void* p1, const void* p2) //比较函数，参数要与qsort中的函数指针指向函数类型一致
{
    return *((int*)p2) - *((int*)p1);   //p1小于p2,返回正数，小于返回负数，等于返回0
}</code></pre>
 <div class="kdocs-line-container">
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:1113px;justify-content:center;align-items:center;height:auto">
   <div class="kdocs-img" style="padding-top:16.981133%;height:0">
    <img src="https://images2.imgbox.com/3c/f5/Y43AyBZJ_o.png" style="margin-left:;width:1113px;margin-top:-16.981133%;height:auto">
   </div>
  </div>
 </div>
 <p>我们还可以使用qsort来排序一个<span class="kdocs-color" style="color:#DA326B">结构体</span>（按照姓名升序排列）：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
struct student
{
    char name[20];
    int age;
};
int cmp_name(const void* p1, const void* p2)//对结构体中的姓名进行排序
{
    //字符串的比较用strcmp，strcmp相等返回0，大于返回1，小于返回-1，与设定的返回值相对应
    return strcmp(((struct student*)p1)-&gt;name, ((struct student*)p2)-&gt;name);
}
int main()
{
    struct student arr[3] = { {"zhangsan",16},{"lisi",14},{"lihau",18} };
    int sz = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, sz, sizeof(arr[0]), cmp_name);
    //打印
    for (int i = 0; i &lt; sz; i++)
    {
        printf("%s %dn", arr[i].name, arr[i].age);
    }
    return 0;
}</code></pre>
 <div class="kdocs-line-container">
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:1213px;justify-content:center;align-items:center;height:auto">
   <div class="kdocs-img" style="padding-top:18.961254%;height:0">
    <img src="https://images2.imgbox.com/5d/d0/BsaUQDm6_o.png" style="margin-left:;width:1213px;margin-top:-18.961254%;height:auto">
   </div>
  </div>
 </div>
 <hr>
 <h3>2.3 回调函数的应用</h3>
 <p style="text-indent:1.4em">学习了qsort是如何借助<span class="kdocs-color" style="color:#DA326B">回调函数</span>来实现排序任意类型的数据，我们是不是可以模拟qsort来实现我们曾经写过的<span class="kdocs-color" style="background-color:#FBF5B3">冒泡排序函数</span>，使得这个冒泡排序函数可以排序<span class="kdocs-color" style="color:#DA326B">任意类型</span>的数据。下面，我们<span class="kdocs-color" style="color:#DA326B">逐步分析</span>如何实现这样的一个代码：</p>
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0"><p>由于排序的数组类型不固定，因此我们第一个参数采用<span class="kdocs-color" style="color:#DA326B">void*类型的指针</span>接收（<span class="kdocs-color" style="background-color:#FBF5B3">void*类型的指针被称为万能指针，可以接收任意类型的指针</span>）第二个参数与第三个参数分别是<span class="kdocs-color" style="color:#DA326B">数组元素个数</span>和<span class="kdocs-color" style="color:#DA326B">每个元素的大小</span>，最后一个参数即为<span class="kdocs-color" style="color:#DA326B">函数指针</span>，指向回调函数。</p></li></ul>
 <pre class="kdocs-cpp"><code class="language-cpp">//冒泡排序，模拟qsort的思想
void my_bubble_sort(void* arr, size_t sz, size_t k, int (*cmp)(const void*, const void*))
{
    //实现
}</code></pre>
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0"><p>接下来我们来实现冒泡排序算法，由于我们不知道数组元素的类型，因此<span class="kdocs-color" style="background-color:#FBF5B3">不能直接通过下标来定位某个元素</span>，那要怎么办呢？这里最巧妙的点来了，我们知道<span class="kdocs-color" style="background-color:#FBF5B3">char*类型的指针的步长为1个字节</span>，并且数组每个元素的所占的字节数我们又是已知的(<span class="kdocs-color" style="color:#DA326B">参数k</span>)，那么我们是不是就可以<span class="kdocs-color" style="background-color:#F8D7B7">将arr强制类型转换为char*，然后加上k的整数倍即可得到相应元素所在地址</span>。怎么样，是不是太巧妙了，下面来看代码：</p></li></ul>
 <pre class="kdocs-cpp"><code class="language-cpp">void my_bubble_sort(void* arr, size_t sz, size_t k, int (*cmp)(const void*, const void*))
{
    for (int i = 0; i &lt; sz - 1; i++)
    {
        for (int j = 0; j &lt; sz - i - 1; j++)
        {
            //对相邻两个元素进行比较
            if (cmp((char*)arr + j * k, (char*)arr + (j + 1) * k)&gt;0)
            {
                //swap交换两个元素
            }
        }
    }
}</code></pre>
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0"><p>由于<span class="kdocs-color" style="background-color:#FBF5B3">cmp()为回调函数，是用户根据需求所设计的</span>，因此我们的冒泡排序函数只剩下最后一个函数<span class="kdocs-color" style="color:#DA326B">swap()</span>了，用于<span class="kdocs-color" style="background-color:#FBF5B3">交换两个元素</span>。那么swap()函数的参数要如何设计呢，用int*？还是用flost*？都不是，这里我们<span class="kdocs-color" style="background-color:#F8D7B7">采用</span><span class="kdocs-color" style="background-color:#F8D7B7;color:#DA326B">char*</span><span class="kdocs-color" style="background-color:#F8D7B7">来接收操作数的地址</span>，并且<span class="kdocs-color" style="background-color:#F8D7B7">再用一个参数来接收元素的大小</span>(原因下面解释）函数原型如下：</p></li></ul>
 <pre class="kdocs-cpp"><code class="language-cpp">void swap(char* p1, char* p2, int k) //p1,p2指向操作数首地址，k为每个元素的字节数</code></pre>
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0"><p>最后，我们来实现这个函数。因为我们不知道元素的类型，所以我们<span class="kdocs-color" style="background-color:#F8D7B7">交换只能一个字节一个字节交换</span>。而对<span class="kdocs-color" style="color:#DA326B">char*指针</span>解引用即向后访问<span class="kdocs-color" style="color:#DA326B">一个字节</span>，又已知元素的大小为<span class="kdocs-color" style="color:#DA326B">k个字节</span>，我们<span class="kdocs-color" style="background-color:#F8D7B7">通过循环k次即可将k个字节全部交换完毕</span>。这也是为什么参数要以char*类型接收以及要接收元素的大小的原因。实现如下：</p></li></ul>
 <pre class="kdocs-cpp"><code class="language-cpp">void swap(char* p1, char* p2, int k) 
{
    //循环k次，k个字节依次交换
    for (int i = 1; i &lt;= k; i++)
    {
        //交换
        char temp = *p1;
        *p1 = *p2;
        *p2 = temp;
        //指向下一字节
        p1++;
        p2++;
    }
}</code></pre>
 <blockquote class="kdocs-blockquote">
  至此，我们完成的整个冒泡函数的实现，
  <span class="kdocs-color" style="color:#DA326B">总代码如下</span>：
 </blockquote>
 <pre class="kdocs-cpp"><code class="language-cpp">void swap(char* p1, char* p2, int k)
{
    for (int i = 1; i &lt;= k; i++)
    {
        char temp = *p1;
        *p1 = *p2;
        *p2 = temp;
        p1++;
        p2++;
    }
}
void my_bubble_sort(void* arr, size_t sz, size_t k, int (*cmp)(const void*, const void*))
{
    for (int i = 0; i &lt; sz - 1; i++)
    {
        for (int j = 0; j &lt; sz - i - 1; j++)
        {
            if (cmp((char*)arr + j * k, (char*)arr + (j + 1) * k)&gt;0)
            {
                swap((char*)arr + j * k, (char*)arr + (j + 1) * k, k);
            }
        }
    }
}</code></pre>
 <p style="text-indent:1.4em">我们可以用来排序<span class="kdocs-color" style="color:#DA326B">整形</span>：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
//递增
int cmp_int1(const void* p1, const void* p2)   //回调函数，用于比较整形
{
    return *((int*)p1) - *((int*)p2);
}
int main()
{
    int arr[10] = { 8,5,4,6,4,7,8,1,9,4 };
    int sz = sizeof(arr) / sizeof(arr[0]);
    my_bubble_sort(arr, sz, sizeof(arr[0]), cmp_name);
    //打印
    for (int i = 0; i &lt; sz; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}</code></pre>
 <div class="kdocs-line-container">
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:1090px;justify-content:center;align-items:center;height:auto">
   <div class="kdocs-img" style="padding-top:14.495413%;height:0">
    <img src="https://images2.imgbox.com/97/45/mPNvLhum_o.png" style="margin-left:;width:1090px;margin-top:-14.495413%;height:auto">
   </div>
  </div>
 </div>
 <p style="text-indent:1.4em;text-align:left">也可以用来排序<span class="kdocs-color" style="color:#DA326B">结构体</span>等等：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
struct student
{
    char name[20];
    int age;
};
int cmp_name(const void* p1, const void* p2)  回调函数，用于比较结构体中的姓名
{
    return strcmp(((struct student*)p1)-&gt;name, ((struct student*)p2)-&gt;name);
}
int main()
{
    struct student arr[3] = { {"zhangsan",16},{"lisi",14},{"lihau",18} };
    int sz = sizeof(arr) / sizeof(arr[0]);
    my_bubble_sort(arr, sz, sizeof(arr[0]), cmp_name);
    //打印
    for (int i = 0; i &lt; sz; i++)
    {
        printf("%s %dn", arr[i].name, arr[i].age);
    }
    return 0;
}</code></pre>
 <h2>3. 指针和数组笔试题?</h2>
 <blockquote class="kdocs-blockquote">
  学习了那么多关于指针的知识点，我们也要学会如何运用。下面给各位带来了一些有关指针与数组的笔试题作为饭后甜点。事不宜迟，让我们马上开始品尝吧！
 </blockquote>
 <h3>3.1 一维整形数组</h3>
 <p style="text-indent:1.4em">首先是一维整形数组，求下列<span class="kdocs-color" style="color:#DA326B">十条语句</span>输出的结果：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">//一维数组

int a[] = {1,2,3,4};

printf("%dn",sizeof(a));//1

printf("%dn",sizeof(a+0));//2

printf("%dn",sizeof(*a));//3

printf("%dn",sizeof(a+1));//4

printf("%dn",sizeof(a[1]));//5

printf("%dn",sizeof(&amp;a));//6

printf("%dn",sizeof(*&amp;a));//7

printf("%dn",sizeof(&amp;a+1));//8

printf("%dn",sizeof(&amp;a[0]));//9

printf("%dn",sizeof(&amp;a[0]+1));//10</code></pre>
 <p>答案及解释如下表：</p>
 <div>
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1"><tbody>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">语句编号</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">答案</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:middle;height:51px"><p style="text-align:center">解释</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">16</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p><span class="kdocs-color" style="background-color:#FBF5B3">数组名单独放在sizeof内部代表整个数组</span>，即求<span class="kdocs-color" style="background-color:#F8D7B7">整个数组所占空间</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">2</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>由于数组名并非单独在sizeof内部，其代表<span class="kdocs-color" style="background-color:#FBF5B3">首元素地址</span>，求的就是<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">3</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>同理，a为首元素地址，对其解引用得到首元素，即求<span class="kdocs-color" style="background-color:#F8D7B7">首元素所占空间</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>首元素地址加1，向后移动4个字节，还是指针，求的为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">5</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>求下标为1的元素，即<span class="kdocs-color" style="background-color:#F8D7B7">第二个整形元素所占空间</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p><span class="kdocs-color" style="background-color:#FBF5B3">&amp;数组名取出的是整个数组的地址</span>，因此求的为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">7</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">16</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>取出整个数组的地址然后解引用，最后得到整个数组，因此求<span class="kdocs-color" style="background-color:#F8D7B7">整个数组所占空间</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">8</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>取出整个数组的地址，然后加1，还是指针，求的为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">9</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>取出数组第一个元素的地址，因此求的为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">10</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>取出数组第一个元素的地址，然后加1指向下一个元素，还是指针，求的为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
</tbody></table>
 </div>
 <blockquote class="kdocs-blockquote">
  怎么样，你都做对了吗？
 </blockquote>
 <hr>
 <h3>3.2 二维整形数组</h3>
 <p style="text-indent:1.4em">同样，求下列几条<span class="kdocs-color" style="color:#080F17">语句</span>输出的结果：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">//二维数组

int a[3][4] = {0};

printf("%dn",sizeof(a));//1

printf("%dn",sizeof(a[0][0]));//2

printf("%dn",sizeof(a[0]));//3

printf("%dn",sizeof(a[0]+1));//4

printf("%dn",sizeof(*(a[0]+1)));//5

printf("%dn",sizeof(a+1));//6

printf("%dn",sizeof(*(a+1)));//7

printf("%dn",sizeof(&amp;a[0]+1));//8

printf("%dn",sizeof(*(&amp;a[0]+1)));//9

printf("%dn",sizeof(*a));//10

printf("%dn",sizeof(a[3]));//11</code></pre>
 <p>答案及解释如下表：</p>
 <div>
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1"><tbody>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">语句编号</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">答案</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:middle;height:51px"><p style="text-align:center">解释</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">48</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p><span class="kdocs-color" style="background-color:#FBF5B3">数组名单独放在sizeof内部代表整个数组</span>，即求<span class="kdocs-color" style="background-color:#F8D7B7">整个数组所占空间</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">2</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>a[0][0]代表第一行第一列元素,即求<span class="kdocs-color" style="background-color:#F8D7B7">第一行第一列元素所占空间</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">3</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">16</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left"><span class="kdocs-color" style="background-color:#FBF5B3">a[0]代表第一行数组，即第一行数组的数组名</span>，数组名单独放在sizeof内部，求的为整个数组的大小，即<span class="kdocs-color" style="background-color:#F8D7B7">第一行一维数组的大小</span>。</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>a[0]为第一行数组的数组名，但没有单独放在sizeof内部，因此为第一行一维数组首元素地址，加一后为第二个元素地址，因此求的是<span class="kdocs-color" style="background-color:#F8D7B7">整形指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">5</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>上面说到a[0]+1为第一行数组第二个元素地址，解引用后即为第一行数组的第二个元素，求的为<span class="kdocs-color" style="background-color:#F8D7B7">整形元素的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>a<span class="kdocs-color" style="background-color:#FBF5B3">数组名没有单独在sizeof内部，因此为首元素地址</span>，即第一行数组的地址，加一后为第二行数组的地址，为指针，求的为<span class="kdocs-color" style="background-color:#F8D7B7">数组指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">7</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">16</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>由6可得a+1为第二行数组的地址，解引用后为第二行数组，求的即为<span class="kdocs-color" style="background-color:#F8D7B7">第二行一维数组的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">8</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>a[0]为第一行数组名，取地址后取出的是第一行数组的地址，加1后为第二行数组的地址，为指针，求的<span class="kdocs-color" style="background-color:#F8D7B7">数组指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">9</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">16</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>由8得a[0]+1为第二行数组的地址，解引用后为第二行数组，求的是<span class="kdocs-color" style="background-color:#F8D7B7">第二行一维数组的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">10</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">16</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>数组名没有单独放在sizeof内部，代表首元素地址，即第一行数组的地址，解引用后得到第一行数组，求的是<span class="kdocs-color" style="background-color:#F8D7B7">第一行一维数组的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">11</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">16</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px">
<p style="text-align:left">1.<span class="kdocs-color" style="background-color:#FBF5B3">sizeof()并不会对括号内部的表达式进行运算操作</span>，即sizeof(arr[3])并不会去访问arr[3]，因此<span class="kdocs-color" style="background-color:#FBF5B3">不构成越界访问</span>。</p>
<p>2.sizeof()是通过变量的<span class="kdocs-color" style="color:#DA326B">类型属性</span><span class="kdocs-color" style="color:#080F17">来确定变量所占空间的大小，arr[3]的类型是一个一维数组，因此sizeof(arr[3])求的即为</span><span class="kdocs-color" style="background-color:#F8D7B7;color:#080F17">一维数组的大小</span></p>
</td>
</tr>
</tbody></table>
 </div>
 <hr>
 <h3>3.3 字符数组</h3>
 <p style="text-indent:1.4em">根据初始化方式的不同我们分为三组题，我们先来看第一组：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">//用字符初始化数组，数组存放的内容为a，b，c，d，e，f
char arr[] = {'a','b','c','d','e','f'};

printf("%dn", sizeof(arr)); //1

printf("%dn", sizeof(arr+0));//2

printf("%dn", sizeof(*arr));//3

printf("%dn", sizeof(arr[1]));//4

printf("%dn", sizeof(&amp;arr));//5

printf("%dn", sizeof(&amp;arr+1));//6

printf("%dn", sizeof(&amp;arr[0]+1));//7

printf("%dn", strlen(arr));//8

printf("%dn", strlen(arr+0));//9

printf("%dn", strlen(*arr));//10

printf("%dn", strlen(arr[1]));//11

printf("%dn", strlen(&amp;arr));//12

printf("%dn", strlen(&amp;arr+1));//13

printf("%dn", strlen(&amp;arr[0]+1));//14</code></pre>
 <div>
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1"><tbody>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">语句编号</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">答案</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:middle;height:51px"><p style="text-align:center">解释</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left"><span class="kdocs-color" style="background-color:#FBF5B3">数组名单独放在sizeof()内部，代表整个数组</span>，求的为<span class="kdocs-color" style="background-color:#F8D7B7">整个数组的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">2</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>数组名没有单独放于内部，代表首元素地址，最终求的为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">3</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>arr代表首元素地址，解引用后得到首元素，求的为<span class="kdocs-color" style="background-color:#F8D7B7">第一个字符的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>arr[1]为数组第2个元素，求的为<span class="kdocs-color" style="background-color:#F8D7B7">第二个字符的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">5</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>&amp;数组名取出整个数组的地址，因此求的是<span class="kdocs-color" style="background-color:#F8D7B7">字符数组指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>&amp;arr为字符数组的地址，加1后越过一个字符数组，类型属性还是指针，求的是<span class="kdocs-color" style="background-color:#F8D7B7">字符数组指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">7</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>取出第一个元素的地址，然后加1，指向第二个元素，还是指针，因此求的是<span class="kdocs-color" style="background-color:#F8D7B7">字符指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">8</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">随机值</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>由于<span class="kdocs-color" style="background-color:#FBF5B3">strlen()遇到''停止计数</span>，但是我们的字符数组中不存在''，所以会继续向后统计直到遇到''。何时遇到''是我们不可预知的，为<span class="kdocs-color" style="background-color:#F8D7B7">随机值</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">9</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">随机值</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p><span class="kdocs-color" style="background-color:#FBF5B3">在strlen()中，arr与arr+0都表示首元素地址</span>，由于不知道何时遇到''，因此为<span class="kdocs-color" style="background-color:#F8D7B7">随机值</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">10</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">非法访问</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>arr为首元素地址，解引用后为首元素。本条语句实际上是将首元素的字面值作为地址传入函数向后进行统计，显然<span class="kdocs-color" style="background-color:#F8D7B7">造成了非法访问</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">11</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">非法访问</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>arr[1]代表数组第二个元素，同理会<span class="kdocs-color" style="background-color:#F8D7B7">造成非法访问</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:51px"><p style="text-align:center">12</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:51px"><p style="text-align:center">随机值</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>&amp;arr为字符数组的地址，指向数组开头。由于不知道''的位置，因此为<span class="kdocs-color" style="background-color:#F8D7B7">随机值</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:51px"><p style="text-align:center">13</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:51px"><p style="text-align:center">随机值</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>&amp;arr为数组的地址，加1后越过一个数组,指向后续元素。但是我们任然不知道''的位置，因此为<span class="kdocs-color" style="background-color:#F8D7B7">随机值(这里的随机值比第12的随机值小6)</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:51px"><p style="text-align:center">14</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:51px"><p style="text-align:center">随机值</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p>&amp;arr[0]为数组首元素地址，加1后为第2个元素地址。因此不用多说，这里<span class="kdocs-color" style="background-color:#F8D7B7">还是随机值，只不过这个随机值比第12小1</span></p></td>
</tr>
</tbody></table>
 </div>
 <hr>
 <p>紧接着我们来看第二组：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">char arr[] = "abcdef"; //用字符串初始化数组,相当于将字符串拷贝到数组中

printf("%dn", sizeof(arr));//1

printf("%dn", sizeof(arr+0));//2

printf("%dn", sizeof(*arr));//3

printf("%dn", sizeof(arr[1]));//4

printf("%dn", sizeof(&amp;arr));//5

printf("%dn", sizeof(&amp;arr+1));//6

printf("%dn", sizeof(&amp;arr[0]+1));//7

printf("%dn", strlen(arr));//8

printf("%dn", strlen(arr+0));//9

printf("%dn", strlen(*arr));//10

printf("%dn", strlen(arr[1]));//11

printf("%dn", strlen(&amp;arr));//12

printf("%dn", strlen(&amp;arr+1));//13

printf("%dn", strlen(&amp;arr[0]+1));//14</code></pre>
 <div>
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1"><tbody>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">语句编号</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">答案</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:middle;height:51px"><p style="text-align:center">解释</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">7</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left"><span class="kdocs-color" style="background-color:#FBF5B3">数组名单独放在sizeof()内部，代表整个数组</span>，求的为<span class="kdocs-color" style="background-color:#F8D7B7">整个数组的所占空间（包括字符串末尾隐藏的''）</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">2</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">数组名没有单独放于内部，代表首元素地址，最终求的为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">3</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">arr代表首元素地址，解引用后得到首元素，求的为<span class="kdocs-color" style="background-color:#F8D7B7">第一个字符的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">arr[1]为数组第2个元素，求的为<span class="kdocs-color" style="background-color:#F8D7B7">第二个字符的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">5</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">&amp;数组名取出整个数组的地址，因此求的是<span class="kdocs-color" style="background-color:#F8D7B7">字符数组指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">&amp;arr为字符数组的地址，加1后越过一个字符数组，类型属性还是指针，求的是<span class="kdocs-color" style="background-color:#F8D7B7">字符数组指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">7</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">取出第一个元素的地址，然后加1，指向第二个元素，还是指针，因此求的是<span class="kdocs-color" style="background-color:#F8D7B7">字符指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">8</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left"><span class="kdocs-color" style="background-color:#FBF5B3">由于字符串以''结尾，末尾隐藏了''</span>，因此strlen计算的结果即为<span class="kdocs-color" style="background-color:#F8D7B7">字符串的长度(不包括末尾隐藏的'')</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">9</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left"><span class="kdocs-color" style="background-color:#FBF5B3">在strlen()中，arr与arr+0都表示首元素地址</span>，因此结果为<span class="kdocs-color" style="background-color:#F8D7B7">字符串长度</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">10</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">非法访问</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">arr为首元素地址，解引用后为首元素。本条语句实际上是将首元素的字面值作为地址传入函数向后进行统计，显然<span class="kdocs-color" style="background-color:#F8D7B7">造成了非法访问</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">11</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">非法访问</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">arr[1]代表数组第二个元素，同理会<span class="kdocs-color" style="background-color:#F8D7B7">造成非法访问</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">12</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">&amp;arr为字符数组的地址，指向数组开头。于是从数组开头向后统计字符串个数直到遇到''停止，因此结果为<span class="kdocs-color" style="background-color:#F8D7B7">字符串的长度</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">13</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">随机值</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">&amp;arr为数组的地址，加1后越过一个数组,即越过了字符串末尾的''指向下一元素。由于不知道后续的''处于何处，因此为<span class="kdocs-color" style="background-color:#F8D7B7">随机值</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">14</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">5</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">&amp;arr[0]为数组首元素地址，加1后为第2个元素地址，即从第二个元素开始向后统计字符的个数。结果为<span class="kdocs-color" style="background-color:#F8D7B7">字符串个数-1</span></p></td>
</tr>
</tbody></table>
 </div>
 <hr>
 <p>最后一组是将字符串赋给一个字符指针，如下：</p>
 <pre class="kdocs-cpp"><code class="language-cpp">char* p = "abcdef";//字符串初始化字符指针，指针指向字符串首元素地址

printf("%dn", sizeof(p));//1

printf("%dn", sizeof(p + 1));//2

printf("%dn", sizeof(*p));//3

printf("%dn", sizeof(p[0]));//4

printf("%dn", sizeof(&amp;p));//5

printf("%dn", sizeof(&amp;p + 1));//6

printf("%dn", sizeof(&amp;p[0] + 1));//7

printf("%dn", strlen(p));//8

printf("%dn", strlen(p + 1));//9

printf("%dn", strlen(*p));//10

printf("%dn", strlen(p[0]));//11

printf("%dn", strlen(&amp;p));//12

printf("%dn", strlen(&amp;p + 1));//13

printf("%dn", strlen(&amp;p[0] + 1));//14</code></pre>
 <div>
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1"><tbody>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">语句编号</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">答案</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:middle;height:51px"><p style="text-align:center">解释</p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">p是个指针，存放字符串首元素地址，因此结果为<span class="kdocs-color" style="background-color:#F8D7B7">一个指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">2</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">p加1指向字符串常量中第2个字符的地址，还是指针，因此结果为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">3</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">对p指针解引用后得到a，求的就为<span class="kdocs-color" style="background-color:#F8D7B7">字符a的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">1</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">p[0]与*(p+0）等价，因此最终得到字符a，求的为<span class="kdocs-color" style="background-color:#F8D7B7">字符a的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">5</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">对一级指针变量取地址即为二级指针，二级指针也是指针，因此结果为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">&amp;p为二级指针，加1越过4个字节空间，还是个指针，结果为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">7</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">4/8</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">p[0]为字符串首元素，&amp;p[0]即为字符串首元素地址，加1后为第二个元素地址，是个指针，因此结果为<span class="kdocs-color" style="background-color:#F8D7B7">指针的大小</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">8</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">6</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">p存放着字符串首元素的地址，strlen(p)求得的即为<span class="kdocs-color" style="background-color:#F8D7B7">字符串长度</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px"><p style="text-align:center">9</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px"><p style="text-align:center">5</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:52px"><p style="text-align:left">p+1指向字符串第二个元素，因此结果为<span class="kdocs-color" style="background-color:#F8D7B7">字符串长度-1</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">10</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">非法访问</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">*p得到首元素a，strlen(*p)即把a的ASCII码值当作地址传入strlen()函数向后进行计数，显然会形成<span class="kdocs-color" style="background-color:#F8D7B7">非法访问</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">11</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">非法访问</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">p[0]等价于*(p+0）,因此结果与10相同，形成<span class="kdocs-color" style="background-color:#F8D7B7">非法访问</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">12</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">随机值</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">传入p的地址，函数从p的低地址处开始向后统计有几个字符。由于我们不知道''的位置，因此最终结果为<span class="kdocs-color" style="background-color:#F8D7B7">随机值</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">13</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">随机值</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">&amp;p取出p的地址，加1后相当于越过指针变量p指向下一地址，但我们还是不知道''的位置，因此最终结果为<span class="kdocs-color" style="background-color:#F8D7B7">随机值</span></p></td>
</tr>
<tr class="kdocs-tableRow">
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">14</p></td>
<td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:51px"><p style="text-align:center">5</p></td>
<td class="kdocs-tableCell" style="width:539px;vertical-align:top;height:51px"><p style="text-align:left">p[0]相当于*(p+0）,由于*和&amp;可以互相抵消，因此&amp;p[0]相当于p。所以本语句结果和第9条语句一样，都为<span class="kdocs-color" style="background-color:#F8D7B7">字符串长度-1</span></p></td>
</tr>
</tbody></table>
 </div>
 <h3>3.4 总结</h3>
 <p>数组名的意义：</p>
 <blockquote class="kdocs-blockquote">
  <span class="kdocs-color" style="background-color:#FBF5B3">1. sizeof(数组名)，这里的数组名代表整个数组，计算的是整个数组的大小</span>
  <br>
  <span class="kdocs-color" style="background-color:#FBF5B3">2. &amp;数组名，这里的数组名表示整个数组，取出的是整个数组的地址。</span>
  <br>
  <span class="kdocs-color" style="background-color:#FBF5B3">3. 除了以上两种情况其他所有的数组名都代表首元素地址。</span>
 </blockquote>
 <hr>
 <p style="text-align:left"> <span class="kdocs-bold" style="font-weight:bold"><span class="kdocs-italic" style="font-style:italic">以上，就是本期的全部内容啦</span></span>?</p>
 <p style="text-align:left"><span class="kdocs-bold" style="font-weight:bold"><span class="kdocs-italic" style="font-style:italic">制作不易，能否点个赞再走呢</span></span>?</p>
 <p></p>
</div>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>