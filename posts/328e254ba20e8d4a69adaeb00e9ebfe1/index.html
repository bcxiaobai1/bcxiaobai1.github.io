<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Rust之自动化测试(一)：如何编写测试 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust之自动化测试(一)：如何编写测试</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h1>开发环境</h1> 
<ul>
<li>Windows 10</li>
<li>Rust 1.71.1</li>
</ul> 
<p> <img alt="" height="67" src="https://images2.imgbox.com/19/f0/79lQY21L_o.png" width="454"></p> 
<ul><li>VS Code 1.81.1</li></ul> 
<p><img alt="" height="296" src="https://images2.imgbox.com/7b/c3/Kj3qf3Rg_o.png" width="401"></p> 
<h1> <a name="t1"></a>项目工程</h1> 
<p>这里继续沿用上次工程<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=rust" title="rust">rust</a>-demo<br><img alt="" height="186" src="https://images2.imgbox.com/b0/66/gsPLix8D_o.png" width="264"></p> 
<h1>编写自动化测试</h1> 
<p>Edsger W. Dijkstra在他1972年的文章《谦逊的程序员》中说，“程序测试可以是一种非常有效的方法来显示错误的存在，但它对于显示它们的不存在是完全不够的。”这并不意味着我们不应该尽可能多地尝试测试！ </p> 
<p>我们程序的正确性是指我们的代码在多大程度上做了我们想要它做的事情。Rust的设计高度关注程序的正确性，但正确性很复杂，不容易证明。Rust的类型系统承担了这个负担的很大一部分，但是类型系统不能捕获所有的东西。因此，Rust包含了对编写自动化软件测试的支持。</p> 
<p>假设我们编写了一个函数<strong><span style="background-color:#a2e043">add_two</span></strong>，它将传递给它的任何数字加2。这个函数的签名接受一个整数作为参数，并返回一个整数作为结果。当我们实现和编译这个函数时，Rust会进行所有的类型检查和借用检查，就像你到目前为止所学的那样，以确保我们不会向这个函数传递一个<strong><span style="background-color:#a2e043">String</span></strong>值或一个无效的引用。但是Rust不能检查这个函数是否能准确地达到我们的目的，即返回参数加2，而不是参数加10或参数减50！这就是测试的由来。</p> 
<p>我们可以编写一些测试来断言，例如，当我们将<strong><span style="background-color:#a2e043">3</span></strong>传递给<strong><span style="background-color:#a2e043">add_two</span></strong>函数时，返回值是<strong><span style="background-color:#a2e043">5</span></strong>。每当我们对代码进行更改时，我们都可以运行这些测试，以确保任何现有的正确行为都没有改变。</p> 
<p id="trans_yiwen_easy">测试是一项复杂的技能:虽然我们无法在一章中涵盖如何编写好的测试的每个细节，但我们将讨论Rust测试工具的机制。我们将讨论编写测试时可用的注释和宏，为运行测试提供的默认行为和选项，以及如何将测试组织成单元测试和集成测试。</p> 
<h1>如何编写测试</h1> 
<p>测试是Rust函数，它验证非测试代码是否以预期的方式运行。测试函数的主体通常执行这三个动作:</p> 
<ol>
<li>设置任何需要的数据或状态。</li>
<li>运行您想要测试的代码。</li>
<li>断言结果是你所期望的。</li>
</ol> 
<p>让我们来看看Rust专门为编写执行这些操作的测试提供的特性，包括<strong><span style="background-color:#a2e043">test</span></strong>属性、一些宏和<strong><span style="background-color:#a2e043">should_panic</span></strong>属性。</p> 
<h1>测试函数的剖析</h1> 
<p>最简单地说，Rust中的测试是一个用<strong><span style="background-color:#a2e043">test</span></strong>属性注释的函数。属性是关于Rust代码片段的元数据；一个例子是我们在第5章中对结构使用的<strong><span style="background-color:#a2e043">derive</span></strong>属性。要将函数更改为测试函数，请在<strong><span style="background-color:#a2e043">fn</span></strong>之前的行中添加<strong><span style="background-color:#a2e043">#[test]</span></strong>。当您使用<strong><span style="background-color:#a2e043">cargo test</span></strong>命令运行您的测试时，Rust会构建一个测试运行二进制文件，运行带注释的函数并报告每个测试函数是通过还是失败。</p> 
<p>每当我们用Cargo创建一个新的库项目时，就会自动为我们生成一个包含测试功能的测试模块。这个模块为您提供了一个编写测试的模板，这样您就不必在每次开始一个新项目时都去查找精确的结构和语法。您可以添加任意多的额外测试函数和测试模块！  </p> 
<p>在实际测试任何代码之前，我们将通过模板测试来探索测试工作的某些方面。然后，我们将编写一些真实世界的测试，调用我们编写的一些代码，并断言其行为是正确的。 </p> 
<p>让我们创建一个名为<strong><span style="background-color:#a2e043">adder</span></strong>的新库项目，它将添加两个数:</p> 
<pre><code class="language-rust">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre> 
<p> <strong><span style="background-color:#a2e043">adder</span></strong>库中src/lib.rs文件的内容应该如示例11-1所示。</p> 
<p>文件名:src/lib.rs</p> 
<pre><code class="language-rust">#[cfg(test)]
mod tests {         
    #[test]                       // 测试
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}</code></pre> 
<p style="text-align:center">示例11-1:由cargo new自动生成的测试模块和函数</p> 
<p>现在，让我们忽略上面两行，把注意力集中在函数上。注意<strong><span style="background-color:#a2e043">#[test]</span></strong>注释:这个属性表明这是一个测试函数，所以测试运行人员知道将这个函数视为一个测试。在<strong><span style="background-color:#a2e043">tests</span></strong>模块中，我们还可能有非测试函数来帮助设置常见的场景或执行常见的操作，所以我们总是需要指出哪些函数是测试。</p> 
<p>示例函数体使用了<strong><span style="background-color:#a2e043">assert_eq！</span></strong>宏来断言包含2和2相加<strong><span style="background-color:#a2e043">result</span></strong>的结果等于4。这个断言作为一个典型测试格式的例子。让我们运行它来看看这个测试是否通过。 </p> 
<p><strong><span style="background-color:#a2e043">cargo test</span></strong>命令运行我们项目中的所有测试，如示例11-2所示。</p> 
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre> 
<p style="text-align:center">示例11-2:运行自动生成的测试的输出 </p> 
<p class="img-center"><img alt="" height="268" src="https://images2.imgbox.com/f6/4c/xUxwT3DS_o.png" width="709"></p> 
<p> Cargo编译并运行了测试。我们看到<strong><span style="background-color:#a2e043">runing1 test</span></strong>的行。下一行显示了生成的测试函数的名称，名为<strong><span style="background-color:#a2e043">it_works</span></strong>，运行该测试的结果是<strong><span style="background-color:#a2e043">ok</span></strong>的。总体总结<strong><span style="background-color:#a2e043">test result: ok</span></strong>。意味着所有的测试都通过了，而写着<strong><span style="background-color:#a2e043">1 passed; 0 failed</span></strong>总计测试通过或失败的次数。 </p> 
<p><strong><span style="background-color:#a2e043">0 measured</span></strong>测量统计值用于测量性能的基准测试。在撰写本文时，基准测试只在夜间Rust中可用。</p> 
<p>从<strong><span style="background-color:#a2e043">Doc-tests adder</span></strong>开始的测试输出的下一部分是任何文档测试的结果。我们还没有任何文档测试，但Rust可以编译任何出现在我们API文档中的代码示例。这个特性有助于保持您的文档和代码同步！现在，我们将忽略<strong><span style="background-color:#a2e043">Doc-tests</span></strong>输出。</p> 
<p>让我们开始根据自己的需要定制测试。首先将<strong><span style="background-color:#a2e043">it_works</span></strong>函数的名称改为不同的名称，例如<strong><span style="background-color:#a2e043">exploration</span></strong>，如下所示:</p> 
<p>文件名:src/lib.rs</p> 
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}</code></pre> 
<p>然后再次运行<strong><span style="background-color:#a2e043">cargo test</span></strong>。现在输出显示的是<strong><span style="background-color:#a2e043">exploration</span></strong>而不是<strong><span style="background-color:#a2e043">it_works</span></strong>:</p> 
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre> 
<p class="img-center"><img alt="" height="267" src="https://images2.imgbox.com/15/fd/LjnjRcvr_o.png" width="734"></p> 
<p> 现在我们将添加另一个测试，但这次我们将做一个失败的测试！当测试函数出现问题时，测试就会失败。每个测试都在一个新线程中运行，当主线程发现一个测试线程已经死亡时，该测试就会被标记为失败。在第9章中，我们谈到了恐慌的最简单的方法是如何打电话给<strong><span style="background-color:#a2e043">panic!</span></strong>宏观。输入新的测试作为一个名为<strong><span style="background-color:#a2e043">another</span></strong>的函数，这样你的src/lib.rs文件看起来如示例11-3所示。</p> 
<p>文件名:src/lib.rs</p> 
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}</code></pre> 
<p style="text-align:center"> 示例11-3:添加第二个测试，该测试将失败，因为我们称之为<strong><span style="background-color:#a2e043">panic!</span></strong>宏指令</p> 
<p>使用<strong><span style="background-color:#a2e043">cargo test</span></strong>再次运行测试。输出应该如示例11-4所示，这表明我们的<strong><span style="background-color:#a2e043">exploration</span></strong>测试通过了，而<strong><span style="background-color:#a2e043">another</span></strong>测试失败了。 </p> 
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre> 
<p style="text-align:center">示例11-4:当一个测试通过而另一个测试失败时的测试结果</p> 
<p class="img-center"><img alt="" height="384" src="https://images2.imgbox.com/5d/12/o9kARaJz_o.png" width="758"></p> 
<p> 行<strong><span style="background-color:#a2e043">test </span><strong><span style="background-color:#a2e043">test</span></strong><span style="background-color:#a2e043">s::another</span></strong>显示<strong><span style="background-color:#a2e043">FAILED</span></strong>，而不是<strong><span style="background-color:#a2e043">ok</span></strong>。在单独的结果和总结之间出现两个新的部分:第一部分显示每个测试失败的详细原因。在这种情况下，我们获得<strong><span style="background-color:#a2e043">another</span></strong>失败的详细信息，因为它在src/lib.rs文件的第10行<strong><span style="background-color:#a2e043">panicked at 'Make this test fail'</span></strong>时死机。 </p> 
<p>总结行显示在最后:总的来说，我们的测试结果是<strong><span style="background-color:#a2e043">FAILED</span></strong>的。我们有一个测试通过，一个测试失败。 </p> 
<p>现在您已经看到了不同场景下的测试结果，让我们来看看除了<strong><span style="background-color:#a2e043">panic!</span></strong>之外的一些宏在测试中很有用。 </p> 
<h1>用assert!宏检查结果</h1> 
<p><strong><span style="background-color:#a2e043">assert!</span></strong>当您希望确保测试中的某个条件评估为真时，标准库提供的宏非常有用。我们给出<strong><span style="background-color:#a2e043">assert!</span></strong>计算结果为布尔值的参数。如果该值为<strong><span style="background-color:#a2e043">true</span></strong>，则什么都不会发生，测试通过。如果值为<strong><span style="background-color:#a2e043">false</span></strong>，则<strong><span style="background-color:#a2e043">assert!</span></strong>调用<strong><span style="background-color:#a2e043">panic!</span></strong>导致测试失败。使用<strong><span style="background-color:#a2e043">assert!</span></strong>帮助我们检查我们的代码是否按照我们想要的方式运行。</p> 
<p>在第五章的示例5-15中，我们使用了一个<strong><span style="background-color:#a2e043">Rectangular</span></strong>结构和一个<strong><span style="background-color:#a2e043">can_hold</span></strong>方法，它们在示例11-5中重复出现。让我们将这段代码放到src/lib.rs文件中，然后使用<strong><span style="background-color:#a2e043">assert!</span></strong>为它编写一些测试。</p> 
<p> 文件名:src/lib.rs</p> 
<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre> 
<p style="text-align:center">示例11-5:使用第5章中的<strong><span style="background-color:#a2e043">Rectangular</span></strong>结构及其<strong><span style="background-color:#a2e043">can_hold</span></strong>方法</p> 
<p><strong><span style="background-color:#a2e043">can_hold</span></strong>方法返回一个布尔值，这意味着它是<strong><span style="background-color:#a2e043">assert!</span></strong>的完美用例。在示例11-6中，我们编写了一个测试，通过创建一个宽度为8、高度为7的<strong><span style="background-color:#a2e043">Rectangular</span></strong>实例，并断言它可以容纳另一个宽度为5、高度为1的<strong><span style="background-color:#a2e043">Rectangular</span></strong>实例，来练习<strong><span style="background-color:#a2e043">can_hold</span></strong>方法。 </p> 
<p>文件名:src/lib.rs</p> 
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre> 
<p style="text-align:center"> 示例11-6:对<strong><span style="background-color:#a2e043">can_hold</span></strong>的测试，检查一个较大的矩形是否可以容纳一个较小的矩形</p> 
<p>注意，我们在<strong><span style="background-color:#a2e043">tests</span></strong>模块中添加了新的一行:<strong><span style="background-color:#a2e043">use super::*;</span></strong>。<strong><span style="background-color:#a2e043">tests</span></strong>模块是一个常规的模块，它遵循我们在第7章节中提到的常见的可见性规则。因为<strong><span style="background-color:#a2e043">tests</span></strong>模块是一个内部模块，我们需要将外部模块中的测试代码放到内部模块的范围内。我们在这里使用了一个glob，所以我们在外部模块中定义的任何东西都可以用于这个<strong><span style="background-color:#a2e043">tests</span></strong>模块。 </p> 
<p>我们将我们的测试命名为<strong><span style="background-color:#a2e043">llarger_can_hold_smaller</span></strong>，并且创建了我们需要的两个矩形实例。然后我们调用了<strong><span style="background-color:#a2e043">assert!</span></strong>宏，并将调用<strong><span style="background-color:#a2e043">larger.can_hold(&amp;smaller)</span></strong>的结果传递给它。这个表达式应该返回<strong><span style="background-color:#a2e043">true</span></strong>，所以我们的测试应该通过。让我们来了解一下！</p> 
<pre><code class="language-bash">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre> 
<p class="img-center"><img alt="" height="273" src="https://images2.imgbox.com/43/9d/8mNGizYe_o.png" width="736"></p> 
<p> 确实测试通过了！让我们添加另一个测试，这次断言较小的矩形不能容纳较大的矩形:</p> 
<p>文件名:src/lib.rs</p> 
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre> 
<p> 因为在这种情况下<strong><span style="background-color:#a2e043">can_hold</span></strong>函数的正确结果是<strong><span style="background-color:#a2e043">false</span></strong>，所以我们需要在将结果传递给<strong><span style="background-color:#a2e043">assert!</span></strong>之前对其求反。因此，如果<strong><span style="background-color:#a2e043">can_hold</span></strong>返回<strong><span style="background-color:#a2e043">false</span></strong>，我们的测试将通过:</p> 
<pre><code class="language-bash">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre> 
<p class="img-center"><img alt="" height="293" src="https://images2.imgbox.com/18/78/bi60AqG6_o.png" width="811"></p> 
<p>两项测试通过！现在让我们看看当我们在代码中引入一个bug时，测试结果会发生什么。我们将更改<strong><span style="background-color:#a2e043">can_hold</span></strong>方法的实现，在比较宽度时用小于号替换大于号: </p> 
<pre><code class="language-rust">// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre> 
<p> 运行测试现在会产生以下结果:</p> 
<pre><code class="language-bash">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre> 
<p>我们的测试发现了漏洞！因为<strong><span style="background-color:#a2e043">larger.width</span></strong>是8，<strong><span style="background-color:#a2e043">smaller.width</span></strong>是5，所以<strong><span style="background-color:#a2e043">can_hold</span></strong>中的宽度比较现在返回<strong><span style="background-color:#a2e043">false</span></strong>: 8不小于5。</p> 
<h1>用宏assert_eq!和assert_ne!测试相等性</h1> 
<p>验证功能的一种常见方法是测试被测代码的结果与您期望代码返回的值之间是否相等。您可以使用<strong><span style="background-color:#a2e043">assert!</span></strong>来做到这一点，并使用<strong><span style="background-color:#a2e043">==</span></strong>运算符向其传递一个表达式。然而，这是一个非常常见的测试，标准库提供了一对宏——<strong><span style="background-color:#a2e043">assert_eq!</span></strong>和<strong><span style="background-color:#a2e043">assert_eq!</span></strong>—为了更方便地执行该测试。这些宏分别比较相等或不相等的两个参数。如果断言失败，它们还会打印这两个值，这更容易看出测试失败的原因；反之，<strong><span style="background-color:#a2e043">assert!</span></strong>只指示它为<strong><span style="background-color:#a2e043">==</span></strong>表达式获得了一个<strong><span style="background-color:#a2e043">false</span></strong>，而不打印导致<strong><span style="background-color:#a2e043">false</span></strong>的值。</p> 
<p>在示例11-7中，我们编写了一个名为<strong><span style="background-color:#a2e043">add_two</span></strong>的函数，将<strong><span style="background-color:#a2e043">2</span></strong>加到它的参数中，然后我们使用<strong><span style="background-color:#a2e043">assert_eq!</span></strong>测试这个函数。 </p> 
<p>文件名:src/lib.rs</p> 
<pre><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}</code></pre> 
<p style="text-align:center"> 示例11-7:使用<strong><span style="background-color:#a2e043">assert_eq!</span></strong>测试函数<strong><span style="background-color:#a2e043">add_two</span></strong></p> 
<p>让我们检查它是否通过！ </p> 
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre> 
<p> 我们将<strong><span style="background-color:#a2e043">4</span></strong>作为参数传递给<strong><span style="background-color:#a2e043">assert_eq!</span></strong>，等于调用<strong><span style="background-color:#a2e043">add_two(2)</span></strong>的结果。这个测试的代码行是<strong><span style="background-color:#a2e043">test tests::it_adds_two...ok</span></strong>，<strong><span style="background-color:#a2e043">ok</span></strong>文本表示我们的测试通过了！</p> 
<p>让我们在代码中引入一个bug，看看<strong><span style="background-color:#a2e043">assert_eq!</span></strong>是什么看起来当它失败时。将<strong><span style="background-color:#a2e043">add_two</span></strong>函数的实现改为添加<strong><span style="background-color:#a2e043">3</span></strong>:</p> 
<pre><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
</code></pre> 
<p>再次运行测试:</p> 
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre> 
<p>我们的测试发现了bug！<strong><span style="background-color:#a2e043">it_adds_two</span></strong>测试失败，消息告诉我们失败的断言是<strong><span style="background-color:#a2e043">assertion failed: `(left == right)`</span></strong>以及<strong><span style="background-color:#a2e043">left </span></strong>和<strong><span style="background-color:#a2e043">right</span></strong>值是什么。这条消息帮助我们开始调试:<strong><span style="background-color:#a2e043">left</span></strong>的参数是4，但是<strong><span style="background-color:#a2e043">right</span></strong>的参数是<strong><span style="background-color:#a2e043">5</span></strong>，这里我们有<strong><span style="background-color:#a2e043">add_two(2)</span></strong>。你可以想象，当我们有很多测试正在进行时，这将特别有帮助。</p> 
<p>注意，在一些语言和测试框架中，等式断言函数的参数被称为<strong><span style="background-color:#a2e043">expected</span></strong>和<strong><span style="background-color:#a2e043">actual</span></strong>，我们指定参数的顺序很重要。然而，在Rust中，它们被称为<strong><span style="background-color:#a2e043">left</span></strong>和<strong><span style="background-color:#a2e043">right</span></strong>，我们指定我们期望的值和代码产生的值的顺序并不重要。我们可以把这个测试中的断言写成<strong><span style="background-color:#a2e043">assert_eq!(add_two(2), 4)</span></strong>，这将导致显示断言失败的相同<strong><span style="background-color:#a2e043">assertion failed::</span><strong><span style="background-color:#a2e043">`(left == right)</span></strong><span style="background-color:#a2e043">`</span></strong>。</p> 
<p><strong><span style="background-color:#a2e043">assert_ne!</span></strong>如果我们给它的两个值不相等，将通过，如果相等，将失败。当我们不确定一个值是什么，但是我们知道这个值绝对不应该是什么时，这个宏是最有用的。例如，如果我们正在测试一个函数，它肯定会以某种方式改变它的输入，但是改变输入的方式取决于我们在一周中的哪一天运行测试，那么最好的断言可能是函数的输出不等于输入。</p> 
<p>表面之下，是<strong><span style="background-color:#a2e043">assert_eq!</span></strong>和<strong><span style="background-color:#a2e043">assert_ne!</span></strong>宏使用运算符<strong><span style="background-color:#a2e043">==</span></strong>和<strong><span style="background-color:#a2e043">!=</span></strong>，分别为。当断言失败时，这些宏使用调试格式打印它们的参数，这意味着被比较的值必须实现<strong><span style="background-color:#a2e043">PartialEq</span></strong>和<strong><span style="background-color:#a2e043">Debug</span></strong>特征。所有基本类型和大多数标准库类型都实现了这些特征。对于您自己定义的结构和枚举，您需要实现<strong><span style="background-color:#a2e043">PartialEq</span></strong>来断言这些类型的相等性。当断言失败时，您还需要实现<strong><span style="background-color:#a2e043">Debug</span></strong>来打印值。因为这两个特征都是可派生的特征，正如第5章示例5-12中提到的，这通常就像在你的结构或枚举定义中添加<strong><span style="background-color:#a2e043">#[derive(PartialEq，Debug)]</span></strong>注释一样简单。请参阅附录C，“可衍生特征”，了解有关这些和其他可衍生特征的更多详细信息。</p> 
<h1>添加自定义失败消息</h1> 
<p>您还可以添加一个自定义消息，作为<strong><span style="background-color:#a2e043">assert!</span></strong>的可选参数，与失败消息一起打印，<strong><span style="background-color:#a2e043">assert_eq！</span></strong>，和<strong><span style="background-color:#a2e043">assert_ne!</span></strong>。所需参数之后指定的任何参数都将传递给<strong><span style="background-color:#a2e043">format!</span></strong>宏(在第8章的“用+运算符串联or格式！宏”部分)，因此您可以传递一个包含<strong><span style="background-color:#a2e043">{}</span></strong>占位符和要放入这些占位符的值的格式字符串。自定义消息对于记录断言的含义非常有用；当一个测试失败时，您会对代码的问题有更好的了解。</p> 
<p>例如，假设我们有一个用名字问候别人的函数，我们想测试我们传递给函数的名字是否出现在输出中:</p> 
<p>文件名:src/lib.rs </p> 
<pre><code class="language-rust">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre> 
<p> 对这个程序的要求还没有达成一致，我们很确定开头的<strong><span style="background-color:#a2e043">Hello</span></strong>文本会改变。我们决定，当需求改变时，我们不需要更新测试，所以我们不检查<strong><span style="background-color:#a2e043">greeting</span></strong>函数返回的值是否完全相等，而是断言输出包含输入参数的文本。</p> 
<p>现在让我们通过将<strong><span style="background-color:#a2e043">greeting</span></strong>改为排除<strong><span style="background-color:#a2e043">name</span></strong>来引入一个bug，看看默认测试失败是什么样子的:</p> 
<pre><code class="language-rust">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
</code></pre> 
<p> 运行该测试会产生以下结果:</p> 
<pre><code class="language-bash">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at 'assertion failed: result.contains("Carol")', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre> 
<p>这个结果只是表明断言失败了，以及断言在哪一行。更有用的失败消息是打印<strong><span style="background-color:#a2e043">greeting</span></strong>函数的值。让我们添加一个定制的失败消息，该消息由一个格式字符串组成，该格式字符串带有一个占位符，占位符中填充了我们从<strong><span style="background-color:#a2e043">greeting</span></strong>函数中获得的实际值:</p> 
<pre><code class="language-rust">    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{}`",
            result
        );
    }
</code></pre> 
<p>现在，当我们运行测试时，我们将得到一个更具信息性的错误消息:</p> 
<pre><code class="language-bash">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre> 
<p> 我们可以在测试输出中看到我们实际得到的值，这将帮助我们调试发生了什么，而不是我们预期会发生什么。</p> 
<h1>使用should_panic检查panic</h1> 
<p>除了检查返回值，检查我们的代码是否如我们所期望的那样处理错误情况也很重要。例如，考虑我们在第9章示例9-13中创建的猜测类型。其他使用<strong><span style="background-color:#a2e043">Guess</span></strong>的代码依赖于<strong><span style="background-color:#a2e043">Guess</span></strong>实例只包含1到100之间的值的保证。我们可以编写一个测试，确保试图创建一个值在该范围之外的<strong><span style="background-color:#a2e043">Guess</span></strong>实例时会出错。</p> 
<p>我们通过向测试函数添加属性<strong><span style="background-color:#a2e043">should_panic</span></strong>来实现这一点。如果函数内部的代码出现混乱，则测试通过；如果函数内部的代码没有死机，测试就会失败。</p> 
<p>示例11-8显示了一个测试，它检查<strong><span style="background-color:#a2e043">Guess::new</span></strong>的错误条件是否在我们期望的时候发生。</p> 
<p>文件名:src/lib.rs</p> 
<pre><code class="language-rust">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre> 
<p style="text-align:center"> 示例11-8:测试一个条件会导致一个<strong><span style="background-color:#a2e043">panic!</span></strong></p> 
<p>我们将<strong><span style="background-color:#a2e043">#[should_panic]</span></strong>属性放在<strong><span style="background-color:#a2e043">#[test]</span></strong>属性之后，它所应用的测试函数之前。让我们看看测试通过后的结果: </p> 
<pre><code class="language-bash">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre> 
<p class="img-center"><img alt="" height="483" src="https://images2.imgbox.com/f6/7c/fSskgPfj_o.png" width="799"></p> 
<p>看起来不错！现在，让我们在代码中引入一个错误，删除如果值大于100，<strong><span style="background-color:#a2e043">new</span></strong>将会死机的条件: </p> 
<pre><code class="language-rust">// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}
</code></pre> 
<p>当我们运行示例11-8中的测试时，它会失败:</p> 
<pre><code class="language-bash">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre> 
<p> 在这种情况下，我们没有得到非常有用的消息，但是当我们查看测试函数时，我们看到它被注释为<strong><span style="background-color:#a2e043">#[should_panic]</span></strong>。我们得到的失败意味着测试函数中的代码没有导致死机。</p> 
<p>使用<strong><span style="background-color:#a2e043">should_panic</span></strong>的测试可能不精确。<strong><span style="background-color:#a2e043">should_panic</span></strong>测试将会通过，即使测试因不同于我们预期的原因而死机。为了使<strong><span style="background-color:#a2e043">should_panic</span></strong>测试更加精确，我们可以向<strong><span style="background-color:#a2e043">should_panic</span></strong>属性添加一个可选的预期参数。测试工具将确保失败消息包含所提供的文本。例如，考虑示例11-9中<strong><span style="background-color:#a2e043">Guess</span></strong>的修改代码，其中<strong><span style="background-color:#a2e043">new</span></strong>根据值是太小还是太大而出现不同的消息。</p> 
<p>文件名:src/lib.rs</p> 
<pre><code class="language-rust">// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {}.",
                value
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {}.",
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre> 
<p style="text-align:center"> 示例11-9:测试<strong><span style="background-color:#a2e043">panic!</span></strong>带有包含指定子字符串的紧急消息</p> 
<p>这个测试将会通过，因为我们在<strong><span style="background-color:#a2e043">should_panic</span></strong>属性的<strong><span style="background-color:#a2e043">expected</span></strong>参数中输入的值是<strong><span style="background-color:#a2e043">Guess::new</span></strong>函数出错的消息的子字符串。我们可以指定我们期望的整个紧急消息，在本例中，<strong><span style="background-color:#a2e043">Guess value must be less than or equal to 100, got 200.</span></strong>。您选择指定的内容取决于恐慌消息中有多少是独特的或动态的，以及您希望测试有多精确。在这种情况下，紧急消息的子字符串足以确保测试函数中的代码执行<strong><span style="background-color:#a2e043">else if value &gt; 100</span></strong>的情况。 </p> 
<p>为了查看当带有<strong><span style="background-color:#a2e043">expected</span></strong>消息的<strong><span style="background-color:#a2e043">should_panic</span></strong>测试失败时会发生什么，让我们通过交换<strong><span style="background-color:#a2e043">if value &lt; 1</span></strong>和<strong><span style="background-color:#a2e043">else if value &gt; 100</span></strong>块的主体，再次在代码中引入一个bug:</p> 
<pre><code class="language-rust">        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {}.",
                value
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {}.",
                value
            );
        }
</code></pre> 
<p>这一次，当我们运行<strong><span style="background-color:#a2e043">should_panic</span></strong>测试时，它将失败:</p> 
<pre><code class="language-bash">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at 'Guess value must be greater than or equal to 1, got 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre> 
<p>失败消息表明该测试确实如我们预期的<strong>Result&lt;T，E &gt;</strong>那样死机，但是死机消息不包括预期的字符串'<strong><span style="background-color:#a2e043">Guess value must be less than or equal to 100'</span></strong>。在这种情况下，我们得到的紧急消息是<strong><span style="background-color:#a2e043">Guess value must be greater than or equal to 1, got 200</span></strong>。现在我们可以开始找出我们的错误在哪里了！</p> 
<h1>在测试中使用Result&lt; T，E &gt;</h1> 
<p>到目前为止，我们的测试失败时都会惊慌失措。我们也可以编写使用<strong><span style="background-color:#a2e043">Result&lt;T，E &gt;</span></strong>的测试！下面是示例11-1中的测试，重写后使用<strong><span style="background-color:#a2e043">Result&lt;T，E &gt;</span></strong>并返回一个<strong>Err</strong>而不是死机:</p> 
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}</code></pre> 
<p><strong><span style="background-color:#a2e043">it_works</span></strong>函数现在有了<strong><span style="background-color:#a2e043">Result &lt;()，String &gt;</span></strong>返回类型。在函数体中，而不是调用<strong><span style="background-color:#a2e043">assert_eq!</span></strong>，当测试通过时，我们返回<strong><span style="background-color:#a2e043">Ok(())</span></strong>，当测试失败时，返回一个包含<strong><span style="background-color:#a2e043">String</span></strong>的<strong><span style="background-color:#a2e043">Err</span></strong>。</p> 
<p>编写返回<strong><span style="background-color:#a2e043">Result&lt;T，E &gt;</span></strong>的测试使您能够在测试体中使用问号操作符，这是一种编写测试的便捷方式，如果测试中的任何操作返回<strong>Err</strong>变量，测试就会失败。</p> 
<p>不能在使用<strong><span style="background-color:#a2e043">Result&lt;T，E &gt;</span></strong>的测试上使用<strong><span style="background-color:#a2e043">#[should_panic]</span></strong>批注。要断言一个操作返回一个E<strong><span style="background-color:#a2e043">Err</span></strong>rr变量，不要在<strong><span style="background-color:#a2e043">Result&lt;T，E &gt;</span></strong>值上使用问号运算符。而是使用<strong><span style="background-color:#a2e043">assert!(value.is_err())</span></strong>。 </p> 
<p>现在您已经知道了编写测试的几种方法，让我们看看运行测试时会发生什么，并探索我们可以使用<strong><span style="background-color:#a2e043">cargo test</span></strong>的不同选项。 </p> 
<h1>本章重点</h1> 
<ul>
<li>自动化测试的概念</li>
<li>如何编写测试用例</li>
<li>assert!在测试用例中如何使用</li>
<li>assert_eq!和assert_ne!在测试用例中如何使用</li>
<li>添加自定义失败信息</li>
<li>使用should_panic检查panic</li>
<li>使用Result&lt;T, E&gt;</li>
</ul>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>