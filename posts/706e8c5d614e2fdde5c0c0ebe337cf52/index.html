<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【C语言】数组（详细讲解&#43;源码展示） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】数组（详细讲解&#43;源码展示）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px"><a href="#%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0">数组概述</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:0px"><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</a></p> 
<p id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">如何使用一维数组</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px"><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">一维数组的初始化</a></p> 
<p id="%E6%95%B0%E7%BB%84%E5%90%8D-toc" style="margin-left:40px"><a href="#%E6%95%B0%E7%BB%84%E5%90%8D">数组名</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%99%E7%BB%84-toc" style="margin-left:40px"><a href="#%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%99%E7%BB%84">一维字符教组</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%99%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px"><a href="#%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%99%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89">一维字符教组的定义</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px"><a href="#%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96">一维字符数组初始化</a></p> 
<p id="%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8-toc" style="margin-left:80px"><a href="#%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8">一维字符数组的引用</a></p> 
<p id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</a></p> 
<p id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">如何使用二维数组</a></p> 
<p id="%C2%A0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px"><a href="#%C2%A0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"> 二维数组的初始化</a></p> 
<p id="1)%E6%8C%89%E8%A1%8C%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px"><a href="#1%29%E6%8C%89%E8%A1%8C%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96">1)按行进行初始化</a></p> 
<p id="2)%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px"><a href="#2%29%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96">2)连续赋值初始化</a></p> 
<p id="3)%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px"><a href="#3%29%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0%E5%88%9D%E5%A7%8B%E5%8C%96">3)部分元素初始化</a></p> 
<p id="4)%E5%85%A8%E5%91%98%E8%B5%8B0%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px"><a href="#4%29%E5%85%A8%E5%91%98%E8%B5%8B0%E5%88%9D%E5%A7%8B%E5%8C%96">4)全员赋0初始化</a></p> 
<p id="5)%E7%AC%AC%E4%B8%80%E7%BB%B4%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px"><a href="#5%29%E7%AC%AC%E4%B8%80%E7%BB%B4%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96">5)第一维不定义初始化</a></p> 
<p id="%C2%A0%E6%95%B0%E7%BB%84%E5%90%8D-toc" style="margin-left:40px"><a href="#%C2%A0%E6%95%B0%E7%BB%84%E5%90%8D"> 数组名</a></p> 
<p id="%C2%A0%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84-toc" style="margin-left:40px"><a href="#%C2%A0%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"> 二维字符数组</a></p> 
<p id="%C2%A0%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px"><a href="#%C2%A0%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"> 二维字符数组的定义</a></p> 
<p id="%C2%A0%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px"><a href="#%C2%A0%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"> 二维字符数组的初始化</a></p> 
<p id="%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%99%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8-toc" style="margin-left:80px"><a href="#%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%99%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8">二维字符教组的引用</a></p> 
<p id="%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:0px"><a href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a></p> 
<p id="%E7%BB%93%E5%B0%BE-toc" style="margin-left:0px"><a href="#%E7%BB%93%E5%B0%BE">结尾</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h1>数组概述</h1> 
<p>在程序设计中，为了方便处理数据把具有相同类型的若干变量按有序形式组织起来——称为数组。</p> 
<p class="img-center"><img alt="" height="212" src="https://images2.imgbox.com/9f/04/qvMqHaeV_o.png" width="621"></p> 
<p><strong>数组就是在内存中连续的相同类型的变量空间。</strong>同一个数组所有的成员都是相同的数据类型，并且所有的成员在内存中的地址是连续的。</p> 
<p style="text-align:justify">--我们可以将一个数组分解为多个数组元素：这些数组元素可以是基本数据类型或构造类型。</p> 
<pre><code class="language-cpp">int a[100];  //基本数据类型
struct Stu p[100];    //构造
</code></pre> 
<p>（注：<strong>构造数据类型</strong>：数组类型、枚举类型enum、指针类型、引用类型、结构体struct、联合体union（又称联合，共用体）、class类等。）</p> 
<p style="text-align:justify">--按数组元素类型的不同，数组可分为：数值数组、字符数组、指针数组、结构数组等类别。</p> 
<p></p> 
<pre><code class="language-cpp">int a[100] ;    //数值数组
char s[100] ;    //字符数组
char *p[100] ;    //指针数组
struct Peo n[100] ;    //结构数组
</code></pre> 
<p>数组元素下标的个数也称为维数，我们可以根据维数的不同，将数组分为一维数组、二维数组、三维数组...... 我们在通常情况下将一维数组以上的数组称作多维数组 。</p> 
<h1 id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</h1> 
<h2 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">如何使用一维数组</h2> 
<p>一维数组的定义包括以下几点要求：</p> 
<ol>
<li>数组名字符合标识符的书写规定(数字、英文字母、下划线) 。</li>
<li>数组名不能与其它变量名相同 。</li>
<li>方括号[]中常量表达式表示数组元素的个数 。</li>
</ol> 
<pre><code class="language-cpp">//方括号中的数量是其数组所包含元素，但其下标应该从0开始 。

a[3] 包含 a[0], a[1], a[2] 三个元素

//0， 1， 2分别表示其元素下标 。</code></pre> 
<p>好了，你已经掌握了一维数组的使用，下面就来练习以下一位数组的创建以及赋值吧。</p> 
<p>代码如下; </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main()
{
	int a[100] ;    //在这里我们定义了一个数组a，a有100个成员，每个成员都是int类型
	//没有a这个变量，a是数组的名字，但不是变量名，它是常量
	
	int i = 0;
	for (i = 0; i &lt; 100; i++)
	{
		a[i] = i; //给数组赋值 让a[0] = 0, a[1] = 1 ... a[i] = i ;
	}

	//遍历数组，输出每个成员的值
	for (i = 0; i &lt; 100; i++)
	{
		printf("%d ", a[i]);
        printf("n");
	}
	printf("n");

	return 0;
}
</code></pre> 
<h2 id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">一维数组的初始化</h2> 
<p style="margin-left:0">我们在定义数组的同时进行赋值，就叫做初始化。如果<strong>全局数组</strong>不做初始化，那么编译器将其初始赋值为零。但是<strong>局部数组</strong>如果不进行初始化，那么其内容将为随机值。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int b[5] ;	//定义全局数组 

int main()
{
	int a[5] = { 1, 2, 3, 4, 5 }	;	//定义一个数组并进行初始化 
	int c[5] ;	//定义局部数组
	int d[]	= {1, 2, 3}	;	//如果[]中不定义元素个数，定义时必须初始化 
	int e[5] = { 0 };//所有的成员都设置为0
	
	printf("%dn", a[0]) ;
	printf("%dn", b[0]) ;
	printf("%dn", b[2]) ;
	printf("%dn", c[0]) ;
	printf("%dn", c[2]) ;
	
	return 0;
}</code></pre> 
<p>运行结果：</p> 
<p class="img-center"><img alt="" height="401" src="https://images2.imgbox.com/91/d5/oE1XvnkQ_o.png" width="886"></p> 
<p> 这个运行结果就很好的展示了我们上面所讲到的知识。</p> 
<h2 id="%E6%95%B0%E7%BB%84%E5%90%8D">数组名</h2> 
<p>一个数组方括号外的就是该数组的数组名，例如;a[10] , a就是该数组的数组名。<strong>数组名是一个地址的常量，代表数组中首元素的地址。</strong></p> 
<p>下面案例中我们会用到一个函数，那么在这里我们就提前为大家普及一下，sizeof（）函数。</p> 
<p>sizeof 是一个关键字，它是一个编译时运算符，用于判断变量或数据类型的<strong>字节大小</strong>。sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。</p> 
<p>sizeof的语法：</p> 
<pre><code class="language-cpp">sizeof (object) ;</code></pre> 
<p>其中object是我们要去计算大小的数据类型，这些数据类型包括类、结构、共用体和其他用户自定义数据类型。</p> 
<p>好了，了解那么多之后我们就看一下这串代码吧。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main()
{
	int a[5] = { 1, 2, 3, 4, 5 };	//定义一个数组并初始化所有成员变量 

	printf("%pn", a) ;		//数组名是一个地址的常量，代表数组中首元素的地址。 
	printf("%pn", &amp;a[0]) ;	// a和a[0]的地址是相同的 

	int n = sizeof(a) ; 		//数组占用内存的大小，5个int类型，5 * 4  = 20
	int n0 = sizeof(a[0]) ;		//数组第0个元素占用内存大小也就是这个数组中每个元素内存的大小。 

	int i = 0;
	for (i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++)	// sizeof(a) / sizeof(a[0]就是数组中元素个数
	{
		printf("%d ", a[i]);
	}
	printf("n");

	return 0;
}</code></pre> 
<p>输出结果： </p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/80/48/guq9pB1g_o.png" width="1200"></p> 
<p>根据输出结果我们就能证实： 数组名代表数组中首元素的地址。</p> 
<p>代码中出现的（ sizeof(a) / sizeof(a[0] ）这个就是利用整个数组的大小与数组中单个元素的大小相除就可以得到我们数组中的元素了 。</p> 
<h2 id="%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%99%E7%BB%84">一维字符教组</h2> 
<p>一维字符数组一般用于存储和表示一个字符串，在 C 语言中，一般以空字符 '0' (ASCII 值为 0)作为字符串结束的标志。</p> 
<h3 id="%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%99%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89">一维字符教组的定义</h3> 
<p>一维字符数组定义与一维数组相差不大，其格式为：</p> 
<pre><code class="language-cpp">char 数组名[数组大小] ;</code></pre> 
<p>例如：</p> 
<pre><code class="language-cpp">char a[10] ;</code></pre> 
<p>该语句定义了一个一维字符数组 a，大小为 10，即占 10 个字符变量空间，最大可存储长度为 9 的字符串（第 10 个字符为 ''）。由于没有显式给每个字符变量赋值，故<strong>每个字符变量为随机值</strong>。</p> 
<h3 id="%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96">一维字符数组初始化</h3> 
<p>以为字符数组在初始化时可以采用单个字符逐个赋值的方式初始化，也可以使用字符串初始化的方式。</p> 
<p> <strong>1）逐个字符赋值</strong></p> 
<p>我们在逐个字符赋值的时候可能会出现以下三种情况。</p> 
<p><strong>a.当字符个数少于数组空间大小时</strong></p> 
<p>比如：</p> 
<pre><code class="language-cpp">char a[8] = {'h','e','l','l','o'} ;    //始值个数5小于数组a空间个数8</code></pre> 
<p>该语句定义了含 8 个字符变量的一维字符数组a，前 5 个字符变量分别显式初始化为 'h'，'e'，'l'，'l'，'o' 等 5 个字符，后 3 个字符变量为空字符 ''。</p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="114" src="https://images2.imgbox.com/f8/35/jJl0f9ZM_o.png" width="954"> 
  <figcaption>
    储存形式图 
  </figcaption> 
 </figure> 
</div> 
<p>当字符数组中含有字符串结束字符 '' 时，这时我们就可以使用 printf 函数和格式控制符 %s，输出该字符数组中的字符串 。其中格式控制符 %s，从输出列表中的该地址开始，到第一次遇到 '' 为止，这之间的字符全部输出。</p> 
<pre><code class="language-cpp">printf ("%s”，a) ;</code></pre> 
<p>并且我们在进行一维数组初始化时，其第一维大小可以省略 。</p> 
<pre><code class="language-cpp">char a[] = {'h','e','l','l','o'} ;</code></pre> 
<p>而这时储存的形式就变成了这样：</p> 
<p class="img-center"><img alt="" height="116" src="https://images2.imgbox.com/9e/ec/IrAJbQYr_o.png" width="949"></p> 
<p>这时数组中就不存在了，也就是说我们不可以使用不能使用%s去进行输出了。 所以char a[8] = {'h','e','l','l','o'}  与 char a[] = {'h','e','l','l','o'} 并不是等价关系。</p> 
<p><strong>b.当字符个数等于数组空间大小时</strong></p> 
<p>比如：</p> 
<pre><code class="language-cpp">char a[5]={'h','e','l','l','o'} ;    //初值个数5等于数组大小5</code></pre> 
<p> 此语句的执行结果如下图：</p> 
<p class="img-center"><img alt="" height="116" src="https://images2.imgbox.com/b1/51/jjk7dpTX_o.png" width="971"></p> 
<p> 可以发现，这时char a[5]={'h','e','l','l','o'} 与 char a[] = {'h','e','l','l','o'}就成为了等价关系。同样该字符数组中不包含字符串结束标志 ''，故不能使用 printf("%s"，c); 输出其中的字符串。</p> 
<p>所以对于这种数组，我们通常会采用for循环的形式去输出该字符数组。</p> 
<pre><code class="language-cpp">int i;
for(i=0;i&lt;5;i++) 
{
    printf ("%c",a[i]) ;
}

    </code></pre> 
<p><strong>c.当字符个数多于空间大小时</strong></p> 
<p>我们在初始化的时候，当字符个数多于空间大小时，编译时报错。</p> 
<pre><code class="language-cpp">char a[4] = {'h','e','l','l','o'}; //初值个数5大于数组大小4</code></pre> 
<p>报错： </p> 
<p class="img-center"><img alt="" height="147" src="https://images2.imgbox.com/2a/80/OlY63g6t_o.png" width="1200"></p> 
<p><s>                                                                                                                                                           </s></p> 
<p><strong>2）字符串初始化赋值</strong></p> 
<p>在 C 语言中，字符串一般是指含有字符串结束符 '' 的若干个字符的集合。而使用<strong>双引号</strong>括起来的字符串常量，默认隐含字符串结束符 ''。</p> 
<pre><code class="language-cpp">char a[15] = {"Hello World"}; //注意该数组大小应足够大 不然会报错</code></pre> 
<p>并且我们在用字符串对字符数组初始化时，一般大括号可以去掉，即:</p> 
<pre><code class="language-cpp">char a[15] = "Hello World"  ;</code></pre> 
<p>这时我们的语句的等价关系就是：</p> 
<pre><code class="language-cpp">char a[15] = {"Hello World"} ;
//等价于	
char a[15] = "Hello World"  ; 
//等价于
char a[15]= {'H','e','l','l','o',' ','W','o','e','l','d','','','',''} ; 
//等价于
char a[15]= {'H','e','l','l','o',' ','W','o','e','l','d',''} ;
//等价于
char a[15]= {'H','e','l','l','o',' ','W','o','e','l','d'} ;</code></pre> 
<p>其中，其数组大小都是我们指定的15 。 而储存形式也如下图所示。</p> 
<p class="img-center"><img alt="" height="242" src="https://images2.imgbox.com/44/3e/BubPuY1g_o.png" width="1200"></p> 
<p> 为了防止字符个数超出数组空间的现象，我们在采用字符串对字符数组进行初始化时，一般省略一维数组空间的大小，即:</p> 
<pre><code class="language-cpp">char a[] = {"Hello World"} ;</code></pre> 
<p>该数组中除了存储字符串中的 11 个有效字符外，还自动在字符串的结尾存储 '' 字符。所以该数组的大小为 12。其存储形式如下所示。</p> 
<p class="img-center"><img alt="" height="185" src="https://images2.imgbox.com/08/9c/NRV2eTQO_o.png" width="1200"></p> 
<p> 为节省空间以及书写方便防止不必要的失误，当我们采用用字符串对字符数组初始化时，一般均省略其一维的大小。</p> 
<h3 id="%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8">一维字符数组的引用</h3> 
<p>字符数组中的每一个元素都是一个字符，所以我们可以使用下标的形式来访问数组中的每一个字符。</p> 
<pre><code class="language-cpp">char a[]="abcd" ;</code></pre> 
<p>定义了一个一维字符数组 a，用字符串常量对其初始化，该a数组大小为 5，前 4 个元素的值分别为 'a'、'b'、'c'、'd'，第 5 个元素的值为 ''。其存储形式如下所示。</p> 
<p class="img-center"><img alt="" height="259" src="https://images2.imgbox.com/e8/83/VGVAFkbm_o.png" width="1200"></p> 
<p>我们可以使用 a[i] 引用该数组中的每个元素，例如：</p> 
<pre><code class="language-cpp">int i;
for(i=0;c[i]!='';i++) //当前i号位置的字符变量只要不是结束符就输出
    printf("%c",a[i]) ;</code></pre> 
<p> 其中for循环使用 '' 作为判断依据也可以很好的避免了计算长度所带来的复杂程度。</p> 
<h1 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</h1> 
<p>当数组元素具有两个下标时, 该数组称为二维数组。 二维谁可以看做具有行和列的平面数据结构。</p> 
<h2 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">如何使用二维数组</h2> 
<p>二维数组定义的一般形式为：</p> 
<pre><code class="language-cpp">类型说明符 数组名[常量表达式1][常量表达式2]</code></pre> 
<p>其中常量表达式1表示第一维下标的长度，常量表达式2 表示第二维下标的长度。 </p> 
<p>其命名规则与一维数组的命名规则相同。比如：</p> 
<pre><code class="language-cpp">int a[3][4] ;</code></pre> 
<p>第一行表示定义了一个 3×4，即 3 行 4 列总共有 12 个元素的数组 a。这 12 个元素的名字依次是：a[0][0]、a[0][1]、a[0][2]、a[0][3]；a[1][0]、a[1][1]、a[1][2]、a[1][3]；a[2][0]、a[2][1]、a[2][2]、a[2][3]；</p> 
<p class="img-center"><img alt="" height="172" src="https://images2.imgbox.com/1d/14/J0iaP4ni_o.png" width="510"></p> 
<p> 与一维数组相同，二维数组的行序号和列序号的下标都是从 0 开始的。元素 a[i][j] 表示第 i+1 行、第 j+1 列的元素。数组 int a[m][n] 最大范围处的元素是 a[m–1][n–1]。所以我们在日常引用数组元素时应该注意，下标值应在定义的数组大小的范围内。</p> 
<p>在C语言中，二维数组进行存放时，是按行进行存放的，就例如上文中的数组a，就是先存放a[0]行，再存放a[1]行、a[2]行，并且每行有四个元素，也是从0-3依次存放的。</p> 
<p>对于二维数组而言，其只是在概念上是二维的：其下标在两个方向上变化，所以对其访问一般需要两个下标。</p> 
<p style="margin-left:0">实际上在内存中并不存在二维数组，二维数组实际的硬件存储器是连续编址的，也就是说内存中只有一维数组，在放完一行元素之后顺次放入第二行元素，与一维数组的存放方式相同其内存地址依旧是连续的。</p> 
<p>下面我们来看下这串代码：</p> 
<p>要求，创建一个3×4的数组，并按照数组存放方式去从1开始依次递增赋值。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main()
{
	int a[3][4];	//定义二维数组 
	
	/*
	这个二维数组由三个一维数组组成
	这三个一维数组的数组名分别是 a[0],a[1],a[2] 
	而这个一维数组是 int [4]
	*/ 

	int i = 0;
	int j = 0;
	int num = 0;
	
	for (i = 0; i &lt; 3; i++)		//for循环给数组每个元素赋值
	{
		for (j = 0; j &lt; 4; j++)
		{
			a[i][j] = num++;
		}
	}

	for (i = 0; i &lt; 3; i++)
	{
		for (j = 0; j &lt; 4; j++)
		{
			printf("%d	 ", a[i][j]) ;	//输出每个成员的值 
		}
		printf("n");
	}

	return 0;
}</code></pre> 
<p> 运行结果：</p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/7d/ec/DrqlpSh7_o.png" width="1200"></p> 
<h2 id="%C2%A0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"> 二维数组的初始化</h2> 
<p>二维数组初始化的形式为:</p> 
<pre><code class="language-cpp">数据类型 数组名[常量表达式1][常量表达式2] = { 初始化数据 } ;</code></pre> 
<p>我们可以用下面的方法对二维数组进行初始化。 </p> 
<h3 id="1)%E6%8C%89%E8%A1%8C%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96">1)按行进行初始化</h3> 
<p>在 { } 内部再按照行数用 {}二次进行分开去初始化数组。其中行与行之间的{}要用逗号隔开；代码中{1，2，3，4}为第一行数组初始化；{5，6，7，8}为第二行数组初始化；{9，10，11，12}为第三行数组初始化。</p> 
<pre><code class="language-cpp">int a[3][4] = {<!-- -->{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};</code></pre> 
<h3 id="2)%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96">2)连续赋值初始化</h3> 
<p>连续赋值就是将 { } 中的数据依次赋值给数组中的各元素。其赋值顺序与二维数组存放顺序是相同的。就比如a[3][4]数组初始化，先从a[0]行a[0][0]元素开始到a[0][3]元素之后再到a[1]行a[1][0]元素开始.......最终到a[2][3]为止。</p> 
<pre><code class="language-cpp">int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};</code></pre> 
<h3 id="3)%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0%E5%88%9D%E5%A7%8B%E5%8C%96">3)部分元素初始化</h3> 
<p>我们在对二维数组进行赋值的时候<span style="background-color:#ffffff">可以只给数组中部分元素赋初值，那么未初始化的元素则为0。</span></p> 
<pre><code class="language-cpp">int a[3][4] = { 1, 2, 3, 4  } ;
int a[3][4] = {<!-- -->{1, 2}, {5}, {9}};</code></pre> 
<p>第一行是只对二维数组的第一行进行初始化，其余行则为0。</p> 
<p>第二行是对第一行的前两个元素赋值、第二行和第三行的第一个元素赋值。其余元素自动为 0。</p> 
<p>上面两种情况初始化后的结果分别是：</p> 
<p></p> 
<p class="img-center"><img alt="" height="652" src="https://images2.imgbox.com/38/61/tDQoDbjk_o.png" width="1200"></p> 
<h3 id="4)%E5%85%A8%E5%91%98%E8%B5%8B0%E5%88%9D%E5%A7%8B%E5%8C%96">4)全员赋0初始化</h3> 
<p>二维数组“清零”，也就是将里面每一个元素都赋值为零，这时就不需要跟之前一样将每个元素都赋值一遍了。</p> 
<pre><code class="language-cpp">int a[3][4]={0}；</code></pre> 
<h3 id="5)%E7%AC%AC%E4%B8%80%E7%BB%B4%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96">5)第一维不定义初始化</h3> 
<p>如果我们在定义的时候对所有的元素都赋初值的话，那么我们可以不指定第一维的长度，但第二维的长度不能省。这时系统会根据数据总数和第二维的长度算出第一维的长度。但这种省略的写法几乎不用，因为可读性差。</p> 
<pre><code class="language-cpp">int a[][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};</code></pre> 
<p></p> 
<p><strong>所以二维数组的初始化方式总结下来也就以下几种了：</strong> </p> 
<pre><code class="language-cpp">    //按行进行初始化 	
    int a[3][4] = {<!-- -->{ 1, 2, 3, 4 },{ 5, 6, 7, 8, },{ 9, 10, 11, 12 }} ;

	//连续赋值初始化
	int a[3][4] = { 1, 2, 3, 4 , 5, 6, 7, 8, 9, 10, 11, 12  } ;

	//部分元素初始化
	int a[3][4] = { 1, 2, 3, 4  } ;

	//全员赋0初始化
	int a[3][4] = {0} ;

	//第一维不定义初始化
	int a[][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
</code></pre> 
<h2 id="%C2%A0%E6%95%B0%E7%BB%84%E5%90%8D"> 数组名</h2> 
<p>和一维数组一样，数组名是一个地址的常量，代表数组中首元素的地址。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main()
{
	//定义了一个二维数组
	int a[3][4] = { 1, 2, 3, 4 , 5, 6, 7, 8, 9, 10, 11, 12  } ;

	//数组名为数组首元素地址，二维数组的第0个元素为一维数组
	printf("a = %pn", a) ;    //输出地址
	printf("a[0] = %pn", a[0]) ;
	
	//测二维数组所占内存空间
	//sizeof(a) = 3 * 4 * 4 = 48
	printf("sizeof(a) = %dn", sizeof(a)) ;

	//测第0个元素所占内存空间
	printf("sizeof(a[0]) = %dn", sizeof(a[0]) ) ;

	//测第0行0列元素所占内存空间
	printf("sizeof(a[0][0]) = %dn", sizeof(a[0][0])) ;

	return 0;
}
</code></pre> 
<p> 运行结果：</p> 
<p class="img-center"><img alt="" height="639" src="https://images2.imgbox.com/a3/ec/o21LtqZd_o.png" width="1200"></p> 
<p>通过运行结果我们可以看出，数组名a的地址也就是二维数组中a[0][0]的地址。以及每个int元素所占内存是4，如果要测量每行所占内存只需输入一个下标即可。</p> 
<p>于是我们就可以用内存大小的比值去计算出二维数组行数和列数。具体计算操作如下：</p> 
<pre><code class="language-cpp">	//求二维数组行数
	printf("i = %dn", sizeof(a) / sizeof(a[0])) ;

	// 求二维数组列数
	printf("j = %dn", sizeof(a[0]) / sizeof(a[0][0])) ;

	//求二维数组行*列总数
	printf("n = %dn", sizeof(a) / sizeof(a[0][0])) ;
</code></pre> 
<h2 id="%C2%A0%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"> <strong>二维字符数组</strong>
</h2> 
<p>二维字符数组是用来存放字符串, 二维字符数组每一行可以看做一维字符数组, 即二维字符数组的每一行可以存放一个字符串。</p> 
<h3 id="%C2%A0%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"> <strong>二维字符数组的定义</strong>
</h3> 
<p>二维字符数组的定义与一般二维数组的定义方式相同,只是要使用char数据类型去进行定义。</p> 
<pre><code class="language-cpp">char 数组名[第一维大小][第二维大小];</code></pre> 
<p>例如： </p> 
<pre><code class="language-cpp">char a[3][4] ;</code></pre> 
<p>二维字符数组 a 有3行4列, 每一行可以存放长度小于或等于3的字符串(原因：不要忘记要给字符串结束标识符留一个位置)。 </p> 
<h3 id="%C2%A0%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"> <strong>二维字符数组的初始化</strong>
</h3> 
<p>其与二维数组的初始化方式大致相同，其也可以在定义时初始化。通常情况下，二维数组的每一行分别使用一个字符串进行初始化。</p> 
<pre><code class="language-cpp">char a[2][6] = {"Hello","C++" } ;
char a[][6] = {"Hello","C++"} ;//第二维同样不可省略

//等价于
char a[2][6] = {<!-- -->{"Hello"},{"C++"} } ;</code></pre> 
<p>以上三条初始化语句中以及等价关系中，二维数组的第一维大小均可省略。数组 a 的逻辑结构如下所示： </p> 
<p class="img-center"><img alt="" height="178" src="https://images2.imgbox.com/e3/45/iKw4sSgF_o.png" width="923"></p> 
<p>a由于在二维字符数组每个字符串单独占一行, 所以可以用 a[n] 引用该二维数组字符中第 n 行的字符串；也可以用 a[i][j] 引用某行某列中的单独一个字符串 。 </p> 
<h3 id="%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%99%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8">二维字符教组的引用</h3> 
<p>在平时使用中，可以使用行下标和列下标引用二维字符数组中的每个元素（字符），例如：</p> 
<pre><code class="language-cpp">printf ("%c",a[1][4]) ;     //输出1行4列元素
scanf ("%c",&amp;a[2][3]) ;     //输入一个字符到2行3列元素中
a[2][0]='B' ;     //把字符赋值给2行0列元素
printf ("%s",a[1]) ;     //c[1]为第2行的数组名（首元素地址）
scanf ("%s",a[2]) ;     //输入字符串到c[2]行，从c[2]行的首地址开始存放</code></pre> 
<p>下面这些是我们在使用时经常与遇见的错误，这里我给大家列出来了几条： </p> 
<pre><code class="language-cpp">a[0][0]="A" ;     //行、列下标表示的为字符型元素，不能使用字符串赋值
printf ("%c",a[2]) ;      //a[2]为第3行的首地址，不是字符元素，故不能用%c</code></pre> 
<h1 id="%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</h1> 
<p>多维数组我们平时见到的其实并不多，所以在这里并不做强制要求，如果感兴趣的朋友可以了解一下。</p> 
<p style="margin-left:0">多维数组的定义与二维数组类似，其语法格式具体如下：</p> 
<pre><code class="language-cpp">数组类型修饰符 数组名 [n1][n2]…[nn];</code></pre> 
<pre><code class="language-cpp">int a[3][4][5] ;	//定义三维数组 
int b[4][6][7][3] ;		//定义四维数组 </code></pre> 
<p> 这里我们拿三维数组来进行举例讲解：</p> 
<p style="margin-left:0">其数组的名字是a，数组的长度为3，每个数组的元素又是一个二维数组，这个二维数组的长度是4，并且这个二维数组中的每个元素又是一个一维数组，这个一维数组的长度是5，元素类型是int。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main()
{
	//定义三维数组 
	int a[3][4][5] = 
		{ { { 1, 2, 3, 4, 5 }, { 6, 7, 8, 9, 10 }, { 0 }, { 0 } }, { { 0 }, { 0 }, { 0 }, { 0 } }, { { 0 }, { 0 }, { 0 }, { 0 } } };

	int i, j, k;
	for (i = 0; i &lt; 3; i++)
	{
		for (j = 0; j &lt; 4; j++)
		{
			for (k = 0; k &lt; 5; k++)
			{
				printf("%d, ", a[i][j][k]);	//输出 
			}
			printf("n");
		}
	}
	return 0;
}
</code></pre> 
<h1 id="%E7%BB%93%E5%B0%BE">结尾</h1> 
<p>好啦！到这里数组的基本知识也所剩无几了，如果还有什么不理解的地方可以在下方评论区随便留言，我看到后会及时的回复，当然只学这些数组知识是仅仅不够的，接下来我会出一期数组的实战强训练用于加强对本篇数组知识的学习以及强化一些深度知识，在那里就没有太多的知识点了，我会将一些数组中常见的题目（逆序，排序等），以及与数组有关的一些代码操作给大家讲解并附上代码供大家学习参考。如果大家感兴趣还请关注一下本人，本人会不定期出一些知识讲解博文，万分感谢。</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>