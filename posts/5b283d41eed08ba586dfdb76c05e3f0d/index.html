<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C语言实现 扫雷游戏 | 简单项目 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言实现 扫雷游戏 | 简单项目</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <h2 id="main-toc"><strong>目录</strong></h2> 
<h2 id="%E7%BB%84%E6%88%90-toc" style="margin-left:0px"><a href="#%E7%BB%84%E6%88%90" title="文件组成">文件组成</a></h2> 
<h2 id="test.c%20%E6%B8%B8%E6%88%8F%E4%B8%BB%E9%A2%98%E6%A1%86%E6%9E%B6%C2%A0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0-toc" style="margin-left:0px"><a href="#test.c%20%E6%B8%B8%E6%88%8F%E4%B8%BB%E9%A2%98%E6%A1%86%E6%9E%B6%C2%A0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0" title="test.c 游戏主题框架         ">test.c 游戏主题框架         </a></h2> 
<h2 id="print.h%20%E5%85%B3%E4%BA%8E%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%A3%B0%E6%98%8E-toc" style="margin-left:0px"><a href="#print.h%20%E5%85%B3%E4%BA%8E%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%A3%B0%E6%98%8E" title="infor.h 信息模块函数的声明">infor.h 信息模块函数的声明</a></h2> 
<h2 id="%C2%A0print.c%20%E5%85%B3%E4%BA%8E%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px"><a href="#%C2%A0print.c%20%E5%85%B3%E4%BA%8E%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9A%E4%B9%89" title=" infor.c 信息模块的函数定义与功能实现"> infor.c 信息模块的函数定义与功能实现</a></h2> 
<h2 id="game.h%20%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E-toc" style="margin-left:0px"><a href="#game.h%20%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E" title="game.h 游戏模块函数的声明">game.h 游戏模块函数的声明</a></h2> 
<h2 id="game.c%20%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px"><a href="#game.c%20%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0" title="game.c 游戏模块的函数定义与功能实现">game.c 游戏模块的函数定义与功能实现</a></h2> 
<h2 id="%E7%BB%93%E5%B0%BE%20%E6%BA%90%E7%A0%81-toc" style="margin-left:80px"><a href="#%E7%BB%93%E5%B0%BE%20%E6%BA%90%E7%A0%81" title="结尾 源码">结尾 源码</a></h2> 
<hr id="hr-toc">
<p></p> 
<blockquote> 
 <h1 id="%E7%BB%84%E6%88%90">文件组成</h1> 
</blockquote> 
<p>要写一个扫雷游戏，由于体量较大，我们打算分三个.c 文件(源文件) 来定义函数，实现代码，两个 .h 文件（头文件） 来实现我们.c文件中函数的声明和库函数头文件的引用。</p> 
<p>三个 源文件 : test.c , game.c , print.c</p> 
<p>两个头文件：game.h , print.h</p> 
<p><span style="color:#fe2c24"><strong>文件的源码 我会放在结尾以供大家学习</strong></span></p> 
<blockquote> 
 <h1 id="test.c%20%E6%B8%B8%E6%88%8F%E4%B8%BB%E9%A2%98%E6%A1%86%E6%9E%B6%C2%A0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0">test.c 游戏主题框架         </h1> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include "game.h"  /这里引上我们编写好的头文件
#include "infor.h"/里面有我们所有自定函数的声明和库函数头文件的引用

void menu() {/游戏主界面的菜单
	printf("***************************n");
	printf("*******   1. PLAY   *******n");
	printf("*******   0. EXIT   *******n");
	printf("*******   2. INFOR  *******n");
	printf("***************************n");

}

int main() {
	srand((unsigned int)time(NULL));/由于游戏中布置雷需要随机数，我们在这里就将它初始化
	int input;/用来接收玩家输入
	do {/主题采用循环结构 当玩家结束游戏后可以进行选择进入或者退出
		menu();/打印菜单
		printf("请选择序号:&gt;");/提示玩家选择
		scanf("%d", &amp;input);
		switch (input) {
		case 1:
			game();/进入游戏模块
			break;
		case 0:
			printf("退出游戏n");/退出游戏
			break;
		case 2:
			INFOR();/进入信息菜单 查看规则以及其他信息
			break;
		default:
			printf("输入错误 重新输入n");/输入错入提示
		}

	} while (input);/当玩家输入0 退出程序

	return 0;
}</code></pre> 
<p>此时我们程序运行起来 就会是这个样子</p> 
<p> <img alt="" height="259" src="https://images2.imgbox.com/9f/1a/Zsj9Vcgq_o.png" width="388"></p> 
<p></p> 
<blockquote> 
 <h1 id="print.h%20%E5%85%B3%E4%BA%8E%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%A3%B0%E6%98%8E">infor.h 信息模块函数的声明</h1> 
</blockquote> 
<pre><code class="language-cpp">#pragma once

void INFOR();/信息模块入口
void menu_in();/信息模块的菜单
void game_rules();/游戏规则说明
void infor();/补充信息

</code></pre> 
<blockquote> 
 <h1 id="%C2%A0print.c%20%E5%85%B3%E4%BA%8E%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9A%E4%B9%89"> infor.c 信息模块的函数定义与功能实现</h1> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;/引上库函数的头文件


void menu_in() {/只是当玩家选择 1 后显示的菜单
	printf("1.游戏规则n");
	printf("2.制作信息n");
	printf("3.奖励n");
	printf("0.返回n");

}
void game_rules() {/游戏规则
	printf("n踩点和标记需输入对应 行和列如 第一行第一列 应该输入 "1 1"n猜到雷会被炸死,恐怖至极，骨灰都找不到!!!n踩到非雷会显示以它中心3X3矩形范围内雷的个数.n如果显示0会自动帮你展开n正确标记出所有雷,或者踩完所有非雷点即可获胜.nthats it...nn");
}
void infor() {/其他信息这里可以看自己喜好添加
	printf(".一步一步按提示来 不然要炸nn");
}
void reward() {/奖励
	printf("完成1级难度即可获得:&gt; ");
	printf("游戏作者的大拇指！！！n");

}

以上是这一模块函数的定义
——————————————————————————————————————————————————————
以下是则以模块的的框架
跟主界面类似 用到循环体 以实现重复选择

void INFOR() {/这一模块的框架
	menu_in();/菜单
	int input;
	do {
		printf("请选择序号:&gt;");
		scanf("%d", &amp;input);
		switch (input) {
		case 1:
			game_rules();/规则
			break;
		case 2:
			infor();/信息
			break;
		case 3:
			reward();/奖励
			break;
		case 0:
			break;/退出循环，回到主界面
        default:
			printf("输入错误 重新输入n");/输入错入提示
		}
	} while (input);/可以重复选择
}
结束后回到主界面

</code></pre> 
<p>这时 如果你运行程序 并在主界面输入 2 并按下回车</p> 
<p>将会是这样</p> 
<p><img alt="" height="654" src="https://images2.imgbox.com/ab/e5/uuxUhhbC_o.png" width="737"></p> 
<p>如继续输入 0 就回到主界面  </p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/9f/1a/Zsj9Vcgq_o.png" width="388"></p> 
<p>至此 扫雷游戏除了游戏 就都编写完成了(狗头)</p> 
<blockquote> 
 <h1 id="game.h%20%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E">game.h 游戏模块函数的声明</h1> 
</blockquote> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
#include&lt;Windows.h&gt;
#include&lt;string.h&gt;

/定义 棋盘行列的全局变量
为了方便 我们定义11X11的棋盘 但只使用 其中9X9的空间
#define ROW 9 
#define COL 9 
#define ROWS 11
#define COLS 11

/扫雷游戏主体
void game();
/初始化棋盘的函数
void InitBoard(char Board[ROWS][COLS], int rows, int cols, char set);
/打印棋盘的函数
void DisplayBoard(char Board[ROWS][COLS], int row, int col);
/设置雷的函数
void SetMine(char Board[ROWS][COLS],int row,int col,int nub);
/玩家排雷(一直玩到结束，返回值为输赢结果)
char FindMine(char Board[ROWS][COLS], char show[ROWS][COLS], int row, int col,int nub);
/返回点周围雷的个数
char CountMine(char Board[ROWS][COLS],char[ROWS][COLS] ,int row, int col);
/将点展开
void Extend(char Board[ROWS][COLS], char show[ROWS][COLS], int row, int col);
/判断赢没赢(赢返回 1 ，没赢返回 0 )
int Is_win(char Board[ROWS][COLS],char show[ROWS][COLS], int row, int col,int nub);
/游戏胜利 或 失败后延时打印结果
void SleepPrint(char* p);</code></pre> 
<blockquote> 
 <h1 id="game.c%20%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">game.c 游戏模块的函数定义与功能实现</h1> 
</blockquote> 
<p>为了方便 我们定义两个二维数组 来分别代表 用户看到的棋盘数字 ，标记 （排查雷的信息）的棋盘 和 存放雷的棋盘 里面 只有 雷。</p> 
<p><strong>用户棋盘show board:</strong></p> 
<p><strong> </strong><img alt="" height="318" src="https://images2.imgbox.com/9e/c2/XjDTR7w9_o.png" width="334"></p> 
<p><strong>存雷棋盘：</strong></p> 
<p><strong><img alt="" height="319" src="https://images2.imgbox.com/f2/ad/q4GeudgZ_o.png" width="317"> </strong></p> 
<p><strong>玩家可以选择是要踩 还是 要 标记，把所有非标记的雷周围的点都踩完 就赢了：</strong></p> 
<p><img alt="" height="364" src="https://images2.imgbox.com/a0/a5/pGgkzDEF_o.png" width="412"></p> 
<p><strong>当玩家踩到非雷时 会显示 这个点 周围雷的个数：</strong></p> 
<p><strong><img alt="" height="345" src="https://images2.imgbox.com/2b/bf/vDUbk5tX_o.png" width="411"></strong></p> 
<p><strong>当这个点周围没有雷时 不会显示数字0，而是自动帮你展开 到周围有雷的位置:</strong></p> 
<p> <img alt="" height="343" src="https://images2.imgbox.com/78/63/1Y02ZPJT_o.png" width="364"></p> 
<p> 只有胜利 或者 被炸死从而结束游戏时 会 打印一次 存放雷的棋盘：</p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/b9/9e/2jhBcCO7_o.png" width="362"></p> 
<p></p> 
<p><span style="color:#956fe7"><strong> 代码如下 ：</strong></span></p> 
<p></p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"game.h"


/初始化棋盘的函数
void InitBoard(char Board[ROWS][COLS],int rows,int cols,char set) {
	int i;
	int j;
	for (i = 0; i &lt; rows; i++) {/将每个元素都设为0
		for (j = 0; j &lt; cols; j++) {
			Board[i][j] = set;
		}
	}
}
/打印棋盘的函数   
void DisplayBoard(char Board[ROWS][COLS], int row, int col) {
	int i;
	int j;
	
	printf("————扫雷游戏————n");
	for (j = 0; j &lt; 10; j++) {
		if (0 == j) {
			printf("%d  ", j);
			continue;
		}
		printf("%d ",j);
	}
	printf("nn");
	for (i = 1; i &lt;=row; i++) {
		printf("%d  ", i);
		for (j = 1; j &lt;= col; j++) {
			printf("%c ", Board[i][j]);
		}
		printf("n");
	}
	printf("————扫雷游戏————n");

}
</code></pre> 
<p>会打印如下棋盘</p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/9e/c2/XjDTR7w9_o.png" width="334"></p> 
<p></p> 
<pre><code class="language-cpp">/设置雷的函数
void SetMine(char Board[ROWS][COLS], int row, int col,int nub) {	 
	int i;
	int j;
	while (nub) { /nub为雷的个数
		 i = rand() % row + 1;/随机生成行
		 j = rand() % col + 1;/随机生成列
		if (Board[i][j] == '*') {/查重
			Board[i][j] = '#';/我们用 字符'＃'来表示雷
			nub--;/每设置一个雷 nub自减

		}
	}
}
/数雷的个数的函数
char CountMine(char Board[ROWS][COLS], char show[ROWS][COLS],int row, int col) {
	char count = '0';
	int i; int j;
	for (i = row - 1; i &lt; row + 2; i++) {

		for (j = col - 1; j &lt; col + 2; j++) {/排查点 周围 雷的个数
			
			if (Board[i][j] == '#') {
				count++;

			}
		}

	}
	return count;
	}
	
/当3X3范围内没有雷时 自动展开的函数
这里用到了递归，若周围没有雷就把这个点设成 空白字符 并自动把周围的点都踩了，直到周围有雷为止
void Extend(char Board[ROWS][COLS],char show[ROWS][COLS],int row,int col){
	show[row][col] = ' ';

	int i, j;
	for (i = row - 1; i &lt; row + 2; i++) {
		for (j = col - 1; j &lt; col + 2; j++) {
			
			if (show[i][j] == '*') {
				show[i][j] = CountMine(Board, show, i, j);
				if (show[i][j] == '0') {
					Extend(Board, show, i, j);
				}
			}
		}
		
	}
}
/判断 游戏的函状态的函数
int Is_win(char Board[ROWS][COLS],char show[ROWS][COLS], int row, int col,int nub) {
	int i,j;
	int count = 0;/数正确的标记
	int count0 = 0;/数标记的总个数
	int COUNT = 0;/数*号后面是雷的个数
	int COUNT0 = 0;/数*号的总个数
	for (i = 1; i &lt;=row; i++) {
		for (j = 1; j &lt;= col; j++) {
			if (show[i][j] == '!') {
				count0++;
				if (Board[i][j] == '#') {
					count++;
				}
			}if (show[i][j] == '*') {
				COUNT0++;
				if (Board[i][j] == '#') {
					COUNT++;


				}
			}
		}
	}
	if ((nub == count&amp;&amp;nub==count0)|| COUNT == COUNT0) { 
/如果标记出了所有雷 或者 正确标记了所有没踩了的雷 就代表胜利

		return 1;返回 1
	}
	else if (nub == count &amp;&amp; nub &lt;= count0) {
/如果有错误标记或者标记过多
		return 2;返回 2
	}
	/一切正常 但没赢 
	return 0; 返回 0 
}
/玩家 排雷或者标记的函数！
char FindMine(char Board[ROWS][COLS],char show[ROWS][COLS], int row,int col,int nub) {
	int a, b;
	int input=1;
	while (1) {
		printf("请选择是要踩(1)还是要标记(2):&gt;");/标记（插旗）或者 踩点
		scanf("%d", &amp;input);
		switch (input)/这里用switch语句来对玩家的输入 执行不同的语句
		{
		case 1:/ 若玩家输入 1 就是踩点 ，则执行一下语句
			printf("请输入要走的行列:&gt;");
			while (1) { /执行踩
				scanf("%d %d", &amp;a, &amp;b);
				if (a &gt; 0 &amp;&amp; a &lt; 10 &amp;&amp; b&gt;0 &amp;&amp; b &lt; 10) {
					if (show[a][b] != '*' &amp;&amp; show[a][b] != '!') {/查重
						printf("这个点 (%d行%d列) 已经踩过了,重新输入:&gt;", a, b);
						continue;
					}
					break;
				}
				else
					printf("输入错误，重新输入:&gt;");/输入错误提示 
			}
			if (Board[a][b] == '#') {/如果该点是雷，则失败，结束游戏
				return 'F';

			}
			else {
				show[a][b] = CountMine(Board, show, a, b);/如果不是雷，数周围雷的个数
				if (show[a][b] == '0') {/如果周围没有雷，调用自动展开函数来自动展开
					Extend(Board, show, a, b);
				}
			}
			if (1 == Is_win(Board, show, row, col, nub)) {/每次走完 判断是否已经赢下游戏
				DisplayBoard(show, row, col);/如果赢了就结束游戏
				return 'W';
			}
			
			DisplayBoard(show, row, col);/打印棋盘
		
			

			break;
		case 2://标记
/更踩点思路相似
			printf("请输入要标记的行列:&gt;");
			while (1) {
				scanf("%d %d", &amp;a, &amp;b);/行 列
				if (a &gt; 0 &amp;&amp; a &lt; 10 &amp;&amp; b&gt;0 &amp;&amp; b &lt; 10) {/判断坐标的合法性

					if (show[a][b] == '!') {/如果这是标记过的点 ，我们就把这个标记取消
						show[a][b] = '*';
/判断是否赢得游戏
						if (1 == Is_win(Board, show, row, col, nub)) {
							DisplayBoard(show, row, col);
							return 'W';
						}
/如果标记多了就提示
						if (2 == Is_win(Board, show, row, col, nub)) {
							printf("标记多了...");
						}
						
						break;
					}
					else {/如果是没标记过的点 我们就把这个点 标记上
/随后在检测是否赢得游戏
						show[a][b] = '!';
						if (1==Is_win(Board, show, row, col,nub)) {
							return 'W';
						}
						if (2 == Is_win(Board, show, row, col, nub)) {
							printf("标记多了...");
						}
						break;
					}
				}
				else {
					printf("输入错误,重新输入:&gt;");
				}
			}
			DisplayBoard(show, row, col);
			break;
/这里判断 最开始选择要踩还是标记那里 是否 输入错误
		default:
			printf("输入错误,重新输入:&gt;");
			printf("n");
		}
	}
	
}

/这是一个 延时打印 胜利图案的函数 增加游戏的趣味性
void SleepPrint(char* p) {
	int i;
	int len = strlen(p);
	for (i = 0; i &lt; len; i += 2) {
		printf("%c%c", *(p + i), *(p + i + 1));
		Sleep(600);
	}

}
这是游戏模块的主体框架
void game() {
	char Board[ROWS][COLS] = { 0 };//布置好雷的信息
	char show[ROWS][COLS] = { 0 };//排查出雷的信息
	InitBoard(Board, ROWS, COLS, '*');
	InitBoard(show, ROWS, COLS, '*');
	printf("请选择游戏难度(1~3):&gt;");
	int tmpe;
	int nub=0;
	do {
		scanf("%d", &amp;tmpe);
		switch (tmpe)
		{
		case 1:
			nub = 10;
			break;
		case 2:
			nub = 15;
			break;
		case 3:
			nub = 20;
			break;
		default:
			printf("输入错误,重新输入:&gt;");
			break;
		}
	} while (tmpe != 1 &amp;&amp; tmpe != 3 &amp;&amp; tmpe != 2);
	SetMine(Board, ROW, COL, nub);
	DisplayBoard(show, ROW, COL);
	
	char Result=FindMine(Board, show, ROW, COL,nub);
	switch (Result) {
	case 'F':/如果输了 就延时打印 “你被炸死了”
		SleepPrint("你被炸死了");
		for (int i = 0; i &lt; 3; i++) {
			printf(".");
			Sleep(600);
		}
		printf("n");
		DisplayBoard(Board, ROW, COL);
		break;
	case'W':/如果赢了就延时打印 “你赢了”

		SleepPrint("你赢了");
		for (int i = 0; i &lt; 3; i++) {
			printf("!");
			Sleep(600);
		}
		printf("n");
		DisplayBoard(Board, ROW, COL);
	}
}
/随后退出到 主界面 让玩家选择是退出程序 或是进入某个模块</code></pre> 
<p><span style="color:#956fe7">这样 ，我们的扫雷游戏的部分就 完成了 .</span></p> 
<blockquote> 
 <h3 id="%E7%BB%93%E5%B0%BE%20%E6%BA%90%E7%A0%81">结尾 源码</h3> 
</blockquote> 
<p><span style="color:#956fe7">希望这篇博客 能对大家有所帮助，祝看到这篇的博客的人都早日成为 </span><span style="color:#fe2c24">大牛！！!</span></p> 
<p><span style="color:#4da8ee"> 游戏的 源文件 头文件:&gt;</span></p> 
<p><span style="color:#4da8ee">        </span>                                        <a class="link-info has-card" href="https://gitee.com/leyi999/project.git" title=" 扫雷游戏https://gitee.com/leyi999/project.git"><span class="link-card-box"><span class="link-title"> 扫雷游戏https://gitee.com/leyi999/project.git</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/7b/75/hKyurVrU_o.png">https://gitee.com/leyi999/project.git</span></span></a></p> 
<p><span style="color:#4da8ee">        .</span></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>