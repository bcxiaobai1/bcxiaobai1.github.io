<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>汇编-ARMv8架构指令集 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">汇编-ARMv8架构指令集</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h2><strong>1. ARMv8寄存器体系</strong></h2> 
<h3>1.1 概述</h3> 
<p>ARMv8架构继承了ARMv7与之前处理器技术的基础，除了对现有的16/32bit的Thumb2指令支持外，也向前兼容了现有的A32(ARM 32bit)指令集，基于64bit的AArch64架构，除了新增A64(ARM 64bit)指令集外，也扩充了现有的A32(ARM 32bit)和T32(Thumb2 32bit）指令集，另外还新增加了CRYPTO(加密)模块支持。</p> 
<h4>1.2 特性</h4> 
<ol><li>ARMv8提供了AArch32 state和AArch64 state两种Execution State</li></ol> 
<table align="left" border="1" cellpadding="1" cellspacing="1" style="width:682px"><tbody>
<tr>
<td style="text-align:center">AArch 32</td>
<td style="width:392px">AArch 64</td>
</tr>
<tr>
<td>提供13个32bit通用寄存器R0-R12，一个32bit PC指针 (R15)、堆栈指针SP (R13)、链接寄存器LR (R14)</td>
<td style="width:392px">提供31个64bit通用寄存器X0-X30(W0-W30 低32位)，其中X30是程序链接寄存器LR</td>
</tr>
<tr>
<td>提供一个32bit异常链接寄存器ELR，用于Hyp mode下的异常返回</td>
<td style="width:392px">提供一个64bit PC指针、堆栈指针SPx 、异常链接寄存器ELRx</td>
</tr>
<tr>
<td>提供32个64bit SIMD向量和标量floating-point支持</td>
<td style="width:392px">提供32个128bit SIMD向量和标量floating-point支持</td>
</tr>
<tr>
<td>提供两个指令集A32(32bit)、T32(16/32bit)</td>
<td style="width:392px">定义ARMv8异常等级ELx(x&lt;4)，x越大等级越高，权限越大</td>
</tr>
<tr>
<td>兼容ARMv7的异常模型</td>
<td style="width:392px">定义一组PSTATE,用以保存PE(Processing Element)状态</td>
</tr>
<tr>
<td>协处理器只支持CP10CP11CP14CP15</td>
<td style="width:392px">没有协处理器概念</td>
</tr>
</tbody></table> 
<p></p> 
<p></p> 
<p><br>  </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h4>1.3 寄存器</h4> 
<p>​ 在ARM64架构下，CPU提供了33个寄存器, 其中前31个（0~30）是通用寄存器 (<code>general-purpose integer registers</code>)，最后2个(31,32)是专用寄存器（<code>sp</code>寄存器和 <code>pc</code> 寄存器)。</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:640px"><tbody>
<tr>
<th style="text-align:center">寄存器</th>
<th style="text-align:center">说明</th>
</tr>
<tr>
<td style="text-align:center">X0寄存器</td>
<td style="text-align:center">用来保存返回值（或传参）</td>
</tr>
<tr>
<td style="text-align:center">X1 ~ X7 寄存器</td>
<td style="text-align:center">用来保存函数的传参</td>
</tr>
<tr>
<td style="text-align:center">X8寄存器</td>
<td style="text-align:center">也可以用来保存返回值</td>
</tr>
<tr>
<td style="text-align:center">X9 ~ X28寄存器</td>
<td style="text-align:center">一般寄存器，无特殊用途</td>
</tr>
<tr>
<td style="text-align:center">x29(FP)寄存器</td>
<td style="text-align:center">用来保存栈底地址</td>
</tr>
<tr>
<td style="text-align:center">X30 (LR)寄存器</td>
<td style="text-align:center">用来保存返回地址</td>
</tr>
<tr>
<td style="text-align:center">X31(SP) 寄存器</td>
<td style="text-align:center">用来保存栈顶地址</td>
</tr>
<tr>
<td style="text-align:center">X32(PC)寄存器</td>
<td style="text-align:center">用来保存当前执行的指令的地址</td>
</tr>
</tbody></table> 
<h2><strong>2 Exception Level</strong></h2> 
<h3>​ 2.1 ARMv8定义EL0-EL3共 4个Exception Level来控制PE的行为</h3> 
<p> Exception Level</p> 
<ul>
<li>ELx(x&lt;4)，x越大等级越高，执行特权越高</li>
<li>执行在EL0称为非特权执行</li>
<li>EL2 没有Secure state，只有Non-secure state</li>
<li>EL3 只有Secure state，实现EL0/EL1的Secure和Non-secure之间的切换</li>
<li>EL0 &amp; EL1 必须要实现，EL2/EL3则是可选实现</li>
</ul> 
<h3>2.2 Exception Level &amp; Security</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:649px"><tbody>
<tr>
<th style="text-align:center;width:201px">Exception Level</th>
<td style="text-align:center;width:447px"></td>
</tr>
<tr>
<td style="text-align:center;width:201px">EL0</td>
<td style="text-align:center;width:447px">Application</td>
</tr>
<tr>
<td style="text-align:center;width:201px">EL1</td>
<td style="text-align:center;width:447px">
<a href="http://lib.csdn.net/base/linux" title="Linux">Linux</a> kernel- OS</td>
</tr>
<tr>
<td style="text-align:center;width:201px">EL2</td>
<td style="text-align:center;width:447px">Hypervisor</td>
</tr>
<tr>
<td style="text-align:center;width:201px">EL3</td>
<td style="text-align:center;width:447px">Secure Monitor</td>
</tr>
<tr>
<td style="text-align:center;width:201px"><strong>Security</strong></td>
<td style="text-align:center;width:447px"></td>
</tr>
<tr>
<td style="text-align:center;width:201px">Non-secure</td>
<td style="text-align:center;width:447px">Non-secure EL0/EL1/EL2, 只能访问Non-secure memory</td>
</tr>
<tr>
<td style="text-align:center;width:201px">Secure</td>
<td style="text-align:center;width:447px">Secure EL0/EL1/EL3, 可以访问Non-secure memory &amp; Secure memory</td>
</tr>
</tbody></table> 
<h4></h4> 
<h2>1 汇编指令基础</h2> 
<h3>1.1 汇编指令格式</h3> 
<p><br><strong>​ ARM指令使用的是 三地址码 , 它的格式如下:</strong></p> 
<p>​ &lt;opcode&gt; {&lt;cond&gt;} {S} &lt;Rd&gt; , &lt;Rn&gt; , &lt;shifter_operand&gt;</p> 
<ul>
<li>opcode：操作码，也就是助记符，操作码，也就是助记符，说明指令需要执行的操作类型</li>
<li>cond：指令执行条件码，在编码中占4bit，0b0000 -0b1110</li>
<li>S：条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值</li>
<li>Rd：目标寄存器，A64指令可以选择X0-X30 or W0-W30</li>
<li>Rn：第一个操作数的寄存器，和Rd一样，不同指令有不同要求</li>
<li>shifter_operand：第二个操作数，可以是立即数，寄存器Rm和寄存器移位方式（Rm，#shit）</li>
</ul> 
<p>Cond项表明了指令的执行的条件，每一条ARM指令都可以在规定的条件下执行，每条ARM指令包含4位的条件码，位于指令的最高4位[31：28]。<br>     条件码共有16种，每种条件码用2个字符表示，这两个字符可以添加至指令助记符的后面，与指令同时使用。<br>     当指令的执行条件满足时，指令才被执行，否则指令被忽略。如果在指令后不写条件码，则使用默认条件AL（无条件执行）。<br>     <br>    <strong>指令的条件码</strong><br>     <br>     条 件 码      助记符后缀            标    志                含    义<br>     0000            EQ                    Z置位                相等equal<br>     0001            NE                    Z清零                不相等not equal<br>     0010            CS                    C置位                无符号数大于或等于Carry Set<br>     0011            CC                    C清零                无符号数小于<br>     0100            MI                    N置位                负数minus<br>     0101            PL                    N清零                正数或零plus<br>     0110            VS                    V置位                溢出<br>     0111            VC                    V清零                没有溢出<br>     1000            HI                    C置位Z清零           无符号数大于high<br>     1001            LS                    Z置位C清零           无符号数小于或等于less<br>     1010            GE                    N等于V               带符号数大于或等于<br>     1011            LT                    N不等于V             带符号数小于least<br>     1100            GT                    Z清零且（N等于V）    带符号数大于great<br>     1101            LE                    Z清零或（N不等于V）  带符号数小于或等于<br>     1110            AL                    忽略                 无条件执行all<br>     1111</p> 
<p></p> 
<h3><strong> 1.2 指令分类</strong></h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:656px"><tbody>
<tr>
<th style="width:185px">类型</th>
<th style="width:468px">Note</th>
</tr>
<tr>
<td style="width:185px">跳转指令</td>
<td style="width:468px">条件跳转、无条件跳转（#imm、register）指令</td>
</tr>
<tr>
<td style="width:185px">异常产生指令</td>
<td style="width:468px">系统调用类指令（SVC、HVC、SMC）</td>
</tr>
<tr>
<td style="width:185px">系统寄存器指令</td>
<td style="width:468px">读写系统寄存器，如 ：MRS、MSR指令 可操作PSTATE的位段寄存器</td>
</tr>
<tr>
<td style="width:185px">数据处理指令</td>
<td style="width:468px">包括各种算数运算、逻辑运算、位操作、移位(shift)指令</td>
</tr>
<tr>
<td style="width:185px">load/store内存访问指令</td>
<td style="width:468px">load/store {批量寄存器、单个寄存器、一对寄存器、非-暂存、非特权、独占}以及load-Acquire、store-Release指令 （A64没有LDM/STM指令）</td>
</tr>
<tr>
<td style="width:185px">协处理器指令</td>
<td style="width:468px">A64没有协处理器指令</td>
</tr>
</tbody></table> 
<h3>1.3 寻址方式</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:686px"><tbody>
<tr>
<th style="width:187px">类型</th>
<th style="width:133px">立即数偏移</th>
<th style="width:191px">寄存器偏移</th>
<th style="width:176px">扩展寄存器偏移</th>
</tr>
<tr>
<td style="width:187px">基址寄存器（无偏移）</td>
<td style="width:133px">{ base{，#0 } }</td>
<td style="width:191px"></td>
<td style="width:176px"></td>
</tr>
<tr>
<td style="width:187px">基址寄存器（+ 偏移）</td>
<td style="width:133px">{ base{，#imm } }</td>
<td style="width:191px">{ base，Xm{，LSL #imm } }</td>
<td style="width:176px">[base，Wm，(S|U)XTW {#imm }]</td>
</tr>
<tr>
<td style="width:187px">Pre-indexed（事先更新）</td>
<td style="width:133px">[ base，#imm ]!</td>
<td style="width:191px"></td>
<td style="width:176px"></td>
</tr>
<tr>
<td style="width:187px">Post-indexed（事后更新）</td>
<td style="width:133px">[ base，#imm ]</td>
<td style="width:191px">{ base },Xm</td>
<td style="width:176px"></td>
</tr>
<tr>
<td style="width:187px">PC-相对寻址</td>
<td style="width:133px">label</td>
<td style="width:191px"></td>
<td style="width:176px"></td>
</tr>
</tbody></table> 
<p></p> 
<h2><span style="background-color:#ff9900">2 跳转指令</span></h2> 
<p>跳转指令用于实现程序流程的跳转，在ARM程序中有两种方法可以实现程序流程的跳转：</p> 
<p></p> 
<h3>2.1 直接向程序计数器PC写入跳转地址值。</h3> 
<blockquote> 
 <p>通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用</p> 
 <p>MOV LR，PC ;将下一条指令地址写到LR</p> 
 <p></p> 
 <p>等类似指令，可以保存将来的返回地址值，从而实现在4GB连续的线性地址空间的子程序调用。</p> 
</blockquote> 
<h3>2.2 使用专门的跳转指令</h3> 
<blockquote> 
 <p>ARM指令集中的跳转指令可以完成从当前指令向前或向后的32MB的地址空间的跳转，包括以下4条指令：</p> 
</blockquote> 
<p><strong><span style="background-color:#cccccc">1.2.1、  </span><span style="color:#fe2c24"><span style="background-color:#cccccc">B</span></span><span style="background-color:#cccccc">指令</span></strong></p> 
<p><span style="color:#fe2c24">B</span>指令的格式为：</p> 
<blockquote> 
 <p><em><span style="color:#fe2c24">B</span>{条件}  目标地址</em></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24">B</span>指令是最简单的跳转指令。一旦遇到一个 B 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继续执行。<strong><span style="background-color:#ffd900">注意存储在跳转指令中的实际值是相对当前PC值的一个偏移量，而不是一个绝对地址</span></strong>，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是 24 位有符号数，左移两位后有符号扩展为 32 位，表示的有效偏移为 26 位(前后32MB的地址空间)。以下指令：</p> 
</blockquote> 
<pre><code class="language-cpp">B   Label         ；程序无条件跳转到标号Label处执行


CMP R1，＃0       ；当CPSR寄存器中的Z条件码置位时，程序跳转到标号Label处执行

BEQ Label      </code></pre> 
<p></p> 
<p><strong><span style="background-color:#cccccc">1.2.2、  <span style="color:#fe2c24">BL</span>指令</span></strong></p> 
<p><span style="color:#fe2c24">BL</span>指令的格式为：</p> 
<blockquote> 
 <p><em><span style="color:#fe2c24">BL</span>{条件} 目标地址</em></p> 
</blockquote> 
<blockquote> 
 <p>BL 是另一个跳转指令，但跳转之前，会<strong><span style="background-color:#ffd900">在寄存器R14中保存PC的当前内容</span></strong>，因此，可以通过将R14 的内容重新加载到PC中，来返回到跳转指令之后的那个指令处执行。该指令是实现子程序调用的一个基本而且常用的手段。以下指令：</p> 
</blockquote> 
<pre><code class="language-cpp">  BL   Label    ；当程序无条件跳转到标号Label处执行时，同时将当前的PC值保存到R14中</code></pre> 
<p><strong><span style="background-color:#cccccc">1.2.3、 </span><span style="color:#fe2c24"><span style="background-color:#cccccc"> BLX</span></span><span style="background-color:#cccccc">指令</span></strong></p> 
<p>BLX指令的格式为：</p> 
<blockquote> 
 <p><em>BLX  目标地址</em></p> 
</blockquote> 
<blockquote> 
 <p>BLX指令从ARM指令集<span style="background-color:#ffd900">跳转到指令中所指定的目标地址，并将处理器的工作状态有ARM状态切换到<strong>Thumb状态</strong></span>，该指令同时将PC的当前内容保存到寄存器R14中。因此，当子程序使用Thumb指令集，而调用者使用ARM指令集时，可以通过BLX指令实现子程序的调用和处理器工作状态的切换。同时，子程序的返回可以通过将寄存器R14值复制到PC中来完成。</p> 
</blockquote> 
<p><strong>1.2.4、  <span style="color:#fe2c24">BX</span>指令</strong></p> 
<p>BX指令的格式为：</p> 
<blockquote> 
 <p><em>BX{条件}  目标地址</em></p> 
</blockquote> 
<blockquote> 
 <p>BX指令跳转到指令中所指定的目标地址，<span style="background-color:#ffd900">目标地址处的指令既可以是ARM指令，也可以是Thumb指令</span>。</p> 
</blockquote> 
<p><strong>绝对跳转指令</strong></p> 
<p><strong>BR</strong><strong>指令编码分析</strong></p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/7c/94/EpLwUDMk_o.png" width="625"></p> 
<blockquote> 
 <p></p> 
 <p>1. BR（Branch to Register）指令执行的是无条件的绝对跳转，且跳转后不返回（因为没有保存返回地址）</p> 
 <p>2. BR指令跳转的目标地址存储在&lt;Xn&gt;寄存器中，因此可以在64位地址空间中进行跳转</p> 
 <p>3. BR指令提示CPU的分支预测逻辑这不是一个函数调用</p> 
</blockquote> 
<h4 id="6.2.2%20BR%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81">
<strong>BR</strong><strong>指令编码验证</strong>
</h4> 
<p>编译如下代码，</p> 
<blockquote> 
 <p>br x1</p> 
</blockquote> 
<p>对应机器码如下，</p> 
<p><img alt="" height="20" src="https://images2.imgbox.com/e5/9f/3XWAENJO_o.png" width="274"></p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/00/5c/FzHRhbQy_o.png" width="681"></p> 
<p></p> 
<h3><span style="background-color:#fe2c24"><strong>BLR 指令</strong></span></h3> 
<p>跳转到 某寄存器 (的值)指向的地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器 lr (x30)中，再进行跳转，如：</p> 
<blockquote> 
 <p>blr x20       ; 先将下一指令地址（x20 指向的函数调用后的返回地址）保存到寄存器 lr 中，然后再调用 x20 指向的函数</p> 
</blockquote> 
<p><strong>BLR指令分析</strong></p> 
<h2><img alt="" height="258" src="https://images2.imgbox.com/4f/2f/tBKLJwPG_o.png" width="806"></h2> 
<blockquote> 
 <p></p> 
 <p>1. BLR（Branch with Link to Register）指令的跳转及目的地址的编码方式和BR指令是相同的，差别在于BLR指令在跳转时会将跳转的返回地址，也就是PC + 4，设置到X30寄存器，从而可实现跳转返回</p> 
 <p>2. BLR指令提示CPU的分支预测逻辑这是一个函数调用<br>  </p> 
</blockquote> 
<h4 id="6.2.4%20BLR%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81">
<strong> BLR</strong><strong>指令编码验证</strong>
</h4> 
<p>编译如下代码，</p> 
<blockquote> 
 <p>blr x1</p> 
</blockquote> 
<p>对应机器码如下，</p> 
<p><img alt="" height="20" src="https://images2.imgbox.com/f2/55/QMFIl2iu_o.png" width="275"></p> 
<p> <img alt="" height="187" src="https://images2.imgbox.com/fa/7a/eO4Iq5u6_o.png" width="775"></p> 
<p></p> 
<h2>3、数据处理指令</h2> 
<p>数据处理指令数据处理指令可分为    数据传送指令、算术逻辑运算指令 、比较指令等。</p> 
<ul>
<li>数据传送指令用于在寄存器和存储器之间进行数据的双向传输。</li>
<li>算术逻辑运算指令完成常用的算术与逻辑的运算，该类指令不但将运算结果保存在目的寄存器中，同时更新CPSR中的相应条件标志位。</li>
<li>比较指令不保存运算结果，只更新CPSR中相应的条件标志位。</li>
</ul> 
<p><strong>数据处理指令共以下16条。</strong></p> 
<p>1、    MOV指令</p> 
<p>MOV指令的格式为：</p> 
<p>MOV{条件}{S} 目的寄存器，源操作数</p> 
<p>MOV指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。其中S选项决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</p> 
<p>指令示例：</p> 
<p>MOV R1，R0                        ；将寄存器R0的值传送到寄存器R1</p> 
<p>MOV PC，R14                       ；将寄存器R14的值传送到PC，常用于子程序返回</p> 
<p>MOV R1，R0，LSL＃3                 ；将寄存器R0的值左移3位后传送到R1</p> 
<p>2、  MVN指令</p> 
<p>MVN指令的格式为：</p> 
<p>MVN{条件}{S} 目的寄存器，源操作数</p> 
<p>MVN指令可完成从另一个寄存器、被移位的寄存器、或将一个立即数加载到目的寄存器。与MOV指令不同之处是在传送之前按位被取反了，即把一个被取反的值传送到目的寄存器中。其中S决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</p> 
<p>指令示例：</p> 
<p>MVN  R0，＃0                       ；将立即数0取反传送到寄存器R0中，完成后R0<strong>=</strong>-1</p> 
<p>3、  CMP指令</p> 
<p>CMP指令的格式为：</p> 
<p>CMP{条件} 操作数1，操作数2</p> 
<p>CMP指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT 后缀的指令将可以执行。</p> 
<p>指令示例：</p> 
<p>CMP    R1，R0              ；将寄存器R1的值与寄存器R0的值相减，并根据</p> 
<p>                              结果设置CPSR的标志位</p> 
<p>CMPR1，＃100               ；将寄存器R1的值与立即数100相减，并根据结果</p> 
<p>                              设置CPSR的标志位</p> 
<p>4、  CMN指令</p> 
<p>CMN指令的格式为：</p> 
<p>CMN{条件} 操作数1，操作数2</p> 
<p>CMN指令用于把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较，同时更新CPSR中条件标志位的值。该指令实际完成操作数1和操作数2相加，并根据结果更改条件标志位。</p> 
<p>指令示例：</p> 
<p>CMN    R1，R0              ；将寄存器R1的值与寄存器R0的值相加，并根据结果</p> 
<p>                                设置CPSR的标志位</p> 
<p>   CMNR1，＃100               ；将寄存器R1的值与立即数100相加，并根据结果设置</p> 
<p>                                CPSR的标志位</p> 
<p>5、  TST指令</p> 
<p>TST指令的格式为：</p> 
<p>TST{条件} 操作数1，操作数2</p> 
<p>TST指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中条件标志位的值。操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。</p> 
<p>指令示例：</p> 
<p>TST    R1，＃％1              ；用于测试在寄存器R1中是否设置了最低位（％表示二进制数）</p> 
<p>TSTR1，＃0xffe           ；将寄存器R1的值与立即数0xffe按位与，并根据结果设置CPSR的标志位</p> 
<p>6、  TEQ指令</p> 
<p>TEQ指令的格式为：</p> 
<p>TEQ{条件} 操作数1，操作数2</p> 
<p>TEQ指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的异或运算，并根据运算结果更新CPSR中条件标志位的值。该指令通常用于比较操作数1和操作数2是否相等。</p> 
<p>指令示例：</p> 
<p>TEQ   R1，R2                   ；将寄存器R1的值与寄存器R2的值按位异或，并根据结果设置CPSR的标志位</p> 
<p>7、  ADD指令</p> 
<p>ADD指令的格式为：</p> 
<p>ADD{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</p> 
<p>指令示例：</p> 
<p>ADD     R0，R1，R2                ； R0 <strong>=</strong> R1 <strong>+</strong> R2</p> 
<p>ADD     R0，R1，#256              ； R0 <strong>=</strong> R1 <strong>+</strong> 256</p> 
<p>ADD     R0，R2，R3，LSL#1         ； R0 <strong>=</strong> R2 <strong>+</strong> (R3 <strong>&lt;&lt;</strong> 1)</p> 
<p>8、  ADC指令</p> 
<p>ADC指令的格式为：</p> 
<p>ADC{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>ADC指令用于把两个操作数相加，再加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中。它使用一个进位标志位，这样就可以做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</p> 
<p>以下指令序列完成两个128位数的加法，第一个数由高到低存放在寄存器R7～R4，第二个数由高到低存放在寄存器R11～R8，运算结果由高到低存放在寄存器R3～R0：</p> 
<p>ADDS     R0，R4，R8          ； 加低端的字</p> 
<p>ADCS    R1，R5，R9             ； 加第二个字，带进位</p> 
<p>ADCS    R2，R6，R10          ； 加第三个字，带进位</p> 
<p>ADC      R3，R7，R11              ； 加第四个字，带进位</p> 
<p>9、  SUB指令</p> 
<p>SUB指令的格式为：</p> 
<p>SUB{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令可用于有符号数或无符号数的减法运算。</p> 
<p>指令示例：</p> 
<p>SUB     R0，R1，R2                ； R0 <strong>=</strong> R1 - R2</p> 
<p>SUB     R0，R1，#256              ； R0 <strong>=</strong> R1 - 256</p> 
<p>SUB     R0，R2，R3，LSL#1         ； R0 <strong>=</strong> R2 - (R3 <strong>&lt;&lt;</strong> 1)</p> 
<p>10、~~~~C指令</p> 
<p>~~~~C指令的格式为：</p> 
<p>~~~~C{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>~~~~C指令用于把操作数1减去操作数2，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或无符号数的减法运算。</p> 
<p>指令示例：</p> 
<p>SUBS    R0，R1，R2                         ； R0 <strong>=</strong> R1 - R2 - ！C，并根据结果设置</p> 
<p>                                                 CPSR的进位标志位</p> 
<p>11、R~~~~指令</p> 
<p>R~~~~指令的格式为：</p> 
<p>R~~~~{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>R~~~~指令称为逆向减法指令，用于把操作数2减去操作数1，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令可用于有符号数或无符号数的减法运算。</p> 
<p>指令示例：</p> 
<p>R~~~~     R0，R1，R2                              ； R0 <strong>=</strong> R2 – R1</p> 
<p>R~~~~     R0，R1，#256                            ； R0 <strong>=</strong> 256 – R1</p> 
<p>R~~~~     R0，R2，R3，LSL#1                       ； R0 <strong>=</strong> (R3 <strong>&lt;&lt;</strong> 1) - R2</p> 
<p>12、RSC指令</p> 
<p>RSC指令的格式为：</p> 
<p>RSC{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>RSC指令用于把操作数2减去操作数1，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或无符号数的减法运算。</p> 
<p>指令示例：</p> 
<p>RSC     R0，R1，R2                             ； R0 <strong>=</strong> R2 – R1 - ！C</p> 
<p>13、AND指令</p> 
<p>AND指令的格式为：</p> 
<p>AND{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>AND指令用于在两个操作数上进行逻辑与运算，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于屏蔽操作数1的某些位。</p> 
<p>指令示例：</p> 
<p>AND R0，R0，＃3                            ； 该指令保持R0的0、1位，其余位清零。</p> 
<p>14、ORR指令</p> 
<p>ORR指令的格式为：</p> 
<p>ORR{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于设置操作数1的某些位。</p> 
<p>指令示例：</p> 
<p>ORR R0，R0，＃3         ； 该指令设置R0的0、1位，其余位保持不变。</p> 
<p>15、EOR指令</p> 
<p>EOR指令的格式为：</p> 
<p>EOR{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>EOR指令用于在两个操作数上进行逻辑异或运算，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于反转操作数1的某些位。</p> 
<p>指令示例：</p> 
<p>EOR R0，R0，＃3        ； 该指令反转R0的0、1位，其余位保持不变。</p> 
<p>16、BIC指令</p> 
<p>BIC指令的格式为：</p> 
<p>BIC{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。操作数2为32位的掩码，如果在掩码中设置了某一位，则清除这一位。未设置的掩码位保持不变。</p> 
<p>指令示例：</p> 
<p>BIC R0，R0，＃％1011    ； 该指令清除 R0 中的位 0、1、和 3，其余的位保持不变。</p> 
<h3></h3> 
<h2>4、法指令与乘加指令</h2> 
<p>ARM微处理器支持的乘法指令与乘加指令共有6条，可分为运算结果为32位和运算结果为64位两类，与前面的数据处理指令不同，指令中的所有操作数、目的寄存器必须为通用寄存器，不能对操作数使用立即数或被移位的寄存器，同时，目的寄存器和操作数1必须是不同的寄存器。 </p> 
<p>乘法指令与乘加指令共有以下6条：</p> 
<p>1、  MUL指令</p> 
<p>MUL指令的格式为：</p> 
<p>MUL{条件}{S} 目的寄存器，操作数1，操作数2</p> 
<p>MUL指令完成将操作数1与操作数2的乘法运算，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。其中，操作数1和操作数2均为32位的有符号数或无符号数。</p> 
<p>指令示例：</p> 
<p>MUL R0，R1，R2            ；R0 <strong>=</strong> R1 × R2</p> 
<p>MULS R0，R1，R2           ；R0 <strong>=</strong> R1 × R2，同时设置CPSR中的相关条件标志位</p> 
<p>2、  MLA指令</p> 
<p>MLA指令的格式为：</p> 
<p>MLA{条件}{S} 目的寄存器，操作数1，操作数2，操作数3</p> 
<p>MLA指令完成将操作数1与操作数2的乘法运算，再将乘积加上操作数3，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。其中，操作数1和操作数2均为32位的有符号数或无符号数。</p> 
<p>指令示例：</p> 
<p>MLA R0，R1，R2，R3            ；R0 <strong>=</strong> R1 × R2 <strong>+</strong> R3</p> 
<p>MLAS  R0，R1，R2，R3          ；R0 <strong>=</strong> R1 × R2 <strong>+</strong> R3，同时设置CPSR中的相关条件标志位</p> 
<p>3、  SMULL指令</p> 
<p>SMULL指令的格式为：</p> 
<p>SMULL{条件}{S}   目的寄存器Low，目的寄存器低High，操作数1，操作数2</p> 
<p>SMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。其中，操作数1和操作数2均为32位的有符号数。</p> 
<p>指令示例：</p> 
<p>SMULL   R0，R1，R2，R3       ；R0 <strong>=</strong> （R2 × R3）的低32位</p> 
<p>                                 ；R1 <strong>=</strong> （R2 × R3）的高32位</p> 
<p>4、  SMLAL指令</p> 
<p>SMLAL指令的格式为：</p> 
<p>SMLAL{条件}{S}   目的寄存器Low，目的寄存器低High，操作数1，操作数2</p> 
<p>SMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。其中，操作数1和操作数2均为32位的有符号数。</p> 
<p>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位。</p> 
<p>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</p> 
<p>指令示例：</p> 
<p>SMLAL   R0，R1，R2，R3       ；R0 <strong>=</strong> （R2 × R3）的低32位 ＋ R0</p> 
<p>                                  ；R1 <strong>=</strong> （R2 × R3）的高32位 ＋ R1</p> 
<p>5、  UMULL指令</p> 
<p>UMULL指令的格式为：</p> 
<p>UMULL{条件}{S}   目的寄存器Low，目的寄存器低High，操作数1，操作数2</p> 
<p>UMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。其中，操作数1和操作数2均为32位的无符号数。</p> 
<p>指令示例：</p> 
<p>UMULL   R0，R1，R2，R3       ；R0 <strong>=</strong> （R2 × R3）的低32位</p> 
<p>                                 ；R1 <strong>=</strong> （R2 × R3）的高32位</p> 
<p>6、  UMLAL指令</p> 
<p>UMLAL指令的格式为：</p> 
<p>UMLAL{条件}{S}   目的寄存器Low，目的寄存器低High，操作数1，操作数2</p> 
<p>UMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。其中，操作数1和操作数2均为32位的无符号数。</p> 
<p>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位。</p> 
<p>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</p> 
<p>指令示例：</p> 
<p>UMLAL   R0，R1，R2，R3                 ；R0 <strong>=</strong> （R2 × R3）的低32位 ＋ R0</p> 
<p>                                          ；R1 <strong>=</strong> （R2 × R3）的高32位 ＋ R1</p> 
<h3></h3> 
<h2>5、程序状态寄存器访问指令</h2> 
<p>1、  MRS指令</p> 
<p>MRS指令的格式为：</p> 
<p>MRS{条件}    通用寄存器，程序状态寄存器（CPSR或SPSR）</p> 
<p>MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。该指令一般用在以下两种情况：</p> 
<p>Ⅰ.当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。</p> 
<p>Ⅱ.当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存。</p> 
<p>指令示例：</p> 
<p>MRS R0，CPSR                         ；传送CPSR的内容到R0</p> 
<p>MRS R0，SPSR                         ；传送SPSR的内容到R0</p> 
<p>2、  MSR指令</p> 
<p>MSR指令的格式为：</p> 
<p>MSR{条件}    程序状态寄存器（CPSR或SPSR）_<strong>&lt;</strong>域<strong>&gt;</strong>，操作数</p> 
<p>MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数。<strong>&lt;</strong>域<strong>&gt;</strong>用于设置程序状态寄存器中需要操作的位，32位的程序状态寄存器可分为4个域：</p> 
<p>位[31：24]为条件标志位域，用f表示；</p> 
<p>位[23：16]为状态位域，用s表示；</p> 
<p>位[15：8]为扩展位域，用x表示；</p> 
<p>位[7：0]为控制位域，用c表示；</p> 
<p>该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。</p> 
<p>指令示例：</p> 
<p>MSR CPSR，R0        ；传送R0的内容到CPSR</p> 
<p>MSR SPSR，R0        ；传送R0的内容到SPSR</p> 
<p>MSR CPSR_c，R0      ；传送R0的内容到SPSR，但仅仅修改CPSR中的控制位域</p> 
<h3></h3> 
<h2><strong>5、加载/存储指令</strong></h2> 
<p>ARM微处理器支持加载/存储指令用于在寄存器和存储器之间传送数据，加载指令用于将存储器中的数据传送到寄存器，存储指令则完成相反的操作。常用的加载存储指令如下：</p> 
<p>1、LDR指令</p> 
<p>LDR指令的格式为：</p> 
<p>LDR{条件} 目的寄存器，<strong>&lt;</strong>存储器地址<strong>&gt;</strong></p> 
<p>LDR指令用于从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。该指令在程序设计中比较常用，且寻址方式灵活多样，请读者认真掌握。</p> 
<p>指令示例：</p> 
<p>LDR R0，[R1]                             ；将存储器地址为R1的字数据读入寄存器R0。</p> 
<p>LDR R0，[R1，R2]                        ；将存储器地址为R1<strong>+</strong>R2的字数据读入寄存器R0。LDR R0，[R1，＃8]                          ；将存储器地址为R1<strong>+</strong>8的字数据读入寄存器R0。</p> 
<p>LDR  R0，[R1，R2] ！                     ；将存储器地址为R1<strong>+</strong>R2的字数据读入寄存器R0，</p> 
<p>并将新地址R1＋R2写入R1。</p> 
<p>LDR R0，[R1，＃8] ！                     ；将存储器地址为R1<strong>+</strong>8的字数据读入寄存器R0，</p> 
<p>并将新地址R1＋8写入R1。</p> 
<p>LDR  R0，[R1]，R2                       ；将存储器地址为R1的字数据读入寄存器R0，并</p> 
<p>                                           将新地址R1＋R2写入R1。</p> 
<p>LDR  R0，[R1，R2，LSL＃2]！             ；将存储器地址为R1＋R2×4的字数据读入寄存器</p> 
<p>R0，并将新地址R1＋R2×4写入R1。</p> 
<p>LDRR0，[R1]，R2，LSL＃2                 ；将存储器地址为R1的字数据读入寄存器R0，</p> 
<p>并将新地址R1＋R2×4写入R1。</p> 
<p>2、LDRB指令</p> 
<p>LDRB指令的格式为：</p> 
<p>LDR{条件}B 目的寄存器，<strong>&lt;</strong>存储器地址<strong>&gt;</strong></p> 
<p>LDRB指令用于从存储器中将一个8位的字节数据传送到目的寄存器中，同时将寄存器的高24位清零。该指令通常用于从存储器中读取8位的字节数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p> 
<p>指令示例：</p> 
<p>LDRB  R0，[R1]                          ；将存储器地址为R1的字节数据读入寄存器R0，并</p> 
<p>将R0的高24位清零。</p> 
<p>LDRB R0，[R1，＃8]                     ；将存储器地址为R1＋8的字节数据读入寄存器</p> 
<p>                                           R0，并将R0的高24位清零。</p> 
<p>3、LDRH指令</p> 
<p>LDRH指令的格式为：</p> 
<p>LDR{条件}H 目的寄存器，<strong>&lt;</strong>存储器地址<strong>&gt;</strong></p> 
<p>LDRH指令用于从存储器中将一个16位的半字数据传送到目的寄存器中，同时将寄存器的高16位清零。该指令通常用于从存储器中读取16位的半字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p> 
<p>指令示例：</p> 
<p>  LDRH   R0，[R1]               ；将存储器地址为R1的半字数据读入寄存器R0，并</p> 
<p>                                  将R0的高16位清零。</p> 
<p>LDRH   R0，[R1，＃8]          ；将存储器地址为R1＋8的半字数据读入寄存器R0，</p> 
<p>                                  并将R0的高16位清零。</p> 
<p>LDRHR0，[R1，R2]              ；将存储器地址为R1＋R2的半字数据读入寄存器</p> 
<p>                                  R0，并将R0的高16位清零。</p> 
<h2>ADR 指令</h2> 
<h4>
<a name="t5"></a>定义</h4> 
<p><code>adr</code>指令根据PC的偏移地址计算目标地址。偏移地址是一个21位的有符号数，加上当前的PC地址得到目标地址。<code>adr</code>可以获取当前PC地址±1MB范围内的地址。下面是<code>adr</code>指令的编码格式。立即数占用21位。</p> 
<p><img alt="" height="737" src="https://images2.imgbox.com/50/a9/pxRLQCyx_o.png" width="849"></p> 
<h2>adr_l</h2> 
<p><br> adr_l是Linux内核定义的一个宏，用于获取基于PC相对偏移+/- 4 GB内的符号地址。</p> 
<p>在内核上下文中，使用adrp和add指令获取符号地址，</p> 
<p>而在内核模块上下文中，使用mov指令获取符号地址。</p> 
<blockquote> 
 <p>    [arch/arm64/include/asm/assembler.h]<br>     .macro    <span style="color:#fe2c24"><strong>adr_l</strong></span>, dst, sym<br> #ifndef MODULE  /* 内核上下文中 */<br>     adrp    dst, sym  /* 获取符号所在页的基地址 */<br>     /* :lo12:sym - 获取符号sym的低12位地址。<br>        符号所在页的基地址加上低12位地址就得到符号的完整地址 */<br>     add    dst, dst, :lo12:sym<br> #else  /* 内核模块上下中 */<br>     /* 将符号的bit[64:48]地址加载到dst寄存器中，同时做<br>        overflow check，其他位清零 */<br>     movz    dst, #:abs_g3:sym<br>     /* 将符号的bit[47:32]地址加载到dst寄存器中，不做<br>        overflow check，其他位保持不变 */<br>     movk    dst, #:abs_g2_nc:sym<br>     /* 将符号的bit[31:16]地址加载到dst寄存器中，不做<br>        overflow check，其他位保持不变 */<br>     movk    dst, #:abs_g1_nc:sym<br>     /* 将符号的bit[15:0]地址加载到dst寄存器中，不做<br>        overflow check，其他位保持不变 */<br>     movk    dst, #:abs_g0_nc:sym<br> #endif<br>     .endm </p> 
</blockquote> 
<p><br> mov指令获取地址的操作如下图所示。</p> 
<p><img alt="" height="456" src="https://images2.imgbox.com/5b/6a/gDSSBf4H_o.png" width="583"><br> MOVZ将16位立即数移至寄存器，并且除该立即数之外的所有其他位均设置为零，同时也可以将立即数向左移0、16、32或48位。</p> 
<blockquote> 
 <p>   instruction                       value of x0<br> movz  x0, #0x1f88           |        0x1f88<br> movz  x0, #0x1f88, lsl #16  |        0x1f880000<br><br> MOVK移动16位立即数并将其保存到寄存器中，但寄存器中其他位保持不变。</p> 
</blockquote> 
<blockquote> 
 <p>       instruction                    value of x0<br> movk   x0, #0xb7fb, lsl #16  |        0xb7fb1f88<br> movk   x0, #0x7f, lsl #32    |        0x7fb7fb1f88 </p> 
</blockquote> 
<h3></h3> 
<h3>ADR LDR 伪指令的区别</h3> 
<p><strong>LDR  获取地址的内容</strong></p> 
<blockquote> 
 <p>ldr <strong>&lt;</strong>register<strong>&gt;</strong> , <strong>=</strong> <strong>&lt;</strong>expression<strong>&gt;</strong></p> 
 <p>相当于PC寄存器或其它寄存器的长转移.</p> 
</blockquote> 
<p><strong>ADR 获取地址</strong></p> 
<blockquote> 
 <p>adr <strong>&lt;</strong>register<strong>&gt;</strong> <strong>&lt;</strong>label<strong>&gt;</strong></p> 
 <p>相于PC寄存器或其它寄存器的小范围转移.</p> 
</blockquote> 
<p><strong>ADRL</strong></p> 
<blockquote> 
 <p>adrl <strong>&lt;</strong>register<strong>&gt;</strong> <strong>&lt;</strong>label<strong>&gt;</strong></p> 
 <p>相于PC寄存器或其寄存器的中范围转移.</p> 
</blockquote> 
<blockquote> 
 <p>在学习ARM汇编指令的时候，经常会使用到ldr与adr两条指令，相信大部分初学的人曾经都对这两个命令产生过疑惑。</p> 
 <p>其实这两条指令都是伪指令：</p> 
 <p><span style="color:#fe2c24"><strong>ldr指令是大范围的地址读取伪指令，相对于PC寄存器或其他寄存器的大范围跳转</strong></span>；<br> adr指令是小范围的地址读取伪指令，相对于PC寄存器或其他寄存器的小范围跳转。<br> 要想清楚的说明这两条指令的区别，还是得从实际的例子中来解释，空谈泛泛，难以实际掌握。</p> 
 <p>   <strong> ldr r0, _start           ;取_start地址中的内容</strong><br>     nop<br>     nop<br>     adr r0, _start<br>     nop<br>     nop<br>   <strong>  ldr r0, =_start         ;绝对地址</strong><br>     nop<br>     nop<br> _start:<br>     nop<br><br> 反汇编后的结果如下：</p> 
 <p>1   0x00000000: e59f001c ... LDR r0, [pc, #28];<span style="color:#0d0016"><span style="background-color:#ff9900"> [0x24]=e1a00000  ;pc=0+8 +28</span></span><br><span style="background-color:#a5a5a5">2   0x00000004: e1a00000 ... MOV r0, r0</span><br><span style="background-color:#a5a5a5">3   0x00000008: e1a00000 ... MOV r0, r0</span><br> 4   0x0000000c: e28f0010 ... ADD r0, pc, 0x10; r0=x00000024；pc=8+0x10 <br><span style="background-color:#a5a5a5">5   0x00000010: e1a00000 ... MOV r0, r0 </span><br><span style="background-color:#a5a5a5">6   0x00000014: e1a00000 ... MOV r0, r0</span><br> 7   0x00000018: e59f0008 ... LDR r0, [pc, #8]; <span style="background-color:#ff9900">[0x28]=00000024 ;pc=0x18+8+8=40</span><br><span style="background-color:#a5a5a5">8   0x0000001c: e1a00000 ... MOV r0, r0</span><br><span style="background-color:#a5a5a5">9   0x00000020: e1a00000 ... MOV r0, r0</span><br> _start:<br> 10  <strong>0x00000024</strong>: e1a00000 ... MOV r0, r0<br>    <br> 11  <span style="background-color:#ff9900">0x00000028: <strong>00000024</strong> ... DCD 36 </span> ;$d  存放_start地址值</p> 
 <p></p> 
 <ul>
<li>第一行，寄存器间接寻址，获取_start的地址，此时，r0=0xe1a00000.</li>
<li>第四行，此时，r0=0x00000024.</li>
<li>第七行，取得标号_start的绝对地址，这个<strong><span style="background-color:#fe2c24">绝对地址是在link的时候确定</span></strong>的，看上去这只是一条指令，但是它要占用2个32bit的空间，一条是指令，另一条是_start的数据。<span style="background-color:#ff9900">因为在编译的时候不能够确定_start的值</span>，而且也不能够用mov指令来给r0赋一个32bit的常量，所以需要多出一个空间来存放_start的真正数据，在这里就是0x00000024，由此可以看出，这个是绝对寻址，不管代码在什么地方运行，它的结果都是r0=0x00000024.</li>
</ul> 
</blockquote> 
<blockquote> 
 <p>例2：</p> 
 <p></p> 
 <p>.text<br> .globl _start<br> _start:<br>     ldr r0, test<br>     adr r0, test<br>     ldr r0, =test<br>     nop<br> test:<br>     nop</p> 
 <p></p> 
 <p><strong>反汇编</strong></p> 
 <p></p> 
 <p><strong><em>test_adr_elf:<br> file format elf32-littlearm<br> Disassembly of section .text:</em></strong></p> 
 <p><br><strong><em>00000000 _start:<br> 0: e59f0008 ldr r0, [pc, #8]; </em></strong>ldr r0, test   -------------1<br><strong><em>4: e28f0004 add r0, pc, #4; </em></strong>adr r0, test  --------------2<br><strong><em>8: e59f0004 ldr r0, [pc, #4]; </em></strong> ldr r0, =test --------------3<br><strong><em>c: e1a00000 nop (mov r0,r0)；nop<br> 00000010 test:</em><br> 10:e1a00000 nop (mov r0,r0)<br> 14:00000010 andeq r0, r0, r0, lsl r0    -------------------4</strong></p> 
 <p></p> 
 <p>1) test标签偏移是16 pc=0+8+8  r0=[10]=<strong>e1a00000,取内容</strong></p> 
 <p>2) test标签偏移是12 r0=4+8+4=0x10,取地址，就是text 当前地址</p> 
 <p>3）ldr r0,=test被编译成两个字，<strong>一个指令</strong>，<strong>一个文字池(地址14)</strong>。</p> 
 <p>pc=8+8+4=20; r0=[14]=<strong>00000010,取的也就是test标签的地址</strong></p> 
 <p><strong>4）数字被翻译成了指令，不影响</strong></p> 
</blockquote> 
<h2><span style="background-color:#ff9900"> adrp</span></h2> 
<blockquote> 
 <p>该指令在ARMv8中首次被设计出来，是ARM指令集的一个重大创新，可以减少指令条数以及访存的次数。有几篇博客介绍了该指令的作用，但是没有讲清楚，如 《ARM指令浅析2（adrp、b）》、 《汇编七、ADRP指令》。<br> 指令的使用方式为:</p> 
 <p>adrp &lt;Rd&gt;, &lt;label&gt;</p> 
 <p><span style="background-color:#ffd900">adrp就是address page 的简写</span>，这里的page指的是大小为4KB的连续内存，和操作系统中的页不是一回事。该指令的作用是将label所在页且4KB对其的页基地址放入寄存器Xd中。Labe表示的地址肯定在这个页基地址确定的页内。要想彻底搞懂这个指令的作用，还需要从指令汇编的过程和译码的过程进行分析。</p> 
 <p><strong>adrp指令汇编</strong></p> 
 <p>也就是将这个指令变成二进制机器码的过程，根据ARM文档，adrp指令的二进制格式为：</p> 
 <p><img alt="" src="https://images2.imgbox.com/19/e1/AMz1QvnG_o.png"></p> 
 <p> 32bit中的21bit immhi和immlo是由lable的地址(L)和当前指令所在的地址计算来的</p> 
</blockquote> 
<blockquote> 
 <p>第一步获取label和当前指令所在页的页基地址，两者相减得到差值；</p> 
 <p>第二步将差值右移12位，再取低21位作为immhi:immlo。在进行指令汇编的时候，数据和指令在最终的二进制文件中的位置都确定了，当然也可以确定当前指令在所在的页基地址和lable所在的页基地址。</p> 
 <p><img alt="" src="https://images2.imgbox.com/67/c9/t5RtR4gA_o.png"></p> 
 <p></p> 
 <p><br> 在Linux内核启动代码primary_entry中，使用adrp指令获取Linux内核在内存中的起始页地址，页大小为4KB，由于内核启动的时候MMU还未打开，此时获取的Linux内核在内存中的起始页地址为物理地址。adrp通过当前PC地址的偏移地址计算目标地址，和实际的物理无关，因此属于位置无关码。</p> 
 <p><span style="background-color:#ff9900">思考：为什么MMU未开启，adrp获取的是物理地址：</span></p> 
 <p><span style="background-color:#ff9900">未开启MMU前，CPU取指或访问数据，都是直接访问的物理地址内存</span></p> 
</blockquote> 
<blockquote> 
 <p>2.1.定义<br> adrp指令根据PC的偏移地址计算<strong>目标页地址</strong>。<span style="color:#0d0016"><span style="background-color:#ff9900">首先adrp将一个21位有符号立即数左移12位，得到一个33位的有符号数（最高位为符号位,可寻址-4G-+4G）</span></span>，接着将PC地址的低12位清零，<span style="background-color:#ffd900">这样就得到了当前PC地址所在页的地址</span>，然后将<span style="background-color:#a2e043">当前PC地址所在页的地址加上33位的有符号数，就得到了目标页地址，最后将目标页地址写入通用寄存器</span>。此处页大小为4KB，只是为了得到更大的地址范围，和虚拟内存的页大小没有关系。</p> 
 <p></p> 
 <p>通过adrp指令，可以获取当前PC地址±4GB范围内的地址。</p> 
 <p>通常的使用场景是先通过adrp获取一个基地址，然后再通过基地址的偏移地址获取具体变量的地址。</p> 
 <p><br> 下面是adrp指令的编码格式。立即数占用21位，在运行的时候，会将21位立即数扩展为33位有符号数。最高位为1，表示这是一个aarch64指令。</p> 
</blockquote> 
<p><img alt="" height="874" src="https://images2.imgbox.com/4e/f5/paBmIwRc_o.png" width="961"></p> 
<p></p> 
<h2><span style="background-color:#ff9900">STR指令</span></h2> 
<blockquote> 
 <p>STR指令的格式为：</p> 
 <p>STR{条件} 源寄存器，<strong>&lt;</strong>存储器地址<strong>&gt;</strong></p> 
 <p></p> 
 <p>STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令LDR。</p> 
</blockquote> 
<blockquote> 
 <p>指令示例：</p> 
 <p><strong><span style="color:#0d0016">STR R0，[R1]，＃8 </span></strong>           ；将R0中的字数据写入以R1为地址的存储器中，并</p> 
 <p>                                 将<strong>新地址</strong>R1＋8写入R1。</p> 
 <p><strong>STR R0，[R1，＃8]</strong>            ；将R0中的字数据写入以R1＋8为地址的存储器中。</p> 
</blockquote> 
<hr> 
<h3><span style="background-color:#ff9900">str_l  </span></h3> 
<blockquote> 
 <p><strong>str_l    x4, kimage_voffset, x5 </strong></p> 
 <p></p> 
 <p><em>注释：x4-&gt;kimage_voffset</em></p> 
</blockquote> 
<blockquote> 
 <p>//assemble.h</p> 
 <p>    <strong> .macro    str_l, src, sym, tmp</strong><br><strong>#ifndef MODULE</strong><br>     adrp    tmp, sym<br>     str    src, [tmp, :lo12:sym]<br><strong>#else</strong><br>     adr_l    tmp, sym<br>     str    src, [tmp]<br><strong>#endif</strong><br>     <strong>.endm</strong></p> 
 <p></p> 
 <p><em>注：</em></p> 
 <p><em>在内核上下文中，使用adrp和add指令获取符号地址，</em></p> 
 <p><em>而在内核模块上下文中，使用mov指令获取符号地址。</em></p> 
</blockquote> 
<hr> 
<p><strong>STRB指令</strong></p> 
<p>STRB指令的格式为：</p> 
<p>STR{条件}B 源寄存器，<strong>&lt;</strong>存储器地址<strong>&gt;</strong></p> 
<p>STRB指令用于从源寄存器中将一个8位的字节数据传送到存储器中。该字节数据为源寄存器中的低8位。</p> 
<p>指令示例：</p> 
<p>STRB    R0，[R1]             ；将寄存器R0中的字节数据写入以R1为地址的存储</p> 
<p>                                  器中。</p> 
<p>STRB    R0，[R1，＃8]        ；将寄存器R0中的字节数据写入以R1＋8为地址的</p> 
<p>                                  存储器中。</p> 
<hr> 
<p><strong>STRH指令</strong></p> 
<p>STRH指令的格式为：</p> 
<p>STR{条件}H 源寄存器，<strong>&lt;</strong>存储器地址<strong>&gt;</strong></p> 
<p>STRH指令用于从源寄存器中将一个16位的半字数据传送到存储器中。该半字数据为源寄存器中的低16位。</p> 
<p>指令示例：</p> 
<p>    STRH   R0，[R1]             ；将寄存器R0中的半字数据写入以R1为地址的存储器中。</p> 
<p>STRH   R0，[R1，＃8]        ；将寄存器R0中的半字数据写入以R1＋8为地址的存储器中。</p> 
<hr> 
<p><strong>STUR 指令</strong><br> stur 寄存器,[内存地址]</p> 
<p><span style="color:#ff9900"><strong>与STR的区别：</strong></span></p> 
<p><span style="color:#ff9900"><strong>        用于：右边立即数是负数的情况</strong></span></p> 
<p>例如下面汇编代码</p> 
<blockquote> 
 <p>str w11, [x10, #0xa0]<br><span style="background-color:#ff9900">stur w12, [x29, #</span><strong><span style="background-color:#ff9900">-0x18</span></strong><span style="background-color:#ff9900">]</span></p> 
</blockquote> 
<p><strong>局部变量:</strong></p> 
<blockquote> 
 <p>int a = 3;</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p>mov    w12, #0x3<br><strong>stur   w12, [x29, #-0x18]</strong><br><br> mov 先把3 赋值给寄存器w12,然后 stur存储指令把w12 寄存器里的内容写入内存地址 x29, <span style="color:#fe2c24"><strong>#-0x18</strong></span> 里.</p> 
</blockquote> 
<p>再看<strong>全局变量</strong> int g_a = 0;</p> 
<blockquote> 
 <p>g_a = 10;</p> 
</blockquote> 
<blockquote> 
 <p><br> mov    w11, #0xa<br> str    w11, [x10, #0xa0]<br><br> mov 先把10=16进制0xa赋值给了 w11<br> str存储指令把w11里的内容写入 内存地址 x10, #0xa0 里面.</p> 
</blockquote> 
<h2>
<strong>STP 指令</strong> </h2> 
<p>p是pair的意思把一对寄存器写入到右边内存；<br> stp w0,w1,[x2] //把w0和 w1里面的值,写入到右边内存,[x2]中,w0在左边,w1在右边<br> 在oc中的调用<br> fn2的声明</p> 
<blockquote> 
 <p>int fn2(int a,int b,int *c);//fn2的声明</p> 
</blockquote> 
<p>调用</p> 
<blockquote> 
 <p>int c = 1;<br> int d = 2;<br> int e = 0;<br> result = fn2(c, d,&amp;e);<br> NSLog(@"result=%d",result);<br>  </p> 
</blockquote> 
<p>汇编函数定义</p> 
<blockquote> 
 <p>_fn2:<br> //w0 存储参数1,w1存储参数2.因为w0和w1共同组成x0,第三个参数向后延续一个寄存器,所以参数3存入x1中<br> stp w0,w1,[x2] //把w0和 w1里面的值,写入到右边内存,[x2]中,w0在左边,w1在右边<br> mov x0,x2//把x2的值存入返回值x0中<br> ret</p> 
</blockquote> 
<p>调试结果</p> 
<blockquote> 
 <p>(lldb) re read x2<br>       x2 = 0x000000016fd9540c<br> (lldb) x 0x000000016fd9540c<br> 0x16fd9540c: 00 00 00 00 02 00 00 00 01 00 00 00 0a 00 00 00  ................<br> 0x16fd9541c: 01 00 00 00 c0 e4 6d 83 02 00 00 00 00 88 3e 80  ......m.......&gt;.<br> (lldb) re read w0<br>       w0 = 0x00000001<br> (lldb) re read w1<br>       w1 = 0x00000002<br> (lldb) si<br> (lldb) x 0x000000016fd9540c<br> 0x16fd9540c: 01 00 00 00 02 00 00 00 01 00 00 00 0a 00 00 00  ................<br> 0x16fd9541c: 01 00 00 00 c0 e4 6d 83 02 00 00 00 00 88 3e 80  ......m.......&gt;.<br> (lldb) si<br> (lldb) re read x0<br>       x0 = 0x000000016fd9540c<br>  </p> 
</blockquote> 
<p>这个x0就是返回值,赋值给int类型是取走后8位,就是 0x6fd9540c,转换成10进制就是1876513804</p> 
<p>打印结果:</p> 
<blockquote> 
 <p>result=1876513804</p> 
</blockquote> 
<hr> 
<h2><strong><code><span style="background-color:#ff9900">ldp</span></code></strong></h2> 
<p>出栈指令（ldr 的变种指令，可以同时操作两个寄存器)，如：</p> 
<blockquote> 
 <p> ldp x29, x30, [sp, #0x10]    ; 将 sp 偏移 16 个字节的值取出来，存入寄存器 x29 和寄存器 x30</p> 
</blockquote> 
<h2><strong>6、批量数据加载/存储指令</strong></h2> 
<p>ARM微处理器所支持批量数据加载/存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。常用的加载存储指令如下：</p> 
<p>LDM（或STM）指令</p> 
<p>LDM（或STM）指令的格式为：</p> 
<p>LDM（或STM）{条件}{类型} 基址寄存器{！}，寄存器列表{∧}</p> 
<p>LDM（或STM）指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。其中，{类型}为以下几种情况：</p> 
<p>IA   每次传送后地址加1；</p> 
<p>IB   每次传送前地址加1；</p> 
<p>DA   每次传送后地址减1；</p> 
<p>DB   每次传送前地址减1；</p> 
<p>FD   满递减堆栈；</p> 
<p>ED   空递减堆栈；</p> 
<p>FA   满递增堆栈；</p> 
<p>EA   空递增堆栈；</p> 
<p>{！}为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。</p> 
<p>基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。</p> 
<p>{∧}为可选后缀，当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。</p> 
<p>指令示例：</p> 
<p>STMFD  R13!，{R0，R4-R12，LR}        ；将寄存器列表中的寄存器（R0，R4到</p> 
<p>                                            R12，LR）存入堆栈。</p> 
<p>LDMFD  R13!，{R0，R4-R12，PC}        ；将堆栈内容恢复到寄存器（R0，R4到</p> 
<p>                                            R12，LR）。</p> 
<h3></h3> 
<h2><strong>7、数据交换指令</strong></h2> 
<p>1、SWP指令</p> 
<p>SWP指令的格式为：</p> 
<p>SWP{条件} 目的寄存器，源寄存器1，[源寄存器2]</p> 
<p>SWP指令用于将源寄存器2所指向的存储器中的字数据传送到目的寄存器中，同时将源寄存器1中的字数据传送到源寄存器2所指向的存储器中。显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p> 
<p>指令示例：</p> 
<p>SWP   R0，R1，[R2]                    ；将R2所指向的存储器中的字数据传送到R0，同时                                        将R1中的字数据传送到R2所指向的存储单元。</p> 
<p>SWP   R0，R0，[R1]             ；该指令完成将R1所指向的存储器中的字数据与R0中的数据</p> 
<p>交换。</p> 
<p>2、SWPB指令</p> 
<p>SWPB指令的格式为：</p> 
<p>SWP{条件}B 目的寄存器，源寄存器1，[源寄存器2]</p> 
<p>SWPB指令用于将源寄存器2所指向的存储器中的字节数据传送到目的寄存器中，目的寄存器的高24清零，同时将源寄存器1中的字节数据传送到源寄存器2所指向的存储器中。显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p> 
<p>指令示例：</p> 
<p>SWPB   R0，R1，[R2]            ；将R2所指向的存储器中的字节数据传送到R0，R0的高24</p> 
<p>位清零，同时将R1中的低8位数据传送到R2所指向的存储单元。</p> 
<p>SWPB   R0，R0，[R1]           ；该指令完成将R1所指向的存储器中的字节数据与</p> 
<p>                                    R0中的低8位数据交换。</p> 
<h3></h3> 
<h2><strong>8、移位指令（操作）</strong></h2> 
<p>1、LSL（或ASL）操作</p> 
<p>LSL（或ASL）操作的格式为：</p> 
<p>通用寄存器，LSL（或ASL） 操作数      </p> 
<p>LSL（或ASL）可完成对通用寄存器中的内容进行逻辑（或算术）的左移操作，按操作数所指定的数量向左移位，低位用零来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。</p> 
<p>操作示例</p> 
<p>MOV   R0, R1, LSL#2               ；将R1中的内容左移两位后传送到R0中。</p> 
<p>2、LSR操作</p> 
<p>LSR操作的格式为：</p> 
<p>通用寄存器，LSR 操作数      </p> 
<p>LSR可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用零来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。</p> 
<p>操作示例： </p> 
<p>MOV   R0, R1, LSR#2            ；将R1中的内容右移两位后传送到R0中，左端用</p> 
<p>                                      零来填充。</p> 
<p>3、ASR操作</p> 
<p>ASR操作的格式为：</p> 
<p>通用寄存器，ASR 操作数      </p> 
<p>ASR可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用第31位的值来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。</p> 
<p>操作示例：</p> 
<p>MOV    R0, R1, ASR#2          ；将R1中的内容右移两位后传送到R0中，左端用</p> 
<p>                                              第31位的值来填充。</p> 
<p>4、ROR操作</p> 
<p>ROR操作的格式为：</p> 
<p>通用寄存器，ROR 操作数      </p> 
<p>ROR可完成对通用寄存器中的内容进行循环右移的操作，按操作数所指定的数量向右循环移位，左端用右端移出的位来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。显然，当进行32位的循环右移操作时，通用寄存器中的值不改变。</p> 
<p>操作示例：</p> 
<p>MOV    R0, R1, ROR#2           ；将R1中的内容循环右移两位后传送到R0中。</p> 
<p>5、RRX操作</p> 
<p>RRX操作的格式为：</p> 
<p>通用寄存器，RRX 操作数      </p> 
<p>RRX可完成对通用寄存器中的内容进行带扩展的循环右移的操作，按操作数所指定的数量向右循环移位，左端用进位标志位C来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。</p> 
<p>操作示例：</p> 
<p>MOV   R0, R1, RRX#2             ；将R1中的内容进行带扩展的循环右移两位后传送到R0中。</p> 
<h3></h3> 
<h2><strong>9、协处理器指令</strong></h2> 
<p>1、CDP指令</p> 
<p>CDP指令的格式为：</p> 
<p>CDP{条件} 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</p> 
<p>CDP指令用于ARM处理器通知ARM协处理器执行特定的操作,若协处理器不能成功完成特定的操作，则产生未定义指令异常。其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，目的寄存器和源寄存器均为协处理器的寄存器，指令不涉及ARM处理器的寄存器和存储器。</p> 
<p>指令示例：</p> 
<p>  CDP   P3，2，C12，C10，C3，4   ；该指令完成协处理器P3的初始化 </p> 
<p>2、LDC指令</p> 
<p>LDC指令的格式为：</p> 
<p>LDC{条件}{L} 协处理器编码,目的寄存器，[源寄存器]</p> 
<p>LDC指令用于将源寄存器所指向的存储器中的字数据传送到目的寄存器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。其中，{L}选项表示指令为长读取操作，如用于双精度数据的传输。</p> 
<p>指令示例：</p> 
<p>   LDC   P3，C4，[R0]                ；将ARM处理器的寄存器R0所指向的存储器中</p> 
<p>                                         的字数据传送到协处理器P3的寄存器C4中。 </p> 
<p>3、STC指令</p> 
<p>STC指令的格式为：</p> 
<p>STC{条件}{L} 协处理器编码,源寄存器，[目的寄存器]</p> 
<p>STC指令用于将源寄存器中的字数据传送到目的寄存器所指向的存储器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。其中，{L}选项表示指令为长读取操作，如用于双精度数据的传输。</p> 
<p>指令示例：</p> 
<p>STC   P3，C4，[R0]              ；将协处理器P3的寄存器C4中的字数据传送到</p> 
<p>                                      ARM处理器的寄存器R0所指向的存储器中。 </p> 
<p>4、MCR指令</p> 
<p>MCR指令的格式为：</p> 
<p>MCR{条件} 协处理器编码，协处理器操作码1，源寄存器，目的寄存器1，目的寄存器2，协处理器操作码2。</p> 
<p>MCR指令用于将ARM处理器寄存器中的数据传送到协处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄存器。</p> 
<p>指令示例：</p> 
<p>   MCR   P3，3，R0，C4，C5，6       ；该指令将ARM处理器寄存器R0中的数据传送到协处理器P3的寄存器C4和C5中。 </p> 
<p>5、MRC指令</p> 
<p>MRC指令的格式为：</p> 
<p>MRC{条件} 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</p> 
<p>MRC指令用于将协处理器寄存器中的数据传送到ARM处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，目的寄存器为ARM处理器的寄存器，源寄存器1和源寄存器2均为协处理器的寄存器。</p> 
<p>指令示例：</p> 
<p>  MRC   P3，3，R0，C4，C5，6        ；该指令将协处理器P3的寄存器中的数据传</p> 
<p>                                         送到ARM处理器寄存器中。 </p> 
<h3></h3> 
<h2><strong>10、异常产生指令</strong></h2> 
<p>1、SWI指令</p> 
<p>SWI指令的格式为：</p> 
<p>SWI{条件} 24位的立即数</p> 
<p>SWI指令用于产生软件中断，以便用户程序能调用操作系统的系统例程。操作系统在SWI的异常处理程序中提供相应的系统服务，指令中24位的立即数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传递，当指令中24位的立即数被忽略时，用户程序调用系统例程的类型由通用寄存器R0的内容决定，同时，参数通过其他通用寄存器传递。 </p> 
<p>指令示例：</p> 
<p>   SWI   0x02                         ；该指令调用操作系统编号位02的系统例程。</p> 
<p>2、BKPT指令</p> 
<p>BKPT指令的格式为：</p> 
<p>BKPT   16位的立即数</p> 
<p>BKPT指令产生软件断点中断，可用于程序的调试。</p> 
<p></p> 
<h2>11  ARM汇编器所支持的伪指令</h2> 
<p>在ARM汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对应的操作码，通常称这些特殊指令助记符为伪指令，他们所完成的操作称为伪操作。伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成。</p> 
<p></p> 
<p>在ARM的汇编程序中，有如下4种伪指令：符号定义伪指令、数据定义伪指令、汇编控制伪指令、宏指令以及其他伪指令。</p> 
<p></p> 
<h3>11.1   符号定义（Symbol Definition）伪指令</h3> 
<p>符号定义伪指令用于定义ARM汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。常见的符号定义伪指令有如下4种：</p> 
<p></p> 
<p>1、  GBLA、GBLL和GBLS</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>GBLA（GBLL或GBLS）  全局变量名</p> 
<p></p> 
<p>GBLA、GBLL和GBLS伪指令用于定义一个ARM程序中的全局变量，并将其初始化。其中：</p> 
<p></p> 
<p>GBLA伪指令用于定义一个全局的数字变量，并初始化为0；</p> 
<p></p> 
<p>GBLL伪指令用于定义一个全局的逻辑变量，并初始化为F（假）；</p> 
<p></p> 
<p>GBLS伪指令用于定义一个全局的字符串变量，并初始化为空；</p> 
<p></p> 
<p>由于以上三条伪指令用于定义全局变量，因此在整个程序范围内变量名必须唯一。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>GBLA    Test1                   ；定义一个全局的数字变量，变量名为Test1</p> 
<p></p> 
<p>Test1   SETA    0xaa            ；将该变量赋值为0xaa</p> 
<p></p> 
<p>GBLL    Test2                    ；定义一个全局的逻辑变量，变量名为Test2</p> 
<p></p> 
<p>Test2   SETL    {TRUE}          ；将该变量赋值为真</p> 
<p></p> 
<p>GBLS    Test3                   ；定义一个全局的字符串变量，变量名为Test3</p> 
<p></p> 
<p>Test3   SETS    “Testing”      ；将该变量赋值为“Testing”</p> 
<p></p> 
<p>2、  LCLA、LCLL和LCLS</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>LCLA（LCLL或LCLS）  局部变量名</p> 
<p></p> 
<p>LCLA、LCLL和LCLS伪指令用于定义一个ARM程序中的局部变量，并将其初始化。其中：</p> 
<p></p> 
<p>LCLA伪指令用于定义一个局部的数字变量，并初始化为0；</p> 
<p></p> 
<p>LCLL伪指令用于定义一个局部的逻辑变量，并初始化为F（假）；</p> 
<p></p> 
<p>LCLS伪指令用于定义一个局部的字符串变量，并初始化为空；</p> 
<p></p> 
<p>    以上三条伪指令用于声明局部变量，在其作用范围内变量名必须唯一。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>LCLA   Test4                    ；声明一个局部的数字变量，变量名为Test4</p> 
<p></p> 
<p>Test3   SETA    0xaa             ；将该变量赋值为0xaa</p> 
<p></p> 
<p>LCLL    Test5                     ；声明一个局部的逻辑变量，变量名为Test5</p> 
<p></p> 
<p>Test4   SETL    {TRUE}           ；将该变量赋值为真</p> 
<p></p> 
<p>LCLS   Test6                    ；定义一个局部的字符串变量，变量名为Test6</p> 
<p></p> 
<p>Test6   SETS    “Testing”       ；将该变量赋值为“Testing”</p> 
<p></p> 
<p>3、  SETA、SETL和SETS</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>变量名   SETA（SETL或SETS） 表达式</p> 
<p></p> 
<p>伪指令SETA、SETL、SETS用于给一个已经定义的全局变量或局部变量赋值。</p> 
<p></p> 
<p>SETA伪指令用于给一个数学变量赋值；</p> 
<p></p> 
<p>SETL伪指令用于给一个逻辑变量赋值；</p> 
<p></p> 
<p>SETS伪指令用于给一个字符串变量赋值；</p> 
<p></p> 
<p>其中，变量名为已经定义过的全局变量或局部变量，表达式为将要赋给变量的值。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>LCLA    Test3                   ；声明一个局部的数字变量，变量名为Test3</p> 
<p></p> 
<p>Test3   SETA   0xaa            ；将该变量赋值为0xaa</p> 
<p></p> 
<p>LCLL    Test4                   ；声明一个局部的逻辑变量，变量名为Test4</p> 
<p></p> 
<p>Test4   SETL   {TRUE}          ；将该变量赋值为真</p> 
<p></p> 
<p>4、  RLIST</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>名称 RLIST  {寄存器列表}</p> 
<p></p> 
<p>RLIST伪指令可用于对一个通用寄存器列表定义名称，使用该伪指令定义的名称可在ARM指令LDM/STM中使用。在LDM/STM指令中，列表中的寄存器访问次序为根据寄存器的编号由低到高，而与列表中的寄存器排列次序无关。</p> 
<p></p> 
<p>    使用示例：</p> 
<p></p> 
<p>RegList RLIST   {R0-R5，R8，R10} ；将寄存器列表名称定义为RegList，可</p> 
<p></p> 
<p>在ARM指令LDM/STM中通过该名称访</p> 
<p></p> 
<p>问寄存器列表。</p> 
<p></p> 
<h3>11.2、数据定义（Data Definition）伪指令</h3> 
<p>数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常见的数据定义伪指令有如下9种：</p> 
<p></p> 
<p>1、  DCB</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>标号     DCB 表达式</p> 
<p></p> 
<p>DCB伪指令用于分配一片连续的字节存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为0～255的数字或字符串。DCB也可用“<strong>=</strong>”代替。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>Str DCB “This is a test！”  ；分配一片连续的字节存储单元并初始化。</p> 
<p></p> 
<p>2、  DCW（或DCWU）</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>标号     DCW（或DCWU）   表达式</p> 
<p></p> 
<p>DCW（或DCWU）伪指令用于分配一片连续的半字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。。</p> 
<p></p> 
<p>用DCW分配的字存储单元是半字对齐的，而用DCWU分配的字存储单元并不严格半字对齐。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>DataTest    DCW     1，2，3  ；分配一片连续的半字存储单元并初始化。</p> 
<p></p> 
<p>3、  DCD（或DCDU）</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>标号     DCD（或DCDU）   表达式</p> 
<p></p> 
<p>DCD（或DCDU）伪指令用于分配一片连续的字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。DCD也可用“&amp;”代替。</p> 
<p></p> 
<p>用DCD分配的字存储单元是字对齐的，而用DCDU分配的字存储单元并不严格字对齐。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>           DataTest   DCD     4，5，6  ；分配一片连续的字存储单元并初始化。</p> 
<p></p> 
<p>4、  DCFD（或DCFDU）</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>标号     DCFD（或DCFDU） 表达式</p> 
<p></p> 
<p>DCFD（或DCFDU）伪指令用于为双精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。每个双精度的浮点数占据两个字单元。</p> 
<p></p> 
<p>用DCFD分配的字存储单元是字对齐的，而用DCFDU分配的字存储单元并不严格字对齐。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>FDataTest   DCFD    2E115，-5E7 ；分配一片连续的字存储单元并初始化为指定的</p> 
<p></p> 
<p>双精度数。</p> 
<p></p> 
<p>5、  DCFS（或DCFSU）</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>标号     DCFS（或DCFSU） 表达式</p> 
<p></p> 
<p>DCFS（或DCFSU）伪指令用于为单精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。每个单精度的浮点数占据一个字单元。</p> 
<p></p> 
<p>用DCFS分配的字存储单元是字对齐的，而用DCFSU分配的字存储单元并不严格字对齐。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>FDataTest   DCFS    2E5，-5E－7  ；分配一片连续的字存储单元并初始化为指定的</p> 
<p></p> 
<p>单精度数。</p> 
<p></p> 
<p>6、  DCQ(或DCQU）</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>标号     DCQ（或DCQU）   表达式</p> 
<p></p> 
<p>DCQ（或DCQU）伪指令用于分配一片以8个字节为单位的连续存储区域并用伪指令中指定的表达式初始化。</p> 
<p></p> 
<p>用DCQ分配的存储单元是字对齐的，而用DCQU分配的存储单元并不严格字对齐。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>DataTest    DCQ     100          ；分配一片连续的存储单元并初始化为指定的值。</p> 
<p></p> 
<p>7、  SPACE</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>标号     SPACE   表达式</p> 
<p></p> 
<p>SPACE伪指令用于分配一片连续的存储区域并初始化为0。其中，表达式为要分配的字节数。SPACE也可用“％”代替。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>DataSpace   SPACE   100          ；分配连续100字节的存储单元并初始化为0。</p> 
<p></p> 
<p>8、  MAP</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>MAP      表达式{，基址寄存器}</p> 
<p></p> 
<p>MAP伪指令用于定义一个结构化的内存表的首地址。MAP也可用“＾”代替。</p> 
<p></p> 
<p>表达式可以为程序中的标号或数学表达式，基址寄存器为可选项，当基址寄存器选项不存在时，表达式的值即为内存表的首地址，当该选项存在时，内存表的首地址为表达式的值与基址寄存器的和。</p> 
<p></p> 
<p>MAP伪指令通常与FIELD伪指令配合使用来定义结构化的内存表。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>MAP 0x100，R0                    ；定义结构化内存表首地址的值为0x100＋R0。</p> 
<p></p> 
<p>9、  FILED</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>标号     FIELD   表达式</p> 
<p></p> 
<p>FIELD伪指令用于定义一个结构化内存表中的数据域。FILED也可用“#”代替。</p> 
<p></p> 
<p>表达式的值为当前数据域在内存表中所占的字节数。</p> 
<p></p> 
<p>FIELD伪指令常与MAP伪指令配合使用来定义结构化的内存表。MAP伪指令定义内存表的首地址，FIELD伪指令定义内存表中的各个数据域，并可以为每个数据域指定一个标号供其他的指令引用。</p> 
<p></p> 
<p>注意MAP和FIELD伪指令仅用于定义数据结构，并不实际分配存储单元。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>MAP     0x100                    ；定义结构化内存表首地址的值为0x100。</p> 
<p></p> 
<p>             A       FIELD   16      ；定义A的长度为16字节，位置为0x100</p> 
<p></p> 
<p>             B       FIELD   32      ；定义B的长度为32字节，位置为0x110</p> 
<p></p> 
<p>S       FIELD   256              ；定义S的长度为256字节，位置为0x130</p> 
<p></p> 
<h3>11.3、 汇编控制（Assembly Control）伪指令</h3> 
<p>汇编控制伪指令用于控制汇编程序的执行流程，常用的汇编控制伪指令包括以下4条：</p> 
<p></p> 
<p>1、  IF、ELSE、ENDIF</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p><strong>IF</strong>   逻辑表达式</p> 
<p></p> 
<p>     指令序列1</p> 
<p></p> 
<p><strong>ELSE</strong></p> 
<p></p> 
<p>     指令序列2</p> 
<p></p> 
<p>ENDIF</p> 
<p></p> 
<p>IF、ELSE、ENDIF伪指令能根据条件的成立与否决定是否执行某个指令序列。当IF后面的逻辑表达式为真，则执行指令序列1，否则执行指令序列2。其中，ELSE及指令序列2可以没有，此时，当IF后面的逻辑表达式为真，则执行指令序列1，否则继续执行后面的指令。</p> 
<p></p> 
<p>IF、ELSE、ENDIF伪指令可以嵌套使用。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>GBLL    Test                    ；声明一个全局的逻辑变量，变量名为Test</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p><strong>IF</strong>  Test <strong>=</strong> TRUE</p> 
<p></p> 
<p>指令序列1</p> 
<p></p> 
<p><strong>ELSE</strong></p> 
<p></p> 
<p>指令序列2</p> 
<p></p> 
<p>ENDIF</p> 
<p></p> 
<p>2、  WHILE、WEND</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>WHILE    逻辑表达式</p> 
<p></p> 
<p>     指令序列</p> 
<p></p> 
<p>WEND</p> 
<p></p> 
<p>WHILE、WEND伪指令能根据条件的成立与否决定是否循环执行某个指令序列。当WHILE后面的逻辑表达式为真，则执行指令序列，该指令序列执行完毕后，再判断逻辑表达式的值，若为真则继续执行，一直到逻辑表达式的值为假。</p> 
<p></p> 
<p>WHILE、WEND伪指令可以嵌套使用。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>GBLA    Counter                 ；声明一个全局的数学变量，变量名为Counter</p> 
<p></p> 
<p>Counter SETA        3           ；由变量Counter控制循环次数</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>WHILE   Counter <strong>&lt;</strong> 10</p> 
<p></p> 
<p>指令序列</p> 
<p></p> 
<p>WEND</p> 
<p></p> 
<p>3、  MACRO、MEND</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>$标号    宏名    $参数1，$参数2，……   </p> 
<p></p> 
<p>指令序列</p> 
<p></p> 
<p>MEND</p> 
<p></p> 
<p>MACRO、MEND伪指令可以将一段代码定义为一个整体，称为宏指令，然后就可以在程序中通过宏指令多次调用该段代码。其中，$标号在宏指令被展开时，标号会被替换为用户定义的符号，</p> 
<p></p> 
<p>宏指令可以使用一个或多个参数，当宏指令被展开时，这些参数被相应的值替换。</p> 
<p></p> 
<p>    宏指令的使用方式和功能与子程序有些相似，子程序可以提供模块化的程序设计、节省存储空间并提高运行速度。但在使用子程序结构时需要保护现场，从而增加了系统的开销，因此，在代码较短且需要传递的参数较多时，可以使用宏指令代替子程序。</p> 
<p></p> 
<p>    包含在MACRO和MEND之间的指令序列称为宏定义体，在宏定义体的第一行应声明宏的原型（包含宏名、所需的参数），然后就可以在汇编程序中通过宏名来调用该指令序列。在源程序被编译时，汇编器将宏调用展开，用宏定义中的指令序列代替程序中的宏调用，并将实际参数的值传递给宏定义中的形式参数。</p> 
<p></p> 
<p>MACRO、MEND伪指令可以嵌套使用。</p> 
<p></p> 
<p>4、  MEXIT</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>MEXIT</p> 
<p></p> 
<p>MEXIT用于从宏定义中跳转出去。</p> 
<p></p> 
<h3>11.4、其他常用的伪指令</h3> 
<p>还有一些其他的伪指令，在汇编程序中经常会被使用，包括以下13条：</p> 
<p></p> 
<p>1、  AREA</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>AREA 段名    属性1，属性2，…… </p> 
<p></p> 
<p>AREA伪指令用于定义一个代码段或数据段。其中，段名若以数字开头，则该段名需用“<strong>|</strong>”括起来，如<strong>|</strong>1_test<strong>|</strong>。</p> 
<p></p> 
<p>属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。常用的属性如下：</p> 
<p></p> 
<p>●CODE属性：用于定义代码段，默认为READONLY。</p> 
<p></p> 
<p>●DATA属性：用于定义数据段，默认为READWRITE。</p> 
<p></p> 
<p>●READONLY属性：指定本段为只读，代码段默认为READONLY。</p> 
<p></p> 
<p>●READWRITE属性：指定本段为可读可写，数据段的默认属性为READWRITE。</p> 
<p></p> 
<p>●ALIGN属性：使用方式为ALIGN 表达式。在默认时，ELF（可执行连接文件）的代码段和数据段是按字对齐的，表达式的取值范围为0～31，相应的对齐方式为2表达式次方。</p> 
<p></p> 
<p>●COMMON属性：该属性定义一个通用的段，不包含任何的用户代码和数据。各源文件中同名的COMMON段共享同一段存储单元。</p> 
<p></p> 
<p>一个汇编语言程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY</p> 
<p></p> 
<p>指令序列</p> 
<p></p> 
<p>；该伪指令定义了一个代码段，段名为Init，属性为只读</p> 
<p></p> 
<p>2、  ALIGN</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>ALIGN    {表达式{，偏移量}}  </p> 
<p></p> 
<p>ALIGN伪指令可通过添加填充字节的方式，使当前位置满足一定的对其方式<strong>|</strong>。其中，表达式的值用于指定对齐方式，可能的取值为2的幂，如1、2、4、 8、16等。若未指定表达式，则将当前位置对齐到下一个字的位置。偏移量也为一个数字表达式，若使用该字段，则当前位置的对齐方式为：2的表达式次幂＋偏移量。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY，ALIEN＝3   ；指定后面的指令为8字节对齐。</p> 
<p></p> 
<p>指令序列</p> 
<p></p> 
<p>END</p> 
<p></p> 
<p>3、  CODE16、CODE32</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>CODE16（或CODE32）</p> 
<p></p> 
<p>CODE16伪指令通知编译器，其后的指令序列为16位的Thumb指令。</p> 
<p></p> 
<p>CODE32伪指令通知编译器，其后的指令序列为32位的ARM指令。</p> 
<p></p> 
<p>若在汇编源程序中同时包含ARM指令和Thumb指令时，可用CODE16伪指令通知编译器其后的指令序列为16位的Thumb指令，CODE32伪指令通知编译器其后的指令序列为32位的ARM指令。因此，在使用ARM指令和Thumb指令混合编程的代码里，可用这两条伪指令进行切换，但注意他们只通知编译器其后指令的类型，并不能对处理器进行状态的切换。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>CODE32              ；通知编译器其后的指令为32位的ARM指令</p> 
<p></p> 
<p>LDR R0，＝NEXT＋1    ；将跳转地址放入寄存器R0</p> 
<p></p> 
<p>BX  R0              ；程序跳转到新的位置执行，并将处理器切换到Thumb工作状态</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>CODE16              ；通知编译器其后的指令为16位的Thumb指令</p> 
<p></p> 
<p>NEXT    LDR R3，＝0x3FF  </p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>END                 ；程序结束</p> 
<p></p> 
<p>4、  ENTRY</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>ENTRY</p> 
<p></p> 
<p>ENTRY伪指令用于指定汇编程序的入口点。在一个完整的汇编程序中至少要有一个ENTRY（也可以有多个，当有多个ENTRY时，程序的真正入口点由链接器指定），但在一个源文件里最多只能有一个ENTRY（可以没有）。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY</p> 
<p></p> 
<p>ENTRY                                  ；指定应用程序的入口点</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>5、  END</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>END</p> 
<p></p> 
<p>END伪指令用于通知编译器已经到了源程序的结尾。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>END                                    ；指定应用程序的结尾</p> 
<p></p> 
<p>6、  EQU</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>名称     EQU 表达式{，类型}</p> 
<p></p> 
<p>EQU伪指令用于为程序中的常量、标号等定义一个等效的字符名称，类似于C语言中的＃define。其中EQU可用“<strong>*</strong>”代替。</p> 
<p></p> 
<p>名称为EQU伪指令定义的字符名称，当表达式为32位的常量时，可以指定表达式的数据类型，可以有以下三种类型：</p> 
<p></p> 
<p>CODE16、CODE32和DATA</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>Test    EQU 50                        ；定义标号Test的值为50</p> 
<p></p> 
<p>Addr EQU 0x55，CODE32                ；定义Addr的值为0x55，且该处为32位的ARM</p> 
<p></p> 
<p>指令。</p> 
<p></p> 
<p>7、  EXPORT（或GLOBAL）</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>EXPORT       标号{[WEAK]}</p> 
<p></p> 
<p>EXPORT伪指令用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。EXPORT可用GLOBAL代替。标号在程序中区分大小写，[WEAK]选项声明其他的同名标号优先于该标号被引用。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY</p> 
<p></p> 
<p>EXPORT      Stest               ；声明一个可全局引用的标号Stest</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>END                 </p> 
<p></p> 
<p>8、  IMPORT</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>IMPORT       标号{[WEAK]}</p> 
<p></p> 
<p>IMPORT伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，而且无论当前源文件是否引用该标号，该标号均会被加入到当前源文件的符号表中。</p> 
<p></p> 
<p>标号在程序中区分大小写，[WEAK]选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY</p> 
<p></p> 
<p>IMPORT      Main                ；通知编译器当前文件要引用标号Main，</p> 
<p></p> 
<p>但Main在其他源文件中定义</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>END                 </p> 
<p></p> 
<p>9、  EXTERN</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>EXTERN       标号{[WEAK]}</p> 
<p></p> 
<p>EXTERN伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，如果当前源文件实际并未引用该标号，该标号就不会被加入到当前源文件的符号表中。</p> 
<p></p> 
<p>标号在程序中区分大小写，[WEAK]选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY</p> 
<p></p> 
<p>EXTERN      Main                  ；通知编译器当前文件要引用标号Main，</p> 
<p></p> 
<p>但Main在其他源文件中定义</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>END                 </p> 
<p></p> 
<p>10、GET（或INCLUDE）</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>GET      文件名</p> 
<p></p> 
<p>GET伪指令用于将一个源文件包含到当前的源文件中，并将被包含的源文件在当前位置进行汇编处理。可以使用INCLUDE代替GET。</p> 
<p></p> 
<p>汇编程序中常用的方法是在某源文件中定义一些宏指令，用EQU定义常量的符号名称，用MAP和FIELD定义结构化的数据类型，然后用GET伪指令将这个源文件包含到其他的源文件中。使用方法与C语言中的“include”相似。</p> 
<p></p> 
<p>GET伪指令只能用于包含源文件，包含目标文件需要使用INCBIN伪指令</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY</p> 
<p></p> 
<p>GET a1.s                     ；通知编译器当前源文件包含源文件a1.s</p> 
<p></p> 
<p>GE  T   C：a2.s            ；通知编译器当前源文件包含源文件C： a2.s</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>END                 </p> 
<p></p> 
<p>11、INCBIN</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>INCBIN       文件名</p> 
<p></p> 
<p>INCBIN伪指令用于将一个目标文件或数据文件包含到当前的源文件中，被包含的文件不作任何变动的存放在当前文件中，编译器从其后开始继续处理。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>AREA    Init，CODE，READONLY</p> 
<p></p> 
<p>INCBIN      a1.dat          ；通知编译器当前源文件包含文件a1.dat</p> 
<p></p> 
<p>INCBIN C：a2.txt          ；通知编译器当前源文件包含文件C：a2.txt</p> 
<p></p> 
<p>……</p> 
<p></p> 
<p>END                 </p> 
<p></p> 
<p>12、RN</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>名称     RN      表达式</p> 
<p></p> 
<p>RN伪指令用于给一个寄存器定义一个别名。采用这种方式可以方便程序员记忆该寄存器的功能。其中，名称为给寄存器定义的别名，表达式为寄存器的编码。</p> 
<p></p> 
<p>使用示例：</p> 
<p></p> 
<p>Temp    RN  R0               ；将R0定义一个别名Temp</p> 
<p></p> 
<p>13、ROUT</p> 
<p></p> 
<p>语法格式：</p> 
<p></p> 
<p>{名称}   ROUT</p> 
<p></p> 
<p>ROUT伪指令用于给一个局部变量定义作用范围。在程序中未使用该伪指令时，局部变量的作用范围为所在的AREA，而使用ROUT后，局部变量的作为范围为当前ROUT和下一个ROUT之间。</p> 
<p></p> 
<p></p> 
<p><strong>********************************************************************************</strong>                                                                             <strong>*</strong></p> 
<p><strong>*</strong>                                                                             <strong>*</strong></p> 
<p><strong>*******************************************************************************</strong></p> 
<p>4 ARM GNU常用汇编语言介绍</p> 
<p></p> 
<p>4.1 ARM GNU常用汇编伪指令介绍</p> 
<p><strong>1.   abort</strong></p> 
<pre><code class="language-cpp">.abort    ;停止汇编</code></pre> 
<pre><code>.align ab***pr1,ab***pr2   ;</code></pre> 
<p>以某种对齐方式,在未使用的存储区域填充值. 第一个值表示对齐方式,4, 8,16或32. 第二个表达式值表示填充的值.</p> 
<p></p> 
<p><strong>2.    if...else...endif</strong></p> 
<pre><code class="language-cpp">.if

.else

.endif</code></pre> 
<p> 支持条件预编译</p> 
<p></p> 
<p>3. include</p> 
<p>.include "file": 包含指定的头文件, 可以把一个汇编常量定义放在头文件中.</p> 
<p>4. comm</p> 
<p>.comm  symbol, length:在bss段申请一段命名空间,该段空间的名称叫symbol, 长度为length. Ld连接器在连接会</p> 
<p>为它留出空间.</p> 
<p></p> 
<p>5. data</p> 
<p>.data subsection: 说明接下来的定义归属于subsection数据段.</p> 
<p></p> 
<p>6. equ</p> 
<p>.equ symbol, expression: 把某一个符号(symbol)定义成某一个值(expression).该指令并不分配空间.</p> 
<p></p> 
<p>7. global</p> 
<p>.global symbol: 定义一个全局符号, 通常是为ld使用.</p> 
<p></p> 
<p>8. ascii</p> 
<p>.ascii "string": 定义一个字符串并为之分配空间.</p> 
<p></p> 
<p>9. byte</p> 
<p>.byte expressions: 定义一个字节, 并为之分配空间.</p> 
<p></p> 
<p>10. short</p> 
<p>.short expressions: 定义一个短整型, 并为之分配空间.</p> 
<p></p> 
<p>11. int</p> 
<p>.int expressions: 定义一个整型,并为之分配空间.</p> 
<p></p> 
<p>12 long</p> 
<p>.long expressions: 定义一个长整型, 并为之分配空间.</p> 
<p></p> 
<p>13 word</p> 
<p>.word expressions: 定义一个字,并为之分配空间, 4bytes.</p> 
<p></p> 
<p>14. macro/endm</p> 
<p>.macro: 定义一段宏代码, .macro表示代码的开始, .endm表示代码的结束.</p> 
<p></p> 
<p>15. req</p> 
<p>name .req register name: 为寄存器定义一个别名.</p> 
<p></p> 
<p>16. code</p> 
<p>.code [16<strong>|</strong>32]: 指定指令代码产生的长度, 16表示Thumb指令, 32表示ARM指令.</p> 
<p></p> 
<p>17. ltorg</p> 
<p>.ltorg: 表示当前往下的定义在归于当前段,并为之分配空间.</p> 
<p></p> 
<p>4.2 ARM GNU专有符号</p> 
<p>1. @</p> 
<p>表示注释从当前位置到行尾的字符.</p> 
<p></p> 
<p>2. #</p> 
<p>注释掉一整行.</p> 
<p></p> 
<p>3. ;</p> 
<p>新行分隔符.</p> 
<p></p> 
<p>4.3 操作码</p> 
<p></p> 
<p>1. NOP</p> 
<p>nop</p> 
<p>空操作, 相当于MOV r0, r0</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>