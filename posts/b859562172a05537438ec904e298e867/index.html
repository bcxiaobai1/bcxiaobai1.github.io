<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>c#快速入门~在java基础上，知道C#和JAVA 的不同即可 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c#快速入门~在java基础上，知道C#和JAVA 的不同即可</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h2 id="c-学习参考文档和开发工具" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">C# 概述</span></span></strong></h2> 
<h3 id="c-概述-1" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">C# 概述</span></span></strong></h3> 
<ul style="margin-left:30px">
<li>C#（发音为 <strong>"C sharp"</strong>）是一种新式编程语言，不仅<strong>面向对象</strong>，还类型安全。</li>
<li>它是由 <strong><span style="color:#FF0000">微软</span></strong> （Microsoft）开发的。</li>
<li>
<strong><span style="color:#FF0000">C# 编程是基于 C 和 C++ 编程语言的, 源于 C 语言系列</span></strong> 。</li>
<li>虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言， <strong><span style="color:#FF0000">但是它与 Java 非常相似</span></strong> 。</li>
<li>
<strong><span style="color:#FF0000">C# 程序在 .NET 上运行</span></strong> 。</li>
<li>C# 文件的后缀为 <strong>.cs</strong>。</li>
</ul> 
<blockquote> 
 <h3 id="c-与net的关系" style="margin-left:0"><strong><span style="color:#000000">C# 与.Net的关系</span></strong></h3> 
 <ul style="margin-left:25px">
<li>C# 是由 Anders Hejlsberg 和他的团队<strong>在 .Net 框架开发期间开发的</strong>。</li>
<li>
<strong>C# 程序在 .NET 上运行</strong>，而 .NET 是名为公共语言运行时 (CLR) 的虚执行系统和一组类库。 CLR 是 Microsoft 对公共语言基础结构 (CLI) 国际标准的实现。</li>
<li>.NET是微软公司下的一个开发平台，.NET核心就是.NET Framwork（.NET框架）是.NET程序开发和运行的环境。</li>
<li>用 C# 编写的源代码被编译成符合 CLI 规范的<a href="https://learn.microsoft.com/zh-cn/dotnet/standard/managed-code" title="中间语言 (IL)">中间语言 (IL)</a>。 IL 代码和资源（如位图和字符串）存储在扩展名通常为 .dll 的程序集中。 程序集包含一个介绍程序集的类型、版本和区域性的清单。</li>
<li>通过 C# 生成的 IL 代码可以与通过 .NET 版本的 F#、Visual Basic、C++ 生成的代码进行交互。</li>
</ul> 
</blockquote> 
<p></p> 
<h3 id="c-特性" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">C# 特性</span></span></strong></h3> 
<blockquote> 
 <p style="margin-left:auto">简单，现代，<strong>面向对象</strong>，<strong>类型安全</strong>，<strong>版本控制</strong>，<strong>兼容</strong>，灵活</p> 
</blockquote> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto"><strong>简单</strong>：虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言， <strong><span style="color:#FF0000">但是它与 Java 非常相似</span></strong> 。所以它容易上手</p> </li>
<li> <p style="margin-left:auto"><strong>类型安全</strong>：C# 允许动态分配轻型结构的对象和内嵌存储。 C# 支持泛型方法和类型，因此增强了类型安全性和性能。</p> </li>
<li> <p style="margin-left:auto"><strong>兼容</strong>: C# 有<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/types/" title="统一类型系统">统一类型系统</a>。 所有 C# 类型（包括 <code>int</code> 和 <code>double</code> 等基元类型）均继承自一个根 <code>object</code> 类型。 所有类型共用一组通用运算。 任何类型的值都可以一致地进行存储、传输和处理。 此外，C# 还支持用户定义的<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types" title="引用类型">引用类型</a>和<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types" title="值类型">值类型</a>。</p> </li>
<li> <p style="margin-left:auto"><strong>版本控制</strong>：C# 强调版本控制，以确保程序和库以兼容方式随时间推移而变化。 C# 设计中受版本控制加强直接影响的方面包括：单独的 <code>virtual</code> 和 <code>override</code> 修饰符，关于方法重载决策的规则，以及对显式接口成员声明的支持。</p> </li>
</ul> 
<p></p> 
<h3 id="c-流行原因" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">C# 流行原因：</span></span></strong></h3> 
<ul style="margin-left:30px">
<li>现代的、通用的编程语言。</li>
<li>面向对象。</li>
<li>面向组件。</li>
<li>容易学习。</li>
<li>结构化语言。</li>
<li>它产生高效率的程序。</li>
<li>它可以在多种计算机平台上编译。</li>
<li>.Net 框架的一部分。</li>
</ul> 
<p></p> 
<h3 id="c-一些重要的功能" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">C# 一些重要的功能：</span></span></strong></h3> 
<ul style="margin-left:30px">
<li>布尔条件（Boolean Conditions）</li>
<li>自动垃圾回收（Automatic Garbage Collection）</li>
<li>标准库（Standard Library）</li>
<li>组件版本（Assembly Versioning）</li>
<li>属性（Properties）和事件（Events）</li>
<li>委托（Delegates）和事件管理（Events Management）</li>
<li>易于使用的泛型（Generics）</li>
<li>索引器（Indexers）</li>
<li>条件编译（Conditional Compilation）</li>
<li>简单的多线程（Multithreading）</li>
<li>LINQ 和 Lambda 表达式</li>
<li>集成 Windows</li>
</ul> 
<p style="margin-left:auto"><br><br>  </p> 
<h1 id="c-快速入门c-和-java-的不同" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">c# 快速入门~C# 和 java 的不同</span></span></strong></h1> 
<h2 id="1入门demo的hello-world" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">1、入门demo的hello world</span></span></strong></h2> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;using System;
namespace HelloWorldApplication
{
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;HelloWorld&lt;/span&gt;
   {
      &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
      {
         &lt;span style="color:#008000"&gt;/* 我的第一个 C# 程序*/&lt;/span&gt;
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"Hello World"&lt;/span&gt;);
         Console.ReadKey();
      }
   }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto"><strong>using</strong> 关键字用于在程序中包含 <strong>System</strong> 命名空间。 一个程序一般有多个 <strong>using</strong> 语句。</p> </li>
<li> <p style="margin-left:auto">命名空间声明（Namespace declaration）</p> </li>
<li> <p style="margin-left:auto">最后一行 <strong>Console.ReadKey();</strong> 是针对 VS.NET 用户的。这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭</p> </li>
</ul> 
<p></p> 
<h3 id="-如果是通过-visual-studio-写的c-项目" style="background-color:transparent;margin-left:0px"><strong><span style="color:#000000"><span style="background-color:#ffffff">☺ 如果是通过 Visual Studio 写的c# 项目：</span></span></strong></h3> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">目录结构：</span></span></p> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto">解决方案：相当于项目的工程空间，工程空间是可以有多个项目的</p> </li>
<li> <p style="margin-left:auto">.vs文件: 是和项目配置相关的</p> </li>
<li> <p style="margin-left:auto">后缀 .sln 文件：是解决方案文件，通过该文件可以打开解决方案</p> </li>
<li> <p style="margin-left:auto">项目中后缀是 .cs 文件：就是咱用 c# 写的代码</p> </li>
</ul> 
<p></p> 
<h3 id="-对于hello-world-程序" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">☺ 对于hello world 程序</span></span></strong></h3> 
<h3 id="1-using" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">(1) using</span></span></strong></h3> 
<ul style="margin-left:30px"><li><strong><span style="color:#FF0000">在任何 C# 程序中的第一条语句都是：using System;</span></strong></li></ul> 
<h3 id="2-namespace" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">(2) namespace</span></span></strong></h3> 
<p></p> 
<h2 id="2注释" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">2、注释</span></span></strong></h2> 
<ul style="margin-left:30px">
<li>和java 是一样的~</li>
<li>补充：关键词 #region 和 #endregion 用来管理注释</li>
</ul> 
<p style="margin-left:auto"></p> 
<p class="img-center"><img alt="" class="medium-zoom-image" height="156" src="https://images2.imgbox.com/eb/9d/O5bssaK1_o.png" width="1200"></p> 
<p></p> 
<h2 id="3变量命名规范" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">3、变量命名规范</span></span></strong></h2> 
<ul style="margin-left:30px"><li>除了数字、字母，还可以是@</li></ul> 
<p></p> 
<h2 id="4c-的变量类型还包含了指针类型" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">4、C# 的变量类型：还包含了指针类型</span></span></strong></h2> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">在 C# 中，变量分为以下几种类型：</span></span></p> 
<ul style="margin-left:30px">
<li>值类型（Value types）</li>
<li>引用类型（Reference types）</li>
<li>指针类型（Pointer types）</li>
</ul> 
<p></p> 
<h3 id="引用类型" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">引用类型：</span></span></strong></h3> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff"><strong>内置的引用类型</strong>有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</span></span></p> 
<p></p> 
<h4 id="-动态dynamic类型" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 动态（Dynamic）类型</span></span></strong></h4> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在<strong>运行时</strong>发生的。</span></span></p> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">声明动态类型的语法：dynamic &lt;variable_name&gt; = value;</span></span></p> 
<ul style="margin-left:30px"><li>举例子：dynamic d = 20;</li></ul> 
<p></p> 
<h4 id="-字符串string类型还有-修饰有其相对的意义" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">☺ 字符串（String）类型：还有@ 修饰，@有其相对的意义</span></span></strong></h4> 
<ul style="margin-left:30px">
<li>字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</li>
<li>举例子1：使用引号的</li>
</ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;String str = &lt;span style="color:#a31515"&gt;"runoob.com"&lt;/span&gt;;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li> <p style="margin-left:auto">举例子2：使用@，意义：</p> <p style="margin-left:auto">（1）取消  在字符串中的转义作用，使其单纯的表示为一个‘’。<br> （2）将字符串按照编辑的原格式输出。</p> </li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#0000ff"&gt;string&lt;/span&gt; str = @&lt;span style="color:#a31515"&gt;"C:Windows"&lt;/span&gt;; &lt;span style="color:#008000"&gt;//相当于string str = "C:\Windows";&lt;/span&gt;

&lt;span style="color:#008000"&gt;//作用2：使其按照编辑的原格式输出&lt;/span&gt;
Console.WriteLine(@&lt;span style="color:#a31515"&gt;"你好啊！
我的朋友！"&lt;/span&gt;);
Console.ReadKey();

&lt;span style="color:#008000"&gt;//输出结果为：&lt;/span&gt;
你好啊！
我的朋友！   
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h4 id="-指针类型pointer-types" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 指针类型（Pointer types）</span></span></strong></h4> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto">C# 中的指针与 C 或 C++ 中的指针有相同的功能。语法：type* identifier;</p> </li>
<li> <p style="margin-left:auto">举例子：</p> </li>
</ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#a31515"&gt;char&lt;/span&gt;* cptr;
&lt;span style="color:#a31515"&gt;int&lt;/span&gt;* iptr;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h4 id="-用户自定义引用类型有classinterface-或-delegate" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 用户自定义引用类型有：class、interface 或 delegate。</span></span></strong></h4> 
<p></p> 
<h2 id="5定义常量使用关键词-const" style="background-color:transparent;margin-left:0px"><strong><span style="color:#000000"><span style="background-color:#ffffff">5、定义常量，使用关键词 const</span></span></strong></h2> 
<p></p> 
<h2 id="6占位符的" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">6、占位符的</span></span></strong></h2> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto">Console.WriteLine的后半部的参数变量的顺序就是对应 {0}、{1}、{2}、{3}...</p> </li>
<li> <p style="margin-left:auto">举例子：</p> </li>
</ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#a31515"&gt;int&lt;/span&gt; n1 = &lt;span style="color:#880000"&gt;10&lt;/span&gt;;
&lt;span style="color:#a31515"&gt;int&lt;/span&gt; n2 = &lt;span style="color:#880000"&gt;20&lt;/span&gt;;
&lt;span style="color:#a31515"&gt;int&lt;/span&gt; n3 = &lt;span style="color:#880000"&gt;30&lt;/span&gt;;
Console.WriteLine(&lt;span style="color:#a31515"&gt;"参数结果是:{0},{1},{2}"&lt;/span&gt;, n1, n2, n3);
Console.ReadKey();

&lt;span style="color:#008000"&gt;//输出结果为：&lt;/span&gt;
参数结果是:&lt;span style="color:#880000"&gt;10&lt;/span&gt;,&lt;span style="color:#880000"&gt;20&lt;/span&gt;,&lt;span style="color:#880000"&gt;30&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h2 id="7c-的运算符和java-不太一样的是它还有其他运算符" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">7、C# 的运算符，和java 不太一样的是它还有<code>其他运算符</code></span></span></strong></h2> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto">对于算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符 和java是一样的</p> </li>
<li> <p style="margin-left:auto"><code>其他运算符</code>:</p> </li>
</ul> 
<div style="margin-left:0"> 
 <table border="1" cellspacing="0">
<thead><tr>
<th style="background-color:#fafafa;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">运算符</span></span></th>
<th style="background-color:#fafafa;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">描述</span></span></th>
<th style="background-color:#fafafa;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">实例</span></span></th>
</tr></thead>
<tbody>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">is</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><span style="color:#FF0000">判断对象是否为某一类型。</span></span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">as</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><span style="color:#FF0000">强制转换，即使转换失败也不会抛出异常。</span></span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">Object obj = new StringReader("Hello"); StringReader r = obj as StringReader;</span></span></td>
</tr>
</tbody>
</table> 
</div> 
<p></p> 
<h2 id="8c-的访问权限-privateprotectedinternalprotected-internalpublic" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">8、C# 的访问权限-private、protected、internal、protected internal、public</span></span></strong></h2> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto">和java有点点不一样的是，default 权限在C# 被叫为internal，并且c# 多了一个访问权限为protected internal</p> </li>
<li> <p style="margin-left:auto">其他的都是差不多一样的： private、protected、internal、protected internal、public</p> </li>
</ul> 
<p style="margin-left:auto"></p> 
<p class="img-center"><img alt="" height="247" src="https://images2.imgbox.com/b8/6e/qCNuEcqd_o.png" width="256"></p> 
<p></p> 
<h2 id="-9c-方法的参数传递ref关键词的使用实现参数作为引用类型out关键字的使用实现参数作为输出类型" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">☺ 9、C# 方法的参数传递，<code>ref关键词的使用，实现参数作为引用类型，out关键字的使用，实现参数作为输出类型</code></span></span></strong></h2> 
<ul style="margin-left:30px">
<li>c# 方法的定义，调用和java 是一模一样的</li>
<li>参数的传递和 java 也是一模一样的，有三种情况：值参数、引用参数、输出参数</li>
</ul> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">☺ 输出参数的作用：方法没有返回值时，而需要从该方法中返回结果的时候，需要使用输出参数</span></span></p> 
<p></p> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">■ <code>ref 类型的使用，实现参数作为引用类型</code>:</span></span></p> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;using System;
namespace CalculatorApplication
{
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;NumberManipulator&lt;/span&gt;
   {
      public &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;swap&lt;/span&gt;(ref &lt;span style="color:#a31515"&gt;int&lt;/span&gt; x, ref &lt;span style="color:#a31515"&gt;int&lt;/span&gt; y)
      {
         &lt;span style="color:#a31515"&gt;int&lt;/span&gt; temp;

         temp = x; &lt;span style="color:#008000"&gt;/* 保存 x 的值 */&lt;/span&gt;
         x = y;    &lt;span style="color:#008000"&gt;/* 把 y 赋值给 x */&lt;/span&gt;
         y = temp; &lt;span style="color:#008000"&gt;/* 把 temp 赋值给 y */&lt;/span&gt;
       }
   
      &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
      {
         NumberManipulator n = new NumberManipulator();
         &lt;span style="color:#008000"&gt;/* 局部变量定义 */&lt;/span&gt;
         &lt;span style="color:#a31515"&gt;int&lt;/span&gt; a = &lt;span style="color:#880000"&gt;100&lt;/span&gt;;
         &lt;span style="color:#a31515"&gt;int&lt;/span&gt; b = &lt;span style="color:#880000"&gt;200&lt;/span&gt;;

         Console.WriteLine(&lt;span style="color:#a31515"&gt;"在交换之前，a 的值： {0}"&lt;/span&gt;, a);
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"在交换之前，b 的值： {0}"&lt;/span&gt;, b);

         &lt;span style="color:#008000"&gt;/* 调用函数来交换值 */&lt;/span&gt;
         n.swap(ref a, ref b);&lt;span style="color:#008000"&gt;//-------这里使用了关键词ref，实现了参数作用引用类型--------&lt;/span&gt;

         Console.WriteLine(&lt;span style="color:#a31515"&gt;"在交换之后，a 的值： {0}"&lt;/span&gt;, a);
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"在交换之后，b 的值： {0}"&lt;/span&gt;, b);
 
         Console.ReadLine();

      }
   }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>结果：</li></ul> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">在交换之前，a 的值：100<br> 在交换之前，b 的值：200<br> 在交换之后，a 的值：100<br> 在交换之后，b 的值：200</span></span></p> 
<p></p> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">■ <code>out关键字的使用，实现参数作为输出类型</code>：</span></span></p> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;using System;

namespace CalculatorApplication
{
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;NumberManipulator&lt;/span&gt;
   {
      public &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;getValue&lt;/span&gt;(out &lt;span style="color:#a31515"&gt;int&lt;/span&gt; x )
      {
         &lt;span style="color:#a31515"&gt;int&lt;/span&gt; temp = &lt;span style="color:#880000"&gt;5&lt;/span&gt;;
         x = temp;
      }
   
      &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
      {
         NumberManipulator n = new NumberManipulator();
         &lt;span style="color:#008000"&gt;/* 局部变量定义 */&lt;/span&gt;
         &lt;span style="color:#a31515"&gt;int&lt;/span&gt; a = &lt;span style="color:#880000"&gt;100&lt;/span&gt;;
         
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"在方法调用之前，a 的值： {0}"&lt;/span&gt;, a);
         
         &lt;span style="color:#008000"&gt;/* 调用函数来获取值 */&lt;/span&gt;
         n.getValue(out a);&lt;span style="color:#008000"&gt;//-------这里使用了关键词out，实现了实现参数作为输出类型--------&lt;/span&gt;

         Console.WriteLine(&lt;span style="color:#a31515"&gt;"在方法调用之后，a 的值： {0}"&lt;/span&gt;, a);
         Console.ReadLine();

      }
   }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>结果：</li></ul> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">在方法调用之前，a 的值： 100<br> 在方法调用之后，a 的值： 5</span></span></p> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="10不定长参数-关键词-params数组" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">10、不定长参数-关键词 params+数组</span></span></strong></h2> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;public 返回类型 方法名称( params 类型名称[] 数组名称 )
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>举例子：</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;using System;

namespace ArrayApplication
{
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;ParamArray&lt;/span&gt;
   {
      public &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;AddElements&lt;/span&gt;(params &lt;span style="color:#a31515"&gt;int&lt;/span&gt;[] arr)  &lt;span style="color:#008000"&gt;//-----------不定长参数----------&lt;/span&gt;
      {
         &lt;span style="color:#a31515"&gt;int&lt;/span&gt; sum = &lt;span style="color:#880000"&gt;0&lt;/span&gt;;
         foreach (&lt;span style="color:#a31515"&gt;int&lt;/span&gt; i in arr)
         {
            sum += i;
         }
         &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; sum;
      }
   }
  
    
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;TestClass&lt;/span&gt;
   {
      &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
      {
         ParamArray app = new ParamArray();
         &lt;span style="color:#a31515"&gt;int&lt;/span&gt; sum = app.AddElements(&lt;span style="color:#880000"&gt;512&lt;/span&gt;, &lt;span style="color:#880000"&gt;720&lt;/span&gt;, &lt;span style="color:#880000"&gt;250&lt;/span&gt;, &lt;span style="color:#880000"&gt;567&lt;/span&gt;, &lt;span style="color:#880000"&gt;889&lt;/span&gt;);
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"总和是： {0}"&lt;/span&gt;, sum);
         Console.ReadKey();
      }
   }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="11可空类型--单问号--与-双问号-" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">11、可空类型--单问号 ? 与 双问号 ??</span></span></strong></h2> 
<h3 id="-可空类型nullable-type表示在值类型的正常取值范围内再加上一个null值" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 可空类型（Nullable Type）表示在值类型的正常取值范围内再加上一个null值.</span></span></strong></h3> 
<ul style="margin-left:30px"><li>举例子：</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#a31515"&gt;int&lt;/span&gt; i; &lt;span style="color:#008000"&gt;//默认值0&lt;/span&gt;
&lt;span style="color:#a31515"&gt;int&lt;/span&gt;? ii; &lt;span style="color:#008000"&gt;//默认值null，可空的int&lt;/span&gt;

&lt;span style="color:#008000"&gt;//-----------------------&lt;/span&gt;
&lt;span style="color:#a31515"&gt;int&lt;/span&gt;? i = &lt;span style="color:#880000"&gt;3&lt;/span&gt;; &lt;span style="color:#008000"&gt;// 相当于Nullable&lt;int&gt; i = new Nullable&lt;int&gt;(3);&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h3 id="-一个和两个的区别" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 一个？和两个？的区别：</span></span></strong></h3> 
<ul style="margin-left:30px">
<li>一个问号：用于定义值变量是可空的值变量。</li>
<li>两个问号：用于判断一个可空的变量当前值是否为null，若是null，则返回指定的值。</li>
</ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;a = b ?? c &lt;span style="color:#008000"&gt;//b是一个可空的值变量，如果 b 为 null，则 a = c，如果 b 不为 null，则 a = b&lt;/span&gt;
    
&lt;span style="color:#a31515"&gt;double&lt;/span&gt;? num1 = null;
&lt;span style="color:#a31515"&gt;double&lt;/span&gt; num3 = num1 ?? &lt;span style="color:#880000"&gt;5.34&lt;/span&gt;;      &lt;span style="color:#008000"&gt;// num1 如果为空值则返回 5.34&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="12二维数组的写法有点不同" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">12、二维数组的写法有点不同</span></span></strong></h2> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;	   &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
        {
            &lt;span style="color:#008000"&gt;/* 一个带有 5 行 2 列的数组 */&lt;/span&gt;
            &lt;span style="color:#a31515"&gt;int&lt;/span&gt;[,] a = new &lt;span style="color:#a31515"&gt;int&lt;/span&gt;[&lt;span style="color:#880000"&gt;5&lt;/span&gt;, &lt;span style="color:#880000"&gt;2&lt;/span&gt;] {<!-- -->{&lt;span style="color:#880000"&gt;0&lt;/span&gt;,&lt;span style="color:#880000"&gt;0&lt;/span&gt;}, {&lt;span style="color:#880000"&gt;1&lt;/span&gt;,&lt;span style="color:#880000"&gt;2&lt;/span&gt;}, {&lt;span style="color:#880000"&gt;2&lt;/span&gt;,&lt;span style="color:#880000"&gt;4&lt;/span&gt;}, {&lt;span style="color:#880000"&gt;3&lt;/span&gt;,&lt;span style="color:#880000"&gt;6&lt;/span&gt;}, {&lt;span style="color:#880000"&gt;4&lt;/span&gt;,&lt;span style="color:#880000"&gt;8&lt;/span&gt;} };

            &lt;span style="color:#a31515"&gt;int&lt;/span&gt; i, j;
            &lt;span style="color:#008000"&gt;/* 输出数组中每个元素的值 */&lt;/span&gt;
            &lt;span style="color:#0000ff"&gt;for&lt;/span&gt; (i = &lt;span style="color:#880000"&gt;0&lt;/span&gt;; i &lt; &lt;span style="color:#880000"&gt;5&lt;/span&gt;; i++)
            {
                &lt;span style="color:#0000ff"&gt;for&lt;/span&gt; (j = &lt;span style="color:#880000"&gt;0&lt;/span&gt;; j &lt; &lt;span style="color:#880000"&gt;2&lt;/span&gt;; j++)
                {
                    Console.WriteLine(&lt;span style="color:#a31515"&gt;"a[{0},{1}] = {2}"&lt;/span&gt;, i, j, a[i,j]);
                }
            }
           Console.ReadKey();
        }
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<h3 id="-array-类的常用方法" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ Array 类的常用方法：</span></span></strong></h3> 
<h2 id="array-类的方法" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">Array 类的方法</span></span></strong></h2> 
<ul style="margin-left:30px"><li>Array 类的常用属性：<strong>Length</strong> 或 <strong>LongLength</strong>
</li></ul> 
<div style="margin-left:0"> 
 <table border="1" cellspacing="0">
<thead><tr>
<th style="background-color:#fafafa;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">序号</span></span></th>
<th style="background-color:#fafafa;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">方法 &amp; 描述</span></span></th>
</tr></thead>
<tbody>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">1</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>Clear</strong> 根据元素的类型，设置数组中某个范围的元素为零、为 false 或者为 null。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">2</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>Copy(Array, Array, Int32)</strong> 从数组的第一个元素开始复制某个范围的元素到另一个数组的第一个元素位置。长度由一个 32 位整数指定。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">3</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>CopyTo(Array, Int32)</strong> 从当前的一维数组中复制所有的元素到一个指定的一维数组的指定索引位置。索引由一个 32 位整数指定。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">4</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>GetLength</strong> 获取一个 32 位整数，该值表示指定维度的数组中的元素总数。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">5</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>GetLongLength</strong> 获取一个 64 位整数，该值表示指定维度的数组中的元素总数。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">6</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>GetLowerBound</strong> 获取数组中指定维度的下界。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">7</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>GetType</strong> 获取当前实例的类型。从对象（Object）继承。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">8</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>GetUpperBound</strong> 获取数组中指定维度的上界。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">9</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>GetValue(Int32)</strong> 获取一维数组中指定位置的值。索引由一个 32 位整数指定。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">10</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>IndexOf(Array, Object)</strong> 搜索指定的对象，返回整个一维数组中第一次出现的索引。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">11</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>Reverse(Array)</strong> 逆转整个一维数组中元素的顺序。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">12</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>SetValue(Object, Int32)</strong> 给一维数组中指定位置的元素设置值。索引由一个 32 位整数指定。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">13</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>Sort(Array)</strong> 使用数组的每个元素的 IComparable 实现来排序整个一维数组中的元素。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">14</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff"><strong>ToString</strong> 返回一个表示当前对象的字符串。从对象（Object）继承。</span></span></td>
</tr>
</tbody>
</table> 
</div> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="13c-中还有结构体在-c-中的结构与传统的-c-或-c-中的结构不同" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">13、c# 中还有结构体，在 C# 中的结构与传统的 C 或 C++ 中的结构不同。</span></span></strong></h2> 
<h3 id="-在-c-中的结构与传统的-c-或-c-中的结构不同" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 在 C# 中的结构与传统的 C 或 C++ 中的结构不同：</span></span></strong></h3> 
<ul style="margin-left:30px">
<li>结构可带有方法、字段、索引、属性、运算符方法和事件。</li>
<li>结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。</li>
<li>与类不同，结构不能继承其他的结构或类。</li>
<li>结构不能作为其他结构或类的基础结构。</li>
<li>结构可实现一个或多个接口。</li>
<li>结构成员不能指定为 abstract、virtual 或 protected。</li>
<li>当您使用 <strong>New</strong> 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。</li>
<li>如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li>
</ul> 
<p></p> 
<h3 id="-类-vs-结构" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 类 vs 结构：</span></span></strong></h3> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto">类是引用类型，结构是值类型。</p> </li>
<li> <p style="margin-left:auto">结构不支持继承。</p> </li>
<li> <p style="margin-left:auto">结构不能声明默认的构造函数。</p> </li>
</ul> 
<p></p> 
<h3 id="-举例子" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 举例子：</span></span></strong></h3> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#008000"&gt;//声明 Book 结构&lt;/span&gt;
&lt;span style="color:#0000ff"&gt;struct&lt;/span&gt; &lt;span style="color:#a31515"&gt;Books&lt;/span&gt;
{
   public &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; title;
   public &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; author;
   public &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; subject;
   public &lt;span style="color:#a31515"&gt;int&lt;/span&gt; book_id;
};  
&lt;span style="color:#008000"&gt;//使用结构体&lt;/span&gt;
public &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;testStructure&lt;/span&gt;
{
   public &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
   {
      Books Book1;        &lt;span style="color:#008000"&gt;/* 声明 Book1，类型为 Books */&lt;/span&gt;
      &lt;span style="color:#008000"&gt;/* book 1 详述 */&lt;/span&gt;
      Book1.title = &lt;span style="color:#a31515"&gt;"C Programming"&lt;/span&gt;;
      Book1.author = &lt;span style="color:#a31515"&gt;"Nuha Ali"&lt;/span&gt;;
      Book1.subject = &lt;span style="color:#a31515"&gt;"C Programming Tutorial"&lt;/span&gt;;
      Book1.book_id = &lt;span style="color:#880000"&gt;6495407&lt;/span&gt;;
      &lt;span style="color:#008000"&gt;/* 打印 Book1 信息 */&lt;/span&gt;
      Console.WriteLine( &lt;span style="color:#a31515"&gt;"Book 1 title : {0}"&lt;/span&gt;, Book1.title);
      Console.WriteLine(&lt;span style="color:#a31515"&gt;"Book 1 author : {0}"&lt;/span&gt;, Book1.author);
      Console.WriteLine(&lt;span style="color:#a31515"&gt;"Book 1 subject : {0}"&lt;/span&gt;, Book1.subject);
      Console.WriteLine(&lt;span style="color:#a31515"&gt;"Book 1 book_id :{0}"&lt;/span&gt;, Book1.book_id);
   }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h3 id="-类-vs-结构的使用场景" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 类 vs 结构的使用场景：</span></span></strong></h3> 
<blockquote> 
 <p style="margin-left:auto"><strong>结构和类的区别：</strong></p> 
 <ul style="margin-left:25px">
<li>1、<strong>结构是值类型</strong>，它在栈中分配空间；而类是引用类型，它在堆中分配空间，栈中保存的只是引用。</li>
<li>2、结构类型直接存储成员数据，让其他类的数据位于堆中，位于栈中的变量保存的是指向堆中数据对象的引用。</li>
</ul> 
 <p style="margin-left:auto">由于结构是值类型，并且直接存储数据，因此在一个对象的主要成员为数据且数据量不大的情况下，使用结构会带来更好的性能。</p> 
 <p style="margin-left:auto">因为结构是值类型，因此在为结构分配内存，或者当结构超出了作用域被删除时，性能会非常好，因为他们将内联或者保存在堆栈中。</p> 
</blockquote> 
<h4 id="-结构和类的适用场合分析" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">▷ 结构和类的适用场合分析：</span></span></strong></h4> 
<ul style="margin-left:30px">
<li>1、<strong>当堆栈的空间很有限</strong>，且有大量的逻辑对象时，<strong>创建类</strong>要比创建结构好一些；</li>
<li>2、对于点、矩形和颜色这样的 <strong><code>轻量对象</code></strong> ，假如要声明一个含有许多个颜色对象的数组，则CLR需要为每个对象分配内存，在这种情况下，使用结构的成本较低；</li>
<li>3、在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承。</li>
<li>4、大多数情况下，目标类型只是含有一些数据，或者以数据为主。</li>
</ul> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="14c-的类和java是一模一样的就是多了个析构函数" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">14、c# 的类和java是一模一样的，就是多了个析构函数</span></span></strong></h2> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto">c#中的类，类的定义-成员变量、成员方法，类的构造函数，类的实例化、调用类的成员变量、方法，都是和java一模一样的！</p> </li>
<li> <p style="margin-left:auto">析构函数：</p> 
  <ul style="margin-left:30px">
<li>析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。</li>
<li>
<strong>析构函数用于在结束程序（比如关闭文件、释放内存等）之前<code>释放资源</code></strong> 。析构函数不能继承或重载。</li>
</ul>
</li>
<li> <p style="margin-left:auto">举例子：</p> </li>
</ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;using System;
namespace LineApplication
{
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Line&lt;/span&gt;
   {
      private &lt;span style="color:#a31515"&gt;double&lt;/span&gt; length;   &lt;span style="color:#008000"&gt;// 线条的长度&lt;/span&gt;
      public &lt;span style="color:#a31515"&gt;Line&lt;/span&gt;()  &lt;span style="color:#008000"&gt;// 构造函数&lt;/span&gt;
      {
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"对象已创建"&lt;/span&gt;);
      }
      ~Line() &lt;span style="color:#008000"&gt;//析构函数&lt;/span&gt;
      {
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"对象已删除"&lt;/span&gt;);
      }

      public &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;setLength&lt;/span&gt;( &lt;span style="color:#a31515"&gt;double&lt;/span&gt; len )
      {
         length = len;
      }
      public &lt;span style="color:#a31515"&gt;double&lt;/span&gt; &lt;span style="color:#a31515"&gt;getLength&lt;/span&gt;()
      {
         &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; length;
      }

      &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
      {
         Line line = new Line();
         &lt;span style="color:#008000"&gt;// 设置线条长度&lt;/span&gt;
         line.setLength(&lt;span style="color:#880000"&gt;6.0&lt;/span&gt;);
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"线条的长度： {0}"&lt;/span&gt;, line.getLength());          
      }
   }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>结果：</li></ul> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">对象已创建<br> 线条的长度： 6<br> 对象已删除</span></span></p> 
<p style="margin-left:auto"><br><br>  </p> 
<h2 id="15c-的继承实现还有抽象类重写抽象类的方法的写法以及-abstract-和-virtual-的区别最后总结一下在c中子类和父类的同名方法的关系" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">15、C# 的继承、实现，还有抽象类，重写抽象类的方法的写法以及 abstract 和 virtual 的区别(最后总结一下，在C#中子类和父类的同名方法的关系)</span></span></strong></h2> 
<h3 id="-继承语法" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 继承语法：</span></span></strong></h3> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;访问修饰符&gt; &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;基类&gt;
{
 ...
}
&lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;派生类&gt; : &lt;基类&gt;
{
 ...
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>子类继承父类，语法：</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt; &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; 子类: 父类
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>子类继承父类的构造方法，语法：</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;public 子类(参数列表): base(参数列表){}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>子类调用父类中的普通的方法(非构造方法)，语法：</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;子类声明的方法{
	base.父类声明的方法(参数列表);
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h4 id="-举例子-1" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 举例子：</span></span></strong></h4> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;using System;
namespace InheritanceApplication
{
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Shape&lt;/span&gt;
   {
      public &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;setWidth&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; w)
      {
         width = w;
      }
      public &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;setHeight&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; h)
      {
         height = h;
      }
      protected &lt;span style="color:#a31515"&gt;int&lt;/span&gt; width;
      protected &lt;span style="color:#a31515"&gt;int&lt;/span&gt; height;
   }

   &lt;span style="color:#008000"&gt;// 派生类&lt;/span&gt;
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Rectangle&lt;/span&gt;: Shape
   {
      public &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;getArea&lt;/span&gt;()
      {
         &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; (width * height);
      }
   }
   
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h3 id="-接口interface实现的语法" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 接口interface实现的语法：</span></span></strong></h3> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#008000"&gt;//声明为接口，使用的关键词还是 interface &lt;/span&gt;
   &lt;span style="color:#008000"&gt;// 接口 PaintCost&lt;/span&gt;
   public interface PaintCost
   {
      &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;getCost&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; area);&lt;span style="color:#008000"&gt;//接口中的方法，是没有任何修饰符&lt;/span&gt;
   }

&lt;span style="color:#008000"&gt;//子类实现接口，是使用冒号，代替java的implements&lt;/span&gt;
 &lt;span style="color:#008000"&gt;// 派生类&lt;/span&gt;
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Rectangle&lt;/span&gt; : PaintCost
   {
      public &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;getCost&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; area)
      {
         &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; area * &lt;span style="color:#880000"&gt;70&lt;/span&gt;;
      }
   }
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<blockquote> 
 <p style="margin-left:auto">▷ 接口：接口是可以有属性看，但是不能有字段的！</p> 
 <pre class="highlighter-hljs" style="margin-left:0"><code class="language-c language-c#"><span style="color:#008000">// 接口 PaintCost</span>
public interface PaintCost
{
 <span style="color:#a31515">int</span> Cost{<!-- --><span style="color:#0000ff">set</span>; get;}<span style="color:#008000">//接口可以有属性（属性是特殊的方法，属性的特点：是通过set设置值，通过get获取值）</span>
 <span style="color:#008000">//public int cost2; 接口是不能有字段的</span>
}
</code></pre> 
 <ul style="margin-left:25px"><li>这一块属性的写法，属于简写，详细的介绍，在后边~</li></ul> 
 <p style="margin-left:auto">▷ 子类实现接口：有两种方式，常用的是隐式（子类实现接口中声明的方法时用 public），显示就是方法前有接口名：</p> 
 <ul style="margin-left:25px"><li>接口interface实现的语法的例子就是隐式实现</li></ul> 
 <pre class="highlighter-hljs" style="margin-left:0"><code class="language-c language-c#"><span style="color:#008000">// 显示实现，举例子：</span>
   
<span style="color:#008000">// 接口 PaintCost</span>
public interface PaintCost
{
      <span style="color:#a31515">int</span> <span style="color:#a31515">getCost</span>(<span style="color:#a31515">int</span> area);<span style="color:#008000">//接口中的方法，是没有任何修饰符</span>
}

 <span style="color:#008000">// 派生类</span>
<span style="color:#0000ff">class</span> <span style="color:#a31515">Rectangle</span>: PaintCost
{
      <span style="color:#a31515">int</span> PaintCost.getCost(<span style="color:#a31515">int</span> area)
      {
         <span style="color:#0000ff">return</span> area * <span style="color:#880000">70</span>;
      }
}
</code></pre> 
</blockquote> 
<p></p> 
<h3 id="-子类继承抽象类重写抽象类的方法的写法重写abstract修饰的方法要加override" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 子类继承抽象类，重写抽象类的方法的写法：重写<code>abstract</code>修饰的方法，要加<code>override</code></span></span></strong></h3> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;abstract &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Shape&lt;/span&gt;
{
   abstract public &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;area&lt;/span&gt;();
}

&lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Rectangle&lt;/span&gt;:  Shape, PaintCost 
{
      public override &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;area&lt;/span&gt; ()
      {
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"Rectangle 类的面积："&lt;/span&gt;);
         &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; &lt;span style="color:#880000"&gt;100&lt;/span&gt;;
      }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h3 id="-abstract-和-virtual-的区别" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ abstract 和 virtual 的区别：</span></span></strong></h3> 
<h4 id="-区别点" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">▷ 区别点：</span></span></strong></h4> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto">abstract 声明的方法-抽象方法必须存在于抽象类中，抽象类中的抽象方法在声明的时候是不可以有实现体的。对于子类继承了抽象类，就必须重写人家所有的抽象方法！</p> </li>
<li> <p style="margin-left:auto">而 virtual 声明的方法，没有要求一定需要存在什么类中，可以存在抽象父类、普通父类中，并且要求声明为 virtual 方法的同时，需要有实现体！对于子类继承了父类，可以重写或者不重写 父类 virtual 声明的方法。</p> </li>
<li> <p style="margin-left:auto">virtual和abstract 它们有一个共同点：如果用来修饰方法，前面必须添加public，要不然就会出现编译错误：虚拟方法或抽象方法是不能私有的。</p> </li>
</ul> 
<h4 id="-举例子-2" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">▷ 举例子：</span></span></strong></h4> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#008000"&gt;//abstract&lt;/span&gt;
abstract &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;BaseTest1&lt;/span&gt;
{
    public abstract &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;fun&lt;/span&gt;();
}
&lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;DeriveTest1&lt;/span&gt;: BaseTest2
{
    public override &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;fun&lt;/span&gt;() { }&lt;span style="color:#008000"&gt;//对于子类继承了抽象类，就必须重写人家所有的抽象方法！&lt;/span&gt;

}


&lt;span style="color:#008000"&gt;//virtual&lt;/span&gt;
&lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;BaseTest2&lt;/span&gt;
{
   public virtual &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;fun&lt;/span&gt;() { }&lt;span style="color:#008000"&gt;//必须有实现&lt;/span&gt;
}
&lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;DeriveTest2&lt;/span&gt;: BaseTest1
{
    &lt;span style="color:#008000"&gt;//public override void fun() { } //对于子类继承了父类，可以重写或者不重写 父类 virtual 声明的方法。&lt;/span&gt;
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h3 id="-最后总结在c中子类和父类的同名方法的关系c-细分了重写和覆盖是不同的这里和java-不一样在java中重写就是覆盖覆盖就是重写" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">☺ 最后总结，在C#中子类和父类的同名方法的关系，<span style="color:#FF0000">C# 细分了，重写和覆盖是不同的</span>，这里和java 不一样，在java中重写就是覆盖，覆盖就是重写！</span></span></strong></h3> 
<blockquote> 
 <p style="margin-left:auto">▷重写使用的频率比较高，实现多态；覆盖用的频率比较低，用于对以前无法修改的类进行继承的时候。</p> 
</blockquote> 
<h3 id="-1-重写关键词是override" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">☺ (1) 重写(关键词是override)</span></span></strong></h3> 
<ul style="margin-left:30px"><li>重写的意义：实现<strong>多态性</strong>。 <strong><code>多态的意思是，父类引用指向子类实例的时候。当子类重写了父类的这个方法。那么父类的引用调用是子类的方法。</code></strong>
</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#008000"&gt;//代码中的写法，多态的写法：&lt;/span&gt;
父亲 p = new 子类(); 
&lt;span style="color:#008000"&gt;//接着调用同名方法&lt;/span&gt;
p.sameFunction();
&lt;span style="color:#008000"&gt;//这时候，如果子类中和父类的同名方法，没有使用关键词override 进行修饰，那么实际上调用的是父类的方法&lt;/span&gt;


-------------------------------------------------- 举例子-----------------------------------------------
using System;
namespace TestApplication
{
    public &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Shape&lt;/span&gt;
    {
        public &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;ordinaryFunction&lt;/span&gt;()
        {
            Console.WriteLine(&lt;span style="color:#a31515"&gt;" Shape中的ordinaryFunction"&lt;/span&gt;);
        }
    }

    public &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Rectangle&lt;/span&gt;: Shape
    {
        public new &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;ordinaryFunction&lt;/span&gt;()&lt;span style="color:#008000"&gt;//子类中和父类的同名方法，没有使用关键词override 进行修饰，即没有重写的作用&lt;/span&gt;
        {
            Console.WriteLine(&lt;span style="color:#a31515"&gt;" Rectangle中的ordinaryFunction"&lt;/span&gt;);
        }
    }

    &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;RectangleTester&lt;/span&gt;
    {
        &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
        {
            Shape s = new Rectangle();&lt;span style="color:#008000"&gt;//Rectangle 没有重写的情况下，调用的是父类的方法&lt;/span&gt;
            s.ordinaryFunction();
            Console.ReadKey();
        }
    }
}   
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<h3 id="2-覆盖关键词是new" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">(2) 覆盖(关键词是new)</span></span></strong></h3> 
<ul style="margin-left:30px"><li>覆盖的意义：其实就<strong>隐藏</strong>，因为子类中的方法【返回值、参数列表情况都和父类一模一样，这就不是重构了，本质上，子类和父类的这个同名方法是两个不同的方法】，覆盖的作用就是直接隐藏掉父类的方法，直接调用子类方法。</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;public &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Shape&lt;/span&gt;
{
    public &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;ordinaryFunction&lt;/span&gt;()
    {
          Console.WriteLine(&lt;span style="color:#a31515"&gt;" Shape中的ordinaryFunction"&lt;/span&gt;);
    }
}

public &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Rectangle&lt;/span&gt; : Shape
{
     public new &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;ordinaryFunction&lt;/span&gt;() &lt;span style="color:#008000"&gt;//重写基类的同名方法要加上new，否则会有警告&lt;/span&gt;
     {
          Console.WriteLine(&lt;span style="color:#a31515"&gt;" Rectangle中的ordinaryFunction"&lt;/span&gt;);
     }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="-16总结-c的重要的关键词-newvirtualoverrideabstractinterface" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">☺ 16、总结 c#的重要的关键词 new、virtual、override、abstract、interface</span></span></strong></h2> 
<blockquote> 
 <p style="margin-left:auto">参考：作者-北盟网校，B站视频《<a href="https://www.bilibili.com/video/BV1xP4y1y783/%E3%80%8B%EF%BC%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%96%87%E5%AD%97%E5%86%85%E5%AE%B9%E5%B0%B1%E6%98%AF%E4%BD%9C%E8%80%85-%E5%8C%97%E7%9B%9F%E7%BD%91%E6%A0%A1%E6%95%B4%E4%B8%AA%E8%A7%86%E9%A2%91%E6%89%80%E8%AE%B2%E7%9A%84%E9%87%8D%E7%82%B9%E4%BA%86~" title="https://www.bilibili.com/video/BV1xP4y1y783/》，下面的文字内容就是作者-北盟网校整个视频所讲的重点了~">https://www.bilibili.com/video/BV1xP4y1y783/》，下面的文字内容就是作者-北盟网校整个视频所讲的重点了~</a></p> 
</blockquote> 
<h3 id="-new关键字目的是为了隐藏父类同名同参数的方法不写也可以但会有警告建议写一下" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ new关键字，目的是为了隐藏父类同名同参数的方法。不写也可以，但会有警告，建议写一下。</span></span></strong></h3> 
<ul style="margin-left:30px"><li>因为默认就会覆盖子类的方法。覆盖的意思是子类可以调用父类的公开和受保护的方法的。但是万一子类有一个同名同参数的方法，这个时候就不再调用父类继承过来的方法，而是调用自己的方法。</li></ul> 
<h3 id="-virtual方法和普通方法一样但是加上-virtual-后就允许子类重写-override" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ virtual方法和普通方法一样，但是加上 virtual 后就允许子类重写 override。</span></span></strong></h3> 
<h3 id="-override目的就是为了多态" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ override目的就是为了多态。</span></span></strong></h3> 
<ul style="margin-left:30px">
<li>多态是父类引用指向子类对象，调用的是子类的方法体。如果没有 override 那么还是得用父类的方法。</li>
<li>多态的实现可以使用 virtual+override 或者 abstract+override 或者 接口+实现(没有 override) 或者 override+override 
  <ul style="margin-left:30px"><li>override 的源头方法 只有两种 virtual和 abstract</li></ul>
</li>
</ul> 
<h3 id="-abstract方法是抽象方法没有方法体抽象方法必须存在抽象类里" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ abstract方法是抽象方法，没有方法体，抽象方法必须存在抽象类里。</span></span></strong></h3> 
<ul style="margin-left:30px"><li>抽象类可以有非抽象方法 和属性 字段等。抽象类是不能 new 的。它的抽象方法没有方法体的。</li></ul> 
<h3 id="-interface接口可以有属性但是不能有字段方法也是没有修饰符的没有方法体" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ interface接口可以有属性。但是不能有字段。方法也是没有修饰符的。没有方法体。</span></span></strong></h3> 
<ul style="margin-left:30px"><li>实现了接口的类的方法不需要用 override 关键字的。</li></ul> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="17c-命名空间-namespace" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">17、C# 命名空间 namespace</span></span></strong></h2> 
<ul style="margin-left:30px">
<li>和java 的包名作用都是一样了，都是为了实现代码的复用。</li>
<li>我们知道，重用性（reusebility）是软件工程中一个非常重要的目标。重用，不仅仅指自己所写的软件（代码、组件等等）可以被重复利用；更广义的重用是指不同的人，不同的团队，不同的公司之间可以互相利用别人的成果。另外，对于大型软件，往往是由多个团队共同开发的，这些团队有可能分布于不同的城市、地区、甚至国家。由于这些原因，<strong>名字管理成为一个非常重要的因素</strong>。</li>
</ul> 
<blockquote> 
 <p style="margin-left:auto">C++和C# 提供了namespace的概念来支持这种方式。你可以在全局的空间内指定自己的namespace，然后还可以在某个namespace内制定更小范围的namespace。</p> 
</blockquote> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="18预处理" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">18、预处理</span></span></strong></h2> 
<h3 id="c-预处理器指令列表" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">C# 预处理器指令列表</span></span></strong></h3> 
<div style="margin-left:0"> 
 <table border="1" cellspacing="0">
<thead><tr>
<th style="background-color:#fafafa;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">预处理器指令</span></span></th>
<th style="background-color:#fafafa;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">描述</span></span></th>
</tr></thead>
<tbody>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#define</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它用于定义一系列成为符号的字符。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#undef</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它用于取消定义符号。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#if</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它用于测试符号是否为真。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#else</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它用于创建复合条件指令，与 #if 一起使用。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#elif</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它用于创建复合条件指令。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#endif</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">指定一个条件指令的结束。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#line</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#error</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它允许从代码的指定位置生成一个错误。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#warning</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它允许从代码的指定位置生成一级警告。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#region</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。</span></span></td>
</tr>
<tr>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">#endregion</span></span></td>
<td style="border-color:#c0c0c0;text-align:left"><span style="color:#333333"><span style="background-color:#ffffff">它标识着 #region 块的结束。</span></span></td>
</tr>
</tbody>
</table> 
</div> 
<blockquote> 
 <p style="margin-left:auto">预处理器指令指导编译器在实际编译开始之前对信息进行预处理。</p> 
 <p style="margin-left:auto">所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。</p> 
 <p style="margin-left:auto">C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。在 C# 中，预处理器指令用于在条件编译中起作用。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。</p> 
</blockquote> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="19c-正则表达式" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">19、C# 正则表达式</span></span></strong></h2> 
<ul style="margin-left:30px"><li>内容更多，更复杂些，用到再看：<a href="https://www.runoob.com/csharp/csharp-regular-expressions.html" title="C# 正则表达式 | 菜鸟教程">C# 正则表达式 | 菜鸟教程</a>
</li></ul> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="20异常" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">20、异常</span></span></strong></h2> 
<ul style="margin-left:30px">
<li>异常处理的关键词和java是一样的，都是那几个关键词：<strong>try</strong>、<strong>catch</strong>、<strong>finally</strong> 和 <strong>throw</strong>。</li>
<li>不过，异常的根类和继承关系有点不同，自定义异常的时候，要注意一下是应用异常，还是系统异常，然后再继承该异常类：</li>
</ul> 
<blockquote> 
 <p style="margin-left:auto">C# 中的异常类主要是直接或间接地派生于 <strong>System.Exception</strong> 类。<strong>System.ApplicationException</strong> 和 <strong>System.SystemException</strong> 类是派生于 System.Exception 类的异常类。</p> 
 <ul style="margin-left:25px">
<li> <p style="margin-left:auto"><strong>System.ApplicationException</strong> 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。</p> </li>
<li> <p style="margin-left:auto"><strong>System.SystemException</strong> 类是所有预定义的系统异常的基类。</p> </li>
</ul> 
</blockquote> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="21反射结合了特性一起使用" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">21、反射结合了特性一起使用</span></span></strong></h2> 
<h3 id="1-优缺点" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">(1) 优缺点：</span></span></strong></h3> 
<h4 id="优点" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">优点：</span></span></strong></h4> 
<ul style="margin-left:30px">
<li>1、反射提高了程序的灵活性和扩展性。</li>
<li>2、降低耦合性，提高自适应能力。</li>
<li>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li>
</ul> 
<h4 id="缺点" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">缺点：</span></span></strong></h4> 
<ul style="margin-left:30px">
<li>1、<strong>性能问题</strong>：使用反射基本上是一种解释操作， <strong><code>用于字段和方法接入时要远慢于直接代码</code></strong> 。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li>
<li>2、<strong>使用反射会模糊程序内部逻辑</strong>； <strong><code>程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术</code></strong> ，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</li>
</ul> 
<p></p> 
<h3 id="2-特性" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">(2) 特性</span></span></strong></h3> 
<h4 id="预定义特性attribute" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">预定义特性（Attribute）</span></span></strong></h4> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">Net 框架提供了三种预定义特性：</span></span></p> 
<ul style="margin-left:30px">
<li>AttributeUsage</li>
<li>Conditional</li>
<li>Obsolete</li>
</ul> 
<h4 id="attributeusage" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">AttributeUsage</span></span></strong></h4> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">▪ 预定义特性 <strong>AttributeUsage</strong> 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。</span></span></p> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">▪ 规定该特性的语法如下：</span></span></p> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;[AttributeUsage(
   validon,
   AllowMultiple=allowmultiple,
   Inherited=inherited
)]
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px">
<li>参数 validon 规定特性可被放置的语言元素。它是枚举器 <strong><code>AttributeTargets</code></strong> 的值的组合。默认值是 <em>AttributeTargets.All</em>。</li>
<li>参数 <em>allowmultiple</em>（可选的）为该特性的 <em>AllowMultiple</em> 属性（property）提供一个布尔值。如果为 true，则该特性是多用的。默认值是 false（单用的）。</li>
<li>参数 <em>inherited</em>（可选的）为该特性的 <em>Inherited</em> 属性（property）提供一个布尔值。如果为 true，则该特性可被派生类继承。默认值是 false（不被继承）。</li>
</ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property, 
AllowMultiple = &lt;span style="color:#a31515"&gt;true&lt;/span&gt;)]
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="22访问器" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">22、访问器</span></span></strong></h2> 
<h3 id="get-访问器set-访问器" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">get 访问器、set 访问器</span></span></strong></h3> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#008000"&gt;// 声明类型为 string 的 Name 属性&lt;/span&gt;
public &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; Name
{
   get
   {
     &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; name;
   }
   &lt;span style="color:#0000ff"&gt;set&lt;/span&gt;
   {
     name = value;
   }
}


&lt;span style="color:#008000"&gt;// 简写为：&lt;/span&gt;
public &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; Name {get; &lt;span style="color:#0000ff"&gt;set&lt;/span&gt;;}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<ul style="margin-left:30px"><li>举例子：</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;using System;
namespace runoob
{
   public abstract &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Person&lt;/span&gt;
   {
      public abstract &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; Name{get; &lt;span style="color:#0000ff"&gt;set&lt;/span&gt;;}
      public abstract &lt;span style="color:#a31515"&gt;int&lt;/span&gt; Age{get; &lt;span style="color:#0000ff"&gt;set&lt;/span&gt;;}
   }
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Student&lt;/span&gt; : Person
   {
      private &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; name = &lt;span style="color:#a31515"&gt;"N.A"&lt;/span&gt;;
      private &lt;span style="color:#a31515"&gt;int&lt;/span&gt; age = &lt;span style="color:#880000"&gt;0&lt;/span&gt;;
      &lt;span style="color:#008000"&gt;// 声明类型为 string 的 Name 属性&lt;/span&gt;
      public override &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; Name
      {
         get
         {
            &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; name;
         }
         &lt;span style="color:#0000ff"&gt;set&lt;/span&gt;
         {
            name = value;
         }
      }
      &lt;span style="color:#008000"&gt;// 声明类型为 int 的 Age 属性&lt;/span&gt;
      public override &lt;span style="color:#a31515"&gt;int&lt;/span&gt; Age
      {
         get
         {
            &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; age;
         }
         &lt;span style="color:#0000ff"&gt;set&lt;/span&gt;
         {
            age = value;
         }
      }
      public override &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; &lt;span style="color:#a31515"&gt;ToString&lt;/span&gt;()
      {
         &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; Name = &lt;span style="color:#a31515"&gt;" + Name + "&lt;/span&gt;, Age = &lt;span style="color:#a31515"&gt;" + Age;
      }
   }
}
&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="23委托关键词-delegate" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">23、委托，关键词 delegate</span></span></strong></h2> 
<h3 id="-其实底层就是使用的是反射" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">☺ <span style="color:#FF0000">其实底层就是使用的是反射!</span></span></span></strong></h3> 
<h3 id="-委托类似于-c-或-c-中函数的指针即用变量调方法好处使方法的使用变得更加灵活" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 委托：类似于 C 或 C++ 中函数的<code>指针</code>！即<code>用变量调方法</code>。好处：使方法的使用变得更加灵活。</span></span></strong></h3> 
<ul style="margin-left:30px"><li>某个方法自己不调用，而将方法自己委托给另一个变量，由这个变量执行这个方法，执行结果和这个方法自己执行是一样的</li></ul> 
<h3 id="-委托在实际使用中的例子" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 委托在实际使用中的例子：</span></span></strong></h3> 
<ul style="margin-left:30px">
<li>自定义排序</li>
<li>窗体传值</li>
<li>多线程操作</li>
</ul> 
<h3 id="-举例子-3" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 举例子：</span></span></strong></h3> 
<ul style="margin-left:30px"><li>声明为委托类型，语法：</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;public|internal delegate 返回值 委托名(参数列表);
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>对于声明为委托类型的方法，是需要使用new 关键词进行实例化创建的，然后使用变量进行引用，最后通过该变量执行</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#008000"&gt;//声明为委托类型&lt;/span&gt;
delegate &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;NumberChanger&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; n);
--------------------------------------------------------------------
  public &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;AddNum&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; p)
  {
      num += p;
      &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; num;
  }
--------------------------------------------------------------------
&lt;span style="color:#008000"&gt;// 使用new 创建委托实例 或者直接使用变量指向方法&lt;/span&gt;
NumberChanger nc1 = new NumberChanger(AddNum);&lt;span style="color:#008000"&gt;//相当于 NumberChanger nc1 = AddNum;&lt;/span&gt;
&lt;span style="color:#008000"&gt;// 使用委托对象调用方法，执行AddNum 方法&lt;/span&gt;
nc1(&lt;span style="color:#880000"&gt;25&lt;/span&gt;);
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<h3 id="-委托的多播简单理解理解成java中的链式调用即可" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">■ 委托的多播，简单理解，理解成java中的链式调用即可</span></span></strong></h3> 
<ul style="margin-left:30px"><li>举例子：</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;using System;

delegate &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;NumberChanger&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; n);
namespace DelegateAppl
{
   &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;TestDelegate&lt;/span&gt;
   {
      &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;int&lt;/span&gt; num = &lt;span style="color:#880000"&gt;10&lt;/span&gt;;
      public &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;AddNum&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; p)
      {
         num += p;
         &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; num;
      }

      public &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;MultNum&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; q)
      {
         num *= q;
         &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; num;
      }
      public &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;int&lt;/span&gt; &lt;span style="color:#a31515"&gt;getNum&lt;/span&gt;()
      {
         &lt;span style="color:#0000ff"&gt;return&lt;/span&gt; num;
      }

      &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
      {
         &lt;span style="color:#008000"&gt;// 创建委托实例&lt;/span&gt;
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         &lt;span style="color:#008000"&gt;// 调用多播&lt;/span&gt;
         nc(&lt;span style="color:#880000"&gt;5&lt;/span&gt;);
         Console.WriteLine(&lt;span style="color:#a31515"&gt;"Value of Num: {0}"&lt;/span&gt;, getNum());
         Console.ReadKey();
      }
   }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>结果：</li></ul> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">Value of Num: 75</span></span></p> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="24事件设计模式-发布订阅模式" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">24、事件【设计模式-发布订阅模式】</span></span></strong></h2> 
<h3 id="1-为什么需要事件" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">(1) 为什么需要事件？</span></span></strong></h3> 
<ul style="margin-left:30px"><li>原因1：</li></ul> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">看看前面的委托的声明的语法，声明为委托类型的时候，修饰符是 public|internal</span></span></p> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">而有时候，程序为了安全考虑，需要私有化，即封装起来，不给外界随意调用，随意修改！</span></span></p> 
<ul style="margin-left:30px"><li>原因2：</li></ul> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">委托链可以累加方法，+= 误用了 = 那么只会执行最后一个=的方法，不安全，有被覆盖的隐患</span></span></p> 
<blockquote> 
 <p style="margin-left:auto"><span style="color:#FF0000">事件实际上是一个私有委托变量，对外界开放了一个向委托变量增加方法绑定的方法，和开放了一个减少委托变量身上绑定的方法</span>。</p> 
</blockquote> 
<p></p> 
<h4 id="-官网对事件的概述" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">☺ 官网对事件的概述：</span></span></strong></h4> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff"><strong>事件是一种特殊的多播委托</strong>，仅可以<strong>从声明事件的类</strong>（或派生类）<strong>或结构</strong>（ <strong><code>发布服务器类</code></strong>）<strong>中对其进行调用</strong>。</span></span></p> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">如果其他类或结构订阅该事件，<strong>则在发布服务器类引发该事件时，将调用其事件处理程序方法</strong>。</span></span></p> 
<ul style="margin-left:30px"><li>例子1：发布服务器类</li></ul> 
<blockquote> 
 <p style="margin-left:auto"><code>event</code> 关键字用于声明发布服务器类中的事件。</p> 
</blockquote> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;&lt;span style="color:#008000"&gt;//关于如何声明和引发使用 [EventHandler] 作为基础委托类型的事件&lt;/span&gt;

public &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;SampleEventArgs&lt;/span&gt;
{
    public &lt;span style="color:#a31515"&gt;SampleEventArgs&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt; text) { Text = text; }
    public &lt;span style="color:#0000ff"&gt;string&lt;/span&gt; Text { get; } &lt;span style="color:#008000"&gt;// readonly&lt;/span&gt;
}

public &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Publisher&lt;/span&gt;
{
    &lt;span style="color:#008000"&gt;// Declare the delegate (if using non-generic pattern).&lt;/span&gt;
    public delegate &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;SampleEventHandler&lt;/span&gt;(object sender, SampleEventArgs e);

    &lt;span style="color:#008000"&gt;// Declare the event.&lt;/span&gt;
    public event SampleEventHandler SampleEvent;

    &lt;span style="color:#008000"&gt;// Wrap the event in a protected virtual method&lt;/span&gt;
    &lt;span style="color:#008000"&gt;// to enable derived classes to raise the event.&lt;/span&gt;
    protected virtual &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;RaiseSampleEvent&lt;/span&gt;()
    {
        &lt;span style="color:#008000"&gt;// Raise the event in a thread-safe manner using the ?. operator.&lt;/span&gt;
        SampleEvent?.Invoke(this, new SampleEventArgs(&lt;span style="color:#a31515"&gt;"Hello"&lt;/span&gt;));
    }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<ul style="margin-left:30px"><li>例子2：就是在例子1的基础上，在发布服务器类中，添加了监听方法 onXX事件</li></ul> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;using System;
namespace ConsoleApplication1
{
    &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Program&lt;/span&gt;
    {
        &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Main&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;string&lt;/span&gt;[] args)
        {
            Counter c = new Counter(new Random().Next(&lt;span style="color:#880000"&gt;10&lt;/span&gt;));
            c.ThresholdReached += c_ThresholdReached;&lt;span style="color:#008000"&gt;//真实的事件处理方法&lt;/span&gt;
            &lt;span style="color:#0000ff"&gt;for&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; i = &lt;span style="color:#880000"&gt;0&lt;/span&gt;; i &lt; &lt;span style="color:#880000"&gt;10&lt;/span&gt;; i++)
            {
                Console.WriteLine(&lt;span style="color:#a31515"&gt;"adding one"&lt;/span&gt;);
                c.Add(&lt;span style="color:#880000"&gt;1&lt;/span&gt;);
            }
        }
        &lt;span style="color:#008000"&gt;/**
		* 真实的事件处理方法
 	    */&lt;/span&gt;
        &lt;span style="color:#a31515"&gt;static&lt;/span&gt; &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;c_ThresholdReached&lt;/span&gt;(object sender, ThresholdReachedEventArgs e)
        {
            Console.WriteLine(&lt;span style="color:#a31515"&gt;"The threshold of {0} was reached at {1}."&lt;/span&gt;, e.Threshold,  e.TimeReached);
            Environment.Exit(&lt;span style="color:#880000"&gt;0&lt;/span&gt;);
        }
    }

   &lt;span style="color:#008000"&gt;/**
   * 事件参数类
   * EventArgs: 是C# 内置的类，内部有一个委托属性 public delegate void EventHandler&lt;TEventArgs&gt;(object? sender, TEventArgs e);
   */&lt;/span&gt;
    public &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;ThresholdReachedEventArgs&lt;/span&gt; : EventArgs
    {
        public &lt;span style="color:#a31515"&gt;int&lt;/span&gt; Threshold { get; &lt;span style="color:#0000ff"&gt;set&lt;/span&gt;; }
        public DateTime TimeReached { get; &lt;span style="color:#0000ff"&gt;set&lt;/span&gt;; }
    }
    
    &lt;span style="color:#0000ff"&gt;class&lt;/span&gt; &lt;span style="color:#a31515"&gt;Counter&lt;/span&gt;
    {
        &lt;span style="color:#008000"&gt;//声明事件&lt;/span&gt;
        public event EventHandler&lt;ThresholdReachedEventArgs&gt; ThresholdReached;
        
        private &lt;span style="color:#a31515"&gt;int&lt;/span&gt; threshold;
        private &lt;span style="color:#a31515"&gt;int&lt;/span&gt; total;

        public &lt;span style="color:#a31515"&gt;Counter&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; passedThreshold)
        {
            threshold = passedThreshold;
        }

        public &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;Add&lt;/span&gt;(&lt;span style="color:#a31515"&gt;int&lt;/span&gt; x)
        {
            total += x;
            &lt;span style="color:#0000ff"&gt;if&lt;/span&gt; (total &gt;= threshold)
            {
                ThresholdReachedEventArgs args = new ThresholdReachedEventArgs();
                args.Threshold = threshold;
                args.TimeReached = DateTime.Now;
                OnThresholdReached(args);&lt;span style="color:#008000"&gt;//监听或通知事件&lt;/span&gt;
            }
        }
        &lt;span style="color:#008000"&gt;/**
		*监听或通知事件
		*/&lt;/span&gt;
        protected virtual &lt;span style="color:#a31515"&gt;void&lt;/span&gt; &lt;span style="color:#a31515"&gt;OnThresholdReached&lt;/span&gt;(ThresholdReachedEventArgs e)
        {
            EventHandler&lt;ThresholdReachedEventArgs&gt; handler = ThresholdReached;
            &lt;span style="color:#0000ff"&gt;if&lt;/span&gt; (handler != null)
            {
                handler(this, e);&lt;span style="color:#008000"&gt;//事件处理程序&lt;/span&gt;
            }
        }
    }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h3 id="2-事件的本质" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">(2) 事件的本质</span></span></strong></h3> 
<blockquote> 
 <p style="margin-left:auto">以日志事件为例，日志事件写法：public event EventHandler LogHandler; 它的的本质如下：</p> 
</blockquote> 
<pre class="has" style="margin-left:auto"><code class="language-highlighter-hljs">&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-c language-c#"&gt;private delegate EventHandler&lt;LogHandlerArgs&gt; LogHandler;
    
public event EventHandler&lt;LogHandlerArgs&gt; LogHandler
{
    add
    {
        LogHandler += value;&lt;span style="color:#008000"&gt;//添加到事件的方法队列中&lt;/span&gt;
     }
     remove
     {
         LogHandler -= value;
     }
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<h3 id="3-事件具有以下属性" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">(3) 事件具有以下属性：</span></span></strong></h3> 
<ul style="margin-left:30px">
<li> <p style="margin-left:auto"><strong>事件通常用于表示用户操作，例如单击按钮或图形用户界面中的菜单选项</strong>。</p> </li>
<li> <p style="margin-left:auto">发行者确定何时引发事件；订户确定对事件作出何种响应。</p> </li>
<li> <p style="margin-left:auto">一个事件可以有多个订户。 订户可以处理来自多个发行者的多个事件。</p> </li>
<li> <p style="margin-left:auto">没有订户的事件永远也不会引发。</p> </li>
<li> <p style="margin-left:auto">当事件具有多个订户时，引发该事件时会同步调用事件处理程序。</p> </li>
<li> <p style="margin-left:auto">在 .NET 类库中，事件基于 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.eventhandler" title="EventHandler">EventHandler</a> 委托和 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs" title="EventArgs">EventArgs</a> 基类。</p> </li>
</ul> 
<p style="margin-left:auto"><br>  </p> 
<h2 id="25c-不安全代码" style="margin-left:0"><strong><span style="color:#000000"><span style="background-color:#ffffff">25、C# 不安全代码</span></span></strong></h2> 
<p style="margin-left:auto"><span style="color:#333333"><span style="background-color:#ffffff">当一个代码块使用 <strong>unsafe</strong> 修饰符标记时，C# 允许在函数中使用指针变量。<strong>不安全代码</strong>或非托管代码是指使用了<strong>指针</strong>变量的代码块。</span></span></p> 
<ul style="margin-left:30px"><li>详情：<a href="https://www.runoob.com/csharp/csharp-unsafe-codes.html" title="C# 不安全代码 | 菜鸟教程">C# 不安全代码 | 菜鸟教程</a>
</li></ul>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>