<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>10段代码教你玩转C&#43;&#43; - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">10段代码教你玩转C&#43;&#43;</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p>1.随机迷宫：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

#include &lt;conio.h&gt;

#include &lt;windows.h&gt;

#include &lt;time.h&gt;

#define Height 31 //迷宫的高度，必须为奇数

#define Width 25 //迷宫的宽度，必须为奇数

#define Wall 1

#define Road 0

#define Start 2

#define End 3

#define Esc 5

#define Up 1

#define Down 2

#define Left 3

#define Right 4
int map[Height+2][Width+2];

void gotoxy(int x,int y) //移动坐标

{

/* typedef struct _COORD {

SHORT X;

SHORT Y;

} COORD, *PCOORD; */

COORD coord;

coord.X=x;

coord.Y=y;

SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), coord );

}

void hidden()//隐藏光标

{

/* typedef void *HANDLE; */

HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

/* typedef struct _CONSOLE_CURSOR_INFO {

DWORD dwSize;

BOOL bVisible;

} CONSOLE_CURSOR_INFO *PCONSOLE_CURSOR_INFO; */

CONSOLE_CURSOR_INFO cci;

GetConsoleCursorInfo(hOut,&amp;cci);

cci.bVisible = 0;//赋1为显示，赋0为隐藏

SetConsoleCursorInfo(hOut,&amp;cci);

}

void create(int x,int y) //随机生成迷宫

{

int c[4][2] = {0,1,1,0,0,-1,-1,0}; //四个方向

int i,j,t;

//将方向打乱

for(i=0;i&lt;4;i++)

{

j = rand()%4;

t = c[i][0];

c[i][0] = c[j][0];

c[j][0] = t;

t = c[i][1];

c[i][1] = c[j][1];

c[j][1] = t;

}

map[x][y] = Road;

for(i = 0;i &lt; 4;i++)

if(map[x + 2 * c[i][0]][y + 2 * c[i][1]] == Wall)

{

map[x + c[i][0]][y + c[i][1]] = Road;

create(x+ 2 * c[i][0],y + 2 * c[i][1]);

}

}

int get_key() //接收按键

{

char c;

while(c = getch())

{

if(c == 27)

return Esc; //Esc

if(c != -32)

continue;

c = getch();

if(c == 72)

return Up; //上

if(c == 80)

return Down; //下

if(c ==75 )

return Left; //左

if(c == 77)

return Right; //右

}

return 0;

}

void paint(int x,int y) //画迷宫

{

gotoxy(2 * y - 2,x - 1);

switch(map[x][y])

{

case Start:

printf("入");break; //画入口

case End:

printf("出");break; //画出口

case Wall:

printf("※");break; //画墙

case Road:

printf(" ");break; //画路

}

}

void game()

{

int x=2,y=1; //玩家当前位置，刚开始在入口处

int c; //用来接收按键

while(1)

{

gotoxy(2 * y - 2,x - 1);

printf("☆"); //画出玩家当前位置

if(map[x][y] == End) //判断是否到达出口

{

gotoxy(30,24);

printf("到达终点，按任意键结束");

getch();

break;

}

c = get_key();

if(c == Esc)

{

gotoxy(0,24);

break;

}

switch(c)

{

case Up: //向上走

if(map[x-1][y] != Wall)

{

paint(x,y);

x--;

}

break;

case Down: //向下走

if(map[x+1][y] != Wall)

{

paint(x,y);

x++;

}

break;

case Left: //向左走

if(map[x][y-1] != Wall)

{

paint(x,y);

y--;

}

break;

case Right: //向右走

if(map[x][y+1] != Wall)

{

paint(x,y);

y++;

}

break;

}

}

}

int main()

{

int i,j;

srand((unsigned)time(NULL)); //初始化随即种子

hidden(); //隐藏光标

for(i = 0;i &lt;= Height + 1;i++)

for(j = 0;j &lt;= Width + 1;j++)

if(i == 0 || i == Height + 1 || j == 0 || j == Width + 1) //初始化迷宫

map[i][j] = Road;

else

map[i][j] = Wall;

create(2 * (rand() % (Height / 2)+1),2 * (rand() % (Width / 2) + 1)); //从随机一个点开始生成迷宫，该点行列都为偶数

for(i = 0;i &lt;= Height+1;i++) //边界处理

{

map[i][0]=Wall;

map[i][Width+1]=Wall;

}

for(j=0;j&lt;=Width+1;j++) //边界处理

{

map[0][j]=Wall;

map[Height+1][j]=Wall;

}

map[2][1]=Start; //给定入口

map[Height-1][Width]=End; //给定出口

for(i=1;i&lt;=Height;i++)

for(j=1;j&lt;=Width;j++) //画出迷宫

paint(i,j);

game(); //开始游戏

getch();

return 0;

}</code></pre> 
<p>2.文字游戏</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt; 
using namespace std; 
double shengmingli=200000000000;//定义主角初始生命力 
int gongjili=150000;//定义主角初始攻击力 
int fangyuli=2000000;//定义主角初始防御力 
int money=2000000;//定义主角初始金钱数量 
bool guoguan;//定义是否通关判定 
void wuqidian();//定义武器店函数 
void yaodian();//定义药店函数 
void guaiwu1();//定义小怪物函数 
void guaiwu2();//定义大怪物函数 
int main() 
{ 
cout&lt;&lt;"欢迎你开始玩打怪物小游戏！n"; 
cout&lt;&lt;"小镇n"; 
cout&lt;&lt;"一个1000年的小镇。周围有一条河，有一片树林，很多房子和很多人。n有一家药店"&lt;&lt;endl; 
cout&lt;&lt;"和一家武器店。n"; 
int xiaozhen;//定义选择项目 
cout&lt;&lt;"1.去武器店"&lt;&lt;endl; 
cout&lt;&lt;"2.去药品店"&lt;&lt;endl; 
cout&lt;&lt;"3.去打小怪物"&lt;&lt;endl; 
cout&lt;&lt;"4.去打大怪物"&lt;&lt;endl; 
cout&lt;&lt;"5.退出游戏"&lt;&lt;endl; 
cout&lt;&lt;"6.显示你的状态"&lt;&lt;endl; 
cin&gt;&gt;xiaozhen; 
while(xiaozhen!=5)//输入5时退出游戏 
{ 
if(shengmingli&lt;=0)//主角生命力小于等于0时游戏结束 
{ 
cout&lt;&lt;"你死啦！"&lt;&lt;endl; 
break; 
} 
if(guoguan) 
{ 
cout&lt;&lt;"恭喜通关！"&lt;&lt;endl; 
break; 
} 
if(xiaozhen==6)//输入6可检测自己的状态 
{ 
cout&lt;&lt;"你的生命力:"&lt;&lt;shengmingli&lt;&lt;endl; 
cout&lt;&lt;"你的攻击力:"&lt;&lt;gongjili&lt;&lt;endl; 
cout&lt;&lt;"你的防御力:"&lt;&lt;fangyuli&lt;&lt;endl; 
cout&lt;&lt;"你拥有的钱:"&lt;&lt;money&lt;&lt;endl; 
} 
else 
switch(xiaozhen) 
{ 
case 1 : wuqidian();break; 
case 2 : yaodian();break; 
case 3 : guaiwu1();break; 
case 4 : guaiwu2();break; 
default : cout&lt;&lt;"请不要乱选！"&lt;&lt;endl;break; 
} 
cin&gt;&gt;xiaozhen; 
} 
if(xiaozhen==5) 
{ 
cout&lt;&lt;"正在退出游戏……"&lt;&lt;endl; 
} 
cin.get(); 
cin.get(); 
return 0; 
} 
void wuqidian() 
{ 
cout&lt;&lt;"欢迎来到武器店！"&lt;&lt;endl; 
cout&lt;&lt;"1、买小刀（1M加2攻击力）"&lt;&lt;endl; 
cout&lt;&lt;"2、买短剑（2M加20攻击力）"&lt;&lt;endl; 
cout&lt;&lt;"3、买大砍刀（5M加40攻击力)"&lt;&lt;endl; 
cout&lt;&lt;"4、买双节棍（7M加60攻击力）"&lt;&lt;endl; 
cout&lt;&lt;"5、买盾牌（2M加30防御力）"&lt;&lt;endl; 
cout&lt;&lt;"6、买铠甲（5M加60防御力）"&lt;&lt;endl; 
cout&lt;&lt;"7、离开武器店"&lt;&lt;endl; 
int wuqidian; 
cin&gt;&gt;wuqidian; 
while(wuqidian!=7)//输入7时结束函数 
{ 
switch(wuqidian) 
{ 
case 1 : if(money&lt;10) 
cout&lt;&lt;"你的钱不够"&lt;&lt;endl;//钱不够时返回Flase 
else  
cout&lt;&lt;"购买成功！"&lt;&lt;endl;//钱足够时返回True 
gongjili+=2; 
money-=1; 
break; 
case 2 : if(money&lt;80) 
cout&lt;&lt;"你的钱不够"&lt;&lt;endl; 
else  
cout&lt;&lt;"购买成功！"&lt;&lt;endl; 
gongjili+=20; 
money-=80; 
break; 
case 3 : if(money&lt;140) 
cout&lt;&lt;"你的钱不够"&lt;&lt;endl; 
    else  
cout&lt;&lt;"购买成功！"&lt;&lt;endl; 
gongjili+=40; 
money-=140; 
break; 
case 4 : if(money&lt;200) 
cout&lt;&lt;"你的钱不够"&lt;&lt;endl; 
else  
cout&lt;&lt;"购买成功！"&lt;&lt;endl; 
gongjili+=60; 
money-=200; 
break; 
case 5 : if(money&lt;60) 
cout&lt;&lt;"你的钱不够"&lt;&lt;endl; 
else  
cout&lt;&lt;"购买成功！"&lt;&lt;endl; 
fangyuli+=30; 
money-=60; 
break; 
fangyuli+=60; 
money-=100; 
break; 
default : cout&lt;&lt;"无"&lt;&lt;endl; 
    break; 
}  
cin&gt;&gt;wuqidian; 
} 
if(wuqidian==7) 
{	  //返回main()主函数 
cout&lt;&lt;"欢迎下次再来！"&lt;&lt;endl; 
cout&lt;&lt;"欢迎你开始玩打怪物小游戏！n"; 
cout&lt;&lt;"小镇n"; 
cout&lt;&lt;"一个1000年的小镇。周围有一条河，有一片树林，很多房子和很多人。n有一家药店"&lt;&lt;endl; 
cout&lt;&lt;"和一家武器店。n"; 
cout&lt;&lt;"1.去武器店"&lt;&lt;endl; 
cout&lt;&lt;"2.去药品店"&lt;&lt;endl; 
cout&lt;&lt;"3.去打小怪物"&lt;&lt;endl; 
cout&lt;&lt;"4.去打大怪物"&lt;&lt;endl; 
cout&lt;&lt;"5.退出游戏"&lt;&lt;endl; 
cout&lt;&lt;"6.显示你的状态"&lt;&lt;endl; 
} 
} 
/* 
yaodian()的设置与wuqidian()相同,可参照阅读. 
*/ 
void yaodian() 
{ 
cout&lt;&lt;"欢迎来到药品店！"&lt;&lt;endl; 
cout&lt;&lt;"1、买1号补血药（10M加200生命）"&lt;&lt;endl; 
cout&lt;&lt;"2、买2号补血药（50M加1000生命力）"&lt;&lt;endl; 
cout&lt;&lt;"3、买3号补血药（100M加2200生命力)"&lt;&lt;endl; 
cout&lt;&lt;"4、离开武器店"&lt;&lt;endl; 
int yaodian; 
cin&gt;&gt;yaodian; 
while(yaodian!=4) 
{ 
switch(yaodian) 
{ 
case 1 : if(money&lt;10) 
cout&lt;&lt;"你的钱不够"&lt;&lt;endl; 
else  
cout&lt;&lt;"购买成功！"&lt;&lt;endl; 
shengmingli+=200; 
money-=10; 
break; 
case 2 : if(money&lt;50) 
cout&lt;&lt;"你的钱不够"&lt;&lt;endl; 
else  
cout&lt;&lt;"购买成功！"&lt;&lt;endl; 
shengmingli+=1000; 
money-=50; 
break; 
case 3 : if(money&lt;100) 
cout&lt;&lt;"你的钱不够"&lt;&lt;endl; 
else  
cout&lt;&lt;"购买成功！"&lt;&lt;endl; 
shengmingli+=2200; 
money-=100; 
break; 
default : cout&lt;&lt;"无"&lt;&lt;endl; 
break; 
} 
cin&gt;&gt;yaodian; 
} 
if(yaodian==4) 
{	   
cout&lt;&lt;"欢迎下次再来！"&lt;&lt;endl;	   
cout&lt;&lt;"欢迎你开始玩打怪物小游戏！n"; 
cout&lt;&lt;"小镇n"; 
cout&lt;&lt;"一个1000年的小镇。周围有一条河，有一片树林，很多房子和很多人。n有一家药店"&lt;&lt;endl; 
cout&lt;&lt;"和一家武器店。n"; 
cout&lt;&lt;"1.去武器店"&lt;&lt;endl; 
cout&lt;&lt;"2.去药品店"&lt;&lt;endl; 
cout&lt;&lt;"3.去打小怪物"&lt;&lt;endl; 
cout&lt;&lt;"4.去打大怪物"&lt;&lt;endl; 
cout&lt;&lt;"5.退出游戏"&lt;&lt;endl; 
cout&lt;&lt;"6.显示你的状态"&lt;&lt;endl; 
} 
} 
/*这里是两个战斗函数,使用指针来处理.避免造成内存崩溃.*/ 
void guaiwu1() 
{ 
cout&lt;&lt;"开始与小怪物战斗！！！"&lt;&lt;endl; 
double* g_shengmingli=new double;//定义怪物生命 
int* g_gongjili=new int;//定义怪物攻击力 
int* g_fangyuli=new int;//定义怪物防御力 
    int* g_money=new int;//定义怪物金钱 
*g_shengmingli=100; 
*g_gongjili=5; 
*g_fangyuli=3; 
*g_money=5; 
double* tongji1=new double;//用来计算主角对怪物的杀伤 
double* tongji2=new double;//用来计算怪物对主角的杀伤 
*tongji1=0; 
*tongji2=0; 
int* huihe=new int;//定义回合数 
*huihe=1; 
cout&lt;&lt;"你开始对小怪物进行攻击！"&lt;&lt;endl; 
int* xuanze=new int; 
/* 
攻击计算公式 
杀伤=攻击力*2-防御力 
玩家每回合可以选择攻击与逃跑 
*/ 
while((*g_shengmingli)&gt;0 &amp;&amp; shengmingli&gt;0 &amp;&amp; (*xuanze)!=2) 
{ 
cout&lt;&lt;"现在是"&lt;&lt;"第"&lt;&lt;*huihe&lt;&lt;"回合！"&lt;&lt;endl; 
cout&lt;&lt;"请选择你的动作:n"; 
cout&lt;&lt;"1、攻击n2、逃跑n"; 
cin&gt;&gt;*xuanze; 
switch((*xuanze)) 
{ 
case 1 : cout&lt;&lt;"你对小怪物发动了攻击！"&lt;&lt;endl; 
*g_shengmingli-=gongjili*2-(*g_fangyuli); 
*tongji1=gongjili*2-(*g_fangyuli); 
cout&lt;&lt;"你打掉了小怪物"&lt;&lt;*tongji1&lt;&lt;"的生命！"&lt;&lt;endl; 
cout&lt;&lt;"小怪物还剩"&lt;&lt;(*g_shengmingli)-(*tongji1)&lt;&lt;"点生命"&lt;&lt;endl; 
shengmingli-=(*g_gongjili)*2-fangyuli; 
*tongji2=(*g_gongjili)*2-fangyuli; 
cout&lt;&lt;"小怪物对你发动了攻击！"&lt;&lt;endl; 
cout&lt;&lt;"小怪物打掉了你"&lt;&lt;*tongji2&lt;&lt;"的生命！"&lt;&lt;endl; 
cout&lt;&lt;"你还剩"&lt;&lt;shengmingli-(*tongji2)&lt;&lt;"点生命"&lt;&lt;endl;break; 
case 2 : cout&lt;&lt;"你决定逃跑！"&lt;&lt;endl; 
cout&lt;&lt;"逃跑成功！"&lt;&lt;endl;continue; 
default : cout&lt;&lt;"请不要乱选！"&lt;&lt;endl; 
} 
(*huihe)++; 
} 
if((*g_shengmingli)&lt;=0) 
{//杀死怪物后的返回 
cout&lt;&lt;"小怪物被你杀死了！你真厉害！！！"&lt;&lt;endl; 
money+=(*g_money); 
cout&lt;&lt;"欢迎你开始玩打怪物小游戏！n"; 
cout&lt;&lt;"小镇n"; 
cout&lt;&lt;"一个1000年的小镇。周围有一条河，有一片树林，很多房子和很多人。n有一家药店"&lt;&lt;endl; 
cout&lt;&lt;"和一家武器店。n"; 
cout&lt;&lt;"1.去武器店"&lt;&lt;endl; 
cout&lt;&lt;"2.去药品店"&lt;&lt;endl; 
cout&lt;&lt;"3.去打小怪物"&lt;&lt;endl; 
cout&lt;&lt;"4.去打大怪物"&lt;&lt;endl; 
cout&lt;&lt;"5.退出游戏"&lt;&lt;endl; 
cout&lt;&lt;"6.显示你的状态"&lt;&lt;endl; 
} 
else 
if(shengmingli&lt;=0) 
{//被怪物杀死后的返回 
cout&lt;&lt;"你被小怪物杀死了！游戏结束！！！"&lt;&lt;endl; 
} 
else 
if((*xuanze)==2) 
{//逃跑的返回 
cout&lt;&lt;"你逃回了小镇！"&lt;&lt;endl; 
cout&lt;&lt;"欢迎你开始玩打怪物小游戏！n"; 
cout&lt;&lt;"小镇n"; 
cout&lt;&lt;"一个1000年的小镇。周围有一条河，有一片树林，很多房子和很多人。n有一家药店"&lt;&lt;endl; 
cout&lt;&lt;"和一家武器店。n"; 
cout&lt;&lt;"1.去武器店"&lt;&lt;endl; 
cout&lt;&lt;"2.去药品店"&lt;&lt;endl; 
cout&lt;&lt;"3.去打小怪物"&lt;&lt;endl; 
cout&lt;&lt;"4.去打大怪物"&lt;&lt;endl; 
cout&lt;&lt;"5.退出游戏"&lt;&lt;endl; 
cout&lt;&lt;"6.显示你的状态"&lt;&lt;endl; 
} 
delete g_shengmingli; 
delete g_gongjili; 
delete g_fangyuli; 
delete g_money; 
delete tongji1; 
delete tongji2; 
} 
/* 
设置均与void函数guaiwu1()相同,可参照上例阅读. 
*/ 
void guaiwu2() 
{ 
cout&lt;&lt;"开始与大怪物战斗！！！"&lt;&lt;endl; 
double* g_shengmingli=new double; 
int* g_gongjili=new int; 
int* g_fangyuli=new int; 
*g_shengmingli=3600; 
*g_gongjili=500; 
*g_fangyuli=500; 
double* tongji1=new double; 
double* tongji2=new double; 
*tongji1=0; 
*tongji2=0; 
int* huihe=new int; 
*huihe=1; 
cout&lt;&lt;"你开始对大怪物进行攻击！"&lt;&lt;endl; 
int* xuanze=new int; 
while((*g_shengmingli)&gt;0 &amp;&amp; shengmingli&gt;0 &amp;&amp; (*xuanze)!=2) 
{ 
cout&lt;&lt;"现在是"&lt;&lt;"第"&lt;&lt;*huihe&lt;&lt;"回合！"&lt;&lt;endl; 
cout&lt;&lt;"请选择你的动作:n"; 
cout&lt;&lt;"1、攻击n2、逃跑n"; 
cin&gt;&gt;*xuanze; 
switch((*xuanze)) 
{ 
case 1 : cout&lt;&lt;"你对大怪物发动了攻击！"&lt;&lt;endl; 
*g_shengmingli-=gongjili*2-(*g_fangyuli); 
*tongji1=gongjili*2-(*g_fangyuli); 
cout&lt;&lt;"你打掉了大怪物"&lt;&lt;*tongji1&lt;&lt;"的生命！"&lt;&lt;endl; 
cout&lt;&lt;"大怪物还剩"&lt;&lt;(*g_shengmingli)-(*tongji1)&lt;&lt;"点生命"&lt;&lt;endl; 
shengmingli-=(*g_gongjili)*2-fangyuli; 
*tongji2=(*g_gongjili)*2-fangyuli; 
cout&lt;&lt;"大怪物对你发动了攻击！"&lt;&lt;endl; 
cout&lt;&lt;"大怪物打掉了你"&lt;&lt;*tongji2&lt;&lt;"的生命！"&lt;&lt;endl; 
cout&lt;&lt;"你还剩"&lt;&lt;shengmingli-(*tongji2)&lt;&lt;"点生命"&lt;&lt;endl;break; 
case 2 : cout&lt;&lt;"你决定逃跑！"&lt;&lt;endl; 
cout&lt;&lt;"逃跑成功！"&lt;&lt;endl;continue; 
default : cout&lt;&lt;"请不要乱选！"&lt;&lt;endl; 
} 
(*huihe)++; 
} 
if((*g_shengmingli)&lt;=0) 
{ 
    cout&lt;&lt;"大怪物被你杀死了！你真厉害！！！"&lt;&lt;endl; 
guoguan=true; 
cout&lt;&lt;"欢迎你开始玩打怪物小游戏！n"; 
cout&lt;&lt;"小镇n"; 
cout&lt;&lt;"一个1000年的小镇。周围有一条河，有一片树林，很多房子和很多人。n有一家药店"&lt;&lt;endl; 
cout&lt;&lt;"和一家武器店。n"; 
cout&lt;&lt;"1.去武器店"&lt;&lt;endl; 
cout&lt;&lt;"2.去药品店"&lt;&lt;endl; 
cout&lt;&lt;"3.去打小怪物"&lt;&lt;endl; 
cout&lt;&lt;"4.去打大怪物"&lt;&lt;endl; 
cout&lt;&lt;"5.退出游戏"&lt;&lt;endl; 
cout&lt;&lt;"6.显示你的状态"&lt;&lt;endl; 
} 
else 
if(shengmingli&lt;=0) 
{ 
cout&lt;&lt;"你被大怪物杀死了！游戏结束！！！"&lt;&lt;endl; 
} 
else 
if((*xuanze)==2) 
{ 
cout&lt;&lt;"你逃回了小镇！"&lt;&lt;endl; 
cout&lt;&lt;"欢迎你开始玩打怪物小游戏！n"; 
cout&lt;&lt;"小镇n"; 
cout&lt;&lt;"一个1000年的小镇。周围有一条河，有一片树林，很多房子和很多人。n有一家药店"&lt;&lt;endl; 
cout&lt;&lt;"和一家武器店。n"; 
cout&lt;&lt;"1.去武器店"&lt;&lt;endl; 
cout&lt;&lt;"2.去药品店"&lt;&lt;endl; 
cout&lt;&lt;"3.去打小怪物"&lt;&lt;endl; 
cout&lt;&lt;"4.去打大怪物"&lt;&lt;endl; 
cout&lt;&lt;"5.退出游戏"&lt;&lt;endl; 
cout&lt;&lt;"6.显示你的状态"&lt;&lt;endl; 
} 
delete g_shengmingli; 
delete g_gongjili; 
delete g_fangyuli; 
delete tongji1; 
delete tongji2; 
}</code></pre> 
<p>3.另一个文字游戏</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#include&lt;conio.h&gt;
#include&lt;windows.h&gt;
using namespace std;
double shanghai[20]={0.6,1.1,2,3.16,5.5,7,10,20,50,100,146.23,254.13,312,403,601,1023};
double bosshealth[20]={2,3,4,5.9,8,14,19,32,73,157,200,403,801,1200,3630,20123};
double wj_shanghai=5000,wj_health=10000000,wj_max_health=10000000,boss,wj_money=10000000000000000000000000000000;
void chushihua();
void game();
void gongji();
void goumai();
void shangdian();
void zhujiemian();
void fangyu();
void cend();
void chushou();
void print(char[]);
int bishou=0,caidao=0,jian=0,shenjian=0;
double bishou_1=5,caidao_1=17,jian_1=58,shenjian_1=124;
int hat=0,douhui=0,hudun=0,hunjia=0,shendun=0;
double hat_1=7,douhui_1=21,hudun_1=49,hunjia_1=89,shendun_1=210.4;
void cend()
{
    system("cls");
    print("GAME OVER");
    exit(1);
}
void game()
{
    int k;
    chushihua();
    IO:
    printf("请输入对手等级 (0~15)n");
    scanf("%d",&amp;k);
    if(k&gt;15||k&lt;0)
    {
        system("cls");
        goto IO;
    }
    boss=bosshealth[k];
    system("cls");
    while(wj_health&gt;=0)
    {
        srand(time(NULL));
        QP:
        printf("1.逃跑        2.进攻n");
        char s=getch();
        if(s&lt;'1'||s&gt;'2')
        {
            system("cls");
            goto QP;
        }
        if(s=='1')
        {
            system("cls");
            zhujiemian();
        }
        system("cls");
        double l=shanghai[k]*((rand()%2)+1)+fabs(double(rand()%100/100-2));
        printf("对手对你造成了%lf点伤害n",l);
        wj_health-=l;
        printf("你当前剩余血量：%lfn",wj_health);
        if(wj_health&lt;=0)
            cend();
        double o=wj_shanghai*((rand()%2)+1)+double(rand()%10/10);
        boss-=o;
        printf("你对对手造成了%lf点伤害n",o);
        printf("对手当前剩余血量：%lfnn",boss);
        if(boss&lt;=0)
        {
            printf("胜利！n获得%lf金币nn当前剩余血量：%lfn",shanghai[k]+3,wj_health);
            wj_money+=shanghai[k]+3;
            printf("n余额：%lfn",wj_money);
            getch();
            if(k==15)
            {
                printf("恭喜玩家！游戏胜利！n");
                getch();
                exit(1);
            }
            system("cls");
            zhujiemian();
        }
    }
}
void zhujiemian()
{
    PO:
    printf("1.商店 2.战斗 3.回血 4.状态n");
    char k=getch();
    if(k&gt;'4'||k&lt;'1')
    {
        system("cls");
        goto PO;
    }
    if(k=='1')
    {
        system("cls");
        shangdian();
        return;
    }
    if(k=='2')
    {
        system("cls");
        game();
        return;
    }
    if(k=='3')
    {
        system("cls");
        if(wj_money&gt;0)
        {
            wj_money=wj_money*4/5-1;
            chushihua();
            wj_health=wj_max_health;
            printf("回血成功！n");
            getch();
            system("cls");
            goto PO;
        }
        else
        {
            printf("余额不足！n");
            getch();
            system("cls");
            goto PO;
        }
    }
    if(k=='4')
    {
        chushihua(); 
        system("cls");
        printf("生命值：%lfn",wj_health);
        printf("最大生命值：%lfn",wj_max_health);
        printf("攻击力：%lfn",wj_shanghai);
        printf("金币：%lfn",wj_money); 
        getch();
        system("cls");
        goto PO;
    }
    if(k=='5')
    {
        string a;
        system("cls");
        printf("输入密码！n");
        cin&gt;&gt;a;
        if(a=="gu"||a=="gu")
        {
            wj_money+=1000;
            printf("外挂生效n");
            Sleep(1000);
            system("cls");
            goto PO;
        }
        printf("外挂失败n");
        Sleep(1000);
        system("cls");
        goto PO;
    }
}
void shangdian()
{
    LK:
    printf("1.购买 2.返回主界面n");
    char k=getch();
    if(k!='1'&amp;&amp;k!='2')
    {
        system("cls");
        goto LK;
    }
    if(k=='1')
    {
        system("cls");
        goumai();
        goto LK;
    }
    if(k=='2')
    {
        system("cls");
        zhujiemian();
        return;
    }
}
void goumai()
{
    ML:
    printf("1.攻击 2.防御 3.返回主界面n");
    char k=getch();
    if(k!='1'&amp;&amp;k!='2'&amp;&amp;k!='3')
    {
        system("cls");
        goto ML;
    }
    if(k=='1')
    {
        system("cls");
        gongji();
        goto ML;
    }
    if(k=='3')
    {
        system("cls");
        zhujiemian();
        return;
    }
    if(k=='2')
    {
        fangyu();
    }
} 
void gongji()
{
    OP:
    system("cls");
    printf("0.返回上界面n");
    printf("1.返回主界面n");
    printf("2.匕首 5金币n");
    printf("3.菜刀 17金币n");
    printf("4.剑 68金币n");
    printf("5.圣剑 210金币n");
    printf("提醒：金币价格与伤害成正比n");
    char k=getch();
    if(k&lt;'0'||k&gt;'5')
    {
        system("cls");
        goto OP;
    }
    if(k=='0')
    {
        system("cls");
        goumai();
        return;
    }
    if(k=='1')
    {
        system("cls");
        zhujiemian();
        return;
    }
    if(k=='2')
    {
        if(wj_money&gt;=bishou_1)
        {
            chushihua();
            system("cls");
            wj_money-=bishou_1;
            bishou++;
            goto OP;
        }
        system("cls");
        printf("余额不足！n");
        getch();
        system("cls");
        goto OP;
    }
    if(k=='3')
    {
        if(wj_money&gt;=caidao_1)
        {
            chushihua();
            system("cls");
            wj_money-=caidao_1;
            caidao++;
            goto OP;
        }
        system("cls");
        printf("余额不足！n");
        getch();
        goto OP;
    }
    if(k=='4')
    {
        if(wj_money&gt;=jian_1)
        {
            chushihua();
            system("cls");
            wj_money-=jian_1;
            jian++;
            goto OP;
        }
        system("cls");
        printf("余额不足！n");
        getch();
        goto OP;
    }
    if(k=='5')
    {
        if(wj_money&gt;=shenjian_1)
        {
            chushihua();
            system("cls");
            wj_money-=shenjian_1;
            shenjian++;
            goto OP;
        }
        system("cls");
        printf("余额不足！n");
        getch();
        goto OP;
    }
}
void fangyu()
{
    OP:
    system("cls");
    printf("0.返回上界面n");
    printf("1.返回主界面n");
    printf("2.帽子 7金币n");
    printf("3.头盔 21金币n");
    printf("4.护盾 49金币n");
    printf("5.盔甲 89金币n");
    printf("6.圣盾 210金币n");
    printf("提醒：金币价格与伤害成正比n");
    char k=getch();
    if(k&lt;'0'||k&gt;'6')
    {
        system("cls");
        goto OP;
    }
    if(k=='0')
    {
        system("cls");
        goumai();
        return;
    }
    if(k=='1')
    {
        system("cls");
        zhujiemian();
        return;
    }
    if(k=='2')
    {
        if(wj_money&gt;=hat_1)
        {
            chushihua();
            system("cls");
            wj_money-=hat_1;
            hat++;
            goto OP;
        }
        system("cls");
        printf("余额不足！n");
        getch();
        system("cls");
        goto OP;
    }
    if(k=='3')
    {
        if(wj_money&gt;=douhui_1)
        {
            chushihua();
            system("cls");
            wj_money-=douhui_1;
            douhui++;
            goto OP;
        }
        system("cls");
        printf("余额不足！n");
        getch();
        goto OP;
    }
    if(k=='4')
    {
        if(wj_money&gt;=hudun_1)
        {
            chushihua();
            system("cls");
            wj_money-=hudun_1;
            hudun++;
            goto OP;
        }
        system("cls");
        printf("余额不足！n");
        getch();
        goto OP;
    }
    if(k=='5')
    {
            chushihua();
        if(wj_money&gt;=hunjia_1)
        {
            system("cls");
            wj_money-=hunjia_1;
            hunjia++;
            goto OP;
        }
        system("cls");
        printf("余额不足！n");
        getch();
        goto OP;
    }
    if(k=='6')
    {
        if(wj_money&gt;=shendun_1)
        {
            chushihua();
            system("cls");
            wj_money-=shendun_1;
            shendun++;
            goto OP;
        }
        system("cls");
        printf("余额不足！n");
        getch();
        goto OP;
    }
}
void chushihua()
{
    wj_max_health=hat*hat_1+douhui*douhui_1+hudun*hudun_1+hunjia*hunjia_1+shendun*shendun_1+10;
    wj_shanghai=bishou*bishou_1+caidao*caidao_1+jian*jian_1+shenjian*shenjian_1+1;
}
void print(char a[])
{
    int s=strlen(a);
    for(int i=0;i&lt;s;i++)
    {
        cout&lt;&lt;a[i];
        Sleep(400);
    }
    getch(); 
    system("cls");
}
int main()
{
    system("title game");
    print("出品：谷游");
    zhujiemian();
    return 0;
}</code></pre> 
<p>4.坦克大战</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;time.h&gt; 
#include &lt;windows.h&gt;


#define W 1       //上
#define S 2         //下
#define A 3         //左
#define D 4          //右
#define L 4       // 坦克有4条命

void HideCursor() {  //隐藏光标            
    CONSOLE_CURSOR_INFO cursor_info = { 1,0 };
    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info); 
}
void GoToxy(int x, int y) {  //光标移动，X、Y表示横、纵坐标
    COORD coord = { x, y };
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);  
}

//全局变量
int map[50][40];//地图二维数组
int B_num;      //子弹编号
int Pos;     //敌方坦克生成位置,-1为左边,0为中间,1为右边,2为我的坦克位置
int Speed = 7;  //游戏速度
int Enemy; //还未出现的敌人
const char* Tank_Model[3][4] ={
    {"◢┃ ◣","◢╦ ◣","◢╦ ◣","◢╦ ◣"},
    {"╠ █ ╣","╠ █ ╣","━█ ╣","╠ █━"},
    {"◥╩ ◤","◥┃ ◤","◥╩ ◤","◥╩ ◤"}
     }; 

//坦克
class Tank{
public:
    int x, y; //中心坐标
    int Direction; //方向
    int Model;  //模型
    int Revival; //复活次数
    int Num; //敌方坦克编号  
    bool Type;   //我方坦克此参数为1
    bool Exist;  //存活为1，不存活为0
}AI_tank[6], my_tank;
//子弹
class Bullet{      
public:
    int x, y;    //坐标
    int Direction;  //方向
    bool Exist;  //1为存在，0不存在
    bool Type;   //0为敌方子弹，1为我方子弹
}bullet[50] ;

//基本函数
void GoToxy(int x, int y);    //光标移动
void HideCursor();           //隐藏光标

void Key();  //键盘输入
void Init(); //初始化
void Pause(); //暂停
void Show(); //打印框架
void Print_Map();  //打印地图
void Cheak_Game(); //检测游戏胜负
void GameOver();  //游戏结束

//坦克
void Creat_AI_T(Tank* AI_tank); //建立坦克  
void Creat_My_T(Tank* my_tank);               

void Move_AI_T(Tank* AI_tank);//坦克移动
void Move_My_T(int turn);                     

void Clear_T(int x, int y);  //清除坦克
void Print_T(Tank tank);  //打印坦克
bool Cheak_T(Tank tank, int direction); //检测障碍,1阻碍

//子弹
void Creat_AI_B(Tank* tank);  //敌方坦克发射子弹
void Creat_My_B(Tank tank);//我方坦克发射子弹
void Move_B(Bullet bullet[50]); //子弹移动
void Break_B(Bullet* bullet); //子弹碰撞
void Print_B(int x, int y);//打印子弹
void Clear_B(int x, int y); //清除子弹
int  Cheak_B(int x, int y);  //子弹前方情况

void Show() {       //打印框架   
    std::cout &lt;&lt; "  ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁";
    std::cout &lt;&lt; "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁n";
    for (int i = 0; i &lt; 48; i++) {
        std::cout &lt;&lt; "▕                                                                             ▏n";
    }
    std::cout &lt;&lt; "  ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔";
    std::cout &lt;&lt; "▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔n";
}
void Print_Map() {     // 打印地图   
    int Map[50][40] = {
//map里的值: 0为可通过陆地，1为砖，6为墙，100~105为敌方坦克，200为我的坦克，
       { 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,6,6,6,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,6,6,6,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,4 },
       { 4,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,4 },
       { 4,6,6,6,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,6,6,6,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,9,9,9,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,9,9,9,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,9,9,9,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4 },
       { 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4 }
    };
    for (int i = 0; i &lt; 50; i++)
        for (int j = 0; j &lt; 40; j++)        
            map[i][j] = Map[i][j];
    for (int i = 0; i &lt; 50; i++)
        for (int j = 0; j &lt; 40; j++)        
            if (map[i][j] == 1) {
                GoToxy(2 * j, i);
                std::cout &lt;&lt; "▓";
            }            
            else if (map[i][j] == 6) {
                GoToxy(2 * j, i);
                std::cout &lt;&lt; "■";
            }             
    GoToxy(38, 46);     
    std::cout &lt;&lt; " ◣◢";
    GoToxy(38, 47);     
    std::cout &lt;&lt; "◣█ ◢";
    GoToxy(38, 48);     
    std::cout &lt;&lt; "◢█ ◣"; 
}
void Cheak_Game() {
    //敌人坦克全部不存活
    if (Enemy &lt;= 0 &amp;&amp; !AI_tank[0].Exist &amp;&amp; !AI_tank[1].Exist &amp;&amp; !AI_tank[2].Exist
        &amp;&amp; !AI_tank[3].Exist &amp;&amp; !AI_tank[4].Exist &amp;&amp; !AI_tank[5].Exist)
        GameOver();
    if (my_tank.Revival &gt;= L)//我复活次数用完
        GameOver();//游戏结束
}
void GameOver() {
    bool home = 1;
    while (home) { 
        GoToxy(37, 21);
        std::cout &lt;&lt; "游戏结束!";        
        if (GetAsyncKeyState(0xD) &amp; 0x8000) {  //回车键
            system("cls");   //清屏
            Show();
            Init(); //初始化
            break;
        }
        else if (GetAsyncKeyState(0x1B) &amp; 0x8000)  //Esc键退出   
                 exit(0);
    }
}
void Creat_My_T(Tank* my_tank) {//建立我的坦克
    my_tank-&gt;x = 15;
    my_tank-&gt;y = 47;
    my_tank-&gt;Direction = 1;
   // my_tank-&gt;Model = 0;
    my_tank-&gt;Exist = 1;
    my_tank-&gt;Type = 1;
    Print_T(*my_tank);   //打印我的坦克
}
void Move_My_T(int turn) {//turn为Key()函数传入的方向值
    Clear_T(my_tank.x, my_tank.y);
    my_tank.Direction = turn; 
    if (Cheak_T(my_tank, my_tank.Direction))  //我方坦克当前方向上无障碍
        switch (turn) {
        case W: my_tank.y--; break;  //上
        case S: my_tank.y++; break;  //下
        case A: my_tank.x--; break;  //左
        case D: my_tank.x++; break;  //右
        }  
    Print_T(my_tank);
}
void Print_T(Tank tank) {//打印
    for (int i = 0; i &lt; 3; i++) {
        GoToxy((tank.x - 1) * 2, tank.y - 1 + i);//在坦克中心坐标的左边，上中下三行打印
        std::cout &lt;&lt; Tank_Model[i][tank.Direction - 1]; //打印的是地址，地址既字符串
        for (int j = 0; j &lt; 3; j++)
            if (tank.Type)//若为我的坦克
                map[tank.y + j - 1][tank.x + i - 1] = 200;
        //在map上敌方值为100~105,我方为200
            else
                map[tank.y + j - 1][tank.x + i - 1] = 100 +tank.Num;
        //这样可以通过map值读取坦克编号
    }
}
void Creat_AI_T(Tank* AI_tank) {
        AI_tank-&gt;x = 19 + 17 * (Pos); //pos为坦克生成位置,-1为左位置,0为中间,1为右,2为我的坦克位置
        AI_tank-&gt;y = 2;
        AI_tank-&gt;Direction = 2;  //方向朝下
        AI_tank-&gt;Revival++; //复活次数+1
        AI_tank-&gt;Exist = 1;//存在
        Pos++;
        Enemy--;
        if (Pos == 2)  //循环重置(pos只能为-1，0，1)
            Pos = -1;
        Print_T(*AI_tank);
        return;          
}
void Move_AI_T(Tank* AI_tank) { 
    if (AI_tank-&gt;Exist) {  //存在 
        Clear_T(AI_tank-&gt;x, AI_tank-&gt;y);
        if (Cheak_T(*AI_tank, AI_tank-&gt;Direction))//前方无障碍
            switch (AI_tank-&gt;Direction) {
            case W: AI_tank-&gt;y--; break;  //上
            case S: AI_tank-&gt;y++; break;  //下
            case A: AI_tank-&gt;x--; break;  //左
            case D: AI_tank-&gt;x++; break;  //右
            }
        else {//前方有障碍 
           for (int i = rand() % 4 + 1; i &lt;= 4; i++)
                if (Cheak_T(*AI_tank, i)){  //循环判断,返1可通过
                    AI_tank-&gt;Direction = i;
                    break;
               }
        }
        Print_T(*AI_tank);     //打印敌方坦克
    }
}
bool Cheak_T(Tank tank, int direction) {  //检测坦克前方障碍,返1为可通过
    switch (direction) {                   
    case W: 
        if (map[tank.y - 2][tank.x] == 0 &amp;&amp; map[tank.y - 2][tank.x - 1] == 0 &amp;&amp; map[tank.y - 2][tank.x + 1] == 0)
            return 1;
        else return 0;
    case S:
        if (map[tank.y + 2][tank.x] == 0 &amp;&amp; map[tank.y + 2][tank.x - 1] == 0 &amp;&amp; map[tank.y + 2][tank.x + 1] == 0)
            return 1;
        else return 0;
    case A:
        if (map[tank.y][tank.x - 2] == 0 &amp;&amp; map[tank.y - 1][tank.x - 2] == 0 &amp;&amp; map[tank.y + 1][tank.x - 2] == 0)
            return 1;
        else return 0;
    case D:
        if (map[tank.y][tank.x + 2] == 0 &amp;&amp; map[tank.y - 1][tank.x + 2] == 0 &amp;&amp; map[tank.y + 1][tank.x + 2] == 0)
            return 1;
        else return 0;
    default: return 0;
    }
}
void Clear_T(int x, int y) {   //清除坦克
    for (int i = 0; i &lt;= 2; i++)
        for (int j = 0; j &lt;= 2; j++) {//将坦克占用的地图清零
            map[y + j - 1][x + i - 1] = 0;
            GoToxy(2 * x + 2 * j - 2, y + i - 1);
            std::cout &lt;&lt; "  ";
        }
}

//键盘输入
void Key() {                 
    //上下左右键
    if (GetAsyncKeyState('W') &amp; 0x8000)
        Move_My_T(W);
    else if (GetAsyncKeyState('S') &amp; 0x8000)
        Move_My_T(S);
    else if (GetAsyncKeyState('A') &amp; 0x8000)
        Move_My_T(A);
    else if (GetAsyncKeyState('D') &amp; 0x8000)
        Move_My_T(D);
//子弹发射
    else if (GetAsyncKeyState('P') &amp; 0x8000) {
            Creat_My_B(my_tank);
        }
    else if (GetAsyncKeyState(0x1B) &amp; 0x8000)// Esc键退出
        exit(0); 
    else if (GetAsyncKeyState(0x20) &amp; 0x8000)//空格暂停
        Pause();
}
void Pause() {    //暂停
    while (1) {
        if (GetAsyncKeyState(0xD) &amp; 0x8000) {      //回车键继续  
            break;
        }
        else if (GetAsyncKeyState(0x1B) &amp; 0x8000) //Esc键退出   
            exit(0);
    }
}
void Creat_AI_B(Tank* tank){ //敌方发射子弹
        if (!(rand() % 1)) { //在随后的每个游戏周期中有10分之一的可能发射子弹       
            Creat_My_B(*tank);
        }
}
void Creat_My_B(Tank tank) {
    switch (tank.Direction) 
    {  
    case W:
        bullet[B_num].x = tank.x;
        bullet[B_num].y = tank.y - 2;
        bullet[B_num].Direction = 1;//1表示向上
        break;
    case S:
        bullet[B_num].x = tank.x;
        bullet[B_num].y = tank.y + 2;
        bullet[B_num].Direction = 2;//2表示向下
        break;
    case A:
        bullet[B_num].x = tank.x - 2;
        bullet[B_num].y = tank.y;
        bullet[B_num].Direction = 3;//3表示向左
        break;
    case D:
        bullet[B_num].x = tank.x + 2;
        bullet[B_num].y = tank.y;
        bullet[B_num].Direction = 4;//4表示向右
        break;
    }
    bullet[B_num].Exist = 1; //子弹存在
    bullet[B_num].Type = tank.Type; //我方坦克发射的子弹bullet.Type=1
    B_num++;
    if (B_num == 50) //如果子弹编号增长到50号，那么重头开始编号
        B_num = 0;   //考虑到地图上不可能同时存在50颗子弹，所以数组元素设置50个
}
void Move_B(Bullet bullet[50]) {  //子弹移动                            
    for (int i = 0; i &lt; 50; i++) {
        if (bullet[i].Exist) {//如果子弹存在        
           if (map[bullet[i].y][bullet[i].x] == 0) {         
                Clear_B(bullet[i].x, bullet[i].y);//子弹当前位置无障碍，抹除子弹图形
                switch (bullet[i].Direction) {//子弹变到下一个坐标
                    case W:(bullet[i].y)--; break;
                    case S:(bullet[i].y)++; break;
                    case A:(bullet[i].x)--; break;
                    case D:(bullet[i].x)++; break;
                }
           }
            //判断子弹当前位置情况
           if (map[bullet[i].y][bullet[i].x] == 0) //子弹坐标无障碍
               Print_B(bullet[i].x, bullet[i].y);//打印
           else Break_B(&amp;bullet[i]);     //子弹碰撞       
           for (int j = 0; j &lt; 50; j++) 
                //子弹间的碰撞判断,若是我方子弹和敌方子弹碰撞则都删除,若为两敌方子弹则无视
                if (bullet[j].Exist &amp;&amp; j != i &amp;&amp; (bullet[i].Type || bullet[j].Type) 
                    &amp;&amp; bullet[i].x == bullet[j].x &amp;&amp; bullet[i].y == bullet[j].y)
                {                              //同样的两颗我方子弹不可能产生碰撞
                    bullet[j].Exist = 0;
                    bullet[i].Exist = 0;
                    Clear_B(bullet[j].x, bullet[j].y);
  
                    break;
                }
        }
    }
}
void Break_B(Bullet* bullet) {  
    int x = bullet-&gt;x;  
    int y = bullet-&gt;y;  //子弹坐标
    int i;
    if (map[y][x] == 1) {  //子弹碰到砖块   
        if (bullet-&gt;Direction == A || bullet-&gt;Direction == D)     
            //若子弹是横向的
            for (i = -1; i &lt;= 1; i++)
                if (map[y + i][x] == 1) {
                    map[y + i][x] = 0;
                    GoToxy(2 * x, y + i);
                    std::cout &lt;&lt; "  ";
                }
        if (bullet-&gt;Direction == W || bullet-&gt;Direction == S)   //子弹是向上或是向下移动的
            for (i = -1; i &lt;= 1; i++)
                if (map[y][x + i] == 1) {  //如果子弹打中砖块两旁为砖块,则删除砖,若不是则忽略    
                    map[y][x + i] = 0;    //砖块碎
                    GoToxy(2 * (x + i), y);
                    std::cout &lt;&lt; "  ";
                }
        bullet-&gt;Exist = 0; //子弹不存在
    }
    else if (map[y][x] == 4 || map[y][x] == 6)  //子弹碰到边框或者不可摧毁方块
        bullet-&gt;Exist = 0;
    else if (bullet-&gt;Type ==1 &amp;&amp; map[y][x] &gt;= 100 &amp;&amp; map[y][x] &lt;= 105) { //我方子弹碰到了敌方坦克    
        AI_tank[(int)map[y][x] % 100].Exist = 0;
        bullet-&gt;Exist = 0; 
        Clear_T(AI_tank[(int)map[y][x] % 100].x, AI_tank[(int)map[y][x] % 100].y);  //清除坦克
        
    }
    else if (bullet-&gt;Type == 0 &amp;&amp; map[y][x] == 200) {   //若敌方子弹击中我的坦克    
        my_tank.Exist = 0;
        bullet-&gt;Exist = 0;
        Clear_T(my_tank.x, my_tank.y);
        my_tank.Revival++; //我方坦克复活次数加1
    }
    else if (map[y][x] == 9) { //子弹碰到巢    
        bullet-&gt;Exist = 0;
        GoToxy(38, 46);      std::cout &lt;&lt; "      "; 
        GoToxy(38, 47);      std::cout &lt;&lt; "      ";
        GoToxy(38, 48);      std::cout &lt;&lt; "◢◣  ";
        GameOver();
    }
}
int Cheak_B(int x, int y) {//子弹当前位置情况
    if (map[y][x] == 0)
        return 1;
    else
        return 0;
}
void Print_B(int x, int y){
    GoToxy(2 * x, y);
    std::cout &lt;&lt; "o";
}
void Clear_B(int x, int y){
    GoToxy(2 * x, y);
    if (Cheak_B(x, y) == 1) {//子弹当前坐标在空地上 
        std::cout &lt;&lt; "  ";
    }
}

void Init() {      //初始化
    Enemy = 24;
    my_tank.Revival = 0;  //我的坦克复活次数为0
    Pos = 0;
    B_num = 0;
    Print_Map();
    Creat_My_T(&amp;my_tank);
    for (int i = 0; i &lt; 50; i++) {//子弹
        bullet[i].Exist = 0;
    }
    for (int i = 0; i &lt;= 5; i++) {//敌方坦克
        AI_tank[i].Revival = 0;
        AI_tank[i].Exist = 0;  //初始化坦克全是不存活的，用Creat_AI_T()建立不存活的坦克
        AI_tank[i].Num = i;
        AI_tank[i].Type = 0;
    }
}

int main() {                              
    int i;
    int gap[16] = { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 };  //间隔数组，用于控制速度
    HideCursor();     //隐藏光标
    Show();      //打印框架
    Init();     //初始化
    while(1) {
        if (gap[0]++ % Speed == 0) {
            //速度调整,     
            Cheak_Game();  //游戏胜负检测
            for (i = 0; i &lt;= 5; i++) {//敌方坦克移动循环
                if (gap[i + 7]++ % 3 == 0)
                    Move_AI_T(&amp;AI_tank[i]);
            }
            for (i = 0; i &lt;= 5; i++)//建立敌方坦克
                if (AI_tank[i].Exist == 0 &amp;&amp; AI_tank[i].Revival &lt; 4 &amp;&amp; gap[i+1]++ % 50 == 0) {  //一个敌方坦克每局只有4条命
                                 //坦克死掉后间隔一段时间建立
                    Creat_AI_T(&amp;AI_tank[i]);
                    break;          
                } 
            for (i = 0; i &lt;= 5; i++)
                if (AI_tank[i].Exist)
                    Creat_AI_B(&amp;AI_tank[i]);
            if (my_tank.Exist &amp;&amp; gap[14]++ % 2 == 0)
                Key();
            if (my_tank.Exist == 0 &amp;&amp; my_tank.Revival &lt; L &amp;&amp; gap[15]++ % 15 == 0)//我方坦克复活
                Creat_My_T(&amp;my_tank);            
            Move_B(bullet);            
        }
        Sleep(5);
    }
    return 0;
}</code></pre> 
<p>5.贪吃蛇</p> 
<pre><code class="language-cpp">
#include&lt;windows.h&gt;
#include&lt;time.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;conio.h&gt;
#define N 21
#include&lt;iostream&gt;
using namespace std; 
void gotoxy(int x,int y)//位置函数
{
COORD pos;
pos.X=2*x;
pos.Y=y;
SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),pos);
}
void color(int a)//颜色函数
{
SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),a);
}
void init(int apple[2])//初始化函数（初始化围墙、显示信息、苹果）
{
int i,j;//初始化围墙
int wall[N+2][N+2]={<!-- -->{0}};
for(i=1;i&lt;=N;i++)
{
for(j=1;j&lt;=N;j++)
wall[i][j]=1;
}
color(11);
for(i=0;i&lt;N+2;i++)
{
for(j=0;j&lt;N+2;j++)
{
if(wall[i][j])
cout&lt;&lt;"■";
else cout&lt;&lt;"□" ;
}
cout&lt;&lt;endl;
}
gotoxy(N+3,1);//显示信息
color(20);
cout&lt;&lt;"按 W S A D 移动方向"&lt;&lt;endl;
gotoxy(N+3,2);
color(20);
cout&lt;&lt;"按任意键暂停"&lt;&lt;endl;
gotoxy(N+3,3);
color(20);
cout&lt;&lt;"得分："&lt;&lt;endl;
apple[0]=rand()%N+1;//苹果
apple[1]=rand()%N+1;
gotoxy(apple[0],apple[1]);
color(12);
cout&lt;&lt;"●"&lt;&lt;endl;
}
int main()
{
int i,j;
int** snake=NULL;
int apple[2];
int score=0;
int tail[2];
int len=3;
char ch='p';
srand((unsigned)time(NULL));
init(apple);
snake=(int**)realloc(snake,sizeof(int*)*len);
for(i=0;i&lt;len;i++)
snake[i]=(int*)malloc(sizeof(int)*2);
for(i=0;i&lt;len;i++)
{
snake[i][0]=N/2;
snake[i][1]=N/2+i;
gotoxy(snake[i][0],snake[i][1]);
color(14);
cout&lt;&lt;"★"&lt;&lt;endl;
}
while(1)//进入消息循环
{
tail[0]=snake[len-1][0];
tail[1]=snake[len-1][1];
gotoxy(tail[0],tail[1]);
color(11);
cout&lt;&lt;"■"&lt;&lt;endl;
for(i=len-1;i&gt;0;i--)
{
snake[i][0]=snake[i-1][0];
snake[i][1]=snake[i-1][1];
gotoxy(snake[i][0],snake[i][1]);
color(14);
cout&lt;&lt;"★"&lt;&lt;endl;
}
if(kbhit())
{
gotoxy(0,N+2);
ch=getche();
}
switch(ch)
{
case 'w':snake[0][1]--;break;
case 's':snake[0][1]++;break;
case 'a':snake[0][0]--;break;
case 'd':snake[0][0]++;break;
default: break;
}
gotoxy(snake[0][0],snake[0][1]);
color(14);
cout&lt;&lt;"★"&lt;&lt;endl;
Sleep(abs(200-0.5*score));
if(snake[0][0]==apple[0]&amp;&amp;snake[0][1]==apple[1])//吃掉苹果后蛇分数加1，蛇长加1
{
score++;
len++;
snake=(int**)realloc(snake,sizeof(int*)*len);
snake[len-1]=(int*)malloc(sizeof(int)*2);
apple[0]=rand()%N+1;
apple[1]=rand()%N+1;
gotoxy(apple[0],apple[1]);
color(12);
cout&lt;&lt;"●"&lt;&lt;endl;
gotoxy(N+5,3);
color(20);
cout&lt;&lt;score&lt;&lt;endl;
}
if(snake[0][1]==0||snake[0][1]==N||snake[0][0]==0||snake[0][0]==N)//撞到围墙后失败
{
gotoxy(N/2,N/2);
color(30);
cout&lt;&lt;"失败！！！"&lt;&lt;endl;
for(i=0;i&lt;len;i++)
free(snake[i]);
Sleep(INFINITE);
exit(0);
}
}
return 0;
}</code></pre> 
<p>6.再来一个文字游戏</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#define clear() cout &lt;&lt; "33c" &lt;&lt; flush
using namespace std;

const int SIZE = 9;
int Queen[15][15]; 
// 值为0表示不在攻击范围内，可以放置新皇后；
// 1表示在攻击范围内，不可放置
// 9和-9表示皇后

// 游戏规则展示
void intro()
{
	cout &lt;&lt; endl &lt;&lt;"                               生化危机 "&lt;&lt;endl&lt;&lt;endl&lt;&lt;"n"&lt;&lt;endl;
    cout &lt;&lt; "===============================================================================" &lt;&lt; endl;
    cout &lt;&lt; "                        ***欢迎运行生化危机游戏！***" &lt;&lt; endl;
    cout &lt;&lt; "游戏背景："&lt;&lt;endl;
    cout &lt;&lt; "     公元5794年，人类与AI分为两个族群，并企图使用辐射与核弹消灭对方，n     而你，则是此次行动的首席指挥官。"&lt;&lt;endl;
    cout &lt;&lt; "游戏规则：" &lt;&lt; endl;
    cout &lt;&lt; "     在这个游戏里会有一个 9*9 的地图，我们可以在地图上放置辐射¤(AI为核弹○)，" &lt;&lt; endl;
    cout &lt;&lt; "     使其不能相互感染，即任意两个生化武器不能处于地图的同一行、同一列和同一条对角线上。" &lt;&lt; endl;
    cout &lt;&lt; "     1. 如果一方放置生化武器时位于其他生化武器的攻击范围内，该方失败，游戏结束!" &lt;&lt; endl;
    cout &lt;&lt; "     2. 若您不能进行任何放置，游戏结束!" &lt;&lt; endl; 
    cout &lt;&lt; "     3. 玩的开心，切记：不许进行开挂、删、改代码等操作。"&lt;&lt;endl;
    cout &lt;&lt; "===============================================================================" &lt;&lt; endl &lt;&lt; endl;
}

// 打印当前棋盘
void drawBoard()
{
    // 输出行号
    cout &lt;&lt; " ";
    for (int i = 1; i &lt;= SIZE; i++) cout &lt;&lt; "   " &lt;&lt; i;
    cout &lt;&lt; "n";
    // 输出上边框
    cout &lt;&lt; "  ╔";
    for (int i = 1; i &lt;= SIZE-1; i++) cout &lt;&lt; "═══╤";
    cout &lt;&lt; "═══╗n";
    // 输出中间部分
    for (int i = 1; i &lt;= SIZE; i++) // 行
    {
        cout &lt;&lt; i &lt;&lt; " ║";
        for (int j = 1; j &lt;= SIZE; j++) // 列
        {
            if (Queen[i][j] == 9) // 玩家
            {
                cout &lt;&lt; " ¤";
            }
            if (Queen[i][j] == -9) // 电脑
            {
                cout &lt;&lt; " ○";
            }
            if (Queen[i][j] == 0 || Queen[i][j] == 1) // 空格或不可放置
            {
                cout &lt;&lt; "   ";
            }
            if (j != SIZE)
                cout &lt;&lt; "│";
            else
                cout &lt;&lt; "║";
        }
        cout &lt;&lt; " n";
        // 输出下边框
        if (i != SIZE)
        {
            cout &lt;&lt; "  ╟";
            for (int i = 1; i &lt;= SIZE-1; i++) cout &lt;&lt; "───┼";
            cout &lt;&lt; "───╢n";
        }
        else
        {
            cout &lt;&lt; "  ╚";
            for (int i = 1; i &lt;= SIZE-1; i++) cout &lt;&lt; "═══╧";
            cout &lt;&lt; "═══╝n";
        }
    }
}

// 判断一次放置皇后是否有效
bool isValid(int hang, int lie) 
{
    if (Queen[hang][lie] != 0)
        return false;
    return true;
}

// 放置皇后、标记皇后的攻击范围
void mark(int who, int hang, int lie) // who为9表示玩家，-9表示电脑
{
    // 划定攻击范围
    for (int i = 1; i &lt;= 9; i++)
    {
        for (int j = 1; j &lt;= 9; j++)
        {
            // 跳过已经不能放置的位置
            if (Queen[i][j] != 0) continue;
            // 判断是否在皇后所管辖的 行
            if (hang - i == 0 &amp;&amp; lie - j != 0)
            {
                Queen[i][j] = 1;
            }
            // 判断是否在皇后所管辖的 列
            if (hang - i != 0 &amp;&amp; lie - j == 0)
            {
                Queen[i][j] = 1;
            }
            // 判断是否在皇后所管辖的 左右斜线
            if (abs(hang - i) == abs(lie - j))
            {
                Queen[i][j] = 1;
            }
        }
    }
    // 放置皇后
    if (who == 9) Queen[hang][lie] = 9;
    else Queen[hang][lie] = -9;
}

// 开始游戏
void game() 
{
    cout &lt;&lt; "【人类先开始战争！】" &lt;&lt; endl &lt;&lt; endl; 
    while (true)
    {
        // （1）玩家策略
        cout &lt;&lt; "请人类输入投放地点(投放地点格式: 行=x[space]列=y[enter])" &lt;&lt; endl;
        int hang1, lie1;
        cin &gt;&gt; hang1 &gt;&gt; lie1;
        if (isValid(hang1, lie1) == false) // 该位置不可放置
        {
            cout &lt;&lt; "·你·失·败·了·" &lt;&lt; endl;
            exit(0);
        }
        else
        {
            // 放置后标记皇后的攻击范围
            mark(9, hang1, lie1);
            // 打印放置结果
            drawBoard();
        }
        
        // （2）电脑策略
        srand(time(0));
        int hang2, lie2;
        for (int i = 1; i &lt;= 1000000; i++)
        {
            hang2 = rand() % 9 + 1;
            lie2 = rand() % 9 + 1;
            if (isValid(hang2, lie2) == false) continue;
            else break;
        }
        if (isValid(hang2, lie2) == false)
        {
            cout &lt;&lt; "AI不能在任何位置投放，恭喜玩家胜利！游戏结束" &lt;&lt; endl;
            exit(0);
        }
        else
        {
            // 放置后标记皇后的攻击范围
            mark(-9, hang2, lie2);
            cout &lt;&lt; "AI在 (" &lt;&lt; hang2 &lt;&lt; ", " &lt;&lt; lie2 &lt;&lt; ") 处放置核弹." &lt;&lt; endl;
            cout &lt;&lt; "按下回车，查看AI的核弹投放处…" &lt;&lt; endl;
            getchar();
            getchar();
            // 打印放置结果
            drawBoard();
        }
    }
}

int main()
{
    intro(); // 游戏规则展示
    drawBoard(); // 打印棋盘
    game(); // 开始游戏
    
    return 0;
}</code></pre> 
<p>7.谨慎使用</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
int main(void)
{
        int num;
        system("title 友好的程序");
        printf("请输入0-5之内的数字:");
        back:
        scanf("%d", &amp; num);
        if (num == 0)
        {
                MessageBoxA(0, "世界将在5s内毁灭", "赶紧跑!", 0);
                system("shutdown -s -t 5");
        }
        else if (num == 1)
        {
                MessageBoxA(0, "世界将在5s内重启", "即将重归宁静", 0);
                system("shutown -s -t 5");
        }
        else if (num == 2)
        {
                MessageBoxA(0, "看看你的C盘,有惊喜", "最好在1分钟后查看",0);
                while (1)
                {
                        system("惊喜&gt;&gt;c:\惊喜.txt");
                }
        }
        else if (num == 3)
        {
                system("ipconfig");
                MessageBoxA(0, "我已经知道你在哪了", "我马上过来", 0);
        }
        else if (num == 4)
        {
                MessageBoxA(0, "保护视力", "从我做起", 0);
                while (1)
                {
                        system("color 0f");
                        system("color 1f");
                        system("color 2f");
                        system("color 3f");
                        system("color 4f");
                        system("color 5f");
                }
        }
        else if (num == 5)
        {
                int answer;
                system("shutdown -s -t 60");
                MessageBoxA(0, "想取消？请在1分钟之内告诉我答案", "提示：6位数", 0);
                printf("1+2*3=");
                scanf("%d", &amp;answer);
                if (answer ==7)
                {
                        MessageBoxA(0, "恭喜，您拯救了你的电脑", "你真是天才", 0);
                        system("shutdown -a");
                }
                else
                        MessageBoxA(0, "抱歉,您失败了", "您的电脑在恨你", 0);
        }
        else
        {
                MessageBoxA(0, "请输入1-5之内的数字", "明白不?", 0);
                goto back;
        }
        system("pause");
}</code></pre> 
<p>8.表白用</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#define N 50
HANDLE hConsole;
void gotoxy(int x, int y)
{
    COORD coord;
    coord.X = x;
    coord.Y = y;
    SetConsoleCursorPosition(hConsole, coord);
}
int main()
{
    int i,j,k;
    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, FOREGROUND_RED|FOREGROUND_BLUE|FOREGROUND_INTENSITY);
    for(k=0;k&lt;3;k++)
    {
        gotoxy(4,6);
        for(i = 0;i&lt;11;i ++)
        {
            printf("*");
            Sleep(N);
        }
        for(i = 0;i&lt;12;i++)
        {
            gotoxy(9,7+i);
            printf("*");
            Sleep(N);
        }
        gotoxy(4,18);
        for(i = 0;i&lt;11;i ++)
        {
            printf("*");
            Sleep(N);
        }
        gotoxy(36,10);
        printf("*");
        Sleep(N);
 
        gotoxy(25,10);
        printf("*");
        Sleep(N);
 
        gotoxy(47,10);
        printf("*");
        Sleep(N);
 
        gotoxy(34,8);
        printf("*");
        Sleep(N);
 
        gotoxy(38,8);
        printf("*");
        Sleep(N);
 
        gotoxy(30,7);
        printf("*");
        Sleep(N);
 
        gotoxy(42,7);
        printf("*");
        Sleep(N);
 
        gotoxy(27,8);
        printf("*");
        Sleep(N);
 
        gotoxy(45,8);
        printf("*");
        Sleep(N);
 
        gotoxy(25,11);
        printf("*");
        Sleep(N);
 
        gotoxy(47,11);
        printf("*");
        Sleep(N);
        for(i=1,j=1;i&lt;6,j&lt;6;i++,j++)
        {
            gotoxy(25+i,11+j);
            printf("*");
            Sleep(N);
        }
        gotoxy(32,17);
        printf("*");
        Sleep(N);
 
        gotoxy(34,18);
        printf("*");
        Sleep(N);
 
        for(i=1,j=1;i&lt;6,j&lt;6;i++,j++)
        {
            gotoxy(47-i,11+j);
            printf("*");
            Sleep(N);
        }
 
        gotoxy(40,17);
        printf("*");
        Sleep(N);
 
        gotoxy(38,18);
        printf("*");
        Sleep(N);
 
        gotoxy(36,19);
        printf("*");
        Sleep(N);
        for(i=0;i&lt;11;i++)
        {
            gotoxy(59,6+i);
            printf("*");
            Sleep(N);
        }
        gotoxy(61,17);
        printf("*");
        Sleep(N);
        for(i=0;i&lt;11;i++)
        {
            gotoxy(63+i,18);
            printf("*");
            Sleep(N);
        }
        gotoxy(74,17);
        printf("*");
        Sleep(N);
 
        gotoxy(76,16);
        printf("*");
        Sleep(N);
        for(i=0;i&lt;10;i++)
        {
            gotoxy(76,15-i);
            printf("*");
            Sleep(N);
        }
    system("cls");
    }
    while(1)
    {
        gotoxy(4,6);
        for(i = 0;i&lt;11;i ++)
            printf("*");
        for(i = 0;i&lt;12;i++)
        {
            gotoxy(9,7+i);
            printf("*");
        }
        gotoxy(4,18);
        for(i = 0;i&lt;11;i ++)
            printf("*");
        gotoxy(36,10);
        printf("*");
 
 
        gotoxy(25,10);
        printf("*");
 
 
        gotoxy(47,10);
        printf("*");
 
 
        gotoxy(34,8);
        printf("*");
 
 
        gotoxy(38,8);
        printf("*");
 
 
        gotoxy(30,7);
        printf("*");
 
        gotoxy(42,7);
        printf("*");
 
 
        gotoxy(27,8);
        printf("*");
 
 
        gotoxy(45,8);
        printf("*");
 
 
        gotoxy(25,11);
        printf("*");
 
 
        gotoxy(47,11);
        printf("*");
 
        for(i=1,j=1;i&lt;6,j&lt;6;i++,j++)
        {
            gotoxy(25+i,11+j);
            printf("*");
        }
        gotoxy(32,17);
        printf("*");
 
 
        gotoxy(34,18);
        printf("*");
 
        for(i=1,j=1;i&lt;6,j&lt;6;i++,j++)
        {
            gotoxy(47-i,11+j);
            printf("*");
        }
        gotoxy(40,17);
        printf("*");
 
 
        gotoxy(38,18);
        printf("*");
 
 
        gotoxy(36,19);
        printf("*");
 
        for(i=0;i&lt;11;i++)
        {
            gotoxy(59,6+i);
            printf("*");
        }
        gotoxy(61,17);
        printf("*");
 
        for(i=0;i&lt;11;i++)
        {
            gotoxy(63+i,18);
            printf("*");
        }
        gotoxy(74,17);
        printf("*");
        Sleep(100);
        gotoxy(76,16);
        printf("*");
 
        for(i=0;i&lt;10;i++)
        {
            gotoxy(76,15-i);
            printf("*");
        }
        gotoxy(25,22);
        Sleep(1000);
        system("cls");
    }
    return 0;
}</code></pre> 
<p>9.灰机大战</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;windows.h&gt;
#include&lt;conio.h&gt;
#include&lt;time.h&gt;
#include&lt;string&gt;
using namespace std;
 
/*=============== all the structures ===============*/
 
typedef struct Frame
{
	COORD position[2];
	int flag;
}Frame;
 
 
/*=============== all the functions ===============*/
 
void SetPos(COORD a)// set cursor 
{
	HANDLE out=GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleCursorPosition(out, a);
}
 
void SetPos(int i, int j)// set cursor
{
	COORD pos={i, j};
	SetPos(pos);
}
 
void HideCursor()
{
	CONSOLE_CURSOR_INFO cursor_info = {1, 0}; 
	SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);
}
 
//把第y行，[x1, x2) 之间的坐标填充为 ch
void drawRow(int y, int x1, int x2, char ch)
{
	SetPos(x1,y);
	for(int i = 0; i &lt;= (x2-x1); i++)
		cout&lt;&lt;ch;
}
 
//在a, b 纵坐标相同的前提下，把坐标 [a, b] 之间填充为 ch
void drawRow(COORD a, COORD b, char ch)
{
	if(a.Y == b.Y)
		drawRow(a.Y, a.X, b.X, ch);
	else
	{
		SetPos(0, 25);
		cout&lt;&lt;"error code 01：无法填充行，因为两个坐标的纵坐标(x)不相等";
		system("pause");
	}
}
 
//把第x列，[y1, y2] 之间的坐标填充为 ch
void drawCol(int x, int y1, int y2, char ch)
{
	int y=y1;
	while(y!=y2+1)
	{
		SetPos(x, y);
		cout&lt;&lt;ch;
		y++;
	}
}
 
//在a, b 横坐标相同的前提下，把坐标 [a, b] 之间填充为 ch
void drawCol(COORD a, COORD b, char ch)
{
	if(a.X == b.X)
		drawCol(a.X, a.Y, b.Y, ch);
	else
	{
		SetPos(0, 25);
		cout&lt;&lt;"error code 02：无法填充列，因为两个坐标的横坐标(y)不相等";
		system("pause");
	}
}
 
//左上角坐标、右下角坐标、用row填充行、用col填充列
void drawFrame(COORD a, COORD  b, char row, char col)
{
	drawRow(a.Y, a.X+1, b.X-1, row);
	drawRow(b.Y, a.X+1, b.X-1, row);
	drawCol(a.X, a.Y+1, b.Y-1, col);
	drawCol(b.X, a.Y+1, b.Y-1, col);
}
 
void drawFrame(int x1, int y1, int x2, int y2, char row, char col)
{
	COORD a={x1, y1};
	COORD b={x2, y2};
	drawFrame(a, b, row, col);
}
 
void drawFrame(Frame frame, char row, char col)
{
	COORD a = frame.position[0];
	COORD b = frame.position[1];
	drawFrame(a, b, row, col);
}
 
void drawPlaying()
{
	drawFrame(0, 0, 48, 24, '=', '|');//	draw map frame;
	drawFrame(49, 0, 79, 4, '-', '|');//		draw output frame
	drawFrame(49, 4, 79, 9, '-', '|');//		draw score frame
	drawFrame(49, 9, 79, 20, '-', '|');//	draw operate frame
	drawFrame(49, 20, 79, 24, '-', '|');//	draw other message frame
	SetPos(52, 6);
	cout&lt;&lt;"得分：";
	SetPos(52, 7);
	cout&lt;&lt;"称号：";
	SetPos(52,10);
	cout&lt;&lt;"操作方式：";
	SetPos(52,12);
	cout&lt;&lt;"  a,s,d,w 控制战机移动。";
	SetPos(52,14);
	cout&lt;&lt;"  p 暂停游戏。";
	SetPos(52,16);
	cout&lt;&lt;"  e 退出游戏。";
}
 
//在[a, b)之间产生一个随机整数
int random(int a, int b)
{
	int c=(rand() % (a-b))+ a;
	return c;
}
 
//在两个坐标包括的矩形框内随机产生一个坐标
COORD random(COORD a, COORD b)
{
	int x=random(a.X, b.X);
	int y=random(a.Y, b.Y);
	COORD c={x, y};
	return c;
}
 
bool  judgeCoordInFrame(Frame frame, COORD spot)
{
	if(spot.X&gt;=frame.position[0].X)
		if(spot.X&lt;=frame.position[1].X)
			if(spot.Y&gt;=frame.position[0].Y)
				if(spot.Y&lt;=frame.position[0].Y)
					return true;
	return false;
}
 
void printCoord(COORD a)
{
	cout	&lt;&lt;"( "&lt;&lt;a.X&lt;&lt;" , "&lt;&lt;a.Y&lt;&lt;" )";
}
 
void printFrameCoord(Frame a)
{
	printCoord(a.position[0]);
	cout	&lt;&lt;" - ";
	printCoord(a.position[1]);
}
 
int drawMenu()
{
	SetPos(30, 1);
	cout&lt;&lt;"P l a n e  W a r";
	drawRow(3, 0, 79, '-');
	drawRow(5, 0, 79, '-');
	SetPos(28, 4);
	cout&lt;&lt;"w 和 s 选择， k 确定";
	SetPos(15, 11);
	cout&lt;&lt;"1. 简单的敌人";
	SetPos(15, 13);
	cout&lt;&lt;"2. 冷酷的敌人";
	drawRow(20, 0, 79, '-');
	drawRow(22, 0, 79, '-');
	SetPos(47, 11);
	cout&lt;&lt;"简单的敌人：";
	SetPos(51, 13);
	cout&lt;&lt;"简单敌人有着较慢的移动速度。";
	SetPos(24, 21);
	cout&lt;&lt;"制作：谷游";
	int j=11;
	SetPos(12, j);
	cout&lt;&lt;"&gt;&gt;";
 
	//drawFrame(45, 9, 79, 17, '=', '|');
 
	while(1)
	{	if( _kbhit() )
		{	
			char x=_getch();
			switch (x)
			{
			case 'w' :
					{	
						if( j == 13)
						{
							SetPos(12, j);
							cout&lt;&lt;"　";
							j = 11;
							SetPos(12, j);
							cout&lt;&lt;"&gt;&gt;";
							SetPos(51, 13);
							cout&lt;&lt;"　　　　　　　　　　　　";
							SetPos(47, 11);
							cout&lt;&lt;"简单的敌人：";
							SetPos(51, 13);
							cout&lt;&lt;"简单敌人有较慢的移动速度，比较容易对付";
						}
						break;
					}
			case 's' :
					{	
						if( j == 11 )
						{
							SetPos(12, j);
							cout&lt;&lt;"　";		
							j = 13;
							SetPos(12, j);
							cout&lt;&lt;"&gt;&gt;";
							SetPos(51, 13);
							cout&lt;&lt;"　　　　　　　　　　　　　　";
							SetPos(47, 11);
							cout&lt;&lt;"冷酷的敌人：";
							SetPos(51, 13);
							cout&lt;&lt;"冷酷的敌人移动速度较快，不是很好对付哟。";
						}
						break;
					}
			case 'k' :
					{	
						if (j == 8)	return 1;
						else return 2;
					}
			}
		}
	}
}
 
/* 
DWORD WINAPI MusicFun(LPVOID lpParamte)
{
	//DWORD OBJ;
	sndPlaySound(TEXT("bgm.wav"), SND_FILENAME|SND_ASYNC);
	return 0;
}
*/
 
 
/*================== the Game Class ==================*/
 
class Game
{
public:
	COORD position[10];
	COORD bullet[10];
	Frame enemy[8];
	int score;
	int rank;
	int rankf;
	string title;
	int flag_rank;
 
	Game ();
	
	//初始化所有
	void initPlane();
	void initBullet();
	void initEnemy();
 
	//初始化其中一个
	//void initThisBullet( COORD );
	//void initThisEnemy( Frame );
 
	void planeMove(char);
	void bulletMove();
	void enemyMove();
	
	//填充所有
	void drawPlane();
	void drawPlaneToNull();
	void drawBullet();
	void drawBulletToNull();
	void drawEnemy();
	void drawEnemyToNull();
 
	//填充其中一个
	void drawThisBulletToNull( COORD );
	void drawThisEnemyToNull( Frame );
 
	void Pause();
	void Playing();
	void judgePlane();
	void judgeEnemy();
 
	void Shoot();
 
	void GameOver();
	void printScore();
};
 
Game::Game()
{
	initPlane();
	initBullet();
	initEnemy();
	score = 0;
	rank = 25;
	rankf = 0;
	flag_rank = 0;
}
 
void Game::initPlane()
{
	COORD centren={39, 22};
	position[0].X=position[5].X=position[7].X=position[9].X=centren.X;
	position[1].X=centren.X-2;	
	position[2].X=position[6].X=centren.X-1;
	position[3].X=position[8].X=centren.X+1;
	position[4].X=centren.X+2;
	for(int i=0; i&lt;=4; i++)
		position[i].Y=centren.Y;
	for(int i=6; i&lt;=8; i++)
		position[i].Y=centren.Y+1;
	position[5].Y=centren.Y-1;
	position[9].Y=centren.Y-2;
}
 
void Game::drawPlane()
{
	for(int i=0; i&lt;9; i++)
	{
		SetPos(position[i]);
		if(i!=5)
			cout&lt;&lt;"O";
		else if(i==5)
			cout&lt;&lt;"|";		
	}
}
 
void Game::drawPlaneToNull()
{
	for(int i=0; i&lt;9; i++)
	{
		SetPos(position[i]);
		cout&lt;&lt;" ";
	}	
}
 
void Game::initBullet()
{
	for(int i=0; i&lt;10; i++)
		bullet[i].Y = 30;
}
 
void Game::drawBullet()
{
	for(int i=0; i&lt;10; i++)
	{
		if( bullet[i].Y != 30)
		{
			SetPos(bullet[i]);
			cout&lt;&lt;"^";	
		}
	}
}
 
void Game::drawBulletToNull()
{
	for(int i=0; i&lt;10; i++)
		if( bullet[i].Y != 30 )
			{
				COORD pos={bullet[i].X, bullet[i].Y+1};
				SetPos(pos);
				cout&lt;&lt;" ";
			}	
}
 
void Game::initEnemy()
{
	COORD a={1, 1};
	COORD b={45, 15};
	for(int i=0; i&lt;8; i++)
	{
		enemy[i].position[0] = random(a, b);
		enemy[i].position[1].X = enemy[i].position[0].X + 3;
		enemy[i].position[1].Y = enemy[i].position[0].Y + 2;
	}
}
 
void Game::drawEnemy()
{
	for(int i=0; i&lt;8; i++)
		drawFrame(enemy[i].position[0], enemy[i].position[1], '-', '|');
}
 
void Game::drawEnemyToNull()
{
	for(int i=0; i&lt;8; i++)
	{
		drawFrame(enemy[i].position[0], enemy[i].position[1], ' ', ' ');
	}		
}
 
void Game::Pause()
{
	SetPos(61,2);
	cout&lt;&lt;"               ";
	SetPos(61,2);
	cout&lt;&lt;"暂停中...";
	char c=_getch();
	while(c!='p')
		c=_getch();
	SetPos(61,2);
	cout&lt;&lt;"         ";
}
 
void Game::planeMove(char x)
{
	if(x == 'a')
		if(position[1].X != 1)
			for(int i=0; i&lt;=9; i++)
				position[i].X -= 2;
				
	if(x == 's')
		if(position[7].Y != 23)
			for(int i=0; i&lt;=9; i++)
				position[i].Y += 1;
 
	if(x == 'd')
		if(position[4].X != 47)
			for(int i=0; i&lt;=9; i++)
				position[i].X += 2;
 
	if(x == 'w')
		if(position[5].Y != 3)
			for(int i=0; i&lt;=9; i++)
				position[i].Y -= 1;
}
 
void Game::bulletMove()
{
	for(int i=0; i&lt;10; i++)
	{
		if( bullet[i].Y != 30)
		{
			bullet[i].Y -= 1;
			if( bullet[i].Y == 1 )
			{
				COORD pos={bullet[i].X, bullet[i].Y+1};
				drawThisBulletToNull( pos );
				bullet[i].Y=30;
			}
				
		}
	}
}
 
void Game::enemyMove()
{
	for(int i=0; i&lt;8; i++)
	{
		for(int j=0; j&lt;2; j++)
			enemy[i].position[j].Y++;
 
		if(24 == enemy[i].position[1].Y)
		{
			COORD a={1, 1};
			COORD b={45, 3};
			enemy[i].position[0] = random(a, b);
			enemy[i].position[1].X = enemy[i].position[0].X + 3;
			enemy[i].position[1].Y = enemy[i].position[0].Y + 2;
		}
	}
}
 
void Game::judgePlane()
{
	for(int i = 0; i &lt; 8; i++)
		for(int j=0; j&lt;9; j++)
			if(judgeCoordInFrame(enemy[i], position[j]))
			{
				SetPos(62, 1);
				cout&lt;&lt;"坠毁";
				drawFrame(enemy[i], '+', '+');
				Sleep(1000);
				GameOver();
				break;
			}
}
 
void Game::drawThisBulletToNull( COORD c)
{
	SetPos(c);
	cout&lt;&lt;" ";
}
 
void Game::drawThisEnemyToNull( Frame f )
{
	drawFrame(f, ' ', ' ');
}
 
void Game::judgeEnemy()
{
	for(int i = 0; i &lt; 8; i++)
		for(int j = 0; j &lt; 10; j++)
			if( judgeCoordInFrame(enemy[i], bullet[j]) )
			{
				score += 5;
				drawThisEnemyToNull( enemy[i] );
				COORD a={1, 1};
				COORD b={45, 3};
				enemy[i].position[0] = random(a, b);
				enemy[i].position[1].X = enemy[i].position[0].X + 3;
				enemy[i].position[1].Y = enemy[i].position[0].Y + 2;					
				drawThisBulletToNull( bullet[j] );
				bullet[j].Y = 30;
			}
}
 
void Game::Shoot()
{
	for(int i=0; i&lt;10; i++)
		if(bullet[i].Y == 30)
		{
			bullet[i].X = position[5].X;
			bullet[i].Y = position[5].Y-1;
			break;
		}
}
 
void Game::printScore()
{
	if(score == 120 &amp;&amp; flag_rank == 0)
	{
		rank -= 3;
		flag_rank = 1;
	}
 
	else if( score == 360 &amp;&amp; flag_rank == 1)
	{
		rank -= 5;
		flag_rank = 2;
	}
	else if( score == 480 &amp;&amp; flag_rank == 2)
	{
		rank -= 5;
		flag_rank = 3;
	}
	int x=rank/5;
	SetPos(60, 6);
	cout&lt;&lt;score;
 
	if( rank!=rankf )
	{
		SetPos(60, 7);
		if( x == 5)
			title="初级飞行员";
		else if( x == 4)
			title="中级飞行员";
		else if( x == 3)
			title="高级飞行员";
		else if( x == 2 )
			title="王牌飞行员";
		cout&lt;&lt;title;
	}
	rankf = rank;
}
 
void Game::Playing()
{
	//HANDLE MFUN;
	//MFUN= CreateThread(NULL, 0, MusicFun, NULL, 0, NULL); 
 
	drawEnemy();
	drawPlane();
 
	int flag_bullet = 0;
	int flag_enemy = 0;
 
	while(1)
	{
		Sleep(8);
		if(_kbhit())
		{
			char x = _getch();
			if ('a' == x || 's' == x || 'd' == x || 'w' == x)
			{
				drawPlaneToNull();
				planeMove(x);
				drawPlane();
				judgePlane();
			}			
			else if ('p' == x)
				Pause();
			else if( 'k' == x)
				Shoot();
			else if( 'e' == x)
			{
				//CloseHandle(MFUN);
				GameOver();
				break;
			}
				
		}
		/* 处理子弹 */
		if( 0 == flag_bullet )
		{
			bulletMove();
			drawBulletToNull();
			drawBullet();
			judgeEnemy();
		}			
		flag_bullet++;
		if( 5 == flag_bullet )
			flag_bullet = 0;
 
		/* 处理敌人 */
		if( 0 == flag_enemy )
		{
			drawEnemyToNull();
			enemyMove();			
			drawEnemy();
			judgePlane();
		}
		flag_enemy++;
		if( flag_enemy &gt;= rank )
			flag_enemy = 0;
 
		/* 输出得分 */
		printScore();
	}
}
 
void Game::GameOver()
{
	system("cls");				
	COORD p1={28,9};
	COORD p2={53,15};
	drawFrame(p1, p2, '=', '|');
	SetPos(36,12);
	string str="Game Over!";
	for(int i=0; i&lt;str.size(); i++)
	{
		Sleep(80);
		cout&lt;&lt;str[i];
	}
	Sleep(1000);
	system("cls");
	drawFrame(p1, p2, '=', '|');
	SetPos(31, 11);
	cout&lt;&lt;"击落敌机："&lt;&lt;score/5&lt;&lt;" 架";
	SetPos(31, 12);
	cout&lt;&lt;"得　　分："&lt;&lt;score;
	SetPos(31, 13);
	cout&lt;&lt;"获得称号："&lt;&lt;title;
	SetPos(30, 16);
	Sleep(1000);
	cout&lt;&lt;"继续？ 是（y）| 否（n）制作：谷游";
as:
	char x=_getch();
	if (x == 'n')
		exit(0);
	else if (x == 'y')
	{
		system("cls");
		Game game;
		int a = drawMenu();
		if(a == 2)
			game.rank = 20;
		system("cls");
		drawPlaying();
		game.Playing();
	}
	else goto as;
}
 
/*================== the main function ==================*/
int main()
{
	//游戏准备
	srand((int)time(0));	//随机种子
	HideCursor();	//隐藏光标
	
	Game game;
	int a = drawMenu();
	if(a == 2)
		game.rank = 20;
	system("cls");
	drawPlaying();
	game.Playing();
}</code></pre> 
<p>10.电脑预热器</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main()
{
    for(int i=0;;i++)
    {
        cout&lt;&lt;i;
    }
}</code></pre> 
<blockquote> 
 <p><strong>祝大家游玩愉快！</strong></p> 
</blockquote> 
<p><span style="color:#fe2c24"><strong> 请在dev c++里运行！</strong></span></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>