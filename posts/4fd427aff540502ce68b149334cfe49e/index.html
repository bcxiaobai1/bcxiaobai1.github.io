<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>正则表达式 - 边界 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">正则表达式 - 边界</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E9%9B%B6%E5%AE%BD%E6%96%AD%E8%A8%80-toc" style="margin-left:0px"><a href="#%E4%B8%80%E3%80%81%E9%9B%B6%E5%AE%BD%E6%96%AD%E8%A8%80">一、零宽断言</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%A1%8C%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F-toc" style="margin-left:0px"><a href="#%E4%BA%8C%E3%80%81%E8%A1%8C%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F">二、行的开始和结束</a></p> 
<p id="1%20.%20%5E%20%E4%B8%8E%20%24-toc" style="margin-left:40px"><a href="#1%20.%20%5E%20%E4%B8%8E%20%24">1 . ^ 与 $</a></p> 
<p id="2.%20dotall%20%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px"><a href="#2.%20dotall%20%E6%A8%A1%E5%BC%8F">2. dotall 模式</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C%E5%92%8C%E9%9D%9E%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C-toc" style="margin-left:0px"><a href="#%E4%B8%89%E3%80%81%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C%E5%92%8C%E9%9D%9E%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C">三、单词边界和非单词边界</a></p> 
<p id="1.%20%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E5%8D%95%E8%AF%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-toc" style="margin-left:40px"><a href="#1.%20%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E5%8D%95%E8%AF%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">1. 统计某个单词出现的次数</a></p> 
<p id="2.%20%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px"><a href="#2.%20%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0">2. 统计单词个数</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%B8%BB%E9%A2%98%E8%AF%8D%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%B8%8E%E7%BB%93%E6%9D%9F%E4%BD%8D%E7%BD%AE-toc" style="margin-left:0px"><a href="#%E5%9B%9B%E3%80%81%E4%B8%BB%E9%A2%98%E8%AF%8D%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%B8%8E%E7%BB%93%E6%9D%9F%E4%BD%8D%E7%BD%AE">四、主题词的起始与结束位置</a></p> 
<p id="%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8%E5%85%83%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E9%9D%A2%E5%80%BC-toc" style="margin-left:0px"><a href="#%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8%E5%85%83%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E9%9D%A2%E5%80%BC">五、使用元字符的字面值</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%9C%A8%E6%AE%B5%E9%A6%96%E5%8A%A0%E6%A0%87%E7%AD%BE-toc" style="margin-left:0px"><a href="#%E5%85%AD%E3%80%81%E5%9C%A8%E6%AE%B5%E9%A6%96%E5%8A%A0%E6%A0%87%E7%AD%BE">六、在段首加标签</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h1>一、零宽断言</h1> 
<p>        断言（assertions）从字面上理解就是判定是还是否。在正则表达式的系统里，也就是匹配或者不匹配。随便写一个正则表达式，都能产生匹配或者不匹配的结果，所以可以这样说，所有的正则表达式都可以叫断言。</p> 
<p>        我们也经常会看到零宽断言（zero-width assertions）这个概念。普通的断言，比如 d+ （匹配一个或者多个数字），它所匹配的内容有长度的；而有些断言比如 ^ 和 $ （分别匹配行开头和结尾）不匹配字符，而是匹配字符串中的位置，这样可以理解为它所匹配的内容长度为0，所以称这类断言为零宽断言(zero-width assertions)。</p> 
<p>        实际中很多时候提到断言，通常是指零宽断言。零宽断言又可分为锚位符（anchor）和环视（Lookarounds）两类。</p> 
<p>        锚位符会根据字符串中的当前位置导致匹配成功或失败，但它们不会导致引擎在字符串中前进或消耗字符。下表中列出的元字符是锚位符。</p> 
<table align="center" border="1" cellspacing="0"><tbody>
<tr>
<td style="background-color:#f2f2f2;border-color:#000000;width:40.85pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>断言</strong></p> </td>
<td style="background-color:#f2f2f2;border-color:#000000;width:172.15pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>描述</strong></p> </td>
<td style="background-color:#f2f2f2;border-color:#000000;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>模式</strong></p> </td>
<td style="background-color:#f2f2f2;border-color:#000000;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>匹配</strong></p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:40.85pt"> <p style="margin-left:.0001pt;text-align:justify">^</p> </td>
<td style="vertical-align:top;width:172.15pt"> <p style="margin-left:.0001pt;text-align:justify">匹配字符串或行的开头。</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">^d{3}</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">901 in 901-333-</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:40.85pt"> <p style="margin-left:.0001pt;text-align:justify">$</p> </td>
<td style="vertical-align:top;width:172.15pt"> <p style="margin-left:.0001pt;text-align:justify">匹配字符串或行的末尾。</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">-d{3}$</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">-333 in -901-333</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:40.85pt"> <p style="margin-left:.0001pt;text-align:justify">A</p> </td>
<td style="vertical-align:top;width:172.15pt"> <p style="margin-left:.0001pt;text-align:justify">匹配字符串的开头。</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">Ad{3}</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">901 in 901-333-</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:40.85pt"> <p style="margin-left:.0001pt;text-align:justify">Z</p> </td>
<td style="vertical-align:top;width:172.15pt"> <p style="margin-left:.0001pt;text-align:justify">匹配字符串的末尾，或字符串末尾的 n 之前。</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">-d{3}Z</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">-333 in -901-333</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:40.85pt"> <p style="margin-left:.0001pt;text-align:justify">z</p> </td>
<td style="vertical-align:top;width:172.15pt"> <p style="margin-left:.0001pt;text-align:justify">匹配字符串的末尾。</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">-d{3}z</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">-333 in -901-333</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:40.85pt"> <p style="margin-left:.0001pt;text-align:justify">G</p> </td>
<td style="vertical-align:top;width:172.15pt"> <p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#ffffff"><span style="color:#333333">匹配必须出现在上一个匹配结束的位置。</span></span></p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">G<span style="color:#fe2c24">(d)</span></p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">(1)、(3)、(5) in (1)(3)(5)[7](9)</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:40.85pt"> <p style="margin-left:.0001pt;text-align:justify">b</p> </td>
<td style="vertical-align:top;width:172.15pt"> <p style="margin-left:.0001pt;text-align:justify">匹配 w 和 W字符之间的边界上。</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">bw+sw+b</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">them theme、them them in them theme them them</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:40.85pt"> <p style="margin-left:.0001pt;text-align:justify">B</p> </td>
<td style="vertical-align:top;width:172.15pt"> <p style="margin-left:.0001pt;text-align:justify">匹配非边界。</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">Bendw*b</p> </td>
<td style="vertical-align:top;width:106.55pt"> <p style="margin-left:.0001pt;text-align:justify">ends、ender in end sends endure lender</p> </td>
</tr>
</tbody></table> 
<p>        环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则，如下表所示。</p> 
<table align="center" border="1" cellspacing="0"><tbody>
<tr>
<td style="background-color:#f2f2f2;border-color:#000000;width:42.35pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>断言</strong></p> </td>
<td style="background-color:#f2f2f2;border-color:#000000;width:189.85pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>名称</strong></p> </td>
<td style="background-color:#f2f2f2;border-color:#000000;width:63.8pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>含义</strong></p> </td>
<td style="background-color:#f2f2f2;border-color:#000000;width:130.1pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>示例</strong></p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:42.35pt"> <p style="margin-left:.0001pt;text-align:justify">(?&lt;=Y)</p> </td>
<td style="vertical-align:top;width:189.85pt"> <p style="margin-left:.0001pt;text-align:justify">肯定逆序环视positive-lookahead</p> </td>
<td style="vertical-align:top;width:63.8pt"> <p style="margin-left:.0001pt;text-align:justify">左边是Y</p> </td>
<td style="vertical-align:top;width:130.1pt"> <p style="margin-left:.0001pt;text-align:justify">(?&lt;=d)th 左边是数字的th，能匹配 9th</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:42.35pt"> <p style="margin-left:.0001pt;text-align:justify">(?&lt;!Y)</p> </td>
<td style="vertical-align:top;width:189.85pt"> <p style="margin-left:.0001pt;text-align:justify">否定逆序环视negative-lookahead</p> </td>
<td style="vertical-align:top;width:63.8pt"> <p style="margin-left:.0001pt;text-align:justify">左边不是Y</p> </td>
<td style="vertical-align:top;width:130.1pt"> <p style="margin-left:.0001pt;text-align:justify">(?&lt;!d)th 左边不是数字的th，能匹配 health</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:42.35pt"> <p style="margin-left:.0001pt;text-align:justify">(?=Y)</p> </td>
<td style="vertical-align:top;width:189.85pt"> <p style="margin-left:.0001pt;text-align:justify">肯定顺序环视positive-lookbehind</p> </td>
<td style="vertical-align:top;width:63.8pt"> <p style="margin-left:.0001pt;text-align:justify">右边是Y</p> </td>
<td style="vertical-align:top;width:130.1pt"> <p style="margin-left:.0001pt;text-align:justify">six(?=d)右边是数字的six，能匹配six6</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:42.35pt"> <p style="margin-left:.0001pt;text-align:justify">(?!Y)</p> </td>
<td style="vertical-align:top;width:189.85pt"> <p style="margin-left:.0001pt;text-align:justify">否定顺序环视negative-lookbehind</p> </td>
<td style="vertical-align:top;width:63.8pt"> <p style="margin-left:.0001pt;text-align:justify">右边不是Y</p> </td>
<td style="vertical-align:top;width:130.1pt"> <p style="margin-left:.0001pt;text-align:justify">hi(?!d)右边不是数字的hi，能匹配high</p> </td>
</tr>
</tbody></table> 
<h1 id="%E4%BA%8C%E3%80%81%E8%A1%8C%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F">二、行的开始和结束</h1> 
<h2 id="1%20.%20%5E%20%E4%B8%8E%20%24">1 . ^ 与 $</h2> 
<p>        就像之前看到的那样，要匹配行或字符串的起始要使用脱字符（U+005E）^。根据上下文，^ 会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。而上下文则依赖于应用程序和在应用程序中所使用的选项。</p> 
<p>        若要匹配行或字符串的结尾位置要使用美元符 $。正如前一篇中介绍的单行模式与多行模式所述，如果不选择多行模式，整个目标文本被视做一个字符串。</p> 
<p>        对于上一篇生成的测试数据来说，使用多行模式时，^How.*Country$ 匹配两行，否则只匹配一行。</p> 
<pre><code>mysql&gt; select * from t_regexp where regexp_like(a,'^How.*Country$','m')G
*************************** 1. row ***************************
a: THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.
ARGUMENT.
How a Ship having passed the Line was driven by Storms to the cold Country
towards the South Pole; and how from thence she made her course to the tropical
Latitude of the Great Pacific Ocean; and of the strange things that befell;
and in what manner the Ancyent Marinere came back to his own Country.
I.
1       It is an ancyent Marinere,
2          And he stoppeth one of three:
3       "By thy long grey beard and thy glittering eye
4          "Now wherefore stoppest me?
*************************** 2. row ***************************
a: How a Ship having passed the Line was driven by Storms to the cold Country
2 rows in set (0.00 sec)</code></pre> 
<h2 id="2.%20dotall%20%E6%A8%A1%E5%BC%8F">2. dotall 模式</h2> 
<p>        正则表达式中的 dotall 模式，表示 . 匹配行结束符，而缺省 . 遇到行结束符时会终止匹配。在MySQL的正则表达式函数中，使用 match_type 的 n 值表示使用 dotall 模式。看如下正则表达式：</p> 
<pre><code>^THE.*?$</code></pre> 
<p>        我们想匹配以THE开头，以 ? 结束的字符串，如果不指定 dotall 模式，不会返回任何记录。指定 dotall 模式后，可以看到它匹配了整个文本。注意MySQL正则中的转义要写两个  。</p> 
<pre><code>mysql&gt; select * from t_regexp where regexp_like(a,'^THE.*\?$')G
Empty set (0.00 sec)

mysql&gt; select * from t_regexp where regexp_like(a,'^THE.*\?$','n')G
*************************** 1. row ***************************
a: THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.
ARGUMENT.
How a Ship having passed the Line was driven by Storms to the cold Country
towards the South Pole; and how from thence she made her course to the tropical
Latitude of the Great Pacific Ocean; and of the strange things that befell;
and in what manner the Ancyent Marinere came back to his own Country.
I.
1       It is an ancyent Marinere,
2          And he stoppeth one of three:
3       "By thy long grey beard and thy glittering eye
4          "Now wherefore stoppest me?
1 row in set (0.00 sec)</code></pre> 
<p>        dotall 选项表示点号除了匹配其他字符之外，还会匹配换行符。取消 dotall 选项，表达式 ^THE.* 则匹配第一行；使用 dotall 选项后，全部文本都会被匹配，不需要使用 ?$ 来匹配文本的结尾。</p> 
<h1 id="%E4%B8%89%E3%80%81%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C%E5%92%8C%E9%9D%9E%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C">三、单词边界和非单词边界</h1> 
<p>        b 匹配单词边界，如 bTHEb 匹配单词 THE。就像 ^ 和 $ 一样，b 是个零宽度断言，表面上它会匹配空格或者是行起始，而实际上它匹配的是个零宽度的不存在的东西。这个理解起来不是很容易，但可以通过观察它匹配和不匹配的内容来理解。</p> 
<pre><code>mysql&gt; select regexp_like('the m','\bTHE\b');
+----------------------------------+
| regexp_like('the m','\bTHE\b') |
+----------------------------------+
|                                1 |
+----------------------------------+
1 row in set (0.00 sec)

mysql&gt; select regexp_like('them','\bTHE\b');
+---------------------------------+
| regexp_like('them','\bTHE\b') |
+---------------------------------+
|                               0 |
+---------------------------------+
1 row in set (0.00 sec)

mysql&gt; select regexp_like('the m','\bTHE\b','c');
+--------------------------------------+
| regexp_like('the m','\bTHE\b','c') |
+--------------------------------------+
|                                    0 |
+--------------------------------------+
1 row in set (0.00 sec)

mysql&gt; select regexp_like('the m','\bTHE\b','i');
+--------------------------------------+
| regexp_like('the m','\bTHE\b','i') |
+--------------------------------------+
|                                    1 |
+--------------------------------------+
1 row in set (0.00 sec)</code></pre> 
<p>        还可以匹配非单词边界。非单词边界匹配除单词边界之外的位置，比如单词或者字符串中的字母或数字。例如 BeB 匹配字母e，而匹配的字母 e 的两边都是其他字母或者是非单词字符。零宽度断言不会匹配两边的字符，但它会识别文字 e 的两边是否是非单词边界。</p> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/f4/87/6SCau9Im_o.png"></p> 
<p>        下面看两个具体的应用。</p> 
<h2 id="1.%20%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E5%8D%95%E8%AF%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">1. 统计某个单词出现的次数</h2> 
<p>        假设要统计 THE 出现的次数，不区分大小写，实现如下，结果为9。</p> 
<pre><code class="language-sql">select (length(a) - length(regexp_replace(a,'\bthe\b',''))/2)/3 a 
  from t_regexp 
 where regexp_instr(a,'\n');</code></pre> 
<p>        说明：</p> 
<ul>
<li>regexp_instr(a,'\n') 条件只返回带有换行符的多行字符串。</li>
<li>regexp_replace(a,'\bthe\b','') 将原字符串中的 the 单词替换掉，用 b 确定单词边界。regexp_replace函数缺省不区分大小写。</li>
<li>用原字符串长度减去替换掉 the 后的字符串长度，再除以 the 这个单词的长度，结果即为 the 出现的次数。</li>
<li>/2 的原因是，MySQL 8.0.17之前有bug，结果返回的是UTF-16字符集，而不是原字符串的字符集，导致 length 函数的返回值会翻倍。（Prior to MySQL 8.0.17, the result returned by this function used the UTF-16 character set; in MySQL 8.0.17 and later, the character set and collation of the expression searched for matches is used. (Bug #94203, Bug #29308212)）</li>
<li>MySQL没有提供类似于Oracle的regexp_count()函数，因此只能用替换掉需统计字符串再取长度差的通用方法。</li>
</ul> 
<h2 id="2.%20%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0">2. 统计单词个数</h2> 
<p>        统计多行字符串中的单词个数（即著名的Wordcount），实现如下，结果为95。</p> 
<pre><code class="language-sql">select a, length(regexp_replace(regexp_replace(regexp_replace(regexp_replace(a,'\s+$','',1,0,'m'),'\.|,|\?|"|:|;',' '),'\s{2,}',' '),'\w',''))/2 c
  from t_regexp 
 where regexp_instr(a,'\n')G</code></pre> 
<p>        说明：</p> 
<ul>
<li>regexp_instr(a,'\n') 条件只返回带有换行符的多行字符串。</li>
<li>regexp_replace(a,'\s+$','',1,0,'m') 使用多行模式替换掉所有空行。s 匹配一个空白字符，包括空格、制表符、换页符和换行符；+ 匹配前面一个字符重复一次或更多次；$ 匹配字符串的结束。多行空行即为以空格开头开头，中间重复多个空格或换行符，再加此字符串结束的一串字符。</li>
<li>regexp_replace(..., '\.|,|\?|"|:|;',' ') 将所有相关标点符号替换成空格，用于外层的 w+ 匹配。</li>
<li>regexp_replace(..., '\s{2,}',' ') 将多个空格压缩为一个，避免统计多次。</li>
<li>length(regexp_replace(..., '\w',''))/2 将所有匹配单词替换掉后，剩下的空格个数即为单词数量。/2 的原因如上所述。w+ 匹配的结果如下图所示。</li>
</ul> 
<p style="text-align:center"><img alt="" src="https://images2.imgbox.com/cb/8c/glRIxNFa_o.png"></p> 
<h1 id="%E5%9B%9B%E3%80%81%E4%B8%BB%E9%A2%98%E8%AF%8D%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%B8%8E%E7%BB%93%E6%9D%9F%E4%BD%8D%E7%BD%AE">四、主题词的起始与结束位置</h1> 
<p>        与锚位符 ^ 相似，简写式 A 匹配主题词的起始。要匹配主题词的结尾，可以使用 Z 或 z。 Z 和 z 之间的不同在于当遇到换行符时 Z 会将其看做字符串结尾匹配，而 z 只匹配字符串结尾。所谓主题词，简单但不严谨的理解就是将被测试字符串看成一个单一字符串，其首尾的单词。A Z z 不受回车、换行、空行的影响，因此与匹配模式无关。从下面的例子可以看到，即使使用多行模式，A 也不会匹配除首行外目标字符串。</p> 
<pre><code class="language-sql">mysql&gt; select regexp_like(
    -&gt; 'aaa
    '&gt; the bbb','\A\s*(THE|The|the)') m;
+---+
| m |
+---+
| 0 |
+---+
1 row in set (0.00 sec)

mysql&gt; select regexp_like(
    -&gt; 'aaa
    '&gt; the bbb','\A\s*(THE|The|the)','m') m;
+---+
| m |
+---+
| 0 |
+---+
1 row in set (0.00 sec)</code></pre> 
<p>        As*(THE|The|the) 匹配单词the出现在行首位置且之前有零个或多个空格。同样是这个正则表达式，测试表数据中可以匹配两行。</p> 
<pre><code class="language-sql">mysql&gt; select * from t_regexp where regexp_like(a,'\A\s*(THE|The|the)')G
*************************** 1. row ***************************
a: THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.
ARGUMENT.
How a Ship having passed the Line was driven by Storms to the cold Country
towards the South Pole; and how from thence she made her course to the tropical
Latitude of the Great Pacific Ocean; and of the strange things that befell;
and in what manner the Ancyent Marinere came back to his own Country.
I.
1       It is an ancyent Marinere,
2          And he stoppeth one of three:
3       "By thy long grey beard and thy glittering eye
4          "Now wherefore stoppest me?
*************************** 2. row ***************************
a: THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.
2 rows in set (0.00 sec)</code></pre> 
<p>        (MARINERE|Marinere)(.)?Z 会匹配一行（主题词）尾部的MARINERE或Marinere，之后是任何可选字符。在本例中可选字符就是标点符号或者字母S。点号两边的括号不是必需的。</p> 
<pre><code class="language-sql">mysql&gt; select * from t_regexp where regexp_like(a,'(MARINERE|Marinere)(.)?\Z');
+------------------------------------+
| a                                  |
+------------------------------------+
| 1       It is an ancyent Marinere, |
+------------------------------------+
1 row in set (0.00 sec)</code></pre> 
<p>        如果将 MARINERE|Marinere 换成 me，则可以匹配多行字符串的结尾。</p> 
<pre><code class="language-sql">mysql&gt; select * from t_regexp where regexp_like(a,'(me)(.)?\Z')G
*************************** 1. row ***************************
a: THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.
ARGUMENT.
How a Ship having passed the Line was driven by Storms to the cold Country
towards the South Pole; and how from thence she made her course to the tropical
Latitude of the Great Pacific Ocean; and of the strange things that befell;
and in what manner the Ancyent Marinere came back to his own Country.
I.
1       It is an ancyent Marinere,
2          And he stoppeth one of three:
3       "By thy long grey beard and thy glittering eye
4          "Now wherefore stoppest me?
*************************** 2. row ***************************
a: 4          "Now wherefore stoppest me?
2 rows in set (0.00 sec)</code></pre> 
<h1 id="%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8%E5%85%83%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E9%9D%A2%E5%80%BC">五、使用元字符的字面值</h1> 
<p>        可以用 Q 和 E 之间的字符集匹配字符串字面值。为了展示这一点，考虑如下字符串：</p> 
<pre><code class="language-sql">.^$*+?|(){}[]-</code></pre> 
<p>        这15个元字符在正则表达式中有特殊含义，用来编写匹配模式。连字符在字符组的方括号中用来表示范围，但在其他情况下无特殊含义。</p> 
<p>        在尝试匹配这些字符时，可能被MySQL判定为非法的正则表达式，但如果放在 Q 和 E 之间则会匹配字面值，因为Q和E之间的任意字符都会被解释为普通字符。当然也可以只用转义匹配字面值。</p> 
<pre><code class="language-sql">mysql&gt; select regexp_like('.^$*+?|(){}[]-','+');
ERROR 3688 (HY000): Syntax error in regular expression on line 1, character 1.
mysql&gt; select regexp_like('.^$*+?|(){}[]-','\Q+\E');
+------------------------------------------+
| regexp_like('.^$*+?|(){}[]-','\Q+\E') |
+------------------------------------------+
|                                        1 |
+------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; select regexp_like('.^$*+?|(){}[]-','\+');
+--------------------------------------+
| regexp_like('.^$*+?|(){}[]-','\+') |
+--------------------------------------+
|                                    1 |
+--------------------------------------+
1 row in set (0.00 sec)</code></pre> 
<h1 id="%E5%85%AD%E3%80%81%E5%9C%A8%E6%AE%B5%E9%A6%96%E5%8A%A0%E6%A0%87%E7%AD%BE">六、在段首加标签</h1> 
<p>        上篇中我们为每行文本加了标签，现在要在段首添加HTML标签。可以利用 A 的特性轻松实现。如前所述，无论是否使用多行模式，替换结果都一样。(\A.*) 捕获分组获取第一行，&lt;h1&gt;$1&lt;h1&gt; 在第一行首尾加标签。</p> 
<pre><code class="language-sql">mysql&gt; select regexp_replace(a,'(\A.*)','&lt;! DOCTYPE html&gt;n&lt;html lang="en"&gt;n&lt;head&gt;&lt;title&gt;Rime&lt;/title&gt;&lt;/head&gt;n&lt;body&gt;n&lt;h1&gt;$1&lt;h1&gt;') a
    -&gt;   from t_regexp
    -&gt;  where regexp_instr(a,'\n')G
*************************** 1. row ***************************
a: &lt;! DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;&lt;title&gt;Rime&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.&lt;h1&gt;
ARGUMENT.
How a Ship having passed the Line was driven by Storms to the cold Country
towards the South Pole; and how from thence she made her course to the tropical
Latitude of the Great Pacific Ocean; and of the strange things that befell;
and in what manner the Ancyent Marinere came back to his own Country.
I.
1       It is an ancyent Marinere,
2          And he stoppeth one of three:
3       "By thy long grey beard and thy glittering eye
4          "Now wherefore stoppest me?
1 row in set (0.00 sec)</code></pre> 
<p>        也可以将正则表达式改为 ^(.*)$ 匹配整行，然后只替换多行模式的第一行，能达到相同的效果。</p> 
<pre><code class="language-sql">mysql&gt; select regexp_replace(a,'^(.*)$','&lt;! DOCTYPE html&gt;n&lt;html lang="en"&gt;n&lt;head&gt;&lt;title&gt;Rime&lt;/title&gt;&lt;/head&gt;n&lt;body&gt;n&lt;h1&gt;$1&lt;h1&gt;',1,1,'m') a
    -&gt;   from t_regexp
    -&gt;  where regexp_instr(a,'\n')G
*************************** 1. row ***************************
a: &lt;! DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;&lt;title&gt;Rime&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.&lt;h1&gt;
ARGUMENT.
How a Ship having passed the Line was driven by Storms to the cold Country
towards the South Pole; and how from thence she made her course to the tropical
Latitude of the Great Pacific Ocean; and of the strange things that befell;
and in what manner the Ancyent Marinere came back to his own Country.
I.
1       It is an ancyent Marinere,
2          And he stoppeth one of three:
3       "By thy long grey beard and thy glittering eye
4          "Now wherefore stoppest me?
1 row in set (0.00 sec)</code></pre> 
<p>        用 sed 命令实现（rime.txt文件中为原文本内容）：</p> 
<pre><code class="language-bash">sed '1!b; i
&lt;! DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;title&gt;Rime&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
s/^/&lt;h1&gt;/
s/$/&lt;/h1&gt;/' rime.txt</code></pre> 
<p>        sed中的插入命令 i 允许在文件或字符串中的某个位置之前插入文本，1!b; 只替换第一行。</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>