<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>MySQL高级篇——索引的数据结构 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL高级篇——索引的数据结构</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <h1 id="main-toc"><strong>文章目录：</strong></h1> 
<p id="1.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F-toc" style="margin-left:0px"><a href="#1.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F">1.为什么使用索引？</a></p> 
<p id="2.%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:0px"><a href="#2.%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">2.索引的优缺点</a></p> 
<p id="3.InnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95-toc" style="margin-left:0px"><a href="#3.InnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95">3.InnoDB中的索引</a></p> 
<p id="3.1%20%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px"><a href="#3.1%20%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95">3.1 设计索引</a></p> 
<p id="3.2%20%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px"><a href="#3.2%20%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5">3.2 常见索引概念</a></p> 
<p id="3.2.1%20%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-toc" style="margin-left:80px"><a href="#3.2.1%20%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">3.2.1 聚簇索引</a></p> 
<p id="3.2.2%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-toc" style="margin-left:80px"><a href="#3.2.2%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">3.2.2 非聚簇索引</a></p> 
<p id="3.2.3%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-toc" style="margin-left:80px"><a href="#3.2.3%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95">3.2.3 联合索引</a></p> 
<p id="4.InnoDB%E4%B8%8EMyISAM%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94-toc" style="margin-left:0px"><a href="#4.InnoDB%E4%B8%8EMyISAM%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94">4.InnoDB与MyISAM的索引对比</a></p> 
<p id="5.B-Tree%E5%92%8CB%2BTree%E7%9A%84%E5%B7%AE%E5%BC%82-toc" style="margin-left:0px"><a href="#5.B-Tree%E5%92%8CB%2BTree%E7%9A%84%E5%B7%AE%E5%BC%82">5.B-Tree和B+Tree的差异</a></p> 
<hr id="hr-toc">
<h1>1.为什么使用索引？</h1> 
<p><img alt="" height="265" src="https://images2.imgbox.com/43/7e/caCK23zt_o.png" width="564"></p> 
<blockquote> 
 <div>
  <span style="color:#34495e">假如给数据使用 </span>
  <span style="color:#e96900">二叉树 </span>
  <span style="color:#34495e">这样的数据结构进行存储，如下图所示</span>
 </div> 
</blockquote> 
<p><img alt="" height="370" src="https://images2.imgbox.com/66/c7/vfxVkvss_o.png" width="606"></p> 
<hr>
<h1 id="2.%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">2.索引的优缺点</h1> 
<blockquote> 
 <div>
  <span style="color:#34495e">MySQL</span>
  <span style="color:#34495e">官方对索引的定义为：</span>
  <span style="color:#880000"><strong>索引（Index</strong></span>
  <span style="color:#880000"><strong>）是帮助</strong></span>
  <span style="color:#880000"><strong>MySQL</strong></span>
  <span style="color:#880000"><strong>高效获取数据的数据结构</strong></span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#880000"><strong>索引的本质：</strong></span>
  <span style="color:#34495e">索引是数据结构。你可以简单理解为</span>
  <span style="color:#34495e">“</span>
  <span style="color:#34495e">排好序的快速查找数据结构</span>
  <span style="color:#34495e">”</span>
  <span style="color:#34495e">，满足特定查找算法。 </span>
  <span style="color:#34495e">这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 </span>
  <span style="color:#e96900">高级查找算法 </span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div> 
  <div>
   <span style="color:#34495e"><strong>优点 </strong></span>
  </div> 
  <div></div> 
  <div>
   <span style="color:#34495e">（1</span>
   <span style="color:#34495e">）类似大学图书馆建书目索引，提高数据检索的效率，降低 </span>
   <span style="color:#e96900">数据库的</span>
   <span style="color:#e96900">IO</span>
   <span style="color:#e96900">成本 </span>
   <span style="color:#34495e">，这也是创建索引最主</span>
   <span style="color:#34495e">要的原因。 </span>
  </div> 
  <div>
   <span style="color:#34495e">（</span>
   <span style="color:#34495e">2</span>
   <span style="color:#34495e">）通过创建唯一索引，可以保证数据库表中每一行 </span>
   <span style="color:#e96900">数据的唯一性 </span>
   <span style="color:#34495e">。 </span>
  </div> 
  <div>
   <span style="color:#34495e">（</span>
   <span style="color:#34495e">3</span>
   <span style="color:#34495e">）在实现数据的</span>
   <span style="color:#34495e">参考完整性方面，可以 </span>
   <span style="color:#e96900">加速表和表之间的连接 </span>
   <span style="color:#34495e">。换句话说，对于有依赖关系的子表和父表联合查询时，</span>
   <span style="color:#34495e">可以提高查询速度。 </span>
  </div> 
  <div>
   <span style="color:#34495e">（</span>
   <span style="color:#34495e">4</span>
   <span style="color:#34495e">）在使用分组和排序子句进行数据查询时，可以显著 </span>
   <span style="color:#e96900">减少查询中分组和排序的时</span>
   <span style="color:#e96900">间 </span>
   <span style="color:#34495e">，降低了</span>
   <span style="color:#34495e">CPU</span>
   <span style="color:#34495e">的消耗。 </span>
  </div> 
  <div></div> 
  <div>
   <span style="color:#34495e"><strong>缺点 </strong></span>
  </div> 
  <div></div> 
  <div>
   <span style="color:#34495e">（</span>
   <span style="color:#34495e">1</span>
   <span style="color:#34495e">）创建索引和维护索引要 </span>
   <span style="color:#e96900">耗费时间 </span>
   <span style="color:#34495e">，并</span>
   <span style="color:#34495e">且随着数据量的增加，所耗费的时间也会增加。 </span>
  </div> 
  <div>
   <span style="color:#34495e">（</span>
   <span style="color:#34495e">2</span>
   <span style="color:#34495e">）索引需要占 </span>
   <span style="color:#e96900">磁盘空间 </span>
   <span style="color:#34495e">，除了数据表占数据空间之</span>
   <span style="color:#34495e">外，每一个索引还要占一定的物理空间， </span>
   <span style="color:#e96900">存储在磁盘上 </span>
   <span style="color:#34495e">，如果有大量的索引，索引文件就可能比数据文</span>
   <span style="color:#34495e">件更快达到最大文件尺寸。 </span>
  </div> 
  <div>
   <span style="color:#34495e">（</span>
   <span style="color:#34495e">3</span>
   <span style="color:#34495e">）虽然索引大大提高了查询速度，同时却会 </span>
   <span style="color:#e96900">降低更新表的速度 </span>
   <span style="color:#34495e">。当对表</span>
   <span style="color:#34495e">中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 </span>
  </div> 
  <div> 
   <hr>
   <p><span style="color:#34495e">索引是个好东西，可不能乱建，它在空间和时间上都会有消耗： </span></p> 
  </div> 
  <div> 
   <div>
    <span style="color:#880000"><strong>空间上的代价</strong></span>
    <span style="color:#34495e">：每建立一个索引都要为它建立一棵</span>
    <span style="color:#34495e">B+</span>
    <span style="color:#34495e">树，每一棵</span>
    <span style="color:#34495e">B+</span>
    <span style="color:#34495e">树的每一个节点都是一个数据页，一个页默认会</span>
    <span style="color:#34495e">占用 </span>
    <span style="color:#e96900">16KB </span>
    <span style="color:#34495e">的存储空间，一棵很大的</span>
    <span style="color:#34495e">B+</span>
    <span style="color:#34495e">树由许多数据页组成，那就是很大的一片存储空间。 </span>
   </div> 
   <div></div> 
   <div>
    <span style="color:#880000"><strong>时间上的代价：</strong></span>
    <span style="color:#34495e">每次对表中的数据进行 </span>
    <span style="color:#e96900">增、删、改 </span>
    <span style="color:#34495e">操作时，都需要去修改各个</span>
    <span style="color:#34495e">B+</span>
    <span style="color:#34495e">树索引。而且我们讲过，</span>
    <span style="color:#34495e">B+</span>
    <span style="color:#34495e">树每 </span>
    <span style="color:#34495e">层节点都是按照索引列的值 </span>
    <span style="color:#e96900">从小到大的顺序排序 </span>
    <span style="color:#34495e">而组成了 </span>
    <span style="color:#e96900">双向链表 </span>
    <span style="color:#34495e">。不论是叶子节点中的记录，还 </span>
    <span style="color:#34495e">是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序</span>
    <span style="color:#34495e">而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需</span>
    <span style="color:#34495e">要额外的时间进行一些 </span>
    <span style="color:#e96900">记录移位 </span>
    <span style="color:#34495e">， </span>
    <span style="color:#e96900">页面分裂 </span>
    <span style="color:#34495e">、 </span>
    <span style="color:#e96900">页面回收 </span>
    <span style="color:#34495e">等操作来维护好节点和记录的排序。如果</span>
    <span style="color:#34495e">我们建了许多索引，每个索引对应的</span>
    <span style="color:#34495e">B+</span>
    <span style="color:#34495e">树都要进行相关的维护操作，会给性能拖后腿。 </span>
   </div> 
  </div> 
 </div> 
</blockquote> 
<hr>
<h1 id="3.InnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95">3.InnoDB中的索引</h1> 
<blockquote> 
 <div>
  <span style="color:#34495e">在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 </span>
  <span style="color:#e96900">从第一个页 </span>
  <span style="color:#34495e">沿着 </span>
  <span style="color:#e96900">双向链表 </span>
  <span style="color:#34495e">一直往下找，在每一个页中根据我们上面的查找方式去查</span>
  <span style="color:#34495e">找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 </span>
  <span style="color:#e96900">超级耗时 </span>
  <span style="color:#34495e">的。如果一个表有一亿条记录 </span>
  <span style="color:#34495e">呢？此时 </span>
  <span style="color:#e96900">索引 </span>
  <span style="color:#34495e">应运而生。</span>
 </div> 
</blockquote> 
<h2 id="3.1%20%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95">3.1 设计索引</h2> 
<blockquote> 
 <p>先建一张表：</p> 
</blockquote> 
<pre><code class="language-sql">CREATE TABLE index_demo(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY(c1)
) ROW_FORMAT = Compact;</code></pre> 
<blockquote> 
 <div>
  <span style="color:#34495e">这个新建的 </span>
  <span style="color:#e96900">index_demo </span>
  <span style="color:#34495e">表中有</span>
  <span style="color:#34495e">2</span>
  <span style="color:#34495e">个</span>
  <span style="color:#34495e">INT</span>
  <span style="color:#34495e">类型的列，</span>
  <span style="color:#34495e">1</span>
  <span style="color:#34495e">个</span>
  <span style="color:#34495e">CHAR(1)</span>
  <span style="color:#34495e">类型的列，而且我们规定了</span>
  <span style="color:#34495e">c1</span>
  <span style="color:#34495e">列为主键，这个表使用 </span>
  <span style="color:#e96900">Compact </span>
  <span style="color:#34495e">行格式来实际存储记录的。这里我们简化了</span>
  <span style="color:#34495e">index_demo</span>
  <span style="color:#34495e">表的行格式示意图： </span>
 </div> 
</blockquote> 
<p><img alt="" height="424" src="https://images2.imgbox.com/99/1c/raSPi51L_o.png" width="808"></p> 
<blockquote> 
 <div>
  <span style="color:#34495e">我们只在示意图里展示记录的这几个部分： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#e96900">record_type </span>
  <span style="color:#34495e">：记录头信息的一项属性，表示记录的类型， </span>
  <span style="color:#e96900">0 </span>
  <span style="color:#34495e">表示普通记录、 </span>
  <span style="color:#e96900">2 </span>
  <span style="color:#34495e">表示最小记录、 </span>
  <span style="color:#e96900">3 </span>
  <span style="color:#34495e">表示最大记录、 </span>
  <span style="color:#e96900">1 </span>
  <span style="color:#34495e">暂时还没用过，下面讲。 </span>
 </div> 
 <div></div> 
 <span style="color:#e96900">next_record </span>
 <span style="color:#34495e">：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用</span>
 <span style="color:#34495e">箭头来表明下一条记录是谁。 </span> 
 <div></div> 
 <div>
  <span style="color:#e96900">各个列的值 </span>
  <span style="color:#34495e">：这里只记录在 </span>
  <span style="color:#e96900">index_demo </span>
  <span style="color:#34495e">表中的三个列，分别是 </span>
  <span style="color:#e96900">c1 </span>
  <span style="color:#34495e">、 </span>
  <span style="color:#e96900">c2 </span>
  <span style="color:#34495e">和 </span>
  <span style="color:#e96900">c3 </span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#e96900">其他信息 </span>
  <span style="color:#34495e">：除了上述</span>
  <span style="color:#34495e">3</span>
  <span style="color:#34495e">种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。 </span>
 </div> 
 <div></div> 
 <div> 
  <div>
   <span style="color:#34495e">把一些记录放到页里的示意图就是：</span>
  </div> 
 </div> 
</blockquote> 
<p><img alt="" height="474" src="https://images2.imgbox.com/2e/ff/r0YepiAg_o.png" width="819"></p> 
<blockquote> 
 <div>
  <span style="color:#34495e">我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规</span>
  <span style="color:#34495e">律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果</span>
  <span style="color:#34495e">我们 </span>
  <span style="color:#e96900">想快速的定位到需要查找的记录在哪些数据页 </span>
  <span style="color:#34495e">中该咋办？我们可以为快速定位记录所在的数据页而 </span>
  <span style="color:#e96900">建</span>
  <span style="color:#e96900">立一个目录 </span>
  <span style="color:#34495e">，建这个目录必须完成下边这些事： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#880000"><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。 </strong></span>
  <span style="color:#880000"><strong>给所有的页建立一个目录项。 </strong></span>
 </div> 
</blockquote> 
<p><img alt="" height="326" src="https://images2.imgbox.com/24/ba/akMPhCEy_o.png" width="794"></p> 
<blockquote> 
 <div>
  <span style="color:#34495e">以 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">28 </span>
  <span style="color:#34495e">为例，它对应 </span>
  <span style="color:#e96900">目录项</span>
  <span style="color:#e96900">2 </span>
  <span style="color:#34495e">，这个目录项中包含着该页的页号 </span>
  <span style="color:#e96900">28 </span>
  <span style="color:#34495e">以及该页中用户记录的最小主键值 </span>
  <span style="color:#e96900">5 </span>
  <span style="color:#34495e">。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键</span>
  <span style="color:#34495e">值快速查找某条记录的功能了。比如：查找主键值为 </span>
  <span style="color:#e96900">20 </span>
  <span style="color:#34495e">的记录，具体查找过程分两步： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">1. </span>
  <span style="color:#34495e">先从目录项中根据 </span>
  <span style="color:#e96900">二分法 </span>
  <span style="color:#34495e">快速确定出主键值为 </span>
  <span style="color:#e96900">20 </span>
  <span style="color:#34495e">的记录在 </span>
  <span style="color:#e96900">目录项</span>
  <span style="color:#e96900">3 </span>
  <span style="color:#34495e">中（因为 </span>
  <span style="color:#e96900">12 &lt; 20 &lt; </span>
  <span style="color:#e96900">209 </span>
  <span style="color:#34495e">），它对应的页是 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">9 </span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">2. </span>
  <span style="color:#34495e">再根据前边说的在页中查找记录的方式去 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">9 </span>
  <span style="color:#34495e">中定位具体的记录。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 </span>
  <span style="color:#e96900">索引 </span>
  <span style="color:#34495e">。 </span>
 </div> 
</blockquote> 
<blockquote> 
 <div>
  <span style="color:#34495e"><strong>迭代</strong></span>
  <span style="color:#34495e"><strong>1次：目录项纪录的页，</strong>我们把前边使用到的目录项放到数据页中的样子就是这样：</span>
 </div> 
</blockquote> 
<p><img alt="" height="421" src="https://images2.imgbox.com/30/5c/JWanlWR9_o.png" width="838"></p> 
<blockquote> 
 <div>
  <span style="color:#34495e">从图中可以看出来，我们新分配了一个编号为</span>
  <span style="color:#34495e">30</span>
  <span style="color:#34495e">的页来专门存储目录项记录。这里再次强调 </span>
  <span style="color:#e96900">目录项记录</span>
  <span style="color:#34495e"> 和普通的 </span>
  <span style="color:#e96900">用户记录 </span>
  <span style="color:#34495e">的</span>
  <span style="color:#880000"><strong>不同点</strong></span>
  <span style="color:#34495e">： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#e96900">目录项记录 </span>
  <span style="color:#34495e">的 </span>
  <span style="color:#e96900">record_type </span>
  <span style="color:#34495e">值是</span>
  <span style="color:#34495e">1</span>
  <span style="color:#34495e">，而 </span>
  <span style="color:#e96900">普通用户记录 </span>
  <span style="color:#34495e">的 </span>
  <span style="color:#e96900">record_type </span>
  <span style="color:#34495e">值是</span>
  <span style="color:#34495e">0</span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">目录项记录只有 </span>
  <span style="color:#e96900">主键值和页的编号 </span>
  <span style="color:#34495e">两个列，而普通的用户记录的列是用户自己定义的，可能包含 </span>
  <span style="color:#e96900">很</span>
  <span style="color:#e96900">多列 </span>
  <span style="color:#34495e">，另外还有</span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">自己添加的隐藏列。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">了解：记录头信息里还有一个叫 </span>
  <span style="color:#e96900">min_rec_mask </span>
  <span style="color:#34495e">的属性，只有在存储 </span>
  <span style="color:#e96900">目录项记录 </span>
  <span style="color:#34495e">的页中的主键值 </span>
  <span style="color:#34495e">最小的 </span>
  <span style="color:#e96900">目录项记录 </span>
  <span style="color:#34495e">的 </span>
  <span style="color:#e96900">min_rec_mask </span>
  <span style="color:#34495e">值为 </span>
  <span style="color:#e96900">1 </span>
  <span style="color:#34495e">，其他别的记录的 </span>
  <span style="color:#e96900">min_rec_mask </span>
  <span style="color:#34495e">值都是 </span>
  <span style="color:#e96900">0 </span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#880000"><strong>相同点：</strong></span>
  <span style="color:#34495e">两者用的是一样的数据页，都会为主键值生成 </span>
  <span style="color:#e96900">Page Directory </span>
  <span style="color:#34495e">（页目录），从而在按照主键值进行查找时可以使用 </span>
  <span style="color:#e96900">二分法 </span>
  <span style="color:#34495e">来加快查询速度。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">现在以查找主键为 </span>
  <span style="color:#e96900">20 </span>
  <span style="color:#34495e">的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">1. </span>
  <span style="color:#34495e">先到存储 </span>
  <span style="color:#e96900">目录项记录 </span>
  <span style="color:#34495e">的页，也就是页</span>
  <span style="color:#34495e">30</span>
  <span style="color:#34495e">中通过 </span>
  <span style="color:#e96900">二分法 </span>
  <span style="color:#34495e">快速定位到对应目录项，因为 </span>
  <span style="color:#e96900">12 &lt; 20 &lt; 209 </span>
  <span style="color:#34495e">，所以定位到对应的记录所在的页就是页</span>
  <span style="color:#34495e">9</span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">2. </span>
  <span style="color:#34495e">再到存储用户记录的页</span>
  <span style="color:#34495e">9</span>
  <span style="color:#34495e">中根据 </span>
  <span style="color:#e96900">二分法 </span>
  <span style="color:#34495e">快速定位到主键值为 </span>
  <span style="color:#e96900">20 </span>
  <span style="color:#34495e">的用户记录。</span>
 </div> 
</blockquote> 
<blockquote> 
 <div>
  <span style="color:#34495e"><strong>迭代</strong></span>
  <span style="color:#34495e"><strong>2</strong></span>
  <span style="color:#34495e"><strong>次：多个目录项纪录的页 </strong></span>
 </div> 
</blockquote> 
<p><img alt="" height="392" src="https://images2.imgbox.com/f5/1a/GVW2xQC4_o.png" width="862"></p> 
<blockquote> 
 <div>
  <span style="color:#34495e">从图中可以看出，我们插入了一条主键值为</span>
  <span style="color:#34495e">320</span>
  <span style="color:#34495e">的用户记录之后需要两个新的数据页： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">为存储该用户记录而新生成了 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">31 </span>
  <span style="color:#34495e">。 </span>
  <span style="color:#34495e">因为原先存储目录项记录的 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">30</span>
  <span style="color:#e96900">的容量已满 </span>
  <span style="color:#34495e">（我们前边假设只能存储</span>
  <span style="color:#34495e">4</span>
  <span style="color:#34495e">条目录项记录），所以不得</span>
  <span style="color:#34495e">不需要一个新的 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">32 </span>
  <span style="color:#34495e">来存放 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">31 </span>
  <span style="color:#34495e">对应的目录项。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要</span>
  <span style="color:#34495e">3</span>
  <span style="color:#34495e">个步</span>
  <span style="color:#34495e">骤，以查找主键值为 </span>
  <span style="color:#e96900">20 </span>
  <span style="color:#34495e">的记录为例： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">1. </span>
  <span style="color:#34495e">确定 </span>
  <span style="color:#e96900">目录项记录页 </span>
  <span style="color:#34495e">。我们现在的存储目录项记录的页有两个，即 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">30 </span>
  <span style="color:#34495e">和 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">32 </span>
  <span style="color:#34495e">，又因为页</span>
  <span style="color:#34495e">30</span>
  <span style="color:#34495e">表示的目录项的主键值的 </span>
  <span style="color:#34495e">范围是 </span>
  <span style="color:#e96900">[1, 320) </span>
  <span style="color:#34495e">，页</span>
  <span style="color:#34495e">32</span>
  <span style="color:#34495e">表示的目录项的主键值不小于 </span>
  <span style="color:#e96900">320 </span>
  <span style="color:#34495e">，所以主键值为 </span>
  <span style="color:#e96900">20 </span>
  <span style="color:#34495e">的记录对应的目</span>
  <span style="color:#34495e">录项记录在 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">30 </span>
  <span style="color:#34495e">中。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">2. </span>
  <span style="color:#34495e">通过目录项记录页 </span>
  <span style="color:#e96900">确定用户记录真实所在的页 </span>
  <span style="color:#34495e">。 </span>
  <span style="color:#34495e">在一个存储 </span>
  <span style="color:#e96900">目录项记录 </span>
  <span style="color:#34495e">的页中通过主键值定位一条目录项记录的方式说过了。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">3. </span>
  <span style="color:#34495e">在真实存储用户记录的页中定位到具体的记录。</span>
 </div> 
</blockquote> 
<blockquote> 
 <div>
  <span style="color:#34495e"><strong>迭代</strong></span>
  <span style="color:#34495e"><strong>3</strong></span>
  <span style="color:#34495e"><strong>次：目录项记录页的目录页</strong></span>
 </div> 
</blockquote> 
<p><img alt="" height="538" src="https://images2.imgbox.com/09/6c/0dFnF0lg_o.png" width="845"></p> 
<blockquote> 
 <div>
  <span style="color:#34495e">如图，我们生成了一个存储更高级目录项的 </span>
  <span style="color:#e96900">页</span>
  <span style="color:#e96900">33 </span>
  <span style="color:#34495e">，这个页中的两条记录分别代表页</span>
  <span style="color:#34495e">30</span>
  <span style="color:#34495e">和页</span>
  <span style="color:#34495e">32</span>
  <span style="color:#34495e">，如果用户记录的主键值在 </span>
  <span style="color:#e96900">[1, 320) </span>
  <span style="color:#34495e">之间，则到页</span>
  <span style="color:#34495e">30</span>
  <span style="color:#34495e">中查找更详细的目录项记录，如果主键值 </span>
  <span style="color:#e96900">不小于</span>
  <span style="color:#e96900">320 </span>
  <span style="color:#34495e">的</span>
  <span style="color:#34495e">话，就到页</span>
  <span style="color:#34495e">32</span>
  <span style="color:#34495e">中查找更详细的目录项记录。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">我们可以用下边这个图来描述它： </span>
 </div> 
</blockquote> 
<p><img alt="" height="440" src="https://images2.imgbox.com/d2/9d/GJvcHRdx_o.png" width="838"></p> 
<blockquote> 
 <div>
  <span style="color:#34495e">这个数据结构，它的名称是 </span>
  <span style="color:#e96900">B+</span>
  <span style="color:#e96900">树 </span>
  <span style="color:#34495e">。 </span>
 </div> 
</blockquote> 
<h2 id="3.2%20%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5">3.2 常见索引概念</h2> 
<blockquote> 
 <div>
  <span style="color:#34495e">索引按照物理实现方式，索引可以分为 </span>
  <span style="color:#34495e">2 </span>
  <span style="color:#34495e">种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。 </span>
 </div> 
</blockquote> 
<h3 id="3.2.1%20%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">3.2.1 聚簇索引</h3> 
<blockquote> 
 <div>
  <span style="color:#880000"><strong>特点： </strong></span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">1. </span>
  <span style="color:#34495e">使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#e96900">        页内 </span>
  <span style="color:#34495e">的记录是按照主键的大小顺序排成一个 </span>
  <span style="color:#e96900">单向链表 </span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">        各个存放 </span>
  <span style="color:#e96900">用户记录的页 </span>
  <span style="color:#34495e">也是根据页中用户记录的主键大小顺序排成一个 </span>
  <span style="color:#e96900">双向链表 </span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">        存放 </span>
  <span style="color:#e96900">目录项记录的页 </span>
  <span style="color:#34495e">分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键</span>
  <span style="color:#34495e">大小顺序排成一个 </span>
  <span style="color:#e96900">双向链表 </span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">2. B+</span>
  <span style="color:#34495e">树的 </span>
  <span style="color:#e96900">叶子节点 </span>
  <span style="color:#34495e">存储的是完整的用户记录。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">        所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#880000"><strong>优点： </strong></span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#e96900">        数据访问更快 </span>
  <span style="color:#34495e">，因为聚簇索引将索引和数据保存在同一个</span>
  <span style="color:#34495e">B+</span>
  <span style="color:#34495e">树中，因此从聚簇索引中获取数据比非聚簇索引更快 。</span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">        聚簇索引对于主键的 </span>
  <span style="color:#e96900">排序查找 </span>
  <span style="color:#34495e">和 </span>
  <span style="color:#e96900">范围查找 </span>
  <span style="color:#34495e">速度非常快 。</span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">        按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 </span>
  <span style="color:#e96900">节省了大量的</span>
  <span style="color:#e96900">io</span>
  <span style="color:#e96900">操作 </span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#880000"><strong>缺点： </strong></span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#e96900">        插入速度严重依赖于插入顺序 </span>
  <span style="color:#34495e">，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影</span>
  <span style="color:#34495e">响性能。因此，对于</span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">表，我们一般都会定义一个</span>
  <span style="color:#880000"><strong>自增的</strong></span>
  <span style="color:#880000"><strong>ID</strong></span>
  <span style="color:#880000"><strong>列为主键 。</strong></span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#e96900">        更新主键的代价很高 </span>
  <span style="color:#34495e">，因为将会导致被更新的行移动。因此，对于</span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">表，我们一般定义</span>
  <span style="color:#880000"><strong>主键为</strong></span>
  <span style="color:#880000"><strong>不可更新 。</strong></span>
 </div> 
 <div>
  <span style="color:#e96900">        </span>
 </div> 
 <div>
  <span style="color:#e96900">        二级索引访问需要两次索引查找 </span>
  <span style="color:#34495e">，第一次找到主键值，第二次根据主键值找到行数据。</span>
 </div> 
</blockquote> 
<h3 id="3.2.2%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">3.2.2 非聚簇索引</h3> 
<p><img alt="" height="487" src="https://images2.imgbox.com/b4/98/F3CIHbqe_o.png" width="840"></p> 
<blockquote> 
 <div>
  <span style="color:#880000"><strong>概念：回表 </strong></span>
  <span style="color:#34495e">我们根据这个以</span>
  <span style="color:#34495e">c2</span>
  <span style="color:#34495e">列大小排序的</span>
  <span style="color:#34495e">B+</span>
  <span style="color:#34495e">树只能确定我们要查找记录的主键值，所以如果我们想根据</span>
  <span style="color:#34495e">c2</span>
  <span style="color:#34495e">列的值查找到完整的用户记录的话，仍然需要到 </span>
  <span style="color:#e96900">聚簇索引 </span>
  <span style="color:#34495e">中再查一遍，这个过程称为 </span>
  <span style="color:#e96900">回表 </span>
  <span style="color:#34495e">。也就</span>
  <span style="color:#34495e">是根据</span>
  <span style="color:#34495e">c2</span>
  <span style="color:#34495e">列的值查询一条完整的用户记录需要使用到 </span>
  <span style="color:#e96900">2 </span>
  <span style="color:#34495e">棵</span>
  <span style="color:#34495e">B+</span>
  <span style="color:#34495e">树！ </span>
 </div> 
</blockquote> 
<h3 id="3.2.3%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95">3.2.3 联合索引</h3> 
<blockquote> 
 <div>
  <span style="color:#34495e">我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让</span>
  <span style="color:#34495e">B+</span>
  <span style="color:#34495e">树按照 </span>
  <span style="color:#e96900">c2</span>
  <span style="color:#e96900">和</span>
  <span style="color:#e96900">c3</span>
  <span style="color:#e96900">列 </span>
  <span style="color:#34495e">的大小进行排序，这个包含两层含义： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">先把各个记录和页按照</span>
  <span style="color:#34495e">c2</span>
  <span style="color:#34495e">列进行排序。 </span>
  <span style="color:#34495e">在记录的</span>
  <span style="color:#34495e">c2</span>
  <span style="color:#34495e">列相同的情况下，采用</span>
  <span style="color:#34495e">c3</span>
  <span style="color:#34495e">列进行排序 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">注意一点，以</span>
  <span style="color:#34495e">c2</span>
  <span style="color:#34495e">和</span>
  <span style="color:#34495e">c3</span>
  <span style="color:#34495e">列的大小为排序规则建立的</span>
  <span style="color:#34495e">B+</span>
  <span style="color:#34495e">树称为 </span>
  <span style="color:#e96900">联合索引 </span>
  <span style="color:#34495e">，本质上也是一个二级索引。它的意</span>
  <span style="color:#34495e">思与分别为</span>
  <span style="color:#34495e">c2</span>
  <span style="color:#34495e">和</span>
  <span style="color:#34495e">c3</span>
  <span style="color:#34495e">列分别建立索引的表述是不同的，不同点如下： </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">建立 </span>
  <span style="color:#e96900">联合索引 </span>
  <span style="color:#34495e">只会建立如上图一样的</span>
  <span style="color:#34495e">1</span>
  <span style="color:#34495e">棵</span>
  <span style="color:#34495e">B+</span>
  <span style="color:#34495e">树。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">为</span>
  <span style="color:#34495e">c2</span>
  <span style="color:#34495e">和</span>
  <span style="color:#34495e">c3</span>
  <span style="color:#34495e">列分别建立索引会分别以</span>
  <span style="color:#34495e">c2</span>
  <span style="color:#34495e">和</span>
  <span style="color:#34495e">c3</span>
  <span style="color:#34495e">列的大小为排序规则建立</span>
  <span style="color:#34495e">2</span>
  <span style="color:#34495e">棵</span>
  <span style="color:#34495e">B+</span>
  <span style="color:#34495e">树。 </span>
 </div> 
</blockquote> 
<hr>
<h1 id="4.InnoDB%E4%B8%8EMyISAM%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94">4.<span style="color:#34495e"><strong>InnoDB与MyISAM的索引</strong></span><span style="color:#34495e"><strong>对比 </strong></span>
</h1> 
<blockquote> 
 <div>
  <span style="color:#34495e">① 在</span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">存储引擎中，我们只需要根据主键值对 </span>
  <span style="color:#e96900">聚簇索引 </span>
  <span style="color:#34495e">进行一次查找就能找到对应的记录，而在</span>
  <span style="color:#e96900">MyISAM </span>
  <span style="color:#34495e">中却需要进行一次 </span>
  <span style="color:#e96900">回表 </span>
  <span style="color:#34495e">操作，意味着</span>
  <span style="color:#34495e">MyISAM</span>
  <span style="color:#34495e">中建立的索引相当于全部都是 </span>
  <span style="color:#e96900">二级索引 </span>
  <span style="color:#34495e">。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">② </span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">的数据文件本身就是索引文件，而</span>
  <span style="color:#34495e">MyISAM</span>
  <span style="color:#34495e">索引文件和数据文件是 </span>
  <span style="color:#e96900">分离的 </span>
  <span style="color:#34495e">，索引文件仅保存数</span>
  <span style="color:#34495e">据记录的地址。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">③ </span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">的非聚簇索引</span>
  <span style="color:#34495e">data</span>
  <span style="color:#34495e">域存储相应记录 </span>
  <span style="color:#e96900">主键的值 </span>
  <span style="color:#34495e">，而</span>
  <span style="color:#34495e">MyISAM</span>
  <span style="color:#34495e">索引记录的是 </span>
  <span style="color:#e96900">地址 </span>
  <span style="color:#34495e">。换句话说，</span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">的所有非聚簇索引都引用主键作为</span>
  <span style="color:#34495e">data</span>
  <span style="color:#34495e">域。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">④ </span>
  <span style="color:#34495e">MyISAM</span>
  <span style="color:#34495e">的回表操作是十分 </span>
  <span style="color:#e96900">快速 </span>
  <span style="color:#34495e">的，因为是拿着地址偏移量直接到文件中取数据的，反观</span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">是通</span>
  <span style="color:#34495e">过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。 </span>
 </div> 
 <div></div> 
 <div>
  <span style="color:#34495e">⑤ </span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">要求表 </span>
  <span style="color:#e96900">必须有主键 </span>
  <span style="color:#34495e">（ </span>
  <span style="color:#e96900">MyISAM</span>
  <span style="color:#e96900">可以没有 </span>
  <span style="color:#34495e">）。如果没有显式指定，则</span>
  <span style="color:#34495e">MySQL</span>
  <span style="color:#34495e">系统会自动选择一个</span>
  <span style="color:#34495e">可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则</span>
  <span style="color:#34495e">MySQL</span>
  <span style="color:#34495e">自动为</span>
  <span style="color:#34495e">InnoDB</span>
  <span style="color:#34495e">表生成一个隐</span>
  <span style="color:#34495e">含字段作为主键，这个字段长度为</span>
  <span style="color:#34495e">6</span>
  <span style="color:#34495e">个字节，类型为长整型。 </span>
 </div> 
</blockquote> 
<p><img alt="" height="431" src="https://images2.imgbox.com/1d/74/jy9E4lkd_o.png" width="599"></p> 
<hr>
<h1 id="5.B-Tree%E5%92%8CB%2BTree%E7%9A%84%E5%B7%AE%E5%BC%82">5.B-Tree和B+Tree的差异</h1> 
<blockquote> 
 <p>先来看看B-Tree</p> 
</blockquote> 
<p><img alt="" height="406" src="https://images2.imgbox.com/f4/cf/d27Iyu7w_o.png" width="860"></p> 
<blockquote> 
 <p>再来看看B+Tree</p> 
</blockquote> 
<p><img alt="" height="538" src="https://images2.imgbox.com/09/6c/0dFnF0lg_o.png" width="845"></p> 
<blockquote> 
 <div>
  <strong><span style="color:#34495e">1. </span><span style="color:#34495e">B+树 有 </span><span style="color:#34495e">k </span><span style="color:#34495e">个孩子的节点就有 </span><span style="color:#34495e">k </span><span style="color:#34495e">个关键字，也就是孩子数量 </span><span style="color:#34495e">= </span><span style="color:#34495e">关键字数；而 </span><span style="color:#34495e">B </span><span style="color:#34495e">树中，孩子数量 </span><span style="color:#34495e">= </span><span style="color:#34495e">关键字数 +1</span><span style="color:#34495e">。</span></strong>
 </div> 
 <div></div> 
 <div>
  <strong><span style="color:#34495e">2. B+树 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）（比如在页30中的1和5，分别也在页10、页28中出现了）；而B树并不具备这样的特征。</span></strong>
 </div> 
 <div></div> 
 <div>
  <strong><span style="color:#34495e">3. B+树 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中；而 </span><span style="color:#34495e">B </span><span style="color:#34495e">树中， </span><span style="color:#e96900">非叶子节点既保存索引，也保存数据记录 </span><span style="color:#34495e">。 </span></strong>
 </div> 
 <div></div> 
 <div>
  <strong><span style="color:#34495e">4. B+树 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。（要想获取从小到大的结果序列，只需依次查找叶子节点即可）；而B树则必须进行中序遍历才可以（也就是图中的3、5、8、9、10、12，这种左根右的方式）。</span></strong>
 </div> 
</blockquote> 
<p><img alt="" height="292" src="https://images2.imgbox.com/97/ba/uFMnFWKZ_o.png" width="994"></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>