<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>分组密码算法AES的C/C&#43;&#43;编程实现 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分组密码算法AES的C/C&#43;&#43;编程实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify">AES原理概述与算法分析：</p> 
<p style="margin-left:.0001pt;text-align:justify">AES属于分组加密算法，明文长度固定为128bit，密钥长度可以是128/192/256 bit，此实验分析并编码密钥为128bit的AES算法。</p> 
<p style="margin-left:.0001pt;text-align:justify">AES加密过程先是明文经过初始化变换，其次再经过九轮循环运算，每一次循环运算都要依次进行字节代换、行移位、列混合和轮密钥加，九轮循环运算结束后，再进行一次最终轮运算，这一轮与前面的九轮的区别除了不进行列混合，其余的不变，也即是最后一轮依次进行字节代换、行移位和轮密钥加，经过这一步骤得到的即为密文。</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="308" src="https://images2.imgbox.com/83/bd/A60ivvNd_o.png" width="497"></p> 
<p style="margin-left:.0001pt;text-align:justify">     图1.AES加密过程</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">了解到整个AES的加密过程，再进一步深入分析一下各个环节的步骤。</p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><strong>初始变换</strong></strong>：输入的明文矩阵与子密钥矩阵进行按字节的异或操作，得到的结果就是初始变换后的结果。</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="226" src="https://images2.imgbox.com/6e/79/nd6UKeH9_o.png" width="546"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">  图2.  16字节数据的矩阵排列方式</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="309" src="https://images2.imgbox.com/25/3d/G5KTq2ra_o.png" width="445"></p> 
<p>        图3. 初始变换</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><strong>字节代换</strong></strong>：把4*4的矩阵通过查表进行代换，如39，即查找S盒第三行第九列的数字，将该数字替换39.</p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><strong>行移位</strong></strong>：如图4所示</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="127" src="https://images2.imgbox.com/3f/1f/72dnnug9_o.png" width="633"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">             4. 行移位</p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><strong>列混合</strong></strong>：将输入的4*4的矩阵左乘一个给定的4*4矩阵，不过不是简单的矩阵乘法运算，是在域上的运算。具体过程如下图6、7所示。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="154" src="https://images2.imgbox.com/14/dd/T8IzRbro_o.png" width="467"></p> 
<p style="margin-left:.0001pt;text-align:justify">图5.列混合</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="218" src="https://images2.imgbox.com/1f/16/xRVdY2PX_o.png" width="554"></p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/76/51/XDUCZt4d_o.png" width="555"></p> 
<p>图6</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><strong>轮密钥加</strong></strong>：将得到的结果与子密钥矩阵异或，一列一列逐次异或。</p> 
<p style="margin-left:.0001pt;text-align:justify">然而开始时只有一个16字节的子密钥，是怎么生成10轮16字节的子密钥的呢？因此，接下来分析子密钥矩阵的扩展过程<strong><strong>。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><strong>子密钥矩阵的扩展过程：</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify">AES的密钥扩展的目的是将输入的128位密钥扩展成11个128位的子密钥。</p> 
<p style="margin-left:.0001pt;text-align:justify">密钥扩展过程说明：将初始密钥以列为主，转化为4个32bits的字，分别记为w[0，1,2，3]；按照如下方式，依次求解w[i]，其中i是整数并且属于[4,43]。</p> 
<p style="margin-left:.0001pt;text-align:justify">   当i%4!=0时，w[i]=w[i-4]⊕w[i-1]</p> 
<p style="margin-left:.0001pt;text-align:justify">   当i%4=0时，将w[i-1]循环左移一个字节，分别对每个字节按S盒进行映射。与轮常量Rcon（Rc[i/4],0,0,0）进行异或，RC是一个一维数组，其中RC = {01, 02, 04, 08, 10, 20, 40, 80, 1B, 36}。最后再和w[i-1]进行异或。</p> 
<p style="margin-left:.0001pt;text-align:justify">解密过程是加密的逆过程，如图7所示。</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="571" src="https://images2.imgbox.com/55/f5/9sHu07a9_o.png" width="480"></p> 
<p style="margin-left:.0001pt;text-align:justify">                                 图7 AES解密</p> 
<p style="margin-left:.0001pt;text-align:justify">其中逆字节代换是在逆S盒中实现的，而逆列混合中左乘的是。</p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><strong>总结：</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify">AES算法是一种对称密码，但是这一次的对称密码比以往的实验都要复杂的多，我们在这一次实验上也花了很多的时间。</p> 
<p style="margin-left:.0001pt;text-align:justify">AES算法主要由四个不同的变换组成，包括一个置换和三个替代：字节代替，用一个S盒完成分组的字节到字节的代替；行移位，一个比较简单的置换；列混淆，利用域GF(28)上的算术特性的一个代替；轮密钥加，当前分组和扩展密钥的一部分进行按位XOR(异或)。</p> 
<p style="margin-left:.0001pt;text-align:justify">我觉得这次实验最难的一个功能模块是列混淆。因为首先列混淆的乘法不是一般的乘法，而是x乘法，即GF（2^8）上的乘法。其次这个模块涉及到矩阵运算，我们知道矩阵运算是比较复杂，比较麻烦的。该运算可以通过字节的左移一位（最后一位补0）,b7=0则再与0x1B做逐比特异或来实现；若是遇到形如0x3A*0x03，则可将0x03拆成0x01异或0x02与0x3A分别相乘再进行异或。</p> 
<p style="margin-left:.0001pt;text-align:justify">好在本次实验矩阵的大小是4*4固定的，而且课程PPT中还给出了推导后的矩阵计算公式，使得我们不必要真的去写一个x乘法矩阵运算，只需要套用一堆固定的公式，这带来了一定程度上的方便，其中还要注意矩阵行、列计算的转换，所以还是很复杂的，很考验逻辑思维能力。</p> 
<p style="margin-left:.0001pt;text-align:justify">实验过程中，意识到要实现完整地AES流程是相对十分复杂的，需要提前对密钥进行密钥扩展，将明文转化成十六进制变为矩阵，加密过程中，先用初始密钥进行异或，再做九轮字节代换、行移位、列混合；最后再进行一轮字节代换、行移位的加密，加密系数高；解密过程类似，但密钥的选取倒逆选取。</p> 
<p style="margin-left:.0001pt;text-align:justify"><strong><strong>个人感悟与收获：</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify">通过这次对AES算法的代码编写，之前上课时听得不太明白的地方豁然开朗了。开始时确实是不知道从何下手，然后和队友一起讨论，两个人查阅相关的资料。每次弄懂一个知识点的时候，都不由地感叹算法的精妙。</p> 
<p style="margin-left:.0001pt;text-align:justify">这次实验课收获很大，不仅懂得了AES算法的核心思想，对密码学这门课也有了一定的认识，不再像之前那样毫无头绪了，对密码学也开始产生兴趣，不由地想要探索更多的知识。</p> 
<p style="margin-left:.0001pt;text-align:justify">经过这次实验，感觉自己对AES算法的理解、对字符字节的控制上都有所进步，收获良多。</p> 
<p style="margin-left:.0001pt;text-align:justify">本实验难度较大，涉及到诸多运算。但在此过程中亦收获满满。比如，了解到十六进制的x运算，该运算可以通过字节的左移一位（最后一位补0）,b7=0则再与0x1B做逐比特异或来实现；若是遇到形如0x3A*0x03，则可将0x03拆成0x010x02与0x3A分别相乘再进行异或。实验过程中，意识到要实现完整地AES流程是相对十分复杂的，要提前对密钥进行密钥扩展，将明文转化成十六进制变为矩阵，加密过程中，先用初始密钥进行异或，再做九轮字节代换、行移位、列混合；最后再进行一轮字节代换、行移位的加密，加密系数高；解密过程类似，但密钥的选取倒逆选取。</p> 
<p style="margin-left:.0001pt;text-align:justify">代码如下：（实验环境：Visual  C++ 6.0）</p> 
<p style="margin-left:.0001pt;text-align:justify">#include &lt;stdio.h&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify">#pragma warning(disable:4996)</p> 
<p style="margin-left:.0001pt;text-align:justify"> //定义轮常量表</p> 
<p style="margin-left:.0001pt;text-align:justify">static const unsigned char Rcon[10] = {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36 };</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义有限域*2乘法</p> 
<p style="margin-left:.0001pt;text-align:justify">static unsigned char x2time(unsigned char x)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">if (x &amp; 0x80)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">return (((x &lt;&lt; 1) ^ 0x1B) &amp; 0xFF);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">return x &lt;&lt; 1;</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义有限域*3乘法</p> 
<p style="margin-left:.0001pt;text-align:justify">static unsigned char x3time(unsigned char x)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">return (x2time(x) ^ x);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义有限域*4乘法</p> 
<p style="margin-left:.0001pt;text-align:justify">static unsigned char x4time(unsigned char x)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">return (x2time(x2time(x)));</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义有限域*8乘法</p> 
<p style="margin-left:.0001pt;text-align:justify">static unsigned char x8time(unsigned char x)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">return (x2time(x2time(x2time(x))));</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义有限域*9乘法</p> 
<p style="margin-left:.0001pt;text-align:justify">static unsigned char x9time(unsigned char x)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">return (x8time(x) ^ x);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义有限域*B乘法</p> 
<p style="margin-left:.0001pt;text-align:justify">static unsigned char xBtime(unsigned char x)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">return (x8time(x) ^ x2time(x) ^ x);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义有限域*D乘法</p> 
<p style="margin-left:.0001pt;text-align:justify">static unsigned char xDtime(unsigned char x)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">return (x8time(x) ^ x4time(x) ^ x);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义有限域*E乘法</p> 
<p style="margin-left:.0001pt;text-align:justify">static unsigned char xEtime(unsigned char x)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">return (x8time(x) ^ x4time(x) ^ x2time(x));</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//s盒矩阵 Substitution Table</p> 
<p style="margin-left:.0001pt;text-align:justify">static const unsigned char sbox[256] = {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16,</p> 
<p style="margin-left:.0001pt;text-align:justify">};</p> 
<p style="margin-left:.0001pt;text-align:justify">//逆向S盒矩阵</p> 
<p style="margin-left:.0001pt;text-align:justify">static const unsigned char contrary_sbox[256] = {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,</p> 
<p style="margin-left:.0001pt;text-align:justify">0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,</p> 
<p style="margin-left:.0001pt;text-align:justify">0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d,</p> 
<p style="margin-left:.0001pt;text-align:justify">};</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义s盒字节代换替换操作</p> 
<p style="margin-left:.0001pt;text-align:justify">static void SubBytes(unsigned char* col)</p> 
<p style="margin-left:.0001pt;text-align:justify">{//字节代换</p> 
<p style="margin-left:.0001pt;text-align:justify">int x;</p> 
<p style="margin-left:.0001pt;text-align:justify">for (x = 0; x &lt; 16; x++)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">col[x] = sbox[col[x]];</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//逆向字节代换</p> 
<p style="margin-left:.0001pt;text-align:justify">static void Contrary_SubBytes(unsigned char* col)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">int x;</p> 
<p style="margin-left:.0001pt;text-align:justify">for (x = 0; x &lt; 16; x++)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">col[x] = contrary_sbox[col[x]];</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义行移位操作：行左循环移位</p> 
<p style="margin-left:.0001pt;text-align:justify">static void ShiftRows(unsigned char* col)</p> 
<p style="margin-left:.0001pt;text-align:justify">{//正向行移位</p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char t;</p> 
<p style="margin-left:.0001pt;text-align:justify">//左移1位</p> 
<p style="margin-left:.0001pt;text-align:justify">t = col[1]; col[1] = col[5]; col[5] = col[9]; col[9] = col[13]; col[13] = t;</p> 
<p style="margin-left:.0001pt;text-align:justify">//左移2位，交换2次数字来实现</p> 
<p style="margin-left:.0001pt;text-align:justify">t = col[2]; col[2] = col[10]; col[10] = t;</p> 
<p style="margin-left:.0001pt;text-align:justify">t = col[6]; col[6] = col[14]; col[14] = t;</p> 
<p style="margin-left:.0001pt;text-align:justify">//左移3位，相当于右移1次</p> 
<p style="margin-left:.0001pt;text-align:justify">t = col[15]; col[15] = col[11]; col[11] = col[7]; col[7] = col[3]; col[3] = t;</p> 
<p style="margin-left:.0001pt;text-align:justify">//第4行不移位</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//逆向行移位</p> 
<p style="margin-left:.0001pt;text-align:justify">static void Contrary_ShiftRows(unsigned char* col)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char t;</p> 
<p style="margin-left:.0001pt;text-align:justify">t = col[13]; col[13] = col[9]; col[9] = col[5]; col[5] = col[1]; col[1] = t;</p> 
<p style="margin-left:.0001pt;text-align:justify">t = col[2]; col[2] = col[10]; col[10] = t;</p> 
<p style="margin-left:.0001pt;text-align:justify">t = col[6]; col[6] = col[14]; col[14] = t;</p> 
<p style="margin-left:.0001pt;text-align:justify">t = col[3]; col[3] = col[7]; col[7] = col[11]; col[11] = col[15]; col[15] = t;</p> 
<p style="margin-left:.0001pt;text-align:justify">//同理，第4行不移位</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义列混合操作</p> 
<p style="margin-left:.0001pt;text-align:justify">static void MixColumns(unsigned char* col)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char tmp[4], xt[4];</p> 
<p style="margin-left:.0001pt;text-align:justify">int i;</p> 
<p style="margin-left:.0001pt;text-align:justify">for (i = 0; i &lt; 4; i++, col += 4)</p> 
<p style="margin-left:.0001pt;text-align:justify">{  //col代表一列的基地址，col+4:下一列的基地址</p> 
<p style="margin-left:.0001pt;text-align:justify">//xt[n]代表*2   xt[n]^col[n]代表*3   col[n]代表*1</p> 
<p style="margin-left:.0001pt;text-align:justify">tmp[0] = x2time(col[0]) ^ x3time(col[1]) ^ col[2] ^ col[3]; //2 3 1 1</p> 
<p style="margin-left:.0001pt;text-align:justify">tmp[1] = col[0] ^ x2time(col[1]) ^ x3time(col[2]) ^ col[3]; //1 2 3 1</p> 
<p style="margin-left:.0001pt;text-align:justify">tmp[2] = col[0] ^ col[1] ^ x2time(col[2]) ^ x3time(col[3]); //1 1 2 3</p> 
<p style="margin-left:.0001pt;text-align:justify">tmp[3] = x3time(col[0]) ^ col[1] ^ col[2] ^ x2time(col[3]); //3 1 1 2</p> 
<p style="margin-left:.0001pt;text-align:justify">//修改后的值 直接在原矩阵上修改</p> 
<p style="margin-left:.0001pt;text-align:justify">col[0] = tmp[0];</p> 
<p style="margin-left:.0001pt;text-align:justify">col[1] = tmp[1];</p> 
<p style="margin-left:.0001pt;text-align:justify">col[2] = tmp[2];</p> 
<p style="margin-left:.0001pt;text-align:justify">col[3] = tmp[3];</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义逆向列混淆</p> 
<p style="margin-left:.0001pt;text-align:justify">static void Contrary_MixColumns(unsigned char* col)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char tmp[4];</p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char xt2[4];//colx2</p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char xt4[4];//colx4</p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char xt8[4];//colx8</p> 
<p style="margin-left:.0001pt;text-align:justify">int x;</p> 
<p style="margin-left:.0001pt;text-align:justify">for (x = 0; x &lt; 4; x++, col += 4)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">tmp[0] = xEtime(col[0]) ^ xBtime(col[1]) ^ xDtime(col[2]) ^ x9time(col[3]);</p> 
<p style="margin-left:.0001pt;text-align:justify">tmp[1] = x9time(col[0]) ^ xEtime(col[1]) ^ xBtime(col[2]) ^ xDtime(col[3]);</p> 
<p style="margin-left:.0001pt;text-align:justify">tmp[2] = xDtime(col[0]) ^ x9time(col[1]) ^ xEtime(col[2]) ^ xBtime(col[3]);</p> 
<p style="margin-left:.0001pt;text-align:justify">tmp[3] = xBtime(col[0]) ^ xDtime(col[1]) ^ x9time(col[2]) ^ xEtime(col[3]);</p> 
<p style="margin-left:.0001pt;text-align:justify">col[0] = tmp[0];</p> 
<p style="margin-left:.0001pt;text-align:justify">col[1] = tmp[1];</p> 
<p style="margin-left:.0001pt;text-align:justify">col[2] = tmp[2];</p> 
<p style="margin-left:.0001pt;text-align:justify">col[3] = tmp[3];</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//密钥编排，16字节---&gt;44列32bit密钥生成--&gt; 11组16字节:分别用于11轮 轮密钥加运算</p> 
<p style="margin-left:.0001pt;text-align:justify">void ScheduleKey(unsigned char* inkey, unsigned char* outkey, int Nk, int Nr)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">//inkey:初始16字节密钥key</p> 
<p style="margin-left:.0001pt;text-align:justify">//outkey：11组*16字节扩展密钥expansionkey</p> 
<p style="margin-left:.0001pt;text-align:justify">//Nk：4列</p> 
<p style="margin-left:.0001pt;text-align:justify">//Nr：10轮round</p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char temp[4], t;</p> 
<p style="margin-left:.0001pt;text-align:justify">int x, i;</p> 
<p style="margin-left:.0001pt;text-align:justify">/*copy the key*/</p> 
<p style="margin-left:.0001pt;text-align:justify">//第0组：[0-3]直接拷贝</p> 
<p style="margin-left:.0001pt;text-align:justify">for (i = 0; i &lt; (4 * Nk); i++)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">outkey[i] = inkey[i];</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//第1-10组：[4-43]</p> 
<p style="margin-left:.0001pt;text-align:justify">i = Nk;</p> 
<p style="margin-left:.0001pt;text-align:justify">while (i &lt; (4 * (Nr + 1))) //i=4~43 WORD 32bit的首字节地址，每一个4字节</p> 
<p style="margin-left:.0001pt;text-align:justify">{//1次循环生成1个字节扩展密钥，4次循环生成一个WORD</p> 
<p style="margin-left:.0001pt;text-align:justify">//temp：4字节数组：代表一个WORD密钥</p> 
<p style="margin-left:.0001pt;text-align:justify">//i不是4的倍数的时候</p> 
<p style="margin-left:.0001pt;text-align:justify">//每个temp = 每个outkey32bit = 4字节</p> 
<p style="margin-left:.0001pt;text-align:justify">for (x = 0; x &lt; 4; x++)</p> 
<p style="margin-left:.0001pt;text-align:justify">temp[x] = outkey[(4 * (i - 1)) + x]; //i：32bit的首字节地址</p> 
<p style="margin-left:.0001pt;text-align:justify">//i是4的倍数的时候</p> 
<p style="margin-left:.0001pt;text-align:justify">if (i % Nk == 0)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">/*字循环：循环左移1字节 RotWord()*/</p> 
<p style="margin-left:.0001pt;text-align:justify">t = temp[0]; temp[0] = temp[1]; temp[1] = temp[2]; temp[2] = temp[3]; temp[3] = t;</p> 
<p style="margin-left:.0001pt;text-align:justify">/*字节代换：SubWord()*/</p> 
<p style="margin-left:.0001pt;text-align:justify">for (x = 0; x &lt; 4; x++)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">temp[x] = sbox[temp[x]];</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">/*轮常量异或：Rcon[j]*/</p> 
<p style="margin-left:.0001pt;text-align:justify">temp[0] ^= Rcon[(i / Nk) - 1];</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">for (x = 0; x &lt; 4; x++)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">outkey[(4 * i) + x] = outkey[(4 * (i - Nk)) + x] ^ temp[x];</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">++i;</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义轮密钥加操作</p> 
<p style="margin-left:.0001pt;text-align:justify">static void AddRoundKey(unsigned char* col, unsigned char* expansionkey, int round)//密匙加</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">//扩展密钥：44*32bit =11*4* 4*8 =  16字节*11轮，每轮用16字节密钥</p> 
<p style="margin-left:.0001pt;text-align:justify">//第0轮，只进行一次轮密钥加</p> 
<p style="margin-left:.0001pt;text-align:justify">//第1-10轮，轮密钥加</p> 
<p style="margin-left:.0001pt;text-align:justify">int x;</p> 
<p style="margin-left:.0001pt;text-align:justify">for (x = 0; x &lt; 16; x++)</p> 
<p style="margin-left:.0001pt;text-align:justify">{ //每1轮操作：4*32bit密钥 = 16个字节密钥</p> 
<p style="margin-left:.0001pt;text-align:justify">col[x] ^= expansionkey[(round &lt;&lt; 4) + x];</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//AES加密函数</p> 
<p style="margin-left:.0001pt;text-align:justify">void AesEncrypt(unsigned char* blk, unsigned char* expansionkey, int Nr)</p> 
<p style="margin-left:.0001pt;text-align:justify">{//加密一个区块</p> 
<p style="margin-left:.0001pt;text-align:justify">//输入blk原文，直接在上面修改，输出blk密文</p> 
<p style="margin-left:.0001pt;text-align:justify">//输入skey：</p> 
<p style="margin-left:.0001pt;text-align:justify">//输入Nr = 10轮</p> 
<p style="margin-left:.0001pt;text-align:justify">int round;</p> 
<p style="margin-left:.0001pt;text-align:justify">//第1轮之前：轮密钥加</p> 
<p style="margin-left:.0001pt;text-align:justify">AddRoundKey(blk, expansionkey, 0);//密钥已经到位</p> 
<p style="margin-left:.0001pt;text-align:justify">//第1-9轮：4类操作：字节代换、行移位、列混合、轮密钥加</p> 
<p style="margin-left:.0001pt;text-align:justify">for (round = 1; round &lt;= (Nr - 1); round++)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">SubBytes(blk); //输入16字节数组，直接在原数组上修改</p> 
<p style="margin-left:.0001pt;text-align:justify">ShiftRows(blk); //输入16字节数组，直接在原数组上修改</p> 
<p style="margin-left:.0001pt;text-align:justify">MixColumns(blk); //输入16字节数组，直接在原数组上修改</p> 
<p style="margin-left:.0001pt;text-align:justify">AddRoundKey(blk, expansionkey, round);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//第10轮：不进行列混合</p> 
<p style="margin-left:.0001pt;text-align:justify">SubBytes(blk);</p> 
<p style="margin-left:.0001pt;text-align:justify">ShiftRows(blk);</p> 
<p style="margin-left:.0001pt;text-align:justify">AddRoundKey(blk, expansionkey, Nr);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">//AES 解密函数</p> 
<p style="margin-left:.0001pt;text-align:justify">void Contrary_AesEncrypt(unsigned char* blk, unsigned char* expansionkey, int Nr)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">int x;</p> 
<p style="margin-left:.0001pt;text-align:justify">AddRoundKey(blk, expansionkey, Nr);</p> 
<p style="margin-left:.0001pt;text-align:justify">Contrary_ShiftRows(blk);</p> 
<p style="margin-left:.0001pt;text-align:justify">Contrary_SubBytes(blk);</p> 
<p style="margin-left:.0001pt;text-align:justify">for (x = (Nr - 1); x &gt;= 1; x--)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">AddRoundKey(blk, expansionkey, x);</p> 
<p style="margin-left:.0001pt;text-align:justify">Contrary_MixColumns(blk);</p> 
<p style="margin-left:.0001pt;text-align:justify">Contrary_ShiftRows(blk);</p> 
<p style="margin-left:.0001pt;text-align:justify">Contrary_SubBytes(blk);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">AddRoundKey(blk, expansionkey, 0);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">int main(void) {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char pt[17], key[17];</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义原文pt</p> 
<p style="margin-left:.0001pt;text-align:justify">//定义密钥key</p> 
<p style="margin-left:.0001pt;text-align:justify">unsigned char expansionkey[15 * 16];</p> 
<p style="margin-left:.0001pt;text-align:justify">int i;</p> 
<p style="margin-left:.0001pt;text-align:justify">int j;</p> 
<p style="margin-left:.0001pt;text-align:justify">printf("You are welcome to use the AES machine in SDUn");</p> 
<p style="margin-left:.0001pt;text-align:justify">printf("Please enter plaintext (length = 16):n");</p> 
<p style="margin-left:.0001pt;text-align:justify">scanf("%s", pt);</p> 
<p style="margin-left:.0001pt;text-align:justify">printf("please input key：n");</p> 
<p style="margin-left:.0001pt;text-align:justify">scanf("%s", key);</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">//加密过程</p> 
<p style="margin-left:.0001pt;text-align:justify">ScheduleKey(key, expansionkey, 4, 10);//密钥扩展生成</p> 
<p style="margin-left:.0001pt;text-align:justify">AesEncrypt(pt, expansionkey, 10);//调用AES 加密</p> 
<p style="margin-left:.0001pt;text-align:justify">printf("ciphertext: ");</p> 
<p style="margin-left:.0001pt;text-align:justify">//输出密文</p> 
<p style="margin-left:.0001pt;text-align:justify">for (i = 0; i &lt; 16; i++)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">printf("%02x ", pt[i]);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">printf("n");</p> 
<p style="margin-left:.0001pt;text-align:justify">printf("n");</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">//解密过程</p> 
<p style="margin-left:.0001pt;text-align:justify">Contrary_AesEncrypt(pt, expansionkey, 10);//调用AES 解密</p> 
<p style="margin-left:.0001pt;text-align:justify">printf("The decrypted plaintext is: ");</p> 
<p style="margin-left:.0001pt;text-align:justify">//输出明文</p> 
<p style="margin-left:.0001pt;text-align:justify">for (i = 0; i &lt; 16; i++)</p> 
<p style="margin-left:.0001pt;text-align:justify">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify">printf("%c ", pt[i]);</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify">printf("n");</p> 
<p style="margin-left:.0001pt;text-align:justify">printf("n");</p> 
<p style="margin-left:.0001pt;text-align:justify">while (1);</p> 
<p style="margin-left:.0001pt;text-align:justify">return 0;</p> 
<p style="margin-left:.0001pt;text-align:justify">}</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="288" src="https://images2.imgbox.com/7e/8d/YlwvcvGC_o.png" width="786"></p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="207" src="https://images2.imgbox.com/ab/7a/GvGbNdh8_o.png" width="758"></p> 
<p> 部分图片来源于网络，若有侵权请联系删除。如有疑问，欢迎私信。</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>