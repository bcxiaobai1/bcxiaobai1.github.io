<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>嵌入式工程师面试知识总结 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式工程师面试知识总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-github-gist">
                    
                        
                    
                    <h1>
<a id="CC_0"></a>C/C++语言</h1> 
<h2>
<a id="_2"></a>指针</h2> 
<h3>
<a id="1_______4"></a>1. 数组指针 与 指针数组，函数指针 与 指针函数 区别？</h3> 
<p>答：<br> <strong>函数指针</strong>指向函数的指针变量，即本质是一个变量。<br> <strong>指针函数</strong>是指返回值是指针的函数，即本质是一个函数。<br> <strong>数组指针</strong>是指向数组首元素的地址的指针，其本质为指针。（这个指针存放的是数组首地址的地址，相当于2级指针，这个指针不可移动）<br> <strong>指针数组</strong>是数组元素为指针的数组，其本质为数组。</p> 
<h3>
<a id="2_a_11"></a>2. 用变量a给出下面的定义</h3> 
<p>a) 一个整型数?<br> b) 一个指向整型数的指针?<br> c) 一个指向指针的的指针，它指向的指针是指向一个整型数?<br> d) 一个有10个整型数的数组?<br> e) 一个有10个指针的数组，该指针是指向一个整型数的?<br> f) 一个指向有10个整型数数组的指针?<br> g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数?<br> h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数？<br> 答：<br> a) int a;<br> b) int *a;<br> c) int * * a;<br> d) int a[10];<br> e) int *a[10];<br> f) int (*a)[10];<br> g) int (*a)(int );<br> h) int (*a[10])(int );</p> 
<h3>
<a id="3___30"></a>3.什么叫 野指针， 产生原因，如何规避</h3> 
<p>答：野指针就是 指针指向的位置是不可知的。<br> 原因：<br> 1、指针变量未初始化<br> 2、指针释放后之后未置空（指针所指向的变量 在指针之前被销毁）<br> 3、指针操作超越变量作用域<br> 规避：<br> 1、初始化时置 NULL<br> 2、释放时置 NULL</p> 
<h3>
<a id="4_40"></a>4.简述数组与指针的区别？</h3> 
<p>答：<br> 数组 在静态存储区被创建（如全局数组），或 在栈上被创建。<br> 指针 可以随时指向任意类型的内存块。<br> (1)修改内容上的差别</p> 
<pre><code class="prism language-cpp">   <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> “hello”<span class="token punctuation">;</span>
   a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> ‘X’<span class="token punctuation">;</span>
   <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> “world”<span class="token punctuation">;</span> <span class="token comment">// 注意p 指向常量字符串</span>
   p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> ‘X’<span class="token punctuation">;</span> <span class="token comment">// 编译器不能发现该错误，运行时错误</span>
</code></pre> 
<p>(2) sizeof(数组名),计算出数组的容量（字节数）；<br> sizeof(指针变量),计算出指针变量的字节数，而不是所指的内存容量。</p> 
<h2>
<a id="static_54"></a>static</h2> 
<h3>
<a id="1_static_56"></a>1. 关键字static的作用是什么？</h3> 
<p>答：<br> static对 局部变量 改变生存期；<br> static对 全局变量 改变作用域；<br> static对 函数 改变作用域；</p> 
<h2>
<a id="const_62"></a>const</h2> 
<p>const的意思是只读，不可改变的。</p> 
<h3>
<a id="1_const__65"></a>1关键字 const 是什么含意？</h3> 
<p>答：<br> <strong>作用</strong>：定义常量、修饰函数参数、修饰函数返回值三个作用。<br> <strong>定义</strong>：const修饰的数据类型是指常类型，常类型的变量或对象的值是不能被更新的。<br> <strong>目的</strong>：const 推出的初始目的是为了取代预编译指令，消除它的缺点，同时继承它的优点。</p> 
<h3>
<a id="2_const__71"></a>2.使用 const 理由</h3> 
<p>答：<br> 1.const 修饰只读变量、数组，防止被修改。<br> 2.节省空间。const 修饰只读变量常数只有一个拷贝，不是像#define给的是立即数，有多个拷贝。<br> 3.使用const修饰的形参函数能够处理const和非const实参。</p> 
<h3>
<a id="3_const__77"></a>3.下面 const 声明都是什么意思？</h3> 
<p>答：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token comment">//a是一个 常整型数</span>
<span class="token keyword">int</span> <span class="token keyword">const</span> a<span class="token punctuation">;</span> <span class="token comment">//a是一个 常整型数</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span> <span class="token comment">//a是一个指向 常整型数 的指针（整型数是不可修改，但指针可以）</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> a<span class="token punctuation">;</span> <span class="token comment">//a是一个指向整型数的 常指针（指针指向的整型数是可以修改的，但指针是不可修改的</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> a<span class="token punctuation">;</span> <span class="token comment">//a是一个指向 常整型数的 常指针（指针指向的整型数 和 指针 都不可修改）</span>
</code></pre> 
<h3>
<a id="4const_87"></a>4.指向字符串常量的指针，指向字符串的常量指针（const）</h3> 
<p>答：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">//指向 "字符串常量"</span>
p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'X'</span><span class="token punctuation">;</span> <span class="token comment">//错误! 想要修改字符串的第一个字符. 但是常量不允许修改</span>
p <span class="token operator">=</span> p2<span class="token punctuation">;</span> <span class="token comment">//正确! 让p指向另外一个指针.</span>

<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">//指向字符串的" 常量的指针"</span>
p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'X'</span><span class="token punctuation">;</span> <span class="token comment">//正确! 允许修改字符串, 因为该字符串不是常量</span>
p <span class="token operator">=</span> p2<span class="token punctuation">;</span> <span class="token comment">//错误! 指针是常量, 不许修改p的指向</span>

<span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> 和 <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> 是一样的，<span class="token keyword">const</span> 的位置在<span class="token keyword">char</span>左边还是右边都一样<span class="token punctuation">.</span>
常量指针的<span class="token keyword">const</span>应当写在 <span class="token operator">*</span> 星号的右边<span class="token punctuation">.</span>
指向常量字符串的常量指针的写法是 <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token string">"xx"</span><span class="token punctuation">;</span> 要<span class="token number">2</span>个<span class="token keyword">const</span>
</code></pre> 
<h2>
<a id="volatile_103"></a>volatile</h2> 
<h3>
<a id="1_105"></a>1.概念作用</h3> 
<p>volatile(英译:易变的)是一个特征修饰符关键字，防止编译器对修饰的变量相关代码进行优化，每次使用都重新读取变量的值，而不是使用寄存器里的备份。<br> volatile字面意思不太好理解，其实它是提醒编译器这个变量是易变的，不要去优化它！</p> 
<h3>
<a id="2_const__volatile__109"></a>2.一个参数既可以是 const 还可以是 volatile 吗？解释为什么。</h3> 
<p>答: 是的。<br> 例如是只读的状态寄存器。<br> volatile 是不让<strong>编译器</strong>去优化它。const 是不让<strong>程序</strong>去修改它。</p> 
<h3>
<a id="3_volatile__114"></a>3.一个指针可以是 volatile 吗？解释为什么。</h3> 
<p>答: 是的。例如当一个中断服务子程序修改一个指向一个buffer的指针时。</p> 
<h3>
<a id="4volatile__117"></a>4.volatile 用在如下的几个地方：</h3> 
<p>1）、中断服务程序中<strong>修改的</strong>供其它程序<strong>检测的</strong>变量需要加volatile；<br> 2）、多任务环境下各任务间共享的标志应该加volatile；<br> 3）、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</p> 
<h3>
<a id="5volatile__122"></a>5.以上几种情况还要同时考虑数据的完整性（比如标志读了一半被打断了重写），volatile 是不具备原子性的，所以要考虑临界资源的访问冲突问题。</h3> 
<p>1）中可以通过关中断来实现，或其他方法实现；<br> 2）中可以禁止任务调度，或其他方法实现；<br> 3）中则只能依靠硬件的良好设计了。</p> 
<h2>
<a id="_127"></a>内存</h2> 
<h3>
<a id="1_129"></a>1.程序的内存分配</h3> 
<p>答：<br> 1）栈区（stack）----由编译器自动分配释放，存放函数的参数值，局部变量等。<br> 2）堆区（heap）----一般由程序员分配释放。分配使用new和malloc，释放使用deleted和free<br> 3）全局区（静态区）（static）----全局变量和静态变量是存放在一块的。初始化的在一块区域，未初始化存放在另一块区域(BSS)。<br> 4）常量区----存放常量字符串。<br> 5）程序代码区----存放函数体的二进制代码。<br> 例子程序:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//全局初始化区</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span> <span class="token comment">//全局未初始化区</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>栈
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span>”abc”<span class="token punctuation">;</span> <span class="token comment">//栈</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> <span class="token comment">//栈</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p3<span class="token operator">=</span>”<span class="token number">123456</span>″<span class="token punctuation">;</span> <span class="token comment">//123456\0在常量区，p3在栈上。</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">0</span>； <span class="token comment">//全局（静态）初始化区</span>
    p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分配得来得10和20字节的区域就在堆区。</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>”<span class="token number">123456</span>″<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//123456\0放在常量区，编译器可能会将它与p3所向”123456″优化成一个地方。</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-w5O7qfi0-1661091706346)(…/_resources/2757d7fd2adcd72691003742e297ed6b.png)]<br> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nb1qBwNT-1661091706348)(…/_resources/e90512f0aac4bb3bebe77497f8e5b7ba.png)]</p> 
<h3>
<a id="20x67a90xaa66ANSI_155"></a>2.访问固定的内存位置。绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器，写代码去完成这一任务。</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x67a9</span><span class="token punctuation">;</span>

<span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">0xaa55</span><span class="token punctuation">;</span>
</code></pre> 
<p>一个较晦涩的方法是：<br> <code>*(int * const)(0x67a9) = 0xaa55;</code><br> 即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p> 
<h3>
<a id="3_166"></a>3.队列和栈有什么区别？</h3> 
<p>答：队列先进先出，栈后进先出</p> 
<h3>
<a id="4_heap_stack__169"></a>4.解释 堆（heap）和 栈(stack) 的区别</h3> 
<p>答：<br> 1)<strong>申请方式</strong><br> stack:由系统自动分配。<br> 例如：声明在函数中一个局部变量int b; 系统自动在栈中为b开辟空间<br> heap:需要程序员自己申请，并指明大小。在c中malloc函数<br> 如：<code>p1 = (char*)malloc(10); //在C++中用new运算符。注意p1本身是在栈中的。</code><br> 2)<strong>申请效率的比较</strong><br> 栈: 由系统自动分配，速度较快。但程序员是无法控制的。<br> 堆: 是由malloc/new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br> 3)<strong>申请大小的限制</strong><br> 栈：系统预先规定好的.事先配置好。栈获得的空间较小。<br> 堆：程序员自己定义堆获得的空间比较灵活，也比较大。<br> 4)<strong>堆和栈中的存储内容</strong><br> 栈：存储函数 局部临时变量、现场的保护等。<br> 堆：堆中的具体内容由程序员安排。</p> 
<h3>
<a id="5_186"></a>5.堆栈溢出一般是由什么原因导致的？</h3> 
<p>答：<br> 1.没有回收垃圾资源;<br> 2.层次太深的递归调用</p> 
<h3>
<a id="6____191"></a>6.全局变量 和 局部变量 在内存中是否有区别？如果有，是什么区别？</h3> 
<p>答：<br> 1、全局变量储存在静态数据区，局部变量在堆栈中。<br> 2、全局变量的作用域是整个函数，局部变量的作用域是声明该变量的函数</p> 
<h3>
<a id="7_C_196"></a>7.全局变量 可不可以定义在可被多个.C文件包含的头文件中？为什么？</h3> 
<p>答：可以，在不同的C文件中以static形式来声明同名全局变量。只能有一个C文件中对此变量赋初值，此时连接不会出错。</p> 
<h3>
<a id="8_199"></a>8.堆栈区别</h3> 
<p>答：</p> 
<table>
<thead><tr>
<th></th>
<th>堆</th>
<th>栈（通常说堆栈）</th>
</tr></thead>
<tbody>
<tr>
<td>管理方式不同</td>
<td>程序员手工分配/释放</td>
<td>编译器自动管理</td>
</tr>
<tr>
<td>作用不同</td>
<td>程序员使用的大块空间</td>
<td>保护运行环境现场（中断、函数调用、任务切换）</td>
</tr>
<tr>
<td>生长方向不同</td>
<td>向上生长</td>
<td>向下生长</td>
</tr>
</tbody>
</table> 
<h2>
<a id="_207"></a>其他</h2> 
<h3>
<a id="1aabit_3a_bit_3_209"></a>1.嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。</h3> 
<p>答：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">BITS_CLR</span><span class="token expression"><span class="token punctuation">(</span>v<span class="token punctuation">,</span> n<span class="token punctuation">)</span> v <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1u</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">BITS_SET</span><span class="token expression"><span class="token punctuation">(</span>v<span class="token punctuation">,</span> n<span class="token punctuation">)</span> v <span class="token operator">|=</span>  <span class="token punctuation">(</span><span class="token number">1u</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token function">BTIS_SET</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">BTIS_CLR</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="2_switch__219"></a>2.不能做 switch() 的参数类型</h3> 
<p>答：实型</p> 
<h3>
<a id="3_____222"></a>3.当表达式中存在 有符号类型 和 无符号类型 时，所有的操作数是啥类型？</h3> 
<p>答：无符号类型。有符号类型将自动转换为无符号类型。</p> 
<h3>
<a id="4sizeofstrlen_225"></a>4.sizeof与strlen的区别</h3> 
<p>答：<br> strlen(…) 是函数，计算字符串的长度,以’’ 结束(不包含’’)<br> sizeof(…) 是运算符，不是函数。计算内存空间大小。在编译时就计算好了，因此sizeof不能用来返回动态分配的内存空间的大小。</p> 
<h2>
<a id="_230"></a>常见算法</h2> 
<h3>
<a id="1_232"></a>1、冒泡排序算法？</h3> 
<p>原理：比较相邻元素进行比较，交换。</p> 
<pre><code class="prism language-cpp"><span class="token comment">/**
  ******************************************************************************
  * @brief   冒泡排序加强版 函数
  * @param   *ary    数据指针
  * @param   len     数据长度
  * @param   dir     排序方向（1--降序；0--升序） 
  * @return  None
  * @note    升降排列通用 
  ******************************************************************************
  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BubbleType</span>     <span class="token expression"><span class="token keyword">int</span> </span><span class="token comment">//元素类型</span></span>
<span class="token keyword">void</span> <span class="token function">BubbleSortPlus</span><span class="token punctuation">(</span>BubbleType <span class="token operator">*</span>ary<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> dir<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	BubbleType tmp<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
 
	len<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//自减1。注意不能少 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//外循环为排序趟数，len个数进行len-1趟</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>len<span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//内循环为每趟比较的次数，第i趟比较len-i次</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ary<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">^</span> dir<span class="token punctuation">)</span> <span class="token comment">//相邻元素比较，若逆序则交换（升序为左大于右，降序反之）</span>
			<span class="token punctuation">{<!-- --></span>
				tmp <span class="token operator">=</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				ary<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="21A2B_267"></a>2.二分查找，数组起始下标为1，则查找A[2]的比较序列的下标为(B)</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">BinSearch</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>Array<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> Array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;</span> Array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&gt;</span> Array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> low  <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="3PID__283"></a>3.PID 作用</h3> 
<p>答：</p> 
<table>
<thead><tr>
<th></th>
<th>名称</th>
<th>作用</th>
<th>缺点</th>
</tr></thead>
<tbody>
<tr>
<td>P</td>
<td>比例控制</td>
<td>控制对象以线性的方式增加，在一个常量比例下，动态输出。</td>
<td>会产生稳态误差</td>
</tr>
<tr>
<td>I</td>
<td>积分控制</td>
<td>用来消除稳态误差</td>
<td>会增加超调</td>
</tr>
<tr>
<td>D</td>
<td>微分控制</td>
<td>减弱超调，加大惯性响应速度</td>
<td>对噪音敏感，容易出现过操作</td>
</tr>
</tbody>
</table> 
<h3>
<a id="3PID__291"></a>3.PID 调参方法</h3> 
<p>答：<br> 1，先调节比例。从小往大调，使系统在目标值上下波动，且波动足够小。<br> 2，再调节积分。从大往小调，使系统稳定。</p> 
<p>曲线振荡很频繁，比例度盘要放大<br> 曲线漂浮绕大湾，比例度盘往小扳</p> 
<p>曲线偏离回复慢，积分时间往下降<br> 曲线波动周期长，积分时间再加长</p> 
<h2>
<a id="MCUSTM32__303"></a>MCU/STM32 部分</h2> 
<h3>
<a id="1_305"></a>1.什么单片机？有哪些组成？各有什么功能？</h3> 
<blockquote> 
 <p>答：<br> <mark>单片机</mark>是单芯片微型计算机。把CPU、RAM、ROM、I/O口、中断系统、定时器等功能集成到一块硅片上构成的的微型计算机系统。<br> <mark>单片机组成</mark>由CPU、RAM、ROM、I/O口、中断系统、定时器等功能。</p> 
 <ul>
<li>CPU:中央处理器。计算机系统的运算和控制核心。</li>
<li>RAM:随机存取存储器。用来暂时存储程序、数据和中间结果</li>
<li>ROM:只读存储器。存放不需要更改的程序。</li>
<li>I/O口:输入/输出端口。</li>
<li>中断系统:处理紧急事件。也是实现多道程序设计的必要条件。</li>
<li>定时器:计时。</li>
</ul> 
</blockquote> 
<h3>
<a id="2ARM_v7_316"></a>2.ARM v7的体系结构可以分为哪几个子版本（款式），分别应用在什么领域？</h3> 
<blockquote> 
 <p>答：A,R,M三种。<br> <strong>Contex-A</strong>系列面向密集型系统的应用处理器内核。顶级主控，在手机，平板，GPS普遍应用，移动设备芯片90%都是使用arm。与arm9和arm11相对应，都是可以跑操作系统系统的如linux等。<br> <strong>Contex-R</strong>系列面向实时应用的高性能内核。主要应用于对实时性较高的场合，如硬盘控制器、车载控制产品等。<br> <strong>Contex-M</strong>系列面向各类嵌入式应用的微控制器内核(相当于高级单片机)。主要应用工业、消费领域。与arm7相似，不能跑大操作系统（只能跑类似uCos2实时操作系统）</p> 
</blockquote> 
<h3>
<a id="3CortexM3_322"></a>3.Cortex-M3的处理器有那两种工作模式和状态？如何进行工作模式和状态的切换？</h3> 
<blockquote> 
 <p>答：<br> ARM状态，32位，ARM状态执行字对齐的32位ARM指令。<br> Thumb状态，16位，执行半字对齐的16位指令。</p> 
</blockquote> 
<h3>
<a id="4_327"></a>4.简述嵌入式系统的定义、应用、特点、构成?</h3> 
<blockquote> 
 <p>答：<br> <strong>嵌入式系统定义</strong>：以应用为中心，以现代计算机技术为基础，能够根据用户需求(功能、可靠性、成本、体积、功耗、环境等)灵活裁剪软硬件模块的专用计算机系统。<br> <strong>嵌入式系统应用</strong>：应用于军事设备、信息终端、汽车电子、制造工业、航天航空等领域。<br> <strong>嵌入式系统特点</strong>：专用性、可裁性、实时性好、可靠性高、功耗低。<br> <strong>嵌入式系统构成</strong>：由 硬件层、中间层、系统软件层、应用软件层 组成。</p> 
</blockquote> 
<h3>
<a id="5STM32_334"></a>5.你用过STM32有哪些型号?内部资源情况？价格？</h3> 
<p>答：下面自己根据情况填写</p> 
<table>
<thead><tr>
<th>型号</th>
<th>内核</th>
<th>ROM(Flash)</th>
<th>RAM(SRAM)</th>
<th>时钟</th>
<th>封装(IO)</th>
<th>功能</th>
<th>价格(美元)</th>
</tr></thead>
<tbody>
<tr>
<td><mark>STM32F103C8Tx</mark></td>
<td>M3</td>
<td>64K</td>
<td>20K</td>
<td>72MHz</td>
<td>LQFP48(37IO)</td>
<td></td>
<td>2</td>
</tr>
<tr>
<td>STM32F105RBT6</td>
<td>M3</td>
<td>64K</td>
<td>64K</td>
<td>72MHz</td>
<td>LQFP64(51IO)</td>
<td>USB(OTG主从)</td>
<td>2.5</td>
</tr>
<tr>
<td>STM32F373VCx</td>
<td>M4</td>
<td>256K</td>
<td>32K</td>
<td>72MHz</td>
<td>LQFP100</td>
<td>16B ADC、DAC</td>
<td>3.2</td>
</tr>
<tr>
<td>STM32F411CEUx</td>
<td>M4</td>
<td>512K</td>
<td>128K</td>
<td>100MHz</td>
<td>UFQFPN48</td>
<td></td>
<td>2.8</td>
</tr>
<tr>
<td><mark>STM32F412VETx</mark></td>
<td>M4</td>
<td>512K</td>
<td>256K</td>
<td>100MHz</td>
<td>LQFP100</td>
<td>USB(HOST)</td>
<td>3.6</td>
</tr>
<tr>
<td>STM32F407VGT6</td>
<td>M4</td>
<td>1M</td>
<td>192K</td>
<td>168MHz</td>
<td>LQFP100(82IO)</td>
<td></td>
<td>5.6</td>
</tr>
<tr>
<td>STM32F429IGTx</td>
<td>M4</td>
<td>1M</td>
<td>256K</td>
<td>180MHz</td>
<td>LQFP176</td>
<td></td>
<td>6.8</td>
</tr>
<tr>
<td>STM32H743ZIT6</td>
<td>M7</td>
<td>2M</td>
<td>1M</td>
<td>480MHz</td>
<td>LQFP144</td>
<td></td>
<td>7</td>
</tr>
<tr>
<td>STM32H743IITx</td>
<td>M7</td>
<td>2M</td>
<td>1M</td>
<td>480MHz</td>
<td>LQFP176</td>
<td></td>
<td>7.2</td>
</tr>
</tbody>
</table> 
<h3>
<a id="6STM32F1F4_348"></a>6.STM32F1和F4的区别？</h3> 
<table>
<thead><tr>
<th>系列</th>
<th>内核</th>
<th>性能</th>
<th>特点</th>
</tr></thead>
<tbody>
<tr>
<td>STM32F0</td>
<td>Cortex-M0</td>
<td>入门级MCU</td>
<td>适合成本敏感型应用</td>
</tr>
<tr>
<td>STM32F1</td>
<td>Cortex-M3</td>
<td>基础型MCU</td>
<td>高性能(外设、低功耗、低压操作)，价格可接受。适合工业、医疗和消费类</td>
</tr>
<tr>
<td>STM32F3</td>
<td>Cortex-M4</td>
<td>混合信号MCU（附带DSP和FPU）</td>
<td>16位ADC、12位DAC、可编程增益运算，72MHz主频</td>
</tr>
<tr>
<td>STM32F4</td>
<td>Cortex-M4</td>
<td>高性能MCU（附带DSP和FPU）</td>
<td>180MHz主频、高性能</td>
</tr>
<tr>
<td>STM32F7</td>
<td>Cortex-M7</td>
<td>高性能MCU</td>
<td>216MHz主频、高性能。</td>
</tr>
<tr>
<td>STM32H7</td>
<td>Cortex-M7</td>
<td>超高性能MCU</td>
<td>480MHz主频、高性能</td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>答：参看STM32开发–STM32初识<br> 内核不同：F1是Cortex-M3内核，F4是Cortex-M4内核；<br> 主频不同：F1主频一般多为72MHz，F4主频一般多为168MHz左右；<br> 浮点运算：F1无浮点运算单位，F4有；<br> 功能性能：F4外设比F1丰富且功能更强大，比如GPIO翻转速率、上下拉电阻配置、ADC精度<br> 等；<br> SRAM大小： F1范围从4K～80K，F4范围64K～256K。<br> Flash大小：F1范围16K~1024K，F4范围128K～2048K。</p> 
</blockquote> 
<h3>
<a id="7STM32_367"></a>7.STM32的启动流程?</h3> 
<blockquote> 
 <p>答：<br> ①上电后硬件设置SP、跳转到 Reset_Hander<br> ②设置系统时钟(SystemInit)<br> ③软件设置SP<br> ④加载.data、.bss，并初始化栈区(__main)<br> ⑤跳转到C文件的main函数</p> 
 <p>Code：代表程序代码段<br> RO_DATA:代表只读数据段<br> RW_DATA：代表已经初始化全局数据<br> ZI_DATA：代表未初始化全局数据</p> 
 <p>RO_SIZE = Code + RO_DATA（占用 Flash）<br> RW_DATA = RW_DATA + ZI_DATA（占用 SRAM）<br> ROM_SIZE = Code + RO_DATA + RW_DATA (烧写到 FLASH 大小空间)</p> 
</blockquote> 
<h3>
<a id="8STM32_384"></a>8.STM32有几个时钟源？</h3> 
<blockquote> 
 <p>答：<br> STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。<br> ①、HSI是<mark>高速内部时钟</mark>，RC振荡器，频率为8MHz，精度不高。<br> ②、HSE是<mark>高速外部时钟</mark>，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。<br> ③、LSI是<mark>低速内部时钟</mark>，RC振荡器，频率为40kHz，提供低功耗时钟。　<br> ④、LSE是<mark>低速外部时钟</mark>，接频率为32.768kHz的石英晶体。<br> ⑤、PLL为<mark>锁相环倍频输出</mark>，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。</p> 
</blockquote> 
<h3>
<a id="9____393"></a>9.函数调用 和 中断服务函数执行 区别</h3> 
<p>答：<br> 不同点：函数调用发生条件已知，中断发生条件未知；函数调用可能有返回值，中断没有返回值。<br> 相同点：都需要CPU去执行，都需要入栈和出栈</p> 
<h3>
<a id="10ARM_398"></a>10.ARM的中断概述</h3> 
<p>答：<br> STM32中断由 NVIC中断控制器 + 模块级中断使能 构成。<br> NVIC中断控制器：属于内核，是一个管理中断机制的模块。由ARM公司设计。<br> 模块级中断使能：属于片上外设，外设中断使能，由芯片厂家设计</p> 
<p>NVIC中断优先级分为两类：抢占优先级、响应优先级；中断中还有自己规定的自然优先级。<br> 8位寄存器来设置 抢占优先级 与 响应优先级，例如：3个位来设置抢占优先级，则剩下5个位来设置响应优先级</p> 
<p><mark>抢占优先级</mark>：高优先级的事件发生时，能够打断低优先级的事件的执行过程。高优先级的事件能够抢到CPU资源。----处理中断嵌套问题。<br> <mark>响应优先级</mark>：高优先级的事件发生时，不能够打断低优先级的事件的执行过程。只能是两个优先级的事件同时发生时，先执行优先级高的事件。----抢占优先级相同时，同时中断，谁先执行的问题。<br> <mark>自然优先级</mark>：中断入口地址固定，则优先级固定。----以上优先级相同，同时中断，按自然优先级执行。<br> 抢占优先级&gt;响应优先级&gt;自然优先级。优先级中：数值越小，优先级越高。</p> 
<p>如：串口1(中断源)： 抢占优先级2，响应优先级3，自然优先级42<br> 定时器2(中断源)：抢占优先级2，响应优先级3，自然优先级50<br> 中断响应 对比规则：<br> 首先比较抢占优先级，如果抢占优先级一样，才会去比较响应优先级，如果响应优先级一样，才会去比较自然优先级。</p> 
<p>举例抢占优先级：<br> 事件A的抢占优先级为2，响应优先级为3<br> 事件B的抢占优先级为1，响应优先级为4<br> 1.当同时发送异常事件时，如何执行？ CPU先执行执行事件B<br> 2.当执行事件A的过程中发生了事件B，如何执行？ CPU先去执行B，执行完B后，回到事件A<br> 3.当执行事件B的过程中发生了事件A，如何执行？ CPU继续执行B，执行完B后，再执行A</p> 
<p>举例响应优先级：<br> 事件A：抢占优先级2 响应优先级3<br> 事件B：抢占优先级2 响应优先级4<br> 1.当同时发送异常事件时，如何执行？ CPU执行A<br> 2.当执行事件A的过程中发生了事件B，如何执行？ CPU继续执行A，执行完A后，再执行B<br> 3.当执行事件B的过程中发生了事件A，如何执行？ CPU继续执行B，执行完B后，再执行A</p> 
<p>举例自然优先级：<br> 事件A：抢占优先级2 响应优先级3 自然优先级 10<br> 事件B：抢占优先级2 响应优先级3 自然优先级 8<br> 1.当同时发送异常事件时，如何执行？ 先执行B<br> 2.当执行事件A的过程中发生了事件B，如何执行？ 继续执行A，执行完A后，再执行B<br> 3.当执行事件B的过程中发生了事件A，如何执行？ 继续执行B，执行完B后，再执行A</p> 
<blockquote> 
 <p>总结：<br> 1.只要抢占优先级一样，就不会发生中断嵌套问题。<br> 2.抢占优先级和响应优先级都是用户自定义。自然优先级由厂家固定。<br> 3.两个中断之间，抢占优先级和响应优先级可以设置成一样，但是自然优先级不可能一样。</p> 
</blockquote> 
<h3>
<a id="11ADC_B__443"></a>11.ADC转换器的主要技术指标（ B ）</h3> 
<p>答：分辨率、转换速率、量化误差</p> 
<h3>
<a id="12DMA__446"></a>12.DMA 概念、作用</h3> 
<p>答：DMA译为 直接存储器访问。主要就是搬运数据，不需要CUP参与。</p> 
<blockquote> 
 <ul>
<li>DMA控制器可编程的数据传输数目最大为（65536 ）。</li>
<li>STM32中，1个DMA请求占用至少（2）个周期的CPU访问系统总线时间。</li>
</ul> 
</blockquote> 
<h3>
<a id="13DMA_451"></a>13.DMA搬运的方向只有三种:</h3> 
<p>答：<br> 1.外设 到 存储器<br> 2.存储器 到 外设<br> 3.存储器 到 存储器</p> 
<h3>
<a id="14DMA_FIFO___457"></a>14.DMA FIFO模式 与 直接模式</h3> 
<p>答：<br> FIFO模式：用于在 源数据 传输到 目标 之前临时存储这些数据。源和目标的传输的数据宽度可以不一致。<br> 直接模式：用于在 源数据 直接传输到 目标，数据宽度要一致。存储器 到 存储器 传输时不得使用直接模式。</p> 
<h3>
<a id="15___462"></a>15.大端模式 与 小端模式</h3> 
<p>答：<br> 1)大端模式（Big-Endian）： 高位字节 排放在内存的 低地址，低位字节排放在内存的高地址。<br> 2)小端模式（Little-Endian）：低位字节 排放在内存的 低地址，高位字节排放在内存的高地址。</p> 
<p>例如：0x87 65 43 21 在 0x20000000 存储方式。</p> 
<table>
<thead><tr>
<th>内存地址</th>
<th>0x20000000</th>
<th>0x20000001</th>
<th>0x20000002</th>
<th>0x20000003</th>
</tr></thead>
<tbody>
<tr>
<td>大端模式存储</td>
<td>0x87</td>
<td>0x65</td>
<td>0x43</td>
<td>0x21</td>
</tr>
<tr>
<td>小端模式存储</td>
<td>0x21</td>
<td>0x43</td>
<td>0x65</td>
<td>0x87</td>
</tr>
</tbody>
</table> 
<p>大端：是符合人的顺序直观思维。常见 C51单片机、通讯协议。<br> 小端：适合字节的存储方式，强制转换不用判断。常见 STM32单片机、BMP、操作系统。</p> 
<p><mark>宏实现大小端转换</mark></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">BIG_LITTLE_SWAP16</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff00</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> </span><span class="token punctuation"></span>
                                      <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x00ff</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">)</span></span></span>
</code></pre> 
<p><mark>函数实现大小端转换</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">BigLittleEndianSwap</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> tmp<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> num <span class="token operator">=</span> size<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
	size<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
	    tmp <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	    p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>size<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		p<span class="token punctuation">[</span>size<span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="16_UARTIICSPI_499"></a>16.常用串行通信 对比（UART、IIC、SPI）</h3> 
<table>
<thead><tr>
<th></th>
<th>UART</th>
<th>IIC</th>
<th>SPI</th>
</tr></thead>
<tbody>
<tr>
<td>特征总结</td>
<td>异步 串行 全双工</td>
<td>同步 串行 半双工</td>
<td>同步 串行 全双工</td>
</tr>
<tr>
<td>时钟</td>
<td>异步</td>
<td>同步</td>
<td>同步</td>
</tr>
<tr>
<td>数据</td>
<td>串行</td>
<td>串行</td>
<td>串行</td>
</tr>
<tr>
<td>通信方向</td>
<td><mark>RS485半双工、RS232全双工、全双工</mark></td>
<td>半双工</td>
<td>全双工</td>
</tr>
<tr>
<td>接口</td>
<td>TX、RX</td>
<td>SCL、SDA</td>
<td>NSS、SCK、MOSI、MISO</td>
</tr>
<tr>
<td>速度(单位bps)</td>
<td>9.6K、…、1.152M(高)</td>
<td>100K(标)、400K(快)、3.4M(高)</td>
<td>25M、80M、100M…Mhz级以上</td>
</tr>
<tr>
<td>数据帧格式</td>
<td>空闲位(1)+起始位(0)+数据位+校验位+停止位(1)</td>
<td>起始条件+数据位+应答+停止条件<br>起始条件:SCL–1, SDA 1–&gt;0 <br>停止条件:SCL–1, SDA 0–&gt;1</td>
<td>低片选+发数据位+收数据位+高片选。<br>四种MODE0 - 3 <br>时钟高/低电平时发送数据位；<br>时钟下降/上升沿时接收数据位；</td>
</tr>
<tr>
<td>GPIO端口模式设置</td>
<td>TX推挽输出<br>RX浮空输入</td>
<td>SCL推挽输出<br>硬件模式：SDA开漏输出、既不上拉也不下拉。<br>软件模拟：SDA推挽输出 或 配置上拉输入。</td>
<td>MISO 主机输入，从机输出。<br>MOSI 主机输出，从机输入。<br>SCLK 时钟信号，由主机产生。<br>CS 从机片选信号，由主机控制。</td>
</tr>
<tr>
<td>主从设备通讯</td>
<td>没有主从之分</td>
<td>有主从之分</td>
<td>有主从之分</td>
</tr>
<tr>
<td>总线结构</td>
<td>一对一</td>
<td>一对多</td>
<td>一对多</td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>I2C仲裁机制？</p> 
 <ul><li>简单说，它遵循“低电平优先”的原则，即谁先发送低电平谁就会掌握对总线的控制权。</li></ul> 
</blockquote> 
<blockquote> 
 <p>SPI通信的四种模式，就是SCLK极性 与 相位 组合的四种情况。</p> 
 <ul>
<li>SCLK极性 就是 空闲时0或1</li>
<li>SCLK相位 就是 上升沿或下降沿</li>
</ul> 
</blockquote> 
<blockquote> 
 <p>I2C、SPI 通讯速率？<br> 答：I2C小百K (100K400K); SPI在十几到几十M</p> 
</blockquote> 
<h3>
<a id="17CAN_523"></a>17.CAN总结介绍一下？</h3> 
<p>CAN控制器根据 CAN_H 和 CAN_L 上的电位差来判断总线电平。总线电平分为显性电平(差为高电平)和隐性电平(差为低电平)。发送方通过使总线电平发生变化，将消息发送给接收方。</p> 
<h3>
<a id="18CAN_526"></a>18.CAN初始化配置步骤?</h3> 
<p>（1）配置相关引脚的复用功能，使能CAN时钟<br> （2）设置CAN工作模式及波特率等（CAN初始化环回模式,波特率500Kbps ）<br> （3）设置滤波器</p> 
<h2>
<a id="TCPIP_531"></a>TCP/IP</h2> 
<h3>
<a id="1TCPUDP_533"></a>1.TCP与UDP区别</h3> 
<table>
<thead><tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr></thead>
<tbody>
<tr>
<td>是否连接</td>
<td>面向连接，多次握手，类似打电话</td>
<td>无需连接，不用握手，类似发短信</td>
</tr>
<tr>
<td>是否可靠</td>
<td>传输可靠</td>
<td>传输不可靠</td>
</tr>
<tr>
<td>连接对象</td>
<td>点对点连接</td>
<td>可以一对一，一对多，多对一和多对多连接</td>
</tr>
<tr>
<td>首部开销</td>
<td>开销大，20~60字节</td>
<td>开销小，8字节</td>
</tr>
<tr>
<td>传输速度</td>
<td>传输慢</td>
<td>传输快</td>
</tr>
<tr>
<td>传输方式</td>
<td>字节流</td>
<td>报文</td>
</tr>
<tr>
<td>适用场景</td>
<td>可靠传输，如文件</td>
<td>实时应用，视频，直播等</td>
</tr>
<tr>
<td>程序上标记</td>
<td>有监听</td>
<td>没有监听</td>
</tr>
</tbody>
</table> 
<h3>
<a id="2TCP_____545"></a>2.TCP 服务端 与 客户端 区别</h3> 
<table>
<thead><tr>
<th></th>
<th>TCP 服务端</th>
<th>TCP 客户端</th>
</tr></thead>
<tbody>
<tr>
<td>主被动</td>
<td>被动角色</td>
<td>主动角色</td>
</tr>
<tr>
<td>类似</td>
<td>10086客服</td>
<td>手机主人</td>
</tr>
<tr>
<td>连接请求</td>
<td>等待来自客户端的连接请求</td>
<td>发送连接请求</td>
</tr>
<tr>
<td>执行情况</td>
<td>处理请求并回传结果</td>
<td>等待服务器的响应</td>
</tr>
</tbody>
</table> 
<p>客户端侧在配置TCP连接时，必须设置服务器IP地址及端口号，自身可设备自动分配，或设定好。<br> 服务器侧在配置TCP连接时，必须设置服务器使用的端口号，客户端IP地址及端口号为可选项。</p> 
<p>IP地址：网络协议地址。类似电话号码<br> 端口号：用于区分不同服务的逻辑编号，通常使用2000~5000范围内端口。类似分机号</p> 
<h3>
<a id="3_559"></a>3.子网掩码作用</h3> 
<p>1、屏蔽部分IP地址，区分 网络标识 和 主机标识，解释 IP地址 是在 局域网上 还是在 远程网络上。<br> 2、将一个大的IP网络划分为几个小的子网络。</p> 
<h3>
<a id="4Gateway_563"></a>4.网关(Gateway)</h3> 
<p>网关称为网间连接器。我们知道从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关，具有路由功能，如路由器。网关也是有IP地址的。</p> 
<h2>
<a id="Bootloader_566"></a>Bootloader</h2> 
<p>规划 bootloader 和 app 的空间</p> 
<h4>
<a id="1Bootloader__569"></a>1.Bootloader 程序部分</h4> 
<p><strong>1.在mdk中设置 bootloader 空间大小</strong><br> <strong>2.擦写APP FLASH</strong><br> <em>APP固件在Bootloader中接收的 情况</em><br> 1)、检查是否要升级<br> 2)、接收app固件文件<br> 3)、擦 APP FLASH<br> 4)、写 APP FLASH<br> <em>APP固件已存储的 情况</em><br> 1)、检查存储区是否有app固件<br> 2)、擦 APP FLASH<br> 3)、写 APP FLASH<br> 4)、擦 升级标志<br> <strong>3.实现跳转</strong><br> 1)、检测 APP 栈顶地址是否合法。<br> 2)、设置 MSP和PSP 栈指针 APP<br> 3)、关闭所有中断（若关闭了总中断，app程序中要开启）<br> 4)、跳转到 APP 复位地址处。（地址强转成函数指针，调用）</p> 
<h4>
<a id="2App__588"></a>2.App 程序部分</h4> 
<p>1、在mdk中设置 App 空间起始地址和大小<br> 2、中断向量表重定向，修改偏移地址（系统初始函数最后）<br> 3、生成bin文件</p> 
<h2>
<a id="RTOS_593"></a>RTOS共同部分</h2> 
<h4>
<a id="1RTOS___595"></a>1.RTOS操作系统 与 裸机开发（前后系统）区别</h4> 
<p>RTOS：人为的为任务切换CPU资源，并对运行环境进行保护管理，相当虚拟了多个CPU。每个任务都是一个死循环。<br> 裸机开发（前后系统）：每个任务只能顺序获得CPU资源。一个任务运行一遍了才轮到下个任务。</p> 
<h4>
<a id="2RTOS___599"></a>2.RTOS 任务优先级 特点</h4> 
<p>答：<br> FreeRTOS 任务优先级 数值越小，优先级越低。<br> uCOSII 任务优先级 数值越小，优先级越大。</p> 
<h3>
<a id="3____604"></a>3.回调函数 与 钩子函数 的区别</h3> 
<p>答：<br> 回调函数：用户定义、编写的函数，注册给系统调用的函数。<br> 钩子函数：系统定义、实现了部分函数功能，剩下部分需要用户实现的函数。</p> 
<h3>
<a id="4_609"></a>4.什么是不可剥夺型内核？</h3> 
<p>答：各个任务彼此合作共享一个CPU 内核要求每个任务自我放弃CPU的所有权。</p> 
<h3>
<a id="5_612"></a>5.什么是可剥夺型内核？</h3> 
<p>答：根据优先级可占用当前CPU的使用权。</p> 
<h2>
<a id="FreeRTOS__615"></a>FreeRTOS 部分</h2> 
<h3>
<a id="1FreeRTOS__617"></a>1.FreeRTOS 移植过程</h3> 
<p>答：</p> 
<blockquote> 
 <p>STM32CubeMX移植FreeRTSO</p> 
 <p>官方示例移植</p> 
 <ul>
<li>1，下载官方示例文件<br> Demo: 对应芯片系列和编译器名称文件夹下的 FreeRTOSConfig<br> FreeRTOS 源码文件：源码文件、头文件夹、移植文件（内存管理、编译器文件下的 内核接口文件）</li>
<li>2，官方工程编译修改正确</li>
<li>3，添加到自己对应芯片工程里，并修改FreeRTOSConfig系统时钟参数</li>
</ul> 
</blockquote> 
<h3>
<a id="2__628"></a>2.队列、事件标志组、信号量、任务通知 总结</h3> 
<table>
<thead><tr>
<th>功能</th>
<th>区别列表</th>
</tr></thead>
<tbody>
<tr>
<td>消息队列</td>
<td>（<mark>需要传递消息时使用</mark>） 在任务与任务间、 中断和任务间传递信息，可以数据传输</td>
</tr>
<tr>
<td>事件标志组</td>
<td>（<mark>多个事件同步，不需要传递消息时使用</mark>） 实现任务与任务间、 中断和任务间的同步，无数据传输。 可实现一对多、多对多的同步， 可选择是 “ 逻辑或 ” 触发还 是 “ 逻辑与 ”触发。即 一 个任务可以等待多个事件的发生。</td>
</tr>
<tr>
<td>信号量</td>
<td>（<mark>单个事件同步，不需要传递消息时使用</mark>）</td>
</tr>
<tr>
<td>#二值信号量</td>
<td>类似一个标志位。仅”空“（0）和”非空“（1）两种状态</td>
</tr>
<tr>
<td>#计数信号量</td>
<td>用来 事件计数 和 资源管理</td>
</tr>
<tr>
<td>#互斥信号量</td>
<td>（<mark>中断中无法使用</mark>）拥有优先级继承的二值信号量</td>
</tr>
<tr>
<td>任务通知</td>
<td>可以在一定场合下替代 FreeRTOS 的信号量， 队列、事件组等</td>
</tr>
</tbody>
</table> 
<h3>
<a id="1_640"></a>1.任务</h3> 
<h4>
<a id="1_642"></a>1.什么是任务</h4> 
<p>任务： 运行的函数<br> 句柄： 结构体指针</p> 
<h4>
<a id="2_646"></a>2.任务状态</h4> 
<blockquote> 
 <ul>
<li>就绪（Ready）： 随时可以运行的任务，但还没轮到它。新创建的任务为就绪态。</li>
<li>运行（Running）： 任务正在执行，此时占用处理器。例如，汽车正在行驶。</li>
<li>阻塞（Blocked）： 等待某个事件（时间延时，事件等）。例如，汽车等待绿灯。</li>
<li>暂停(Suspended)（挂起）： 不等待，直接去休息了。</li>
</ul> 
</blockquote> 
<h4>
<a id="3_652"></a>3.任务优先级</h4> 
<p>高优先级的任务，优先执行，可抢占低优先级任务<br> 高优先级的任务不停止，低优先级任务永远无法执行<br> 同等优先级任务，轮流执行（或叫时间片轮转）</p> 
<p>优先级有关配置：<br> 是否 可抢占<br> 是否 时间片轮转<br> 是否 空闲任务让步</p> 
<h4>
<a id="4_662"></a>4.任务怎么管理</h4> 
<p>FreeRTOS通过三种链表（就绪任务链表、阻塞任务链表、暂停任务链表）来管理任务。就绪任务链表 有多少个优先级就有多少个 就绪任务链表；阻塞任务链表、暂停任务链表 各1个。</p> 
<p>1、从高优先级 就绪任务链表 向低优先级 就绪任务链表 中找到就绪任务，获取任务句柄给到运行指针， 运行它。<br> 2、若有同级任务，排队轮流执行，链表前面的先运行，运行1个tick后排到队伍后面。<br> 3、若某个任务阻塞，则将该任务从 就绪任务链表移到 阻塞任务链表 中；阻塞解除，则反之。<br> 4、若某个任务暂停，则将该任务从 就绪任务链表移到 暂停任务链表 中；解除暂停，则反之。</p> 
<h4>
<a id="5__670"></a>5. 怎么进行任务调度</h4> 
<p>在Tick中断函数中会进行任务切换（链表种取出合适的任务运行）。每次中断会检查有哪些延时任务到期，将其从延时任务列表里移除并加入到就绪列表里。如果就绪任务的优先级都相同，如果开启时间片轮询，就会每个tick执行一个任务，轮询执行。</p> 
<blockquote> 
 <p>Tick中断做了什么：</p> 
 <ul>
<li>1）、找到就绪链表中最高优先级，且排在最前面的的绪任务。</li>
<li>2）、保存当前任务的信息，并将其插入就绪任务链表末端</li>
<li>3）、恢复新的任务</li>
</ul> 
</blockquote> 
<h4>
<a id="6_677"></a>6.创建任务所需参数</h4> 
<p>任务函数、设置任务栈大小（1000）、优先级、参数、传出的任务句柄</p> 
<h3>
<a id="2_681"></a>2.同步与互斥</h3> 
<p>同步： 一种依赖关系，A任务运行完了，B任务才能运行。<br> 互斥： 访问同一个资源时，同一时刻只能有一个获得，一个使用完后才能轮到下一个。</p> 
<h3>
<a id="3__686"></a>3. 队列</h3> 
<p>种类：队列、消息邮箱（长度为1）</p> 
<h4>
<a id="1__690"></a>1. 队列</h4> 
<p>队列是为了任务与任务、任务与中断之间传递不定长消息。FreeRTOS采用是复制消息方式。</p> 
<p>特性：<br> 读写队列支持超时机制。<br> 消息支持先进先出原则（FIFO），但是也支持后进先出原则（LIFO）。<br> 可以允许不同长度的任意类型消息（不超过队列节点最大值）。<br> 一个任务能够从任意一个消息队列接收和发送消息。<br> 多个任务能够从同一个消息队列接收和发送消息。<br> 当队列使用结束后，可以通过删除队列函数进行删除。</p> 
<h4>
<a id="2__701"></a>2. 消息邮箱</h4> 
<p>消息队列长度为 1 的情况。</p> 
<h3>
<a id="4__705"></a>4. 信号量</h3> 
<p>信号量其实就是只有一个队列项的队列，该队列项不是用来传递消息，而是用来计数。<br> 作用：资源管理、任务同步、互斥访问。</p> 
<p>种类：计数信号量、二值信号量、互斥信号量、递归信号量</p> 
<h4>
<a id="1_711"></a>1.计数信号量</h4> 
<p>作用：事件计数 或 资源数量的管理。<br> 优先级翻转现象： 只有一个资源时，低优先级任务 正在占用 资源，高优先级任务 只能等待 低优先级任务 释放资源。这种现象称为“优先级翻转”。</p> 
<h4>
<a id="2_715"></a>2.二值信号量</h4> 
<p>概念：计数值只有 0 和 1 信号量。</p> 
<h4>
<a id="3_718"></a>3.互斥信号量</h4> 
<p>概念：具有优先级继承的二值信号量。<br> 优先级继承：低优先级任务 在使用 互斥信号量时，这时候 高优先级任务 也想用互斥信号量，高优先级任务 把优先级暂时继承给 低优先级任务 减少阻塞时间，让赶快用完。</p> 
<p>互斥信号量 不能用于 中断服务函数，原因如下：<br> 1、有 优先级继承 机制。<br> 2、中断服务函数 不能设置阻塞时间。</p> 
<h4>
<a id="4_726"></a>4.递归信号量</h4> 
<p>概念：其实就是 互斥信号量 嵌套。</p> 
<h3>
<a id="5__729"></a>5. 事件组</h3> 
<p>概念：就是一个 32 位的标志集合。（0 表示该事件类型未发生、1 表示该事件类型已经发生）。支持事件等待超时机制。<br> 作用：多个事件同步，不需要传递消息时使用。</p> 
<blockquote> 
 <p>特性：</p> 
 <ul>
<li>仅用于同步，不提供数据传输。</li>
<li>多次向任务设置同一事件(如果任务还未来得及读走)，等效于 只设置一次。</li>
<li>允许 多个任务 对 同一事件 进行 读写操作。</li>
<li>支持 事件等待 超时机制。</li>
</ul> 
</blockquote> 
<h3>
<a id="6__739"></a>6. 任务通知</h3> 
<p>要明确发给那个任务。</p> 
<blockquote> 
 <p>任务通知可以实现：消息邮箱，计数信号量，二值信号量，事件标志组。<br> 不同点：</p> 
 <ul>
<li>使用 队列，信号量，事件标志组 前 ，必须先创建。</li>
<li>在创建任务的时候，系统已经创建了任务通知， 任务通知处理更快，RAM 开销更小。</li>
</ul> 
</blockquote> 
<blockquote> 
 <p>任务通知限制：</p> 
 <ul>
<li>只有一个任务等待信号量。</li>
<li>不支持超时等待，</li>
<li>几种方式发送通知给任务 ：<br> 1、如果有通知未读，不覆盖通知值。<br> 2、直接覆盖通知值。<br> 3、设置通知值的一个或者多个位 ，可以当做事件组来使用。<br> 4、递增通知值，可以当做计数信号量使用</li>
</ul> 
</blockquote> 
<h3>
<a id="7_756"></a>7.综合问答</h3> 
<h4>
<a id="FreeRTOS__758"></a>FreeRTOS 有几种任务状态？</h4> 
<blockquote> 
 <ul>
<li>就绪（Ready）： 随时可以运行的任务，但还没轮到它。新创建的任务为就绪态。</li>
<li>运行（Running）： 任务正在执行，此时占用处理器。例如，汽车正在行驶。</li>
<li>阻塞（Blocked）： 等待某个事件（时间延时，事件等）。例如，汽车等待绿灯。</li>
<li>暂停(Suspended)（挂起）： 不等待，直接去休息了。</li>
</ul> 
</blockquote> 
<h4>
<a id="FreeRTOS__764"></a>FreeRTOS 优先级？</h4> 
<p>答：FreeRTOS 任务优先级 数值越小，优先级越低。</p> 
<h4>
<a id="FreeRTOS__767"></a>FreeRTOS 调度机制（调度算法/调度算法）有几种？</h4> 
<p>答：三种调度方式：时间片、抢占式、合作式。<br> 时间片调度（不同优先级）：每个任务都有相同的优先级，任务会运行固定的时间片个数或者遇到阻塞式的API函数，比如vTaskDelay，才会执行同优先级任务之间的任务切换。<br> 抢占式调度（相同优先级）：每个任务都有不同的优先级，任务会一直运行直到被高优先级任务抢占或者遇到阻塞式的API函数，比如vTaskDelay。<br> 合作式调度：用到的很少。相同优先级时间片，不同优先级抢占式调度。</p> 
<h4>
<a id="FreeRTOS__773"></a>FreeRTOS 中，互斥信号量和二值信号量的区别？二者能不能中断中调用，说明原因？</h4> 
<p>答：<br> 互斥信号量<br> 1.有优先级继承。<br> 2.中断中不调用。</p> 
<p>二值信号量<br> 1.无优先级继承。<br> 2.允许在中断中调用。</p> 
<p>互斥信号量 不能用于 中断服务函数，原因如下：<br> 1、有 优先级继承 机制。<br> 2、中断服务函数 不能设置阻塞时间。</p> 
<h4>
<a id="_rtos__787"></a>单片机裸机和 rtos 开发过程中，如何保证全局变量在中断和主循环中读写的正确性？</h4> 
<p>答：这个变量是临界区资源，无论裸机还是rtos，都要保证临界资源的可见性和原子性。对于变量可见性用volatile修饰，原子性在rots就要访问变量前设置进入临界状态，访问完毕退出临界状态；裸机就要用锁或关闭中断等方法，若嵌套的话还要注意锁或中断状态的保存。</p> 
<h4>
<a id="UART485_790"></a>UART是全双工还是半双工？485是全双工还是半双工？</h4> 
<p>答：UART/RS232是全双工；485是半双工。</p> 
<h4>
<a id="485_793"></a>你这个项目485采用是啥接法？</h4> 
<p>答：采用一条总线将各个节点串接起来，不支持环形 或星型网络。分支多会造成阻抗不连续，会产生大量的驻波和反射。<br> 阻抗匹配电阻120R。</p> 
<h4>
<a id="485_797"></a>你这个项目485主从机如何地址码如何实现，通讯如何识别？</h4> 
<p>答：目标地址（收件人地址）+本机地址（寄件人地址）。</p> 
<h4>
<a id="LCD_800"></a>LCD屏是多大？啥通讯协议？</h4> 
<p>答：4.3寸（240x320 RGB），用的是8080通讯协议。支持I2C、SPI。</p> 
<h4>
<a id="80806800__803"></a>8080、6800 通讯有几个线，通讯协议是啥？有啥区别？</h4> 
<p>答：8个双向数据线（DB0~DB7），5个控制线，共计13个。8080、6800通讯类似。</p> 
<blockquote> 
 <p>控制线：</p> 
 <ul>
<li>复位（/RES）</li>
<li>数据/命令 选择（Ｄ/Ｉ）</li>
<li>片选（CS）</li>
<li>1). 8080: 读使能（/RD）; 写使能（/WR）<br> 2). 6800: 总使能（E）; 读/写选择（R/W）</li>
</ul> 
</blockquote> 
<blockquote> 
 <p>8080 通讯协议</p> 
 <ul>
<li>1.选择 数据/命令。</li>
<li>2.读、写 禁止。</li>
<li>3.片选。</li>
<li>4.读/写 使能。</li>
<li>5.读/写 数据。</li>
<li>6.读/写 禁止。</li>
<li>7.片选 取消。</li>
</ul> 
</blockquote> 
<blockquote> 
 <p>6800 通讯协议</p> 
 <ul>
<li>1.选择 数据/命令。</li>
<li>2.读/写 选择。</li>
<li>3.片选。</li>
<li>4.使能。</li>
<li>5.读/写 数据。</li>
<li>6.禁止。</li>
<li>7.片选 取消。</li>
</ul> 
</blockquote> 
<h4>
<a id="I2C_830"></a>I2C通讯有几个线，通讯协议是啥？</h4> 
<p>答：2线</p> 
<h4>
<a id="SPI_833"></a>SPI通讯有几个线，通讯协议是啥？</h4> 
<p>答：SPI有3/4线（区别 有无 主输入线）<br> 四种模式，时钟极性、相位两种情况。</p> 
<h4>
<a id="NorFlash__NandFlash__837"></a>NorFlash 与 NandFlash 有啥区别？如何选型？</h4> 
<p>答：</p> 
<table>
<thead><tr>
<th>区别项</th>
<th>NOR Flash</th>
<th>NAND FLASH</th>
</tr></thead>
<tbody>
<tr>
<td>擦写速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>耐用性</td>
<td>擦次数少(10万次)</td>
<td>擦次数多(100万次)</td>
</tr>
<tr>
<td>容量和成本</td>
<td>容量小(1MB~32MB),贵</td>
<td>容量大(16MB~512MB),便宜</td>
</tr>
<tr>
<td>易用性</td>
<td>接口和RAM一样，一次可读一个字节，可直接在上面运行代码</td>
<td>接口使用I/O口来串行访问，一次读512字节，不可直接运行代码，必须先写入驱动程序，才可以继续执行其他的操作。</td>
</tr>
<tr>
<td>主要用途</td>
<td>常用于 保存代码 和 关键数据</td>
<td>用于 保存数据</td>
</tr>
</tbody>
</table> 
<p>根据用途选型。</p> 
<h4>
<a id="MCU__849"></a>MCU 如何选型？</h4> 
<blockquote> 
 <ul>
<li>统计有项目哪些外设</li>
<li>确定外设的供电范围及通讯电平</li>
<li>确定外设IO的种类(中断、PWM、ADC、ADC、通讯)</li>
<li>确定外设的IO数量</li>
<li>统计外设占用的内存和flash大小</li>
<li>再依据成本、交货周期、采购难易、流通性</li>
</ul> 
</blockquote> 
<h4>
<a id="MOS__857"></a>MOS管 如何选型？</h4> 
<blockquote> 
 <ul>
<li>确定N、P沟道的选择<br> 当MOS管接地，负载连接到干线时，构成了低压侧开关，应采用 N沟道MOS管。<br> 当MOS管连接到干线，负载接地时，构成了高压侧开关，常采用 P沟道MOS管。</li>
<li>确定电压（1.5倍）</li>
<li>确定电流</li>
<li>确定开关性能</li>
<li>确定热要求（RDS(ON)）</li>
<li>封装因素考量</li>
<li>品牌（品牌代表性能差异、流通性、成本等等）<br> N管:2N7002<br> P管:AO3401A</li>
</ul> 
</blockquote> 
<h4>
<a id="__870"></a>三极管 如何选型？</h4> 
<blockquote> 
 <ul>
<li>根据电路确定 N管、P管</li>
<li>确定电压（1.5倍）</li>
<li>确定电流</li>
<li>确定开关性能</li>
<li>确定热要求（RDS(ON)）</li>
<li>封装因素考量</li>
<li>品牌（品牌代表性能差异、流通性、成本等等）<br> N管:8050（40V）、3904<br> P管:8550（40V）、3906</li>
</ul> 
</blockquote> 
<h4>
<a id="__881"></a>可控硅管 如何选型？</h4> 
<h4>
<a id="ARM_CortexM3M4___883"></a>ARM Cortex-M3/M4 内核有多少 寄存器？</h4> 
<p>答：16个寄存器（R0‐R15）。其中 13个 通用寄存器（R0‐R12），3个 特殊用途寄存器( R13(SP)、R14(LR)、R15(PC) )</p> 
<blockquote> 
 <p><mark>堆栈指针 R13(SP)</mark><br> CM4 处理器内核中共有两个堆栈指针，共用R13，同一时刻只能用一个。</p> 
 <ul>
<li>
<mark>主堆栈指针（MSP），或写作 SP_main</mark>。这是缺省的堆栈指针，它由 OS 内核、异常服务例程以及所有需要特权访问的应用程序代码来使用。</li>
<li>
<mark>进程堆栈指针（PSP），或写作 SP_process</mark>。用于常规的应用程序代码（不处于异常服用例程中时）。</li>
</ul> 
</blockquote> 
<blockquote> 
 <p><mark>连接寄存器 R14(LR)</mark><br> 用于在调用子程序时存储返回地址。只有一级调用就不用入栈。</p> 
</blockquote> 
<blockquote> 
 <p><mark>程序计数器 R15(PC)</mark><br> R15 是 程序计数器，是用于存放下一条指令所在的地址。</p> 
</blockquote> 
<h4>
<a id="ARM_CortexM3M4___896"></a>ARM Cortex-M3/M4 内核有多少 特殊功能寄存器组？</h4> 
<blockquote> 
 <p>5个</p> 
 <ul>
<li>程序状态 寄存器组（PSRs 或曰 xPSR）</li>
<li>中断屏蔽 寄存器组（PRIMASK, FAULTMASK,以及 BASEPRI）</li>
<li>控制 寄存器（CONTROL）</li>
</ul> 
</blockquote> 
<h4>
<a id="HardFault_902"></a>HardFault死机如何查找？如何调试？</h4> 
<p>答：<br> 1、堆栈溢出<br> 2、内存溢出或访问越界</p> 
<p>第一种方法，在线调试，通过MDK窗口查找发生死机的位置。<br> Step1：找出SP地址。<br> “CPU register”窗口查看LR寄存器B2值（0-MSP；1-PSP），判断SP是MSP(主)还是PSP(进程)，复制SP地址。<br> Step2：找出PC地址。<br> 在memory窗口，输入SP的地址，找到死机前压栈的8个寄存器（压栈依次为 xPSR、PC、LR、R12以及 R3~R0），当前SP地址往大数第7个是死机前PC地址。<br> Step3：找出代码行数。<br> 在反汇编窗口，输入PC地址，就能找到死机前代码的位置。</p> 
<p>第二种方法，离线调试，增加代码，打印发生死机的位置。<br> 目前没用过。</p> 
<h4>
<a id="BUG_918"></a>如果在客户现场出现BUG，不拆机如何查找解决问题？</h4> 
<p>答：要有整体局部意识。<br> 1）、分析问题触发条件和环境；<br> 2）、复现问题；<br> 3）、根据问题现象和环境条件，确认分类类型（比如：电磁环境，硬件问题，软件问题）；<br> 4）、根据根据问题类别制定查找方案，并找到问题；<br> 5）、解决问题，并测试；<br> 6）、还原问题，验证问题点和解决方案是对的；</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>