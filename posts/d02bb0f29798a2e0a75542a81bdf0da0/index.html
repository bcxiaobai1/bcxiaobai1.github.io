<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【Java 基础语法】详解 Java 中的泛型 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java 基础语法】详解 Java 中的泛型</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <p><strong>前言：</strong></p> 
<blockquote> 
 <p>泛型的知识其实在前面 <a href="https://blog.csdn.net/weixin_51367845/article/details/120818850">Java 的泛型和包装类</a> 这章介绍过了一些，但那些知识是为后面介绍 Java 集合框架做的铺垫，而今天这章再配合之前那章，将会完整的介绍 Java 中的泛型！</p> 
</blockquote> 
<p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#1__5">1. 前章回顾</a></li>
<li>
<ul>
<li><a href="#11__7">1.1 泛型类的代码示例</a></li>
<li><a href="#12__53">1.2 泛型类的意义</a></li>
<li><a href="#13__60">1.3 泛型是如何编译的</a></li>
</ul>
  </li>
<li><a href="#2__72">2. 泛型类的定义</a></li>
<li>
<ul>
<li><a href="#21__74">2.1 语法</a></li>
<li><a href="#22__121">2.2 示例</a></li>
</ul>
  </li>
<li><a href="#3__147">3. 内部类</a></li>
<li>
<ul>
<li><a href="#31__149">3.1 概念</a></li>
<li><a href="#32__162">3.2 实例内部类</a></li>
<li><a href="#33__234">3.3 静态内部类</a></li>
<li><a href="#34__289">3.4 匿名内部类</a></li>
</ul>
  </li>
<li><a href="#4__351">4. 泛型类的使用</a></li>
<li>
<ul>
<li><a href="#41__353">4.1 语法</a></li>
<li><a href="#42__361">4.2 示例</a></li>
<li><a href="#43_Type_Inference_369">4.3 类型推导（Type Inference）</a></li>
</ul>
  </li>
<li><a href="#5_Raw_Type_381">5. 裸类型（Raw Type）</a></li>
<li><a href="#6__401">6. 泛型类的类型边界</a></li>
<li>
<ul>
<li><a href="#61__403">6.1 概念</a></li>
<li><a href="#62__411">6.2 语法</a></li>
<li><a href="#63__423">6.3 示例</a></li>
</ul>
  </li>
<li><a href="#7__493">7. 类型擦除</a></li>
<li>
<ul>
<li><a href="#71__495">7.1 概念</a></li>
<li><a href="#72__510">7.2 示例</a></li>
</ul>
  </li>
<li><a href="#8_Wildcards_530">8. 通配符的使用（Wildcards）</a></li>
<li>
<ul>
<li><a href="#81__532">8.1 引入</a></li>
<li><a href="#82__566">8.2 通配符——上界</a></li>
<li><a href="#83__596">8.3 通配符——下界</a></li>
</ul>
  </li>
<li><a href="#9__626">9. 泛型中的父子类型</a></li>
<li><a href="#10__640">10. 泛型方法</a></li>
<li>
<ul>
<li><a href="#101__642">10.1 语法</a></li>
<li><a href="#102__652">10.2 示例</a></li>
<li><a href="#103_Type_Inference_686">10.3 类型型推导（Type Inference）</a></li>
</ul>
  </li>
<li><a href="#11__707">11. 泛型的限制</a></li>
</ul>
</div>
<p></p> 
<h1>
<a id="1__5"></a>1. 前章回顾</h1> 
<h2>
<a id="11__7"></a>1.1 泛型类的代码示例</h2> 
<p>在之前那章我们介绍了泛型类的基本定义，这里我们直接来创建并使用一个使用了泛型的栈来回顾泛型的定义</p> 
<pre><code class="prism language-java"><span class="token comment">// 出现的 &lt;T&gt; 就表示当前的类是一个泛型类，T 是一个占位符</span>
<span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elem<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> usedSize<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token comment">// 入栈（不考虑栈满）</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">T</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 出栈（不考虑栈空）</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestDemo</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> val<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 结果为：2 和 Stack@1b6d3586</span>
</code></pre> 
<p><strong>注意：</strong> 上述代码的构造方法为什么代码块是这样的：<code>this.elem=(T[])new Object[10];</code></p> 
<blockquote> 
 <ul>
<li>如果写成 <code>this.elem=new T[10];</code>，那么我们在编译时根本不知道具体的类型是什么，因此不能直接使用泛型去实例化对象</li>
<li>使用上述方式可以的原因是：此时发生了泛型的<strong>擦除机制</strong>，即将泛型 T 擦除为 Object，从而此时的泛型具有了 Object 的特质，所以如果写成这样 <code>this.elem=new T[10];</code> 就等价于代码是这样的 <code>this.elem=new Object[10];</code>
</li>
<li>但是我们想要的是一个非 Object 类型的不通用的数组，即后期不需要进行强制类型转换，故在擦除机制的前提下我们就可以写成 <code>this.elem=(T[])new Object[10];</code>
</li>
</ul> 
</blockquote> 
<h2>
<a id="12__53"></a>1.2 泛型类的意义</h2> 
<blockquote> 
 <ul>
<li>
<strong>自动进行类型的检查</strong>，如：在编译期间会根据指定泛型的信息来检查你插入的值是否匹配，检查完后泛型的信息就被擦除了</li>
<li>
<strong>自动进行类型的转换</strong>，如：只要我们使用了泛型，就可以在创建某个具体类型的实例的时候不必要进行强制类型转换</li>
</ul> 
</blockquote> 
<h2>
<a id="13__60"></a>1.3 泛型是如何编译的</h2> 
<blockquote> 
 <ul>
<li>泛型是编译期间的一种机制，即<strong>擦除机制</strong>
</li>
<li>擦除机制指的是：在编译的时候将泛型 T，擦除为了 Object（此时所有的泛型信息都被擦除了，在生成的 Java 字节码中是不包含泛型重点类型信息的）</li>
</ul> 
</blockquote> 
<p><strong>证明方式：</strong></p> 
<blockquote> 
 <ul>
<li>如果不重写 <code>toString</code> 方法，输出某个类的实例化对象，结果为：<code>类型@对象地址</code>
</li>
<li>而上述代码的打印结果为：<code>Stack@1b6d3586</code>，而不是 <code>Stack&lt;Integer&gt;@1b6d3586</code>，即泛型的的信息在编译期间就被擦除了</li>
</ul> 
</blockquote> 
<h1>
<a id="2__72"></a>2. 泛型类的定义</h1> 
<h2>
<a id="21__74"></a>2.1 语法</h2> 
<ul>
<li> <p>一个类型形参</p> <pre><code class="prism language-java"><span class="token keyword">class</span> 泛型类名称<span class="token operator">&lt;</span>类型形参<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 该代码块中可以直接使用类型参数</span>
<span class="token punctuation">}</span>
</code></pre> </li>
<li> <p>多个类型形参</p> <pre><code class="prism language-java"><span class="token keyword">class</span> 泛型类名称<span class="token operator">&lt;</span>类型形参<span class="token number">1</span><span class="token punctuation">,</span> 类型形参<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> 类型形参n<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 该代码块中可以直接使用所有类型参数</span>
<span class="token punctuation">}</span>
</code></pre> </li>
<li> <p>泛型类可以继承类（包括泛型类）</p> <pre><code class="prism language-java"><span class="token keyword">class</span> 泛型类名称<span class="token operator">&lt;</span>类型形参<span class="token operator">&gt;</span> <span class="token keyword">extends</span> 父类名称<span class="token operator">&lt;</span>类型形参<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 该代码块中可以直接使用所有类型参数</span>
<span class="token punctuation">}</span>
</code></pre> </li>
<li> <p>泛型类可以是一个接口</p> <pre><code class="prism language-java"><span class="token keyword">interface</span> 泛型类名称<span class="token operator">&lt;</span>类型形参<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 该代码块中可以直接使用类型参数</span>
<span class="token punctuation">}</span>
</code></pre> </li>
</ul> 
<p><strong>常用类型形参：</strong> 类型形参一般使用一个大写字母表示，常有名称如下</p> 
<blockquote> 
 <ul>
<li>
<code>E</code>：表示 Element，即元素，运用在集合中</li>
<li>
<code>K</code>：表示 Key，即键</li>
<li>
<code>V</code>：表示 Value，即值</li>
<li>
<code>N</code>：表示 Number，即数值类型</li>
<li>
<code>T</code>：表示 Type，即 Java 类型</li>
<li>
<code>?</code> ：表示不确定的 Java 类型</li>
</ul> 
</blockquote> 
<h2>
<a id="22__121"></a>2.2 示例</h2> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elem<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> usedSize<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token comment">// 入栈（不考虑栈满）</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">T</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 出栈（不考虑栈空）</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h1>
<a id="3__147"></a>3. 内部类</h1> 
<h2>
<a id="31__149"></a>3.1 概念</h2> 
<blockquote> 
 <p>定义在类内部的类叫做内部类</p> 
</blockquote> 
<p><strong>分类：</strong></p> 
<blockquote> 
 <ul>
<li>本地内部类：定义在方法里面的类，很少见</li>
<li>实例内部类：指没有用 static 修饰的内部类，有的地方也称为非静态内部类</li>
<li>静态内部类：指使用 static 修饰的内部类</li>
<li>匿名内部类：是没有名字的内部类</li>
</ul> 
</blockquote> 
<h2>
<a id="32__162"></a>3.2 实例内部类</h2> 
<p><strong>示例代码：</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">OuterClass</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 在外部类中成员变量都是可以正常定义的</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> data1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> data2<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> data3<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 定义实例内部类</span>
    <span class="token keyword">class</span> <span class="token class-name">InnerClass</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> data4<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
        <span class="token comment">// 实例内部类中静态变量无法定义</span>
        <span class="token comment">// public static int data5=5;	该变量无法定义</span>
        <span class="token comment">// 但是增加一个 final 就可以定义了</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> data5<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> data6<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>
        
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是一个实力内部类的 func 方法，也可以正常定义"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data2<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data3<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data4<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data5<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data6<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>结论1：</strong> 在实例内部类当中，是不可以定义一个静态的成员变量</p> 
<blockquote> 
 <p>因为实例内部类的调用是需要依赖对象的，而 static 修饰的成员是静态的，是不依赖对象的，就如普通的方法中定义静态的变量也是不行的</p> 
</blockquote> 
<p><strong>结论2：</strong> 如果加一个 final，那么就可以在实例内部类中使用 static</p> 
<blockquote> 
 <p>因为此时表示的是常量了，而常量在编译期间就已经确定了</p> 
</blockquote> 
<p><strong>结论3：</strong> 实例化实例内部类的方式是：先实例化外部类，再通过下面第二行代码的形式去实例化</p> 
<pre><code class="prism language-java"><span class="token class-name">OuterClass</span> outerClass<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">OuterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">OuterClass<span class="token punctuation">.</span>InnerClass</span> innerClass<span class="token operator">=</span>outerClass<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>结论4：</strong> 实例内部类中的方法也可以调用外部类的一些成员变量</p> 
<pre><code class="prism language-java">innerClass<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 结果为：</span>
<span class="token comment">// 这是一个实力内部类的 func 方法，也可以正常定义</span>
<span class="token comment">// 1 2 3 4 5 6</span>
</code></pre> 
<p><strong>结论5：</strong> 如果实例内部类中定义的变量名和外部类中的某个变量名相同，那么实例内部类默认调用的是内部类的变量。即使用 this，也表示的是此时内部类的对象，如果要使用外部类的同名变量，则可以通过：<code>外部类名.this.外部类变量名</code> 来调用</p> 
<p><strong>结论6：</strong> 当我们去我们看我们定义的静态内部类的字节码文件时，它其实是这样的<img src="https://images2.imgbox.com/28/36/fORNIl6J_o.png" alt="在这里插入图片描述"></p> 
<p><strong>应用：</strong></p> 
<blockquote> 
 <p>比如我们自己创建链表时，Node 节点是定义在 LinkedList 类外部的，但是可以将 Node 类写成它的一个实例内部类</p> 
</blockquote> 
<h2>
<a id="33__234"></a>3.3 静态内部类</h2> 
<p><strong>示例代码：</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">OuterClass</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 在外部类中成员变量都是可以正常定义的</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> data1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> data2<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> data3<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 定义静态内部类</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> data4<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> data5<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> data6<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>
        
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是一个实力内部类的 func 方法，也可以正常定义"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data2<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data3<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data4<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data5<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data6<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>结论1：</strong> 以下是实例化静态内部类的方法，相比实例内部类，它不需要外部类去创建对象</p> 
<pre><code class="prism language-java"><span class="token class-name">OuterClass<span class="token punctuation">.</span>InnerClass</span> innerClass<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">OuterClass<span class="token punctuation">.</span>InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>结论2：</strong> 在静态内部类当中，不能调用外部类的普通成员变量</p> 
<blockquote> 
 <p>因为普通成员变量需要靠外部类的对象来调用</p> 
</blockquote> 
<p><strong>结论3：</strong> 如果要想在静态内部类中调用外部类的普通成员变量，则可以在静态内部类当中实例化一个外部类的对象，通过这个引用就可以访问外部类的普通成员变量</p> 
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">OuterClass</span> out<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">OuterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span>data1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>结论4：</strong> 当内部类和外部类有同名的静态变量时，默认调用的是内部类本身的。要想调用外部类的，则可以通过：<code>外部类名.变量名</code> 来使用</p> 
<h2>
<a id="34__289"></a>3.4 匿名内部类</h2> 
<p><strong>实例代码：</strong></p> 
<p>不使用匿名内部类来实现抽象方法</p> 
<pre><code class="prism language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"eat something"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 结果为：eat something</span>
</code></pre> 
<p>如果上述 Child 类只使用一次，那么单独写一个类出来就比较麻烦，所以可以使用匿名内部类</p> 
<pre><code class="prism language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"eat something"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 结果为：eat something</span>
</code></pre> 
<p><strong>结论1：</strong> 由于没有名字，所以匿名内部类只能使用一次</p> 
<p><strong>结论2：</strong> 使用匿名内部类的前提是：必须继承一个父类或实现一个接口</p> 
<p><strong>结论3：</strong> 匿名内部类的形式就是直接在声明的对象后面接一个大括号，里面就写该类需要使用的内容</p> 
<p><strong>应用：</strong></p> 
<blockquote> 
 <p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承 Thread 类或是继承 Runnable 接口</p> 
</blockquote> 
<h1>
<a id="4__351"></a>4. 泛型类的使用</h1> 
<h2>
<a id="41__353"></a>4.1 语法</h2> 
<pre><code class="prism language-java">泛型类<span class="token operator">&lt;</span>类型实参<span class="token operator">&gt;</span> 变量名 <span class="token operator">=</span> <span class="token keyword">new</span> 泛型类<span class="token operator">&lt;</span>类型实参<span class="token operator">&gt;</span><span class="token punctuation">(</span>构造方法实参<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2>
<a id="42__361"></a>4.2 示例</h2> 
<pre><code class="prism language-java"><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2>
<a id="43_Type_Inference_369"></a>4.3 类型推导（Type Inference）</h2> 
<blockquote> 
 <p>当编译器可以根据上下文推导出类型实参时，可以省略类型实参的填写</p> 
</blockquote> 
<p>上述示例就可以省略后面一个类型实参</p> 
<pre><code class="prism language-java"><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h1>
<a id="5_Raw_Type_381"></a>5. 裸类型（Raw Type）</h1> 
<p><strong>概念：</strong></p> 
<blockquote> 
 <p>裸类型是一个泛型类但没有带着类型参数</p> 
</blockquote> 
<p><strong>示例：</strong> 上述代码创建的泛型类 <code>Stack&lt;T&gt;</code> ，如果将 <code>Stack</code> 单拿出来不加 <code>&lt;T&gt;</code> 去使用的话，那么它就是一个裸类型，我们可以直接使用它去实例化对象</p> 
<pre><code class="prism language-java"><span class="token class-name">Stack</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>注意：</strong></p> 
<blockquote> 
 <p>我们不要自己去使用裸类型，裸类型是为了兼容老版本的 API 保留的机制。如果使用他的话，就跟不用泛型没两样了，泛型的作用和意义也就没了</p> 
</blockquote> 
<h1>
<a id="6__401"></a>6. 泛型类的类型边界</h1> 
<h2>
<a id="61__403"></a>6.1 概念</h2> 
<blockquote> 
 <p>在定义泛型类时，有时需要对传入的类型参数做一定的约束，可以通过<strong>类型边界</strong>来约束</p> 
</blockquote> 
<p><strong>注意：</strong></p> 
<blockquote> 
 <p>泛型只有上界，没有下界</p> 
</blockquote> 
<h2>
<a id="62__411"></a>6.2 语法</h2> 
<pre><code class="prism language-java"><span class="token keyword">class</span> 泛型类名称<span class="token operator">&lt;</span>类型参数 <span class="token keyword">extends</span> 类型边界<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span>
    
<span class="token punctuation">}</span>
</code></pre> 
<p>上述泛型类可以传入的类型参数必须是类型边界的类或者子类</p> 
<h2>
<a id="63__423"></a>6.3 示例</h2> 
<p><strong>示例一：</strong> 让泛型参数只接受数值类 Number 的子类型</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    
<span class="token punctuation">}</span>
</code></pre> 
<p>故此时泛型参数传 Integer 是可以的，但传 String 是不行的</p> 
<pre><code class="prism language-java"><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> l1<span class="token punctuation">;</span>	<span class="token comment">// 正确，因为 Integer 是 Number 的子类型</span>
<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> l2<span class="token punctuation">;</span>	<span class="token comment">// 编译错误，因为 String 不是 Number 的子类型</span>
</code></pre> 
<p><strong>示例二：</strong> 写一个泛型类 Algorithm，我们要这个类中有一个方法可以实现找到数组的最大值</p> 
<ul>
<li> <p>其实我自己的第一想法，就是写成这样</p> <pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Algorithm</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">findMax</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">T</span> max<span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>max<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                max<span class="token operator">=</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    	<span class="token keyword">return</span> max<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <blockquote> 
   <p>但是报错了，自己一想估摸是泛型参数其实是类类型，即大小比较的是引用值，那么估摸要使用 Comparable 接口或者 Comparator 接口<img src="https://images2.imgbox.com/ac/f1/RMngT6Kx_o.png" alt="在这里插入图片描述"></p> 
  </blockquote> </li>
<li> <p>那么我就直接用 compareTo 方法，但是发现使用不了，原因如下</p> 
  <blockquote> 
   <p>这是由于类型擦除，使得这个 T 被擦除成了 Object，而我们知道 Object 是所有类的祖先类，他是不继承任何类或者接口的。故 compareTo 方法就使用不了</p> 
  </blockquote> </li>
<li> <p>为此，我们就有了这样的写法</p> <pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Algorithm</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">findMax</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">T</span> max<span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                max<span class="token operator">=</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> max<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <blockquote> 
   <p>这里使用了类型边界来进行了一个约束，代表在进行擦除时，擦除到了 Comparable 接口的地方。通俗点讲，就是这样写，那么这个 T 就一定要实现 Comparable 接口，并且擦除时不会擦除成 Object，而是擦除成了 Comparable</p> 
  </blockquote> </li>
</ul> 
<p><strong>问题：</strong> 示例二继承了 Comparable 接口为什么没有重写 compareTo 方法？</p> 
<blockquote> 
 <p>因为我们要传入的参数类型是本身一定要实现 Comparable 这个接口的，既然本身已经实现了，那么 compareTo 这个方法在这个参数类型中就得到了重写</p> 
</blockquote> 
<h1>
<a id="7__493"></a>7. 类型擦除</h1> 
<h2>
<a id="71__495"></a>7.1 概念</h2> 
<blockquote> 
 <ul>
<li>泛型是作用在编译期间的一种机制，实际上运行上是没有这么多类的，那么运行期间是什么类型呢？这就是类型擦除所作的事情</li>
<li>类型擦除主要以其类型边界而定</li>
</ul> 
</blockquote> 
<p><strong>补充：</strong> 编译器在类型擦除阶段所做什么？</p> 
<blockquote> 
 <ol>
<li>将类型变量用擦除后的类型替换</li>
<li>加入必要的类型转换语句</li>
<li>加入必要的 <code>bridge method</code> 保证多态的正确性</li>
</ol> 
</blockquote> 
<h2>
<a id="72__510"></a>7.2 示例</h2> 
<p><strong>示例一：</strong> 擦除后为 Object</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>示例二：</strong> 擦除后为类型边界（这里是 Comparable）</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    
<span class="token punctuation">}</span>
</code></pre> 
<h1>
<a id="8_Wildcards_530"></a>8. 通配符的使用（Wildcards）</h1> 
<h2>
<a id="81__532"></a>8.1 引入</h2> 
<p>以下这个代码的目的是遍历顺序表</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述代码中我们使用了泛型，并且指定了它的类型参数是 T，故我们使用时这个方法已经知道它的类型是 T 了。而这个 T 是我们指定的，有时这个方法本身也不知道传入的这个顺序表的参数类型是什么？那该怎么写呢？</p> 
<p>这里就要使用到通配符 <code>?</code></p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 既然不知道具体类型，那么 static 后面也不需要加 &lt;T&gt; 了</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 由于不知道具体类型是什么，就使用 Object</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="82__566"></a>8.2 通配符——上界</h2> 
<p><strong>语法：</strong></p> 
<pre><code class="prism language-java"><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> 上界<span class="token operator">&gt;</span>
</code></pre> 
<p>表示可以传入的类型实参是上界类型的子类的任意类型</p> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-java"><span class="token comment">// Stack 对象中可以传入的类型实参是 Number 子类的任意类型的 Stack</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> stack<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    
<span class="token punctuation">}</span>

<span class="token comment">// 以下调用都是正确的</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 以下调用是编译错误的</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2>
<a id="83__596"></a>8.3 通配符——下界</h2> 
<p><strong>语法：</strong></p> 
<pre><code class="prism language-java"><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> 下界<span class="token operator">&gt;</span>
</code></pre> 
<p>表示可以传入的类型实参是下界类型的父类的任意类型</p> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-java"><span class="token comment">// Stack 对象中可以传入的类型实参是 Integer 父类的任意类型的 Stack</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token class-name">Super</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    
<span class="token punctuation">}</span>

<span class="token comment">// 以下调用都是正确的</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 以下调用是编译错误的</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h1>
<a id="9__626"></a>9. 泛型中的父子类型</h1> 
<p>我们知道 <code>Object</code> 是 <code>Number</code> 的父类型，<code>Number</code> 是 <code>Integer</code> 的父类型</p> 
<p>但是类如 <code>Stack&lt;Object&gt;</code> 就不是 <code>Stack&lt;Number&gt;</code> 的父类型， <code>Stack&lt;Number&gt;</code> 也不是 <code>Stack&lt;Integer&gt;</code> 的父类型。</p> 
<p><strong>因为泛型的参数类型不参与类型的组成</strong></p> 
<p><strong>如果要确定泛型的父子类型，则需要使用通配符</strong>，如</p> 
<p><code>Stack&lt;?&gt;</code> 是 <code>Stack&lt;? extends Number&gt;</code> 的父类型， <code>Stack&lt;? extends Number&gt;</code> 也是 <code>Stack&lt;Integer&gt;</code> 的父类型</p> 
<h1>
<a id="10__640"></a>10. 泛型方法</h1> 
<h2>
<a id="101__642"></a>10.1 语法</h2> 
<pre><code class="prism language-java">方法限定符 <span class="token operator">&lt;</span>类型形参列表<span class="token operator">&gt;</span> 返回值类型 方法名称<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="102__652"></a>10.2 示例</h2> 
<p><strong>示例一：</strong> 写一个泛型类 Algorithm，我们要这个类中有一个方法可以实现数组中两个值的交换，要求使用这个方法不需要实例化对象</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Algorithm</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token class-name">T</span> i<span class="token punctuation">,</span> <span class="token class-name">T</span> j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">T</span> tmp<span class="token operator">=</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>示例二：</strong> 写一个泛型类 Algorithm，我们要这个类中有一个方法可以实现找到数组的最大值，要求使用这个方法不需要实例化对象</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Algorithm</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">findMax</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">T</span> max<span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                max<span class="token operator">=</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> max<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="103_Type_Inference_686"></a>10.3 类型型推导（Type Inference）</h2> 
<blockquote> 
 <p>当编译器可以根据上下文推导出类型实参时，可以省略类型实参的填写</p> 
</blockquote> 
<p><strong>示例：<strong>通过</strong>示例</strong>中的示例二的 Algorithm 类，去找到数组的最大值</p> 
<pre><code class="prism language-java"><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 使用 &lt;Integer&gt; 表示我们要传入的值都是 Integer 类型的</span>
<span class="token class-name">Integer</span> ret<span class="token operator">=</span><span class="token class-name">Algorithm</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token function">findMax</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>但是由于我们通过上文可以判断这个值是 Integer 类型的，所以上述代码可以省略 <code>&lt;Integer&gt;</code></p> 
<pre><code class="prism language-java"><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> ret<span class="token operator">=</span><span class="token class-name">Algorithm</span><span class="token punctuation">.</span><span class="token function">findMax</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h1>
<a id="11__707"></a>11. 泛型的限制</h1> 
<blockquote> 
 <ul>
<li>泛型类型参数不支持基本数据类型</li>
<li>无法实例化泛型类型的对象</li>
<li>无法使用泛型类型声明静态的属性</li>
<li>无法使用 <code>instanceof</code> 判断带类型参数的泛型类型</li>
<li>无法创建泛型类型数组</li>
<li>无法 <code>create</code>、<code>catch</code>、<code>throw</code> 一个泛型类异常，即异常不支持泛型</li>
<li>泛型类型不是形参一部分，无法重载</li>
</ul> 
</blockquote>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>