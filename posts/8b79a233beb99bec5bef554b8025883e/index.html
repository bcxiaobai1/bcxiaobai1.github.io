<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>【SpringMVC】基于 Spring 的 Web 层MVC 框架 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【SpringMVC】基于 Spring 的 Web 层MVC 框架</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>?欢迎来到@边境矢梦°的csdn博文?</p> 
 <p>?本文主要梳理SpringMVC : 基于 Spring 的 Web 层MVC 框架 ?<br> ?我是边境矢梦°，一个正在为<a href="https://so.csdn.net/so/search?q=%E7%A7%8B%E6%8B%9B&amp;spm=1001.2101.3001.7020" title="秋招">秋招</a>和<a href="https://so.csdn.net/so/search?q=%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B&amp;spm=1001.2101.3001.7020" title="算法竞赛">算法竞赛</a>做准备的学生?<br> ?喜欢的朋友可以关注一下<strong>???</strong>，下次更新不迷路?</p> 
</blockquote> 
<blockquote> 
 <p>Ps: 月亮越亮说明知识点越重要 (<a href="https://so.csdn.net/so/search?q=%E9%87%8D%E8%A6%81%E6%80%A7&amp;spm=1001.2101.3001.7020" title="重要性">重要性</a>或者难度越大)?????    </p> 
</blockquote> 
<p></p> 
<p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%93%A2MVC%E6%A8%A1%E5%BC%8F-toc" style="margin-left:0px"><a href="#%F0%9F%93%A2MVC%E6%A8%A1%E5%BC%8F">?MVC模式</a></p> 
<p id="%F0%9F%93%8CMVC%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px"><a href="#%F0%9F%93%8CMVC%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">?MVC 的工作流程</a></p> 
<p id="%F0%9F%93%8CMVC%20%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:40px"><a href="#%F0%9F%93%8CMVC%20%E7%9A%84%E4%BC%98%E7%82%B9">?MVC 的优点</a></p> 
<p id="%F0%9F%93%8CMVC%20%E7%9A%84%E4%B8%8D%E8%B6%B3-toc" style="margin-left:40px"><a href="#%F0%9F%93%8CMVC%20%E7%9A%84%E4%B8%8D%E8%B6%B3">?MVC 的不足</a></p> 
<p id="%F0%9F%8E%89Spring%20MVC%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%BC%BA%E5%A4%A7%E7%9A%84Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-toc" style="margin-left:0px"><a href="#%F0%9F%8E%89Spring%20MVC%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%BC%BA%E5%A4%A7%E7%9A%84Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">?Spring MVC：构建强大的Web应用程序</a></p> 
<p id="%F0%9F%8E%84%E4%BB%80%E4%B9%88%E6%98%AFSpring%20MVC%EF%BC%9F-toc" style="margin-left:40px"><a href="#%F0%9F%8E%84%E4%BB%80%E4%B9%88%E6%98%AFSpring%20MVC%EF%BC%9F">?什么是Spring MVC？</a></p> 
<p id="%F0%9F%8E%84SpringMVC%E7%9A%84%E7%89%B9%E5%BE%81-toc" style="margin-left:40px"><a href="#%F0%9F%8E%84SpringMVC%E7%9A%84%E7%89%B9%E5%BE%81">?SpringMVC的特征</a></p> 
<p id="%F0%9F%8E%84Spring%20MVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:40px"><a href="#%F0%9F%8E%84Spring%20MVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">?Spring MVC的工作原理</a></p> 
<p id="%F0%9F%8C%88SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px"><a href="#%F0%9F%8C%88SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">?SpringMVC工作流程</a></p> 
<p id="%F0%9F%8E%84Spring%20MVC%20%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px"><a href="#%F0%9F%8E%84Spring%20MVC%20%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6">?Spring MVC 的常用组件</a></p> 
<p id="%F0%9F%8C%B8%40Controller%E5%92%8C%40RequestMapping%E6%B3%A8%E8%A7%A3-toc" style="margin-left:0px"><a href="#%F0%9F%8C%B8%40Controller%E5%92%8C%40RequestMapping%E6%B3%A8%E8%A7%A3">?@Controller和@RequestMapping注解</a></p> 
<p id="%F0%9F%8C%B3%40Controller%20%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B3%40Controller%20%E6%B3%A8%E8%A7%A3">?@Controller 注解</a></p> 
<p id="%F0%9F%8C%B3%40RequestMapping%20%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px"><a href="#%F0%9F%8C%B3%40RequestMapping%20%E6%B3%A8%E8%A7%A3">?@RequestMapping 注解</a></p> 
<p id="%F0%9F%8C%BB%40RequestMapping%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px"><a href="#%F0%9F%8C%BB%40RequestMapping%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">?@RequestMapping 注解的使用方式</a></p> 
<p id="%F0%9F%8C%BB%40RequestMapping%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px"><a href="#%F0%9F%8C%BB%40RequestMapping%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7">?@RequestMapping 注解的属性</a></p> 
<p id="%F0%9F%8C%BB%E6%94%AF%E6%8C%81%20Ant%20%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%B7%AF%E5%BE%84-toc" style="margin-left:80px"><a href="#%F0%9F%8C%BB%E6%94%AF%E6%8C%81%20Ant%20%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%B7%AF%E5%BE%84">?支持 Ant 风格的路径</a></p> 
<hr id="hr-toc"> 
<p><a href="http://c.biancheng.net/" title="C语言中文网：C语言程序设计门户网站(入门教程、编程软件) (biancheng.net)">C语言中文网：C语言程序设计门户网站(入门教程、编程软件) (biancheng.net)</a>   <span style="color:#fe2c24"><strong>学习笔记</strong></span></p> 
<div> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/0e/5e/0VEsqrGd_o.png" width="667"></p> 
</div> 
<h2 id="%F0%9F%93%A2MVC%E6%A8%A1%E5%BC%8F" style="background-color:transparent">?MVC模式</h2> 
<p> MVC 模式，全称为 Model-View-Controller（模型-视图-控制器）模式，它是一种软件架构模式，其目标是将软件的用户界面（即前台页面）和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。</p> 
<p>MVC 模式将应用程序划分成模型（Model）、视图（View）、控制器（Controller）等三层，如下图所示。<br>  </p> 
<p></p> 
<p class="img-center"><img alt="MVC 模式" height="284" src="https://images2.imgbox.com/b3/8c/1sBjXcly_o.png" width="762"></p> 
<table><tbody>
<tr>
<th>分层</th>
<th>描述</th>
</tr>
<tr>
<td>Model（模型）</td>
<td>它是应用程序的主体部分，主要由以下 2 部分组成： 
    <ul>
<li>实体类 Bean：专门用来存储业务数据的对象，它们通常与数据库中的某个表对应，例如 User、Student 等。</li>
<li>业务处理 Bean：指 Service 或 Dao 的对象，专门用于处理业务逻辑、数据库访问。</li>
</ul>
<br> 一个模型可以为多个视图（View）提供数据，一套模型（Model）的代码只需写一次就可以被多个视图重用，有效地减少了代码的重复性，增加了代码的可复用性。</td>
</tr>
<tr>
<td>View（视图）</td>
<td>指在应用程序中专门用来与浏览器进行交互，展示数据的资源。在 Web 应用中，View 就是我们常说的前台页面，通常由 HTML、JSP、CSS、JavaScript 等组成。</td>
</tr>
<tr>
<td>Controller（控制器）</td>
<td>通常指的是，应用程序的 Servlet。它负责将用户的请求交给模型（Model）层进行处理，并将 Model 层处理完成的数据，返回给视图（View）渲染并展示给用户。<br><br> 在这个过程中，Controller 层不会做任何业务处理，它只是 View（视图）层和 Model （模型）层连接的枢纽，负责调度 View 层和 Model 层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。</td>
</tr>
</tbody></table> 
<h3 id="%F0%9F%93%8CMVC%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" style="background-color:transparent">?MVC 的工作流程</h3> 
<p>MVC 的工作流程如下：</p> 
<ol>
<li>用户发送请求到服务器；</li>
<li>在服务器中，请求被控制层（Controller）接收；</li>
<li>Controller 调用相应的 Model 层处理请求；</li>
<li>Model 层处理完毕将结果返回到 Controller；</li>
<li>Controller 再根据 Model 返回的请求处理结果，找到相应的 View 视图；</li>
<li>View 视图渲染数据后最终响应给浏览器。</li>
</ol> 
<h3 id="%F0%9F%93%8CMVC%20%E7%9A%84%E4%BC%98%E7%82%B9" style="background-color:transparent">?MVC 的优点</h3> 
<p>MVC 模式具有以下优点：</p> 
<ul>
<li>
<strong>降低代码耦合性</strong>：在 MVC 模式中，三层之间相互独立，各司其职。一旦某一层的需求发生了变化，我们就只需要更改相应层中的代码即可，而不会对其他层中的代码造成影响。</li>
<li>
<strong>有利于分工合作</strong>：在 MVC 模式中，将应用系统划分成了三个不同的层次，可以更好地实现开发分工。例如，网页设计人员专注于视图（View）层的开发，而那些对业务熟悉的开发人员对 Model 层进行开发，其他对业务不熟悉的开发人员则可以对 Controller 层进行开发。</li>
<li>
<strong>有利于组件的重用</strong>：在 MVC 中，多个视图（View）可以共享同一个模型（Model），大大提高了系统中代码的可重用性。</li>
</ul> 
<h3 id="%F0%9F%93%8CMVC%20%E7%9A%84%E4%B8%8D%E8%B6%B3">?MVC 的不足</h3> 
<p>MVC 模式存在以下不足之处：</p> 
<ul><li>增加了系统结构和实现的复杂性：对于简单的应用，如果也严格遵循 MVC 模式，按照模型、视图与控制器对系统进行划分，无疑会增加系统结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li></ul> 
<ul>
<li>视图与控制器间的联系过于紧密：虽然视图与控制器是相互分离的，但它们之间联系却是十分紧密的。视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了它们的独立重用。</li>
<li>视图对模型数据的低效率访问：视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li>
</ul> 
<p><br> MVC 并不适合小型甚至中型规模的项目，花费大量时间将 MVC 应用到规模并不是很大的应用程序中，通常会得不偿失，因此对于 MVC 设计模式的使用要根据具体的应用场景来决定。</p> 
<hr> 
<h2 id="%F0%9F%8E%89Spring%20MVC%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%BC%BA%E5%A4%A7%E7%9A%84Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" style="background-color:transparent">?<strong style="color:#4f4f4f;font-size:24px;font-weight:bold">Spring MVC：构建强大的Web应用程序</strong>
</h2> 
<div> 
 <p>Spring MVC（Model-View-Controller）是Java世界中最流行的Web应用程序开发框架之一。它提供了一种<strong>结构化的方法</strong>来构建强大的Web应用程序，使开发人员能够<strong>轻松管理请求和响应</strong>、<strong>处理表单提交、进行验证以及与数据库进行交互</strong>。本文将深入探讨Spring MVC的核心概念和工作原理，帮助你更好地理解并利用这个强大的框架来构建Web应用程序。</p> 
 <hr> 
 <h3 id="%F0%9F%8E%84%E4%BB%80%E4%B9%88%E6%98%AFSpring%20MVC%EF%BC%9F">?什么是Spring MVC？</h3> 
 <p>Spring MVC（全称 Spring Web MVC）是 Spring 框架提供的一款基于 MVC 模式的轻量级 Web 开发框架，是 Spring 为表示层（UI）开发提供的一整套完备的解决方案。</p> 
 <ul><li>
<span style="color:#fe2c24"><strong>表示层（UI）</strong></span>：用来实现与用户的交互，接收用户请求，并将请求交给业务逻辑层（BLL）和数据访问层（DAL）进行处理，最后将处理结果返回给用户。</li></ul> 
 <ul>
<li>业务逻辑层（BLL）：起到承上启下的作用，接收表示层传递来的请求，并针对业务对数据进行处理，以实现业务目标。</li>
<li>数据访问层（DAL）：用于实现与数据库的交互和访问，例如从数据库中获取数据、保存或修改数据库中的数据等。</li>
</ul> 
 <p class="img-center"><img alt="三层架构" height="302" src="https://images2.imgbox.com/6d/0f/ou9KRtby_o.png" width="780"></p> 
 <p>Spring MVC 使用 MVC 架构模式的思想，将 Web 应用进行职责解构，把一个复杂的 Web 应用划分成模型（Model）、控制器（Contorller）以及视图（View）三层，有效地简化了 Web 应用的开发，降低了出错风险，同时也方便了开发人员之间的分工配合。</p> 
 <p>Spring MVC 各层的职责如下：</p> 
 <ul>
<li>Model：负责对请求进行处理，并将结果返回给 Controller；</li>
<li>View：负责将请求的处理结果进行渲染，展示在客户端浏览器上；</li>
<li>Controller：是 Model 和 View 交互的纽带；主要负责接收用户请求，并调用 Model 对请求处理，然后将 Model 的处理结果传递给 View。</li>
</ul> 
 <p>Spring MVC 本质是对 Servlet 的进一步封装，其最核心的组件是 DispatcherServlet，它是 Spring MVC 的前端控制器，主要负责对请求和响应的统一地处理和分发。Controller 接收到的请求其实就是 DispatcherServlet 根据一定的规则分发给它的。<br><br> Spring MVC 框架内部采用松耦合、可插拔的组件结构，具有高度可配置性，比起其他的 MVC 框架更具有扩展性和灵活性。此外，Spring MVC 的注解驱动（annotation-driven）和对 REST 风格的支持，也是它最具有特色的功能。 <br><br> Spring MVC 是 Spring 框架的众多子项目之一，自 Spring 框架诞生之日起就包含在 Spring 框架中了，它可以与 Spring 框架无缝集成，在性能方面具有先天的优越性。对于开发者来说，Spring MVC 的开发效率要明显高于其它的 Web 框架，因此 Spring MVC 在企业中得到了广泛的应用，成为目前业界最主流的 MVC 框架之一。</p> 
 <hr> 
 <h3 id="%F0%9F%8E%84SpringMVC%E7%9A%84%E7%89%B9%E5%BE%81">?SpringMVC的特征</h3> 
 <div> 
  <span style="color:#000000"><strong>1. SpringMVC </strong></span> 
  <span style="color:#000000"><strong>从易用性，效率上 比曾经流行的 </strong></span> 
  <span style="color:#000000"><strong>Struts2 </strong></span> 
  <span style="color:#000000"><strong>更好</strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#000000"><strong>2. SpringMVC </strong></span> 
  <span style="color:#000000"><strong>是 </strong></span> 
  <span style="color:#000000"><strong>WEB </strong></span> 
  <span style="color:#000000"><strong>层框架【解读</strong></span> 
  <span style="color:#000000"><strong>: </strong></span> 
  <span style="color:#fe2c24"><strong>SpringMVC 接管了 Web 层组件</strong></span> 
  <span style="color:#000000"><strong>, </strong></span> 
  <span style="color:#000000"><strong>比如控制器</strong></span> 
  <span style="color:#000000"><strong>, </strong></span> 
  <span style="color:#000000"><strong>视</strong></span> 
  <span style="color:#000000"><strong>图</strong></span> 
  <span style="color:#000000"><strong>, </strong></span> 
  <span style="color:#000000"><strong>视图解析</strong></span> 
  <span style="color:#000000"><strong>, </strong></span> 
  <span style="color:#000000"><strong>返回给用户的数据格式</strong></span> 
  <span style="color:#000000"><strong>, </strong></span> 
  <span style="color:#fe2c24"><strong>同时支持 MVC 的开发模式/开发架构(使用了web就会有)</strong></span> 
  <span style="color:#000000"><strong>】 </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#000000"><strong>3. SpringMVC </strong></span> 
  <span style="color:#000000"><strong>通过注解，让 </strong></span> 
  <span style="color:#000000"><strong>POJO </strong></span> 
  <span style="color:#000000"><strong>成为控制器，不需要继承类或者实现接口 </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#000000"><strong>4. SpringMVC </strong></span> 
  <span style="color:#000000"><strong>采用低耦合的组件设计方式，具有更好扩展和灵活性</strong></span> 
  <span style="color:#000000"><strong>. </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#000000"><strong>5. </strong></span> 
  <span style="color:#000000"><strong>支持 </strong></span> 
  <span style="color:#000000"><strong>REST </strong></span> 
  <span style="color:#000000"><strong>格式的 </strong></span> 
  <span style="color:#000000"><strong>URL </strong></span> 
  <span style="color:#000000"><strong>请求</strong></span> 
  <span style="color:#000000"><strong>. </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#000000"><strong>6. SpringMVC </strong></span> 
  <span style="color:#000000"><strong>是基于 </strong></span> 
  <span style="color:#000000"><strong>Spring </strong></span> 
  <span style="color:#000000"><strong>的</strong></span> 
  <span style="color:#000000"><strong>, </strong></span> 
  <span style="color:#000000"><strong>也就是 </strong></span> 
  <span style="color:#000000"><strong>SpringMVC </strong></span> 
  <span style="color:#000000"><strong>是在 </strong></span> 
  <span style="color:#000000"><strong>Spring </strong></span> 
  <span style="color:#000000"><strong>基础上的。</strong></span> 
  <span style="color:#000000"><strong>SpringMVC </strong></span> 
  <span style="color:#000000"><strong>的核</strong></span> 
  <span style="color:#000000"><strong>心包 </strong></span> 
  <span style="color:#000000"><strong>spring-webmvc-xx.jar </strong></span> 
  <span style="color:#000000"><strong>和 </strong></span> 
  <span style="color:#000000"><strong>spring-web-xx.jar </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#000000"><strong>梳理 </strong></span> 
  <span style="color:#000000"><strong>Spring SpringMVC SpringBoot </strong></span> 
  <span style="color:#000000"><strong>的关系 </strong></span> 
 </div> 
 <div> 
  <span style="color:#000000"><strong>1. Spring MVC </strong></span> 
  <span style="color:#000000"><strong>只是 </strong></span> 
  <span style="color:#000000"><strong>Spring </strong></span> 
  <span style="color:#000000"><strong>处理 </strong></span> 
  <span style="color:#000000"><strong>WEB </strong></span> 
  <span style="color:#000000"><strong>层请求的一个模块</strong></span> 
  <span style="color:#000000"><strong>/</strong></span> 
  <span style="color:#000000"><strong>组件</strong></span> 
  <span style="color:#000000"><strong>, Spring MVC </strong></span> 
  <span style="color:#000000"><strong>的基石是</strong></span> 
  <span style="color:#000000"><strong>Servlet[Java WEB] </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#000000"><strong>2. Spring Boot </strong></span> 
  <span style="color:#000000"><strong>是为了简化开发者的使用</strong></span> 
  <span style="color:#000000"><strong>, </strong></span> 
  <span style="color:#000000"><strong>推出的封神框架</strong></span> 
  <span style="color:#000000"><strong>(</strong></span> 
  <span style="color:#000000"><strong>约定优于配置，简化了 </strong></span> 
  <span style="color:#000000"><strong>Spring </strong></span> 
  <span style="color:#000000"><strong>的配置流程</strong></span> 
  <span style="color:#000000"><strong>), SpringBoot </strong></span> 
  <span style="color:#000000"><strong>包含很多组件</strong></span> 
  <span style="color:#000000"><strong>/</strong></span> 
  <span style="color:#000000"><strong>框架，</strong></span> 
 </div> 
 <div> 
  <span style="color:#000000"><strong>Spring</strong></span> 
  <span style="color:#000000"><strong>就是最核心的内容之一，也包含 </strong></span> 
  <span style="color:#000000"><strong>Spring</strong></span> 
  <span style="color:#000000"><strong>MVC </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <p><span style="color:#000000"><strong>3. </strong></span><span style="color:#000000"><strong>他们的关系大概是</strong></span><span style="color:#000000"><strong>: Spring Boot &gt; Spring &gt; Spring MVC</strong></span></p> 
  <p><img alt="" height="527" src="https://images2.imgbox.com/d6/30/oCxJsY9b_o.png" width="736"></p> 
 </div> 
 <hr> 
 <h3 id="%F0%9F%8E%84Spring%20MVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">?Spring MVC的工作原理</h3> 
 <p>Spring MVC的工作原理可以分为以下几个步骤：</p> 
 <ol>
<li> <p><strong>用户发送请求</strong>：当用户在浏览器中输入URL或单击链接时，请求被发送到Web应用程序的前端控制器（通常是<code>DispatcherServlet</code>）。</p> </li>
<li> <p><strong>DispatcherServlet处理请求</strong>：<code>DispatcherServlet</code>是Spring MVC的核心，它接收所有请求并负责将请求分派给适当的控制器。控制器的选择是基于请求的URL映射。</p> </li>
<li> <p><strong>控制器处理请求</strong>：选定的控制器（通常是一个带有<code>@Controller</code>注解的Spring组件）接收请求，并根据业务逻辑处理它。控制器可以访问模型、调用服务、验证数据等。</p> </li>
<li> <p><strong>控制器返回模型和视图</strong>：控制器处理请求后，它通常会返回一个模型（数据）和一个视图名称。模型包含要呈现给视图的数据。视图名称告诉<code>DispatcherServlet</code>要使用哪个视图来渲染响应。</p> </li>
<li> <p><strong>视图呈现响应</strong>：<code>DispatcherServlet</code>使用视图解析器来将视图名称解析为实际的视图对象（例如JSP或Thymeleaf模板）。视图使用模型中的数据来渲染响应，然后将其发送回客户端。</p> </li>
</ol> 
 <hr> 
 <h2 id="%F0%9F%8C%88SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">?SpringMVC工作流程</h2> 
 <p></p> 
 <p class="img-center"><img alt="" height="484" src="https://images2.imgbox.com/6f/45/JCfuqBbm_o.png" width="621"></p> 
 <p style="text-align:center"><br> Spring MVC 工作流程</p> 
 <br> SpringMVC 的执行流程如下。 
 <ol>
<li>用户通过浏览器发起一个 HTTP 请求，该请求会被 DispatcherServlet（前端控制器）拦截；</li>
<li>DispatcherServlet 调用 HandlerMapping（处理器映射器）找到具体的处理器（Handler）及拦截器，最后以 HandlerExecutionChain 执行链的形式返回给 DispatcherServlet。</li>
<li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；</li>
<li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（即 Controller 控制器）对请求进行处理；</li>
<li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC 的底层对象，包括 Model 数据模型和 View 视图信息）；</li>
<li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；</li>
<li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；</li>
<li>ViewResolver 解析完成后，会将 View 视图并返回给 DispatcherServlet；</li>
<li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；</li>
<li>视图负责将结果显示到浏览器（客户端）。</li>
</ol> 
 <hr> 
 <h3 id="%F0%9F%8E%84Spring%20MVC%20%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6">?Spring MVC 的常用组件</h3> Spring MVC 的常用组件如下表。 
 <br>   
 <table><tbody>
<tr>
<th>组件</th>
<th>提供者</th>
<th>描述</th>
</tr>
<tr>
<td>DispatcherServlet</td>
<td>框架提供</td>
<td>前端控制器，它是整个 Spring MVC 流程控制中心，负责统一处理请求和响应，调用其他组件对用户请求进行处理。</td>
</tr>
<tr>
<td>HandlerMapping</td>
<td>框架提供</td>
<td>处理器映射器，根据请求的 url、method 等信息查找相应的 Handler。</td>
</tr>
<tr>
<td>Handler</td>
<td>开发人员提供</td>
<td>处理器，通常被称为 Controller（控制器）。它可以在 DispatcherServlet 的控制下，对具体的用户请求进行处理。</td>
</tr>
<tr>
<td>HandlerAdapter</td>
<td>框架提供</td>
<td>处理器适配器，负责调用具体的控制器方法，对用户发来的请求来进行处理。</td>
</tr>
<tr>
<td>ViewResolver</td>
<td>框架提供</td>
<td>视图解析器，其职责是对视图进行解析，得到相应的视图对象。常见的视图解析器有 ThymeleafViewResolver、InternalResourceViewResolver 等。</td>
</tr>
<tr>
<td>View</td>
<td>开发人员提供</td>
<td>视图，它作用是将模型（Model）数据通过页面展示给用户。</td>
</tr>
</tbody></table> 
</div> 
<h2 id="%F0%9F%8C%B8%40Controller%E5%92%8C%40RequestMapping%E6%B3%A8%E8%A7%A3" style="background-color:transparent">?@Controller和@RequestMapping注解</h2> 
<p>从 Java 5 开始，Java 就增加了对注解（Annotation）的支持，它是代码中的一种<strong>特殊标记</strong>，<span style="color:#fe2c24"><strong>可以在编译、加载和运行时被读取，执行相应的处理。</strong></span>通过注解，开发人员可以在不改变原有代码逻辑的情况下，<span style="color:#fe2c24"><strong>在代码中嵌入补充信息。</strong></span><br><br><strong>Spring 从 2.5 版本开始提供了对注解技术的全面支持，以替换传统的 XML 配置，简化 Spring 的配置。</strong>作为 Spring 框架的一个子项目， Spring MVC 自然也提供了对注解的支持。<br><br> 在 Spring MVC 中有两个十分重要的注解，它们分别是 @Controller 和 @RequestMapping 。本节，我们就针对这两个重要 Spring MVC 注解进行讲解。</p> 
<h3 id="%F0%9F%8C%B3%40Controller%20%E6%B3%A8%E8%A7%A3">?@Controller 注解</h3> 
<p><span style="color:#fe2c24"><strong>@Controller 注解可以将一个普通的 Java 类标识成控制器（Controller）类</strong></span>，示例代码如下。</p> 
<pre><code class="language-java">package net.biancheng.controller;
import org.springframework.stereotype.Controller;
@Controller
public class IndexController {
    // 处理请求的方法
}</code></pre> 
<p>Spring MVC 是通过组件扫描机制查找应用中的控制器类的，为了保证控制器能够被 Spring MVC 扫描到，我们还需要在 Spring MVC 的配置文件中使用 <code>&lt;context:component-scan/&gt;</code> 标签，<span style="color:#fe2c24"><strong>指定控制器类的基本包（请确保所有控制器类都在基本包及其子包下）</strong></span>，示例代码如下。</p> 
<pre><code class="language-java">&lt;!-- 使用扫描机制扫描控制器类，控制器类都在net.biancheng.controller包及其子包下 --&gt;
&lt;context:component-scan base-package="net.biancheng.controller" /&gt;</code></pre> 
<h3 id="%F0%9F%8C%B3%40RequestMapping%20%E6%B3%A8%E8%A7%A3" style="background-color:transparent">?@RequestMapping 注解</h3> 
<p>@RequestMapping 注解是 Spring MVC 中最常被用到的注解之一。它通常被标注在控制器方法上，负责将请求与处理请求的控制器方法关联起来，建立映射关系。<br><br> Spring MVC 的前端控制器（DispatcherServlet）拦截到用户发来的请求后，会通过 @RequestMapping 注解提供的映射信息找到对应的控制器方法，对这个请求进行处理。</p> 
<h4 id="%F0%9F%8C%BB%40RequestMapping%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" style="background-color:transparent">?@RequestMapping 注解的使用方式</h4> 
<p>@RequestMapping <span style="color:#fe2c24"><strong>既可以标注在控制器类上，也可以标注在控制器方法上。</strong></span></p> 
<p><strong>1. 修饰方法</strong></p> 
<p>当 @RequestMapping  注解被标注在方法上时，value 属性值就表示访问该方法的 URL 地址。当用户发送过来的请求想要访问该 Controller 下的控制器方法时，<span style="color:#fe2c24"><strong>请求路径就必须与这个 value 值相同</strong></span>，示例代码如下。</p> 
<pre><code class="language-java">@Controller
public class HelloController {
    @RequestMapping("/login")
    public String welcome() {
        return "login";
    }
}</code></pre> 
<p><strong>2. 修饰类</strong></p> 
<p>当 @RequestMapping 注解标<span style="color:#fe2c24"><strong>注在控制器类上时</strong></span>，<span style="color:#fe2c24"><strong>value 属性的取值就是这个控制器类中的所有控制器方法 URL 地址的父路径</strong></span>。<span style="color:#fe2c24"><strong>也就是说，访问这个 Controller 下的任意控制器方法都需要带上这个父路径。</strong></span></p> 
<pre><code class="language-java">@Controller
@RequestMapping(value = "/springmvc")
public class HelloController {
    @RequestMapping("/login")
    public String welcome() {
        return "login";
    }
}</code></pre> 
<p>例如，在上面的控制类中，用户想要访问 HelloController 中的 welcome() 方法，<strong>请求的地址就必须带上父路径“/springmvc”，即请求地址必须为“/springmvc/login”。</strong></p> 
<h4 id="%F0%9F%8C%BB%40RequestMapping%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7" style="background-color:transparent">?@RequestMapping 注解的属性</h4> 
<p>@RequestMapping 注解中提供了多个可用属性，下面我们就对其中几个比较常用的属性进行介绍。</p> 
<p>?<span style="color:#fe2c24"><strong>1. value 属性</strong></span></p> 
<p>在 @RequestMapping 注解中，<span style="color:#fe2c24"><strong>value 属性用来设置控制器方法的请求映射地址</strong></span>。所有能够匹配到该请求映射地址的请求，都可以被该控制器方法处理，示例代码如下。</p> 
<pre><code class="language-java">@RequestMapping(value = "/register")</code></pre> 
<p><span style="color:#fe2c24"><strong>value 属性是 @RequestMapping 注解的默认属性，如果我们在 @RequestMapping 注解中只设置了一个 value 属性，则该属性名可以被省略</strong></span>，示例代码如下。</p> 
<ul><li> <pre><code class="language-java">//省略 value 属性名
@RequestMapping( "/register")</code></pre> <p>value 属性的取值<span style="color:#fe2c24"><strong>是一个字符串类型的数组</strong></span>，表示该控制器方法可以匹配多个请求地址。 </p> </li></ul> 
<pre><code class="language-java">@RequestMapping( value = {"/register", "/login"})
public String success() {
    return "success";
}</code></pre> 
<p style="background-color:transparent"><span style="color:#fe2c24">?<strong>2. name 属性</strong></span></p> 
<p><strong>name 属性相当于方法的注释</strong>，用于解释这个方法是用来干什么的，使方法更易理解。<br><br> 例如，下面的代码表示 getUsers() 方法是一个用来获取用户信息的控制器方法。</p> 
<pre><code class="language-java">@RequestMapping(value = "toUser",name = "获取用户信息")
public String getUsers() {
    ……
}</code></pre> 
<p style="background-color:transparent">?<span style="color:#fe2c24"><strong>3. method 属性</strong></span></p> 
<p>method 属性<span style="color:#fe2c24"><strong>用来设置控制器方法支持的请求方式</strong></span>。如果一个控制器方法没有设置 @RequestMapping 注解的 method 属性，则说明该控制器方法支持全部请求类型，可以处理所有类型的请求。<br><br> method 属性的取值是一个 RequestMethod 类型的数组，表示一个控制器方法支持多种方式的请求，常用的请求方式有 GET、POST、DELETE、PUT 等。<br><br> 例如，控制器方法只支持 GET 方式的请求，代码如下。</p> 
<pre><code class="language-java">@RequestMapping(value = "/toUser",method = RequestMethod.GET)
</code></pre> 
<p>我们也可以为同一个控制器方法指定支持多种类型的请求。例如，一个方法既支持 GET 方式的请求，也支持 POST 方式的请求，代码如下。</p> 
<pre><code class="language-java">@RequestMapping(value = "/toUser",method = {RequestMethod.GET,RequestMethod.POST})，</code></pre> 
<p style="background-color:transparent">?<span style="color:#fe2c24"><strong>4. params 属性</strong></span></p> 
<p>params 属性<strong>用于指定请求中的参数</strong>，只有当请求中携带了符合条件的参数时，控制器方法才会对该请求进行处理。<br><br> 我们可以通过以下 4 种表达式来对请求的参数进行配置。<br>  </p> 
<table><tbody>
<tr>
<th>序号</th>
<th>表达式</th>
<th>含义</th>
</tr>
<tr>
<td>①</td>
<td> "param"</td>
<td>请求中必须携带名为 param 的参数</td>
</tr>
<tr>
<td>②</td>
<td>"!param"</td>
<td>与表达式 ① 的含义完全相反，请求中不能携带名为 param 的参数</td>
</tr>
<tr>
<td>③</td>
<td>"param=value"</td>
<td>请求中必须携带名为 param 的参数，且参数的取值必须为：value</td>
</tr>
<tr>
<td>④</td>
<td>"param!=value"</td>
<td>与表达式 ③ 的含义完全相反，请求中不能携带参数：param = value。</td>
</tr>
</tbody></table> 
<p><br> params 属性的取值是一个字符串类型的数组，表示只有请求中同时携带了 params 属性指定的全部参数时，控制器方法才会对该请求进行处理。<br><br> 例如，控制器方法 testParam() 的代码如下：</p> 
<pre><code class="language-java">@RequestMapping(value = "/testParam", params = {"name=C语言中文网", "url=http://c.bianheng.net"})
@ResponseBody
public String testParam() {
    return "success";
}</code></pre> 
<p>以上代码表示，只有当请求中同时携带 name 和 url 两个请求参数，且参数值必须分别为 “C语言中文网” 和“http://c.biancheng.net”时，控制器方法 testParam() 才会对该请求进行处理 。</p> 
<p style="background-color:transparent">?<span style="color:#fe2c24"><strong>5. headers 属性</strong></span></p> 
<p>headers 属性用于设置请求中请求头信息，只有当请求中携带指定的请求头信息时，控制器方法才会处理该请求。<br><br> 我们可以通过以下 4 种表达式来指定请求中的请求头信息。<br>  </p> 
<table><tbody>
<tr>
<th>序号</th>
<th>表达式</th>
<th>含义</th>
</tr>
<tr>
<td>①</td>
<td> "header"</td>
<td>请求必须携带请求头信息：header </td>
</tr>
<tr>
<td>②</td>
<td>"!header"</td>
<td>与表达式 ①  的含义完全相反，请求中不能携带请求头信息：header</td>
</tr>
<tr>
<td>③</td>
<td>"header=value"</td>
<td>请求中必须携带请求头信息：header=value 。</td>
</tr>
<tr>
<td>④</td>
<td>"header!=value"</td>
<td>与表达式 ③ 的含义完全相反，请求中不能携带请求头信息：header=value。</td>
</tr>
</tbody></table> 
<p><br> header 属性是一个字符串类型的数组，表示只有当请求同时携带数组中规定的所有头信息时，控制器方法才会对该请求进行处理。<br><br> 例如，控制器方法 method() 的代码如下。</p> 
<pre><code class="language-java">@RequestMapping(value = "toUser",headers = "Referer=http://c.biancheng.net")
public String metnod() {
    ……
}</code></pre> 
<p>在以上代码中，只有当请求的头信息中包含“Referer=http://c.biancheng.net”时，控制器方法 method() 才会处理该请求。</p> 
<hr> 
<h4 id="%F0%9F%8C%BB%E6%94%AF%E6%8C%81%20Ant%20%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%B7%AF%E5%BE%84" style="background-color:transparent;margin-left:auto">?<span style="color:#444444"><span style="background-color:#ffffff">支持 Ant 风格的路径</span></span>
</h4> 
<p><span style="color:#444444"><span style="background-color:#ffffff">Spring MVC 还提供了对 Ant 风格路径的支持，我们可以在 @RequestMapping 注解的 value 属性中使用 Ant 风格的统配符，来设置请求映射地址。</span></span><br><br><span style="color:#444444"><span style="background-color:#ffffff">常用的 Ant 风格的通配符，如下表所示。</span></span><br>  </p> 
<table border="1" cellspacing="0"><tbody>
<tr>
<th style="background-color:#ededed">通配符</th>
<th style="background-color:#ededed">说明</th>
<th style="background-color:#ededed">请求映射举例</th>
<th style="background-color:#ededed">匹配的请求地址举例</th>
</tr>
<tr>
<td style="background-color:#ffffff;border-color:#cccccc">?</td>
<td style="background-color:#ffffff;border-color:#cccccc">表示任意的单个字符。</td>
<td style="background-color:#ffffff;border-color:#cccccc">@RequestMapping(value = "/test-user?")</td>
<td style="background-color:#ffffff;border-color:#cccccc"> 
    <ul style="margin-left:0px">
<li>localhost:8080/test-user<span style="color:#b22222">A</span>
</li>
<li>localhost:8080/test-user<span style="color:#b22222">b</span>
</li>
<li>localhost:8080/test-user<span style="color:#b22222">1</span>
</li>
</ul>
</td>
</tr>
<tr>
<td style="background-color:#ffffff;border-color:#cccccc">*</td>
<td style="background-color:#ffffff;border-color:#cccccc">表示任意的 0 个或多个字符。</td>
<td style="background-color:#ffffff;border-color:#cccccc">@RequestMapping(value = "/test-user*")</td>
<td style="background-color:#ffffff;border-color:#cccccc"> 
    <ul style="margin-left:0px">
<li>localhost:8080/test-user</li>
<li>localhost:8080/test-user<span style="color:#b22222">A</span>
</li>
<li>localhost:8080/test-user<span style="color:#b22222">-abc</span>
</li>
</ul>
</td>
</tr>
<tr>
<td style="background-color:#ffffff;border-color:#cccccc">**</td>
<td style="background-color:#ffffff;border-color:#cccccc">表示任意的一层或多层目录。<br><br> 注意，在使用该通配符时，其使用方式只能时 "/**/xxx"。</td>
<td style="background-color:#ffffff;border-color:#cccccc">@RequestMapping(value = "/**/testuser")</td>
<td style="background-color:#ffffff;border-color:#cccccc"> 
    <ul style="margin-left:0px">
<li>localhost:8080/test-user</li>
<li>localhost:8080<span style="color:#b22222">/aa</span>/test-user</li>
<li>localhost:8080<span style="color:#b22222">/aa/bb</span>/test-user</li>
</ul>
</td>
</tr>
</tbody></table> 
<p></p> 
<p>?☘️????️</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>