<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>软考数据库系统工程师复习资料(完全版) - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软考数据库系统工程师复习资料(完全版)</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:center">目录</p> 
<p><a href="#_Toc17783">第一章 计算机系统知识 2 </a></p> 
<p><a href="#_Toc24402">第二章 数据结构与算法 </a></p> 
<p><a href="#_Toc15528">第三章 操作系统知识 </a></p> 
<p><a href="#_Toc25379">第四章 程序设计基础 </a></p> 
<p><a href="#_Toc13994">第五章 网络基础知识 </a></p> 
<p><a href="#_Toc8162">第六章 多媒体基础知识 </a></p> 
<p><a href="#_Toc20162">第七章 数据库技术基础 </a></p> 
<p><a href="#_Toc181">第八章 关系数据库 </a></p> 
<p><a href="#_Toc29845">第九章 SQL语言 </a></p> 
<p><a href="#_Toc27517">第十章 系统开发与运行 </a></p> 
<p><a href="#_Toc29">第十一章 数据库设计 </a></p> 
<p><a href="#_Toc17249">第十二章 网络与数据库 </a></p> 
<p><a href="#_Toc28315">第十三章 数据库发展趋势与新技术 </a></p> 
<p><a href="#_Toc25738">第十四章 知识产权基础知识 </a></p> 
<p><a href="#_Toc22483">第十五章 标准化基础知识 </a></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">第一章 计算机系统知识</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 计算机软件=程序+数据+相关文档。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 操作数包含在指令中是立即寻址，操作数的地址包含在指令中是直接寻址。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 计算机硬件的典型结构：单总线结构、双总线结构、采用通道的大型系统结构。</p> 
<p style="margin-left:.0001pt;text-align:justify">4. CPU由运算器和控制器组成；控制器由程序计数器（PC）、指令寄存器（IR）、指令译码器（ID）、状态条件寄存器、时序产生器和微操作信号发生器组成。</p> 
<p style="margin-left:.0001pt;text-align:justify">a) PC:   pc自动增加一个值，指向下一条要执行的指令，当程序转移时将转移地址送入PC。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) IR：用于存放当前要执行的指令。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) ID：对现行的指令进行分析，确定指令类型、指令要完成的操作和寻址方式。</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 指令执行的过程：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 取指令：控制器首先按程序计数器所指出的指令地址从内存中取出一条指令。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 指令译码：将指令的操作码部分送入指令译码器中进行分析，然后根据指令的功能发出控制命令。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 按指令操作码执行。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 形成下一条指令地址。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. CPU的基本功能：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 程序控制</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 操作控制</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 时间控制</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 数据处理——CPU的根本任务</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 计算机体系结构和计算机组成的区别：体系结构要解决的问题是计算机系统在总体上、功能上需要解决的问题，而计算机组成要解决的是逻辑上如何具体实现的问题。</p> 
<p style="margin-left:.0001pt;text-align:justify">8. 计算机体系结构分类（指令流、数据流、多倍性）：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) Flynn分类：传统的顺序执行的计算机在同一时刻只能执行一条指令（即只有一个控制流）、处理一个数据（即只有一个数据流），因此被称为单指令流单数据流计算机Single Instruction Single Data即SISD计算机）。而对于大多数并行计算机而言，多个处理单元都是根据不同的控制流程执行不同的操作，处理不同的数据，因此，它们被称作是多指令流多数据流计算机，即MIMD（Multiple Instruction Multiple Data）计算机。曾经在很长一段时间内成为超级并行计算机主流的向量计算机除了标量处理单元之外，最重要的是具有能进行向量计算的硬件单元。在执行向量操作时，一条指令可以同时对多个数据（组成一个向量）进行运算，这就是单指令流多数据流（Single Instruction Multiple Data，SIMD）的概念。因此，我们将向量计算机称为SIMD计算机。第四种类型即所谓的多指令流单数据（MultipleInstructionSingleData）计算机。在这种计算机中，各个处理单元组成一个线性阵列，分别执行不同的指令流，而同一个数据流则顺次通过这个阵列中的各个处理单元。这种系统结构只适用于某些特定的算法。相对而言，SIMD和MISD模型更适合于专用计算。在商用并行计算机中，MIMD模型最为通用，SIMD次之，而MISD最少用。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">9. 存储器的分类：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 按存储器的位置：内存（主存）和外存（辅存）。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 按存储器的材料：磁存储器、半导体存储器（静态和动态）和光存储器。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 按工作方式：读写存储器和只读存储器。只读存储器（ROM/PROM/EPROM/EEPROM/闪存）</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 按访问方式：按地址访问的存储器和按内容访问的存储器（相连存储器）。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 按寻址方式：随机存储器（RAM）、顺序存储器（ASM）—磁带、直接存储器（DAM）—磁盘就是直接存储器。</p> 
<p style="margin-left:.0001pt;text-align:justify">10. 输入/输出：直接程序控制、中断方式、直接存储器存取（DMA）。</p> 
<p style="margin-left:.0001pt;text-align:justify">11. 流水线技术</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 吞吐率和建立时间是流水线技术的两个重要技术指标。吞吐率是指单位时间内流水线处理机流出的结果数；流水线开始工作经过一段时间（建立时间）才能到达最大的吞吐率。若m个子过程所用的时间都是t0则建立时间是 m*t0，否则t0取子过程中的最长时间。那么n条指令执行完成需要的时间为第一条完全执行的时间加上后n-1条所用的时间（n-1）*m*t0。</p> 
<p style="margin-left:.0001pt;text-align:justify">12. 虚拟存储器：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 页式：页表硬件少，查表速度快，主存零头少；分页无逻辑性，不利于存储保护。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 段式：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">c) 段页式：地址变换速度比较慢。</p> 
<p style="margin-left:.0001pt;text-align:justify">13. 只有20%的指令经常应用频率达80%→RISC（精简指令集计算机）简化了CPU的控制器，提高了处理速度，特点有：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">14. 信息安全的基本要素：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">15. 计算机安全等级（技术安全性、管理安全性、政策法律安全性）：分为四组七个等级。</p> 
<p style="margin-left:.0001pt;text-align:justify">组 安全级别</p> 
<p style="margin-left:.0001pt;text-align:justify">1 A1</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">2 B3</p> 
<p style="margin-left:.0001pt;text-align:justify">B2</p> 
<p style="margin-left:.0001pt;text-align:justify">B1</p> 
<p style="margin-left:.0001pt;text-align:justify">3 C2</p> 
<p style="margin-left:.0001pt;text-align:justify">C1</p> 
<p style="margin-left:.0001pt;text-align:justify">4 D（最低级）</p> 
<p style="margin-left:.0001pt;text-align:justify">16. 计算机病毒的特点：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 寄生性</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 隐蔽性</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 非法性</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 传染性</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 破坏性</p> 
<p style="margin-left:.0001pt;text-align:justify">17. 计算机病毒的类型：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 系统引导型病毒————BOOT型病毒</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 文件外壳型病毒————攻击command.com文件</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 混合型病毒————Flip病毒、One Half病毒（幽灵）</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 目录型病毒————改变目录项不敢变相关文件</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 宏病毒————用宏的word或是excel文件</p> 
<p style="margin-left:.0001pt;text-align:justify">18. 计算机可靠性：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 平均无故障时间（MATBF=1/λ）；</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 计算机正常工作的概率（可用/靠性）A= （MTRF平均修复时间）。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 失效率：单位时间内失效的元件数与元件总数的比例，用λ表示。可靠性和是效率的关系是：R(t)=e-λt。</p> 
<p style="margin-left:.0001pt;text-align:justify">19. 计算机可靠模型：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 串联系统：可靠性等于R=R1R2…RN；失效率λ=λ1+λ2+…+λN</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 并联系统：可靠性等于R=1-(1-R1)(1-R2)…(1-RN)；失效率</p> 
<p style="margin-left:.0001pt;text-align:justify">c) m模冗余系统：可靠性  </p> 
<p style="margin-left:.0001pt;text-align:justify">20. 对称加密技术：加密密钥和解密密钥相同。</p> 
<p style="margin-left:.0001pt;text-align:justify">a) DES（数据加密标准算法）：采用替换和移位方法加密，用56位进行对64位数据加密（也就是说只有56是有效的），每次加密对64位数据进行16次的编码，密钥长度为64位。它加密速度快，密钥容易产生。由于DES的密钥较短，不能抵抗对密钥的穷举搜索攻击。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) RC-5算法。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) IDEA算法：明文和密文的长度都为64位，密钥为128位。</p> 
<p style="margin-left:.0001pt;text-align:justify">21. 非对称加密技术：运用公钥加密和私钥解密。</p> 
<p style="margin-left:.0001pt;text-align:justify">a) RSA算法：RAS技术是指可靠性（R）、可用性（A）、可维性（S）</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 信息摘要是一个单向散列函数，经过散列函数得到一个固定的散列值，常用的信息摘要算法有MD5、SHA算法，散列值分别为128和160位。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 数字签名：用私钥进行加密用公钥解密。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 数字时间戳技术：电子商务安全服务项目之一，能提供电子文件的日期和时间信息的安全保护。它是在数据加密上加上了时间，有摘要、文件的日期和时间及数据签名组成。</p> 
<p style="margin-left:.0001pt;text-align:justify">22. 信息传输加密：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 链路加密：对传输途径进行加密；</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 节点加密：</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 端到端加密：</p> 
<p style="margin-left:.0001pt;text-align:justify">23. SSL安全协议：主要应用于提高应用程序之间数据的安全系数。提供的服务有：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 用户和服务器的合法性认证。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 加密数据以隐藏被传送的数据。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 保护数据的完整性。</p> 
<p style="margin-left:.0001pt;text-align:justify">24. DES与RAS的比较：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">25. 计算机故障诊断技术</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 计算机的故障：</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 永久性故障</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 间隙性故障</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. 瞬时性故障</p> 
<p style="margin-left:.0001pt;text-align:justify">26.  内存容量=末地址-首地址+1。</p> 
<p style="margin-left:.0001pt;text-align:justify">27. 存储相关计算问题：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 计算磁道数：磁道数 ＝ （外半径－内半径）×道密度×记录面数。注：硬盘的第一面和最后一面是保护用的要减掉，即有n个双面的盘片记录面数为n×2－2。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 非格式化磁盘容量：容量＝位密度×π×最内圈直径×总磁道数。注：每道位密度是不通的，但是容量是相同的，其中0道是最外面的磁道位密度最小。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 格式化磁盘容量：容量＝每道扇区数×扇区容量×总磁道数。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) （格式化）平均数据传输率：传输率＝每道扇区数×扇区容量×盘片转速。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 存取时间＝寻道时间﹢等待时间。其中：寻道时间是指磁头移动所需的时间；等待时间为等待读写的扇区转到磁头下方所需的时间。</p> 
<p style="margin-left:.0001pt;text-align:justify">f) （非格式化）平均数据传输率：传输率＝最内直径×π（3.14）×位密度×盘片转速。注：一般采用非格式化。</p> 
<p style="margin-left:.0001pt;text-align:justify">28. 数制运算</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">29. 码制</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 反码：正数的反码与原码相同，负数反码为原码按位取反（符号位不变）。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 补码：正数的补码与原码相同，负数的补码为反码末位加1（即除去符号位按位取反末位加1）。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 移码（增码）：将补码的符号位求反。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) ［X ＋ Y ］补＝ ［X］补＋ ［Y ］补</p> 
<p style="margin-left:.0001pt;text-align:justify">e) ［X － Y ］补＝ ［X］补－ ［Y ］补</p> 
<p style="margin-left:.0001pt;text-align:justify">f) ［ － Y ］补＝ － ［Y ］补</p> 
<p style="margin-left:.0001pt;text-align:justify">30. 校验码：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 循环校验码（CRC）：</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 模二除法：指在除法运算的过程中不计其进位的除法。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 海明校验码：</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 根据信息位数，确定校验位数，2r≥k+r+1。k为信息位数，r为校验位数，求出满足不等式的最小r即为校验位数。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc12799"></a><a name="_Toc24402">第二章</a> 数据结构与算法</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 数据结构指数据元素的组织形式。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 线性表的顺序存储结构：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 特点是物理位置上的邻接关系来表示结点的逻辑关系，具有可以随机存取表中的任一结点的，但插入删除不方便。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 查找表中第i个元素 LOC(ai) = LOC(a1)+(i-1)*L</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 线性表的链式存储结构：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 用一组任意的存储单元来存放线性表的数据元素，链表中的结点的逻辑次序和物理次序不一定相同。</p> 
<p style="margin-left:.0001pt;text-align:justify">数据域 指针域</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 线性表的插入和删除</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 顺序存储：Einsert = n/2     Edelete =（n-1）/2</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 链式存储：</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 栈的顺序存储：采用两个顺序栈共享一个数据空间：（先进后出）</p> 
<p style="margin-left:.0001pt;text-align:justify">栈底1</p> 
<p style="margin-left:.0001pt;text-align:justify">栈顶1 … 栈顶2</p> 
<p style="margin-left:.0001pt;text-align:justify">栈底2</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 队列：只允许在表的一端插入元素（队尾），另一端删除元素（队头）。（先进先出）</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 子串包含在它的主串中的位置是子串的第一个字符首次出现的位置。</p> 
<p style="margin-left:.0001pt;text-align:justify">8. 关义表</p> 
<p style="margin-left:.0001pt;text-align:justify">  </p> 
<p style="margin-left:.0001pt;text-align:justify">9. 二叉树的性质：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 二叉树第i层上的结点数目最多为2i-1（i≥1）。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 深度为K的二叉树至多有2k-1个结点（k≥1）。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 在任意一颗二叉树中，若终端结点的个数为n0，度为2的节点数为n2，则n0=n2+1。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 具有n个结点的完全二叉树的深度为（向下取整）。</p> 
<p style="margin-left:.0001pt;text-align:justify">10. 树与二叉树的转换：左孩子不变，其兄弟结点变为左孩子的右孩子；或是将树置保留左孩子结点，其它全删去，然后将各层的兄弟结点连起来。如：</p> 
<p style="margin-left:.0001pt;text-align:justify">  </p> 
<p style="margin-left:.0001pt;text-align:justify">11. 树的前序遍历与二叉树的先序遍历一样；树的后序与二叉树的中序遍历一样。</p> 
<p style="margin-left:.0001pt;text-align:justify">12. 散列就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值，如此建立的表为散列表，散列表是可以动态创建的。</p> 
<p style="margin-left:.0001pt;text-align:justify">13. 二分查找（折半查找）：要求关键字必须采用顺序存储结构，并且必须按关键字的大小有序排序。</p> 
<p style="margin-left:.0001pt;text-align:justify">14. 查找二叉树（二叉排序树）——动态查找表：或者为空树或者满足：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 查找树的左右子树各是一颗查找树。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 若查找树的左子树非空，则其左子树上各节点的值均小于根结点的值。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 若查找树的右子树非空，则其右子树上各节点的值均大于根结点的值。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 平衡二叉树：或者是空树，或者是满足：树中任一节点左右子树的深度相差不超过1。结点的平衡度：其右子树的深度减去左子树的深度（因此平衡度只能为1,0，-1）。</p> 
<p style="margin-left:.0001pt;text-align:justify">15. 有向图中所有顶点的出度数之和等于入度数之和。</p> 
<p style="margin-left:.0001pt;text-align:justify">16. 在图中，边数等于所有顶点的度数之和的一半.</p> 
<p style="margin-left:.0001pt;text-align:justify">17. 在有向图中顶点为n的边数等于 ，无向图中边数等于 。</p> 
<p style="margin-left:.0001pt;text-align:justify">18. C语言中，struct中各成员都占有自己的内存空间，总长度为所有成员的长度之和，而union中的长度等于最长的成员的长度。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc8014"></a><a name="_Toc15528">第三章</a> 操作系统知识</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 操作系统的类型：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 批处理操作系统（单道和多道）</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 分时系统（多路性（同时性）、独立性、交互性、及时性）注：UNIX是多用户多任务的分时系统。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 实时系统——高可靠性</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 网络操作系统</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 分布式操作系统</p> 
<p style="margin-left:.0001pt;text-align:justify">f) 微机操作系统</p> 
<p style="margin-left:.0001pt;text-align:justify">g) 嵌入式操作系统</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 利用PV操作实现进程的互斥和同步。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 网络操作系统</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 集中模式</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 客户机/服务器模式</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 对等模式</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 中断响应时间：从发出中断请求到进入中断处理所用的时间。</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 中断响应时间＝关中断的最长时间 ＋保护CPU内部寄存器的时间 ＋进入中断服务函数的执行时间 ＋开始执行中断服务例程(ISR)的第一条指令时间。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 在磁盘驱动器向盘片的磁性涂层写入数据时，均是以串行方式一位接着一位的顺序记录在盘片的磁道上。</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 高速缓存的组成：Cache由两个部分组成：控制部分和Cache存储器部分。          </p> 
<p style="margin-left:.0001pt;text-align:justify">8. Cache与主存之间的地址映像，就是把CPU送来的主存地址转换成Cache地址。有三种方式：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 直接映像：它把主存空间按Cache大小等分成区，每区内的各块只能按位置一一对应到Cache的相应块位置上。</p> 
<p style="margin-left:.0001pt;text-align:justify">主存地址：主存区号+块号B+块内地址W</p> 
<p style="margin-left:.0001pt;text-align:justify"> Cache地址：块号b + 块内地址w</p> 
<p style="margin-left:.0001pt;text-align:justify">     对应关系：块号B=块号b ， 块内地址W = 块内地址 w</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 全相联映像：主存中的每一页可以映像到Cache中的任意一页。</p> 
<p style="margin-left:.0001pt;text-align:justify">主存地址：块号B+块内地址W</p> 
<p style="margin-left:.0001pt;text-align:justify">Cache地址：块号b +块内地址w</p> 
<p style="margin-left:.0001pt;text-align:justify">    对应关系：块号B通过地址变换表对应于块号b ， 块内地址W = 块内地址 w</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 组相联映像：是直接映像和全相联映像的折中方案。即组间直接映像，组内全相联映像。</p> 
<p style="margin-left:.0001pt;text-align:justify">主存地址：区号E+组号G+组内块号B+块内地址W</p> 
<p style="margin-left:.0001pt;text-align:justify">Cache地址：组号g + 组内块号b + 块内地址w</p> 
<p style="margin-left:.0001pt;text-align:justify">组间是直接映射关系，组内是全相连映射关系</p> 
<p style="margin-left:.0001pt;text-align:justify">对应关系：组号G=组号g，组内块号B通过地址变换表对应于组内块号b ， 块内地址W = 块内地址 w</p> 
<p style="margin-left:.0001pt;text-align:justify">9. Cache存储器：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 命中率：t3＝μ×t1﹢﹙1－μ﹚×t2。其中：μ为Cache的访问命中率（1﹣μ）为未命中率，t1表示Cache的周期时间，t2表示主存储器的周期时间，t3为“Cache+主存储器”的平均周期。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 使用Cache后提高的倍数： r = t2/t3。</p> 
<p style="margin-left:.0001pt;text-align:justify">10. 替换算法：目标就是使Cache获得最高的命中率。常用算法如下：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 随机替换算法。就是用随机数发生器产生一个要替换的块号，将该块替换出去；</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 先进先出算法。就是将最先进入Cache的信息块替换出去。此法简单但并不能说最先进入的就不经常使用；</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 近期最少使用算法。这种方法是将近期最少使用的Cache中的信息块替换出去。该算法较先进先出算法要好一些。但此法也不能保证过去不常用将来也不常用。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 优化替换算法。使用这种方法时必须先执行一次程序，统计Cache的替换情况。注：http://apps.hi.baidu.com/share/detail/30866296</p> 
<p style="margin-left:.0001pt;text-align:justify">11. 局部性理论和Denning的工作集理论：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 虚拟存储管理系统的基础是程序的局部性理论：程序的局部性表现在时间局部性和空间局部性上。时间局部性是指最近被访问的存储单元可能马上又要被访问。空间局部性是指马上被访问的存储单元，其相邻或附近单元也可能马上被访问。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 根据程序的局部性理论，Denning提出了工作集理论：在进程运行时，如果能保证它的工作集页面都在主存储器内，就会大大减少进程的缺页次数，使进程高效地运行；否则将会因某些工作页面不在内存而出现频繁的页面调入/调出现象，造成系统性能急剧下降，严重时会出现“抖动”现象。</p> 
<p style="margin-left:.0001pt;text-align:justify">12. 进程状态</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">13. 进程不发生死锁的条件：系统资源数 = 进程数*（每个进程所需资源数-1）+1。</p> 
<p style="margin-left:.0001pt;text-align:justify">14. 前趋图是一个有向无循环图。</p> 
<p style="margin-left:.0001pt;text-align:justify">15. PV操作：生产者和消费者问题。</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 临界资源：诸进程间需要互斥方式对其进行共享的资源，如打印机。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 临界区：每个进程中访问临界资源的那段程序代码。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) s:信号量；P操作：使S = S-1，若S&lt;0，进程暂停执行，放入信号量的等待队列；V操作：使s = s+1，若s≤0，唤醒等待队列中的一个进程。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 进入临界区时进行P操作，退出临界区是进行V操作。</p> 
<p style="margin-left:.0001pt;text-align:justify">16. 进程通信（间接通信）</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 发送信件:如果指定信箱未满,则将信件送入信箱中由指针所指示的位置,并释放等待该信箱中信件的等待者;否则发送信件者被置成等待信箱状态。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 接收信件:如果指定信箱中有信,则取出一封信件,并释放等待信箱的等待者,否则接收信件者被置成等待信箱中信件的状态进程通信。</p> 
<p style="margin-left:.0001pt;text-align:justify">17. 存储管理：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 页式存储管理：逻辑地址分为页号+页内地址，页表分为 页号+块号，块号对应内存块号。物理地址 = 块号+页内地址。页内地址由每页的大小决定，如逻辑地址有16K=214，页面大小为2K=211则页内地址为11位，也号为3位。即：P=INT[A/L];d=[A]MOD L.其中逻辑地址为A。页面大小为L页号P，页内地址d。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 段式存储管理方式：逻辑地址分为 段号+段内地址，段表分为 段号+段长+基址。基址对应内存地址。物理地址 = 基址+段内地址。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 段页式存储管理方式：逻辑地址分为 段号（s）+段内页号（P）+页内地址（w）。由一个段表和多个（一组页表）组成。物理地址 = 块号+页内地址。在多道环境下，每道程序还需要一个基号作为用户标识。那么物理地址 = (基号+段号+页号)*2n+页内地址。其中2n是将n位的页内地址拼接到后面。</p> 
<p style="margin-left:.0001pt;text-align:justify">18. 文件系统的主要功能是：实现对文件的按名存取，使用打开文件（open）将文件的控制信息从辅存读到内存。</p> 
<p style="margin-left:.0001pt;text-align:justify">19. FAT16文件系统中磁盘分区容量=簇的大小×216。</p> 
<p style="margin-left:.0001pt;text-align:justify">20. Spooling技术是用一类物理设备模拟另一类物理设备的技术,实现这种技术的功能模块称做斯普林系统。Spooling系统的特点：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 提高了I/O速度。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 将独占设备改造成共享设备。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 实现了虚拟设备的功能。</p> 
<p style="margin-left:.0001pt;text-align:justify">21.</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc11323"></a><a name="_Toc25379">第四章</a> 程序设计基础</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 程序设计语言的种类：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 命令式程序设计语言：基于动作的语言，如fortran、pascal和c。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 面向对象程序设计语言：java、C++。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 函数式程序设计语言：主要用于符号数据处理，如积分演算、数理逻辑、游戏推演和人工智能等领域。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 逻辑程序设计语言：不需要描述具体的接替过程，只需给出一些必要的事实和规则，作为专家系统的开发工具。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 程序语言的基本成分：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 数据成分：常量和变量、全局量和局部量、数据类型。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 运算成分：</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 控制成分：顺序结构、选择结构和循环结构。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 函数：函数定义、函数声明、函数调用。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 面向对象程序设计语言的基本特征：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 抽象数据对象；</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 支持模版操作，具体有函数模版和类模版，即泛型编程。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 支持动态性；</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 支持继承——与其它语言的主要区别。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 类库是衡量成熟与否的标识。</p> 
<p style="margin-left:.0001pt;text-align:justify">4. C语言的特点是过程式程序设计属于静态语言所有成分可在编译时确定。</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 脚本语言是动态语言，可在运行时可改变不能产生独立的目标程序。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 编写程序时的错误有：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 动态错误：指源程序中的逻辑错误，发生在程序运行时错误，如除数为0数组下标出界。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 静态错误：分为语法错误和语义错误。</p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc17687"></a><a name="_Toc13994">第五章</a> 网络基础知识</p> 
<p style="margin-left:.0001pt;text-align:justify">1. TCP是第四层（传输层）的传输控制协议；IPSec是第三层（网络层）的VPN协议；PPOE工作于第二层（数据链路层）；SSL是工作于TCP协议之上的安全协议。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. FTP传输需建立：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 控制连接：文件传输命令，由客户端向服务器端请求。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 数据连接：文件的传输，主动模式由服务器端主动连接，被动模式服务器等待客户端来连接。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 端口号：</p> 
<p style="margin-left:.0001pt;text-align:justify">端口号 服务进程 说明</p> 
<p style="margin-left:.0001pt;text-align:justify">20 FTP 文件传输协议（数据连接）</p> 
<p style="margin-left:.0001pt;text-align:justify">21 FTP 文件传输协议（控制连接）</p> 
<p style="margin-left:.0001pt;text-align:justify">23 TELNET 虚拟终端网络</p> 
<p style="margin-left:.0001pt;text-align:justify">25 SMTP 简单邮件传输协议</p> 
<p style="margin-left:.0001pt;text-align:justify">53 DNS 域名服务器</p> 
<p style="margin-left:.0001pt;text-align:justify">80 HTTP 超文本传输协议</p> 
<p style="margin-left:.0001pt;text-align:justify">110 POP3 邮局协议（简单邮件读取）</p> 
<p style="margin-left:.0001pt;text-align:justify">111 RPC 远程过程调用</p> 
<p style="margin-left:.0001pt;text-align:justify">143 IMAP 交互式存取协议（报文存取）</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 电子商务交易：通过身份认证可以确定一个实体的身份，防止一个实体假装成另一个实体；认证与授权相结合，可以防止他人对数据进行非授权的修改、破坏；保护信息的机密性可以防止信息从被监视的通信过程中泄漏出去。抗抵赖性防止参与此交易的一方否认曾经发生过此次交易</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 网络安全技术：信息存取的保障有用户的标识和验证、用户存取权限控制、系统安全监控、计算机病毒的防治、数据加密。</p> 
<p style="margin-left:.0001pt;text-align:justify">a) VPN技术：通过隧道将两个内部网络通过公共网络进行连接使其成为一个总体网络。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 防火墙技术：类型有</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 包过滤防火墙（屏蔽路由器）：将路由器放置于内部网络中，网络层安全。</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 应用代理防火墙：也就是双宿主机防火墙，应用层安全。</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. 状态检测技术防火墙：以上两种技术的综合，屏蔽路由器置于外部网络，双宿主机置于内部网络。</p> 
<p style="margin-left:.0001pt;text-align:justify">iv. 屏蔽子网防火墙：设置DMZ（非军事区）由屏蔽路由器和双宿主机构成。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 多模光纤的特点是：成本低、宽芯线、聚光好、耗散大、低效，用于低速短距离的通信。单模光纤的特点是：成本高、窄芯线、需要激光源、耗散小、高效，用于高速长距离的通信。</p> 
<p style="margin-left:.0001pt;text-align:justify">7. ping命令：判断用户与外部站点的连通性，一、ping127.0.0.1（本地循环地址），无法ping则说明本机TCP/IP协议不能正常工作，二、ping+本机IP不通则说明网络适配器（网卡/MODEM）出现故障，三、ping+同一网段计算机的IP不通则说明网络线路出现故障；netstat命令：用于显示TCP、UDP、IP、ICMP协议相关统计数据，一般用于检验本机网络端口的连接情况；ARP命令：可以查看和修改本地计算机的ARP表项，和查看ARP缓存和解决地址解析问题非常使用。Tracert命令：可以跟踪网络连接，Tracert（路由跟踪）是路由跟踪程序，用于确定IP数据报访问目标所采取的路径，可以查看哪段路由出现连接问题。</p> 
<p style="margin-left:.0001pt;text-align:justify">8. DHCP（动态主机配置协议）：用于网络中的主机动态分配IP地址，默认情况下客户机采用最先达到的DHCP服务器分配的IP地址。</p> 
<p style="margin-left:.0001pt;text-align:justify">9. Internet协议：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) TCP/IP协议：是Internet协议的核心协议，基本特性（逻辑编址、路由选择、域名解析协议、错误检测和流量控制）</p> 
<p style="margin-left:.0001pt;text-align:justify">b) ARP（地址解析协议）和RARP（反地址解析协议）。ARP将IP地址转换为物理地址（MAC地址）。</p> 
<p style="margin-left:.0001pt;text-align:justify">10. 网络设计原则：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 先进性：采用先进的技术；</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 实用性：采用成熟可靠的技术和设备达到使用有效的目的；</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 开放性：网路系统采用开放的标准和技术；</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 经济性：在满足需求的基础上尽量节省费用；</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 高可用/靠性：系统具有很高的平均无故障时间，如：金融、铁路证券等。</p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc16652"></a><a name="_Toc8162">第六章</a> 多媒体基础知识 </p> 
<p style="margin-left:.0001pt;text-align:justify">1. 衡量声音特性的属性（三要素）：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 音量：也叫音强，衡量声音的强弱程度。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 音调：声音频率。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 音色： 由混入基音的泛音决定。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 声音的带宽：声音信号的频率范围。</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 人耳能听到(其它声音)的音频范围：20HZ~20KHZ</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 人的说话声音音频范围：300~3400HZ</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 乐器的音频范围：20HZ~20KHZ</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 声音信号的数字化：——取样-量化法</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 采样：信号测量记录。注：语音信号的采样频率一般为8KHz，音乐信号的采样频率则应该在40KHz以上。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 数字信号是离散的，模拟信号是连续的。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 量化（数模转换）：A/D转换</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 图形图像的区别：图形放大不会失真，图像放大会失真。</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 色彩的三要素：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 亮度：明亮程度的感觉。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 色调：反映的是颜色的种类。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 饱和度：颜色的纯度，即掺入白光的程度，颜色的鲜明程度。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 彩色空间：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) RGB彩色空间：计算机。红黄绿</p> 
<p style="margin-left:.0001pt;text-align:justify">b) CMY彩色空间：打印。青、品红、黄</p> 
<p style="margin-left:.0001pt;text-align:justify">c) YUV彩色空间：电视。</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 图像文件的大小计算：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 已知像素和位数：容量=像素*位数/8B</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 已知像素和色数：容量=像素*位数/8B（2位数=色数即n位数能表示2位数种颜色）</p> 
<p style="margin-left:.0001pt;text-align:justify">8. 音频文件的大小计算：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 未经过压缩的  ：</p> 
<p style="margin-left:.0001pt;text-align:justify">数据传输率（b/s）=采样频率（Hz）*量化位数（采样位数）（b）*声道数（如果求的是字节则应再除以8）</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 经过数字化后所需的存储空间（容量）：</p> 
<p style="margin-left:.0001pt;text-align:justify">声音信号数据量=数据传输率（b/s）*持续时间/8（B）</p> 
<p style="margin-left:.0001pt;text-align:justify">9. 视频文件的大小计算：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 存储容量的（字节数）=每帧图像的容量（B）*每秒帧数*时间</p> 
<p style="margin-left:.0001pt;text-align:justify">注：每帧图像的容量（B）与图像文件容量计算方式一样。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 播放时的传输速率=每张图像的容量*每秒传输的图像数</p> 
<p style="margin-left:.0001pt;text-align:justify">10. 常见视频标准：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) MPEG-1：MPEG-1层1是对复合编码如： 数字盒式录音带；MPEG-1层2是对视频编码如： DAB,VCD；MPEG-1层3 是对音频进行编码，如Internet,MP3音乐；层4是用来检查。数字电视标准。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) MPEG-2：对交互式多媒体的应用。DVD，数字电视标准。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) MPEG-4: 多种不同的视频格式，虚拟现实、远程教育和交互式视频等的应用。多媒体应用的标准。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) MPEG-7: MPEG－7并不是一种压缩编码方法，其正规的名字叫做多媒体内容描述接口，其目的是生成一种用来描述多媒体内容的标准，这个标准将对信息含义的解释提供一定的自由度，可以被传送给设备和电脑程序，或者被设备或电脑程序查取。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) MPEG-21: “多媒体框架”或“数字视听框架”，它以将标准集成起来支持协调的技术以管理多媒体商务为目标，目的就是理解如何将不同的技术和标准结合在一起需要什么新的标准以及完成不同标准的结合工作。</p> 
<p style="margin-left:.0001pt;text-align:justify">f) CIF视频格式的图像分辨率为：352*288（常用标准化的图像格式）；QCIF:176*141；DCIF:528*384</p> 
<p style="margin-left:.0001pt;text-align:justify">g) MPEG-1编码器输出视频的数据率为15Mbps；PAL制式下其图像的分辨率为352×288，帧速率为25帧/秒。</p> 
<p style="margin-left:.0001pt;text-align:justify">11. 图像文件格式</p> 
<p style="margin-left:.0001pt;text-align:justify">g) 静态格式：GIF/BMP/TIF/PCX/JPG/PSD</p> 
<p style="margin-left:.0001pt;text-align:justify">h) 动态格式：AVI/MPG/AVS</p> 
<p style="margin-left:.0001pt;text-align:justify">i) 目前图像使用的编码和压缩标准：JPEG/MPEG/H.261。</p> 
<p style="margin-left:.0001pt;text-align:justify">12. 音频格式</p> 
<p style="margin-left:.0001pt;text-align:justify">a) WAVE/MOD/MP3(MPEG-1的第三层)/REAL AUDIO/MIDI/CD AUDIO</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 音频文件通常分为声音文件和MIDI文件。声音文件是通过声音录入设备录制的原始声音；MIDI是一种音乐演奏指令序列，相当于乐谱，由电子乐器进行演奏，不包含声音数据，文件较小。</p> 
<p style="margin-left:.0001pt;text-align:justify">13. 压缩技术</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 多媒体数据中存在的冗余：时间冗余、空间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 视频图像压缩技术基本思想和方法：在空间上，图像数据压缩采用JPEG压缩方法来去除冗余信息，主要方法包括帧内预测编码和变换编码；在时间上，图像数据压缩采用帧间预测编码和运动补偿算法来去除冗余信息。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 无损压缩也叫冗余压缩法或是熵编码法；有损压缩也叫熵压缩法。区别是无损压缩可以还原。霍夫曼编码和行程编码方法属于无损压缩，而预测编码、变换编码和运动补偿属于有损压缩。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 熵编码：熵编码即编码过程中按熵原理不丢失任何信息的编码，常见的熵编码有：LZW编码、香农(Shannon)编码、哈夫曼(Huffman)编码和算术编码(arithmetic coding)。</p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc10565"></a><a name="_Toc20162">第七章</a> 数据库技术基础</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 数据库（DB）是指长期存储在计算机内的，有组织的，可共享的数据的集合。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 数据库系统（DBS）由数据库、硬件、软件和人员组成。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 数据库技术的发展：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 人工管理阶段</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 文件管理阶段</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 数据库系统阶段（有较高的数据独立性）</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 数据模型的三要素:</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 数据结构</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 数据操作</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 数据的约束条件</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 对数据操作的有：DDL语言（CREATE/ALTER/DROP/完整性约束）、DML语言（SELECT/INSERT/DELETE/UPDATE）;对权限的操作有DCL语言。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 数据模型分为：概念数据模型（E-R模型）和基本数据模型（层次、网状、关系模型）和目前提出的对象模型。</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 实体属性</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 简单属性（不可再分）和复合属性（可分如地址（省份、市…））</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 单值属性（只有一个值）和多值属性（如电话号码可有多个）</p> 
<p style="margin-left:.0001pt;text-align:justify">c) NULL属性（没有或是未知）</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 派生属性（从其他属性可推出来）</p> 
<p style="margin-left:.0001pt;text-align:justify">8. E-R法的构件：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">9. 扩充的E-R模型</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 弱实体（要依赖另一个实体而存在）</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 特殊化————P375</p> 
<p style="margin-left:.0001pt;text-align:justify">10. 数据库系统的体系结构</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 三级模式结构（三层两映像）</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 数据物理独立性</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 数据逻辑独立性</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 集中式数据库系统：两段提交协议：封锁阶段（扩展阶段）和解锁阶段（收缩阶段）</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 客户/服务器数据库体系结构</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 并行数据库系统（多个CPU）————P387</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 共享内存式多处理器</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 无共享式并行体系结构</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 分布式数据库系统：两段提交协议：表决阶段和执行阶段</p> 
<p style="margin-left:.0001pt;text-align:justify">f) Web数据库</p> 
<p style="margin-left:.0001pt;text-align:justify">11. 全码：指关系模型中所有的属性组是这个关系模式的候选键。</p> 
<p style="margin-left:.0001pt;text-align:justify">12. 数据库的控制功能</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 事物管理（不可分割的逻辑工作单位）</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 原子性：要么都做要么都不做</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 一致性：只包含成功提交的是事物</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. 隔离性：多个事物并发执行时是相互隔离的</p> 
<p style="margin-left:.0001pt;text-align:justify">iv. 持久性:一旦事物成功提交则永久的反应到数据库中</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 故障恢复</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 事物内部故障</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 系统故障</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. 介质故障</p> 
<p style="margin-left:.0001pt;text-align:justify">iv. 计算机病毒</p> 
<p style="margin-left:.0001pt;text-align:justify">v. 恢复方法：静态转存和动态转存、海量转存和增量转存、日志文件</p> 
<p style="margin-left:.0001pt;text-align:justify">vi. 事物恢复步骤：反向扫描文件日志、对事物的更新操作执行逆操作、继续反向扫描日志文件，直到事物的开始标志</p> 
<p style="margin-left:.0001pt;text-align:justify">vii. 数据库镜像</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 并发控制</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 并发操作带来的问题：带来数据的不一致性（丢失更新、不可重复读和读脏数据）；破坏了事物的隔离性。</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 并发控制的技术：封锁，排他锁（X锁）和共享锁（S锁）</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. 三级封锁协议：一级：解决丢失更新；二级：解决读脏数据；三级：解决不可重复读</p> 
<p style="margin-left:.0001pt;text-align:justify">iv. 并发调度的可串行性：可串行化是并发事物正确性准则，当且仅当可串行化时才是正确的并发调度</p> 
<p style="margin-left:.0001pt;text-align:justify">v. 封锁的粒度：封锁的范围</p> 
<p style="margin-left:.0001pt;text-align:justify">vi. 事物是不能嵌套的，因为违背了事物的原子性；当且仅当当前没有事物执行时才能开始执行事物。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 安全性和授权</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 安全性违例（未经授权读取、修改、破坏数据）</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 授权</p> 
<p style="margin-left:.0001pt;text-align:justify">1) read：允许读取，不许修改</p> 
<p style="margin-left:.0001pt;text-align:justify">2) insert：允许插入，不许修改</p> 
<p style="margin-left:.0001pt;text-align:justify">3) update：允许修改，不许删除</p> 
<p style="margin-left:.0001pt;text-align:justify">4) delete：允许删除</p> 
<p style="margin-left:.0001pt;text-align:justify">5) index：允许创建或删除索引</p> 
<p style="margin-left:.0001pt;text-align:justify">6) resource：允许创建新关系</p> 
<p style="margin-left:.0001pt;text-align:justify">7) alteration：允许添加或删除关系中的属性</p> 
<p style="margin-left:.0001pt;text-align:justify">8) drop：允许删除关系</p> 
<p style="margin-left:.0001pt;text-align:justify">13. 事物的执行状态：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 活动状态：事物的初始状态。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 部分提交状态：全部执行完。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 失败状态：由于硬件或是逻辑上的错误，使事物不能在继续进行，处于失败状态的事物必须回滚。然后事物就进入了中止态。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 中止状态：事物回滚并数据库恢复到开始执行前的状态。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 提交状态：当事物成功完成后，事物处于提交状态，只有事物处于提交状态，才能说明事物已经提交。</p> 
<p style="margin-left:.0001pt;text-align:justify">14. 事物的隔离级别（高到低）：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 可串行化（读幻影）：SERIALIZABLE</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 可重复读：REPEATABLE READ</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 读提交数据：READ COMMITTED</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 可以读未提交数据：READ UNCOMMITTED</p> 
<p style="margin-left:.0001pt;text-align:justify">e) SQL语句定义：SET RANSACTION SOLATON LEVEL a)/b)/c)/d)</p> 
<p style="margin-left:.0001pt;text-align:justify">f) 幻影现象：同一事物对数据对象的两次访问得到的数据记录不同，不可重复读问题</p> 
<p style="margin-left:.0001pt;text-align:justify">15. 数据仓库</p> 
<p style="margin-left:.0001pt;text-align:justify">a) DW的基本特性：面向主题的、数据是集成的、数据是先对稳定的、数据是反映历史变化的（时限一般5~10年）。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 数据模式——事实表,多维数据模式包括（星型模式、雪花模式、事实星状模式）</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 数据仓库体系结构</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 通常采用：数据仓库服务器、OLAP（联机分析处理）、前端服务器</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 从结构的角度：企业仓库、数据集市、虚拟仓库</p> 
<p style="margin-left:.0001pt;text-align:justify">16. 数据仓库的设计：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 数据仓库的数据模型与操作行数据库的区别：○1不包含纯操作型的数据；○2扩充了码结构，增加了时间属性作为码的一部分；○3增加了一些导出数据。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 数据仓库的物理设计：主要提高I/O性能，通过粒度划分和数据分割来提高系统的性能。</p> 
<p style="margin-left:.0001pt;text-align:justify">17. 数据挖掘技术：海量数据搜集、强大的多处理计算机和数据挖掘算法。</p> 
<p style="margin-left:.0001pt;text-align:justify">18. 数据挖掘中常用的技术：人工神经网络、决策树、遗传算法、近邻算法和规则推倒。</p> 
<p style="margin-left:.0001pt;text-align:justify">19. 数据挖掘的应用过程</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 确定挖掘对象</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 准备数据（数据挖掘工作量的60%），包括○1数据选择；○2数据预处理（清洗）；○3数据转换。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 建立模型</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 数据挖掘</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 结果分析</p> 
<p style="margin-left:.0001pt;text-align:justify">f) 知识应用</p> 
<p style="margin-left:.0001pt;text-align:justify">20. 数据转储：DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 动态转储： 指转储期间允许对数据库进行存取或修改。即转储和用户事务可以并发执行。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 静态转储：在系统中无运行事务时进行的转储操作。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 增量转储：指每次只转储上一次转储后更新过的数据。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 海量转储：指每次转储全部数据库。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 从恢复角度看，使用海量转储得到的后备副本进行恢复一般说来会更方便些。但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效。</p> 
<p style="margin-left:.0001pt;text-align:justify">21. OLAP（联机分析处理）:通常用于对数据仓库进行数据挖掘；OLTP(联机事物处理)是面向事物程序的执行，通常对应密集型更新事物的程序，应用于对数据库的操作。OLAP没有严格的时间要求，OLTP是面向业务的，对时效要求比较高。OLAP用于数据挖掘以提供决策支持，OLTP用于具体的业务。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc3395"></a><a name="_Toc181">第八章</a> 关系数据库</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 关系模型是关系数据库的基础，由关系数据结构、关系操作集合和关系完整性规则组成。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 关系的度是指关系中属性的个数，关系的势指关系中元组的个数。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 在关系模型中所有的域都应该是原子数据（1NF）。</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 关系的三种类型：基本表、查询表、视图表</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 完整性约束：实体完整性、参照完整性、用户定义完整性。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 在关系代数中对传统的的集合运算要求参与运算的关系具有相同的度且对应属性取自同一个域。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">7. 关系运算：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 关系代数语言</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 关系演算语言</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 具有以上两种双重特点的语言（SQL）</p> 
<p style="margin-left:.0001pt;text-align:justify">8. 关系代数中的查询优化准则：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 尽可能早的执行选择运算</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 尽可能早的执行投影运算</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 避免直接做笛卡尔乘积，把笛卡尔乘积之前的操作和之后的一连串选择和投影合并起来一起做。</p> 
<p style="margin-left:.0001pt;text-align:justify">9. 关系模式的设计问题：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 数据冗余：同一数据重复出现多次。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 操作异常（更新异常）：修改异常、插入异常和删除异常。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 规范化的一个原则：“关系模式有冗余问题，就分解它”。</p> 
<p style="margin-left:.0001pt;text-align:justify">10. 关系模式的非形式化设计准则：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 关系模式的设计尽可能只包含直接联系的属性，不要包含有间接联系的属性。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 尽可能的不出现插入、删除和操作异常。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 尽可能的避免放置经常为空值的属性。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 尽可能的使等值连接在主键和外键上进行，并保证不会产生额外的元组。</p> 
<p style="margin-left:.0001pt;text-align:justify">11. 函数依赖：</p> 
<p style="margin-left:.0001pt;text-align:justify">a)  </p> 
<p style="margin-left:.0001pt;text-align:justify">b) 如果函数依赖集的闭包相等则函数依赖相等。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 若存在FD  W→A，如果W的任一个子集X没有X→A，则称W→A是完全函数依赖。否则叫局部函数依赖。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 传递函数依赖：如果X→Y,Y→A,且Y不→X, A不∈Y,则X→A是传递函数依赖。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) FD和关键码：设模式R的属性集U，X是U的一个子集，如果X→U在R上成立，那么X是R的一个超键。如果X→U在R上成立，但是对于任一真子集X1都有X1→U不成立（说明：不含多余属性），那么X是R的一个候选键。</p> 
<p style="margin-left:.0001pt;text-align:justify">f) 如果A是关系模式R中的候选键中的属性，那么称A是R的主属性，否则是非主属性。</p> 
<p style="margin-left:.0001pt;text-align:justify">g) 最小函数依赖：（不包含多余的函数依赖）满足一下三个条件（最小函数依赖集G）：</p> 
<p style="margin-left:.0001pt;text-align:justify">i. G中的每个FD的右边都是单属性。</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. G中没有冗余的FD。</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. G中的左边没有冗余的属性。</p> 
<p style="margin-left:.0001pt;text-align:justify">12. 关系模式的范式—规范化</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 1NF：如果关系R的每个关系r的属性值都是不可分的原子值。（规范化关系）</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 1NF存在的问题：冗余度大和更新异常。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 2NF：如果每个非主属性完全函数依赖于候选键。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 3NF扶沟每个非主属性都不传递依赖R的候选键。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) BCNF：如果每个属性都不传递函数依赖与R的候选键。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 4NF：设R是一个关系模式，D是R上的多值依赖函数，如果D中成立非平凡多值依赖X→→Y时（即X、Y在D中），X必是超键，那么R是4NF。</p> 
<p style="margin-left:.0001pt;text-align:justify">13. 关系模式R分解成2NF模式集：如果关系模式R中，存在FD  W→Z，X→Z，X?W,其中w是主键，Z是非主属性，则有W→Z是局部函数依赖。分解成R1（XZ），主键是X；R2（Y）,Y=U-Z，主键是W，外键是X。</p> 
<p style="margin-left:.0001pt;text-align:justify">14. 将模式R分解成3NF：如果关系模式R中，存在FD  W→Z，X→Z，X不是候选键,其中w是主键，Z是非主属性，Z不?X，则有W→Z是传递依赖。分解正R1（XZ），主键是X，R2（Y）,Y=U-Z，主键是W，外键是X。</p> 
<p style="margin-left:.0001pt;text-align:justify">15. 模式的分解有三种等价情况：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 分解具有无损连接性</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 分解要保持函数依赖</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 分解既要无损连接又要保持函数依赖</p> 
<p style="margin-left:.0001pt;text-align:justify">16. 无损分解的充要条件是：如果p(R1，R2)是R的一个分解则要满足：（R1∩R2）→(R1-R2)或是（R1∩R2）→(R2-R1)，或是R1∩R2是R1或是R2的超键，则是无损分解。</p> 
<p style="margin-left:.0001pt;text-align:justify">17. 保持函数依赖：设p(R1,R2... Rk)是R的一个分解，F是R上FD，如果有 ,则保持函数依赖。</p> 
<p style="margin-left:.0001pt;text-align:justify">18. 无损连接的测试：</p> 
<p style="margin-left:.0001pt;text-align:justify">设关系模式R=A1,…,An，R上成立的FD集F，R的一个分解p={R1,…,Rk}。无损连接分解的判断步骤如下：</p> 
<p style="margin-left:.0001pt;text-align:justify">(1)构造一张k行n列的表格，每列对应一个属性Aj(1≤j≤n)，每行对应一个模式Ri(1≤i≤k)。如果Aj在Ri中，那么在表格的第i行第j列处填上符号aj，否则填上符号bij。</p> 
<p style="margin-left:.0001pt;text-align:justify">(2)把表格看成模式R的一个关系，反复检查F中每个FD在表格中是否成立，若不成立，则修改表格中的元素。修改方法如下：对于F中一个FD：X→Y，如果表格中有两行在X分量上相等，在Y分量上不相等，那么把这两行在Y分量上改成相等。如果Y的分量中有一个是aj，那么另一个也改成aj;如果没有aj，那么用其中的一个bij替换另一个(尽量把ij改成较小的数，亦即取i值较小的那个)。</p> 
<p style="margin-left:.0001pt;text-align:justify">（3）若在修改的过程中，发现表格中有一行全是a，即a1,a2,…,an，那么可立即断定p相对于F是无损连接分解，此时不必再继续修改。若经过多次修改直到表格不能修改之后，发现表格中不存在有一行全是a的情况，那么分解就是有损的。特别要注意，这里有个循环反复修改的过程，因为一次修改可能导致表格能继续修改。</p> 
<p style="margin-left:.0001pt;text-align:justify">19.  候选关键字的判断：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) L类属性：只在函数依赖的左半部出现的属性；R类属性：只在函数依赖的左半部出现的属性；LR类属性，出现在函数依赖左右两边的属性；N类属性，两边都没出现的属性。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) ○1将关系模式R中的所有属性分为以上四类，用X表示L、N两类，用Y表示LR类。○2求X+，若X+包含关系模式的全部属性，则X为R唯一的候选键，否则下一步。○3在Y中取一属性A，求（XA）+，若包含R的全部属性，则转下一步，否则换另一个属性。○4若找到所有的候选键则结束，否则在Y中取两个、三个…，求他们属性的闭包，直到求出所有的候选键。</p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc14460"></a><a name="_Toc29845">第九章</a> SQL语言</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 建立基本表：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) CREATE TABLE C</p> 
<p style="margin-left:.0001pt;text-align:justify">(C# CHAR(4) ○1NOT NULL UNIQUE / ○2NOT NULL PRIMARY / ○3PRIMARY KEY,</p> 
<p style="margin-left:.0001pt;text-align:justify">CNAME CHAR(10) NOT NULL)</p> 
<p style="margin-left:.0001pt;text-align:justify">b) CRATE TABLE C</p> 
<p style="margin-left:.0001pt;text-align:justify">(C# CHAR(4)○1,</p> 
<p style="margin-left:.0001pt;text-align:justify">CNAME CHAR(10) NOT NULL,</p> 
<p style="margin-left:.0001pt;text-align:justify">PRIMARY KEY(C#))注：此时可省略○1</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 定义外键时，可以合起来写：T# CHAR(4) FOREIGN  KEY(T#) REFERENCES T(T#),也可以分两行写T# CHAR(4) ，</p> 
<p style="margin-left:.0001pt;text-align:justify">FOREIGN KEY (T#) REFERENCES T(T#)，</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 定义级联删除，在定义B表外键（A表的主键）属性时加上ON DELETE CASCADE。此时删除A表的主键时，其主键在相应表中是外键（B表的外键）会被同时删除。也可以定义触发器。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 基本表的修改：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 增加新的列：ALTER TABLE&lt;基本表名&gt;ADD&lt;列名&gt;&lt;类型&gt;{可设置缺省值0,——DEFAULT=0}</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 删除列：ALTER TABLE&lt;基本表名&gt;DROP COLUMN&lt;列名&gt;[完整性约束条件CASCADE|RESTRICT]</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 修改数据类型：○1ALTER TABLE&lt;基本表名&gt;ALTER COLUMN&lt;列名&gt;&lt;类型&gt;○2ALTER TABLE&lt;基本表名&gt;MODIFY&lt;列名&gt;&lt;类型&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 基本表的撤销：DROP TABLE&lt;基本表名&gt;[CASCADE|RESTRICT]</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 数据删除：DELETE FROM &lt;基本表名&gt; WHERE &lt;条件表达式&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 注：CASCADE表示所有约束和视图也自动删除，RESTRICT表示没有视图和约束时才能删除。</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 数据修改：UPDATE&lt;基本表名&gt; SET&lt;列名&gt;  =  &lt;值表达式&gt; WHERE&lt;条件表达式&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify">8. 创建索引：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 索引的作用：通过创建唯一的索引，可以保证数据的唯一性；提高数据的检索速度；可以加速表与表之间的连接，对于实现数据的参照完整性有很重要的意义；使用ORDER BY和GROUP BY 检索时可减少查询中组和排序的时间。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 聚簇索引对表的物理数据页中的数据按列进行排序，然后再重新存储到磁盘上，即聚簇索引与数据是混为一体的，它的也节点中存放的是实际的数据。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 非聚簇索引是具有完全独立于数据行的结构，不用将物理数据页中的数据按列排序，节点中存放的是索引的关键字值和行定位置。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 创建索引：CREATE [UNIQUE][CLUSTERE] INDEX&lt;索引名&gt;ON&lt;基本表名&gt;(&lt;列名[DESC][ASC]&gt;, &lt;列名[DESC][ASC]&gt;,….)</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 删除索引：DROP INDEX&lt;索引名&gt;，&lt;索引名&gt;，…</p> 
<p style="margin-left:.0001pt;text-align:justify">9. 视图的操作：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 视图是建立在查询的基础上的，是一张虚拟表，视图的数据必不是按视图存储结构保存在数据库中，而是存储在视图所引用的表中。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 视图的优缺点：视图更新数据实时、安全、存储空间只占用代码的空间，但是执行过程有些慢。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 视图的创建：CREATE VIEW&lt;视图名&gt;（&lt;列名序列&gt;）AS &lt;SELECT 查询语句&gt;[WITH CHECK OPTION]</p> 
<p style="margin-left:.0001pt;text-align:justify">注：子查询（SELECT语句）中通常不允许出现ORDER BY子句和DISTINCT。WITH CHECK OPTION允许用户更新视图。其中列名要么全部省略要么全部指定。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 视图删除：DROP  VIEW&lt;视图名&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 视图更新(只有行列子集视图（视图是从单个基本表只使用选择、投影操作导出的）)</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">10. 数据定义语言（DDL）：CREATE、ALTRE、DROP;数据操作语言（DML）：SELECT、INSERT、DELETE、UPDATE;数据控制语言（DCL）：约束权限</p> 
<p style="margin-left:.0001pt;text-align:justify">11. 查询语句：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">12. UNION 操作符用于合并两个或多个 SELECT 语句的结果集。默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。如：</p> 
<p style="margin-left:.0001pt;text-align:justify">SELECT column_name(s) FROM table_name1</p> 
<p style="margin-left:.0001pt;text-align:justify">UNION</p> 
<p style="margin-left:.0001pt;text-align:justify">SELECT column_name(s) FROM table_name2</p> 
<p style="margin-left:.0001pt;text-align:justify">13. SQL的左连接等：http://www.cnblogs.com/afirefly/archive/2010/10/08/1845906.html</p> 
<p style="margin-left:.0001pt;text-align:justify">14. 字符使用：sname like’王%’匹配‘王’后面任意个字符；sname like‘王_’匹配‘王’后面一个字符；如果模式中包含特殊字符就要用到转意符，用关键字escape来定义，如：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">15. SQL中完整性约束：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 越约束：定义一个新域COLOR</p> 
<p style="margin-left:.0001pt;text-align:justify">CERATE DOMAIN COLOR CHAR(6)  DEFAULT’???’—将颜色默认设置为？？？</p> 
<p style="margin-left:.0001pt;text-align:justify">CONSTRANINT  COLORS—表示为这个域约束起名为colors</p> 
<p style="margin-left:.0001pt;text-align:justify">CHECK(VALUE  IN</p> 
<p style="margin-left:.0001pt;text-align:justify">(’Red’,’Yellow’.’Blue’.’Green’,???’))</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 基本表的约束：主键、外键、检查（CHECK）</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 断言（ASSERTIONS）:</p> 
<p style="margin-left:.0001pt;text-align:justify">CERATE  ASSERTION&lt;断言名&gt;CHEC0（&lt;条件&gt;）</p> 
<p style="margin-left:.0001pt;text-align:justify">DROP ASSERTION&lt;断言名&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify">16. SQL中的安全性机制：视图、权限、角色、审计。</p> 
<p style="margin-left:.0001pt;text-align:justify">17. SQL中的完整性约束：域约束、基本表约束、断言、触发器。</p> 
<p style="margin-left:.0001pt;text-align:justify">18. 权限</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 用户权限（6种）：select、insert、delete、update、references、usage其中references表示允许用户定义新的关系，引用其它关系的主键做为外键；usage允许用户使用已定义的域。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 授权语句：GRANT&lt;权限表&gt;ON&lt;数据库元素&gt;TO&lt;用户名表&gt;[WITH GEANT OPTION] WITH GEANT OPTION表示获得的权限还能获得传递权限，装权限授给别的用户。如：  </p> 
<p style="margin-left:.0001pt;text-align:justify">其中ALL PRIVILEGES表示用全部权限（以上6种）。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 回收语句：REVOKE&lt;权限表&gt;ON&lt;数据库元素&gt;FROM&lt;用户名表&gt;[RESTRICT|CASCADE] CASCADE表示连锁回收，RESTRICT不存在连锁回收时才能进行回收。如：  </p> 
<p style="margin-left:.0001pt;text-align:justify">PUBLIC表示多有当前的或是将来的可能出现的所有用户。</p> 
<p style="margin-left:.0001pt;text-align:justify">19. 触发器的使用;触发器是一个由系统自动执行的对数据库进行修改的语句。触发器由事件、条件和动作三个部分组成。</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 创建触发器：CERATE TRIGGER &lt;名&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">b) 删除触发器：DROP TRIGGER &lt;名&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify">20. 嵌入式SQL</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 区分SQL语句和主语言语句（格式）：EXEC SQL&lt;SQL语句&gt;END_SQL（C语言中用；而不用END_SQL）</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 主语言工作单元与数据库工作单元的通信：</p> 
<p style="margin-left:.0001pt;text-align:justify">i. SQL通信区（SQLCA）：向主语言传递SQL语句执行的状态信息，是主语言能够根据次信息控制程序流程。</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 共享变量（主变量）：主语言通过主变量向sql语句提供参数，由主语言定义，sql中DECLARE语句说明。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 游标（CURSOR）：主语言是面向记录的而sql语言是面向集合的，通过游标可获取多条记录或获取指定的记录。</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 定义游标：</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 打开游标：</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. 推进游标：游标推进一行并把当前值送到主变量中，</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">iv. 关闭游标：</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 动态SQL语句：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">21. 存储过程：由SQL语句和流程控制语句编写的模块，经过编译和优化后存储在数据库服务器端的数据库中。具有一下优点：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 提高运行速度。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 增强了SQL的功能和灵活性。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 可降低网络的通信量。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 减轻了程序编写的工作量。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 间接实现安全控制功能。</p> 
<p style="margin-left:.0001pt;text-align:justify">f) 屏蔽表的细节，简化用户操作。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc27047"></a><a name="_Toc27517">第十章</a> 系统开发与运行</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 软件生存周期的六个阶段：项目计划、需求分析、设计、编码、测试、运行和维护。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 软件开发模型：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 瀑布模型：最早，采用结构化分析与设计方法。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 演化模型：全局开发模型，也叫快速原型模型。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 螺旋模型：结合瀑布模型和快速原型模型，增加了风险分析，使用与大型系统。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 喷泉模型：以用户需求为动力，以对象驱动的模型，采用面像对象开发。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 需求分析阶段是软件工程的重要阶段，它为一个新系统定义业务需求。需求分析阶段的关键是描述一个系统是什么，或者一个系统必须做什么，而不是系统应该如何实现。具体来说，需求分析阶段需完成以下要求：</p> 
<p style="margin-left:.0001pt;text-align:justify">? 确定软件系统的功能需求和非功能需求；</p> 
<p style="margin-left:.0001pt;text-align:justify">? 分析软件系统的数据要求；</p> 
<p style="margin-left:.0001pt;text-align:justify">? 导出系统的逻辑模型；</p> 
<p style="margin-left:.0001pt;text-align:justify">? 修正项目开发计划；</p> 
<p style="margin-left:.0001pt;text-align:justify">? 如有必要，可以开发一个原型系统。</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 软件设计通常可分为概要设计和详细设计。概要设计的任务是确定软件系统的结构、进行模块划分、确定每个模块的功能、接口以及模块间的调用关系。设计软件系统的结构，主要任务是确定模块间的组成关系。</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 系统测试是将软件系统与硬件、外设和网络等其他因素结合在一起，进行信息系统的各种组装测试和确认测试，其目的是通过与系统地需求相比较，发现所开发的系统与用户需求不符或矛盾的地方。常见的系统测试主要有恢复测试、安全性测试、强度测试、性能测试、可靠性测试和安装测试。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 软件项目估算：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 代码行、功能点和工作量估算是最基本项目估算内容。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) IBM估算模型：基于代码行的静态单变量模型。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) CoCoMo（构造性成本）模型：分为基本、中级和详细3个级别，将软件项目类型分为组织型、半独立型和嵌入型。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) Putnam模型：动态多变量模型。</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 风险分析：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 风险识别:性能风险、成本风险、支持风险、进度风险。建立风险条目检查表。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 风险预测：建立风险表，估计风险对项目的影响。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 风险评估：进一步审查在风险预测阶段所做的估算的精确度， 试图为所发现的风险排出优 先次序，并开始考虑如何控制和/或避免可能发生的风险。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 风险控制：风险避免、风险监控、风险管理及监控计划。</p> 
<p style="margin-left:.0001pt;text-align:justify">8. 进度管理（安排）通常使用Grant（甘特图）和PERT（计划评审技术）图。PERT图和Gantt图是两种常用的项目管理工具。PERT（项目评估与评审技术）图是一种图形化的网络模型，描述一个项目中的任务和任务之间的关系。Gantt图是一种简单的水平条形图，它以一个日历为基准描述项目任务。Gantt图中横坐标表示时间（如时、天、周、月、年等），纵坐标表示任务，图中的水平线段表示对一个任务的进度安排，线段的起点和终点对应在横坐标上的时间分别表示该任务的开始时间和结束时间，线段的长度表示完成该任务所需的时间。</p> 
<p style="margin-left:.0001pt;text-align:justify">9. Grant不能反应出个任务之间的依赖关系。</p> 
<p style="margin-left:.0001pt;text-align:justify">10. PERT不能反映任务之间的并行性。</p> 
<p style="margin-left:.0001pt;text-align:justify">11. CMM是对软件组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进其软件过程，软件组织的能力经过这些阶段逐步前进。CMM将软件过程的成熟度分为5个等级，分别为：</p> 
<p style="margin-left:.0001pt;text-align:justify">? 初始级。软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，成功完全依赖个人努力和英雄式的核心任务。</p> 
<p style="margin-left:.0001pt;text-align:justify">? 可重复级。建立了基本的项目管理过程来跟踪成本、进度和机能，有必要的过程准则来重复以往在同类项目中的成功。</p> 
<p style="margin-left:.0001pt;text-align:justify">? 定义级。管理和工程的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有的项目都采用根据实际情况修改后得到的标准软件过程来发展和维护软件。</p> 
<p style="margin-left:.0001pt;text-align:justify">? 管理级。制定了软件工程和产品质量的详细度量标准。软件过程和产品的质量都被开发组织的成员所理解和控制。</p> 
<p style="margin-left:.0001pt;text-align:justify">?优化级。加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能持续不断地改进。</p> 
<p style="margin-left:.0001pt;text-align:justify">12. 软件开发方法：结构化方法、面向数据结构方法、原型法、对象建模。</p> 
<p style="margin-left:.0001pt;text-align:justify">13. 软件质量特特性：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 第一层：质量特性</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 第二层：质量子特性</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 第三层：量度指标</p> 
<p style="margin-left:.0001pt;text-align:justify">14. 系统分析阶段的主要工作：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 对当前系统进行详细调查，收集数据。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 建立当前系统的逻辑模型</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 对现状进行分析，提出改进意见和新系统应达到的目标</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 建立新系统的逻辑模型</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 编写系统方案的说明书</p> 
<p style="margin-left:.0001pt;text-align:justify">15. 系统分析的方法：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 结构化分析方法</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 面向对象分析方法</p> 
<p style="margin-left:.0001pt;text-align:justify">16. 面向数据结构的分析和设计（Jackson）：设计原则是使程序结构与数据结构（问题结构）相对应；以数据结构作为设计基础，根据输入/输出数据结构导出程序结构，使用与规模不大的数据处理系统。</p> 
<p style="margin-left:.0001pt;text-align:justify">17. UML：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 用例图；静态图（类图、对象图、包图）；行为图（状态图、活动图）；交互图（顺序图、协作图）；实现图（构建图、部署图）。</p> 
<p style="margin-left:.0001pt;text-align:justify">   </p> 
<p style="margin-left:.0001pt;text-align:justify">18. 聚合关系——整体-部分关系；泛化关系——一般-特殊关系。</p> 
<p style="margin-left:.0001pt;text-align:justify">19. 软件测试：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 白盒测试（结构测试）：根据程序内部结构和逻辑结构及相关信息设计测试用例，检查程序中所有逻辑路径是否满足要求。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 黑盒测试（行为测试）：不必考虑程序内部的逻辑结构和内部特性，只需根据程序的需求规格说明书，检查是否满足要求。</p> 
<p style="margin-left:.0001pt;text-align:justify">20. CVS是一种版本控制工具。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc21588"></a><a name="_Toc29">第十一章</a> 数据库设计</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 数据库系统生命周期：数据库规划、需求分析与收集、数据库设计、数据库系统实现、测试阶段、运行维护</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 数据字典：是对用户信息要求的整理和描述（需求分析阶段）。包括数据项、数据结构、数据流、数据存储和处理过程。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 需求分析阶段的任务：○1分析用户活动，产生业务流图；○2确定系统范围，产生系统关联图；○3分析用户活动涉及的数据，产生数据流图；○4分析系统数据产生数据字典。</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 需求分析阶段的成果是系统说明书，包括数据流图、数据字典和各种说明性文档等。</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 数据流图（DFD）：顶层DFD确定系统边界，将待开发的系统看做是一个加工，因此只有唯一一个加工和一些外部实体以及两者之间的输入输出数据流。0层DFD确定数据存储。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 面向数据结构的方法（Jackson方法）</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 设计思想：以数据结构作为设计基础，它根据输入/输出数据结构导出程序结构，适用于规模不大的数据处理系统。</p> 
<p style="margin-left:.0001pt;text-align:justify">b)  基本思想:从问题的数据结构导出它的程序结构.作为独立的系统设计方法主要用于小规模数据处理的开发.</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 考虑问题的出发点是:数据结构.</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 最终目标:得出程序的过程性描述.</p> 
<p style="margin-left:.0001pt;text-align:justify">e)  最佳适用范围:详细设计中,确定部分或全部模块的逻辑过程.</p> 
<p style="margin-left:.0001pt;text-align:justify">f) 遵守结构程序设计“由顶向下”逐步细化的原则,并以其为共同的基础; “程序结构必须适应问题结构” 的基本原则,各自拥有从问题结构(包括数据结构)</p> 
<p style="margin-left:.0001pt;text-align:justify">g) 服从导出程序结构的一组映射规则.</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 画DFD的注意事项：</p> 
<p style="margin-left:.0001pt;text-align:justify">1）应适当的为数据流、加工、数据存储以及外部实体命名，名字应该反映该成分的实际含义，避免使用空洞的名字。</p> 
<p style="margin-left:.0001pt;text-align:justify">2）画数据流图，不是画控制流。</p> 
<p style="margin-left:.0001pt;text-align:justify">3）一个加工的输出数据流，不应与输入数据流同名，及时他们的组成完全相同。</p> 
<p style="margin-left:.0001pt;text-align:justify">4）允许一个加工有多条数据流流向另一个加工，也允许一个加工有两条相同的输出数据流流向不同的加工。</p> 
<p style="margin-left:.0001pt;text-align:justify">5）保持父图与子图的平衡。也就是说，父图中的某加工的输入输出流必须与他的子图的输入输出数据流在数量上和名字上相同。值得注意的是，如果父图中的一个输入（输出）数据流对应于子图中的几个输入（输出）数据流，而子图中组成这些数据流的数据项的全体正好是父图中的这一个数据流，那么他们仍然算是平衡的。</p> 
<p style="margin-left:.0001pt;text-align:justify">6）在自顶向下的分解过程中，若一个数据存储首次出现时，只与一个加工有关系，那么这个数据存储应作为这个加工的内部文件而不必画出。</p> 
<p style="margin-left:.0001pt;text-align:justify">7）保持数据守恒，也就是，一个加工的所有输出数据流中的数据必须能从该加工的输出流中直接获得，或者通过该加工能产生的数据。8）每个加工必须既有输入数据流，又有输出数据流。</p> 
<p style="margin-left:.0001pt;text-align:justify">9）在整套数据流图中，每个数据存储必须既有读的数据流，又有写的数据流。但是在某张子图中，可能只有读没有写，或者只有写没有读。</p> 
<p style="margin-left:.0001pt;text-align:justify">10）数据流必须通过加工（也就是外部实体与外部实体，外部实体与数据存储之间不能存在数据流）</p> 
<p style="margin-left:.0001pt;text-align:justify">8. 概念设计阶段——E-R图</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 对现实事物的抽象的三种方法：分类（固有的共同特征和行为，如：学生和教师是不通的分类）、聚集（定义某一类型的所具有的属性，如：学生的学号、姓名等）和概括（由已知类型定义一个新的类型，即得到一个子类，如：研究生是学生的子类，从学生类型中延伸出来）。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 用E-R图建立概念模型：</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 进行数据抽象：根据数据流图使用以上三种抽象方法进行抽象，从高层（对数据的引用笼统）到低层（比较细致）。</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 设计局部概念模型：确定局部应用中的实体、实体的属性、实体标识符和实体间的联系。注意：1）属性不可再分；2）属性不能与其它实体之间有直接联系。</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. 将局部模型综合成全局模型：其中要消除冲突，属性冲突（类型等）、结构冲突（抽象不同、属性组成不同等）和命名冲突（实体名、属性名和联系名等）。</p> 
<p style="margin-left:.0001pt;text-align:justify">iv. 全局ER模型的优化</p> 
<p style="margin-left:.0001pt;text-align:justify">○1合并实体类型：</p> 
<p style="margin-left:.0001pt;text-align:justify">○2消除冗余属性</p> 
<p style="margin-left:.0001pt;text-align:justify">○3消除冗余联系</p> 
<p style="margin-left:.0001pt;text-align:justify">9. 逻辑设计阶段——E-R图向关系模式的转换</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 逻辑设计阶段的主要任务：确定数据模型、将ER模型转换为制定的数据模型、确定完整性约束、确定用户视图。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) E-R图向关系模式的转换（转换成计算机能识别的）：</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 实体类型的转换：将每个实体类型转换成关系模式，实体名对应模式名，属性对应模式的属性，实体标识符对应模式的键。</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 联系类型的转换（二元联系）：○1若实体间的联系是1 ：1的，在转换好的两个关系模式中任意一个模式的属性中加入另一个的主键（作为当前模式的外键）和联系的属性。○2若实体类型之间的联系是1 ：N，则在N端转换来的模式中加入1端实体类型的主键（作为当前模式的外键）和联系的属性。○3若实体间的联系是M:N，则将联系类型也转换成关系模式，其属性为实体两端的实体类型的键加上联系类型的实行，主键为两端实体的之间的组合（同时两个主键也是外键）。</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. 三元联系的转换：○1若实体间的联系是1：1：1，则转换得的3个模式中任意一个中加入另外两个的主键（作为当前模式的外键）和联系类型的属性。○2若实体间的联系是1：1：N，则在N端加入两个1端的主键（作为当前模式的外键）和联系类型的属性。○3若实体间的联系是1：N: M，则联系类型也要转换成关系模式，其属性为M端和N端的实体类型的主键（作为外键）加上联系类型的属性，主键为M和N端的主键的组合。○4若实体间的联系是M:N:P，则联系类型也转换成关系模式，其属性为三端实体类型的主键（作为外键）加上联系类型的属性，而主键为三端实体主键的组合。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 关系模式的规范化</p> 
<p style="margin-left:.0001pt;text-align:justify">i. 根据语义确定关系模式都的数据依赖。</p> 
<p style="margin-left:.0001pt;text-align:justify">ii. 根据数据依赖确定关系模式的范式。</p> 
<p style="margin-left:.0001pt;text-align:justify">iii. 如果不符合要求则根据模式的分解算法进行分解到达3NF、BCNF或是4NF。</p> 
<p style="margin-left:.0001pt;text-align:justify">iv. 关系模式的评价与修正。消除冗余更新异常等。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 确定完整性约束。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 确定用户视图（设计子模式）。提高数据的安全性和独立性。</p> 
<p style="margin-left:.0001pt;text-align:justify">10. 物理设计阶段——数据库的存储结构和存取方法（确定数据分布、确定存储结构、确定存取方式）</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 存储记录的结构设计</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 确定数据的存放位置</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 存取方法的设计</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 完整性和安全性的考虑</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 程序设计</p> 
<p style="margin-left:.0001pt;text-align:justify">11. 数据库的实现：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 用DDL定义数据库的结构</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 组织数据入库</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 编制与调试应用程序</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 数据库试运行</p> 
<p style="margin-left:.0001pt;text-align:justify">12. 数据库的安全性措施：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 权限机制</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 视图机制</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 数据加密</p> 
<p style="margin-left:.0001pt;text-align:justify">13. 在绘制数据流图的加工时可能会出现输入和输出错误：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 只有输入没有输出或者是黑洞；</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 只有输出没有输入或者是奇迹</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 输入的数据流无法通过加工产生输出流活着是灰洞</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 输入的数据流与输出的数据流名称相同</p> 
<p style="margin-left:.0001pt;text-align:justify">14. 数据库的并发控制：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 并发操作带来的问题：数据的不一致性（丢失修改、读脏数据和不可重复读问题）。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 解决问题的方法：从保证事物的隔离性入手。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 解决问题的焦点：事物在读取数据时不加控制而相互干扰。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 封锁协议：两段封锁协议，缩短了持锁时间，提高了并发度，同时解决了数据的不一致性。为了事物并发调度的正确使用两段封锁协议。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 可串行化（性）是并发事物的正确性准则。</p> 
<p style="margin-left:.0001pt;text-align:justify">15. 类图是显示一组类、接口、协作以及它们之间关系的图。类图用于对系统的静态设计视图建模。当对系统的静态视图建模时，通常以下述3种方式之一使用类图。</p> 
<p style="margin-left:.0001pt;text-align:justify">1) 对系统的词汇建模。</p> 
<p style="margin-left:.0001pt;text-align:justify">2) 对简单协作建模。</p> 
<p style="margin-left:.0001pt;text-align:justify">3) 对逻辑数据库模式建模。将模式看作为数据库的概念设计的蓝图。在很多领域中，要在关系数据库或者面向对象数据库中存储永久信息，可以用类图对这些数据库的模式建模。</p> 
<p style="margin-left:.0001pt;text-align:justify">16. 状态图显示一个由状态、转换、事件和活动组成的状态机。用状态图说明系统的动态视图。状态图对接口、类或协作的行为建模是非常重要的。状态图强调一个对象按事件次序发生的行为。</p> 
<p style="margin-left:.0001pt;text-align:justify">17. 活动图显示从活动到活动的流。活动图显示了一组活动，从活动到活动的顺序的或分支的流，以及发生动作的对象或动作所施加的对象。用活动图说明系统的动态视图。活动图对系统的功能建模是非常重要的。活动图强调对象之间的控制流。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc5553"></a><a name="_Toc17249">第十二章</a> 网络与数据库</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 分布式数据库应该有场地透明性和分散存储两个特点。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 完全分布式式数据库应满足：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 分布性</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 逻辑相关性</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 场地透明性</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 场地自治性</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 分布式数据库的特点：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 数据的集中控制性</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 数据独立性</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 数据冗余可靠性</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 场地自治性</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 存取的有效性</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 分布式数据库的体系结构：四层模式结构——全局外层、全局概念层、局部概念层、局部内层。</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 分布式事务有两段提交协议（2PC）和三段提交协议（3PC）。</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 2PC：协调者和参与者，只有协调者才有提交和撤销事务的表决权，其步骤是先表决后执行。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 3PC：在2PC的基础上增加了全局预提交和准备两个报文，确认所有参与者的状态。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 分布式事务故障比集中式事务故障多了通信故障（介质故障、系统故障、事务故障）。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 分布式数据库的透明性：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 分布透明性：用户不必关心数据的逻辑分区和数据的物理位置分布的细节及不必关心数据一致性的问题和局部数据库支持的数据模型。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 分片透明性：用户不必关心数据的逻辑分片。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 位置透明性：用户不必关心数据物理位置分配的细节。</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 复制透明性：用户不必关心数据库在网路中各个结点的复制情况，被复制的数据更新由系统自动完成。</p> 
<p style="margin-left:.0001pt;text-align:justify">e) 局部数据模型透明性：不必关心局部数据使用的何种数据模型。</p> 
<p style="margin-left:.0001pt;text-align:justify">7. XML和数据库之间传输数据：模版驱动和模型驱动。</p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc6556"></a><a name="_Toc28315">第十三章</a> 数据库发展趋势与新技术</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 数据转移技术：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 数据仓库中数据转移的的目的有：改进数据仓库中数据的质量和提高数据仓库中数据的可用性。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 数据转移类型：</p> 
<p style="margin-left:.0001pt;text-align:justify">1） 简单转移：简单转移是所有数据转移的基本单元。</p> 
<p style="margin-left:.0001pt;text-align:justify">2） 清洗：为了保证前后一致地格式化和使用某字段或是字段群。</p> 
<p style="margin-left:.0001pt;text-align:justify">3） 集成：将业务数据从一个或几个来源取出，并逐字段的将数据映射到数据仓库的新数据结构上。</p> 
<p style="margin-left:.0001pt;text-align:justify">4） 聚集和概括：从业务环境中找到零星的数据压缩成数据仓库中的较少数据块。</p> 
<p style="margin-left:.0001pt;text-align:justify">2. 面向对象数据库引入了数组（集合）类型和结构类型两种构造数据类型。将组合属性（如日期）转换为结构类型，多值属性转换为集合类型。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 并行数据库的目标：实现高性能、高可用性、可扩充性。</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 并行数据库的体系结构：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 共享内存结构</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 共享磁盘结构</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 无共享资源结构（具有独领的处理器、内存和磁盘）。</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 对象-关系数据库系统：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 嵌套关系：</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 复合类型：setof</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 继承类型：under</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 引用类型：ref</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 企业资源计划发展经历了基本MPR、闭环的MPR、MPR-Ⅱ和ERP，其中基本的MPR着重管理企业的物料需求计划，闭环的MPR强调了生产能力对需求计划的影响，MPR-Ⅱ阶段的时候围绕着企业的基本经营目标，以生产计划为主线，ERP理论以一个中心（以盈利为中心），两类业务（计划和执行）和三条干线（供应链管理、生产管理和财务管理），并将三条干线紧密结合在一起。</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 决策支持系统（DSS）由数据库子系统、模型库子系统、人机交互系统（模型库与数据库的有机结合）、用户构成。DSS增加了模型库和模型库管理系统。在DSS的基础上增加知识库子系统（包含知识库和推理机+）形成智能DSS。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc4427"></a><a name="_Toc25738">第十四章</a> 知识产权基础知识</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 保护期限:</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">2. 知识产权的时间性概念：知识产权具有法定的保护期限，一旦保护期限届满，权利将自行终止，成为社会公众可以自由使用的知识。至于期限的长短，依各国的法律确定。我国发明专利的保护期为20年，实用新型专利权和外观设计专利权的期限为10年，均自专利申请日起计算；我国公民的作品发表权的保护期为作者终生及其死亡后50年。我国商标权的保护期限自核准注册之日起10年，但可以根据其所有人的需要无限地续展权利期限，在期限届满前6个月内申请续展注册，每次续展注册的有效期10年，续展注册的次数不限。如果商标权人逾期不办理续展注册，其商标权也将终止。商业秘密受法律保护的期限是不确定的，该秘密一旦为公众所知悉，即成为公众可以自由使用的知识。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 知识产权人的确定:</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">4. 侵权判断：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">5. 授予专利权的条件：新颖性、创造性、实用性。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 专利制度的基本特点是：法律保护、科学审查、公开通报和国际交流。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><a name="_Toc19871"></a><a name="_Toc22483">第十五章</a> 标准化基础知识</p> 
<p style="margin-left:.0001pt;text-align:justify">1. 标准化的基本概念：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">2. 标准化的实质：通过制定、发布和实施标准，达到统一。</p> 
<p style="margin-left:.0001pt;text-align:justify">3. 标准化的目的：获得最佳秩序和社会效益。</p> 
<p style="margin-left:.0001pt;text-align:justify">4. 制定标准的原则：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 要从全局利益出发，认真贯彻国家技术经济政策。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 充分满足使用要求。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 有利于促进经济技术的发展。</p> 
<p style="margin-left:.0001pt;text-align:justify">5. 制定标准的阶段：申请、预备、委员会、审查、发布阶段。</p> 
<p style="margin-left:.0001pt;text-align:justify">6. 标准更新：标准复审（复审周期一般不超过五年）、标准确认、标准修订。</p> 
<p style="margin-left:.0001pt;text-align:justify">7. 标准的分类：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 按适用范围：国际（ISO/IEC国际标准化组织）、国家、区域、行业、地方、企业、项目规范。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 按性质：技术标准、管理标准和工作标准。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 按作用：基础标准、产品标准、方法标准、安全标准、卫生标准…</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 按法律约束性：强制标准、推荐标准。</p> 
<p style="margin-left:.0001pt;text-align:justify">8. 标准的编号：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 国际国外：标准代号+专业类号+顺序年号+年代号</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 我国：强制性用GB；推荐性用GB/T</p> 
<p style="margin-left:.0001pt;text-align:justify">9. 常见的标准化组织：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">10. 我国的标准分类：</p> 
<p style="margin-left:.0001pt;text-align:justify">a) 国家标准：(纸板)QB 1457-1992;QB/T 1315-1991;GSB（国家事物标准）。</p> 
<p style="margin-left:.0001pt;text-align:justify">b) 行业标准：教育行业标准（JY）、金融行业标准（JR）、有点通信行业标准（YD）、医药行业标准（YY）、航天（QJ）、电子行业（SJ）、机械行业（JB）。</p> 
<p style="margin-left:.0001pt;text-align:justify">c) 地方标准：DB加上省市代码前两位；上海DB31、重庆DB55、北京DB11.</p> 
<p style="margin-left:.0001pt;text-align:justify">d) 企业标准：Q+/+企业代号。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">11. 软件工程的标准化：</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">12. 国家标准——《计算机软件文档编制规范》，一般产生14中文件，其中管理人员主要使用的有：项目开发计划、可行性研究报告、模版开发卷宗、开发进度月报、项目开发总结报告。开发人员使用：软件需求说明书、项目开发计划、模版开发卷宗、数据需求说明书、概要设计说明书、详细设计说明书、数据库设计说明书、测试计划和测试分析报告。维护人员使用：设计说明书、模版开发卷宗和测试分析报告。</p> 
<p style="margin-left:.0001pt;text-align:justify">13. 标准的复审：ISO标准每5年复审一次，平均标龄4.92年，我过标准有效期一般为5年。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>