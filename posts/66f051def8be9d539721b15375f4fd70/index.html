<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>江湖救急笔记——NOSQL - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">江湖救急笔记——NOSQL</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p>声明：</p> 
<p>·以功利的角度记笔记，有些太难/自己觉得考不到<s>/太累的懒得记</s>的点会记得比较简单！</p> 
<p>·能力有限，并不能100%保证正确。如果有不同的看法和认识一定要自己思考！</p> 
<p>·这门课没有明确的考点，所以很多东西是我觉得重要就写上了……似乎这门课会有很多半开放的设计类题目（瞟到过几眼往年）</p> 
<p>·word文档粘贴的，估计会有一些奇奇怪怪的地方……</p> 
<p style="margin-left:.0001pt"><span style="color:#2f5496">目录</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><a href="#_Toc92016418">第一章——NOSQL概述.. 2</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016419">一、4V理论.. 2</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016420">二、大数据思维.. 2</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016421">三、关系数据库VS NOSQL. 2</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016422">1.两种数据库对比.. 2</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016423">2.关系数据库的优势.. 2</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016424">3.关系数据库的劣势.. 3</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016425">4.NoSQL数据库特点.. 3</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016426">四、去IOE. 3</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016427">五、数据模型发展.. 3</a></p> 
<p style="margin-left:.0001pt;text-align:justify"><a href="#_Toc92016428">第二章——NOSQL理论基础.. 4</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016429">一、ACID. 4</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016430">1.原子性Atomicity. 4</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016431">2.一致性Consistency. 4</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016432">3.隔离性Isolation. 4</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016433">4.持久性Durability. 5</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016434">二、CAP. 5</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016435">1.强一致性Consistency. 5</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016436">2.可用性Availability. 5</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016437">3.分区容错性Partition Tolerance. 5</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016438">4.不同原则的取舍结果.. 5</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016439">三、BASE. 6</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016440">1.基本可用Basic Available. 6</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016441">2.软状态/柔性事务Soft-state. 6</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016442">3.最终一致性Eventual Consitency. 7</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016443">4.与ACID的对比.. 7</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016444">5.eBay模式.. 7</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016445">四、数据一致性实现技术.. 7</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016446"><span style="background-color:#FFFF00">1.Paxos</span><span style="background-color:#FFFF00">协议</span>.. 7</a></p> 
<p style="margin-left:24pt;text-align:justify"><a href="#_Toc92016447">五、NOSQL数据库水平扩展.. 10</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016448">1.水平扩展基础.. 10</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016449">2.分片与复制.. 10</a></p> 
<p style="margin-left:48pt;text-align:justify"><a href="#_Toc92016450"><span style="background-color:#FFFF00">3.</span><span style="background-color:#FFFF00">分片的数据划分方式</span><span style="background-color:#FFFF00">——</span><span style="background-color:#FFFF00">一致性哈希</span>.. 11</a></p> 
<p style="margin-left:.0001pt;text-align:justify"><a href="#_Toc92016451">第三章——.. 14</a></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:left"></p> 
<h1 style="margin-left:0;text-align:justify">
<a name="_Toc92016418">第一章——NOSQL</a>概述</h1> 
<h2 style="margin-left:0;text-align:justify">
<a name="_Toc92016419">一、4V</a>理论</h2> 
<p style="margin-left:.0001pt;text-align:justify">·规模Volume</p> 
<p style="margin-left:.0001pt;text-align:justify">数据量大，从TB到PB到EB</p> 
<p style="margin-left:.0001pt;text-align:justify">·速率Velocity</p> 
<p style="margin-left:.0001pt;text-align:justify">对实时处理要求高</p> 
<p style="margin-left:.0001pt;text-align:justify">·多样Variety</p> 
<p style="margin-left:.0001pt;text-align:justify">除了结构化数据，还有大量非结构化数据（文本、音视频）</p> 
<p style="margin-left:.0001pt;text-align:justify">·价值Value</p> 
<p style="margin-left:.0001pt;text-align:justify">价值密度低，但经过提纯后总价值高</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc92016420">二、大数据思维</a></h2> 
<p style="margin-left:.0001pt;text-align:justify">·全样而非抽样</p> 
<p style="margin-left:.0001pt;text-align:justify">·效率而非精确</p> 
<p style="margin-left:.0001pt;text-align:justify">·相关而非因果（有争议）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc92016421">三、关系数据库VS NOSQL</a></h2> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016422">1.</a>两种数据库对比</h3> 
<table border="1" cellspacing="0"><tbody>
<tr>
<td style="border-color:#000000;vertical-align:top;width:84.8pt"> <p style="margin-left:.0001pt;text-align:justify"></p> </td>
<td style="border-color:#000000;vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:center">关系型数据库</p> </td>
<td style="border-color:#000000;vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:center">非关系型数据库</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:84.8pt"> <p style="margin-left:.0001pt;text-align:center">数据规模</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">以MB或GB为单位</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">直接上GB、TB甚至PB（SQL你就是个弟弟）</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:84.8pt"> <p style="margin-left:.0001pt;text-align:center">数据类型</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">类型单一，数据结构化</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">种类繁多，数据经常是半结构化、非结构化</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:84.8pt"> <p style="margin-left:.0001pt;text-align:center">模式与数据</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">先有模式后有数据</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">模式在数据出现之后才能确定，甚至是不断变化的</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:84.8pt"> <p style="margin-left:.0001pt;text-align:center">如何看待数据</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">仅作为被处理的对象</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">数据要辅助解决诸多问题</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:84.8pt"> <p style="margin-left:.0001pt;text-align:center">处理工具</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">几种工具就可以应对</p> </td>
<td style="vertical-align:top;width:165pt"> <p style="margin-left:.0001pt;text-align:justify">很难有适应多数场景的工具</p> </td>
</tr>
</tbody></table>
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016423">2.</a>关系数据库的优势</h3> 
<p style="margin-left:.0001pt;text-align:justify">·通用性</p> 
<p style="margin-left:.0001pt;text-align:justify">·优秀的数据一致性</p> 
<p style="margin-left:.0001pt;text-align:justify">·最小冗余</p> 
<p style="margin-left:.0001pt;text-align:justify">·可以进行复杂查询（如连接）</p> 
<p style="margin-left:.0001pt;text-align:justify">·成熟的技术</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016424">3.</a>关系数据库的劣势</h3> 
<p style="margin-left:.0001pt;text-align:justify">·难以在分布式环境中扩展：为了保持强一致性，写操作需要集中在主服务器上，但是这就造成了巨大的负担，而且分布式系统下的连接操作更是极度头疼</p> 
<p style="margin-left:.0001pt;text-align:justify">·对一个大表，建立索引、更改属性花的时间很长，在这期间表会长时间上锁</p> 
<p style="margin-left:.0001pt;text-align:justify">·字段不固定时会关系数据库就很难应对，改变字段会耗时，预留字段又容易混淆且白白占用空间</p> 
<p style="margin-left:.0001pt;text-align:justify">·进行简单的查询仍需要解析SQL语句，虽然不代表会很慢，但是这额外的开销是不必要的</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016425">4.NoSQL</a>数据库特点</h3> 
<p style="margin-left:.0001pt;text-align:justify">·易于分散和扩展（因为本来就没有join操作……）</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc92016426">四、去IOE</a></h2> 
<p style="margin-left:.0001pt;text-align:justify">去掉IBM的小型机（X86）、Oracle数据库（开源数据库）、EMC存储设备（云端）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc92016427">五、数据模型发展</a></h2> 
<p style="margin-left:.0001pt;text-align:justify">·结构化模型</p> 
<p style="margin-left:.0001pt;text-align:justify">层次模型、网状模型、关系模型、E-R模型、面向对象模型</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">·半结构化模型</p> 
<p style="margin-left:.0001pt;text-align:justify">XML、JSON、图模型</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">·OLAP分析模型</p> 
<p style="margin-left:.0001pt;text-align:justify">ROLAP、MOLAP</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">·大数据模型</p> 
<p style="margin-left:.0001pt;text-align:justify">NOSQL、NewSQL</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="486" src="https://images2.imgbox.com/b8/4d/TMNyVWQE_o.png" width="865"></p> 
<p> </p> 
<h1 style="margin-left:0;text-align:justify">
<a name="_Toc92016428">第二章——NOSQL</a>理论基础</h1> 
<p style="margin-left:.0001pt;text-align:justify">在分布式系统下，为了保证数据的安全，我们需要进行“冗余存储”——即在各个独立的物理节点上存储多个副本，这就需要维持分布式系统上的数据一致性</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc92016429">一、ACID</a></h2> 
<p style="margin-left:.0001pt;text-align:justify">ACID代表了四个单词，它是关系型数据库的事务特性</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016430">1.</a>原子性Atomicity</h3> 
<p style="margin-left:.0001pt;text-align:justify">事务中的操作要么全都做，要么全都不做</p> 
<p style="margin-left:.0001pt;text-align:justify">·由恢复系统实现</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016431">2.</a>一致性Consistency</h3> 
<p style="margin-left:.0001pt;text-align:justify">事务完成前后要保持一致性，某些状态不应改变（典型就是转账前后的总金额）</p> 
<p style="margin-left:.0001pt;text-align:justify">·由并发控制系统实现</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016432">3.</a>隔离性Isolation</h3> 
<p style="margin-left:.0001pt;text-align:justify">各个并发的事务之间不能互相影响，各个事务之间应该就好像彼此不存在一样</p> 
<p style="margin-left:.0001pt;text-align:justify">·由并发控制系统实现</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016433">4.</a>持久性Durability</h3> 
<p style="margin-left:.0001pt;text-align:justify">一旦事务提交，对数据库的影响必须是永久的</p> 
<p style="margin-left:.0001pt;text-align:justify">·由恢复系统实现</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc92016434">二、CAP</a></h2> 
<p style="margin-left:.0001pt;text-align:justify">·CAP定理：在一个分布式系统中，强一致性Consistency、可用性Availability、分区容错性Partition Tolerance三者不可兼得。</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016435">1.</a>强一致性Consistency</h3> 
<p style="margin-left:.0001pt;text-align:justify">指分布式系统中，所有的数据备份在同一时刻有相同的值</p> 
<p style="margin-left:.0001pt;text-align:justify">一旦系统对某一个写操作返回成功，那么后续的所有读操作都应该读到这个值；返回失败则所有读操作都不会读到它</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016436">2.</a>可用性Availability</h3> 
<p style="margin-left:.0001pt;text-align:justify">每个请求都可以在一定时间内得到响应。这个响应可以是成功，也可以是失败，也不需要确保返回最新的信息</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016437">3.</a>分区容错性Partition Tolerance</h3> 
<p style="margin-left:.0001pt;text-align:justify">分布式系统常常划分在多个子网下，每个子网是一个区。这些区在网络故障等情况下会无法彼此交换信息。</p> 
<p style="margin-left:.0001pt;text-align:justify">分区容错性指在网络中断、消息丢失，部分分区因此挂掉的情况下，系统整体对外也能提供保持强一致性或可用性的服务</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016438">4.</a>不同原则的取舍结果</h3> 
<p>·CA——放弃分区容错性</p> 
<p style="margin-left:.0001pt;text-align:justify">这代表着需要将所有数据放到同一台机器上（以确保不需要检查分布式系统的其它副本），这是当下关系数据库的选择，扩展性不强</p> 
<p>·CP——放弃可用性</p> 
<p style="margin-left:.0001pt;text-align:justify">一旦遇到网络中断等情况，就让受影响的服务不对外服务了，等待数据恢复一致</p> 
<p>·AP——放弃一致性</p> 
<p style="margin-left:.0001pt;text-align:justify">在网络故障时，让各个受影响的分区继续使用本地数据来保证高可用性，但使得系统不一致。</p> 
<p style="margin-left:.0001pt;text-align:justify">当然，放弃C并不代表不再具有一致性，而是降格为“最终一致性”</p> 
<p>·实际情况</p> 
<p style="margin-left:.0001pt;text-align:justify">由于实际的分布式系统几乎无法避免网络硬件引起的网络连接问题，所以P必须被保证。通常要在C和A中放弃一个。</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">对于很多互联网服务，我们要保证用户能快速实时地进行操作，可以选择放弃C</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">对于金融（钱）的领域，C和A都非常需要保证，这时就不得不放弃P，故障时不对外服务</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">也就是说：</p> 
<p style="margin-left:.0001pt;text-align:justify">CA：传统关系数据库思维</p> 
<p style="margin-left:.0001pt;text-align:justify">CP：MongoDB、Redis、Hbase</p> 
<p style="margin-left:.0001pt;text-align:justify">AP：互联网应用</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc92016439">三、BASE</a></h2> 
<p style="margin-left:.0001pt;text-align:justify">BASE模型不同于ACID，它放弃强一致性，换来可用性</p> 
<p style="margin-left:.0001pt;text-align:justify">它是在CAP理论上，对C和A进行权衡的结果，因为我们可以看到可用性也是“基本可用”。它选择放弃强一致性，并根据业务特征尝试完成最终一致性。</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016440">1.</a>基本可用Basic Available</h3> 
<p style="margin-left:.0001pt;text-align:justify">允许损失一些可用性，但是系统仍需要可用。毕竟可用性是“一定时间”内返回，还是可以有操作空间的</p> 
<p style="margin-left:.0001pt;text-align:justify">比如：可以延长响应时间，或者在高峰期将用户从部分功能引导到等待页面。</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016441">2.</a>软状态/柔性事务Soft-state</h3> 
<p style="margin-left:.0001pt;text-align:justify">我们允许系统中不同节点的数据存在不一致的“中间状态”，即同步过程允许存在延时</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016442">3.</a>最终一致性Eventual Consitency</h3> 
<p style="margin-left:.0001pt;text-align:justify">所有数据副本在经过一定时间同步后可以达到一致，但不需要保证实时的强一致性</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016443">4.</a>与ACID的对比</h3> 
<table border="1" cellspacing="0"><tbody>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">ACID</p> </td>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">BASE</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:justify">强一致性</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:justify">弱一致性</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:justify">隔离性</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:justify">注重可用性</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:justify">采用悲观方法</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:justify">采用乐观的策略</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:justify">不易变通</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:justify">简单、快速、易变通</p> </td>
</tr>
</tbody></table>
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016444">5.eBay</a>模式</h3> 
<p style="margin-left:.0001pt;text-align:justify">BASE的一种实现，eBay模式会借助一个消息日志来异步地完成分布式任务</p> 
<p style="margin-left:.0001pt;text-align:justify">使用一个更新记录表来保证被操做过的更新不被重复执行</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">·现在某一个本地数据库完成本地需要做的操作并产生一条消息日志</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">·然后读取消息队列，通过读取更新记录来判断这个操作是否被执行过。如果没有执行过就执行，执行成功后更新更新记录表，同时从消息队列中删除这个消息。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc92016445">四、数据一致性实现技术</a></h2> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016446"><span style="background-color:#FFFF00">1.Paxos</span></a><span style="background-color:#FFFF00">协议</span>
</h3> 
<p style="margin-left:.0001pt;text-align:justify">一种不追求值的正确性、权威性、及时性，只追求一致性的分布式一致性算法</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">·值：这里的“值”可能指某个数值，也可能指某个命令等等含义</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p>·Paxos协议的角色</p> 
<ol><li style="text-align:justify">提议者Proposer：</li></ol>
<p style="margin-left:.0001pt;text-align:justify">处理客户端请求，并将请求发送到集群里，相当于发起一个提议，决定这个值是否被批准</p> 
<ol><li style="text-align:justify">批准者acceptor：</li></ol>
<p style="margin-left:.0001pt;text-align:justify">处理接收到的提议，回复自己的决定，会存储一些状态来决定是否批准提议中的值</p> 
<ol><li style="text-align:justify">学习者learner：</li></ol>
<p style="margin-left:.0001pt;text-align:justify">学习那些被批准的值，但不能学习任何未被批准的值</p> 
<p style="margin-left:.0001pt;text-align:justify">·一个节点可以担当多个角色</p> 
<p>·两个原则</p> 
<p style="margin-left:.0001pt;text-align:justify">安全原则——保证不做错事，某个实例的表决不会出现第二个值覆盖第一个值的情况，也不会出现学习未批准的值的情况</p> 
<p style="margin-left:.0001pt;text-align:justify">存活原则——只要有多数服务器存活并且彼此间可以通信最终都要做到：1.最终批准某个被提议的值；2.一个值被批准，那么其他节点都会学习这个值</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p>·批准提议的规则</p> 
<p style="margin-left:.0001pt;text-align:justify">R：当提议被大多数批准者批准，则该提议被批准</p> 
<p style="margin-left:.0001pt;text-align:justify">P1：一个批准者必须接受它所收到的第一个提议</p> 
<p style="margin-left:.0001pt;text-align:justify">**不同的接收者可能会收到不同的值，且各种值数目相当，没有多数派</p> 
<p style="margin-left:.0001pt;text-align:justify">*所以规定半数以上的接收者接受就可以认为提议被批准，每个接收者都可以接受多个提议，每个提议都有全局层面的一个不重复id</p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#FFFF00">P1a</span><span style="background-color:#FFFF00">：一个</span><span style="background-color:#FFFF00">Acceptor</span><span style="background-color:#FFFF00">只要尚未承诺过任何编号大于</span><span style="background-color:#FFFF00">n</span><span style="background-color:#FFFF00">的</span><span style="background-color:#FFFF00">Prepare</span><span style="background-color:#FFFF00">请求，就接受这个编号为</span><span style="background-color:#FFFF00">n</span><span style="background-color:#FFFF00">的提议。</span></p> 
<p style="margin-left:.0001pt;text-align:justify">P2：如果一项值为v的提议被批准，那么后续只批准值为v的提议 (即允许有多个提议被批准，但是这些提议必须拥有相同的值)</p> 
<p style="margin-left:.0001pt;text-align:justify">*P2a：如果一项值为v的提议被批准，那么acceptor后续只接受值为v的提议（在P2之上更进一步，在批注阶段之前的接受阶段截住）</p> 
<p style="margin-left:.0001pt;text-align:justify">**如果有提议者提出了于已批准的提议值不同的提议，那就会导致P1和P2a的冲突</p> 
<p style="margin-left:.0001pt;text-align:justify">*P2b：如果某个提议被批准，那么之后任何提议者都只能提出具有相同值的提议（解决P1与P2a的冲突）</p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#FFFF00">P2c</span><span style="background-color:#FFFF00">：对于任意的</span><span style="background-color:#FFFF00">n</span><span style="background-color:#FFFF00">和</span><span style="background-color:#FFFF00">v</span><span style="background-color:#FFFF00">，如果</span><span style="background-color:#FFFF00">[n, v]</span><span style="background-color:#FFFF00">被提出，那么肯定存在一个由半数以上</span><span style="background-color:#FFFF00">(majority)</span><span style="background-color:#FFFF00">的接收者组织的集合</span><span style="background-color:#FFFF00">S</span><span style="background-color:#FFFF00">，满足下面两个条件之一：</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#FFFF00">(a) S</span><span style="background-color:#FFFF00">中不存在任何接受过编号小于</span><span style="background-color:#FFFF00">n</span><span style="background-color:#FFFF00">的提议的接收者；</span></p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#FFFF00">(b) S</span><span style="background-color:#FFFF00">中所有接收者接受的编号小于</span><span style="background-color:#FFFF00">n</span><span style="background-color:#FFFF00">的提议中编号最大的提议的</span><span style="background-color:#FFFF00">value</span><span style="background-color:#FFFF00">为</span><span style="background-color:#FFFF00">v</span><span style="background-color:#FFFF00">。</span></p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p>·Paxos协议算法主体</p> 
<p style="margin-left:.0001pt;text-align:justify">引入“承诺”：承诺了一个编号为n的提议，代表后续不会再接收编号小于等于n的提议</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">·阶段1</p> 
<p style="margin-left:.0001pt;text-align:justify">Proposer选择一个编号n，向半数以上的acceptor发送编号为n的prepare请求</p> 
<p style="margin-left:.0001pt;text-align:justify">Acceptor接受到的prepare(n)，如果n大于已经承诺过的所有prepare请求的编号，就将已经接受过的编号最大的提议作为承诺返回给proposer，同时这个acceptor也会承诺不再接受小于n的提议（或prepare）</p> 
<p style="margin-left:.0001pt;text-align:justify">·阶段2</p> 
<p style="margin-left:.0001pt;text-align:justify">如果proposer收到了半数以上的acceptor对n返回的承诺，就会发送一个[n,v]的接受请求给半数以上acceptor（v为返回的所有承诺中，编号最大的提案的v；如果全为null则自选）</p> 
<p style="margin-left:.0001pt;text-align:justify">如果acceptor收到了一个编号为n的accept请求，只要它没有对编号大于n的prepare请求做出过承诺，就接受它，并返回自己接收了请求的信息</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">在这之后，如果proposer能接收到超过半数的接受请求的信息，就结束了，将信息发给learner</p> 
<p style="margin-left:.0001pt;text-align:justify">如果未超过半数，就需要重新发送n值不同的prepare了</p> 
<p>·持久存储</p> 
<p style="margin-left:.0001pt;text-align:justify">为保证宕机恢复后，节点仍能正常参与Paxos，必须存储：</p> 
<p style="margin-left:.0001pt;text-align:justify">·proposer存储发送过的最大的prepare编号，最大的accept编号</p> 
<p style="margin-left:.0001pt;text-align:justify">·acceptor存储承诺过的最大编号，已接受的编号最大的提议的编号和value</p> 
<p style="margin-left:.0001pt;text-align:justify">·learner存储自己学习过的提议和编号</p> 
<p>·Paxos活锁</p> 
<p style="margin-left:.0001pt;text-align:justify">两个proposer A和B，它们交替进行：</p> 
<p style="margin-left:.0001pt;text-align:justify">A发动accept，由于有节点在之前接受了来自B的编号更大的prepare而失败，紧接着A发动了编号更大的prepare</p> 
<p style="margin-left:.0001pt;text-align:justify">B又赶在A发动下一次accept之前，先发动了accept，这也由于有些节点接受了更大的prepare失败（来自A），然后紧接着发动了更大的prepare</p> 
<p style="margin-left:.0001pt;text-align:justify">就此死循环</p> 
<p style="margin-left:.0001pt;text-align:justify">·解法1：要求proposer在一段随机时间后才能再次发动accept或随机改变编号增长幅度</p> 
<p style="margin-left:.0001pt;text-align:justify">·解法2：选取主proposer，只有它们才能发送proposer</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="477" src="https://images2.imgbox.com/d1/2f/XIFXNRja_o.png" width="865"></p> 
<p> </p> 
<h2 style="margin-left:0;text-align:justify">
<a name="_Toc92016447">五、NOSQL</a>数据库水平扩展</h2> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016448">1.</a>水平扩展基础</h3> 
<p style="margin-left:.0001pt;text-align:justify">·随数据量增加，垂直扩展（指提升服务器性能）会变得既难又贵，所以我们要水平扩展——将数据库运行在更多机器的集群上</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">这么做可以处理更大的数据请求，故障时获得更高的可用性（崩了一部分还能用嘛），但是系统会更复杂</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016449">2.</a>分片与复制</h3> 
<p>·分片</p> 
<p style="margin-left:.0001pt;text-align:justify">将数据划分，不同的节点存不同的数</p> 
<p style="margin-left:.0001pt;text-align:justify">这是基于这样的考虑：数据库访问量虽大，但不同的应用程序其实很可能访问不同的数据。</p> 
<p style="margin-left:.0001pt;text-align:justify">我们分片时应当让经常一起访问的数据分在一起</p> 
<p>·分片和分区</p> 
<p style="margin-left:.0001pt;text-align:justify">关系数据库提供的分区是对单个服务器上的单个数据库进行操作，与分片有本质不同</p> 
<table align="left" border="1" cellspacing="0" style="margin-left:6.75pt;width:389.35pt"><tbody>
<tr>
<td style="background-color:#e7faf1;border-color:#003366;width:65.8pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>　</strong></p> </td>
<td style="background-color:#e7faf1;border-color:#003366;width:167.6pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>分片(Sharding)</strong></p> </td>
<td style="background-color:#e7faf1;border-color:#003366;width:155.95pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>分区(Partition)</strong></p> </td>
</tr>
<tr>
<td style="background-color:#e7faf1;border-color:#003366;width:65.8pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>存储依赖</strong></p> </td>
<td style="background-color:#e7faf1;width:167.6pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>可以跨越数据库</strong><br><strong>可以跨越物理机器</strong></p> </td>
<td style="background-color:#e7faf1;width:155.95pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>可以跨越表空间</strong><br><strong>不可以跨越数据库</strong></p> </td>
</tr>
<tr>
<td style="background-color:#e7faf1;border-color:#003366;width:65.8pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>数据划分</strong></p> </td>
<td style="background-color:#e7faf1;width:167.6pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>基于时间、范围、面向服务等</strong></p> </td>
<td style="background-color:#e7faf1;width:155.95pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>基于范围、Hash</strong><strong>、列表等</strong></p> </td>
</tr>
<tr>
<td style="background-color:#e7faf1;border-color:#003366;width:65.8pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>存储方式</strong></p> </td>
<td style="background-color:#e7faf1;width:167.6pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>分布式</strong></p> </td>
<td style="background-color:#e7faf1;width:155.95pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>集中式</strong></p> </td>
</tr>
<tr>
<td style="background-color:#e7faf1;border-color:#003366;width:65.8pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>扩展性</strong></p> </td>
<td style="background-color:#e7faf1;width:167.6pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>Scale Out</strong></p> </td>
<td style="background-color:#e7faf1;width:155.95pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>Scale Up</strong></p> </td>
</tr>
<tr>
<td style="background-color:#e7faf1;border-color:#003366;width:65.8pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>可用性</strong></p> </td>
<td style="background-color:#e7faf1;width:167.6pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>无单点问题</strong></p> </td>
<td style="background-color:#e7faf1;width:155.95pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>存在单点问题</strong></p> </td>
</tr>
<tr>
<td style="background-color:#e7faf1;border-color:#003366;width:65.8pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>价格</strong></p> </td>
<td style="background-color:#e7faf1;width:167.6pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>低廉</strong></p> </td>
<td style="background-color:#e7faf1;width:155.95pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>昂贵</strong></p> </td>
</tr>
<tr>
<td style="background-color:#e7faf1;border-color:#003366;width:65.8pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>应用场景</strong></p> </td>
<td style="background-color:#e7faf1;width:167.6pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>互联网应用，Web2.0</strong><strong>等</strong></p> </td>
<td style="background-color:#e7faf1;width:155.95pt"> <p style="margin-left:.0001pt;text-align:justify"><strong>管理系统</strong></p> </td>
</tr>
</tbody></table>
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>·复制</p> 
<p style="margin-left:.0001pt;text-align:justify">一份数据复制到多个节点上</p> 
<p style="margin-left:.0001pt;text-align:justify">·主从复制：一个主节点负责处理更新，从节点都只负责读操作。这可能会遇到一致性问题，且主节点宕机需要重选一个主节点。</p> 
<p style="margin-left:.0001pt;text-align:justify">·对等复制：不分主从，谁都可以负责更新或读。这种情况的一致性问题更大</p> 
<p>·分片与复制同用</p> 
<p style="margin-left:.0001pt;text-align:justify">进行分片，每个分片会对应一个主节点，并且还要按照复制系数复制出多个片。节点故障的话还需要将丢失的片转移到其他节点上</p> 
<h3 style="margin-left:0;text-align:justify">
<a name="_Toc92016450"><span style="background-color:#FFFF00">3.</span></a><span style="background-color:#FFFF00">分片的数据划分方式——一致性哈希</span>
</h3> 
<p style="margin-left:.0001pt;text-align:justify">一致性哈希的本质是一个负载均衡算法</p> 
<p style="margin-left:.0001pt;text-align:justify">普通hash在添加节点时的更改会很大，一致性哈希改进了这一点</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p>·算法核心需求</p> 
<p style="margin-left:.0001pt;text-align:justify"><span style="background-color:#FFFF00">节点和数据都进行哈希，通过比较节点和数据的哈希来分配数据</span></p> 
<p style="margin-left:.0001pt;text-align:justify">同时，我们要保证加入或移除存储节点时移动的数据应当最少，这点要求有一个衡量指标——单调性</p> 
<p style="margin-left:.0001pt;text-align:justify">单调性：当有新的节点加入时，必须要让有数据能映射到新节点，但又不会让数据被重新映射到其他旧的节点上</p> 
<p>·算法思路</p> 
<p style="margin-left:.0001pt;text-align:justify">·step1：</p> 
<p style="margin-left:.0001pt;text-align:justify">创造一个环形hash空间，通常是32位的数值空间（也就是0~2^32-1）</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="352" src="https://images2.imgbox.com/9b/2a/eRc76qPH_o.png" width="285"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify">·step2：</p> 
<p style="margin-left:.0001pt;text-align:justify">将全部数据使用hash函数映射到环上</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="352" src="https://images2.imgbox.com/37/e5/cgry6vft_o.png" width="588"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify">·step3：</p> 
<p style="margin-left:.0001pt;text-align:justify">把所有存储映射到环上，我们可以选择使用IP地址输入hash函数</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="390" src="https://images2.imgbox.com/1a/e2/u1SaFyJ9_o.png" width="609"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify">·step4：</p> 
<p style="margin-left:.0001pt;text-align:justify">将数据顺时针旋转（也就是不断循环增大啦），直到遇到一个存储器为止</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="320" src="https://images2.imgbox.com/7f/06/tKsvz1nz_o.png" width="535"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify">·step extra 新增：</p> 
<p style="margin-left:.0001pt;text-align:justify">添加一个存储器时，我们对它hash。</p> 
<p style="margin-left:.0001pt;text-align:justify">这个时候，我们需要重新映射的数据是：从新的存储器，到逆时针寻找到的第一个存储器之间。只有它们需要重新映射到新服务器上。</p> 
<p style="margin-left:.0001pt;text-align:justify">·step extra 移除：</p> 
<p style="margin-left:.0001pt;text-align:justify">移除一个存储器时，只有它本来存储的数据需要重新映射（也就是从这个存储器，到逆时针寻找到的第一个存储器之间）</p> 
<p>·虚拟节点</p> 
<p style="margin-left:.0001pt;text-align:justify">哈希算法本身并不能保证绝对的平衡，尤其是存储少时。我们可以引入虚拟节点机制来尝试解决这个问题</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">我们可以让一个存储对应多个哈希值，这样一个存储设备在哈希环上就有了两个点，滑到这两个点的数据都归它存储。更多的哈希值就代表更有偏向于存储平衡</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">存储的虚拟哈希可以通过在IP中添加后缀来产生</p> 
<h1 style="margin-left:0;text-align:justify">
<a name="_Toc92016451">第三章——</a>文档数据库</h1> 
<p style="margin-left:.0001pt;text-align:justify">以一个类似于对象的“文档”作为存储单元</p> 
<p style="margin-left:.0001pt;text-align:justify">其典型MongoDB是最接近关系型数据库的NoSql数据库</p> 
<h2 style="margin-left:0;text-align:justify">一、MongoDB数据组织模型</h2> 
<h3 style="margin-left:0;text-align:justify">1.逻辑结构</h3> 
<p style="margin-left:.0001pt;text-align:justify">由数据库、集合、文档逐层构成</p> 
<table border="1" cellspacing="0"><tbody>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">关系型数据库</p> </td>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">文档数据库MongoDB</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">数据库database</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">数据库database</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">表table</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">集合collection</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">行/元组 row/tuple</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">文档document</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">列/属性 column/attribute</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">域field</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">索引index</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">索引index</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">连接join</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">不支持连接</p> </td>
</tr>
<tr>
<td style="border-color:#000000;vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">主码primary key</p> </td>
<td style="vertical-align:top;width:207.4pt"> <p style="margin-left:.0001pt;text-align:center">主码 _id:object_id</p> </td>
</tr>
</tbody></table>
<h3 style="margin-left:0;text-align:justify">2.MongoDB的数据类型</h3> 
<p style="margin-left:.0001pt;text-align:justify">除了常有的数据类型，还有传统关系数据库中没有的数据类型</p> 
<p style="margin-left:.0001pt;text-align:justify">·Arrays：列表</p> 
<p style="margin-left:.0001pt;text-align:justify">·Object：对象，即文档内嵌</p> 
<p style="margin-left:.0001pt;text-align:justify">·Object_ID：专门用于创建文档ID的对象ID类型</p> 
<p style="margin-left:.0001pt;text-align:justify">·Binary Data：二进制数据</p> 
<p style="margin-left:.0001pt;text-align:justify">·Code：代码类型，用于存储JavaScript代码</p> 
<h3 style="margin-left:0;text-align:justify">3.MongoDB的存储</h3> 
<p>·预分配</p> 
<p style="margin-left:.0001pt;text-align:justify">MongoDB始终保持额外的空间和空余的数据文件，预分配的文件用0填充。这个机制可以有效缓解数据暴涨引起的问题</p> 
<p>·加倍的数据文件</p> 
<p style="margin-left:.0001pt;text-align:justify">数据文件每新分配一次数据文件，下一个数据文件就会是上一个大小的两倍，但不超过20G。这样可以保证小的数据库不会占用过多空间，大的数据库也可以通过加倍的机制获得足够的预留空间</p> 
<p>·命名空间</p> 
<p style="margin-left:.0001pt;text-align:justify">每个集合和索引都有命名空间，命名空间的元数据存在.ns文件中</p> 
<h3 style="margin-left:0;text-align:justify">4.MongoDB的优劣</h3> 
<p>·优势</p> 
<p style="margin-left:.0001pt;text-align:justify">·模式自由，增删属性的代价更低，不需要关系模式与应用程序间的一致问题</p> 
<p style="margin-left:.0001pt;text-align:justify">·易扩展：面向文档的数据模型易扩展，开发者可以专注业务逻辑</p> 
<p style="margin-left:.0001pt;text-align:justify">·高性能：支持索引，内存管理工作直接交给OS，动态查询优化器会记住最高效的查询方式</p> 
<p style="margin-left:.0001pt;text-align:justify">·管理便捷：主服务器宕机系统自动选择备份服务器升格为主服务器，且启动服务器后不需要额外的管理</p> 
<p>·不足</p> 
<p style="margin-left:.0001pt;text-align:justify">·不支持join</p> 
<p style="margin-left:.0001pt;text-align:justify">·对事务支持差</p> 
<p style="margin-left:.0001pt;text-align:justify">·数据更新并非实时写入磁盘，可能丢失数据</p> 
<p style="margin-left:.0001pt;text-align:justify">·预留空间会随存储数据增多而不断增大，也是负担</p> 
<h3 style="margin-left:0;text-align:justify">5.适用场景</h3> 
<p style="margin-left:.0001pt;text-align:justify">·大宗低价值数据</p> 
<p style="margin-left:.0001pt;text-align:justify">·来自网站的数据（网站数据往往非结构性）</p> 
<p style="margin-left:.0001pt;text-align:justify">·缓存（因为性能好）</p> 
<p style="margin-left:.0001pt;text-align:justify">·高伸缩度的，对分布式存储需求大的场景（MongoDB内置对MapReduce的支持）</p> 
<p style="margin-left:.0001pt;text-align:justify">·JSON或对象类数据的存储</p> 
<h2 style="margin-left:0;text-align:justify">二、MongoDB模式设计</h2> 
<p style="margin-left:.0001pt;text-align:justify">MongoDB不是没有模式设计的</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">在关系数据库中需要拆表的操作，在MongoDB中可以通过不同程度的内嵌/信用文档来实现。</p> 
<p style="margin-left:.0001pt;text-align:justify">内嵌文档是直接将全部内容写成一个文档，引用则是将object_id存入以代替存储大量实际内容，数据存入另一个集合</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="454" src="https://images2.imgbox.com/d1/0c/0TRNhH6b_o.png" width="865"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify">越偏向完全内嵌，查询性能就越好（只需要在一个集合内查询），但更新性能就越差（需要遍历这个大集合而不是一个只存储了需要更新的信息类别的小集合）</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">越偏向完全引用，更新性能就越好（只需要遍历一个小的集合），但查询性能就越差（需要查询多个集合）</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">也可以结合两者，在引用的基础上将经常需要查询的字段内嵌</p> 
<h1 style="margin-left:0;text-align:justify">第四章——Key-Value数据库</h1> 
<p style="margin-left:.0001pt;text-align:justify">Key-Value数据库以键值对为存储的基本单位。对于文档数据库来说，一个文档才是一条有意义的数据，单个键值对没有意义。但是对于Key-Value数据库来说，一个键值对就是有意义的。</p> 
<p style="margin-left:.0001pt;text-align:justify">Redis选择将数据存储内存中，同时也支持持久化，定期将数据转到磁盘上</p> 
<h2 style="margin-left:0;text-align:justify">一、Redis数据组织模型</h2> 
<h3 style="margin-left:0;text-align:justify">1.Redis数据模型</h3> 
<p style="margin-left:.0001pt;text-align:justify">Key使用非二进制安全的字符串</p> 
<p style="margin-left:.0001pt;text-align:justify">Values十分单一，以二进制安全的字符串string作为主力类型，并且支持LIST，SETS，HASH，ZSET等集合类型</p> 
<p style="margin-left:.0001pt;text-align:justify">这里的字符串并不是纯的字符串，它不仅是Redis设计的二进制安全字符串，同时也可以存储数字</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="494" src="https://images2.imgbox.com/8e/bd/xpGjBzOZ_o.png" width="791"></p> 
<p> </p> 
<h3 style="margin-left:0;text-align:justify">2.简单动态字符串SDS</h3> 
<p style="margin-left:.0001pt;text-align:justify">普通的C字符串以空字符串为结尾，而Redis的SDS有一个SDSHDR表头，存放了空闲空间free，已用空间len和缓冲区buf属性。借助这些属性，SDS不需要用任何特殊字符表示字符串的结尾</p> 
<p>·优点</p> 
<p style="margin-left:.0001pt;text-align:justify">·获取字符串长度更快（直接读取属性而不是像C读取整个字符串）</p> 
<p style="margin-left:.0001pt;text-align:justify">·杜绝缓冲区溢出（记录free空间，在拼接字符串前可以检查）</p> 
<p style="margin-left:.0001pt;text-align:justify">·减少内存分配（有预分配空间的机制）</p> 
<p style="margin-left:.0001pt;text-align:justify">·二进制安全（不依赖文件特殊字符进行分割，字符串不需要顾忌的问题）</p> 
<h3 style="margin-left:0;text-align:justify">3.Key与Value</h3> 
<p>·key</p> 
<p style="margin-left:.0001pt;text-align:justify">是C的原生字符串，不能使用换行、空格等符号</p> 
<p style="margin-left:.0001pt;text-align:justify">可以预先约定格式，比如冒号分割之类的</p> 
<p style="margin-left:.0001pt;text-align:justify">Key长度应适中，太长影响性能，太短不能达意</p> 
<h2 style="margin-left:0;text-align:justify">二、Redis持久化</h2> 
<h3 style="margin-left:0;text-align:justify">1.快照</h3> 
<p style="margin-left:.0001pt;text-align:justify">默认开启，隔一段时间就将内存中的所有数据保存一份到硬盘里</p> 
<p style="margin-left:.0001pt;text-align:justify">（可以配置为若m秒内有n个key被修改就存一次）</p> 
<p style="margin-left:.0001pt;text-align:justify">缺点是仍有可能丢失数据，且数据量大时不太合适</p> 
<h3 style="margin-left:0;text-align:justify">2.aof（append-only file）</h3> 
<p style="margin-left:.0001pt;text-align:justify">Redis将每一个写操作都通过write函数追加到文件里，Redis重启时通过这个文件重构数据库</p> 
<p style="margin-left:.0001pt;text-align:justify">这样不容易丢失数据，但aof文件可能会很大，且重构是会因为文件过大而很慢</p> 
<h3 style="margin-left:0;text-align:justify">3.主从复制</h3> 
<p style="margin-left:.0001pt;text-align:justify">Redis采用主从复制，主节点负责写操作，从节点负责读操作，主节点定期为所有节点更新。主从复制允许从节点间彼此连接。</p> 
<p style="margin-left:.0001pt;text-align:justify">Redis主从初连接时进行全量复制，之后尽量进行增量复制。从节点可以随时发起全量复制</p> 
<h2 style="margin-left:0;text-align:justify">三、事务</h2> 
<p>·事务</p> 
<p style="margin-left:.0001pt;text-align:justify">只保证一个client的一个事务的命令可以连续执行，其他client的命令无法插入</p> 
<p style="margin-left:.0001pt;text-align:justify">事务中的命令出现语法错误，整个事务就会被拒绝；</p> 
<p style="margin-left:.0001pt;text-align:justify">事务运行时出现了只有运行中才能被发现的错误，其余命令还会正常执行。</p> 
<p>·乐观锁</p> 
<p style="margin-left:.0001pt;text-align:justify">依赖版本号实现。读数据同时读取版本号，操作完成写回数据时再比较一次版本号，要是没变就成功，变了就失败，不再写入。</p> 
<h2 style="margin-left:0;text-align:justify">四、Redis使用场景</h2> 
<p style="margin-left:.0001pt;text-align:justify">·Redis速度顶尖，适合高并发、海量、高扩展需求这样对性能需求高的数据存储</p> 
<p style="margin-left:.0001pt;text-align:justify">·但是Redis对事务的支持很薄弱，也没有复杂的结构支持。对事务要求高的，对结构和复杂查询有要求的数据就不适合</p> 
<h1 style="margin-left:0;text-align:justify">第五章——图数据库</h1> 
<p style="margin-left:.0001pt;text-align:justify">关系数据库需要连接才能处理联系，但是关系数据库的多重连接性能极差。更不要说其他的NoSQL数据库也不天生存在联系的概念了</p> 
<p style="margin-left:.0001pt;text-align:justify">图数据库的理念天生善于处理联系，他的数据模型本身就是基于数据和数据联系的</p> 
<p style="margin-left:.0001pt;text-align:justify">Neo4j是最流行的图数据库</p> 
<h2 style="margin-left:0;text-align:justify">一、Neo4j的数据组织模型</h2> 
<h3 style="margin-left:0;text-align:justify">1.基本存储概念</h3> 
<p style="margin-left:.0001pt;text-align:justify">Neo4j的基本存储概念为节点和边。节点和边都有属性的概念。</p> 
<p style="margin-left:.0001pt;text-align:justify">节点表示实体，边代表实体间的联系。不同节点被边联系起来，形成一个复杂的图。</p> 
<p style="margin-left:.0001pt;text-align:justify">由于数据的构成是图，所以顺理成章地支持了BFS和DFS。</p> 
<h3 style="margin-left:0;text-align:justify">2.存储内容</h3> 
<p style="margin-left:.0001pt;text-align:justify">·属性：Neo4j以键值对象征属性</p> 
<p style="margin-left:.0001pt;text-align:justify">·标签：（不是一个键值对）可以用于表征节点性质的一个内容，同时也便于查询</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify">一个节点可以有若干个标签和若干属性</p> 
<p style="margin-left:.0001pt;text-align:justify">一个联系有方向、名字、开始节点、结束节点、名字、属性</p> 
<h3 style="margin-left:0;text-align:justify">3.事务</h3> 
<p style="margin-left:.0001pt;text-align:justify">Neo4j的事务是ACID级别的，这也是Neo4j的重要竞争力</p> 
<p style="margin-left:.0001pt;text-align:justify">有锁有日志，所有事务被表示为内存对象</p> 
<h3 style="margin-left:0;text-align:justify">4.可用性</h3> 
<p style="margin-left:.0001pt;text-align:justify">使用主从集群，写操作会频繁地从主节点复制到从节点，任何时刻主节点和一些从节点都会有最新的副本</p> 
<h3 style="margin-left:0;text-align:justify">5.可扩展性</h3> 
<p style="margin-left:.0001pt;text-align:justify">Neo4j和关系型数据库一样有延迟问题，索引帮助找到前几个对象，后续要遍历查找</p> 
<h2 style="margin-left:0;text-align:justify">二、Neo4j的模型设计</h2> 
<h3 style="margin-left:0;text-align:justify">1.易理解</h3> 
<p style="margin-left:.0001pt;text-align:justify">一个好的Neo4j数据库设计应该易于理解，从某个起始点开始阅读应当能组成一个完整的语义</p> 
<h3 style="margin-left:0;text-align:justify">2.可查询</h3> 
<p style="margin-left:.0001pt;text-align:justify">应当满足用户的查询需求</p> 
<h2 style="margin-left:0;text-align:justify">三、Neo4j应用场景</h2> 
<p style="margin-left:.0001pt;text-align:justify">图数据库是一种对联系特化的数据库，在知识图谱领域有很大作用</p> 
<h2 style="margin-left:0;text-align:justify">第六章——列族数据库</h2> 
<p style="margin-left:.0001pt;text-align:justify">列式存储（column-based storage）是相对于传统关系数据库的行式存储(Row-based storage)说的</p> 
<p style="margin-left:.0001pt;text-align:justify">行式存储是一整行的内存存在一起，而列式存储是将整列的数据存在一起</p> 
<p style="margin-left:.0001pt;text-align:justify">行存储擅长更新数据，但在读取数据时经常会读到不必要数据；列存储擅长读取某一个属性的数据，但不擅长更新元组</p> 
<h2 style="margin-left:0;text-align:justify">一、列族数据库的数据压缩</h2> 
<p style="margin-left:.0001pt;text-align:justify">行存储不像列族存储这样这么容易出现重复值以供压缩</p> 
<h3 style="margin-left:0;text-align:justify">1.行程长度编码算法</h3> 
<p style="margin-left:.0001pt;text-align:justify">将有序序列中的若干个连续且相同的值压缩为一个三元组：</p> 
<p style="margin-left:.0001pt;text-align:justify">（值，首次出现位置，出现次数）</p> 
<h3 style="margin-left:0;text-align:justify">2.位向量编码</h3> 
<p style="margin-left:.0001pt;text-align:justify">将一个列中的所有值相等的数据转化为一个二元组：</p> 
<p style="margin-left:.0001pt;text-align:justify">（值，指明出现位置的位向量）</p> 
<p style="margin-left:.0001pt;text-align:justify">比如（1,01001）代表值1在第二行和第五行出现了</p> 
<h3 style="margin-left:0;text-align:justify">3.字典编码</h3> 
<p style="margin-left:.0001pt;text-align:justify">维护一个键值与字符串的字典，从而将字符串转化为一个短编码</p> 
<h2 style="margin-left:0;text-align:justify">二、HBase存储模型</h2> 
<h3 style="margin-left:0;text-align:justify">1.HBase的基础特征</h3> 
<p>·HBase的更新</p> 
<p style="margin-left:.0001pt;text-align:justify">实质是通过插入一个列对应的新版本来达到更新的功能，旧版并不会被删除</p> 
<p>·HBase的列族</p> 
<p style="margin-left:.0001pt;text-align:justify">每个列族由几个文件保存，不同列族必定由不同文件保存</p> 
<h3 style="margin-left:0;text-align:justify">2.存储模型</h3> 
<p style="margin-left:.0001pt;text-align:justify">让我们来看看这个图，并依次解释各个名词</p> 
<p style="margin-left:.0001pt;text-align:justify">主键Row key：HBase表的主键，表中的记录按照行键排序，行键用来检索记录的主键</p> 
<p style="margin-left:.0001pt;text-align:justify">时间戳TimeStamp：代表这条的更新时间，是一种版本号概念</p> 
<p style="margin-left:.0001pt;text-align:justify">列族Column family：一个列族可以由多个列构成，且无需事先定义类型和数量。创建表时是必须要指明列族的</p> 
<p style="margin-left:.0001pt;text-align:justify">概念层就可以看出：一个列族中存储了许多列-值的对应</p> 
<p style="margin-left:.0001pt;text-align:justify"></p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="460" src="https://images2.imgbox.com/ba/58/cyEfIUVT_o.png" width="752"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify">虽然看上去有许多的空值，但是不知道还记不记得之前说过：不同的列族是存在不同文件中的，物理层的存储长这个样子</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="439" src="https://images2.imgbox.com/a6/52/g2103ncf_o.png" width="697"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify">只能通过row key访问表，默认返回最新的记录</p> 
<h3 style="margin-left:0;text-align:justify">3.物理实现</h3> 
<p>·HRegion</p> 
<p style="margin-left:.0001pt;text-align:justify">将表按row key取值分割，存储为多个HRegion</p> 
<p style="margin-left:.0001pt;text-align:justify"><img alt="" height="470" src="https://images2.imgbox.com/ad/a6/DrULDCga_o.png" width="395"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify">HRegion会根据大小分割，每个表初始只有一个HRegion，增大到阈值（默认为256MB）后就分割</p> 
<p style="margin-left:.0001pt;text-align:justify">HRegion是分布式系统中存储的最小单元，不同节点的存储单位都是HRegion</p> 
<p>·HStore</p> 
<p style="margin-left:.0001pt;text-align:justify">HRegion不是底层存储的最小单位，HRegion由多个HStore组成，每个HStore存一个列族（也就是说有几个列族存几个HStore）</p> 
<p style="margin-left:.0001pt;text-align:justify">每个HStore又由一个HMemStore和几个HStoreFile构成，后者以HFile的形式存储在HDFS上</p> 
<p style="margin-left:.0001pt;text-align:justify">这个存储的机制是：数据被存到HMemStore上，当它大小达到某个阈值就会被转化为HStoreFile。HStoreFile数量达到一个阈值就会合并，单个HStoreFile大小达到阈值就会出发HRegion的分裂。</p> 
<h3 style="margin-left:0;text-align:justify">4.HBase事务模型</h3> 
<p style="margin-left:.0001pt;text-align:justify">提供单行数据操作的原子性保证</p> 
<p style="margin-left:.0001pt;text-align:justify">HBase数据会首先写入WAL(Write-Ahead-Log，预写日志)，再写入Memstore。写入Memstore异常很容易可以回滚，因此保证写入/更新原子性只需要保证写入WAL的原子性即可</p> 
<h2 style="margin-left:0;text-align:justify">三、应用场景</h2> 
<p style="margin-left:.0001pt;text-align:justify">数据量极大（超千万）且并发需求大的场景，并且只需要简单的业务查询</p> 
<p style="margin-left:.0001pt;text-align:justify">HBase不擅长复杂的业务查询和跨表事务</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>