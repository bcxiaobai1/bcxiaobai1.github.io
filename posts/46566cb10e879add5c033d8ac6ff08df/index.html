<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>哈工大CSAPP程序人生大作业 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈工大CSAPP程序人生大作业</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"><strong>计算机系统</strong></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"><strong>大作业</strong></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">题     目 <u> </u><u>程序人生</u><u>-Hello’s P2P  </u><u> </u></p> 
<p style="margin-left:0;text-align:justify">专       业 <u>  </u><u>计算机科学与技术</u><u>       </u></p> 
<p style="margin-left:0;text-align:justify">学　　   号 <u>  2021110991             </u></p> 
<p style="margin-left:0;text-align:justify">班　　   级 <u>     2103101             </u></p> 
<p style="margin-left:0;text-align:justify">学       生 <u>       </u><u>安心</u><u>          </u></p> 
<p style="margin-left:0;text-align:justify">指 导 教 师 <u>       </u><u>刘宏伟</u><u>          </u></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"><strong>计算机科学与技术学院</strong></p> 
<p style="margin-left:0;text-align:center"><strong>2022</strong><strong>年5月</strong></p> 
<p style="margin-left:0;text-align:center"><a name="_Toc225579639"></a><a name="_Toc250450163"><strong>摘  要</strong></a></p> 
<p style="margin-left:0;text-align:justify">    本文着重从hello程序的预处理、编译、汇编、链接、进程管理等过程入手，深入探究了hello程序从开始执行加载到内存，再到经过一系列操作与过程完成使命任务，最后结束生命周期的整个历程，展示了较为完整的计算机系统知识。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"><strong>关键词：</strong>hello程序   预处理     汇编   链接   进程管理   生命周期  </p> 
<p style="margin-left:0;text-align:justify">       计算机系统      程序编译过程</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"><strong>目  录</strong></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238396">第1章 概述............................................................................................................. - 4 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238397">1.1 Hello简介...................................................................................................... - 4 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238398">1.2 环境与工具..................................................................................................... - 4 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238399">1.3 中间结果......................................................................................................... - 4 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238400">1.4 本章小结......................................................................................................... - 4 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238401">第2章 预处理......................................................................................................... - 5 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238402">2.1 预处理的概念与作用..................................................................................... - 5 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238403">2.2在Ubuntu下预处理的命令.......................................................................... - 5 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238404">2.3 Hello的预处理结果解析.............................................................................. - 5 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238405">2.4 本章小结......................................................................................................... - 5 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238406">第3章 编译............................................................................................................. - 6 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238407">3.1 编译的概念与作用......................................................................................... - 6 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238408">3.2 在Ubuntu下编译的命令............................................................................. - 6 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238409">3.3 Hello的编译结果解析.................................................................................. - 6 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238410">3.4 本章小结......................................................................................................... - 6 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238411">第4章 汇编............................................................................................................. - 7 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238412">4.1 汇编的概念与作用......................................................................................... - 7 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238413">4.2 在Ubuntu下汇编的命令............................................................................. - 7 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238414">4.3 可重定位目标elf格式................................................................................. - 7 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238415">4.4 Hello.o的结果解析...................................................................................... - 7 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238416">4.5 本章小结......................................................................................................... - 7 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238417">第5章 链接............................................................................................................. - 8 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238418">5.1 链接的概念与作用......................................................................................... - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238419">5.2 在Ubuntu下链接的命令............................................................................. - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238420">5.3 可执行目标文件hello的格式.................................................................... - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238421">5.4 hello的虚拟地址空间.................................................................................. - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238422">5.5 链接的重定位过程分析................................................................................. - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238423">5.6 hello的执行流程.......................................................................................... - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238424">5.7 Hello的动态链接分析.................................................................................. - 8 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238425">5.8 本章小结......................................................................................................... - 9 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238426">第6章 hello进程管理................................................................................... - 10 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238427">6.1 进程的概念与作用....................................................................................... - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238428">6.2 简述壳Shell-bash的作用与处理流程..................................................... - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238429">6.3 Hello的fork进程创建过程..................................................................... - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238430">6.4 Hello的execve过程................................................................................. - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238431">6.5 Hello的进程执行........................................................................................ - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238432">6.6 hello的异常与信号处理............................................................................ - 10 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238433">6.7本章小结....................................................................................................... - 10 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238434">第7章 hello的存储管理................................................................................ - 11 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238435">7.1 hello的存储器地址空间............................................................................ - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238436">7.2 Intel逻辑地址到线性地址的变换-段式管理............................................ - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238437">7.3 Hello的线性地址到物理地址的变换-页式管理....................................... - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238438">7.4 TLB与四级页表支持下的VA到PA的变换............................................. - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238439">7.5 三级Cache支持下的物理内存访问.......................................................... - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238440">7.6 hello进程fork时的内存映射.................................................................. - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238441">7.7 hello进程execve时的内存映射.............................................................. - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238442">7.8 缺页故障与缺页中断处理........................................................................... - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238443">7.9动态存储分配管理....................................................................................... - 11 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238444">7.10本章小结..................................................................................................... - 12 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238445">第8章 hello的IO管理................................................................................. - 13 -</a></strong></p> 
<p style="margin-left:12pt"><a href="#_Toc532238446">8.1 Linux的IO设备管理方法.......................................................................... - 13 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238447">8.2 简述Unix IO接口及其函数....................................................................... - 13 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238448">8.3 printf的实现分析........................................................................................ - 13 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238449">8.4 getchar的实现分析.................................................................................... - 13 -</a></p> 
<p style="margin-left:12pt"><a href="#_Toc532238450">8.5本章小结....................................................................................................... - 13 -</a></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238451">结论......................................................................................................................... - 14 -</a></strong></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238452">附件......................................................................................................................... - 15 -</a></strong></p> 
<p style="margin-left:0"><strong><a href="#_Toc532238453">参考文献................................................................................................................. - 16 -</a></strong></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc225579641"></a><a name="_Toc250450165"></a><a name="_Toc532238396">第1章 </a>概述</h1> 
<h2 style="margin-left:0;text-align:justify">
<a name="_Toc532238397"></a><a name="_Toc225579642"></a><a name="_Toc250450166">1.1 </a>Hello简介<a name="_Toc532238398"></a><a name="_Toc225579643"></a><a name="_Toc250450167"></a>
</h2> 
<p style="margin-left:0;text-align:justify">（一）P2P（From Program to Process）：在运行hello程序过程中，hello.c源程序首先被预处理为hello.i文件，再经过编译器编译为hello.s文件，接着由汇编器汇编为hello.o可重定位目标文件，最后经过链接器链接为可执行文件hello。在完成这个过程后，壳（Shell）为hello创建了一个子进程（process），这个子进程通过execve进行程序执行，就完成了完整的P2P过程。</p> 
<p style="margin-left:0;text-align:justify">（二）020（From Zero to Zero）：是指一个程序从无到有，在结束生命周期后由父进程为其回收进程的全过程。对于hello程序来说，在通过execve执行之后，系统会把程序加载到内存，待进程结束后，父进程会将其回收，内核会清理它的内存，这个过程就是020。</p> 
<h2 style="margin-left:0;text-align:justify">1.2 环境与工具</h2> 
<p style="margin-left:0;text-align:justify">软件环境：windows10    ubuntu22.04</p> 
<p style="margin-left:0;text-align:justify">硬件环境：X64 CPU       2GHz   2G RAM      256GHD Disk</p> 
<p style="margin-left:0;text-align:justify">开发工具：gcc         vim        objdump       edb</p> 
<ol><li> 
  <ol><li style="text-align:justify"><a name="_Toc532238399"> 中间结果</a></li></ol>
</li></ol> 
<p style="margin-left:0;text-align:justify">hello.i：预处理生成的文本文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello.s：*.i编译后得到的汇编语言文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello.o：*.s汇编后得到的可重定位目标文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello_objdump.s:*.o经过链接反汇编的汇编语言文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">re_hello.s：*.o经过反汇编生成的汇编语言文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">elf.txt：*.o的elf文本文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello：*.o经过链接生成的可执行目标文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">elf_1.txt：hello的elf文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238400">1.4 本章小结</a></h2> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">本章介绍了hello程序的生命周期，并介绍了执行过程中生成的中间文件的项目和作用。</p> 
<p style="margin-left:0;text-align:center"></p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc225579646"></a><a name="_Toc250450171"></a><a name="_Toc532238401">第2章 </a>预处理</h1> 
<h2 style="margin-left:0;text-align:justify">
<a name="_Toc532238402"></a><a name="_Toc225579647"></a><a name="_Toc250450172">2.1</a> 预处理的概念与作用</h2> 
<p style="margin-left:0;text-align:justify">概念：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">作用：</p> 
<ol>
<li style="text-align:justify">将所有的#define删除，展开所有的宏定义；</li>
<li style="text-align:justify">处理所有的预编译指令；</li>
<li style="text-align:justify">将#include包含的文件插入到预编译指令的位置；</li>
<li style="text-align:justify">添加行号信息和文件名信息；</li>
<li style="text-align:justify">删除所有的注释；</li>
<li style="text-align:justify">生成*.i文件。</li>
</ol> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238403">2.2在Ubuntu下预处理的命令</a></h2> 
<p style="margin-left:0;text-align:justify">指令：gcc -E hello.c -o hello.i</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">图2.2 在Ubuntu下预处理的命令</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238404">2.3 Hello的预处理结果解析</a></h2> 
<h2 style="margin-left:0;text-align:justify">正在上传…重新上传取消<a name="_Toc532238405"></a>
</h2> 
<p style="margin-left:0;text-align:center">图2.3 hello的预处理结果</p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:left">       从图中我们可以看到，hello.i的文件内容比hello.c的文件内容多得多，行数甚至达到了3000多行。这是因为hello.c在进行预处理时插入了一些#include包含的内容。比如，hello.c中第一行的#include &lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中，结果就得到了另一个C程序，通常是以.i作为文件扩展名（即预处理文件）。</p> 
<h2 style="margin-left:0;text-align:justify">2.4 本章小结</h2> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">本章介绍了hello程序的预处理指令以及生成的预处理文件，分析了hello的预处理结果，重点探究了hello.i的内容比hello.c源程序的内容多得多的原因，展示了预处理的功能。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238406">第3章 </a>编译</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238407">3.1 编译的概念与作用</a></h2> 
<p style="margin-left:21pt;text-align:justify">概念： 编译器对预处理器的输出进行编译，生成汇编语言（assemble language）的代码。本质就是利用编译程序从源语言编写的源程序产生目标程序的过程，其中的五个阶段分别是词法分析、语法分析、语义检查和中间代码生成、代码优化、目标代码生成。</p> 
<p style="margin-left:21pt;text-align:justify"></p> 
<p style="margin-left:21pt;text-align:justify">作用：主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238408">3.2 在Ubuntu下编译的命令</a></h2> 
<p style="margin-left:0;text-align:justify">指令：gcc -S hello.i -o hello.s</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">图3.2 在Ubuntu下编译的命令</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238409">3.3 Hello的编译结果解析</a></h2> 
<h2 style="margin-left:0;text-align:justify">3.3.1 术语解释</h2> 
<p style="margin-left:0;text-align:justify">              正在上传…重新上传取消               源文件字段</p> 
<p style="margin-left:0;text-align:justify">              正在上传…重新上传取消                                代码段</p> 
<p style="margin-left:0;text-align:justify">              正在上传…重新上传取消    只读数据段</p> 
<p style="margin-left:0;text-align:justify">              正在上传…重新上传取消                                对齐方式</p> 
<p style="margin-left:0;text-align:justify">              正在上传…重新上传取消                                     类型</p> 
<p style="margin-left:0;text-align:justify">              正在上传…重新上传取消                                    long类型</p> 
<p style="margin-left:0;text-align:justify">              正在上传…重新上传取消                                   string类型</p> 
<h2 style="margin-left:0;text-align:justify">3.3.2 数据类型分析</h2> 
<p style="margin-left:0;text-align:justify">      </p> 
<p style="margin-left:0;text-align:justify">（一）字符串类型</p> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">分别对应代码段中的字符串正在上传…重新上传取消和。</p> 
<p style="margin-left:0;text-align:justify">（二）循环变量i</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">编译器对%rbp进行处理，将变量i通过压栈存储在栈中，在每次循环之后对i进行加一操作，并判断是否满足循环条件（i &lt; 9），然后通过跳转表进行跳转。</p> 
<p style="margin-left:0;text-align:left">（三）main函数参数</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">%rdi用于存放第一个参数，%rsi用于存放第二个参数，因此这里先通过将%rsp的值减去32开辟main函数栈帧，然后用%edi存放第一个参数（int型参数argc），用%rsi存放第二个参数（char型数组argv[]）。</p> 
<h2 style="margin-left:0;text-align:justify">3.3.3 操作类型分析</h2> 
<p style="margin-left:0;text-align:left"><a name="_Toc532238410">（一）赋值操作</a></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">将立即数0通过压栈方式压入M[%rbp - 4]内存空间中，即将i赋值为0。</p> 
<p style="margin-left:0;text-align:left">（二）位置偏移</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">分别移动8位和16位。</p> 
<p style="margin-left:0;text-align:left">（三）加法运算</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">将%rax中的值加8。</p> 
<p style="margin-left:0;text-align:left">（四）跳转操作</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消           相等则跳转</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消            无条件跳转</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消        小于等于则跳转</p> 
<p style="margin-left:0;text-align:left">（五）比较操作</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消        对4进行比较，若小于则继续运算</p> 
<p style="margin-left:0;text-align:left">（六）函数调用</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消          调用puts()函数</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消       调用exit()函数</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消      调用printf()函数</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消       调用sleep()函数</p> 
<p style="margin-left:0;text-align:justify">3.4 本章小结</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">      本章首先介绍了编译的概念与作用，接着通过在Ubuntu操作系统上运行编译hello.c文件指令生成hello.s文件，通过分析其中的汇编代码介绍了汇编语言实现的术语解释、数据类型以及操作类型的代码实现。展示了能够读懂汇编代码的重要性。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238411">第4章 </a>汇编</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238412">4.1 汇编的概念与作用</a></h2> 
<p style="margin-left:0;text-align:justify">概念：从.s到.o，即编译后的文件通过汇编器到生成机器语言二进制程序的过程。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">作用：汇编器（as）将hello.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含着hello的指令编码。如果我们在文本编辑器中打卡hello.o文件，将会看到一堆乱码。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238413">4.2 在Ubuntu下汇编的命令</a></h2> 
<p style="margin-left:0;text-align:justify">指令：gcc hello.s -c -o hello.o</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">图4.2 在Ubuntu下汇编的命令</p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:left">应该注意，生成的.o文件为二进制文件，无法直接通过文本编辑器打开，我们需要输入readelf -a hello.o &gt; ./elf.txt重定向将其转换为ELF文件后再进行查看。</p> 
<p style="margin-left:0;text-align:left"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">图4.2 重定向生成的ELF文件</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238414">4.3 可重定位目标elf格式</a></h2> 
<p style="margin-left:0;text-align:justify">   （一）ELF头</p> 
<p style="margin-left:0;text-align:justify">              正在上传…重新上传取消</p> 
<ol><li style="text-align:justify">魔数</li></ol> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify">文件开头的几个字节称为魔数字，通常用来确定文件的类型或者格式。在加载或读取文件时，可用魔数来确认文件类型是否正确。</p> 
<ol><li style="text-align:justify">节头部表起始</li></ol> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<ol><li style="text-align:justify">ELF头的大小</li></ol> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<ol><li style="text-align:justify">节头部表表项</li></ol> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<ol><li style="text-align:justify">每一节头部表表项的大小</li></ol> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify">       （二）节头表</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">节头表由若干个表项构成，每个表项描述相应的一个节的节名、在文件中的偏移、大小、访问属性、对齐方式等，目标文件中的每个节都有一个表项与之对应。</p> 
<p style="margin-left:0;text-align:justify">从上述解析结果可以看出，该hello.o文件共有13个节。其中编号为0的节是占位符，不具有实际意义；.text、.data、.bss和.rodata节需要在存储器中分配空间，.text节是可执行的，.data和.bss节是可读写的，而.rodata节是只读不可写的。</p> 
<p style="margin-left:0;text-align:justify">  </p> 
<p style="margin-left:0;text-align:justify">（三）重定位节</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">重定位节中包含了一些本程序中使用的一些外部变量和外部函数等信息，这些信息需要在链接的时候根据重定位节的信息对这些变量符号进行修改。</p> 
<ol><li style="text-align:left">UND节</li></ol> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消         </p> 
<p style="margin-left:0;text-align:left">这些函数在hello.c中未被定义，需要在链接时在静态库中引用函数定义。</p> 
<ol><li style="text-align:left">FUNC节</li></ol> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">申明函数main为GLOBAL类型的函数。</p> 
<p style="margin-left:0;text-align:left">              3、.text节</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">              4、.rodata节</p> 
<p style="margin-left:0;text-align:left">                     正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">       （四）符号表</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">              程序中定义的函数名和全局静态变量名都属于符号，与这些符号相关的信息保存在符号表中。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238415">4.4 Hello.o的结果解析</a></h2> 
<p style="margin-left:0;text-align:justify">指令：objdump -d -r hello.o &gt; re_hello.s</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">图4.4 在Ubuntu下的反汇编指令</p> 
<p style="margin-left:0;text-align:left">      </p> 
<ul><li style="text-align:left">跳转指令发生变化</li></ul> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left"></p> 
<p style="margin-left:0;text-align:left">跳转指令由之前的段名称变为实际地址。</p> 
<ul><li style="text-align:left">函数调用发生变化</li></ul> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left"></p> 
<p style="margin-left:0;text-align:left">在反汇编程序中，call指令后紧跟着下一条指令的地址。但是在.o文件中，地址偏移量正在上传…重新上传取消均为0，且指出链接时填入地址为绝对地址引用。</p> 
<ul><li style="text-align:left">数据访问发生变化</li></ul> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left"></p> 
<p style="margin-left:0;text-align:left">在反汇编程序中，使用正在上传…重新上传取消来访问rodata，这是因为在未进行链接时，程序无法得知rodata中数据的具体地址，因此用0填充代替。同时指出链接时通过PC相对寻址的方式进行寻址。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238416">4.5 本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">     </p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">本章介绍了汇编的概念与作用，通过在Ubuntu系统下对hello.s文件进行汇编，得到了hello.o可重定位目标文件。通过对hello.o文件进行反汇编，介绍了ELF文件的内容以及各种节的内容和代码实现。最后简要介绍了编译后反汇编得到的代码与源程序的汇编代码的差别。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238417">第</a>5章 链接</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238418">5.1 链接的概念与作用</a></h2> 
<p style="margin-left:0;text-align:justify">概念：链接是将各种代码和数据片段收集并组合成为一个单文件的过程。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">作用：在每个程序模块中，某一个模块中定义的符号可以被另一个模块引用，因而最终必须通过链接将程序包含的所有模块合并起来，合并时需要在符号引用处填入定义处的地址。这就是链接的作用。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238419">5.2 在Ubuntu下链接的命令</a></h2> 
<p style="margin-left:0;text-align:justify">指令：ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">图5.2 在Ubuntu下链接的命令</p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">图5.2 重定位生成文本编辑器可打开的文件</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238420">5.3 可执行目标文件hello的格式</a></h2> 
<p style="margin-left:0;text-align:justify">（一）ELF头</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">ELF头以Magic（魔数）开始，ELF头大小为正在上传…重新上传取消，获得了入口地址为，同时程序头起点置为非零值。</p> 
<p style="margin-left:0;text-align:left">      </p> 
<p style="margin-left:0;text-align:left">（二）节头</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">       包括了文件中出现的各个节的定义、类型、位置、偏移量和大小等属性。</p> 
<p style="margin-left:0;text-align:left">（三）程序头表</p> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">与可重定位文件相比，可执行文件多了一个程序头表，也称为段头表，它是一个结构数组。包括了各个段的类型、起始位置、偏移量、虚拟地址和物理地址。</p> 
<ul><li style="text-align:left">重定位节</li></ul> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">包括了需要重定位的参数和函数的偏移量、信息、类型、符号值、符号名称和加数等一系列属性。</p> 
<ul><li style="text-align:left">Symbol table</li></ul> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238421">5.4 hello的虚拟地址空间</a></h2> 
<p style="margin-left:0;text-align:justify">       指令：edb –run hello</p> 
<p style="margin-left:0;text-align:justify">              通过该指令可以对hello可执行程序进行查看。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">              （一）地址空间</p> 
<p style="margin-left:0;text-align:justify">              使用edb打开后可以看到data dump为地址空间栏。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:center"></p> 
<p style="margin-left:0;text-align:left">              （二）指令装载地址</p> 
<p style="margin-left:0;text-align:left">              正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">              （三）寄存器</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">              （四）数据堆栈</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">             </p> 
<p style="margin-left:0;text-align:left"></p> 
<p style="margin-left:0;text-align:left">与5.3节地址相比，5.4节中的地址为重定位后的虚拟地址，因此main函数不是从地址为0x0处开始的，而是有一个偏移量，这个偏移量是ELF头的内容以及一些初始化部分的信息内容。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238422">5.5 链接的重定位过程分析</a></h2> 
<p style="margin-left:0;text-align:justify">指令：objdump -d -r hello &gt; hello_objdump.s</p> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify"></p> 
<ul><li style="text-align:justify">函数有所增加</li></ul> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">增加了start()函数。</p> 
<ul><li style="text-align:left">增加了外部库的函数</li></ul> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<ul><li style="text-align:left">地址变更</li></ul> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">对于call指令来说，可重定位目标文件中偏移量为0x0，而可执行目标文件中地址偏移量被填充为正在上传…重新上传取消。</p> 
<ul><li style="text-align:left">增加了init初始化段</li></ul> 
<p style="margin-left:0;text-align:left">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left"></p> 
<p style="margin-left:0;text-align:left"></p> 
<p style="margin-left:0;text-align:left">对以上变更进行对比，由此可以得出编译器在链接时对hello.o文件做出的更改：</p> 
<ul>
<li style="text-align:left">将call函数调用指令处的地址偏移量填充为实际的地址偏移量。在汇编阶段无法填充的原因是编译器不知道被引用函数在内存中的实际地址，因此在链接时将文件段合并之后编译器可以确定被引用函数的具体位置。</li>
<li style="text-align:left">将.rodata节中数据的地址填充为实际的地址。合并之后编译器方可得知数据的实际地址。</li>
<li style="text-align:left">插入了外部库中的函数代码实现。在对hello.s文件进行汇编生成hello.o文件时，printf()、puts()等外部库中的函数在hello.c文件中无定义，因此在连接过程中链接器从外部库中查找相关的函数声明，并将其插入到hello文件中。</li>
<li style="text-align:left">增加了init段，有助于在执行过程中对hello程序进行初始化。</li>
</ul> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238423">5.6 hello的执行流程</a></h2> 
<p style="margin-left:0;text-align:justify">       （一）执行过程：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       加载hello：</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">       进入主函数main()：</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify">       程序终止：</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       （二）各个子程序名称</p> 
<p style="margin-left:0;text-align:justify">1、&lt;_init&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">2、&lt;.plt&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">3、&lt;puts@plt&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">4、&lt;printf@plt&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">5、&lt;getchar@plt&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">6、&lt;atoi@plt&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">7、&lt;exit@plt&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">8、&lt;sleep@plt&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">9、&lt;_start&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">10、&lt;_dl_relocate_static_pie&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">11、&lt;main&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">12、&lt;__libc_csu_init&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">13、&lt;__libc_csu_fini&gt;</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">14、&lt;_fini&gt;</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238424">5.7 Hello的动态链接分析</a></h2> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">在elf文件中找到got pit的开头地址0x404000，然后通过该地址在edb中找到它：</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:left">因此0x7f37c863c2e0和0x7f37c8616d30保存的信息为动态链接后函数的最终地址。</p> 
<p style="margin-left:0;text-align:left"></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238425">5.8 本章小结</a></h2> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">本章介绍了链接的概念与作用，重点探究了链接过程中对hello.o文件做出的改变，以及链接之后hello的执行流程。同时介绍了hello可执行文件的ELF文本格式。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238426">第</a>6章 hello进程管理</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238427">6.1 进程的概念与作用</a></h2> 
<p style="margin-left:0;text-align:justify">       概念：进程的经典定义就是一个执行中程序的实例。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       作用：进程提供给应用程序两个关键抽象：</p> 
<p style="margin-left:0;text-align:justify">一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</p> 
<p style="margin-left:0;text-align:justify">一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238428">6.2 简述壳Shell-bash的作用与处理流程</a></h2> 
<p style="margin-left:0;text-align:justify">作用：Shell执行一系列的读取解析指令，然后终止。读取步骤读取来自用户的一个命令行，解析步骤将命令行解析，并运行程序。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">处理流程：</p> 
<ol>
<li style="text-align:justify">在Shell命令行中输入命令：$./hello；</li>
<li style="text-align:justify">Shell命令行解释器构造argv和envp；</li>
<li style="text-align:justify">调用fork()函数创建子进程，其地址空间与Shell父进程完全相同，包括只读代码段、读写数据段、堆以及用户栈等；</li>
<li style="text-align:justify">调用execve()函数在当前进程（新创建的子进程）的上下文中加载并运行hello程序。将hello中的.text节、.data节、.bss节等内容加载到当前进程的虚拟地址空间；</li>
<li style="text-align:justify">调用hello程序的main()函数，hello程序开始在一个进程的上下文运行。</li>
</ol> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238429">6.3 Hello的fork进程创建过程</a></h2> 
<p style="margin-left:0;text-align:justify">       通过fork()函数创建一个新的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户及虚拟地址空间相同的（但是是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork()函数时，子进程可以读写父进程中打开的任何文件。Fork()函数调用一次返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238430">6.4 Hello的execve过程</a></h2> 
<p style="margin-left:0;text-align:justify">       execve()函数加载并运行可执行文件hello，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到文件hello，execve()才会返回到调用程序。所以，execve()函数调用一次并从不返回。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238431">6.5 Hello的进程执行</a></h2> 
<p style="margin-left:0;text-align:justify">（一）逻辑控制流：</p> 
<p style="margin-left:0;text-align:justify">一系列程序计数器PC的值的序列叫做逻辑控制流，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。各个进程将轮流使用处理器，在同一个处理器核心中，每个进程执行它的流的一部分后被暂时挂起，然后执行其他进程。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">（二）用户模式与内核模式：</p> 
<p style="margin-left:0;text-align:justify">处理器通过某个控制寄存器中的一个模式位来提供限制一个应用可以执行的指令以及它可以访问的地址空间范围的功能。该寄存器描述了当前进程运行的权限。当设置了模式位时，进程就运行在内核模式中。没有设置模式位时，进程就运行在用户模式中。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存；而用户模式的进程不允许和执行特权指令、也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">（三）上下文切换：</p> 
<p style="margin-left:0;text-align:justify">内核为每个进程维持一个上下文。上下文就是内核重新启动的一个进程所需的状态。这个状态包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">（四）进程时间片：</p> 
<p style="margin-left:0;text-align:justify">一个进程执行它的控制流的一部分的每一时间段叫做时间片。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238432">6.6 hello的异常与信号处理</a></h2> 
<p style="margin-left:0;text-align:justify">hello执行过程中会出现四类异常：中断、陷阱、故障、终止。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<ul><li style="text-align:justify">中断</li></ul> 
<p style="margin-left:0;text-align:justify">会产生来自I/O设备的信号，且总是返回到下一条指令。</p> 
<ul><li style="text-align:justify">陷阱</li></ul> 
<p style="margin-left:0;text-align:justify">会产生有意的异常信号，且总是返回到下一条指令。</p> 
<ul><li style="text-align:justify">故障</li></ul> 
<p style="margin-left:0;text-align:justify">会产生潜在的可恢复的错误信号，且可能返回到当前指令。</p> 
<ul><li style="text-align:justify">终止</li></ul> 
<p style="margin-left:0;text-align:justify">会产生不可恢复的错误信号，且不会返回。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">在hello程序中，使用键盘触发中断，而Shell输出的过程触发陷阱。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<ul><li style="text-align:justify">正常运行</li></ul> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<ul><li style="text-align:justify">使用键盘中断</li></ul> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">此时进程被挂起，仍处于后台。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">输入kill，可将进程杀死。</p> 
<p style="margin-left:0;text-align:center">正在上传…重新上传取消</p> 
<ul><li style="text-align:justify">终止进程</li></ul> 
<p style="margin-left:0;text-align:justify">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify">在进程执行过程中按下ctrl+c可直接终止进程。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238433">6.7本章小结</a></h2> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">       本章介绍了进程的相关概念与作用，着重介绍了hello进程的额创建与执行过程，最后介绍了异常的种类以及信号的发送。</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238434">第</a>7章 hello的存储管理</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238435">7.1 hello的存储器地址空间</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify">结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238436">7.2 Intel逻辑地址到线性地址的变换-段式管理</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238437">7.3 Hello的线性地址到物理地址的变换-页式管理</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238438">7.4 TLB与四级页表支持下的VA到PA的变换</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238439">7.5 三级Cache支持下的物理内存访问</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238440">7.6 hello进程fork时的内存映射</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238441">7.7 hello进程execve时的内存映射</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238442">7.8 缺页故障与缺页中断处理</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238443">7.9动态存储分配管理</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify"><em>Printf</em><em>会调用malloc</em><em>，请简述动态内存管理的基本方法与策略。</em></p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238444">7.10本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:center"><strong><span style="color:#ff0000">（第</span></strong><strong><span style="color:#ff0000">7</span></strong><strong><span style="color:#ff0000">章</span></strong><strong><span style="color:#ff0000"> 2</span></strong><strong><span style="color:#ff0000">分）</span></strong></p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc532238445">第</a>8章 hello的IO管理</h1> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238446">8.1 Linux的IO设备管理方法</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify">设备的模型化：文件</p> 
<p style="margin-left:0;text-align:justify">设备管理：unix io接口</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238447">8.2 简述Unix IO接口及其函数</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238448">8.3 printf的实现分析</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify"><a href="https://www.cnblogs.com/pianist/p/3315801.html" title="[转]printf 函数实现的深入剖析 - Pianistx - 博客园">[转]printf 函数实现的深入剖析 - Pianistx - 博客园</a></p> 
<p style="margin-left:0;text-align:justify">从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用 int 0x80或syscall等.</p> 
<p style="margin-left:0;text-align:justify">字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。</p> 
<p style="margin-left:0;text-align:justify">显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238449">8.4 getchar的实现分析</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:justify">异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。</p> 
<p style="margin-left:0;text-align:justify">getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。</p> 
<h2 style="margin-left:0;text-align:justify"><a name="_Toc532238450">8.5本章小结</a></h2> 
<p style="margin-left:0;text-align:justify">（<em>以下格式自行编排，编辑时删除</em>）</p> 
<p style="margin-left:0;text-align:center"><strong><span style="color:#ff0000">（第</span></strong><strong><span style="color:#ff0000">8</span></strong><strong><span style="color:#ff0000">章</span></strong><strong><span style="color:#ff0000">1</span></strong><strong><span style="color:#ff0000">分）</span></strong></p> 
<h1 style="margin-left:0;text-align:center"><a name="_Toc532238451">结论</a></h1> 
<p style="margin-left:0;text-align:justify">经理过程：</p> 
<p style="margin-left:0;text-align:justify">       （一）预处理器将hello.c文件输出为hello.i文件；</p> 
<p style="margin-left:0;text-align:justify">       （二）编译器将hello.i文件输出为汇编文件hello.s文件；</p> 
<p style="margin-left:0;text-align:justify">       （三）汇编器将hello.s文件输出为hello.o可重定位目标文件；</p> 
<p style="margin-left:0;text-align:justify">       （四）链接器将hello.o文件与库函数文件链接生成hello可执行目标文件；</p> 
<p style="margin-left:0;text-align:justify">（五）在Shell命令行中输入命令：$./hello；</p> 
<p style="margin-left:0;text-align:justify">（六）Shell命令行解释器构造argv和envp；</p> 
<p style="margin-left:0;text-align:justify">（七）调用execve()函数在当前进程（新创建的子进程）的上下文中加载并运行hello程序</p> 
<p style="margin-left:0;text-align:justify">（八）调用hello程序的main()函数，hello程序开始在一个进程的上下文运行。</p> 
<p style="margin-left:0;text-align:justify">（九）hello程序执行完毕，由父进程将其回收。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">感悟：</p> 
<p style="margin-left:0;text-align:justify">       从大一入学写下第一个hello.c程序，到现在逐步学习了hello程序经历的一系列过程，不由得感叹计算世界的奇妙。今后的学习更应注重底层逻辑的实现，打好数理基础，为将来的计算之路添砖加瓦。</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p></p> 
<h1 style="margin-left:0;text-align:center">
<a name="_Toc225579656"></a><a name="_Toc250450180"></a><a name="_Toc532238452">附件</a>
</h1> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello.i：预处理生成的文本文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello.s：*.i编译后得到的汇编语言文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello.o：*.s汇编后得到的可重定位目标文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello_objdump.s:*.o经过链接反汇编的汇编语言文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">re_hello.s：*.o经过反汇编生成的汇编语言文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">elf.txt：*.o的elf文本文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">hello：*.o经过链接生成的可执行目标文件</p> 
<p style="margin-left:0;text-align:justify"></p> 
<p style="margin-left:0;text-align:justify">elf_1.txt：hello的elf文件</p> 
<p></p> 
<h1 style="margin-left:0;text-align:center"><a name="_Toc532238453">参考文献</a></h1> 
<p style="margin-left:0;text-align:justify">[1]  CSAPP大黑书</p> 
<p style="margin-left:0;text-align:justify">[2]  CSDN网站</p> 
<p style="margin-left:0;text-align:justify">[3]  科普中国</p> 
<p style="margin-left:0;text-align:justify"></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>