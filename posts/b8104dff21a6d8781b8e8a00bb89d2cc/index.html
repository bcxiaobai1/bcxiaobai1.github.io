<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C语言手写-植物大战僵尸 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言手写-植物大战僵尸</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0"><p>植物大战僵尸，是一个非常经典的小游戏，初学者从零开始，开发一个自己的植物大战僵尸，还是非常值得期待的！可以作为自己的课设，也可以用来快速提升自己的项目开发能力。</p></li></ul> 
 <h2>项目效果（<a class="kdocs-link" style="color:#0A6CFF" href="https://www.bilibili.com/video/BV1vM4y1X7Kb/?share_source=copy_web&amp;vd_source=07605986f1c13ab3786dec350495a673" target="_blank" rel="noopener noreferrer">详细视频教程-下载素材-点这里</a>）</h2> 
 <p><span class="kdocs-color" style="background-color:#DFF0C4">说明：因为完整动图提交后提示违规，所以这里仅截图示意。如果需要演示视频，在评论中回复即可。</span></p> 
 <div class="kdocs-line-container"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:860px;justify-content:center;align-items:center;height:auto"> 
   <div class="kdocs-img" style="padding-top:69.76744%;height:0"> 
    <img src="https://images2.imgbox.com/99/70/dgf3ktzR_o.png" style="margin-left:;width:860px;margin-top:-69.76744%;height:auto"> 
   </div> 
  </div> 
 </div> 
 <h2>项目准备</h2> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0"><p>安装Visual Studio的任意版本（推荐VS2019社区版、VS2022社区版）</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0"><p>安装easyx图形库（<a class="kdocs-link" style="color:#0A6CFF" href="https://easyx.cn/download/EasyX_20220901.exe" target="_blank" rel="noopener noreferrer">官网下载地址</a>）</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0"><p>领取项目素材（回复“植物大战僵尸”，即可领取）</p></li></ul> 
 <h2>创建项目</h2> 
 <p>使用VS创建项目，使用空项目模板：</p> 
 <div class="kdocs-line-container"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:886px;justify-content:center;align-items:center;height:auto"> 
   <div class="kdocs-img" style="padding-top:67.72009%;height:0"> 
    <img src="https://images2.imgbox.com/04/f2/ZLuwzRG0_o.png" style="margin-left:;width:886px;margin-top:-67.72009%;height:auto"> 
   </div> 
  </div> 
 </div> 
 <p>导入素材：在项目目录下，创建res文件夹，把解压后的素材拷贝到res目录下。</p> 
 <div class="kdocs-line-container"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:699px;justify-content:center;align-items:center;height:auto"> 
   <div class="kdocs-img" style="padding-top:32.04578%;height:0"> 
    <img src="https://images2.imgbox.com/05/6d/IACePjZ5_o.png" style="margin-left:;width:699px;margin-top:-32.04578%;height:auto"> 
   </div> 
  </div> 
 </div> 
 <p></p> 
 <p></p> 
 <div class="kdocs-line-container"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:800px;justify-content:center;align-items:center;height:auto"> 
   <div class="kdocs-img" style="padding-top:69.375%;height:0"> 
    <img src="https://images2.imgbox.com/b4/e4/ossJVHjJ_o.png" style="margin-left:;width:800px;margin-top:-69.375%;height:auto"> 
   </div> 
  </div> 
 </div> 
 <p></p> 
 <p></p> 
 <div class="kdocs-line-container"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:800px;justify-content:center;align-items:center;height:auto"> 
   <div class="kdocs-img" style="padding-top:69.375%;height:0"> 
    <img src="https://images2.imgbox.com/17/a9/bdTQD7nm_o.png" style="margin-left:;width:800px;margin-top:-69.375%;height:auto"> 
   </div> 
  </div> 
 </div> 
 <h2>实现游戏初始场景</h2> 
 <p>代码如下（需要逐行代码视频讲解，可回复“代码讲解“）。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;graphics.h&gt;
#include "tools.h"
#include &lt;mmsystem.h&gt;
#pragma comment(lib, "winmm.lib")

#define WIN_WIDTH    900
#define WIN_HEIGHT    600

enum { WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUT };
IMAGE imgBg;
IMAGE imgBar;
IMAGE imgCards[ZHI_WU_COUT];
IMAGE* imgZhiWu[ZHI_WU_COUT][20];
int curZhiWu;
int curX, curY; //当前选中植物在移动过程中的坐标

struct zhiWu {
    int type;   // &gt;=1  0:没有植物
    int frameIndex;
};
struct zhiWu  map[3][9];
int sunshine;
int sunshineTable[ZHI_WU_COUT] = { 100, 50 };

void gameInit() {
    loadimage(&amp;imgBg, "res/bg.jpg");
    loadimage(&amp;imgBar, "res/bar.png");
    sunshine = 150;
    curZhiWu = 0;
    memset(imgZhiWu, 0, sizeof(imgZhiWu));
    memset(map, 0, sizeof(map));

    char name[64];
    for (int i = 0; i &lt; ZHI_WU_COUT; i++) {
        sprintf_s(name, sizeof(name), "res/Cards/card_%d.png", i + 1);
        loadimage(&amp;imgCards[i], name);

        for (int j = 0; j &lt; 20; j++) {
            sprintf_s(name, sizeof(name), "res/zhiwu/%d/%d.png", i, j + 1);
            imgZhiWu[i][j] = new IMAGE;
            loadimage(imgZhiWu[i][j], name);
            if (imgZhiWu[i][j]-&gt;getwidth() == 0) {
                delete imgZhiWu[i][j];
                imgZhiWu[i][j] = NULL;
            }
        }
    }

    initgraph(WIN_WIDTH, WIN_HEIGHT, 1);
    // 设置字体：
    LOGFONT f;
    gettextstyle(&amp;f);                     // 获取当前字体设置
    f.lfHeight = 30;                      // 设置字体高度为 48
    f.lfWidth = 15;
    strcpy(f.lfFaceName, "Segoe UI Black");
    f.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿  
    settextstyle(&amp;f);                     // 设置字体样式
    setbkmode(TRANSPARENT);
    setcolor(BLACK);

    mciSendString("play res/bg.mp3 repeat", 0, 0, 0);
}

void updateWindow() {
    BeginBatchDraw();

    putimage(0, 0, &amp;imgBg);
    putimagePNG(250, 0, &amp;imgBar);

    for (int i = 0; i &lt; ZHI_WU_COUT; i++) {
        int x = 338 + i * 64;
        int y = 6;
        putimage(x, y, &amp;imgCards[i]);
    }

    if (curZhiWu &gt; 0) {  // 绘制正在移动的植物
        IMAGE* img = imgZhiWu[curZhiWu - 1][0];
        putimagePNG(curX - img-&gt;getwidth() * 0.5, curY - img-&gt;getheight() * 0.5, img);
    }

    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 9; j++) {
            if (map[i][j].type &gt; 0) {
                int x = 260 + j * 81.6;    // (msg.x - 260) / 81.6;
                int y = 180 + i * 103.6 + 14; // (msg.y - 210) / 103.6;
                int zhiWuIndex = map[i][j].type;
                int frameIndex = map[i][j].frameIndex;
                putimagePNG(x, y, imgZhiWu[zhiWuIndex - 1][frameIndex]);
            }
        }
    }

    char scoreText[8];
    sprintf_s(scoreText, sizeof(scoreText), "%d", sunshine);
    outtextxy(282 - 10 + 4, 50 + 15 + 2, scoreText);
    EndBatchDraw();
}

void userClick() {
    ExMessage msg;
    static int status = 0;
    if (peekmessage(&amp;msg)) {
        if (msg.message == WM_LBUTTONDOWN) {
            if (msg.x &gt; 338 &amp;&amp; msg.x &lt; 338 + 64 * ZHI_WU_COUT &amp;&amp; msg.y&gt;6 &amp;&amp; msg.y &lt; 96) {
                int index = (msg.x - 338) / 64;
                printf("%dn", index);
                status = 1;
                curZhiWu = index + 1; // 1， 2 
                curX = msg.x;
                curY = msg.y;
            }
        }
        else if (msg.message == WM_MOUSEMOVE &amp;&amp; status == 1) {
            curX = msg.x;
            curY = msg.y;
        }
        else if (msg.message == WM_LBUTTONUP &amp;&amp; status == 1) {
            printf("upn");
            if (msg.x &gt; 260 &amp;&amp; msg.y &lt; 995 &amp;&amp; msg.y &gt; 180 &amp;&amp; msg.y &lt; 491) {
                if (sunshine &gt;= sunshineTable[curZhiWu - 1]) {
                    sunshine -= sunshineTable[curZhiWu - 1];
                    int col = (msg.x - 260) / 81.6;
                    int row = (msg.y - 210) / 103.6;
                    printf("[%d,%d]n", row, col);
                    if (map[row][col].type == 0) {
                        map[row][col].type = curZhiWu;
                        map[row][col].frameIndex = 0;
                    }
                }
            }
            status = 0;
            curZhiWu = 0;
        }
    }
}

void updateGame() {
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 9; j++) {
            if (map[i][j].type &gt; 0) {
                map[i][j].frameIndex++;
                if (imgZhiWu[map[i][j].type - 1][map[i][j].frameIndex] == NULL) {
                    map[i][j].frameIndex = 0;
                }
            }
        }
    }
}

int main(void) {
    gameInit();

    int timer = 0;
    bool flag = true;
    while (1) {
        userClick();
        timer += getDelay();
        if (timer &gt; 20) {
            timer = 0;
            flag = true;
        }
        if (flag) {
            flag = false;
            updateWindow();
            updateGame();
        }
    }

    return 0;
}</code></pre> 
 <h2>添加启动菜单</h2> 
 <p>创建菜单界面，代码如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void startUI() {
    IMAGE imgBg, imgMenu1, imgMenu2;
    loadimage(&amp;imgBg, "res/menu.png");
    loadimage(&amp;imgMenu1, "res/menu1.png");
    loadimage(&amp;imgMenu2, "res/menu2.png");
    int flag = 0;
    while (1) {
        BeginBatchDraw();
        putimage(0, 0, &amp;imgBg);
        putimagePNG(474, 75, flag ? &amp;imgMenu2 : &amp;imgMenu1);

        ExMessage msg;
        if (peekmessage(&amp;msg)) {
            if (msg.message == WM_LBUTTONDOWN &amp;&amp;
                msg.x &gt; 474 &amp;&amp; msg.x &lt; 474 + 300 &amp;&amp; msg.y &gt; 75 &amp;&amp; msg.y &lt; 75 + 140) {
                flag = 1;
                EndBatchDraw();
            }
            else if (msg.message == WM_LBUTTONUP &amp;&amp; flag) {
                return;
            }
        }
        EndBatchDraw();
    }
}</code></pre> 
 <p>在main函数中调用菜单，代码如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int main(void) {
    gameInit();
    startUI();
    int timer = 0;
    bool flag = true;
    while (1) {
        userClick();
        timer += getDelay();
        if (timer &gt; 20) {
            timer = 0;
            flag = true;
        }
        if (flag) {
            flag = false;
            updateWindow();
            updateGame();
        }
    }

    return 0;
}</code></pre> 
 <h2>生产阳光</h2> 
 <p>熟悉植物大战僵尸的同学都知道，种植植物才能消灭僵尸，但是种植植物，需要先具备一定数量的阳光值。初始的阳光值很小。有两种方式生成阳光：第一种，随机降落少量的阳光；第二种，通过种植向日葵，让向日葵自动生产阳光。我们先实现第一种方式。</p> 
 <p></p> 
 <p>定义一个结构体，来表示阳光球。因为阳光是以旋转的方式运动的，所以定义一个图片帧数组，通过循环播放图片帧来实现旋转效果。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">IMAGE imgSunshineBall[29]; 
struct sunshineBall { 
    int x, y;
    int frameIndex;
    bool used;
    int destY;
    int timer = 0;
};
struct sunshineBall balls[10];</code></pre> 
 <p>在gameInit函数中，初始化阳光帧数组。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">    memset(balls, 0, sizeof(balls));
    for (int i = 0; i &lt; 29; i++) {
        sprintf_s(name, sizeof(name), "res/sunshine/%d.png", i + 1);
        loadimage(&amp;imgSunshineBall[i], name);
    }</code></pre> 
 <p>创建阳光，代码如下。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void createSunshine() {
    int ballMax = sizeof(balls) / sizeof(balls[0]);

    static int frameCount = 0;
    static int fre = 400;
    frameCount++;
    if (frameCount &gt;= fre) {
        fre = 200 + rand() % 200;  
        frameCount = 0;
        int i;
        for (i = 0; i &lt; ballMax &amp;&amp; balls[i].used; i++);
        if (i &gt;= ballMax) return;

        balls[i].used = true;
        balls[i].frameIndex = 0;
        balls[i].x = 260 + rand() % (905 - 260);
        balls[i].y = 60;
        balls[i].destY = 180 + (rand() % 4) * 90 + 20;
        balls[i].timer = 0;
    }
}</code></pre> 
 <p>修改阳光的位置和帧序号，代码如下。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void updateSunshine() {
    int ballMax = sizeof(balls) / sizeof(balls[0]);

    for (int i = 0; i &lt; ballMax; i++) {
        if (balls[i].used) {
            balls[i].frameIndex = (balls[i].frameIndex + 1) % 29;
            if(balls[i].timer == 0) balls[i].y += 2;
            if (balls[i].y &gt;= balls[i].destY) {
                balls[i].timer++;
                if (balls[i].timer &gt; 100) balls[i].used = false;
            }
        }
    }
}</code></pre> 
 <p>在updateGame函数中调用以上两个函数 ，以创建阳光并更新阳光的状态。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">createSunshine();
updateSunshine();</code></pre> 
 <p>在updateWindow函数中，渲染阳光。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">for (int i = 0; i &lt; 10; i++) {
    if (balls[i].used) {
        putimagePNG(balls[i].x, balls[i].y, &amp;imgSunshineBall[balls[i].frameIndex]);
    }
}</code></pre> 
 <h2>收集阳光</h2> 
 <p>当“阳光球”出现的时候，用户点击阳光球，就可以“收集”这个阳光，当前总的阳光值就会增加25点。在原版的植物大战僵尸游戏中，阳光球被收集后，会慢慢移动到顶部的“工具栏”的左侧。这个阳光球的“移动过程”，我们后续再实现。</p> 
 <p>定义一个全局变量，表示当前总的阳光值。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int sunshine;</code></pre> 
 <p>在初始化gameInit中，设置一个初始值。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">sunshine = 150;</code></pre> 
 <p>创建收集阳光的函数，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void collectSunshine(ExMessage* msg) {
    int count = sizeof(balls) / sizeof(balls[0]);
    int w = imgSunshineBall[0].getwidth();
    int h = imgSunshineBall[0].getheight();
    for (int i = 0; i &lt; count; i++) {
        if (balls[i].used) {
            int x = balls[i].x;
            int y = balls[i].y;
            if (msg-&gt;x &gt; x &amp;&amp; msg-&gt;x &lt; x + w &amp;&amp; msg-&gt;y &gt; y &amp;&amp; msg-&gt;y &lt; y + h) {
                balls[i].used = false;
                sunshine += 25;
                mciSendString("play res/sunshine.mp3", 0, 0, 0);
            }
        }
    }
}</code></pre> 
 <p>在用户点击处理中，调用收集阳光的函数。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;mmsystem.h&gt;
#pragma comment(lib, "winmm.lib")

void userClick() {
    ExMessage msg;
    static int status = 0;
    if (peekmessage(&amp;msg)) {
        if (msg.message == WM_LBUTTONDOWN) {
            if (msg.x &gt; 338 &amp;&amp; msg.x &lt; 338 + 65 * ZHI_WU_COUNT &amp;&amp; msg.y &lt; 96) {
                int index = (msg.x - 338) / 65;
                status = 1;
                curZhiWu = index + 1;
            } else {
                collectSunshine(&amp;msg);
            }
        }
        // ...... 
    }
}</code></pre> 
 <h2>显示当前总的阳光值</h2> 
 <p>在gameInit初始化中，设置字体。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">LOGFONT f;
gettextstyle(&amp;f);                     // 获取当前字体设置
f.lfHeight = 30;                      // 设置字体高度为 48
f.lfWidth = 15;
strcpy(f.lfFaceName, "Segoe UI Black");
f.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿  
settextstyle(&amp;f);                     // 设置字体样式
setbkmode(TRANSPARENT);
setcolor(BLACK);</code></pre> 
 <p>在updateWindow中绘制阳光值。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">char scoreText[8];
sprintf_s(scoreText, sizeof(scoreText), "%d", sunshine);
outtextxy(276, 67, scoreText);</code></pre> 
 <h2>创建僵尸</h2> 
 <p>创建僵尸的数据模型。这里一共创建了10个僵尸，这10个僵尸全部被消灭后，这个关卡就胜利了。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">
struct zm {
    int x, y; 
    int frameIndex;
    bool used;
    int speed;
};
struct zm zms[10];
IMAGE imgZM[22];</code></pre> 
 <p>僵尸数组，以及僵尸序列帧图片数组，在gameInit函数中进行初始化，如下。<span class="kdocs-color" style="color:#757575">（<span class="kdocs-bold" style="font-weight:bold">注意：把僵尸的素材图片保存到src/zm目录下。）</span></span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">memset(zms, 0, sizeof(zms));
srand(time(NULL));

for (int i = 0; i &lt; 22; i++) {
    sprintf_s(name, sizeof(name), "res/zm/%d.png", i + 1);
    loadimage(&amp;imgZM[i], name);
}</code></pre> 
 <p>创建僵尸，代码如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void createZM() {
    static int zmFre = 500;
    static int count = 0;
    count++;
    if (count &gt; zmFre) {
        zmFre = rand() % 200 + 300;
        count = 0;

        int i;
        int zmMax = sizeof(zms) / sizeof(zms[0]);
        for (i = 0; i &lt; zmMax &amp;&amp; zms[i].used; i++);
        if (i &lt; zmMax) {
            zms[i].used = true;
            zms[i].x = WIN_WIDTH;
            zms[i].y = 180 + (1 + rand() % 3) * 100 - 8;
            zms[i].speed = 1;
        }
    }
}</code></pre> 
 <p>更新僵尸的数据（僵尸的图片帧序号、僵尸的位置），代码如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void updateZM() {
    int zmMax = sizeof(zms) / sizeof(zms[0]);

    static int count1 = 0;
    count1++;
    if (count1 &gt; 2) {
        count1 = 0;
        for (int i = 0; i &lt; zmMax; i++) {
            if (zms[i].used) {
                zms[i].x -= zms[i].speed;
                if (zms-&gt;x &lt; 236 - 66) {
                    printf("GAME OVER!n");
                    MessageBox(NULL, "over", "over", 0); //TO DO
                    break;
                }
            }
        }
    }
    
    static int count2 = 0;
    count2++;
    if (count2 &gt; 4) {
        count2 = 0;
        for (int i = 0; i &lt; zmMax; i++) {
            if (zms[i].used) {
                zms[i].frameIndex = (zms[i].frameIndex + 1) % 22;
            }
        }
    }
}</code></pre> 
 <p>在updateGame函数中，创建僵尸并更新僵尸数据，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">createZM();
updateZM();</code></pre> 
 <p>创建绘制僵尸的接口, 如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void drawZM() {
    int zmCount = sizeof(zms) / sizeof(zms[0]);
    for (int i = 0; i &lt; zmCount; i++) {
        if (zms[i].used) {
            IMAGE* img = &amp;imgZM[zms[i].frameIndex];
            int x = zms[i].x;
            int y = zms[i].y - img-&gt;getheight();
            putimagePNG(x, y, img);
        }
    }
}</code></pre> 
 <p>在updateWindow函数中，绘制僵尸，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">drawZM();</code></pre> 
 <h2>实现阳光球的飞跃</h2> 
 <p>现在的实现效果是，阳光被点击后，阳光球直接消失了！而原版的植物大战僵尸中，阳光被点击后，阳光会自动飞向左上角的位置，飞到终点后，阳光值才增加25点。我们的实现方式是，阳光球每次飞跃4个点，直到飞到终点，如下图：</p> 
 <div class="kdocs-line-container"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:582px;justify-content:center;align-items:center;height:auto"> 
   <div class="kdocs-img" style="padding-top:82.64605%;height:0"> 
    <img src="https://images2.imgbox.com/d9/e7/BG3oGKm3_o.png" style="margin-left:;width:582px;margin-top:-82.64605%;height:auto"> 
   </div> 
  </div> 
 </div> 
 <p></p> 
 <p>给阳光的结构体添加两个成员，表示飞跃过程中的偏移量：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct sunshineBall { 
    int x, y;
    int frameIndex;
    bool used;
    int destY;
    int timer;

    //添加以下两个成员
    float xOff;
    float yOff;
};</code></pre> 
 <p></p> 
 <p>在阳光被创建时，把变异量设置为0， 如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void createSunshine() {
    int ballMax = sizeof(balls) / sizeof(balls[0]);
    static int frameCount = 0;
    static int fre = 200;
    frameCount++;
    if (frameCount &gt;= fre) {
        //...略
        balls[i].xOff = 0;
        balls[i].yOff = 0;
    }

}</code></pre> 
 <p></p> 
 <p>阳光被点击后，马上修改阳光球的xoff和yoff:</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;math.h&gt;

void collectSunshine(ExMessage* msg) {
    int count = sizeof(balls) / sizeof(balls[0]);
    int w = imgSunshineBall[0].getwidth();
    int h = imgSunshineBall[0].getheight();
    for (int i = 0; i &lt; count; i++) {
        if (balls[i].used) {
            int x = balls[i].x;
            int y = balls[i].y;
            if (msg-&gt;x &gt; x &amp;&amp; msg-&gt;x &lt; x + w &amp;&amp;
                msg-&gt;y &gt;y &amp;&amp; msg-&gt;y &lt; y + h) {
                balls[i].used = false;
                sunshine += 25;
                mciSendString("play res/sunshine.mp3", 0, 0, 0);
                
                // 设置初始偏移量
                float destX = 262;
                float destY = 0;
                float angle = atan((y - destY) / (x - destX));
                balls[i].xOff = 4 * cos(angle);
                balls[i].yOff = 4 * sin(angle);
            }
        }
    }
}</code></pre> 
 <p>在阳光飞跃过程中更新阳光的位置，如下：（注意是在飞跃过程中，不断计算偏移量，效果更好。）</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void updateSunshine() {
    int ballMax = sizeof(balls) / sizeof(balls[0]);
    for (int i = 0; i &lt; ballMax; i++) {
        if (balls[i].used) {
           //略...
        }
        else if (balls[i].xOff) {
            float destX = 263;
            float destY = 0;
            float angle = atan((balls[i].y - destY) / (balls[i].x - destX));
            balls[i].xOff = 4 * cos(angle);
            balls[i].yOff = 4 * sin(angle);

            balls[i].x -= balls[i].xOff;
            balls[i].y -= balls[i].yOff;
            if (balls[i].y &lt; 0 || balls[i].x &lt; 262) {
                balls[i].xOff = 0;
                balls[i].yOff = 0;
                sunshine += 25; 
            }
        }
    }
}</code></pre> 
 <p>删除原来被点击后，立即更新阳光值的代码。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">//sunshine += 25;</code></pre> 
 <p>修改渲染阳光的判断条件，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">for (int i = 0; i &lt; ballMax; i++) {
    if (balls[i].used 
            || balls[i].xOff) { //添加这个条件
        IMAGE* img = &amp;imgSunshineBall[balls[i].frameIndex];
        putimagePNG(balls[i].x, balls[i].y, img);
    }
}</code></pre> 
 <p>此时已经能够实现阳光的飞跃了，但是飞跃动作太慢了，后期我们再优化。</p> 
 <h2>发射豌豆</h2> 
 <p>僵尸靠近时，已经种植的植物豌豆就会自动发射“子弹”，我们先为子弹定义数据类型，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct bullet {
    int x, y;
    int row;
    bool used;
    int speed;
};
struct bullet bullets[30];
IMAGE imgBulletNormal;</code></pre> 
 <p>在gameInit函数中，初始化“豌豆子弹池”和子弹的图片，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">loadimage(&amp;imgBulletNormal, "res/bullets/bullet_normal.png");
memset(bullets, 0, sizeof(bullets));</code></pre> 
 <p>在僵尸结构体中，添加成员row, 表示该僵尸所在的“行”，方便后续的判断。也可以不加，直接根据僵尸的y坐标来计算。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct zm {
    int x, y; 
    int frameIndex;
    bool used;
    int speed;

    int row; //0..2
};</code></pre> 
 <p>在createZM函数中，创建僵尸的时候，设置row成员的值，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">......
if (i &lt; zmMax) {
    zms[i].used = true;
    zms[i].x = WIN_WIDTH;

    zms[i].row = rand() % 3; // 0..2;
    zms[i].y = 172 + (1 + zms[i].row) * 100;

    zms[i].speed = 1;
}
......  </code></pre> 
 <p>创建shoot函数，实现豌豆发射子弹，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void shoot() {
    int zmCount = sizeof(zms) / sizeof(zms[0]);
    int directions[3] = { 0 }; 
    int dangerX = WIN_WIDTH - imgZM[0].getwidth();
    for (int i = 0; i &lt; zmCount; i++) {
        if (zms[i].used &amp;&amp; zms[i].x &lt; dangerX) {
            directions[zms[i].row] = 1;
        }
    }

    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 9; j++) {
            if (map[i][j].type == WAN_DOU+1 &amp;&amp; directions[i]) {
                static int count = 0;
                count++;
                if (count &gt; 20) {
                    count = 0;
                    int k;
                    int maxCount = sizeof(bullets) / sizeof(bullets[0]);
                    for (k = 0; k &lt; maxCount &amp;&amp; bullets[k].used; k++);
                    if (k &lt; maxCount) {
                        bullets[k].row = i;
                        bullets[k].speed = 4;
                        bullets[k].used = true;

                        int zwX = 260 + j * 81.6;    // (msg.x - 260) / 81.6;
                        int zwY = 180 + i * 103.6 + 14; // (msg.y - 210) / 103.6;

                        bullets[k].x = zwX + imgZhiWu[map[i][j].type - 1][0]-&gt;getwidth()-10;
                        bullets[k].y = zwY + 5;
                    }
                }
            }
        }
    }
}</code></pre> 
 <p>更新子弹的位置，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void updateBullets() {
    int countMax = sizeof(bullets) / sizeof(bullets[0]);
    for (int i = 0; i &lt; countMax; i++) {
        if (bullets[i].used) {
            bullets[i].x += bullets[i].speed;
            if (bullets[i].x &gt; WIN_WIDTH) {
                bullets[i].used = false;
            }
        }
    }
}</code></pre> 
 <p>在updateGame函数中，发射子弹并更新子弹的位置，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">shoot();
updateBullets();</code></pre> 
 <p>在updateWindow中绘制子弹，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int bulletMax = sizeof(bullets) / sizeof(bullets[0]);
for (int i = 0; i &lt; bulletMax; i++) {
    if (bullets[i].used) {
        putimagePNG(bullets[i].x, bullets[i].y, &amp;imgBulletNormal);
    }
}</code></pre> 
 <h2>子弹和僵尸的碰撞</h2> 
 <p>子弹碰到僵尸之后，子弹会“爆炸”，同时僵尸会“掉血”。我们先给僵尸添加血量成员。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct zm {
     //略...
    int blood;
};</code></pre> 
 <p>并在创建僵尸的时候，把血量初始化为100，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">//...
zms[i].speed = 1;
zms[i].blood = 100;</code></pre> 
 <p>子弹在碰到僵尸之后才会爆炸，并显示爆炸图片：</p> 
 <div class="kdocs-line-container"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;width:352px;justify-content:center;align-items:center;height:auto"> 
   <div class="kdocs-img" style="padding-top:74.431816%;height:0"> 
    <img src="https://images2.imgbox.com/f4/a1/y3xbZKhE_o.png" style="margin-left:;width:352px;margin-top:-74.431816%;height:auto"> 
   </div> 
  </div> 
 </div> 
 <p>所以，我们在子弹的结构体中添加两个成员，分别表示当前是否已经爆炸，以及爆炸的帧图片序号，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct bullet {
    //...
    bool blast;
    int frameIndex; 
};
IMAGE imgBulletBlast[4];</code></pre> 
 <p>在gameInit函数中对子弹帧图片数组，进行初始化，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">loadimage(&amp;imgBulletBlast[3], "res/bullets/bullet_blast.png");
for (int i = 0; i &lt; 3; i++) {
    float k = (i + 1) * 0.2;
    loadimage(&amp;imgBulletBlast[i], "res/bullets/bullet_blast.png", 
        imgBulletBlast[3].getwidth()*k,
        imgBulletBlast[3].getheight()*k, true);
}</code></pre> 
 <p>在发射子弹shoot函数中，对子弹的blast和帧序号frameIndex进行初始化，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">bullets[k].row = i;
bullets[k].speed = 4;
bullets[k].used = true;

bullets[k].blast = false;
bullets[k].blastTime = 0;</code></pre> 
 <p>在更新子弹的updateBullets函数中，更新子弹爆炸的帧序号，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">bullets[i].x += bullets[i].speed;
if (bullets[i].x &gt; WIN_WIDTH) {
    bullets[i].used = false;
}

if (bullets[i].blast) {
    bullets[i].blastTime++;
    if (bullets[i].blastTime &gt;= 4) {
        bullets[i].used = false;
    }
}</code></pre> 
 <p>进行碰撞检测，检查子弹和僵尸是否发生碰撞，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void collisionCheck() {
    int bCount = sizeof(bullets) / sizeof(bullets[0]);
    int zCount = sizeof(zms) / sizeof(zms[0]);
    for (int i = 0; i &lt; bCount; i++) {
        if (bullets[i].used == false || bullets[i].blast)continue;
        for (int k = 0; k &lt; zCount; k++) {
            int x1 = zms[k].x + 80;
            int x2 = zms[k].x + 110;
            if (bullets[i].row == zms[k].row &amp;&amp; bullets[i].x &gt; x1 &amp;&amp; bullets[i].x &lt; x2) {
                zms[i].blood -= 20;
                bullets[i].blast = true;
                bullets[i].speed = 0;
            }
        }
        
    }
}
</code></pre> 
 <p>在updateGame函数中，调用碰撞检测函数，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">collisionCheck();</code></pre> 
 <p>渲染子弹的爆炸效果，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int bulletMax = sizeof(bullets) / sizeof(bullets[0]);
for (int i = 0; i &lt; bulletMax; i++) {
    if (bullets[i].used) {
        if (bullets[i].blast) {
            IMAGE* img = &amp;imgBulletBlast[bullets[i].blastTime];
            int x = bullets[i].x + 12 - img-&gt;getwidth() / 2;
            int y = bullets[i].y + 12 - img-&gt;getheight() / 2;
            putimagePNG(x, y, img);

            /*bullets[i].used = false;*/
        }
        else {
            putimagePNG(bullets[i].x, bullets[i].y, &amp;imgBulletNormal);
        }
        
    }
}
</code></pre> 
 <h2>僵尸死亡</h2> 
 <p>僵尸被豌豆子弹击中后，会“掉血”，血量掉光了，就直接KO了，同时变成一堆“黑沙”。</p> 
 <p>给僵尸结构体添加dead成员，表示是否已经死亡，另外添加一个图片帧数组，用来表示变成成黑沙的过程。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct zm {
    ......
    bool dead;
};
IMAGE imgZmDead[20];</code></pre> 
 <p>在gameInit中对这个图片帧数组进行初始化。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">for (int i = 0; i &lt; 20; i++) {
    sprintf_s(name, sizeof(name), "res/zm_dead/%d.png", i + 1);
    loadimage(&amp;imgZmDead[i], name);
}</code></pre> 
 <p>在碰撞检测中对僵尸的血量做检测，如果血量降到0，就设置为死亡状态。如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void collisionCheck() {
    int bCount = sizeof(bullets) / sizeof(bullets[0]);
    int zCount = sizeof(zms) / sizeof(zms[0]);
    for (int i = 0; i &lt; bCount; i++) {
        if (bullets[i].used == false || bullets[i].blast)continue;
        for (int k = 0; k &lt; zCount; k++) {
            int x1 = zms[k].x + 80;
            int x2 = zms[k].x + 110;
            if (zms[k].dead==false &amp;&amp;  //添加这个条件
                    bullets[i].row == zms[k].row &amp;&amp; bullets[i].x &gt; x1 &amp;&amp; bullets[i].x &lt; x2) {
                zms[k].blood -= 20;
                bullets[i].blast = true;
                bullets[i].speed = 0;
                
                //对血量进行检测
                if (zms[k].blood &lt;= 0) {
                    zms[k].dead = true;
                    zms[k].speed = 0;
                    zms[k].frameIndex = 0;
                }
                break;
            }
        }
    }
}</code></pre> 
 <p>僵尸死亡后，在updateZM中，更新僵尸的状态（变成黑沙发）。如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">static int count2 = 0;
count2++;
if (count2 &gt; 4) {
    count2 = 0;
    for (int i = 0; i &lt; zmMax; i++) {
        if (zms[i].used) {
            //判断是否已经死亡
            if (zms[i].dead) {
                zms[i].frameIndex++;
                if (zms[i].frameIndex &gt;= 20) {
                    zms[i].used = false;
                }
            }
            else {
                zms[i].frameIndex = (zms[i].frameIndex + 1) % 22;
            }
        }
    }
}</code></pre> 
 <p>绘制僵尸的黑沙状态，如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void drawZM() {
    int zmCount = sizeof(zms) / sizeof(zms[0]);
    for (int i = 0; i &lt; zmCount; i++) {
        if (zms[i].used) {
            //选择对应的渲染图片
            IMAGE* img = (zms[i].dead) ? imgZmDead : imgZM;
            img += zms[i].frameIndex;

            int x = zms[i].x;
            int y = zms[i].y - img-&gt;getheight();
            putimagePNG(x, y, img);
        }
    }
}</code></pre> 
 <h2><a class="kdocs-link" style="color:#0A6CFF" href="https://www.bilibili.com/video/BV1vM4y1X7Kb/?share_source=copy_web&amp;vd_source=07605986f1c13ab3786dec350495a673" target="_blank" rel="noopener noreferrer">后续的内容，点击这里看完整的实现</a></h2> 
</div>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>