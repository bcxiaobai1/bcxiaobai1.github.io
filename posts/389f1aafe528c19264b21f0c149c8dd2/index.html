<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Linux--进程间通信 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux--进程间通信</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>        上一篇相关Linux文章已经时隔2月，Linux的学习也相对于来说是更加苦涩；无妨，漫漫其修远兮,吾将上下而求索。</p> 
<p>下面该片文章主要是对进程间通信进行介绍，还对管道，消息队列，共享内存，信号量都一 一进行讲解，虽然是改知识都是属于进程间通信的范畴，但更多是为了更好的理解进程。如果对该文章的进行深入了解，想必对进程的理解也能得到巨大的提升。</p> 
<h2>进程间通信</h2> 
<p>在讲进程时，非常重要的一个知识就是：进程具有独立性！既然它具有独立性，那为什么又需要通信？进程间为什么要需要联系？<strong>进程的独立性是独立的分配资源，不同进程之间的资源是独立的</strong>。但是<strong>进程不是孤立的，进程与进程之间是需要进行信息的交互和状态的传递等</strong>。比如父子进程，他们是需要通信，随时了解状态等信息。因此需要进程间通信。</p> 
<hr>
<h3>Ⅰ什么是通信</h3> 
<p><strong>数据传输</strong>：一个进程需要将它的数据发送给另一个进程</p> 
<p><strong>资源共享：</strong>多个进程之间共享同样的资源。</p> 
<p><strong>通知事件：</strong>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止 时要通知父进程）。</p> 
<p><strong>进程控制：</strong>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p> 
<h3>Ⅱ 为什么需要通信</h3> 
<p>在很多时候是需要多进程协同的，例如：</p> 
<p>查看一个文件中的 "hello"，这个时候就需要一个进程专门负责打印文件，另一进程负责进行过滤。两个进程通过'|'（书划线）</p> 
<blockquote> 
 <p>cat file | grep 'hello'</p> 
</blockquote> 
<p><strong>总结</strong>：需要多进程协同去完成某种业务内容</p> 
<p><strong>通信的本质问题：</strong>操作系统需要直接或者间接给通信双方的进程提供"<strong>内存空间</strong>"，通信的进程，必须看见同一份公共资源。</p> 
<h3>Ⅲ如何通信</h3> 
<p><strong>1.管道--基于文件系统下</strong></p> 
<blockquote> 
 <p>(1)匿名管道pipe</p> 
 <p>(2)命名管道</p> 
</blockquote> 
<p> <img alt="" height="348" src="https://images2.imgbox.com/06/9b/qb1o9w8X_o.png" width="631"></p> 
<p><strong>2.System V IPC --聚焦在本地通信</strong></p> 
<blockquote> 
 <p></p> 
 <p>(1)System V 消息队列</p> 
 <p>(2)System V 共享内存</p> 
 <p>(3)System V 信号量</p> 
</blockquote> 
<p><strong>3.POSIX IPC--让通信过程可以跨主机</strong></p> 
<blockquote> 
 <p>(1)消息队列</p> 
 <p>(2)共享内存</p> 
 <p>(3)信号量</p> 
 <p>(4)互斥量</p> 
 <p>(5)条件变量</p> 
 <p>(6)读写锁</p> 
</blockquote> 
<p><strong>不同的通讯种类本质就是:</strong>通过“公共资源”实现双方通讯，公共资源是操作系统的特地一模个块所提供的，例如：“公共资源”是文件，那么就是管道通信。</p> 
<h2> 管道</h2> 
<p>管道是Unix中最古老的进程间通信的形式，我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”。<strong>管道是通过(不同的)PCB控制fd链接共同管道文件(内存级文件)，</strong>故内存不会通过磁盘I/O的方式进行通信。</p> 
<hr>
<h3>Ⅰ匿名管道</h3> 
<p>实现两个进程看到同一个管道文件，实质就是<strong>通过父进程通过管道特定的系统调用，以读方式和写方式打开一个内存级文件，并通过fork创建子进程时写时拷贝被子，进程继承后，各自关闭自己的读写端进而形成一条通信信道，这条通信信道是基于文件的，故此叫做管道</strong>。这个管道文件是没有名字的，所以就叫做匿名管道。</p> 
<p><strong>pipe(管道)的用法</strong></p> 
<blockquote> 
 <p><strong>#include&lt;unistd.h&gt;</strong></p> 
 <p><strong>功能:</strong>创建一无名管道</p> 
 <p><strong>原型 </strong></p> 
 <p>int pipe(int fd[2]);</p> 
 <p><strong>参数</strong></p> 
 <p>fd：文件描述符数组,其中fd[0]表示读端, fd[1]表示写端</p> 
 <p><strong>返回值:</strong>成功返回0，失败返回错误代码</p> 
</blockquote> 
<p><img alt="" height="269" src="https://images2.imgbox.com/ab/42/fEIGFPO8_o.png" width="501"></p> 
<p><strong>用fork来共享管道原理 </strong></p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/52/46/LZz3vkLc_o.png" width="823"></p> 
<p><strong> 实 例 代 码</strong></p> 
<p>代码的实现也是按照深度理解管道的步骤进行的，第一步创建管道-pipe，第二步父进程fork出子进程，第三步父进程关闭写-fds[1]子进程关闭读-fds[0]。</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;cassert&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;


using namespace std;

//父进程进行读取，子进程进行写入
int main()
{
    //第一步：创建管道文件，打开读写端
    int fds[2];
    int n = pipe(fds);
    assert(n==0);

    //第二步:fork
    pid_t id = fork();
    assert(id &gt;= 0);
    if(id == 0)
    {
        //子进程的通讯代码
        close(fds[0]);
        //string msg = "hello , i am child";
        const char *s ="我是子进程，正在发消息-&gt;";
        int cnt = 0;
        while(true)
        {
            //int sprintf(char *str, const char *format, ...);
            //int fprintf(FILE *stream, const char *format, ...);
            //int snprintf(char *str, size_t size, const char *format, ...);

            cnt++;
            char buf[1024];
            snprintf(buf,sizeof buf, "child-&gt;parent say: %s[%d][%d]n",s, cnt,getpid());
            //写端写满的时候，在写会阻塞，等对方进行读取！
            write(fds[1],buf,strlen(buf));
            cout&lt;&lt;"count: " &lt;&lt; cnt &lt;&lt;endl;

            //sleep(20);//每隔一秒写入
            //break;
        }

        //子进程
        close(fds[1]); 
        cout &lt;&lt; "子进程关闭自己的写端" &lt;&lt; endl;
        exit(0);
    }
    //父进程进行读取
    close(fds[1]);

    //父进程的通信代码
    while(true)
    {
        char buf[1024];
        ssize_t s = read(fds[0],buf,sizeof(buf)-1);

        if(s&gt;0)
        {
            buf[s]=0;
            cout &lt;&lt; "Get Message# " &lt;&lt; buf &lt;&lt;"| my pid:" &lt;&lt; getpid() &lt;&lt; endl;
        }
        else if(s == 0)
        {
            cout &lt;&lt; "read: " &lt;&lt; s &lt;&lt; endl;
            break;
        } 
        //sleep(5);
        //细节：父进程可没有进行sleep
        break;
    }

    close(fds[0]);
    cout &lt;&lt;"父进程关闭读端"&lt;&lt; endl;

    int status = 0;

    n = waitpid(id,&amp;status,0);
    assert(n == id);
    
    cout &lt;&lt; "pid-&gt;"&lt;&lt;(status &amp; 0x7F)&lt;&lt;endl;



    // 0,1,2被占用-&gt;3 ，4
    //[0]:读取 
    //[1]:写入  
    // cout&lt;&lt;"fds[0]:"&lt;&lt; fds[0]&lt;&lt;endl;
    // cout&lt;&lt;"fds[1]:"&lt;&lt; fds[1]&lt;&lt;endl;


    return 0;
}</code></pre> 
<p><strong>结果演示 </strong></p> 
<blockquote> 
 <p>[hongxin@VM-8-2-centos pipe]$ make<br> g++ -o mypipe mypipe.cc -std=c++11<br> [hongxin@VM-8-2-centos pipe]$ ./mypipe <br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[1][12302]<br> | my pid:12301<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[2][12302]<br> | my pid:12301<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[3][12302]<br> | my pid:12301<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[4][12302]<br> | my pid:12301<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[5][12302]<br> | my pid:12301<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[6][12302]<br> | my pid:12301<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[7][12302]<br> | my pid:12301<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[8][12302]<br> | my pid:12301</p> 
</blockquote> 
<p><strong>站在文件描述符角度-深度理解管道</strong></p> 
<p><img alt="" height="638" src="https://images2.imgbox.com/eb/99/0EWUZ4kl_o.png" width="531"></p> 
<p><strong>读写特征</strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24">1.读慢，写快--缓存写</span></p> 
 <p>[hongxin@VM-8-2-centos pipe]$ ./mypipe <br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[1][16115]<br> | my pid:16114<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[2][16115]<br> child-&gt;parent say: 我是子进程，正在发消息-&gt;[3][16115]<br> child-&gt;parent say: 我是子进程，正在发消息-&gt;[4][16115]<br> child-&gt;parent say: 我是子进程，正在发消息-&gt;[5][16115]</p> 
 <p><span style="color:#fe2c24">2.读快，写慢--需要读等写</span></p> 
 <p>[hongxin@VM-8-2-centos pipe]$ ./mypipe <br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[1][16754]<br> | my pid:16753<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[2][16754]<br> | my pid:16753<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[3][16754]<br> | my pid:16753</p> 
 <p><span style="color:#fe2c24">3.写关闭，读到0</span></p> 
 <p>[hongxin@VM-8-2-centos pipe]$ ./mypipe <br> count: 1<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[1][18227]<br> | my pid:18226<br> read: 0</p> 
 <p><span style="color:#fe2c24">4.读关闭，写的话OS会终止写端 会给写进程发送信号，终止写端。 </span><br><span style="color:#494949">[hongxin@VM-8-2-centos pipe]$ ./mypipe <br> count: 1<br> count: 2<br> count: 3<br> Get Message# child-&gt;parent say: 我是子进程，正在发消息-&gt;[1][21895]<br> count: 4<br> count: 5<br> count: 6<br> count: 7<br> count: 8<br> count: 9<br> count: 10<br> count: 11<br> | my pid:21894<br> count: 12<br> count: 13<br> 父进程关闭读端<br> pid-&gt;13</span></p> 
</blockquote> 
<p>操作系统会给写进程发送13号-sigpipe终止之前的写进程<img alt="" height="379" src="https://images2.imgbox.com/24/8b/1ssrUBHu_o.png" width="835"></p> 
<p><strong>管道的特征</strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24">1.管道的生命周期随进程</span></p> 
 <p><span style="color:#fe2c24">2.管道可以用来具有血缘关系的进程之间进行通信，常用于父子通信</span></p> 
 <p><span style="color:#fe2c24">3.管道是面向字节流（网络）</span></p> 
 <p><span style="color:#fe2c24">4.半双工通信--单向通信（特殊概念）</span></p> 
 <p><span style="color:#fe2c24">5.互斥与同步机制--对共享资源进行保护的方案</span></p> 
</blockquote> 
<h3><strong>Ⅱ深度理解控制管道--一父控4子</strong></h3> 
<p><strong>实现功能：</strong>父进程通过管道随机给不同子进程发随机的任务，子进程接受后执行任务。</p> 
<p><img alt="" height="347" src="https://images2.imgbox.com/ec/80/Fn06u3Z5_o.png" width="957"></p> 
<blockquote> 
 <p><strong>思路:</strong></p> 
 <p><span style="color:#fe2c24">1.建立子进程并建立和子进程通信的信道</span></p> 
 <p> <span style="color:#ed7976">       1.1</span>加载方法表</p> 
 <p>               <span style="color:#4da8ee"> 1.1.1</span>声明函数指针类型</p> 
 <p>              <span style="color:#4da8ee">  1.1.2</span>创建函数任务</p> 
 <p>                <span style="color:#4da8ee">1.1.3</span>加载任务          </p> 
 <p>   <span style="color:#ed7976">     1.2</span>创建子进程，并且维护好父子通信信道</p> 
 <p>             <span style="color:#4da8ee">   1.2.1</span>创建子进程和管道</p> 
 <p>        <span style="color:#4da8ee">        1.2.2</span>通信</p> 
 <p>                        <span style="color:#a2e043">①</span>获取命令码   --recvTask(接受任务):read</p> 
 <p>                        <span style="color:#a2e043">②</span>完成任务      --调用函数</p> 
 <p><span style="color:#fe2c24">2.父进程控制子进程，负载均衡的向子进程发生命令码</span></p> 
 <p>       <span style="color:#ed7976"> 2.1</span>设置随机数种子MakeSeed()</p> 
 <p>       <span style="color:#38d8f0"> 2.2</span>随机选择进程--通过随机数%进程数量</p> 
 <p>        <span style="color:#38d8f0">2.3</span>随机选择任务--通过随机数%任务数量</p> 
 <p>      <span style="color:#38d8f0">  2.4</span>随机选择进程后发送随机的任务</p> 
 <p>        <span style="color:#ed7976">2.5</span>次数限制/永远进行</p> 
 <p><span style="color:#fe2c24">3.回收子进程信息--避免僵尸</span></p> 
</blockquote> 
<p><strong>测 试 代 码</strong></p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;cassert&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;ctime&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/types.h&gt;

//获取随机数
#define MakeSeed()  srand((unsigned long)time(nullptr)^getpid()^0x123456 ^ rand()%1234);

#define PROCSS_NUM 5

///子进程完成某一种任务--模拟

//函数指针类型
typedef void (*func_t)();

void downloadTask()
{
    std::cout&lt;&lt; getpid() &lt;&lt;"下载任务n"&lt;&lt;std::endl;
    sleep(1);
}

void ioTask()
{
    std::cout&lt;&lt;getpid() &lt;&lt;"IO任务n"&lt;&lt;std::endl;
    sleep(1);
}

void flushTask()
{
    std::cout&lt;&lt;getpid() &lt;&lt;"刷新任务n"&lt;&lt;std::endl;
    sleep(1);
}

//加载任务到函数指针类型的数组中
void loadTaskFunc(std::vector&lt;func_t&gt; *out)
{
    assert(out);
    out-&gt;push_back(downloadTask);
    out-&gt;push_back(ioTask);
    out-&gt;push_back(flushTask);
}


///下面代码是多进程程序//

//结构体类型
class subEp //Endpoint
{
public:
    subEp(pid_t subId, int writeFd)
        : subId_(subId), writeFd_(writeFd)//初始化列表
    {
        //将不同的进程的pid-文件描述信息 通过 snprintf函数以字符串的形式传入缓冲区nameBuffer 在拷贝在name_
        char nameBuffer[1024];  
        snprintf(nameBuffer,sizeof nameBuffer,"process-%d[pid(%d)-fd(%d)]",num++,subId_,writeFd_);
        name_=nameBuffer;
    }

public:
    static int num;
    std::string name_;  //进程信息
    pid_t subId_;       //进程的pid
    int writeFd_;       //子进程的文件描述符
};
int subEp::num =0;

//接受任务
int recvTask (int readFd)
{
    int code = 0;
    ssize_t s = read(readFd,&amp;code,sizeof code);//读取4byte(文件描述符(int类型))
    if(s == 4) return code;
    else if(s &lt;= 0) return -1;
    else return 0;
}

//发送任务
void sendTask(const subEp &amp;process,int taskNum)
{
    std::cout &lt;&lt; "send task num :"&lt;&lt; taskNum &lt;&lt;" send to " &lt;&lt; process.name_ &lt;&lt; std::endl;
    int n = write(process.writeFd_,&amp;taskNum,sizeof(taskNum));//通过文件描述符（process.writeFd_就代表是哪个进程）发送(int类型-taskNum就代表几号任务)
    assert(n == sizeof(int));
    (void)n;
}

//生成子进程/管道 处理任务
void createSubProcess(std::vector&lt;subEp&gt; *subs,std::vector&lt;func_t&gt; &amp;funcMap)
{
    std::vector&lt;int&gt; deleteFd;
    for (int i = 0; i &lt; PROCSS_NUM; i++)
    {
         for(int i = 0; i &lt; deleteFd.size(); i++) close(deleteFd[i]);
        //生成管道
        int fds[2];
        int n = pipe(fds);
        assert(n == 0);
        (void)n;

        //生成子进程
        pid_t id = fork();
        if (id == 0)
        {
            // 子进程,进行处理任务
            close(fds[1]);//关闭子进程(管道)写
            while (true)
            {
                //1.获取命令码，如果没有发送，子进程应该阻塞
                int commandCode = recvTask(fds[0]);
                //2.完成任务 /* code */
                if(commandCode &gt;= 0 &amp;&amp; commandCode &lt; funcMap.size()) funcMap[commandCode]();//通过数组下标选择并执行该任务
                else if(commandCode == -1) break;

            }
            exit(0);
        }

        //父进程建立信道
        close(fds[0]);//关闭父进程（管道）读
        subEp sub(id, fds[1]);//初始化
        subs-&gt;push_back(sub); //后插
        deleteFd.push_back(fds[1]);
    }
}
 
void loadBlanContrl(const std::vector&lt;subEp&gt;&amp; subs,const std::vector&lt;func_t&gt; &amp;funcMap,int count)
{
    int processnum = subs.size();//进程数量
    int tasknum = funcMap.size();//任务数量
    bool forever = (count == 0 ? true :false);
    while(true)
    {
        //1.先选择一个进程 --&gt;std::vector&lt;subEp&gt; -&gt;index -随机选择进程
        int subIdx = rand()%processnum;
        //2.选择一个任务  --&gt;std::vector&lt;func_t&gt; -&gt;index -随机选择任务
        int taskIdx = rand() % tasknum;
        //3.任务发送给选择的进程
        sendTask(subs[subIdx], taskIdx);//发送随机选择的进程/随机任务

        sleep(1);//每隔1秒发送
        
        //限制发送次数和0退出
        if(!forever)
        {
            count--;
            if(count == 0)break;
        }
    }
    //write quit -&gt; read 0
    //退出后 全部关闭通道
    for(int i = 0;i &lt; processnum; i++)
    {
        close(subs[i].writeFd_);
    }
}

//回收子进程信息
void waitProcess(std::vector&lt;subEp&gt; processes)
{
    int processnum = processes.size();//进程数量
    for(int i = 0;i &lt; processnum;i++)
    {
        waitpid(processes[i].subId_,nullptr,0);//回收子进程信息，避免僵尸
        std::cout &lt;&lt; "wait sub process success ...:" &lt;&lt;processes[i].subId_ &lt;&lt; std::endl;
    }
}

int main()
{
    MakeSeed()//随机数种子

    // 1.建立子进程并建立和子进程通信的信道
    //1.1加载方法表
    std::vector&lt;func_t&gt; funcMap;//数组&lt;函数指针&gt; 
    loadTaskFunc(&amp;funcMap);//加载任务
    //1.2创建子进程，并且维护好父子通信信道
    std::vector&lt;subEp&gt; subs;//数组&lt;结构体/类&gt; 
    createSubProcess(&amp;subs,funcMap);//创建进程/管道

    // 2.走到这里是父进程，控制子进程，负载均衡的向子进程发生命令码
    int taskCnt =10;//0:永远进行
    loadBlanContrl(subs,funcMap,taskCnt);


    // 3.回收子进程信息
    waitProcess(subs);

    return 0;
}</code></pre> 
<p><strong>站在内核角度-管道本质 </strong></p> 
<p> <img alt="" height="374" src="https://images2.imgbox.com/81/29/tk0k67lz_o.png" width="470"></p> 
<h3>Ⅲ命名管道</h3> 
<p><strong>创建一个命名管道</strong></p> 
<p>♧命名管道可以从命令行上创建，命令行方法是使用下面这个命令：</p> 
<blockquote> 
 <p>mkfifo filename</p> 
 <p>mkfifo clean_pipe</p> 
 <p><strong>p</strong>rw-rw-r-- 1 hongxin hongxin   0 Jan 30 17:47 <span style="color:#ffd900"><span style="background-color:#0d0016">clean_pipe</span></span></p> 
</blockquote> 
<p>♧两个文件的通信--先建立两个普通文件和一个管道文件</p> 
<blockquote> 
 <p>prw-rw-r-- 1 hongxin hongxin   0 Jan 30 17:47 <span style="color:#ffd900"><span style="background-color:#0d0016">clean_pipe</span></span><br> -rw-rw-r-- 1 hongxin hongxin  96 Jan 30 17:40 client.cc<br> -rw-rw-r-- 1 hongxin hongxin 162 Jan 30 17:41 makefile<br> -rw-rw-r-- 1 hongxin hongxin  96 Jan 30 17:40 server.cc</p> 
</blockquote> 
<p>脚本语言</p> 
<blockquote> 
 <p>cnt=0; while :; do echo "hello world-&gt; $cnt"; let cnt++; sleep 1; done &gt; named_pipe</p> 
</blockquote> 
<p><img alt="" height="116" src="https://images2.imgbox.com/a2/f2/7C75smHH_o.png" width="1200"></p> 
<p>♧命名管道也可以从程序里创建，相关函数有：</p> 
<blockquote> 
 <p>        #include &lt;sys/types.h&gt;<br>         #include &lt;sys/stat.h&gt;</p> 
 <p>        int mkfifo(const char *filename,mode_t mode);</p> 
</blockquote> 
<p>♧ 命名管道也可以从程序里删除，相关函数：</p> 
<blockquote> 
 <p>       #include &lt;unistd.h&gt;</p> 
 <p>       int unlink(const char *path);</p> 
</blockquote> 
<p><strong>例子-用命名管道实现server&amp;client通信</strong></p> 
<p><strong>server.cc</strong></p> 
<pre><code>#include "comm.hpp"

int main()
{
    bool r = createFifo(NAMED_PIPE);
    assert(r);
    (void)r;

    int rfd = open(NAMED_PIPE,O_RDONLY);
    if(rfd &lt; 0) exit(1);

    //read
    char buf[1024];
    while(true)
    {
        ssize_t s = read(rfd, buf, sizeof(buf)-1);
        if(s &gt; 0)
        {
            buf[s] = 0;
            std::cout &lt;&lt; "client-&gt;server# " &lt;&lt; buf &lt;&lt; std::endl;
        }
        else if(s == 0)
        {
            std::cout &lt;&lt; "client quit, me too!" &lt;&lt; std::endl;
            break;
        }
        else{
                std::cout &lt;&lt; "err string" &lt;&lt; strerror(errno) &lt;&lt; std::endl;
                break;
        }
    }

    close(rfd);

    removeFifo(NAMED_PIPE);

    return 0;
}</code></pre> 
<p><strong>client.cc </strong></p> 
<pre><code>#include "comm.hpp"

int main()
{
    std::cout &lt;&lt; "client begin" &lt;&lt; std::endl;
    int wfd = open(NAMED_PIPE,O_WRONLY);
    std::cout &lt;&lt; "client end" &lt;&lt; std::endl;
    if(wfd &lt; 0) exit(1);

    //write
    char buf[1024];
    while(true)
    {
        std::cout &lt;&lt; "Please Say:";
        fgets(buf,sizeof buf,stdin);
        if(strlen(buf) &gt; 0) buf[strlen(buf)-1] = 0;
        ssize_t n = write(wfd,buf,strlen(buf));
        assert(n == strlen(buf));
        (void)n;
        
    }

    close(wfd);

    return 0;
}</code></pre> 
<p><strong> comm.hpp</strong></p> 
<pre><code>#pragma once

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cerrno&gt;
#include &lt;cassert&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#define NAMED_PIPE "/tmp/mypipe.130"

bool createFifo(const std::string &amp;path)
{
    umask(0);
    int n = mkfifo(path.c_str(), 0600);
    if (n == 0)
        return true;
    else
    {
        std::cout &lt;&lt; "errno: " &lt;&lt; errno &lt;&lt; " err string: " &lt;&lt; strerror(errno) &lt;&lt; std::endl;
        return false;
    }
}

void removeFifo(const std::string &amp;path)
{
    int n = unlink(path.c_str());
    assert(n == 0); // debug , release 里面就没有了
    (void)n;
}</code></pre> 
<p><strong>演示：</strong></p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/8a/a7/q9Xslt8R_o.png" width="1200"></p> 
<h2>system V共享内存</h2> 
<h3>Ⅰ共享内存的介绍</h3> 
<p><strong>共享内存的原理</strong></p> 
<p>原理图如下</p> 
<p><img alt="" height="584" src="https://images2.imgbox.com/38/88/zBjA97pa_o.png" width="1200"></p> 
<p>对共享内存的理解：</p> 
<p>     <em>   1.共享内存是专门设计用来IPC（进程间通信）：以前c语言中学的malloc是开辟一块空间，pcb从进程地址空间通过页表映射到内存开辟一块空间，但是这块空间是不被其他进程所共享的。</em></p> 
<p><em>        2.共享内存是一种通信方式，所有的进程都可以用：开辟一块共享内存，不光是你运行的进程可以用，其他进程也也可以访问这块内存，只是看如何获取该内存的shmid 。</em></p> 
<p><em>        3.OS（操作系统）中一定会同时存在很多的共享内存。</em></p> 
<p><strong>共享内存的概念</strong></p> 
<p>通过让不同的进程，看到同一个内存块的方式：共享内存</p> 
<h3>Ⅱ共享内存函数</h3> 
<p><strong>shmget函数</strong> </p> 
<blockquote> 
 <p>头文件：</p> 
 <p>       <em>#include &lt;sys/ipc.h&gt;<br>        #include &lt;sys/shm.h&gt;</em></p> 
 <p>功能：用来创建共享内存</p> 
 <p>原型：int shmget(key_t key, size_t size, int shmflg);</p> 
 <p>参数</p> 
 <p>        key:这个共享内存段名字</p> 
 <p>        size:共享内存大小</p> 
 <p>        shmflg:由九个权限标志构成，它们的用法和创建文件时使用的mode模式标志是一样的</p> 
 <p>返回值：成功返回一个非负整数，即该共享内存段的标识码；失败返回-1</p> 
</blockquote> 
<p>参数 shmflg</p> 
<p><em>        有两个默认选项IPC_CREAT，IPC_EXCL</em></p> 
<p><em>        IPC_CREAT：如果创建共享内存时，不存在，创建即可；存在，获取该共享内存。</em></p> 
<p><em>        IPC_EXCL：</em></p> 
<p><em>                1.无法单独使用 ； </em></p> 
<p><em>                2.IPC_CREAT | IPC_EXCL同时使用时，如果不存在就创建，如果存在就返回错误。换句话说，如果创建了一块共享内存，那么这个共享内存一定是新的shm。</em></p> 
<p>返回值 int</p> 
<p>         <em>On success, a valid shared memory identifier is returned.  On errir, -1 is returned, and errno is set to indicate the error.</em></p> 
<p><em>        --创建成功，返回一个合法的共享内存的标识符。创建失败，返回-1，错误码被设置。</em></p> 
<p>参数 key </p> 
<p><em>        作用是：能进行唯一性标识</em></p> 
<p><em>        通过ftok函数形成一个key，ftok的介绍     </em></p> 
<p>                <em>头文件： #include &lt;sys/types.h&gt;       #include &lt;sys/ipc.h&gt;</em></p> 
<p><em>                </em>原型： key_t ftok(const char *pathname, int proj_id);</p> 
<p>                作用：将路径名和项目标识符转换为唯一标识符key</p> 
<p>                参数：*pathname 路径名 ，proj_id 项目标识符</p> 
<p><strong>shmctl函数 </strong></p> 
<blockquote> 
 <p>功能：用于控制共享内存</p> 
 <p>头文件：</p> 
 <p>        <em>#include &lt;sys/ipc.h&gt;<br>         #include &lt;sys/shm.h&gt;</em></p> 
 <p>原型</p> 
 <p>      <em>  int shmctl(int shmid, int cmd, struct shmid_ds *buf);</em></p> 
 <p>参数</p> 
 <p>        shmid:由shmget返回的共享内存标识码</p> 
 <p>        cmd:将要采取的动作（有三个可取值） IPC_SET / IPC_RMID / IPC_INFO</p> 
 <p>        buf:指向一个保存着共享内存的模式状态和访问权限的数据结构</p> 
 <p>返回值：成功返回0；失败返回-1</p> 
</blockquote> 
<p><strong>shmat函数</strong></p> 
<blockquote> 
 <p>功能：创建共享内存与进程的关联</p> 
 <p>头文件</p> 
 <p><em>       #include &lt;sys/types.h&gt;<br>        #include &lt;sys/shm.h&gt;</em></p> 
 <p>原型</p> 
 <p>      <em> void *shmat(int shmid, const void *shmaddr, int shmflg);</em></p> 
 <p>参数</p> 
 <p>        shmid:由shmget返回的共享内存标识码</p> 
 <p>       *shmaddr:一般设置为nullptr，系统会选择一个合适的（未使用的）地址来附加段。（因为我们一般是不知道内存地址的）</p> 
 <p>        shmflg::默认0，共享内存只读</p> 
 <p>返回值：成功返回shmat()附加的共享内存段的地址；失败返回-1</p> 
</blockquote> 
<p><strong>shmdt函数</strong></p> 
<blockquote> 
 <p>功能：取消共享内存与进程的关联</p> 
 <p>头文件：</p> 
 <p><em>       #include &lt;sys/types.h&gt;<br>        #include &lt;sys/shm.h&gt;</em></p> 
 <p>原型</p> 
 <p>      <em>  int shmdt(const void *shmaddr);</em></p> 
 <p>参数</p> 
 <p>        *shmaddr：shmat()的返回值</p> 
 <p>返回值：成功返回0；失败返回-1</p> 
</blockquote> 
<h3>Ⅲ实例代码</h3> 
<p><strong>makefile</strong></p> 
<pre><code>.PHONY:all
all:shm_client shm_server

shm_client:shm_client.cc
	g++ -o $@ $^ -std=c++11
shm_server:shm_server.cc
	g++ -o $@ $^ -std=c++11

.PHONY:clean
clean:
	rm -f shm_client shm_server</code></pre> 
<p><strong>comm.hpp</strong></p> 
<pre><code>#ifndef _COMM_HPP_
#define _COMM_HPP_

#include &lt;iostream&gt;
#include &lt;cerrno&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;

#define PATHNAME "."
#define PROJ_ID  0x66
// 共享内存的大小，一般建议是4KB的整数倍
// 系统分配共享内存是以4KB为单位的！ --- 内存划分内存块的基本单位Page
#define MAX_SIZE 4097  // --- 内核给你的会向上取整， 内核给你的，和你能用的，是两码事

key_t getKey()
{
    key_t k = ftok(PATHNAME, PROJ_ID); //可以获取同样的一个Key！
    if(k &lt; 0)
    {
        // cin, cout, cerr -&gt; stdin, stdout, stderr -&gt; 0, 1, 2
        std::cerr &lt;&lt; errno &lt;&lt; ":" &lt;&lt; strerror(errno) &lt;&lt; std::endl;
        exit(1);
    }
    return k;
}
int getShmHelper(key_t k, int flags)
{
    // k是要shmget，设置进入共享内存属性中的！用来表示
    // 该共享内存，在内核中的唯一性！！
    // shmid vs key:
    // fd    vs inode
    int shmid = shmget(k, MAX_SIZE, flags);
    if(shmid &lt; 0)
    {
        std::cerr &lt;&lt; errno &lt;&lt; ":" &lt;&lt; strerror(errno) &lt;&lt; std::endl;
        exit(2);
    }
    return shmid;
}

int getShm(key_t k)
{
    return getShmHelper(k, IPC_CREAT);
}

int createShm(key_t k)
{
    return getShmHelper(k, IPC_CREAT | IPC_EXCL | 0600);
}

void *attachShm(int shmid)
{
    // int a = 10;
    // 100u; // 字面值
    // 纯数字是没有意义的，必须得有类型才可以
    // 10u;
    // 10L;
    // 10;
    // 3.14f;
    // 100元，200$
    void *mem = shmat(shmid, nullptr, 0); //64系统，8
    if((long long)mem == -1L)
    {
        std::cerr &lt;&lt;"shmat: "&lt;&lt; errno &lt;&lt; ":" &lt;&lt; strerror(errno) &lt;&lt; std::endl;
        exit(3);
    }
    return mem;
}

void detachShm(void *start)
{
    if(shmdt(start) == -1)
    {
        std::cerr &lt;&lt;"shmdt: "&lt;&lt; errno &lt;&lt; ":" &lt;&lt; strerror(errno) &lt;&lt; std::endl;
    }
}

void delShm(int shmid)
{
    if(shmctl(shmid, IPC_RMID, nullptr) == -1)
    {
        std::cerr &lt;&lt; errno &lt;&lt; " : " &lt;&lt; strerror(errno) &lt;&lt; std::endl;
    }
}

#endif</code></pre> 
<p><strong>shm_server.cc</strong></p> 
<pre><code>#include "comm.hpp"
#include &lt;unistd.h&gt;

int main()
{
    key_t k = getKey(); 
    printf("key: 0x%xn", k); // key
    int shmid = createShm(k);
    printf("shmid: %dn", shmid); //shmid 

    // sleep(5);
    
    char *start = (char*)attachShm(shmid);
    printf("attach success, address start: %pn", start);

    // 使用
    while(true)
    {
        // char buffer[]; read(pipefd, buffer, ...)
        printf("client say : %sn", start);
        struct shmid_ds ds;
        shmctl(shmid, IPC_STAT, &amp;ds);
        printf("获取属性: size: %d, pid: %d, myself: %d, key: 0x%x",
                ds.shm_segsz, ds.shm_cpid, getpid(), ds.shm_perm.__key);
        sleep(1);
    }

    // 去关联
    detachShm(start);

    sleep(10);

    // 删除共享内存
    delShm(shmid);
    return 0;
}</code></pre> 
<p><strong>shm_client.cc</strong></p> 
<pre><code>#include "comm.hpp"
#include &lt;unistd.h&gt;

int main()
{
    key_t k = getKey(); 
    printf("key: 0x%xn", k);
    int shmid = getShm(k);
    printf("shmid: %dn", shmid);

    char *start = (char*)attachShm(shmid);
    printf("attach success, address start: %pn", start);

    const char* message = "hello server, 我是另一个进程，正在和你通信";
    pid_t id = getpid();
    int cnt = 1;
    // char buffer[1024];
    while(true)
    {
        sleep(5);
        snprintf(start, MAX_SIZE, "%s[pid:%d][消息编号:%d]", message, id, cnt++);
        // snprintf(buffer, sizeof(buffer), "%s[pid:%d][消息编号:%d]", message, id, cnt++);
        // memcpy(start, buffer, strlen(buffer)+1);
        // pid, count, message
    }

    detachShm(start);

    //done

    return 0;
}</code></pre> 
<h3><strong>Ⅳ代码实现的细节把控</strong></h3> 
<p><strong>再谈key</strong></p> 
<p>共享内存和malloc开辟的内存是一样的，都是先需要先描述，后组织。当我们调用接口，操作系统开辟一块普通的内存空间时，操作系统是需要维护的它的，所以他们就不仅仅只开辟一块物理空间。共享内存空间亦是如此：<u>物理内存空间+共享内存的相关属性</u></p> 
<p>操作系统对共享内存相关属性进行增删改查，实质就是对它对应的物理内存空间进行管理。在创建共享内存时，因为共享内存相关属性必须有一个数据体现出改共享内存的唯一性--key。</p> 
<p>为什么共享内存要在系统中保持唯一性呢？因为在OS中，可能会存在多个共享内存。</p> 
<p>key是为了保证该共享内存的唯一性，也是为了让其他进程能够看到key，当其他进程识别到key时，就可以进入该共享内存，然后对这共享内存进行读取操作。这好比就是，小王和小明两个去酒店吃饭，他们都知道同一个房间号，同时在酒店的有一个房间也挂着这个房间号，那么他们就能够通过他们的信息找到该酒店的房间，然后在里面就餐。</p> 
<p>所以说可以被进程知道，同时在共享内存的相关数据中，这个结构体肯定也存在这个key值。</p> 
<blockquote> 
 <p>struct  shm{<!-- --></p> 
 <p>        .............</p> 
 <p>                key_t key;</p> 
 <p>        ................<br> }</p> 
</blockquote> 
<p><strong>shmid与key的关系</strong></p> 
<p>在编写代码的时候，我们看见两个进行不管有相同的key，还有相同的shmid。那么key与shmid有什么关系呢？</p> 
<p>他们的关系就好像fd与inode一样，fd与key是给用使用的，而shmid与inode是被封装在内核数据结构中的，是不被用户使用的，但是能被用户看见。这个好比我们在学校用学号，在社会上用身份证号，当毕业后学校对我们的学号进行删除，不会影响，但身份证号被删除就会影响一生。这就好比key与shimd的关系。</p> 
<p>当我们只运行下部分代码时：</p> 
<pre><code>    key_t k = getKey(); 
    printf("key: 0x%xn", k);
    int shmid = getShm(k);
    printf("shmid: %dn", shmid);</code></pre> 
<p>第一次结果：</p> 
<blockquote> 
 <p>[hongxin@VM-8-2-centos 2023-3-29]$ ./shm_server <br> key: 0x660110c2<br> shmid: 1<br> [hongxin@VM-8-2-centos 2023-3-29]$ ./shm_client <br> key: 0x660110c2<br> shmid: 1</p> 
</blockquote> 
<p>但是第二次再运行时就会发生错误，这是什么原因呢？</p> 
<blockquote> 
 <p>[hongxin@VM-8-2-centos 2023-3-29]$ ./shm_server <br> key: 0x660110c2<br> 17:File exists </p> 
</blockquote> 
<p>那我们先观察一下，共享内存端ipcs -m（共享内存）/-q（消息队列）/-s（信号量）</p> 
<blockquote> 
 <p>[hongxin@VM-8-2-centos 2023-3-29]$ ipcs -m</p> 
 <p>------ Shared Memory Segments --------<br> key                shmid      owner      perms      bytes      nattch     status      <br> 0x660106d4       0        hongxin        0              4096       0                       <br> 0x660110c2      1          hongxin    600            4097       0    </p> 
</blockquote> 
<p>通过观察我们发现，<u>共享内存的生命周期是随操作系统的，而不是随进程</u>。换句说，退出进程时共享内存还在存在，只有关机重启时才能结束共享内存。但是我们可以通过指令来关闭共享内存ipcsm -m shmid,或者通过调用函数接口。</p> 
<blockquote> 
 <p>[hongxin@VM-8-2-centos 2023-3-29]$ ipcrm -m 0<br> [hongxin@VM-8-2-centos 2023-3-29]$ ipcs -m</p> 
 <p>------ Shared Memory Segments --------<br> key        shmid      owner      perms      bytes      nattch     status  </p> 
</blockquote> 
<p>通过调用shmctl 函数接口删除共享内存 </p> 
<pre><code>void delShm(int shmid)
{
    if(shmctl(shmid,IPC_RMID,nullptr))
    {
        std::cerr &lt;&lt;"shmctl: "&lt;&lt; errno &lt;&lt; ":" &lt;&lt; strerror(errno) &lt;&lt; std::endl;
    }
}</code></pre> 
<p><strong>共享内存的特点</strong></p> 
<p><strong>优点：</strong>所有进程间通信，速度最快的，因为减少了拷贝次数。在同样的代码下，考虑键盘输入和显示器输出共享内存与管道数据拷贝次数。</p> 
<p>管道数据拷贝需要4+（2次）</p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/66/0f/KXEzyqX5_o.png" width="945"> 共享内存数据拷贝需要2+（2次）</p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/3f/31/VeyXVEkU_o.png" width="962"></p> 
<p><strong>缺点：</strong>共享内存不进行同步和互斥操作，没有对数据进行保护。</p> 
<p><strong>共享内存的属性信息</strong></p> 
<p>首先大家肯定知道创建共享内存不单单只是开辟一块内存存储数据，也开辟一块内存，存储它的属性信息。这个过程就是先描述，后组织。如下结构体就是储存共享内存的属性信息（一部分），这是内核级的数据，只能查看不能被修改。</p> 
<blockquote> 
 <p><em>struct shmid_ds {<!-- --><br>                struct ipc_perm shm_perm;    /* Ownership and permissions */<br>                size_t          shm_segsz;   /* Size of segment (bytes) */<br>                time_t          shm_atime;   /* Last attach time */<br>                time_t          shm_dtime;   /* Last detach time */<br>                time_t          shm_ctime;   /* Last change time */<br>                pid_t           shm_cpid;    /* PID of creator */<br>                pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */<br>                shmatt_t        shm_nattch;  /* No. of current attaches */<br>                ...<br>            };</em></p> 
</blockquote> 
<p>仔细观察发现为什么没有key？key被封装在结构体struct ipc_perm shm_perm中。</p> 
<blockquote> 
 <p><em> struct ipc_perm {<!-- --><br>                key_t          __key;    /* Key supplied to shmget(2) */<br>                uid_t          uid;      /* Effective UID of owner */<br>                gid_t          gid;      /* Effective GID of owner */<br>                uid_t          cuid;     /* Effective UID of creator */<br>                gid_t          cgid;     /* Effective GID of creator */<br>                unsigned short mode;     /* Permissions + SHM_DEST and<br>                                            SHM_LOCKED flags */<br>                unsigned short __seq;    /* Sequence number */<br>            }</em>;</p> 
</blockquote> 
<h2>system V消息队列 （了解） </h2> 
<p>在消息队列中， 进程A可以读写，进程B也可以读写。他们通过type类型进行区分，例如：当type==0时，可以说明是A进程写入，此时A进程就不读取type==0的数据，相反就读取type==1的数据。B进程的type为1时，就只读取为0的数据即可。这样就可以实现进程间通信。</p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/48/81/DsKXqqjm_o.png" width="1196"></p> 
<p>创建消息队列  msgget</p> 
<blockquote> 
 <p><em>       #include &lt;sys/types.h&gt;<br>        #include &lt;sys/ipc.h&gt;<br>        #include &lt;sys/msg.h&gt;</em></p> 
 <p><em>       int msgget(key_t key, int msgflg);</em></p> 
</blockquote> 
<p>去掉消息队列 msgctl</p> 
<blockquote> 
 <p><em>       #include &lt;sys/types.h&gt;<br>        #include &lt;sys/ipc.h&gt;<br>        #include &lt;sys/msg.h&gt;</em></p> 
 <p><em>       int msgctl(int msqid, int cmd, struct msqid_ds *buf);</em></p> 
</blockquote> 
<p>向消息队列发送消息   msgsnd</p> 
<blockquote> 
 <p><em>       #include &lt;sys/types.h&gt;<br>        #include &lt;sys/ipc.h&gt;<br>        #include &lt;sys/msg.h&gt;</em></p> 
 <p><em>       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</em></p> 
</blockquote> 
<p>接收消息队列的消息 msgrcv</p> 
<blockquote> 
 <p><em>        ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);</em></p> 
</blockquote> 
<p>消息队列提供了一个从一个进程向另外一个进程发送一块数据的方法每个数据块都被认为是有一个类型，接收者进程接收的数据块可以有不同的类型值特性方面IPC资源必须删除，否则不会自动清除，除非重启，所以system V IPC资源的生命周期随内核。</p> 
<h2>system V信号量（了解）</h2> 
<h3>Ⅰ信号量的理解</h3> 
<p><strong>什么是信号量？</strong></p> 
<p>        <em>本质是一个计数器，通常用来表示公共资源中资源数量多少问题的。</em></p> 
<p>如何理解这句话？理解这句话的前提是理解：公共资源是什么？被保护的公共资源和为被保护的公共资源又是什么？如果没有保护公共资源会出现问题吗？保护起来的公共资源又叫什么？如何来保护公共资源呢？</p> 
<p><strong>公共资源：</strong>可以被多个进程同时访问的资源。（相信大家都能理解）</p> 
<p><strong>访问没有保护公共资源：</strong>会出现数据不一致的问题。</p> 
<p>        因为在进程间通信时，进程都是独立，为了能让不同的进程访问同一资源，这时候就提出了共享资源这一方法，但是提出这一方法后，又出现了新的问题，就是数据不一致的，何为数据不一致：当进程A在读取时，进程B还在写入，当A进程读取时x=10，但进程B在写入时，将x=10修改成x=20；这个时候内存中的数据是x=20，但打印出的数据却是x10，此时就出现数据不一致。</p> 
<p><strong>将被保护公共资源叫作：</strong>临界资源，有大部分资源是独立的。</p> 
<p><strong>资源：</strong>内存，文件网络等。</p> 
<p><strong>该进程对对应代码访问这部分临界资源</strong>：临界区；相反，非临界区。</p> 
<p><strong>如何保护共享文件</strong>：互斥与同步</p> 
<p>        互斥：两个或者多个进程不能同时访问一组共享变量的临界区域，否则可能发生与时间有关的错误，这种现象被称为进程互斥。也就是说，一个进程正在访问临界资源，那么另一个访问该资源的进程就必须等待。</p> 
<p><strong>原子性：</strong>在两态情况下，要么不做，做必须做完。</p> 
<p>        举例： 在生活中，微信转账；比如给朋友转账100块，不可能说先转5块，然后再依次转到100块。这样是不现实，我们还害怕钱的丢失。鹅厂的处理就是，要么成功转账100块，要么出问题就不转账。   </p> 
<h3>Ⅱ为什么要有信号量？</h3> 
<p>在特定的场景应用下，比如买票。信号量就好比是票的数量。</p> 
<p>实例：</p> 
<p>        比如我们去电影院，肯定是需要买票的。买票的本质就是对放映厅中的座位进行预订机制。这个时候就可以把这个座位看做是共享资源（每个人都可以买票）。当我们想要获得这种资源时，我们就需要去预订它。预订它时，就需要控制好它。当票有100份时，我们用计数器count=100，当买一份票时，--count。如果count==0时，票卖完了。</p> 
<p>如果当count==1时，代表是共享资源作为一个整体。</p> 
<p>共享资源：</p> 
<p>        1.作为一个整体使用（一台电脑，需要整体使用）</p> 
<p>        2.划分成为一个一个的资源子部分（一箱书，需要一本一本去看）</p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/6d/08/3JyiY222_o.png" width="1200">这里其实就知道为什么需要有信号量了，因为在这里信号量对公共资源能起到保护作用。所有的进程在访问公共资源之前，都必须先申请访问信号量，所有进程必须先看到同一个信号，故此信号量本身就是公共资源。</p> 
<p>信号量本身都是公共资源，所有信号量也应该保证自己的安全，如何保证，就可以在++或者--操作的时候保证其具有原子性！</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/0c/02/vP6YklZR_o.png" width="780"></p> 
<p><strong>获取信号量 semget</strong></p> 
<blockquote> 
 <p><em>       #include &lt;sys/types.h&gt;<br>        #include &lt;sys/ipc.h&gt;<br>        #include &lt;sys/sem.h&gt;</em></p> 
 <p><em>       int semget(key_t key, int nsems, int semflg);</em></p> 
</blockquote> 
<p><strong>删除信号量  semctl</strong></p> 
<blockquote> 
 <p>       #include &lt;sys/types.h&gt;<br>        #include &lt;sys/ipc.h&gt;<br>        #include &lt;sys/sem.h&gt;</p> 
 <p>       int semctl(int semid, int semnum, int cmd, ...);</p> 
</blockquote> 
<p><strong>对信号量进行操作 semop</strong></p> 
<blockquote> 
 <p>       int semop(int semid, struct sembuf *sops, unsigned nsops);</p> 
</blockquote> 
<p>system v标准的进程间通信：共享内存，消息队列，信号量他们的接口的设计，结构的设置都遵守的同一标准，他们都是同一范畴下的。在内核数据结构中都是以下面形式构建的：</p> 
<blockquote> 
 <p><em>struct shmid_ds / smgid_ds / semid_ds</em></p> 
 <p><em>{<!-- --></em></p> 
 <p><em>         struct ipc_perm shm_perm; / struct ipc_perm smg_perm; </em></p> 
 <p><em>        /  struct ipc_perm sem_perm;</em></p> 
 <p><em>        .........................</em></p> 
 <p><em>        ........................</em></p> 
 <p><em>}</em></p> 
 <p></p> 
 <p><em>         struct ipc_perm {<!-- --><br>                key_t          __key;    /* Key supplied to shmget(2) */</em></p> 
 <p><em>                ....................</em></p> 
 <p><em>                ....................</em></p> 
 <p><em>        }</em></p> 
</blockquote> 
<p>  ☺  [ 作者 ]   <em>includeevey</em></p> 
<p> ?  [ 日期 ]   <em>2023 / 4/ 1 </em><br>  ?  [ 声明 ]   <em>到这里就该说再见了，若本文有错误和不准确之处，恳望读者批评指正！<br>                     有则改之无则加勉！若认为文章写的不错，一键三连加关注！</em><br> ————————————————<br><img alt="" height="128" src="https://images2.imgbox.com/36/f2/xus6MoZt_o.png" width="128"><img alt="" height="128" src="https://images2.imgbox.com/36/f2/xus6MoZt_o.png" width="128"><img alt="" height="128" src="https://images2.imgbox.com/36/f2/xus6MoZt_o.png" width="128"><img alt="" height="128" src="https://images2.imgbox.com/36/f2/xus6MoZt_o.png" width="128"><img alt="" height="128" src="https://images2.imgbox.com/36/f2/xus6MoZt_o.png" width="128"><img alt="" height="128" src="https://images2.imgbox.com/36/f2/xus6MoZt_o.png" width="128"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>