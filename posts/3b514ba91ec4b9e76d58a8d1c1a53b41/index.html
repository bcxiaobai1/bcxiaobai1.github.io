<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>嵌入式八股文汇总 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式八股文汇总</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="1CC_1"></a>1、C/C++</h1> 
<h2>
<a id="11__3"></a>1.1 关键字</h2> 
<p>（参考”嵌入式及Linux那些事“以及众多帖子汇总而成）</p> 
<h3>
<a id="volatile_5"></a>volatile</h3> 
<p>​ 当声明指向设备寄存器的指针时一定要用volatile，它会告诉编译器不要对存储在这个地<br> 址的数据进行假设。</p> 
<p>​ 中断服务程序中修改的供其他程序检测的变量。 中断中直接从变量地址中读取数据，而不是从寄存器中读取。</p> 
<p>​ 多线程应用中被几个任务共享的变量。</p> 
<h3>
<a id="static_14"></a>static</h3> 
<p>​ 1、函数体内的变量，这个变量只被声明一次。</p> 
<p>​ 2、在模块内的变量，表示只能被模块内函数使用，不能被模块外函数访问，表示<strong>本地全局变量</strong></p> 
<p>​ 3、模块内的函数，限制在模块内使用，同上。</p> 
<h3>
<a id="extern_22"></a>extern</h3> 
<p><strong>1、引用同一文件变量</strong></p> 
<p>使用在声明之前时，可以使用关键字extern，让声明在程序任意位置。</p> 
<p><strong>2、引用另一个文件中的变量</strong></p> 
<p>extern可以引用其他文件中的全局变量，而且extern只需要指明数据类型和</p> 
<p>extern int num=4; 这样不行。</p> 
<p><strong>3、引用另一个文件中的函数</strong></p> 
<p>可以不用包含头文件引用函数。</p> 
<h3>
<a id="newdelete_mallocfree_38"></a>new/delete malloc/free</h3> 
<p>​ 1、new/delete是操作符，malloc/free是库函数</p> 
<p>​ 2、new/delete可以调用构造函数/析构函数，m/f 只是分配内存。</p> 
<h3>
<a id="struct__union_44"></a>struct 和 union区别</h3> 
<p>​ 1、联合体公用一块地址空间，联合体变量长度等于最长的成员的长度</p> 
<p>​ 2、对不同成员赋值，会将其他成员重写。</p> 
<h3>
<a id="const_50"></a>const</h3> 
<p>​ 1、定义变量为常量</p> 
<p>​ 2、修饰参数为常量</p> 
<p>​ 3、修饰返回值为常量</p> 
<p>总结：只读</p> 
<h3>
<a id="sizeofstrlen_60"></a>sizeof和strlen</h3> 
<p>​ 1、sizeof是运算符，strlen是函数</p> 
<p>​ 2、sizeof可以用类型、函数作为参数，strlen只能计算char*，还必须以/0结尾</p> 
<p>​ 3、sizeof编译的时候计算，strlen是运行期计算，表示字符串长度，不是内存大小。</p> 
<h3>
<a id="typedef_define_68"></a>typedef和 define</h3> 
<p>1、都是替对象去一个别名，增强程序的可读性</p> 
<p>2、define为预处理指令，不做正确性检查，只有带入之后才能发现</p> 
<p>3、typedef用来定义类型别名，不止包含内部类型还包含自定义类型（与机器无关），方便记忆</p> 
<p>4、define不仅可以给类型取别名，还能定义常量、变量、编译开关。</p> 
<p>5、define没有作用域限制，typedef有。</p> 
<h3>
<a id="_define_const__82"></a># define还是 const ，谁定义常量最好</h3> 
<p>1、define只是文本替换，声明周期止于编译期，不分配内存空间，存在于代码段。const常量存在于数据段，堆栈中分配了空间。</p> 
<p>2、const有数据类型，编译器可以对const进行安全检查。</p> 
<p>3、const有保护常量不被修改的作用，提高程序的健壮性。</p> 
<p>总结：一般倾向于用const定义常量</p> 
<h2>
<a id="12__92"></a>1.2 内存</h2> 
<h3>
<a id="C_94"></a>C语言内存分配方式</h3> 
<p>1、静态储存区分配</p> 
<p>2、栈上分配</p> 
<p>3、堆上分配</p> 
<h3>
<a id="C_102"></a>C++内存管理是怎样的</h3> 
<p>分为代码段、数据段、BSS段、堆区、栈区、文件映射区</p> 
<p>代码段：分为只读区和文本区，只读取储存字符串常量，文本区储存机器代码。</p> 
<p>数据段：储存以及初始化的全局变量和静态变量</p> 
<p>BSS段：储存未初始化的全局变量和静态变量，以及初始化为0的全局和静态。</p> 
<p>堆区：手动分配的内存</p> 
<p>栈：局部变量参数返回值等</p> 
<p>映射区：储存动态链接库，mmap函数的文件映射</p> 
<h3>
<a id="_118"></a>堆和栈的区别</h3> 
<p>1、申请方式。 栈为操作系统自动分配/释放，堆为手动</p> 
<p>2、申请大小，栈空间有限，向低地址拓展的连续区域，堆是向高地址拓展的不连续区域，链表储存的空闲地址。</p> 
<p>3、申请效率，栈是系统自动分配，速度快，不可控。堆是由new分配，速度比较慢，容易产生内存碎片。</p> 
<h3>
<a id="_126"></a>栈的作用</h3> 
<p>1、储存临时变量</p> 
<p>2、多线程编程的基础。每个线程至少有一个栈用来存储临时变量和返回的值。</p> 
<h3>
<a id="_132"></a>内存泄漏</h3> 
<p>申请了没有释放，由程序申请的一块内存，没有任何指针指向它，这个内存就泄露了。</p> 
<h3>
<a id="_136"></a>避免内存泄漏方法</h3> 
<p>1、分配的内存以链表管理，使用完毕后从链表删除，程序结束的时候检查链表</p> 
<p>2、良好的编程习惯，在设计内存的程序段，检验出内存泄漏，使用了内存分配的函数，使用完毕后将使用的相应函数释放掉</p> 
<p>3、smart pointer</p> 
<h2>
<a id="_144"></a>指针</h2> 
<h3>
<a id="_146"></a>数组指针和指针数组</h3> 
<p>int （*p）[20]; 数组指针，本质是一个指针，指向一个数组</p> 
<p>int *p[20]; 指针数组，本质是一个数组，里面装的是指针。</p> 
<h3>
<a id="_152"></a>函数指针和指针函数</h3> 
<p>1、函数指针 int（*p）(int,int);本身是一个指针，指向一个函数的地址</p> 
<p>2、指针函数 int *p(int,int); 指针函数表示一个函数，返回数是指针。</p> 
<h3>
<a id="_158"></a>数组名和指针区别</h3> 
<p>1、指针保存的是地址，数组保存的是数据，单数组名是第一个元素的地址</p> 
<p>2、指针间接访问，数组直接下标或者偏移量</p> 
<p>3、sizeof 有区别，指针为指针大小，数组为全体数据大小</p> 
<h3>
<a id="_166"></a>指针常量，常量指针、指向常量的指针</h3> 
<p>1、int *const p 指向地址不变，地址值可变</p> 
<p>2 int const *p 指向地址可变，地址值不能边</p> 
<p>3、const int * const p 都不能变</p> 
<h3>
<a id="_174"></a>指针与引用区别</h3> 
<p>1、都是地址，指针是地址，应用是别名</p> 
<p>2、引用本质是指针常量，对象不变，对象的值可变</p> 
<p>3、++不同，指针是地址自增，引用是对象自增</p> 
<p>4、指针需要解引用</p> 
<p>5、指针可为空，引用不行</p> 
<p>6、sizeof不同 一个是指针大小一个是对象大小</p> 
<h3>
<a id="_188"></a>野指针</h3> 
<p>1、指向不可用内存的指针，指针被创建时如果没有初始化就是野指针</p> 
<p>2、指针被free、delete时没有指向NULL就是野指针</p> 
<p>3、指针超出了变量的地址范围</p> 
<h3>
<a id="_196"></a>智能指针</h3> 
<p>C++智能指针是指一个类，用来存储指针</p> 
<h2>
<a id="13__200"></a>1.3 预处理</h2> 
<h3>
<a id="error_202"></a>预处理器标识#error的目的是什么？</h3> 
<p>1、遇到#error就会生成一个编译错误提示信息，并停止编译</p> 
<h3>
<a id="define_206"></a>define声明一年多少秒</h3> 
<p>#define SECOND_OF_PER_YEAR (365<em>24</em>60*60)UL</p> 
<h3>
<a id="include____include_210"></a>#include"" 和 include&lt;&gt;区别</h3> 
<p>&lt;&gt;号先搜索标准库搜索系统文件比较快，“”号先搜索工作路径搜索自定义文件比较快</p> 
<h3>
<a id="_214"></a>头文件作用</h3> 
<p>1、通过文件调用库功能，源码保护</p> 
<p>2、头文件加强类型安全检查，编译器报错</p> 
<h3>
<a id="_220"></a>头文件定义静态变量</h3> 
<p>1、资源浪费，每个头文件都会单独存在一个静态变量</p> 
<h3>
<a id="11000_224"></a>不使用流程控制语句，打印1~1000数字</h3> 
<pre><code>#include&lt;stdio.h&gt;
#define A(x) x;x;x;x;x;x;x;x;x;x;
int main()
{
	int n=1;
	A(A(A(printf("%d",n++))));
	return 0;
}


</code></pre> 
<h2>
<a id="14__239"></a>1.4 变量</h2> 
<h3>
<a id="_241"></a>全局变量和静态变量</h3> 
<p>1、全局变量作用域为程序块，局部变量为当前函数</p> 
<p>2、全局变量储存在静态区，后者为栈</p> 
<p>3、全局变量生命周期为主函数，局部变量生命周期在局部函数中，甚至循环体内</p> 
<h2>
<a id="15__251"></a>1.5 函数</h2> 
<h3>
<a id="main_253"></a>写个函数在main函数执行前执行</h3> 
<p>1、attribute可以设置函数属性</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>destructor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is function %sn"</span><span class="token punctuation">,</span><span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is function %sn"</span><span class="token punctuation">,</span><span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is function %sn"</span><span class="token punctuation">,</span><span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出结果</span>
<span class="token comment">// this is function before</span>
<span class="token comment">// this is function main</span>
<span class="token comment">// this is function after</span>
</code></pre> 
<h3>
<a id="_279"></a>为什么析构函数必须是虚函数</h3> 
<p>1、基类指针指向子类时，释放基类指针也能释放掉子类的空间，防止内存泄漏。</p> 
<p>2、最好是作为父类的类的析构函数作为虚函数</p> 
<h3>
<a id="C_285"></a>为什么C++默认的析构函数不是虚函数？</h3> 
<p>1、虚函数有额外的虚函数表和虚指针表，占用额外的内存，对于那些不会被继承的类当然也不需要虚函数作为析构函数。</p> 
<h3>
<a id="_289"></a>静态函数和虚函数的区别？</h3> 
<p>1、静态函数编译时确定运行时机</p> 
<p>2、虚函数运行时动态绑定，并且使用虚函数表，内存开销增加</p> 
<h3>
<a id="_295"></a>重载与覆盖</h3> 
<p>1、覆盖是子类和父类的关系，垂直关系，重载是一个类之间的关系，水平关系</p> 
<p>2、覆盖一对一，重载多个方法</p> 
<p>3、覆盖由对象类型决定，重载根据调用的参数表决定</p> 
<h3>
<a id="_303"></a>虚函数表实现多态方法</h3> 
<p><strong>原理</strong>：<br> 虚函数表示一个类的地址表，子类创建时，按照函数声明吮吸会将函数的地址存在虚函数表中。子类重写父类虚函数的时候，父类虚函数表中的位置会被子类虚函数地址覆盖。</p> 
<h3>
<a id="C_308"></a>C语言函数调用方法</h3> 
<p>1、使用栈来支持函数调用操作，栈被用来传递参数，返回值，局部变量等。</p> 
<p>2、函数调用主要操作栈帧结构</p> 
<h3>
<a id="select_314"></a>select函数</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxfdp<span class="token punctuation">,</span>fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span>fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>fd_set <span class="token operator">*</span>errorfds<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="fork_wait_exec_320"></a>fork wait exec函数</h3> 
<p>1、附近产生的子进程使用fork拷贝出一个父进程的副本</p> 
<h3>
<a id="_324"></a>数组的下标可以为负数吗？</h3> 
<p>可以，数组下标指地址偏移量，根据偏移量能定位得到目标地址。</p> 
<h3>
<a id="inline_328"></a>inline函数和宏定义的区别</h3> 
<p>1、内联函数在编译时展开，而宏在预编译时展开。</p> 
<p>2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</p> 
<p>3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</p> 
<p>4、宏不是函数，而inline是函数。</p> 
<p>5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</p> 
<p>6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</p> 
<p>7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p> 
<h3>
<a id="_344"></a>宏和函数的优缺点</h3> 
<p>1、函数调用时，先求出实参表达式的值，然后带入形参。而使用带参数的函数只是进行简单的字符替换</p> 
<p>2、函数调用实在程序运行时处理的，分配的临时的内存单元；而宏展开则是在编译时进行的，在展开时不分配i内存单元，不进行值的传递，也没有"返回值的概念"</p> 
<p>3、函数实参形参都要定义类型，二者要求一致 ，宏不存在类型问题，宏没有类型，宏的参数只是一个符号代表，展开时代入指定的字符就行，宏定义时字串可以是任意内心的数据</p> 
<p>4、函数只可以得到一个返回值，宏可以设法得到多个</p> 
<p>5、使用宏次数多时，展开后源程序长，每次展开都使程序增长，而函数调用不使源程序变长。</p> 
<p>6、宏的替换不占用时间，只占用编译时间，函数调用占用运行时间。</p> 
<p><strong>简单回答：宏由编译计算，增加编译时间，函数运行的时候计算，增加运行时间；函数的返回值入口参数有数据类型，宏只是简单的符号加减。</strong></p> 
<h3>
<a id="ASSERT_360"></a>ASSERT（）作用</h3> 
<p>ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。</p> 
<h3>
<a id="strcpymemcpy_364"></a>strcpy()和memcpy()的区别</h3> 
<p>1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。<br> 2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符""才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。<br> 3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p> 
<h2>
<a id="16__370"></a>1.6 位操作</h2> 
<h3>
<a id="1_372"></a>求解整型类二进制表示1的个数</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> countx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        countx<span class="token operator">++</span><span class="token punctuation">;</span>
        x <span class="token operator">=</span> x<span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">return</span> countx<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="0_387"></a>求解整型类二进制表示0的个数</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">CountZeroBit</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            num <span class="token operator">|=</span> <span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//算法转换</span>
        <span class="token punctuation">}</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在<br> 以上两个操作中，要保持其它位不变。</p> 
<pre><code>void clearbit3(int a)
{
	a&amp;=~(1&lt;&lt;3);
}
void setbit3(int a)
{
	a|=1&lt;&lt;3;
}

</code></pre> 
<h2>
<a id="17__419"></a>1.7 容器与算法</h2> 
<h3>
<a id="mapset_421"></a>map与set区别和底层实现</h3> 
<p>1、底层实现都是红黑树</p> 
<p>2、map是键值对，关键字起到索引作用，值表示与索引相关联的数据，set是关键字的集合并且每个元素只包含一个关键字。</p> 
<p>3、set迭代器是const不能修改元素值，map允许修改value不能修改key</p> 
<p>4、map支持下标操作，set不支持，map可以用key作为下标，set用find</p> 
<h3>
<a id="STLallocator_431"></a>STL的allocator有什么作用？</h3> 
<p>1、内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</p> 
<p>2、提升内存管理效率， STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。</p> 
<h3>
<a id="STL_441"></a>STL迭代器如何删除元素？</h3> 
<p>对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边<br> 每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；<br> 对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，<br> 删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即<br> 可。<br> 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上<br> 面两种正确的方法都可以使用</p> 
<h3>
<a id="STLmapunordered_map_451"></a>STL中map与unordered_map有什么区别？</h3> 
<p>1、map底层红黑树实现，unordered_map采用hash表实现’</p> 
<p>2、map中序遍历有序，un——map无序</p> 
<h3>
<a id="vectorlist_457"></a>vector和list的区别是什么</h3> 
<p>1、vector为数组实现，list为双向链表</p> 
<p>2、vector支持随机访问，list不行</p> 
<p>3、vector顺序储存，list随机</p> 
<p>4、vector一次性分配内存，不够才二倍扩容，list一个个分配</p> 
<p>5、vector随机访问性能好，插入删除比较慢，list反之</p> 
<h3>
<a id="_471"></a>迭代器与指针</h3> 
<p>1、迭代器又名游标模式，提供一种顺序访问一个聚合对象中各个元素，但又不暴露该对象的内部表示。</p> 
<p>2、迭代器是类模板，表现得象指针，重载了指针一些操作，封装了指针，指针的++只是递增地址，但是不能对list生效，迭代器可以。</p> 
<p>3、迭代器有着更良好的用法begin，end等不用担心越界</p> 
<h3>
<a id="STLresizereserve_479"></a>STL里resize和reserve的区别是什么？</h3> 
<p>1、resize改变当前容器内含有元素的数量，会新增元素0，reserve只是增加空间，不新增元素。</p> 
<h2>
<a id="18__485"></a>1.8 类和数据抽象</h2> 
<h3>
<a id="c_487"></a>c++类成员访问权限</h3> 
<p>1、C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限</p> 
<p>2、类内随便访问，类外通过对象访问，且只能访问public成员</p> 
<h3>
<a id="_493"></a>引用与指针的区别</h3> 
<p>1、引用必须被初始化，指针不必。</p> 
<p>2、引用初始化以后不能被改变，指针可以改变所指的对象。</p> 
<p>3、不存在指向空值的引用，但是存在指向空值的指针。</p> 
<h3>
<a id="structclass_501"></a>struct与class区别</h3> 
<p>1、c++中两者都可以定义类，但是struct没有权限，默认public</p> 
<h3>
<a id="_505"></a>面对对象和泛型编程</h3> 
<p>1、面对对象是一种程序设计思想，把对象作为程序的基本单元，一个对象包括了数据和操作数据的函数</p> 
<p>2、泛型编程让类型参数化，使程序可以从逻辑功能上抽象。吧处理的对象当成参数来传递</p> 
<h3>
<a id="_511"></a>右值引用，和左值的区别。</h3> 
<ol>
<li>左值可以寻址，而右值不可以。</li>
<li>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</li>
<li>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。C++的类和C里面的struct有什么区别？</li>
</ol> 
<h3>
<a id="_virtual__517"></a>析构函数可以为 virtual 型，构造函数则不能，为什么？</h3> 
<p>1、虚函数主要是用作多态，如果构造函数也用了，那么派生类必须在初始化列表给基类参数初始化</p> 
<p>2、构造函数运行的时候对象的动态类型还不完整，没法确定没所以不能动态绑定。</p> 
<h3>
<a id="CCstruct_523"></a>C++的类和C里面的struct有什么区别？</h3> 
<p>c++中的类具有成员保护功能，并且具有继承，多态这类特点，而c里的struct没有<br> c里面的struct没有成员函数,不能继承,派生等等.</p> 
<h3>
<a id="C_528"></a>C++中空类默认产生哪些类成员函数？</h3> 
<p>1、构造函数</p> 
<p>2、拷贝构造</p> 
<p>3、析构函数</p> 
<p>4、赋值运算符重载函数</p> 
<p>5、取值运算符重载函数</p> 
<p>6、const取址运算符重载函数</p> 
<h3>
<a id="_542"></a>静态成员函数与非静态成员函数的区别</h3> 
<p>前者没有 this 指针,后者有 this 指针。<br> 静态成员函数只要用来访问静态数据成员,而不访问非静态成员</p> 
<h2>
<a id="19__547"></a>1.9 面对对象</h2> 
<h3>
<a id="_549"></a>面向对象和面向过程有什么区别？</h3> 
<p><strong>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</strong></p> 
<p>1、面对对象以对象为中心，面向过程以过程为中心</p> 
<p>2、面对对象把代码封装成一个整体，其他对象不能直接修改其数据。面向过程直接使用程序来处理数据，各模块存在控制与被控制的关系。</p> 
<p>3、面对对象是将问题分为不同的对象，给予对象赋予属性和行为。面对过程则是将事件分为不同的步骤，按照步骤完成编程。</p> 
<h3>
<a id="_559"></a>面对对象的基本特点</h3> 
<p>1、封装： 把过程和数据封装起来，只有定义的接口才能调用</p> 
<p>2、继承：子类继承父类的功能</p> 
<p>3、多态：不同的对象对从父类继承的同一动作做出不同的反应，</p> 
<p>4、抽象:不打算了解问题全部，只关注当前目标。过程抽象和数据抽象。过程抽象是指任何操作都被当成实体看待，不在乎它是不是由其他子函数完成。</p> 
<h3>
<a id="_569"></a>什么是深拷贝？什么是浅拷贝？</h3> 
<p>1、深拷贝复制一份</p> 
<p>2、浅拷贝哟与可能共享成员变量</p> 
<h3>
<a id="_575"></a>友元</h3> 
<p>1、友元函数：普通函数对一个访问某个类中的私有或者保护成员</p> 
<p>2、友元类：类A中的成员函数访问类B中的私有或保护成员。</p> 
<h3>
<a id="_583"></a>初始化列表和构造函数初始化的区别？</h3> 
<pre><code class="prism language-c++">Example::Example() : ival(0), dval(0.0) {} //初始化列表的构造函数
Example::Example()   //构造函数
{   
ival = 0;   
dval = 0.0;
}
</code></pre> 
<p>结果是一样的，使用初始化列表的构造函数表示 <strong>初始化</strong>类的成员，使用初始化列表的构造函数是对类成员的赋值，而不是初始化。所以一下情况需要对成员初始化所以必须用初始化列表的方法。</p> 
<p>1、成员类型为没有默认构造函数的类</p> 
<p>2、const成员或引用类型的成员</p> 
<h3>
<a id="_600"></a>类的成员变量的初始化顺序是什么？</h3> 
<p>​ 1、成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。</p> 
<p>​ 2、不使用初始化列表的话就与构造函数有关。</p> 
<h3>
<a id="Publicprotectedprivate_606"></a>Public继承、protected继承、private继承的区别？</h3> 
<p>1、public继承就是公有继承完还是公有，保护还是保护，私有还是私有</p> 
<p>2、protected继承就是公有变保护，保护还是保护，私有还是私有</p> 
<p>3、private继承就是所有变成私有</p> 
<h2>
<a id="110__614"></a>1.10 虚函数</h2> 
<h3>
<a id="_616"></a>虚函数注意内容</h3> 
<p>1、只需要在声明的函数体中使用关键字virtual将函数声明为虚函数，定义中不需要</p> 
<p>2、基类某一成员为虚函数之后，派生类中的同名函数自动成为虚函数</p> 
<p>3、非类的成员函数不能定义为虚函数，全局函数以及类的成员函数和构造函数也不能定义为虚函数，可以将析构函数定义为虚函数</p> 
<h3>
<a id="_624"></a>什么函数不能声明为虚函数</h3> 
<p>主要有：普通函数（非成员函数）；静态成员函数；类联成员函数；构造函数：友元函数。</p> 
<h2>
<a id="111_628"></a>1.11数据结构</h2> 
<h3>
<a id="_630"></a>链表和数组的区别</h3> 
<ol>
<li> <p>数组在内存中栈上按<strong>顺序存储</strong>的，而链表是在堆上<strong>随机存储</strong>的。</p> </li>
<li> <p>要访问数组中的元素可以按下标索引来访问，速度比较快，如果对他进行插入操作的话，就得移动很多元素，所以<strong>对数组进行插入操作效率很低</strong>. 由于连表是随机存储的，链表在插入，删除操作上有<strong>很高的效率</strong>（相对数组）</p> </li>
<li> <p>如果要访问链表中的某个元素的话，那就得从链表的头逐个遍历，直到找到所需要的元素为止，所以<strong>链表的随机访问的效率就比数组要低</strong> 。</p> </li>
</ol> 
<h1>
<a id="2ARM_640"></a>2、ARM体系与架构</h1> 
<h2>
<a id="21__642"></a>2.1 硬件基础</h2> 
<h3>
<a id="NAND_FLASH_NOR_FLASH_644"></a>NAND FLASH 和NOR FLASH异同？</h3> 
<p>类别 读 写 擦除 可靠性 容量 用途 价格</p> 
<p>NOR 快 慢 非常慢 比较高 小 保存代码 高</p> 
<p>NAND 快 快 快 低 大 保存数据 低</p> 
<h3>
<a id="CPUMPUMCUSOCSOPC_654"></a>CPU,MPU,MCU,SOC,SOPC联系与差别？</h3> 
<p>1、CPU：是一台计算机的运算核心和控制核心</p> 
<p>2、MPU: 微处理器稍强的CPU</p> 
<p>3、MCU：将计算机的CPU、RAM、ROM、定时计数器和多种I/O接口集成在一片芯片上。</p> 
<p>4、SOC： 系统级芯片不单单是放简单的代码，可以放系统级的代码，也就是说可以运行操作系统</p> 
<h3>
<a id="CPUcachecache_664"></a>CPU中cache的作用？cache的基本组织结构？</h3> 
<p>（1）高速缓冲存储器Cache是位于CPU与内存之间的临时存储器，它的容量比内存小但交换速度快。</p> 
<p>在Cache中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可避开内存直接从Cache中调用，从而加快读取速度。由此可见，在CPU中加入Cache是一种高效的解决方案，这样整个内存储器（Cache+内存）就变成了既有Cache的高速度，又有内存的大容量的存储系统了。<br> （2）全相连映射，直接映射，组相连映射</p> 
<h3>
<a id="_671"></a>交叉编译</h3> 
<p>​ 在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。</p> 
<h3>
<a id="CC_675"></a>C/C++的编译包括几个部分</h3> 
<p>1、预编译：预处理器对c程序进行一些预处理工作，例如对宏定义的变量进行替换；</p> 
<p>​ 1）将所有的#define删除，并展开所有的宏定义；</p> 
<p>​ 2）处理所有的预编译指令，例如：#if,#elif,#else,#endif;</p> 
<p>​ 3）处理#include预编译指令，将被包含的文件插入到预编译指令的位置；</p> 
<p>​ 4）添加行号信息文件名信息，便于调试；</p> 
<p>​ 5）删除所有的注释：// /**/;</p> 
<p>​ 6）保留所有的#pragma编译指令，因为在编写程序的时候，我们经常要用到#pragma指令来设定编译器的状态或者是指示编译器完成一些特定的动作；</p> 
<p>​ 最后生成.i文件；</p> 
<p>​ 总的来说，包括（1）去注释 （2）宏替换 （3）头文件展开 （4）条件编译</p> 
<p>2、编译：编译器将c语言程序翻译成汇编语言程序；</p> 
<p>​ 1）扫描，语法分析，语义分析，源代码优化，目标代码生成，目标代码优化；</p> 
<p>​ 2）生成汇编代码；</p> 
<p>​ 3）汇总符号；</p> 
<p>​ 4）生成.s文件；</p> 
<p>3、汇编：汇编语言通过汇编器编译成可重定位目标程序.o，与之相反称为反汇编；</p> 
<p>​ 1）根据汇编指令和特定平台，把汇编指令翻译成二进制形式；</p> 
<p>​ 2）合并各个section，合并符号表；</p> 
<p>​ 3）生成.o文件；</p> 
<p>4、链接：将目标文件和所需的库函数用链接器进行链接，常见的链接器有Unix；</p> 
<p>​ 1）合并各个.obj文件的section，合并符号表，进行符号解析；</p> 
<p>​ 2）符号地址重定位；</p> 
<p>​ 3）生成可执行文件；</p> 
<h3>
<a id="ROMRAM_721"></a>描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？</h3> 
<p><strong>基于RAM</strong>：</p> 
<p>1、将硬盘或者其介质的代码加载到ram中。</p> 
<p>2、速度快但是可用RAM少，因为自身的空间要存一部分代码</p> 
<p><strong>基于ROM</strong>:</p> 
<p>1、将部分代码搬到RAM中去，所以可用RAM资源比基于RAM的多。</p> 
<h2>
<a id="22__733"></a>2.2 中断与异常</h2> 
<h3>
<a id="_735"></a>中断与异常区别</h3> 
<p>1、中断是指<strong>外部硬件</strong>产生的一个电信号从CPU的中断引脚进入，打断CPU的运行，异常是指<strong>软件运行过程中</strong>发生了一些必须作出处理的事件，CPU自动产生一个陷入来打断CPU的运行。</p> 
<p>2、异常处理的时候要考虑与处理器的时钟同步，异常被称为同步中断</p> 
<h3>
<a id="__741"></a>中断能不能睡眠 为什么？</h3> 
<p>1、一般说中断上下文中不能睡眠,这个中断是指硬件事件发生,触发CPU停止当前活动转而去处理硬件请求.</p> 
<p>2、根据硬件请求响应处理逻辑的实时紧要与否,将整个中断处理过程分为<strong>上半部和下半部</strong>.上半部也就是所谓的硬中断处理逻辑,其要求cpu在收到硬件请求后必须马上处理的事情,比如网卡收到数据包了,把数据包从网卡缓存拷贝到主存(可以由DMA完成,但寄存器的修改以及资源设定还是要由cpu去做)的逻辑就需要cpu立即去做,不做的话,网络新来的数据包就可能丢失.所以这些紧要操作逻辑为硬中断处理.<br> 3、下半部有很多种机制,其中就包括软中断,还有tasklet,workqueue等,软中断只是其中的一种,由于历史的原因,有时候是混淆称呼下半部和软中断的.<br> 4、而可以看到软中断逻辑不属于任何进程,所以才不能睡眠,因为一旦睡眠,cpu切换出去,就切不回来了。</p> 
<p>简单说就是：<strong>唤醒函数针对进程而言的，下半部的中断不属于进程，所以无法被唤醒</strong></p> 
<h3>
<a id="_751"></a>中断的响应执行流程是什么？</h3> 
<p>cpu接受中断-&gt;保存中断上下文跳转到中断处理历程-&gt;执行中断上半部-&gt;执行中断下半 部-&gt;恢复中断上下文。</p> 
<h3>
<a id="_755"></a>写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？</h3> 
<p>1、快进快出，在中断服务函数里尽量快速采集信息。</p> 
<p>2、中断中不能有阻塞操作</p> 
<p>3、中断服务函数注意返回值，使用操作系统定义的宏，而不是自己定义的。</p> 
<p>4、做的事情较多，将这些任务放在后半段tasklet处理。</p> 
<h3>
<a id="_765"></a>中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</h3> 
<p>1、中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。<br> 2、请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。</p> 
<p>3、如一般设备，并且该设备请求cpu的频率比较低，则用中断效率要高一些。主要是看请求频率。</p> 
<h2>
<a id="23__772"></a>2.3 通讯协议</h2> 
<h3>
<a id="_774"></a>异步传输与同步传输？</h3> 
<p>异步传输：是一种典型的基于字节的输入输出，数据按每次一个字节进行传输，其传输速度低。<br> 同步传输：需要外界的时钟信号进行通信，是把数据字节组合起来一起发送，这种组合称之为帧，其传输速度比异步传输快。</p> 
<h3>
<a id="RS232RS485_779"></a>RS232和RS485区别？</h3> 
<ol>
<li>
<strong>传输方式不同</strong>。 RS232采取不平衡传输方式，即所谓单端通讯。 而RS485则采用平衡传输，即差分传输方式。</li>
<li>
<strong>传输距离不同</strong>。RS232适合本地设备之间的通信，传输距离一般不超过20m。而RS485的传输距离<br> 为几十米到上千米。</li>
<li>设备数量。RS232 只允许一对一通信，而RS485 接口在总线上是允许连接多达128个收发器。</li>
<li>
<strong>连接方式</strong>。RS232，规定用电平表示数据，因此线路就是单线路的，用<strong>两根线</strong>才能达到全双工的目的；而RS485， 使用差分电平表示数据，因此，必须用两根线才能达到传输数据的基本要求，要实现全双工，必需用<strong>4根线</strong>。</li>
</ol> 
<h3>
<a id="SPI_787"></a>SPI协议</h3> 
<p>SPI：高速全双工串行总线。</p> 
<p>接口：输出线、输入线、时钟线、片选信号线</p> 
<p>1、片选信号线由高到低是SPI的起始信号 ，从机检测到自己的NSS线起始信号之后就知道自己被选中了，然后由低到高是停止信号。</p> 
<p>2、SPI 使用 MOSI 及 MISO 信号线来传输数据，使用 SCK 信号线进行数据同步。 在时钟线上升沿触发输出，在下降沿被采样。</p> 
<h3>
<a id="IIC_797"></a>IIC协议</h3> 
<p>1、IIC协议是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据,是一个多主机的半双工通信方式</p> 
<p>2、<strong>空闲状态</strong></p> 
<p>SDA与SCL都处于高电平，就是空闲状态。</p> 
<p>2、<strong>起始信号</strong></p> 
<p>时钟线为高，数据线由高到低就是启动信号，<strong>只能由主机发起</strong>空闲状态下才能启动该信号</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HEH6Q7Kx-1669710623167)(C:Users61769AppDataRoamingTyporatypora-user-imagesimage-20220601093452355.png)]</p> 
<p>3、<strong>停止信号</strong></p> 
<p>时钟为高，数据线由低到高就是停止信号</p> 
<p>4、<strong>传输数据格式</strong></p> 
<p>SCL为高就会获取SDA数据值，SDA<strong>在这期间必须稳定</strong></p> 
<p>SCL为低便是SDA电平变化状态，在此期间SDA可以自由变化</p> 
<p>可以主动拉低SCL让IIC进入等待状态知道处理结束再释放SCL数据传输会继续</p> 
<p>5、ACK应答信号</p> 
<p>发送方在第9个时钟脉冲奇迹爱你释放SDA数据，当接收方接收成功时，会输出一个应答信号，低电平有效</p> 
<p>6、写操作</p> 
<p>start信号–设备地址–方向（读、写）。回应（确定这个设备是否存在）–发送数据–回应–发送完之后主芯片发送一个停止信号。</p> 
<p>白色主到从、灰色从到主。</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GWFkECVR-1669710623168)(C:Users61769AppDataRoamingTyporatypora-user-imagesimage-20220601095654891.png)]</p> 
<p>7、读操作</p> 
<p>除了数据需要主到从，其余差不多。</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IMX1TAyk-1669710623169)(C:Users61769AppDataRoamingTyporatypora-user-imagesimage-20220601100048451.png)]</p> 
<h3>
<a id="_845"></a>嵌人式编程中，什么是大端？什么是小端？</h3> 
<p>大端模式：低位字节存在高地址上，高位字节存在低地址上。<br> 小端模式：高位字节存在高地址上，低位字节存在低地址上。</p> 
<pre><code class="prism language-c"><span class="token comment">//第一种</span>
<span class="token keyword">union</span> w<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>c<span class="token punctuation">;</span>
c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>b<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"小端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"大端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//第二种</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x12345678</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">==</span><span class="token number">0x78</span><span class="token punctuation">)</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"小端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"大端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>



</code></pre> 
<h1>
<a id="3Linux_875"></a>3、Linux驱动</h1> 
<h2>
<a id="31__877"></a>3.1 指令</h2> 
<h3>
<a id="Linux_879"></a>Linux指令</h3> 
<p>查看当前进程 ps；</p> 
<p>执行退出 exit；</p> 
<p>查看当前路径 pwd；</p> 
<p>查看目录 ls -a显示所有文件及目录，-l详细列出</p> 
<p>创建目录 mkdir；</p> 
<p>创建文件 vi 、 touch；</p> 
<p>查看文件内容 vi，cat ；</p> 
<p>屏幕输出 echo；</p> 
<h3>
<a id="GCC_897"></a>常用的GCC命令</h3> 
<p>gcc -E test.c -o test.i #把预处理的结果导出到test.i文件</p> 
<p>gcc -S test.i -o test.s #编译器将test.i翻译成汇编语言，并将结果存储在test.s文件中。</p> 
<p>gcc -c test.s -o test.o #将汇编代码编译为目标文件（.o）但不链接</p> 
<p>gcc test.o -o test #将生成的目标文件test.o生成最终的可执行文件test</p> 
<p>gcc test.c -o test #将源文件test.c编译链接为可执行文件test</p> 
<p>gcc test1.c test2.c -o test 多文件编译</p> 
<h3>
<a id="GDB_911"></a>常用的GDB调试指令</h3> 
<p>gcc -g test.c -o test #编译时生成debug有关的程序信 就是说正常编译不能使用GDB</p> 
<p>list 查看源码</p> 
<p>next #单步调试（逐过程，函数直接执行）,简写n<br> step #单步调试（逐语句：跳入自定义函数内部执行）,简写s</p> 
<p>run #运行程序</p> 
<p>break + num #设置第num行 为断点</p> 
<p>continue #继续运行到下一个断点。</p> 
<p>display 追踪具体变量值</p> 
<p>delete breakpoints num #删除第num个断点</p> 
<h3>
<a id="_934"></a>常用的驱动开发指令</h3> 
<p>insmodmodprobe 加载驱动</p> 
<p>rmmod #卸载驱动</p> 
<p>lsmod #查看已有的字符设备信息</p> 
<p>cat /proc/interrupt #查看已有的中断号</p> 
<h3>
<a id="Makefile_944"></a>Makefile</h3> 
<p>经典malefile main包含了input、calcu的头文件</p> 
<pre><code class="prism language-makefile">objects = main.o input.o calcu.o
main: $(objects)
	gcc -o main $(objects)
%.o : %.c
	gcc -c $&lt;
clean:
	rm *.o
	rm main 
</code></pre> 
<h3>
<a id="shell_959"></a>shell相关操作</h3> 
<p>要求</p> 
<p>A、在Linux操作系统启动的时候，自动加载/mnt/test/test程序。<br> B、当test异常退出之后，自动重新启动。<br> C、当test程序重启次数超过100次，自动复位操作系统。<br> 假设你所拥有的资源：<br> A、目标机器是一台具有标准shell的嵌入式计算机，CPU为ARM7 56MB，内存16MB，软件环境基于Linux2.6.11和BusyBox1.2构建。<br> B、当前已有11个用户进程在运行，占用了大部分的CPU时间和内存，你可使用的内存只有2MB左右，CPU时间由系统分派。</p> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>

<span class="token comment">#load *.so that may need</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-r</span> /sbin/ldconfig <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
ldconfig
<span class="token keyword">fi</span>

<span class="token comment">#add the libs PATH that may need</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token string">"/lib"</span>

<span class="token comment">#count is the counter of test started times</span>
<span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">0</span>

<span class="token comment">#main loop</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token number">1</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token keyword">do</span>
<span class="token comment">#add execute property for /mnt/test/test</span>
<span class="token function">chmod</span> +x /mnt/test/test
<span class="token comment">#start test</span>
/mnt/test/test
<span class="token comment">#the running times counter</span>
<span class="token builtin class-name">let</span> <span class="token assign-left variable">count</span><span class="token operator">=</span>count+1
<span class="token builtin class-name">echo</span> <span class="token string">"test running times is <span class="token variable">$count</span>"</span>
<span class="token comment">#Is test running too many times?</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$count</span>"</span> <span class="token parameter variable">-gt</span> <span class="token number">100</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Will reboot because of test running too many times"</span>
<span class="token function">reboot</span>
<span class="token keyword">fi</span>
<span class="token comment">#wait for test stoping...</span>
<span class="token function">sleep</span> <span class="token number">3</span>
<span class="token keyword">done</span>
</code></pre> 
<h2>
<a id="32_uboot_1005"></a>3.2 uboot</h2> 
<h3>
<a id="bootloader_1007"></a>bootloader</h3> 
<p>1、Linux启动需要一个bootloader程序，初始化时钟、中断或者其他外设，然后将Linux内核从flash拷贝到SDRAM中，最后启动Linux内核。</p> 
<p>2、Bootloader就是一小段程序，它在系统上电时开始执行，初始化硬件设各、准备好软件环境，最后调用操作系统内核。</p> 
<h3>
<a id="uboot_1013"></a>uboot启动流程</h3> 
<p>u-boot系统启动流程 ,大多数bootloader都分为<strong>stage1和stage2</strong>两部分, u-boot也不例外。</p> 
<p>依赖于CPU<a href="https://so.csdn.net/so/search?q=%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&amp;spm=1001.2101.3001.7020">体系结构</a>的代码（如设备初始化代码等）通常都放在stage1且可以用汇编语言来实现，而stage2则通常用C语言来实现，这样可以实现复杂的功能，而且有更好的可读性和移植性。</p> 
<p>1、Stage1 start.S代码结构 u-boot的stage1代码通常放在start.S文件中，他用汇编语言写成，其主要代码部分如下</p> 
<p>（1） 定义入口:</p> 
<p>​ 该工作通过修改连接器脚本来完成。</p> 
<p>（2）设置异常向量（Exception Vector）。</p> 
<p>（3）设置CPU的速度、时钟频率及终端控制寄存器。</p> 
<p>（4）初始化内存控制器。</p> 
<p>（5）将ROM中的程序复制到RAM中。</p> 
<p>（6）初始化堆栈。</p> 
<p>（7）转到RAM中执行，该工作可使用指令ldr pc来完成</p> 
<p>2、Stage2</p> 
<p>C语言代码部分 lib_arm/board.c中的start arm boot是C语言开始的函数也是整个启动代码中C语言的主函数，同时还是整个u-boot（armboot）的主函数，该函数只要完成如下操作：</p> 
<p>（1）调用一系列的初始化函数。</p> 
<p>（2）初始化Flash设备。</p> 
<p>（3）初始化系统内存分配函数。</p> 
<p>（4）如果目标系统拥有NAND设备，则初始化NAND设备。</p> 
<p>（5）如果目标系统有显示设备，则初始化该类设备。</p> 
<p>（6）初始化相关网络设备，填写IP、MAC地址等。</p> 
<p>（7）进去命令循环（即整个boot的工作循环），接受用户从串口输入的命令，然后进行相应的工作</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MW4Cn5Yr-1669710623169)(C:Users61769AppDataRoamingTyporatypora-user-imagesimage-20220216125138086.png)]</p> 
<h3>
<a id="uboot_1059"></a>uboot启动过程中做了那些事？</h3> 
<p>1、初始化时钟，关闭看门狗，关中断，启动ICACHE，关闭DCACHE和TLB，关闭MMU，初始化SDRAM，初始化NAND FLASH，重定位。</p> 
<p>2、初始化一个串口，检测系统内存映射，将内核映象和根文件系统映象从 Flash上读到SDRAM空间中，为内核设置启动参数，调用内核。</p> 
<h3>
<a id="uboot_1065"></a>uboot和内核如何完成参数传递？</h3> 
<p>1、完成相关设置：CPU寄存器设置 R0=0 R1=机器类型ID R2=启动参数标记列表在RAM中起始基地址，设置禁止中断，SVC模式（超级用户模式，有利于硬件初始化）MMU关闭</p> 
<p>2、uboot把机器ID通过R1传递给内核，R2存放块内存的基地址，这块内存主要存放uboot给Linux内核的其他参数，参数很多所有需要按规定存放，标记是一种数据结构。</p> 
<p>3、标记的数据结构为tag，它由一个tag_header结构和一个联合（union）组成</p> 
<h3>
<a id="ubootcaches_1073"></a>为什么uboot要关掉caches？</h3> 
<p>caches是cpu内部的一个2级缓存，它的作用是将常用的数据和指令放在cpu内部。caches是通过CP15<br> 管理的，刚上电的时候，cpu还不能管理caches。上电的时候指令cache可关闭，也可不关闭，但数据<br> cache一定要关闭，否则可能导致刚开始的代码里面，去取数据的时候，从cache里面取，而这时候RAM中数据还没有caches过来，导致数据预取异常 。</p> 
<h2>
<a id="33__1083"></a>3.3 文件系统</h2> 
<h3>
<a id="_1085"></a>什么是根文件系统？</h3> 
<p>1、内核启动时所挂载（mount）的第一个文件系统，内核代码的映像文件保存在根文件系统中。</p> 
<p>2、挂载之后会把一些初始化脚本和服务加载到内存中去运行。</p> 
<h3>
<a id="_1091"></a>根文件系统为啥这么重要？</h3> 
<p>1、根文件系统包含系统启动时所必须的目录和关键性的文件，以及使其他文件系统得以挂载（mount）所必要的文件。比如shell命令程序必须运行在根文件系统上，譬如ls、cd等命令。</p> 
<p>2、一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、/bin<br> /sbin等目录下的shell命令，还有/lib目录下的库文件等）相配合才能工作。</p> 
<h2>
<a id="34__1098"></a>3.4 中断</h2> 
<h3>
<a id="___1100"></a>硬中断 / 软中断是什么？有什么区别？</h3> 
<p>1、硬中断是由硬件产生的，软中断是执行中断指令产生的。</p> 
<p>2、硬中断可以直接中断CPU，软中断并不会直接中断CPU。也只有当前正在运行的代码（或进程）才会产生软中断。</p> 
<p>3、硬中断可屏蔽、软中断不可屏蔽</p> 
<p>4、硬中断又称上半部，要快速完成任务</p> 
<h3>
<a id="_1110"></a>中断为什么要区分上半部和下半部？</h3> 
<p>1、调用过程：外部中断产生-&gt;发送中断信号到中断控制器-&gt;通知处理器产生中断的中断号</p> 
<p>2、为了能被新的中断打断。将中断处理一分为二，上半部登记新的中断，处理快速简单的任务，复杂耗时的任务给下半段处理，所以下半段可以被打断。</p> 
<p>3、中断下半部一般使用tasklet或工作队列实现</p> 
<h3>
<a id="linux_1118"></a>linux中断的响应执行流程？</h3> 
<p>cpu接受中断-&gt;保存中断上下文跳转到中断处理历程-&gt;执行中断上半部-&gt;执行中断下半部-&gt;恢复中断上下文。</p> 
<h2>
<a id="35_Linux_1126"></a>3.5 Linux驱动模型</h2> 
<h3>
<a id="_1128"></a>字符设备驱动模型</h3> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-a6VRcWwQ-1669710623169)(C:Users61769AppDataRoamingTyporatypora-user-imagesimage-20220601201707320.png)]</p> 
<h3>
<a id="_1132"></a>请简述主设备号和次设备号的用途</h3> 
<p><strong>主设备号</strong>：主设备号标识设备对应的特定的驱动程序。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织。</p> 
<p>**次设备号：**次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。（多个设备共用一套程序的话，主设备号代表这个驱动程序，每个设备一个次设备号）</p> 
<h3>
<a id="_1138"></a>创建设备文件</h3> 
<p>1、手动创建</p> 
<p>mknod /dev/led c 250 0 ，其中dev/led 为设备节点 ,c 代表字符设备, 250代表主设备号, 0代表次设备号。</p> 
<h3>
<a id="_1146"></a>设备驱动程序中如何注册一个字符设备？</h3> 
<p>1、将cdev结构嵌入到自己的设备特定结构中</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>cdev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>fops<span class="token punctuation">)</span>
</code></pre> 
<p>2、早期注册函数</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">register_chrdev</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> major<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>namem <span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> operations <span class="token operator">*</span>fopen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3>
<a id="Linux_1162"></a>Linux设备中字符设备和块设备有什么主要区别？</h3> 
<p>**字符设备：**提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。</p> 
<p>**块设备：**应用程序可以随机访问设备数据，程序可自行确定读取数据的位置。</p> 
<h3>
<a id="ioremap_1170"></a>驱动中操作物理绝对地址为什么要先ioremap？</h3> 
<p>1、ioremap是将io地址空间映射到虚拟地址空间上去，便于操作。</p> 
<p>2、因为保护模式下的cpu只认虚拟地址，不认物理地址，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟cpu对接，从而操作寄存器。</p> 
<h3>
<a id="LinuxARM_1176"></a>Linux移植ARM的基本步骤和完成的任务</h3> 
<p>1）首先是准备工作，包括下载源码、建立交叉编译环境等；<br> 2）然后是配置和编译内核，必要时还要对源码做一定的修改；<br> 3）第三步就是需要制作文件系统（如RAM disk）来挂接根文件系统；<br> 4）最后是下载、调试内核并在fs中添加自己的应用程序。</p> 
<h3>
<a id="ARMlinux_1183"></a>ARM-linux启动分几部分，简述流程：</h3> 
<p>ARM-linux启动分为四个部分：引导加载程序（bootloader），Linux内核，文件系统，应用程序。</p> 
<p>bootloader是系统启动和复位后执行的第一段代码，它主要用来初始化处理器及外设，然后调用Linux内核。Linux内核在完成系统的初始化之后需要挂载某个文件系统作为根文件系统（root filesystem）。根文件系统是Linux系统的核心组成部分，它可以作为Linux系统中文件和数据的存储区域，通常它还包括配置文件运行应用程序所需要的库。应用程序实现该嵌入式产品所要实现的目标。</p> 
<h1>
<a id="4_1189"></a>4、操作系统</h1> 
<h3>
<a id="_1191"></a>什么是进程？什么是线程？</h3> 
<p>进程是资源分配的基本单位，它是程序执行时的一个实例，在程序运行时创建。<br> 线程是程序执行的最小单位，是进程的一个执行流，一个线程由多个线程组成的。</p> 
<h3>
<a id="_1196"></a>进程和线程有什么区别？</h3> 
<p>1、进程是资源分配的基本单位，线程是程序运行的基本单位</p> 
<p>2、进程有自己的资源空间，线程是共享进程中的数据，所以进程切换开销更大一点</p> 
<p>3、线程通讯要简单一些，因为共享全局变量等</p> 
<p>4、线程执行开销小，进程执行开销大。</p> 
<p>5、多线程中一个线程死掉整个进程也死了，一个进程死掉不会影响其他进程，因为它有独立的地址空间。</p> 
<h3>
<a id="_1208"></a>何时使用多进程，何时使用多线程？</h3> 
<p>对资源的管理和保护要求高，不限制开销和效率时，使用多进程。<br> 要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</p> 
<h3>
<a id="_1213"></a>进程有几种状态？</h3> 
<ol>
<li>创建状态</li>
<li>就绪状态</li>
<li>运行状态</li>
<li>阻塞状态</li>
<li>终止状态</li>
</ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IS9rtzcd-1669710623170)(C:Users61769AppDataRoamingTyporatypora-user-imagesimage-20220601205944952.png)]</p> 
<h3>
<a id="_1227"></a>进程间通信方式</h3> 
<p><strong>管道(pipe)</strong><br> 管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用</p> 
<p><strong>信号量(semophore)</strong><br> 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p> 
<p><strong>消息队列(message queue)</strong><br> 消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。</p> 
<p><strong>共享内存(shared memory)</strong></p> 
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以<br> 访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与<br> 其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p> 
<p><strong>套接字(socket)</strong></p> 
<p>套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p> 
<h3>
<a id="_1248"></a>线程间的通讯方式</h3> 
<p>1）通过条件变量进行线程间的通信</p> 
<p>（2）通过标志位来通知线程间的通信</p> 
<p>（3）通过std::furture来进行线程间的通信</p> 
<h3>
<a id="_1256"></a>线程间同步方法有哪些？</h3> 
<ol>
<li>**临界区：**如果有多个线程试图访问共享资源，那么当有一个线程进入后，其他试图访问共享资源的线程将会被挂起，并一直等到进入临界区的线程离开，临界在被释放后，其他线程才可以抢占。</li>
<li>
<strong>互斥量</strong>：为协调对一个共享资源的单独访问而设计，只有拥有互斥量的线程，才有权限去访问系统<br> 的公共资源，因为互斥量只有一个，所以能够保证资源不会同时被多个线程访问。</li>
<li>**信号量：**为控制一个具有有限数量的用户资源而设计。它允许多个线程在同一个时刻去访问同一个<br> 资源，但一般需要限制同一时刻访问此资源的最大线程数目</li>
<li>事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。</li>
</ol> 
<h3>
<a id="_1267"></a>什么是僵尸进程，孤儿进程，守护进程？</h3> 
<p><strong>僵尸进程</strong>是 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子<br> 进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p> 
<p><strong>孤儿进程</strong>是因为父进程异常结束了，然后被1号进程init收养。<br> <strong>守护进程</strong>是创建守护进程时有意把父进程结束，然后被1号进程init收养</p> 
<h3>
<a id="forkvfork_1275"></a>请你回答一下fork和vfork的区别？</h3> 
<ol>
<li>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</li>
<li>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程<br> 数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</li>
<li>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个<br> 函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</li>
<li>当需要改变共享数据段中变量的值，则拷贝父进程。</li>
</ol> 
<h2>
<a id="_1284"></a>堆和栈</h2> 
<h3>
<a id="bss_1286"></a>什么是代码段，数据段，bss段，堆，栈？</h3> 
<p>代码段：存放程序执行代码的一块区域，通常是只读</p> 
<p>数据段：<strong>已初始化的全局变量</strong>和<strong>已初始化为非0的静态变量</strong></p> 
<p>BSS段：未初始化的全局变量和未初始化的静态变量或者<strong>初始化为0</strong>的静态变量</p> 
<p>数据段和BSS段本质上都是静态区，存放全局变量和静态变量的</p> 
<p>堆：堆是用来存放进程中被动态分配的内存段。</p> 
<p>栈：是用户存放程序临时创建的变量。</p> 
<h3>
<a id="_1302"></a>为什么堆的空间是不连续的？</h3> 
<p>1、堆包含一个链表来维护已用和空闲的内存块。</p> 
<p>2、分配的空间在逻辑地址（虚拟地址）上是连续的，但在物理地址上是不连续的</p> 
<h3>
<a id="_1308"></a>什么是用户栈和内核栈？</h3> 
<p><strong>内核栈</strong> ：内存中属于操作系统空间的一块区域。</p> 
<p><strong>作用</strong>：</p> 
<p>1、保存中断现场</p> 
<p>2、保存调用的参数、返回值、函数局部变量</p> 
<p>用户栈：</p> 
<p>用户<strong>进程空间</strong>的一块区域，用于保存用户空间子程序间调用的参数，返回值以及局部变量。</p> 
<p>为什么不能共用一个栈：</p> 
<p>1、系统栈（内核栈）大小有限用户程序调用次数可能很多。</p> 
<p>2、用户栈空间不能提供相应保护措施</p> 
<h3>
<a id="_1330"></a>线程是否有相同的堆栈？</h3> 
<p>每个线程有自己的堆栈。</p> 
<h2>
<a id="_1336"></a>信号、并发和互斥</h2> 
<h3>
<a id="_1338"></a>驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？</h3> 
<p>并发：多个执行单元同时对共享资源操作，容易导致竞态。</p> 
<p>互斥：一个执行单元在访问共享资源的时候、其他执行单元都被禁止访问。访问共享资源的代码区被称为临界区，临界区需要某种互斥机制加以保护。</p> 
<h3>
<a id="_1344"></a>自旋锁是什么？信号量是什么？二者有何异同？</h3> 
<p>自旋锁：一个执行单元在操作资源时，另一个执行单元不能操作。自旋锁只能短期持有</p> 
<p>信号量：资源标量，使用完了就不允许操作了。会有信号告诉需要等多久。适合长期持有的时候用</p> 
<p><strong>区别：</strong></p> 
<p>1、长时间持有锁使用信号量，短时间持有使用自旋锁。</p> 
<p>2、信号量可以睡眠，其他人需要时也会进入睡眠。</p> 
<p>3、信号量代码可以被抢占。</p> 
<h3>
<a id="_1358"></a>自旋锁和信号量可以睡眠吗？为什么？</h3> 
<p><strong>自旋锁不能睡眠，信号量可以。</strong></p> 
<p>原因：</p> 
<p>1、自旋锁自旋锁禁止处理器抢占；而信号量不禁止处理器抢占。</p> 
<h3>
<a id="_1368"></a>自旋锁和信号量可以用于中断中吗？</h3> 
<p>信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。</p> 
<p>自旋锁可以用于中断。在获取锁之前一定要先禁止本地中断（也就是本CPU中断，对于多核SOC来说会<br> 有多个CPU核），否则可能导致锁死现象的发生</p> 
<h3>
<a id="_1379"></a>产生死锁的原因是什么？</h3> 
<p>多个并发进程因争夺系统资源而产生相互等待的现象。即：一组进程中的每个进程都在等待某个事件发<br> 生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。</p> 
<p>原因：</p> 
<p>1、系统资源有限</p> 
<p>2、进程推进顺序不合理</p> 
<h3>
<a id="_1392"></a>如何避免死锁？</h3> 
<p>1、线程按一定顺序加锁</p> 
<p>2、获取锁时加上时限，也就是说超过时间则放弃获取。</p> 
<p>3、死锁检测</p> 
<h2>
<a id="_1402"></a>内存</h2> 
<h3>
<a id="1Gmalloc12G_1404"></a>在1G内存的计算机中能否malloc(1.2G)？为什么？</h3> 
<p>malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关。</p> 
<h3>
<a id="_1408"></a>内存管理的方法</h3> 
<p>1、块式管理</p> 
<p>​ 分成一大块一大块，只需要几个字节也给一大块。造成浪费、但方便管理。</p> 
<p>2、页式管理</p> 
<p>​ 划分地址空间为若干大小区域，被称为页。优点便于管理，缺点页长与逻辑大小没有关系。</p> 
<p>3、段式管理和段页式管理</p> 
<p><strong>按照程序的自然分界划分的并且长度可以动态改变的区域</strong>，每段可以定义一组相对完整的逻辑信息。段与段在内存中可以不相邻接，也实现了离散分配。</p> 
<p>段页式管理：</p> 
<p>用分段方法来分配和管理虚拟存储器。用分页方法来分配和管理内存</p> 
<h3>
<a id="_1428"></a>什么是虚拟内存？</h3> 
<p>它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），允许程序员编写并运行比实际系统拥有的内存大得多的程序</p> 
<p>好处：</p> 
<p>1、扩大了地址空间</p> 
<p>2、地址保护</p> 
<p>3、公平分配内存：每个进程相当于有了同样大小的额外内存</p> 
<h3>
<a id="_1442"></a>解释下内存碎片，内碎片，外碎片？</h3> 
<p>1、内存碎片：内存碎片是由于多次进行内存分配造成的，空白段太小无法进行下次分配</p> 
<p>2、内碎片：分配给程序的存储空间没有用完，有一部分是程序不使用（没用完），但其他程序也没法用的空间。</p> 
<p>3、外碎片：空间太小，小到无法给任何程序分配（不属于任何进程）的存储空间。</p> 
<h3>
<a id="_1450"></a>解释下虚拟地址、逻辑地址、线性地址、物理地址？</h3> 
<p>1、虚拟地址、逻辑地址：由程序产生的由<strong>段选择符</strong>和<strong>段内偏移地址</strong>组成的地址这两部分组成的地址并没有直接访问物理内存，而是通过分段地址的变换处理后才会对应到相应的物理内存地址。</p> 
<p>2、线性地址：指虚拟地址到物理地址变换之间的中间层，是处理器可寻址的内存空间（称为线性地址空间）中的地址。</p> 
<p>3、物理地址：是指现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。</p> 
<h3>
<a id="_1460"></a>系统调用是什么，你用过哪些系统调用，和库函数有什么区别？</h3> 
<p>系统调用：系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。</p> 
<p>库函数：库函数（Library function）是把函数放到库里，供别人使用的一种方式。.方法是把一些常用到的函数编完放到一个文件里，供不同的人进行调用。一般放在.lib文件中。<strong>系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。</strong></p> 
<p>区别：</p> 
<p>1、库函数是语言或应用程序的一部分，系统调用是内核提供的接口。</p> 
<p>2、库函数在用户地址进行，系统调用在内核地中空间执行</p> 
<p>3、库函数有缓冲、系统调用无缓冲。</p> 
<p>4、系统调用依赖平台，库函数不用</p> 
<h2>
<a id="_1476"></a>上下文</h2> 
<h3>
<a id="_1478"></a>上下文有哪些？怎么理解？</h3> 
<p>上下文简单说来就是一个环境。</p> 
<ol>
<li>用户级上下文: 正文、数据、用户堆栈以及共享存储区；</li>
<li>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；</li>
<li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、<br> pte)、内核栈</li>
</ol> 
<h3>
<a id="_1487"></a>为什么会有上下文这种概念？</h3> 
<p>系统调用中用户空间会传递很多数据给内核空间，保存上下文以便系统调用结束后回到用户空间继续执行。</p> 
<h1>
<a id="5_1491"></a>5、网络编程</h1> 
<h2>
<a id="TCP_UDP_1495"></a>TCP/ UDP</h2> 
<h3>
<a id="TCP_1497"></a>TCP怎么保证可靠性？</h3> 
<p>1、序列号、确认应答、超时重传</p> 
<p>2、窗口控制与高速重发控制/快速重传（重复确认应答）</p> 
<p>窗口控制：不需要对每个没收确认的数据重发，只需要确认一个窗口是否都收齐了。</p> 
<h3>
<a id="TCP_1509"></a>简述一下TCP建立连接和断开连接的过程。</h3> 
<p><strong>连接三次握手</strong></p> 
<p>1、客户端请求，标志位SYN置为1 发送x;</p> 
<p>2、服务端回复，标志位SYN和ACK都置为1 回复 x+1,和 y</p> 
<p>3、客户端收到后回复 y+1，服务端检查ack是否为1，是的话就连接成功</p> 
<p>断开</p> 
<p>1、客户端发送 x+2 回复y+1 进入FIN_WAIT_1 状态</p> 
<p>2、服务端回复x+3 服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态</p> 
<p>3、服务端发送完所有数据之后发送y+1 服务器进入LAST_ACK状态</p> 
<p>4、客户端回复y+2 客户端进入TIME_WAIT状态等待2MSL（报文段最大生存时间）后关闭</p> 
<h3>
<a id="2MSL_1529"></a>为什么客户端最后还要等待2MSL？</h3> 
<p>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度<br> 看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文<br> 它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，<br> 接着给出回应报文，并且会重启2MSL计时器。</p> 
<h3>
<a id="_1536"></a>为什么是三次握手？</h3> 
<p>1、为了防止已失效的连接请求报文段突然又送到了，产生错误。</p> 
<p>2、客户端发送请求报文遗漏，后续才到达时，服务端还是回回复，浪费资源</p> 
<p>3、客户端发送请求报文后掉线了，服务端还是会回复，浪费资源</p> 
<h3>
<a id="_1544"></a>为什么是四次挥手？二三次能不能合并</h3> 
<p>1、TCP是全双工通信，意味着关闭是双方都需要确认的行为。</p> 
<p>2、需要时间释放资源，一旦合并需要等很久。</p> 
<p>3、客户端会以为自己第一次发的报文没有送到，不断尝试发送第一次的报文。</p> 
<h3>
<a id="TCPUDP_1552"></a>TCP/UDP</h3> 
<p>1、TCP面向连接，UDP无连接</p> 
<p>2、TCP数据保证正确、顺序正确，UDP可能丢包</p> 
<p>3、TCP可靠稳定，但是慢效率低，UDP快，容易丢包</p> 
<h3>
<a id="TCPUDP_1560"></a>TCP，UDP适用场景？</h3> 
<p><strong>TCP应用场景</strong></p> 
<p>效率要求相对低，但对准确性要求相对高的场景。文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</p> 
<p><strong>UDP应用场景</strong></p> 
<p>效率要求相对高，对准确性要求相对低的场景。QQ聊天、在线视频、网络语音电话、广播通信</p> 
<h3>
<a id="TCPUDP_1572"></a>TCP相比UDP为什么是可靠的？</h3> 
<p>1、确认和重传机制</p> 
<p>2、数据排序</p> 
<p>3、流量控制 窗口和计时器的使用</p> 
<p>4、拥塞控制</p> 
<h3>
<a id="OSITCPIP2_1586"></a>什么是OSI七层模型和TCP/IP四层模型？每层列举2个协议。</h3> 
<ol>
<li>
<strong>物理层:</strong> 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3<br> CLOCK RJ45</li>
<li>
<strong>数据链路层</strong>: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP</li>
<li>
<strong>网络层</strong>：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP</li>
<li>
<strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP</li>
<li>
<strong>会话层</strong>：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</li>
<li>
<strong>表示层</strong>: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</li>
<li>
<strong>应用层</strong>: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</li>
</ol> 
<p>​ TCP/IP</p> 
<p>链路层：MAC VLAN PPP</p> 
<p>网络层：IP协议、ICMP协议、ARP协议、RARP协议。<br> 传输层：UDP协议、TCP协议。<br> 应用层：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送<br> 协议），POP3协议（邮局协议），HTTP协议。</p> 
<h3>
<a id="TCPIP_1608"></a>TCP/IP数据链路层的交互过程是怎么样的？</h3> 
<p>网络层等在数据链路层用MAC地址作为通信目标，数据包到达网络层等往数据链路层发送的时候，首先<br> 回去ARP缓存表去查找ip对应的MAC地址，如果查到了，就将此ip对应的MAC地址封装到链路层数据包<br> 的包头。如果缓存中没有找到，则会发起一个广播寻找目的IP的物理地址。</p> 
<h3>
<a id="IPUDPTCP_1614"></a>传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文？</h3> 
<p>根据端口继续区分需接受的程序；<br> 根据ip协议头中标识字段：UDP 17 、TCP 6</p> 
<h3><a id="_1619"></a></h3> 
<h2>
<a id="_1621"></a>端口号</h2> 
<p>熟知的端口号：</p> 
<p>20：FTP 数据传输</p> 
<p>21/TCP FTP 文件传输协议</p> 
<p>23/tcp Telnet 不安全的文本传送</p> 
<p>25/tcp SMTP Simple Mail Transfer Protocol (E-mail)</p> 
<p>69/udp TFTP Trivial File Transfer Protocol</p> 
<p>79/tcp finger Finger</p> 
<p>80/tcp HTTP 超文本传送协议 (WWW)</p> 
<p>88/tcp Kerberos Authenticating agent</p> 
<p>110/tcp POP3 Post Office Protocol (E-mail)</p> 
<p>113/tcp ident old identification server system</p> 
<p>119/tcp NNTP used for usenet newsgroups</p> 
<p>220/tcp IMAP3</p> 
<p>443/tcp HTTPS used for securely transferring web pages</p> 
<h3>
<a id="ICMP_1653"></a>ICMP协议属于什么层</h3> 
<p><strong>1.ICMP是基于IP协议工作的，但是它并不是传输层的功能，因此仍然把它归结为网络层协议</strong></p> 
<p><strong>2.<em>ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6</em></strong></p> 
<h3>
<a id="IP_1659"></a>物理地址和IP的转化</h3> 
<p>地址解析协议（ARP）的作用是将IP地址转换成物理地址；反地址解析协议（RARP）则负责将物理地址转换成IP地址。</p> 
<h3>
<a id="wwwbaiducomhttpssocsdnnetsosearchq_1663"></a>从在浏览器地址栏中输入www.baidu.com到看到百度首页，这个过程中间经历了什么？都涉及到哪些<a href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a>？</h3> 
<p>按照时间顺序：<br> 1.客户端浏览器获取用户在地址栏输入的域名。<br> 2.客户端浏览器将域名发送给DNS域名系统，请求解析。<br> 3.DNS解析域名得到相应的IP，返回给客户端浏览器。<br> 4.客户端浏览器根据IP向服务器发起TCP三次握手，建立TCP连接。<br> 5.客户端浏览器向服务器发送HTTP请求，请求百度首页。<br> 6.服务器通过HTTP响应向客户端浏览器返回百度首页文件。<br> 7.释放TCP连接。<br> 8.客户端浏览器解析HTML文件，根据文件内容获取CSS、JS等资源文件，将页面渲染展示给用户。</p> 
<h2>
<a id="HTTPIP_1679"></a>HTTP/IP</h2> 
<h3>
<a id="http_1683"></a>什么是http协议？</h3> 
<p>1、HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p> 
<p>2、HTTP是一个基于TCP/IP通信协议来传递数据</p> 
<p>ICMP协议属于什么层</p> 
<h3>
<a id="http_1693"></a>http协议有什么特点？</h3> 
<p>1、简单快速 客户向服务器请求服务时，只需传送请求方法和路径</p> 
<p>2、无连接 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</p> 
<p>3、基于TCP协议</p> 
<p>4、默认端口80</p> 
<h3>
<a id="https_1703"></a>https建立连接过程是什么?</h3> 
<ol>
<li> <p>客户端连接到Web服务器 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。</p> </li>
<li> <p>发送HTTP请求</p> <p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文</p> </li>
<li> <p>服务器接受请求并返回HTTP响应</p> </li>
</ol> 
<p>​ Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。</p> 
<pre><code>4. 释放连接TCP连接
4. 客户端浏览器解析HTML内容
</code></pre> 
<h3>
<a id="httphttpshttps_1718"></a>http和https的区别是什么？https有什么优缺点？</h3> 
<p>区别：</p> 
<p>1、HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，安全性高</p> 
<p>2、HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p> 
<p>3、HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p> 
<p>4、HTTP协议端口是80，HTTPS协议端口是443</p> 
<h3>
<a id="HTTPS_1730"></a>HTTPS优缺点</h3> 
<p>1、握手延时 高</p> 
<p>2、部署成本高</p> 
<h3>
<a id="IPMAC_1736"></a>请你说一说IP地址作用，以及MAC地址作用</h3> 
<p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供<br> 的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地<br> 址的差异。</p> 
<h3>
<a id="_1742"></a>具体网络层的操作该怎么做？</h3> 
<p>服务端：socket-bind-listen-accept</p> 
<p>客户端：socket-connect</p> 
<h3>
<a id="socket_1748"></a>请你来说一下socket编程中服务器端和客户端主要用到哪些函数？</h3> 
<p><strong>基于TCP的socket</strong></p> 
<ol>
<li>服务器端程序<br> （1）、创建一个socket，用函数socket()<br> （2）、绑定IP地址、端口等信息到socket上，用函数bind()<br> （3）、设置允许的最大连接数，用函数listen()<br> （4）、接收客户端上来的连接，用函数accept()<br> （5）、收发数据，用函数send()和recv()，或者read()和write()<br> （6）、关闭网络连接</li>
<li>客户端程序：<br> （1）、创建一个socket，用函数socket()<br> （2）、设置要连接的对方的IP地址和端口等属性<br> （3）、连接服务器，用函数connect()<br> （4）、收发数据，用函数send()和recv()，或read()和write()<br> （5）、关闭网络连接</li>
</ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FTnjHTXr-1669710623170)(C:Users61769AppDataRoamingTyporatypora-user-imagesimage-20220602212911447.png)]</p> 
<p><strong>基于UDP的socket</strong></p> 
<ol>
<li>服务器端流程<br> （1）、建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。<br> （2）、设置服务器地址和侦听端口，初始化要绑定的网络地址结构。<br> （3）、绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。<br> （4）、接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。<br> （5）、向客户端发送数据，使用sendto()函数向服务器主机发送数据。<br> （6）、关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</li>
<li>客户端流程<br> （1）、建立套接字文件描述符，socket()。<br> （2）、设置服务器地址和端口，struct sockaddr。<br> （3）、向服务器发送数据，sendto()。<br> （4）、接收服务器的数据，recvfrom()。<br> （5）、关闭套接字，close()。</li>
</ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uk9NgPQv-1669710623171)(C:Users61769AppDataRoamingTyporatypora-user-imagesimage-20220602212928435.png)]</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>