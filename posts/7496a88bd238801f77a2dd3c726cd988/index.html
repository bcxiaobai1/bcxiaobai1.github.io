<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>面试必备之java缓存总结，从单机缓存到分布式缓存架构 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试必备之java缓存总结，从单机缓存到分布式缓存架构</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="1_1"></a>1、<strong>缓存定义</strong>
</h1> 
<blockquote> 
 <p>高速数据存储层，提高程序性能</p> 
</blockquote> 
<h1>
<a id="2_5"></a>2、<strong>为什么要用缓存（读多写少，高并发）</strong>
</h1> 
<blockquote> 
 <p>1、提高读取吞吐量</p> 
 <p>2、提升应用程序性能</p> 
 <p>3、降低数据库成本</p> 
 <p>4、减少后端负载</p> 
 <p>5、消除数据库热点</p> 
 <p>6、可预测的性能</p> 
</blockquote> 
<h1>
<a id="3_19"></a>3、<strong>缓存分类</strong>
</h1> 
<h2>
<a id="31localCache_21"></a>3.1、单机缓存（localCache）</h2> 
<h3>
<a id="_23"></a>实现方案</h3> 
<h4>
<a id="1JSR107_25"></a>1、基于JSR107规范自研（了解即可）：</h4> 
<blockquote> 
 <p>1、Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。<br> 2、CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。<br> 3、CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。<br> 4、Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。<br> 5、Entry是一个存储在Cache中的key-value对。<br> 每一个存储在Cache中的条目有一个定义的有效期，即Expiry Duration。<br> 一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。</p> 
</blockquote> 
<h4>
<a id="2ConcurrentHashMap_35"></a>2、基于ConcurrentHashMap实现数据缓存</h4> 
<h2>
<a id="32redisMemcached_37"></a>3.2、分布式缓存（redis、Memcached）</h2> 
<h1>
<a id="4_39"></a>4、<strong>单机缓存</strong>
</h1> 
<h2>
<a id="1_41"></a>1、<strong>自己实现一个单机缓存</strong>
</h2> 
<h3>
<a id="_43"></a>创建缓存类</h3> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @author yinfeng
 * @description 本地缓存实现：用map实现一个简单的缓存功能
 * @since 2022/2/8 13:54
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapCacheDemo</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * 在构造函数中，创建了一个守护程序线程，每5秒扫描一次并清理过期的对象
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CLEAN_UP_PERIOD_IN_SEC <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * ConcurrentHashMap保证线程安全的要求
     * SoftReference &lt;Object&gt;  作为映射值，因为软引用可以保证在抛出OutOfMemory之前，如果缺少内存，将删除引用的对象。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SoftReference</span><span class="token punctuation">&lt;</span><span class="token class-name">CacheObject</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MapCacheDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//创建了一个守护程序线程，每5秒扫描一次并清理过期的对象</span>
        <span class="token class-name">Thread</span> cleanerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>CLEAN_UP_PERIOD_IN_SEC <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    cache<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>entry <span class="token operator">-&gt;</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">CacheObject</span><span class="token operator">::</span><span class="token function">isExpired</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cleanerThread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cleanerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> periodInMillis<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">long</span> expiryTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> periodInMillis<span class="token punctuation">;</span>
            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CacheObject</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> expiryTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>cacheObject <span class="token operator">-&gt;</span> <span class="token operator">!</span>cacheObject<span class="token punctuation">.</span><span class="token function">isExpired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">CacheObject</span><span class="token operator">::</span><span class="token function">getValue</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cache<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>entry <span class="token operator">-&gt;</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>cacheObject <span class="token operator">-&gt;</span> <span class="token operator">!</span>cacheObject<span class="token punctuation">.</span><span class="token function">isExpired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 缓存对象value
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CacheObject</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token class-name">Object</span> value<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> expiryTime<span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token class-name">CacheObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> expiryTime<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>expiryTime <span class="token operator">=</span> expiryTime<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">boolean</span> <span class="token function">isExpired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> expiryTime<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

  
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="main_137"></a>写个main方法测试一下</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">MapCacheDemo</span> mapCacheDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MapCacheDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mapCacheDemo<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"uid_10001"</span><span class="token punctuation">,</span> <span class="token string">"{1}"</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mapCacheDemo<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"uid_10002"</span><span class="token punctuation">,</span> <span class="token string">"{2}"</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"从缓存中取出值:"</span> <span class="token operator">+</span> mapCacheDemo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"uid_10001"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"5秒钟过后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 5秒后数据自动清除了</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"从缓存中取出值:"</span> <span class="token operator">+</span> mapCacheDemo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"uid_10001"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="2guava_cache_154"></a>2、<strong>谷歌guava cache缓存框架</strong>
</h2> 
<h3>
<a id="21_156"></a>2.1、<strong>简介</strong>
</h3> 
<blockquote> 
 <p>Guava Cache是一个内存缓存模块，用于将数据缓存到jvm内存中，是单个应用运行时的本地缓存，他不将数据放到文件或外部服务器。</p> 
</blockquote> 
<h3>
<a id="22__160"></a>2.2 <strong>简单使用</strong>
</h3> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @author yinfeng
 * @description guava测试，https://github.com/google/guava
 * @since 2022/2/8 14:13
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GuavaCacheDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//缓存接口这里是LoadingCache，LoadingCache在缓存项不存在时可以自动加载缓存</span>
        <span class="token class-name">LoadingCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> userCache
                <span class="token comment">//CacheBuilder的构造函数是私有的，只能通过其静态方法newBuilder()来获得CacheBuilder的实例</span>
                <span class="token operator">=</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//设置并发级别为8，并发级别是指可以同时写缓存的线程数</span>
                <span class="token punctuation">.</span><span class="token function">concurrencyLevel</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>
                <span class="token comment">//设置写缓存后8秒钟过期</span>
                <span class="token punctuation">.</span><span class="token function">expireAfterWrite</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span>
                <span class="token comment">//设置写缓存后1秒钟刷新</span>
                <span class="token punctuation">.</span><span class="token function">refreshAfterWrite</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span>
                <span class="token comment">//设置缓存容器的初始容量为10</span>
                <span class="token punctuation">.</span><span class="token function">initialCapacity</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
                <span class="token comment">//设置缓存最大容量为100，超过100之后就会按照LRU最近虽少使用算法来移除缓存项</span>
                <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
                <span class="token comment">//设置要统计缓存的命中率</span>
                <span class="token punctuation">.</span><span class="token function">recordStats</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//设置缓存的移除通知</span>
                <span class="token punctuation">.</span><span class="token function">removalListener</span><span class="token punctuation">(</span>notification <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>notification<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 被移除了，原因： "</span> <span class="token operator">+</span> notification<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">//build方法中可以指定CacheLoader，在缓存不存在时通过CacheLoader的实现自动加载缓存</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>
                        <span class="token keyword">new</span> <span class="token class-name">CacheLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                            <span class="token annotation punctuation">@Override</span>
                            <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"缓存没有时，从数据库加载"</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token comment">// TODO jdbc的代码~~忽略掉</span>
                                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"yinfeng"</span> <span class="token operator">+</span> key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 第一次读取</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">User</span> user <span class="token operator">=</span> userCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"uid"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 第二次读取</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">User</span> user <span class="token operator">=</span> userCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"uid"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cache stats:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//最后打印缓存的命中率等 情况</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userCache<span class="token punctuation">.</span><span class="token function">stats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Data</span>
    <span class="token annotation punctuation">@AllArgsConstructor</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> userId<span class="token punctuation">;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> userId <span class="token operator">+</span> <span class="token string">" --- "</span> <span class="token operator">+</span> userName<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h1>
<a id="5_227"></a>5、<strong>分布式缓存</strong>
</h1> 
<h2>
<a id="51_redis_229"></a>5.1 <strong>redis</strong>
</h2> 
<h3>
<a id="511__231"></a>5.1.1 <strong>介绍</strong>
</h3> 
<blockquote> 
 <p>Redis是一个开源的使用C语言缩写、支持网络、可基于内存亦可持久化的日志型，Key-Value数据库，并提供多种语言的API。</p> 
 <p>本质是客户端-服务端应用软件程序。</p> 
 <p>特点是使用简单,性能强悍,功能应用场景丰富。</p> 
</blockquote> 
<h3>
<a id="512_239"></a>5.1.2<strong>通用命令</strong>
</h3> 
<table>
<thead><tr>
<th>命令</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>DEL key</td>
<td>用于在key存在是删除key</td>
</tr>
<tr>
<td>DUMP key</td>
<td>序列化给定的key，并返回给定的值</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>检查给定key是否存在</td>
</tr>
<tr>
<td>EXPIRE key seconds</td>
<td>为给定key设置过期时间，单位秒</td>
</tr>
<tr>
<td>TTL key</td>
<td>以秒为单位，返回给定key的剩余生存时间</td>
</tr>
<tr>
<td>TYPE key</td>
<td>返回key所存储的值的类型</td>
</tr>
</tbody>
</table>
<h3>
<a id="513__250"></a>5.1.3 <strong>数据结构</strong>
</h3> 
<h4>
<a id="1_String_252"></a>1. <strong>String</strong>
</h4> 
<p><strong>定义</strong></p> 
<blockquote> 
 <p>String数据结构是简单的key-value类型，value其实不仅是String，也可以是数字。</p> 
 <p>使用场景：微博数，粉丝数(常规计数)</p> 
</blockquote> 
<p><strong>常用命令</strong></p> 
<table>
<thead><tr>
<th>命令</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>Get</td>
<td>获取指定key的值</td>
</tr>
<tr>
<td>Set</td>
<td>设置指定key的值</td>
</tr>
<tr>
<td>Incr</td>
<td>将key中储存的数字值增一</td>
</tr>
<tr>
<td>Decr</td>
<td>将key中储存的数字值减一</td>
</tr>
<tr>
<td>Mget</td>
<td>获取所有(一个或多个)给定key的值</td>
</tr>
</tbody>
</table>
<h4>
<a id="2_List_270"></a>2. List</h4> 
<p><strong>定义</strong></p> 
<blockquote> 
 <p>List就是链表，依赖于链表结构</p> 
 <p>使用场景：微博的关注列表，粉丝列表</p> 
</blockquote> 
<p><strong>常用命令</strong></p> 
<table>
<thead><tr>
<th>命令</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>Lpush</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>Rpush</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>Lpop</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>Rpop</td>
<td>移除列表的最后一个元素,返回值为移除的元素</td>
</tr>
<tr>
<td>Lrange</td>
<td>获取所有(一个或多个)给定key的值</td>
</tr>
</tbody>
</table>
<h4>
<a id="3_Set_288"></a>3. Set</h4> 
<p><strong>定义</strong></p> 
<blockquote> 
 <p>Set就是一个集合，集合的概念就是一堆不重复值的组合。利用Reds提供的Set数据结构，可以存储一些集合性的数据。</p> 
 <p>使用场景：实现如共同关注，共同喜好，二度好友</p> 
</blockquote> 
<p><strong>常用命令</strong></p> 
<table>
<thead><tr>
<th>命令</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>Lpush</td>
<td>向集合中添加一个或多个成员</td>
</tr>
<tr>
<td>Rpush</td>
<td>移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td>Lpop</td>
<td>返回集合中的所有成员</td>
</tr>
<tr>
<td>Rpop</td>
<td>返回所有给定集合的并集</td>
</tr>
</tbody>
</table>
<h4>
<a id="4_Sorted_set_305"></a>4. Sorted set</h4> 
<p><strong>定义</strong></p> 
<blockquote> 
 <p>Sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。</p> 
 <p>使用场景：排行榜、按照用户投票和时间排序</p> 
</blockquote> 
<p><strong>常用命令</strong></p> 
<table>
<thead><tr>
<th>命令</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>Zadd</td>
<td>向有序集合添加一个或多个成员,或者更新已存在成员的分数</td>
</tr>
<tr>
<td>Zrange</td>
<td>通过索引区间返回有序集合中指定区间内的成员</td>
</tr>
<tr>
<td>Zrem</td>
<td>移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>Zcard</td>
<td>获取有序集合的成员数</td>
</tr>
</tbody>
</table>
<h4>
<a id="5_Hash_322"></a>5. Hash</h4> 
<p><strong>定义</strong></p> 
<blockquote> 
 <p>Hash是一个sting类型的field和value的映射表</p> 
 <p>使用场景：存储部分变更数据，如用户信息</p> 
</blockquote> 
<p><strong>常用命令</strong></p> 
<table>
<thead><tr>
<th>命令</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>Zadd</td>
<td>获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td>Zrange</td>
<td>将哈希表key中的字段field的值设为value</td>
</tr>
<tr>
<td>Hgetall</td>
<td>获取在哈希表中指定key的所有字段和值</td>
</tr>
</tbody>
</table>
<h4>
<a id="6_GEO_338"></a>6. GEO</h4> 
<p><strong>定义</strong></p> 
<blockquote> 
 <p>GEO3.2版本开始对GEO(地理位置)的支持</p> 
 <p>使用场景：LBS应用开发</p> 
</blockquote> 
<p><strong>常用命令</strong></p> 
<table>
<thead><tr>
<th>命令</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>GEOADD</td>
<td>增加地理位置的坐标,可以批量添加地理位置</td>
</tr>
<tr>
<td>GEODIST</td>
<td>获取两个地理位置的距离</td>
</tr>
<tr>
<td>GEOHASH</td>
<td>获取某个地理位置的geohash值</td>
</tr>
<tr>
<td>GEOPOS</td>
<td>获取指定位置的坐标,可以批量获取多个地理位置的坐标</td>
</tr>
<tr>
<td>GEORADIUS</td>
<td>根据给定地理位置坐标获取指定范围内的地理位置集合(注意:该命令的中心点由输入的经度和结度决定)</td>
</tr>
<tr>
<td>GEORADIUSBYMEMBER</td>
<td>根据给定成员的位置获取指定范围内的位置信息集合(注意:该命令的中心点足由给定的位置元素决定)</td>
</tr>
</tbody>
</table>
<h4>
<a id="7_Stream_357"></a>7. Stream</h4> 
<p><strong>定义</strong></p> 
<blockquote> 
 <p>Stream5.0版本开始的新结构“流”</p> 
 <p>使用场景:消费者生产者场景(类似MO)</p> 
</blockquote> 
<p><strong>常用命令</strong></p> 
<table>
<thead><tr>
<th>命令</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>XADD</td>
<td>增加地理位置的坐标,可以批量添加地理位置</td>
</tr>
<tr>
<td>XLEN</td>
<td>stream流中的消息数量</td>
</tr>
<tr>
<td>XDEL</td>
<td>删除流中的消息</td>
</tr>
<tr>
<td>XRANGE</td>
<td>返回流中满足给定ID范围的消息</td>
</tr>
<tr>
<td>XREAD</td>
<td>从一个或者多个流中读取消息</td>
</tr>
<tr>
<td>XINFO</td>
<td>检索关于流和关联的消费者组的不同的信息</td>
</tr>
</tbody>
</table>
<h3>
<a id="514__376"></a>5.1.4 <strong>持久化机制</strong>
</h3> 
<h4>
<a id="1__378"></a><strong>1. 介绍</strong>
</h4> 
<blockquote> 
 <p>redis的数据都存放在内存中，如果没有配置持久化，重启后数据就全丢失，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后,可以从磁盘中恢复数据</p> 
</blockquote> 
<h4>
<a id="2__382"></a><strong>2. 持久化方式</strong>
</h4> 
<blockquote> 
 <ol>
<li>RDB持久化：RDB持久化方式能够在指定的时间间隔对你的数据进行快照存储</li>
<li>AOF持久化： AOF持久化方式记录每次对服务器写的操作,当服务器重后的时候会重新执行这些命令来恢复原始的数据</li>
</ol> 
</blockquote> 
<h4>
<a id="3RDB_387"></a><strong>3.RDB方式</strong>
</h4> 
<blockquote> 
 <p>客户端直接通过命令BGSAVE或者SAVE来创建一个内存快照：</p> 
 <ol>
<li>BGSAVE调用fork来创建一个子进程，子进程负责将快照写入磁盘,而父进程仍然继续处理命令。</li>
<li>SAVE执行SAVE命令过程中,不再响应其他命令。</li>
</ol> 
</blockquote> 
<p><strong>在redis.conf中调整save配置选项，当在规定的时间内，redis发生了写操作的个数满足条件会触发BGSAVE命令</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">#900秒之内至少一次写操作</span>
save <span class="token number">900</span> <span class="token number">1</span>
<span class="token comment">#300秒之内至少发生10次写操作</span>
save <span class="token number">300</span> <span class="token number">10</span>
</code></pre> 
<p><strong>优缺点</strong></p> 
<table>
<thead><tr>
<th>优点</th>
<th>缺点</th>
</tr></thead>
<tbody>
<tr>
<td>对性能影响最小</td>
<td>同步时丢失数据</td>
</tr>
<tr>
<td>RDB文件进行数据恢复比使用AOF要快很多</td>
<td>如果数据集非常大且CPU不够强(比如单核CPU)，Redis在fork子进程时可能会消耗相对较长的时间,影响RediS对外提供服务的能力</td>
</tr>
</tbody>
</table>
<h4>
<a id="4_AOF_410"></a><strong>4. AOF持久化方式</strong>
</h4> 
<p><strong>开启AOF持久化</strong></p> 
<pre><code class="prism language-bash">appendonty <span class="token function">yes</span>
</code></pre> 
<p><strong>AOF策略调整</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">#每次有数据修改发生时都会写入AOF文件</span>
appendfsync always
<span class="token comment">#每秒钟同步一次,该策略为AOF的默认策略</span>
appendfsync everysec
<span class="token comment">#从不同步。高效但是数据不会被持久化</span>
appendfsync no
</code></pre> 
<p><strong>优点</strong></p> 
<table>
<thead><tr>
<th>优点</th>
<th>缺点</th>
</tr></thead>
<tbody>
<tr>
<td>最安全</td>
<td>文件体积大</td>
</tr>
<tr>
<td>容灾</td>
<td>性能消耗比RDB高</td>
</tr>
<tr>
<td>易读,可修改</td>
<td>数据恢复速度比RDB慢</td>
</tr>
</tbody>
</table>
<h3>
<a id="515__439"></a><strong>5.1.5 内存管理</strong>
</h3> 
<h4>
<a id="1_441"></a><strong>1、内存分配</strong>
</h4> 
<p><strong>不同数据类型的大小限制：</strong></p> 
<blockquote> 
 <p>Strings类型：一个Strings类型的Value最大可以存储512M。</p> 
 <p>Lists类型：list的元素个数最多为2^32-1个</p> 
 <p>Sets类型：元素个数最多为2^32-1个</p> 
 <p>Hashes类型：键值对个数最多为2^32-1个</p> 
</blockquote> 
<p><strong>最大内存控制：</strong></p> 
<blockquote> 
 <p>maxmemory 最大内存阈值</p> 
 <p>maxmemory-policy 到达阈值的执行策略</p> 
</blockquote> 
<h4>
<a id="2_459"></a><strong>2、内存压缩</strong>
</h4> 
<pre><code class="prism language-bash"><span class="token comment">#配置字段最多512个</span>
hash-max-zipmap-entries <span class="token number">512</span>
<span class="token comment">#配置value最大为64字节</span>
hash-max-zipmap-value <span class="token number">64</span>
<span class="token comment">#配置元素个数最多512个</span>
lst-max-zipmap-entries <span class="token number">512</span>
<span class="token comment">#配置value最大为64字节</span>
list-max-zipmap-value <span class="token number">64</span>
<span class="token comment">#配置元素个数最多512个</span>
set-max-zipmap-entries <span class="token number">512</span>
</code></pre> 
<p>大小超出压缩范围，溢出后redis将自动将其转换为正常大小</p> 
<h4>
<a id="3_476"></a><strong>3、过期数据的处理策略</strong>
</h4> 
<p><strong>主动处理(redis主动触发检测key足否过期)每秒抗行10次。过程如下：</strong></p> 
<blockquote> 
 <ol>
<li>从具有相关过期的key集合中测试20个随机key</li>
<li>删除找到的所有已过期key</li>
<li>如果超过25%的key已过期,请从步骤1重新开始</li>
</ol> 
</blockquote> 
<p><strong>被动处理:</strong></p> 
<blockquote> 
 <ol><li>每次访问key的时候，发现超时后被动过期，清理掉</li></ol> 
</blockquote> 
<p><strong>数据恢复阶段过期数据的处理策略：</strong></p> 
<blockquote> 
 <p><strong>RDB方式</strong>：过期的Key不会被持久化到文件中。载入时过期的key，会通过redis的主动和被动方式清理掉。</p> 
 <p><strong>AOF方式</strong>：每次遇到过期的key，redis会追加一条DEL命令到AOF文件，也就是说只要我们顺序载入执行AOF命令文件就会删除过期的key</p> 
 <p><strong>注意</strong>：过期数据的计算和计算机本身的时间是有直接联系的!</p> 
</blockquote> 
<p><strong>Redis内存回收策略：</strong></p> 
<blockquote> 
 <p>配置文件中设置：maxmemory-poIicy noeviction</p> 
 <p>命令动态调整：config set maxmemory-policy noeviction</p> 
</blockquote> 
<table>
<thead><tr>
<th>回收策略</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>noeviction</td>
<td>客户端尝试执行会让更多内存被使用的命令直接报错</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>在所有key里执行LRU算法清除</td>
</tr>
<tr>
<td>volatile-lru</td>
<td>在所有已经过期的key里执行LRU算法清除</td>
</tr>
<tr>
<td>allkeys-lfu</td>
<td>在所有key里执行LFU算法清除</td>
</tr>
<tr>
<td>volatile-lfu</td>
<td>在所有已经过期的key里执行LFU算法清除</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>在所有key里随机回收</td>
</tr>
<tr>
<td>volatile-random</td>
<td>在已经过期的key里随机回收</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>回收已经过期的key，并且优先回收存活时间(TTL)较短的key</td>
</tr>
</tbody>
</table>
<h4>
<a id="4LRU_513"></a><strong>4、LRU算法</strong>
</h4> 
<p><strong>LRU(最近最少使用)：根据数据的历史访问记录来进行沟汰数据</strong></p> 
<blockquote> 
 <p><strong>核心思想</strong>：如果数据最近被访问过，那么将来被访问的几率也更高。</p> 
 <p><strong>注意</strong>：Redis的LRU算法并非完整的实现，完整的LRU实现需要太多的内存。</p> 
 <p><strong>方法</strong>：通过对少量keys进行取样(50%)，然后回收其中一个最好的key。</p> 
 <p><strong>配置方式</strong>：maxmemory-samples 5</p> 
</blockquote> 
<h4>
<a id="5LFU_525"></a><strong>5、LFU算法</strong>
</h4> 
<p><strong>LFU：根据数据的历史访问频率来沟汰数据</strong></p> 
<blockquote> 
 <p><strong>核心思想</strong>：如果数据过去被访问多次,那么将来被访问的频率也更高。</p> 
 <p>启用LFU算法后，可以使用热点数据分析功能。</p> 
</blockquote> 
<h3>
<a id="516__533"></a><strong>5.1.6 主从复制</strong>
</h3> 
<h4>
<a id="1_535"></a><strong>1、介绍</strong>
</h4> 
<p><strong>为什么要主从复制</strong></p> 
<blockquote> 
 <p>redis-server单点故障</p> 
 <p>单节点QPS有限</p> 
</blockquote> 
<p><strong>应用场景分析</strong></p> 
<blockquote> 
 <p>读写分离场景，规避redis单机瓶颈</p> 
 <p>故障切换，master出问题后还有slave节点可以使用</p> 
</blockquote> 
<h4>
<a id="2_549"></a><strong>2、搭建主从复制</strong>
</h4> 
<p><strong>主Redis Server以普通模式启动，主要是启动从服务器的方式</strong></p> 
<ol>
<li> <p>命令行</p> <pre><code class="prism language-bash"><span class="token comment">#连接需要实现从节点的rediS,执行下面的命令</span>
slaveof <span class="token punctuation">[</span>ip<span class="token punctuation">]</span> <span class="token punctuation">[</span>port<span class="token punctuation">]</span>
</code></pre> </li>
<li> <p>redis.conf配置文件</p> <pre><code class="prism language-bash"><span class="token comment">#配置文件中增加</span>
slaveof <span class="token punctuation">[</span>ip<span class="token punctuation">]</span> <span class="token punctuation">[</span>port<span class="token punctuation">]</span>
<span class="token comment">#从服务器是否只读(默认yes)</span>
slave-read-only <span class="token function">yes</span>
</code></pre> </li>
<li> <p>退出主从集群的方式</p> <pre><code class="prism language-bash">slaveof no one
</code></pre> </li>
</ol> 
<h4>
<a id="3_579"></a><strong>3、检查主从复制</strong>
</h4> 
<pre><code class="prism language-bash"><span class="token comment">#redis客户端执行</span>
info replication
</code></pre> 
<h4>
<a id="4_586"></a><strong>4、主从复制流程</strong>
</h4> 
<blockquote> 
 <ol>
<li>从服务器通过psync命令发送服务器已有的同步进度(同步源ID，同步进度offset)</li>
<li>master收到请求，同步源为当前master，则根据偏移量增量同步</li>
<li>同步源非当前master，则进入全量同步：maser生成rdb，传输到slave，加载到slave内存</li>
</ol> 
</blockquote> 
<h4>
<a id="5_592"></a><strong>5、主从复制核心知识</strong>
</h4> 
<blockquote> 
 <ol>
<li>Redis默认使用异步复制，slave和master之间异步地确认处理的数据量</li>
<li>一个master可以拥有多个slave</li>
<li>Slave可以接受其他slave的连接。slave可以有下级sub slave</li>
<li>主从同步过程在master侧是非阻塞的</li>
<li>slave初次同步需要删除旧数据，加载新数据，会阻塞到来的连接请求</li>
</ol> 
</blockquote> 
<h4>
<a id="6_600"></a><strong>6、应用场景</strong>
</h4> 
<blockquote> 
 <ol>
<li>主从复制可以用来支持读写分离</li>
<li>slave服务器设定为只读，可以用在数据安全的场景下。</li>
<li>可以使用主从复制来避免master持久化造成的开销。master关闭持久化，slave设置为不定期保存或开启AOF</li>
<li>
<strong>注意</strong>：重新启动的master程序将从一个空数据集开始,如果一个slave试图与它同步，那么这个slave也会被清空。</li>
</ol> 
</blockquote> 
<h4>
<a id="7_607"></a><strong>7、注意事项</strong>
</h4> 
<ol>
<li> <p>读写分离场景:</p> 
  <blockquote> 
   <p>数据复制延时导致读到过期数据或者读不到数据(网络原因，slave阻塞)</p> 
   <p>从节点故障(多个client如何迁移)</p> 
  </blockquote> </li>
<li> <p>全量复制情况下:</p> 
  <blockquote> 
   <p>第一次建立主从关系或者runid不匹配会导致全量复制</p> 
   <p>故障转移的时候也会出现全量复制</p> 
  </blockquote> </li>
<li> <p>复制风暴:</p> 
  <blockquote> 
   <p>master故障重启，如果slave节点过多，所有slave都要复制，对服务器的性能，网络的压力都有很大影响。</p> 
   <p>如果一个机器部署了多个master</p> 
  </blockquote> </li>
<li> <p>写能力有限</p> 
  <blockquote> 
   <p>主从复制还是只有一台master，提供的写服务能力有限</p> 
  </blockquote> </li>
<li> <p>master故障情况下:</p> 
  <blockquote> 
   <p>如果是mater无持久化，Slave开启持久化来保留数据的场展，建议不要配置redis自动重启。</p> 
   <p>启动redis自动重启，master启动后，无备份数据，可能导致集群数据丢失的情况</p> 
  </blockquote> </li>
<li> <p>带有效期的key:</p> 
  <blockquote> 
   <p>Slave不会让key过期，而是等待master让key过期</p> 
   <p>在Lua脚本执行期间，不执行任何key过期操作</p> 
  </blockquote> </li>
</ol> 
<h3>
<a id="517__643"></a><strong>5.1.7 哨兵模式</strong>
</h3> 
<h4>
<a id="1Sentinel_645"></a><strong>1、哨兵(Sentinel)机制核心作用</strong>
</h4> 
<p><img src="https://images2.imgbox.com/09/d3/4qXOWS9m_o.png" alt="请添加图片描述"></p> 
<h4>
<a id="2_647"></a><strong>2、核心运作流程</strong>
</h4> 
<p><strong>服务发现和健康检查流程</strong></p> 
<blockquote> 
 <p>搭建redis主从集群 ==&gt; 启动哨兵(客户端通过哨兵发现Redis实例信息) ==&gt; 哨兵通过连接master发现主从集群内的所有实例信息 ==&gt; 哨兵监控redis实例的健康状况</p> 
</blockquote> 
<p><strong>故障切换流程</strong></p> 
<blockquote> 
 <p>哨兵一旦发现master不能正常提供服务，则通知给其他哨兵 ==&gt; 当一定数量的哨兵都认为master挂了 ==&gt; 选举一个哨兵作为故障转移的执行者 ==&gt; 执行者在slave中选取一个作为新的master ==&gt; 将其他slave重新设定为新master的从属</p> 
</blockquote> 
<h4>
<a id="3Redis_657"></a><strong>3、哨兵如何知道Redis主从信息</strong>
</h4> 
<blockquote> 
 <p>哨兵配置文件中，保存着主从集群中master的信息，可以通过info replication命令，进行主从信息自动发现。</p> 
</blockquote> 
<h4>
<a id="4sdown_661"></a><strong>4、什么是主观下线(sdown)</strong>
</h4> 
<blockquote> 
 <p><strong>主观下线</strong>：单个哨兵自身认为redis实例已经不能提供服务</p> 
 <p><strong>检测机制</strong>：哨兵向redis发送ping请求，+PONG，-LOADING，-MASTERDOWN三种情况视为正常，其他回复均视为无效</p> 
 <p>对应配置文件的配置项：sentinel down-after-milliseconds mymaster 1000</p> 
</blockquote> 
<h4>
<a id="5odown_669"></a><strong>5、什么是客观下线(odown)</strong>
</h4> 
<blockquote> 
 <p><strong>客观下线</strong>：一定数量值的哨兵认为master已经下线。</p> 
 <p><strong>检测机制</strong>：当哨兵主观认为maser下线后，则会通过SENTINEL is-master-down-by-addr命令询问其他哨兵是否认为master已经下线，如果达成共识（达到quorum个数），就会认为master节点客观下线，开始故障转移流程</p> 
 <p>对应配置文件的配置项：sentinel monitor mymaster 1.0.0.1 6380 2</p> 
</blockquote> 
<h4>
<a id="6_677"></a><strong>6、哨兵之间如何通信</strong>
</h4> 
<ol>
<li>哨兵之间的自动发现：发布自己的信息，订阅其他哨兵消息（pub/sub）</li>
<li>哨兵之间通过命令进行通信：直连发送命令</li>
<li>哨兵之间通过订阅发布进行通信：相互订阅指定主题（pub/sub）</li>
</ol> 
<h4>
<a id="7_683"></a><strong>7、哨兵领导选举机制</strong>
</h4> 
<p><strong>基于Raft算法实现的选举机制，流程简述如下:</strong></p> 
<ol>
<li>拉票阶段：每个哨兵节点希望自己成为领导者;</li>
<li>Sentinel节点收到拉票命令后，如果没有收到或同意过其他sentinel节点的请求，就同意该sentinel节点的请求(每个sentinel只持有一个同意票数)</li>
<li>如果sentinel节点发现自己的票数已经超过一半的数值，那么它将成为领导者，去执行故障转移</li>
<li>投票结束后，如果超过failover-timeout的时间内，没进行实际的故障转移操作，则重新拉票选举。</li>
</ol> 
<h4>
<a id="8slave_692"></a><strong>8、slave选举方案</strong>
</h4> 
<blockquote> 
 <p>slave节点状态 &gt; 优先级 &gt; 数据同步情况 &gt; 最小的run id</p> 
</blockquote> 
<h4>
<a id="9_696"></a><strong>9、最终主从切换的过程</strong>
</h4> 
<blockquote> 
 <p>针对即将成为master的slave节点，将其撒出主从集群，自动执行：slaveof NO ONE</p> 
 <p>针对其他slave节点，使它们成为新master的从属，自动执行：slaveof new_master_host new_master_port</p> 
</blockquote> 
<h4>
<a id="10_702"></a><strong>10、哨兵服务部署方案</strong>
</h4> 
<blockquote> 
 <p><strong>不推荐</strong>：一主一从，两个哨兵</p> 
 <p><strong>推荐</strong>：一主两从，三个哨兵</p> 
 <p><strong>redis集群非强一致</strong>：一主两从,网络分区下可能出现数据不一致或丢失。</p> 
</blockquote> 
<h3>
<a id="518_redis_710"></a><strong>5.1.8 redis集群分片存储</strong>
</h3> 
<h4>
<a id="1_712"></a><strong>1、为什么要分片存储</strong>
</h4> 
<blockquote> 
 <p>redis的内存需求可能超过机器的最大内存。(一台机器不够用)</p> 
</blockquote> 
<h4>
<a id="2_716"></a><strong>2、官方集群方案</strong>
</h4> 
<blockquote> 
 <p>redis cluster是redis的分布式集科解决方案，在3.0版本推出后有效地解决了redis分布式分面的需求，实现了数据在多个Redis节点之间自动分片,故障自动转移,扩容机制等功能。</p> 
 <p>主要基于CRC16(key) % 16384 计算出每个key对应的slot，然后根据redis集群中实例的预设槽slot（16384个）进行对应的操作，slot不存储数据，仅仅用来做片区划分。</p> 
</blockquote> 
<h4>
<a id="3_722"></a><strong>3、搭建集群</strong>
</h4> 
<blockquote> 
 <ol>
<li>准备6个独立的redis服务</li>
<li>通过redis-cli工具创建集群</li>
<li>检验集群</li>
<li>故障转移测试</li>
<li>集群扩容</li>
<li>集群节点删除</li>
</ol> 
</blockquote> 
<h4>
<a id="4_731"></a><strong>4、集群关心的问题</strong>
</h4> 
<ol>
<li> <p>增加了slot槽的计算,是不是比单机性能差?</p> 
  <blockquote> 
   <p>不是的，为了避免每次都需要服务器计算重定向，优秀的Java客户端都实现了本地计算，并且缓存服务器slots分配，有变动时再更新本地内容，从而避免了多次重定向带来的性能损耗。</p> 
  </blockquote> </li>
<li> <p>redis集群大小,到底可以装多少数据?</p> 
  <blockquote> 
   <p>理论是可以做到16384个槽，每个槽对应一个实例，但是redis宫方建议是最大1000个实例，因为存储已经足够大了。</p> 
  </blockquote> </li>
<li> <p>集群节点间是怎么通信的?</p> 
  <blockquote> 
   <p>每个Redis群集节点都有一个额外的TCP端口，每个节点使用TCP连接与每个其他节点连接。检测和故障转移这些步骤基本和哨兵模式类似。</p> 
  </blockquote> </li>
<li> <p>ask和moved重定向的区别</p> <p><strong>重定向包括两种情况</strong></p> 
  <blockquote> 
   <p>若确定slot不属于当前节点，redis会返回moved。</p> 
   <p>若当前redis节点正在处理slot迁移，则代表此处请求对应的key暂时不在此节点，返回ask，告诉客户端本次请求重定向。</p> 
  </blockquote> </li>
<li> <p>数据倾斜和访问倾斜的问题</p> <p><strong>倾斜导致集群中部分节点数据多，压力大。解决方案分为前期和后期:</strong></p> 
  <blockquote> 
   <p>前期是业务层面提前预测，哪些key是热点，在设计的过程中规避。</p> 
   <p>后期是slot迁移，尽量将压力分摊(slot调整有自动rebalance、reshard和手动)。</p> 
  </blockquote> </li>
<li> <p>slot手动迁移怎么做?</p> 
  <blockquote> 
   <ol>
<li>在迁移目的节点执行cluster setslot IMPORTING 命令，指明需要迁移的slot和迁移源节点。</li>
<li>在迁移源节点执行cluster setslot MIGRATING 命令，指明需要迁移的slot和迁移目的节点。</li>
<li>在迁移源节点执行cluster getkeysinslot获取该slot的key列表</li>
<li>在迁移源节点执行对每个key执行migrate命令，该命令会同步把该key迁移到目的节点。</li>
<li>在迁移源节点反复执行cluster getkeysinslo命令，直到该slot的列表为空。</li>
<li>在迁移源节点和目的节点执行cluster setslot NODE ，完成迁移操作。</li>
</ol> 
  </blockquote> </li>
<li> <p>节点之间会交换信息，传递的消息包括槽的信息，带来带宽消耗。<strong>注意</strong>：避免使用大的一个集群,可以分多个集群。</p> </li>
<li> <p>Pub/Sub发布订阅机制：对集群内任意的一个节点执行pubish发布消息，这个消息会在集群中进行传播，其他节点都接收到发布的消息。</p> </li>
<li> <p>读写分离：</p> 
  <blockquote> 
   <p>redis-cluster默认所有<strong>从节点上的读写</strong>，都会重定向到key对应槽的主节点上。</p> 
   <p>可以通过readonly设置当前连接可读，通过readwrite取消当前连接的可读状态。</p> 
   <p><strong>注意</strong>：主从节点依然存在数据不一致的问题</p> 
  </blockquote> </li>
</ol> 
<h3>
<a id="519_redis_784"></a><strong>5.1.9 redis监控</strong>
</h3> 
<h4>
<a id="1monitor_786"></a><strong>1、monitor命令</strong>
</h4> 
<p>monitor是一个调试命令，返回服务器处理的每个命令。对于发现程序的错误非常有用。出于安全考虑，某些特殊管理命令CONFIG不会记录到MONITOR输出。</p> 
<p><strong>注意</strong>：运行一个MONITOR命令能够降低50%的吞吐量，运行多个MONITOR命令降低的吞吐量更多。</p> 
<h4>
<a id="2info_792"></a><strong>2、info命令</strong>
</h4> 
<p>INFO命令以一种易于理解和阅读的格式，返回关于Redis服务器的各种信息和统计数值。</p> 
<table>
<thead><tr>
<th>info命令</th>
<th>返回信息</th>
</tr></thead>
<tbody>
<tr>
<td>server</td>
<td>Redis服务器的一般信息</td>
</tr>
<tr>
<td>clients</td>
<td>客户端的连接部分</td>
</tr>
<tr>
<td>memory</td>
<td>内存消耗相关信息</td>
</tr>
<tr>
<td>persistence</td>
<td>持久化相关信息</td>
</tr>
<tr>
<td>stats</td>
<td>一般统计</td>
</tr>
<tr>
<td>replication</td>
<td>主/从复制信息</td>
</tr>
<tr>
<td>cpu</td>
<td>统计CPU的消耗</td>
</tr>
<tr>
<td>commandstats</td>
<td>Redis命令统计</td>
</tr>
<tr>
<td>cluster</td>
<td>Redis集群信息</td>
</tr>
<tr>
<td>keyspace</td>
<td>数据库的相关统计</td>
</tr>
</tbody>
</table>
<p>可以通过section返回部分信息，如果没有使用任何参数时，默认为detault。</p> 
<h4>
<a id="3_RedisLive_811"></a><strong>3、图形化监控工具： Redis-Live</strong>
</h4> 
<h2>
<a id="52_memcached_815"></a><strong>5.2 memcached入门</strong>
</h2> 
<h3>
<a id="memcached_817"></a><strong>由于memcached慢慢淡出了人们的视野，使用的公司越来越少，所以这里只是做个入门介绍。</strong>
</h3> 
<h3>
<a id="1_819"></a><strong>1、简介</strong>
</h3> 
<p><strong>是一个免费开源的、高性能的、具有分布式内存对象的缓存系统，它通过减轻数据库负载加速动态web应用。</strong></p> 
<blockquote> 
 <p>本质上就是一个内存key-Value缓存</p> 
 <p>协议简单，使用的是基于文本行的协议</p> 
 <p>不支持数据的持久化，服务器关闭之后数据全部丢失</p> 
 <p>Memcached简洁而强大，便于快速开发，上手较为容易</p> 
 <p>没有安全机制</p> 
</blockquote> 
<h3>
<a id="2_833"></a><strong>2、设计理念</strong>
</h3> 
<ol>
<li> <p>简单的键/值存储：服务器不关心你的数据是什么样的，只管数据存储</p> </li>
<li> <p>服务端功能简单，很多逻辑依赖客户端实现</p> 
  <blockquote> 
   <p>客户端专注如何选择读取或写入的服务器，以及无法联系服务器时要执行的操作。</p> 
   <p>服务器专注如何存储和管理何时清除或重用内存</p> 
  </blockquote> </li>
<li> <p>Memcached实例之间没有通信机制</p> </li>
<li> <p>每个命令的复杂度为0(1)：慢速机器上的查询应该在1ms以下运行。高端服务器的吞吐量可以达到每秒数百万</p> </li>
<li> <p>缓存自动清除机制</p> </li>
<li> <p>缓存失效机制</p> </li>
</ol> 
<h3>
<a id="3_851"></a><strong>3、常用命令</strong>
</h3> 
<table>
<thead><tr>
<th>分组</th>
<th>命令</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>存储命令</td>
<td>set</td>
<td>用于将value存储在指定的key中。key已经存在，更新该key所对应的原来的数据。</td>
</tr>
<tr>
<td></td>
<td>add</td>
<td>用于将value存储在指定的key中，存在则不更新。</td>
</tr>
<tr>
<td></td>
<td>replace</td>
<td>替换已存在的key的Value，不存在，则替换失败。</td>
</tr>
<tr>
<td></td>
<td>append</td>
<td>用于向已存在key的value后面追加数据</td>
</tr>
<tr>
<td></td>
<td>prepend</td>
<td>向已存在key的value前面追加数据</td>
</tr>
<tr>
<td></td>
<td>cas</td>
<td>比较和替换，比对后，没有被其他客户端修改的情况下才能写入。</td>
</tr>
<tr>
<td>检索命令</td>
<td>get</td>
<td>获取存储在key中的value，不存在，则返回空。</td>
</tr>
<tr>
<td></td>
<td>gets</td>
<td>获取带有CAS令牌存的value，若key不存在，则返回为空</td>
</tr>
<tr>
<td>删除</td>
<td>delete</td>
<td>删除已存在的key</td>
</tr>
<tr>
<td>计算</td>
<td>incr/decr</td>
<td>对已存在的key的数字值进行自增或自减操作</td>
</tr>
<tr>
<td>统计</td>
<td>stats</td>
<td>返回统计信息如PID(进程号)、版本号、连接数等</td>
</tr>
<tr>
<td></td>
<td>stats items</td>
<td>显示各个slab中item的数目和存储时长(最后一次访问距离现在的秒数)</td>
</tr>
<tr>
<td></td>
<td>stats slabs</td>
<td>显示各个slab的信息，包括chunk的大小、数目、使用情况等。</td>
</tr>
<tr>
<td></td>
<td>stats sizes</td>
<td>显示所有item的大小和个数</td>
</tr>
<tr>
<td>清除</td>
<td>flush_all</td>
<td>清除所有内容</td>
</tr>
</tbody>
</table>
<h3>
<a id="4_871"></a><strong>4、客户端使用</strong>
</h3> 
<p>客户端支持的特性：集群下多服务器选择，节点权重配置，失败/故障转移，数据压缩，连接管理</p> 
<h3>
<a id="5_875"></a><strong>5、服务端配置</strong>
</h3> 
<ol>
<li> <p>命令行参数</p> 
  <blockquote> 
   <p>查看memcached-h或man memcached获取最新文档</p> 
  </blockquote> </li>
<li> <p>init脚本</p> 
  <blockquote> 
   <p>如果通过yum应用商店安装，可以使用/etc/sysconfig/memcached文件进行参数配置</p> 
  </blockquote> </li>
<li> <p>检查运行配置</p> 
  <blockquote> 
   <p>stats settings查看运行中的memcached的配置</p> 
  </blockquote> </li>
</ol> 
<h3>
<a id="6memcached_889"></a><strong>6、memcached性能</strong>
</h3> 
<p>Memcached性能的关键是硬件，内部实现是hash表，读写操作都是0(1)。硬件好，几百万的OPS都是没问题的。</p> 
<p><strong>最大连接数限制</strong>：内部基于事件机制(类似JAVA NIO)所以这个限制和nio类似，只要内存，操作系统参数进行调整，轻松几十万。</p> 
<p><strong>集群节点数量限制</strong>：理论是没限制的，但是节点越多，客户端需要建立的连接就会越多。</p> 
<p><strong>注意</strong>：memcached服务端没有分布式的功能，所以不论是集群还是主从备份，都需要第三方产品支持。</p> 
<h3>
<a id="7_899"></a><strong>7、服务器硬件需要</strong>
</h3> 
<p><strong>CPU要求</strong>：CPU占用率低，默认为4个工作线程</p> 
<p><strong>内存要求</strong>：</p> 
<blockquote> 
 <p>memcached内容存在内存里面，所有内存使用率高。</p> 
 <p>建议memcached实例独占服务器,而不是混用。</p> 
 <p>建议每个memcached实例内存大小都足一致的，如果不一致则需要进行权重调整</p> 
</blockquote> 
<p><strong>网络要求</strong>：</p> 
<blockquote> 
 <p>根据项目传输的内容来定，网络越大越好，虽然通常10M就够用了</p> 
 <p>建议:项目往memcached传输的内容保持尽可能的小</p> 
</blockquote> 
<p><strong>8、Memcached应用场景</strong></p> 
<blockquote> 
 <ol>
<li>
<strong>数据查询缓存</strong>：将数据库中的数据加载到memcached，提供程序的访问速度</li>
<li>
<strong>计数器的场景</strong>：通过incr/decr命令实现评论数量、点击数统计，操作次数等等场景。</li>
<li>
<strong>乐观锁实现</strong>：例如计划任务多实例部暑的场景下，通过CAS实现不重复执行</li>
<li>
<strong>防止重复处理</strong>：CAS命令</li>
</ol> 
</blockquote> 
<h2>
<a id="53__924"></a><strong>5.3 互联网高并发缓存架构</strong>
</h2> 
<h3>
<a id="531__926"></a><strong>5.3.1 缓存架构分析图</strong>
</h3> 
<p><img src="https://images2.imgbox.com/ec/d7/gJMRn74F_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="532__931"></a><strong>5.3.2 缓存雪崩</strong>
</h3> 
<p><strong>定义</strong>：因为缓存服务挂掉或者热点缓存失效，从而导致所有请求都去查数据库，导致数据库连接不够用或者数据库处理不过来，从而导致整个系统不可用。</p> 
<p><strong>常用解决方案</strong>：</p> 
<blockquote> 
 <ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>缓存降级，直接返回错误码；</li>
<li>加锁实现防止大量请求堆到数据库。</li>
<li>设置热点数据永远不过期，防止了自动失效的情况，通过其他后台检查程序，防止缓存数据和数据库长期不同步</li>
</ol> 
</blockquote> 
<h3>
<a id="532__942"></a><strong>5.3.2 缓存击穿</strong>
</h3> 
<p><strong>定义</strong>：查询必然不存在的数据，请求透过Redis，直击数据库。</p> 
<p><strong>常用解决方案</strong>：</p> 
<blockquote> 
 <ol>
<li>用户内容预生成。</li>
<li>访问频率限制。</li>
<li>缓存中无数据，也不查询数据库，直接返回错误码。</li>
<li>布隆过滤器</li>
</ol> 
</blockquote>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>