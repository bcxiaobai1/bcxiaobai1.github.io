<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>SQL语句知识大全 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SQL语句知识大全</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h3>
<a id="_2"></a>目录导航</h3> 
<ul>
<li><a href="#SQL_1">一、SQL简介</a></li>
<li> 
  <ul>
<li><a href="#1_9">1.什么是数据库</a></li>
<li><a href="#2_17">2.数据库分类</a></li>
<li><a href="#3SQL__28">3.SQL 是什么？</a></li>
<li><a href="#4SQL__34">4.SQL 能做什么？</a></li>
<li><a href="#5RDBMS_47">5.RDBMS</a></li>
</ul> </li>
<li><a href="#_57">二、基础语法</a></li>
<li> 
  <ul>
<li><a href="#1_59">1.创建数据库</a></li>
<li><a href="#2_63">2.删除数据库</a></li>
<li><a href="#3_67">3.创建表</a></li>
<li><a href="#4_76">4.删除新表</a></li>
<li><a href="#5_80">5.增加一个列</a></li>
<li><a href="#6_86">6.添加主键</a></li>
<li><a href="#7_93">7.创建索引</a></li>
<li><a href="#8_101">8.创建视图</a></li>
<li><a href="#9tablesql_107">9.几个简单的table操作的sql语句</a></li>
<li> 
    <ul>
<li><a href="#_109">**选择：**</a></li>
<li><a href="#_113">**插入：**</a></li>
<li><a href="#_117">**删除：**</a></li>
<li><a href="#_121">**范围更新**：</a></li>
<li><a href="#_125">**范围查找**</a></li>
<li><a href="#_129">**排序**：</a></li>
<li><a href="#_133">**总数**：</a></li>
<li><a href="#_137">**求和**：</a></li>
<li><a href="#_141">**平均**：</a></li>
<li><a href="#_145">**最大**：</a></li>
<li><a href="#_149">**最小**：</a></li>
</ul> </li>
<li><a href="#10_153">10.几个高级查询运算词</a></li>
<li> 
    <ul>
<li><a href="#UNION__155">**UNION 运算符**</a></li>
<li><a href="#EXCEPT__159">EXCEPT 运算符</a></li>
<li><a href="#INTERSECT__163">INTERSECT 运算符</a></li>
</ul> </li>
<li><a href="#11_168">11.使用外连接</a></li>
<li> 
    <ul>
<li><a href="#111left_join_172">11.1.left join</a></li>
<li><a href="#112right_join_180">11.2.right join</a></li>
<li><a href="#113fullcross_join_184">11.3.full/cross join</a></li>
<li><a href="#_188">案例</a></li>
</ul> </li>
<li><a href="#12_232">12.如何修改数据库的名称</a></li>
<li><a href="#13_238">13.临时表</a></li>
<li> 
    <ul>
<li><a href="#131_240">13.1.临时表的概念</a></li>
<li><a href="#132_246">13.2.临时表的创建、使用和删除</a></li>
<li> 
      <ul>
<li><a href="#1321SQL_Server_248">13.2.1.SQL Server</a></li>
<li> 
        <ul>
<li><a href="#_250">创建：</a></li>
<li><a href="#_282">使用：</a></li>
<li><a href="#_290">删除：</a></li>
</ul> </li>
<li><a href="#1322Mysql_298">13.2.2.Mysql</a></li>
<li> 
        <ul>
<li><a href="#_300">创建：</a></li>
<li><a href="#_319">使用：</a></li>
<li><a href="#_327">删除：</a></li>
</ul> </li>
<li><a href="#1323Oracle_335">13.2.3.Oracle</a></li>
<li> 
        <ul>
<li><a href="#_339">创建：</a></li>
<li><a href="#_358">使用：</a></li>
<li><a href="#_364">删除：</a></li>
</ul> </li>
</ul> </li>
<li><a href="#133_372">13.3.临时表的应用</a></li>
</ul> </li>
</ul> </li>
<li><a href="#SQL_379">三.SQL语句提升</a></li>
<li> 
  <ul>
<li><a href="#1_381">1.复制表</a></li>
<li><a href="#2_390">2.拷贝表</a></li>
<li><a href="#3_406">3.跨数据库之间表的拷贝</a></li>
<li><a href="#4_415">4.子查询</a></li>
<li><a href="#5_425">5.显示文章、提交人和最后回复时间</a></li>
<li><a href="#6_431">6.外连接查询</a></li>
<li><a href="#7_439">7.在线视图查询</a></li>
<li><a href="#8between_447">8.between的用法</a></li>
<li><a href="#9in__455">9.in 的使用方法</a></li>
<li><a href="#10_461">10.两张关联表，删除主表中已经在副表中没有的信息</a></li>
<li><a href="#11_467">11.四表联查问题</a></li>
<li><a href="#12_473">12.日程安排提前五分钟提醒</a></li>
<li><a href="#13sql__479">13.一条sql 语句搞定数据库分页</a></li>
<li><a href="#1410_498">14.前10条记录</a></li>
<li><a href="#1510_504">15.随机取出10条数据</a></li>
<li><a href="#16_510">16.随机选择记录</a></li>
<li><a href="#17_516">17.删除重复记录</a></li>
<li><a href="#18_536">18.列出数据库里所有的表名</a></li>
<li><a href="#19_542">19.列出表里的所有的列名</a></li>
<li><a href="#20table1_548">20.初始化表table1</a></li>
<li><a href="#211015_554">21.选择从10到15的记录</a></li>
</ul> </li>
<li><a href="#_560">四、开发技巧</a></li>
<li><a href="#_754">五、数据开发-经典</a></li>
<li> 
  <ul>
<li><a href="#1_756">1.按姓氏笔画排序:</a></li>
<li><a href="#2_760">2.数据库加密:</a></li>
<li><a href="#3_773">3.取回表中字段:</a></li>
<li><a href="#4_783">4.查看硬盘分区:</a></li>
<li><a href="#5AB_789">5.比较A,B表是否相等:</a></li>
<li><a href="#6_800">6.杀掉所有的事件探察器进程:</a></li>
<li><a href="#7_808">7.记录搜索:</a></li>
<li><a href="#9_858">9：获取当前数据库中的所有用户表</a></li>
<li><a href="#10_864">10：获取某一个表的所有字段</a></li>
<li><a href="#11_876">11：查看与某一个表相关的视图、存储过程、函数</a></li>
<li><a href="#12_882">12：查看当前数据库中所有存储过程</a></li>
<li><a href="#13_888">13：查询用户创建的所有数据库</a></li>
<li><a href="#14_896">14：查询某一个表的字段和数据类型</a></li>
<li><a href="#15_903">15：不同服务器数据库之间的数据操作</a></li>
</ul> </li>
<li><a href="#SQL_Server_1032">六、SQL Server基本函数</a></li>
<li> 
  <ul><li><a href="#1__1036">1.字符串函数 长度与分析用</a></li></ul> </li>
</ul> 
<h1>
<a id="SQL_98"></a>一、SQL简介</h1> 
<p><strong>SQL</strong> (Structured Query Language：结构化查询语言)</p> 
<p>是用于管理关系数据库管理系统（RDBMS）。</p> 
<p>SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p> 
<h2>
<a id="1_107"></a>1.什么是数据库</h2> 
<p>数据库 (DB database)</p> 
<p>概念:数据仓库 软件 安装在操作系统之上 可以存储大量的数据 500w</p> 
<p>作用:存储数据 管理数据</p> 
<h2>
<a id="2_116"></a>2.数据库分类</h2> 
<p>关系型数据库 (SQL)</p> 
<p>MySQL Oracle SqlServer DB2 SQLite<br> 通过表和表之间 行和列之间的关系进行数据的存储 学员信息表 考勤表…<br> 非关系型数据库(noSQL) Not Only</p> 
<p>Redis mongDB<br> 非关系型数据库 对象存储 通过对象的自身的属性来决定</p> 
<h2>
<a id="3SQL__128"></a>3.SQL 是什么？</h2> 
<ul>
<li>SQL 指结构化查询语言，全称是 Structured Query Language。</li>
<li>SQL 让您可以访问和处理数据库，包括数据插入、查询、更新和删除。</li>
<li>SQL 在1986年成为 ANSI（American National Standards Institute 美国国家标准化组织）的一项标准，在 1987 年成为国际标准化组织（ISO）标准。</li>
</ul> 
<h2>
<a id="4SQL__135"></a>4.SQL 能做什么？</h2> 
<ul>
<li>SQL 面向数据库执行查询</li>
<li>SQL 可从数据库取回数据</li>
<li>SQL 可在数据库中插入新的记录</li>
<li>SQL 可更新数据库中的数据</li>
<li>SQL 可从数据库删除记录</li>
<li>SQL 可创建新数据库</li>
<li>SQL 可在数据库中创建新表</li>
<li>SQL 可在数据库中创建存储过程</li>
<li>SQL 可在数据库中创建视图</li>
<li>SQL 可以设置表、存储过程和视图的权限</li>
</ul> 
<h2>
<a id="5RDBMS_149"></a>5.RDBMS</h2> 
<p>RDBMS 指关系型数据库管理系统，全称 Relational Database Management System。</p> 
<p>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。</p> 
<p>RDBMS 中的数据存储在被称为表的数据库对象中。</p> 
<p>表是相关的数据项的集合，它由列和行组成。</p> 
<h1>
<a id="_160"></a>二、基础语法</h1> 
<h2>
<a id="1_163"></a>1.创建数据库</h2> 
<p>create database db-name</p> 
<h2>
<a id="2_168"></a>2.删除数据库</h2> 
<p>drop database db-name</p> 
<h2>
<a id="3_173"></a>3.创建表</h2> 
<p>create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],…)</p> 
<p><strong>根据已有的表创建新表：</strong></p> 
<p>**A：**create table tab_new like tab_old (使用旧表创建新表)<br> **B：**create table tab_new as select col1,col2… from tab_old definition only</p> 
<h2>
<a id="4_183"></a>4.删除新表</h2> 
<p>drop table tabname</p> 
<h2>
<a id="5_188"></a>5.增加一个列</h2> 
<p>Alter table tabname add column col type</p> 
<p><strong>注</strong>：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。</p> 
<h2>
<a id="6_195"></a>6.添加主键</h2> 
<p><strong>Alter table tabname add primary key(col)</strong><br> 说明：</p> 
<p>删除主键：Alter table tabname drop primary key(col)</p> 
<h2>
<a id="7_203"></a>7.创建索引</h2> 
<p><strong>create [unique] index idxname on tabname(col….)</strong></p> 
<p>删除索引：drop index idxname</p> 
<p><strong>注：索引是不可更改的，想更改必须删除重新建。</strong></p> 
<h2>
<a id="8_212"></a>8.创建视图</h2> 
<p><strong>create view viewname as select statement</strong></p> 
<p><strong>删除视图</strong>：drop view viewname</p> 
<h2>
<a id="9tablesql_219"></a>9.几个简单的table操作的sql语句</h2> 
<h3>
<a id="_222"></a><strong>选择：</strong>
</h3> 
<p>select * from table1 where 范围</p> 
<h3>
<a id="_226"></a><strong>插入：</strong>
</h3> 
<p>insert into table1(field1,field2) values(value1,value2)</p> 
<h3>
<a id="_230"></a><strong>删除：</strong>
</h3> 
<p>delete from table1 where</p> 
<h3>
<a id="_234"></a><strong>范围更新</strong>：</h3> 
<p>update table1 set field1=value1 where</p> 
<h3>
<a id="_238"></a><strong>范围查找</strong>
</h3> 
<p>select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料!</p> 
<h3>
<a id="_242"></a><strong>排序</strong>：</h3> 
<p>select * from table1 order by field1,field2 [desc]</p> 
<h3>
<a id="_246"></a><strong>总数</strong>：</h3> 
<p>select count as totalcount from table1</p> 
<h3>
<a id="_250"></a><strong>求和</strong>：</h3> 
<p>select sum(field1) as sumvalue from table1</p> 
<h3>
<a id="_254"></a><strong>平均</strong>：</h3> 
<p>select avg(field1) as avgvalue from table1</p> 
<h3>
<a id="_258"></a><strong>最大</strong>：</h3> 
<p>select max(field1) as maxvalue from table1</p> 
<h3>
<a id="_262"></a><strong>最小</strong>：</h3> 
<p>select min(field1) as minvalue from table1</p> 
<h2>
<a id="10_266"></a>10.几个高级查询运算词</h2> 
<h3>
<a id="UNION__269"></a><strong>UNION 运算符</strong>
</h3> 
<p>UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。</p> 
<h3>
<a id="EXCEPT__273"></a>EXCEPT 运算符</h3> 
<p><strong>EXCEPT</strong>运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p> 
<h3>
<a id="INTERSECT__277"></a>INTERSECT 运算符</h3> 
<p><strong>INTERSECT</strong>运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 <strong>ALL</strong>随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。<br> **注：**使用运算词的几个查询结果行必须是一致的。</p> 
<h2>
<a id="11_282"></a>11.使用外连接</h2> 
<p><img src="https://images2.imgbox.com/d2/61/EQLWFTcq_o.png" alt="img"></p> 
<h3>
<a id="111left_join_287"></a>11.1.left join</h3> 
<p>left （outer） join：左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。</p> 
<pre><code>select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c
</code></pre> 
<h3>
<a id="112right_join_294"></a>11.2.right join</h3> 
<p>right （outer） join:右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。</p> 
<h3>
<a id="113fullcross_join_298"></a>11.3.full/cross join</h3> 
<p>full/cross （outer） join：全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。</p> 
<h3>
<a id="_302"></a>案例</h3> 
<p>例如有如下关系的数据：</p> 
<p><img src="https://images2.imgbox.com/bc/c7/6NSD2cpR_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4jd5lLPJ-1625900376640)(C:UsersqingcAppDataRoamingTypora	ypora-user-imagesr5802380779.png)]"></p> 
<p>1、inner join</p> 
<p><img src="https://images2.imgbox.com/4d/21/vSMylEQH_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TAzy9gZx-1625900376641)(C:UsersqingcAppDataRoamingTypora	ypora-user-imagesr5803009181.png)]"></p> 
<p>2.1、full outer join等于full join</p> 
<p><img src="https://images2.imgbox.com/bd/17/htzuJKEW_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SzfIJsgx-1625900376642)(C:UsersqingcAppDataRoamingTypora	ypora-user-imagesr5803002553.png)]"></p> 
<p>2.2、full outer join but a.Key is null or b.Key is null</p> 
<p><img src="https://images2.imgbox.com/d2/ee/wrUjknkN_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n9Us5bNr-1625900376645)(C:UsersqingcAppDataRoamingTypora	ypora-user-imagesr5802997725.png)]"></p> 
<p>3.1、left outer join等于left join</p> 
<p><img src="https://images2.imgbox.com/08/a6/8Ineedql_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xvnBIugy-1625900376646)(C:UsersqingcAppDataRoamingTypora	ypora-user-imagesr5802993139.png)]"></p> 
<p>3.2、left outer join but b.Key is null</p> 
<p><img src="https://images2.imgbox.com/36/e2/j7Hs8wlZ_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7jjasjCb-1625900376648)(C:UsersqingcAppDataRoamingTypora	ypora-user-imagesr5802987427.png)]"></p> 
<p>笛卡尔积<br> <img src="https://images2.imgbox.com/e7/6c/CxO5pgY7_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="12_331"></a>12.如何修改数据库的名称</h2> 
<pre><code>sp_renamedb 'old_name', 'new_name'
</code></pre> 
<h2>
<a id="13_337"></a>13.临时表</h2> 
<h3>
<a id="131_340"></a>13.1.临时表的概念</h3> 
<p>在我们操作的表数据量庞大而且又要关联其他表进行查询的时候或者我们操作的数据是临时性数据且在短期内会有很多DML操作(比如购物车)的时候或者我们做查询时需要连接很多个表的时候，如果直接操作数据库的业务表可能效率很低，这个时候我们就可以借助临时表来提升效率。<br> 临时表顾名思义，是一个临时的表，数据库不会将其序列化到磁盘上(有些也会序列化到磁盘上)而是存在于数据库服务器的内存中(因此会增加数据库服务器内存的消耗)，在使用完之后就会销毁。临时表分为两种：会话临时表和全局临时表，区别在于可用的作用域和销毁的时机不同。会话临时表只在当前会话(连接)内可用，且在当前会话结束(断开数据库连接)后就会销毁；全局临时表创建后在销毁之前所有用户都可以访问，销毁的时机是在创建该临时表的连接断开且没有其他会话访问时才销毁，实际上在创建全局临时表的会话断开后，其他用户就已经不能在访问该临时表了，但此时该临时表并不会立即销毁，而是等所有正在使用该全局临时表的会话(或者说连接)断开之后才会销毁。当然有时考虑到内存占用的问题，我们也可以手动销毁(DROP)临时表。<br> 目前大多数数据库厂商(Oracle、Sql Server、Mysql)都支持临时表，但不同的数据库创建和使用临时表的语法稍有不同。</p> 
<h3>
<a id="132_346"></a>13.2.临时表的创建、使用和删除</h3> 
<h4>
<a id="1321SQL_Server_348"></a>13.2.1.SQL Server</h4> 
<h5>
<a id="_350"></a>创建：</h5> 
<p>方式一：</p> 
<pre><code>#会话临时表
CREATE TABLE #临时表名(
	字段1 约束条件1,
	字段2 约束条件2,
	...
);

#全局临时表
CREATE TABLE ##临时表名(
	字段1 约束条件,
	字段2 约束条件,
	...
);
</code></pre> 
<p>方式二：</p> 
<pre><code>#会话临时表
SELECT 字段列表 INTO #临时表名 
FROM 业务表;

#全局临时表
SELECT 字段列表 INTO ##临时表名 
FROM 业务表;
</code></pre> 
<h5>
<a id="_380"></a>使用：</h5> 
<pre><code>#查询临时表
SELECT * FROM #临时表名;
SELECT * FROM ##临时表名;
</code></pre> 
<h5>
<a id="_387"></a>删除：</h5> 
<pre><code>#删除临时表
DROP TABLE #临时表名;
DROP TABLE ##临时表名;
</code></pre> 
<h4>
<a id="1322Mysql_394"></a>13.2.2.Mysql</h4> 
<h5>
<a id="_396"></a>创建：</h5> 
<p>Mysql中没有全局临时表，创建的时候没有#</p> 
<pre><code>CREATE TEMPORARY TABLE [IF NOT EXISTS] 临时表名(
   字段1 约束条件,
   字段2 约束条件,
   ...
);

#根据现有表创建临时表
CREATE TEMPORARY TABLE [IF NOT EXISTS] 临时表名
[AS] SELECT 查询字段
FROM 业务表
[WHERE 条件];
</code></pre> 
<h5>
<a id="_414"></a>使用：</h5> 
<p>创建的临时表可以和业务表同名，若临时表和业务表同名时在该会话中会使用临时表</p> 
<pre><code>SELECT * FROM 临时表名;
</code></pre> 
<h5>
<a id="_421"></a>删除：</h5> 
<p>为避免临时表名和业务表名相同时导致误删除，可以加上TEMPORARY关键字</p> 
<pre><code>DROP [TEMPORARY] TABLE 临时表名;
</code></pre> 
<h4>
<a id="1323Oracle_428"></a>13.2.3.Oracle</h4> 
<p>Oracle的临时表也只有会话级的，但同时又细化出了一个事务级别的临时表，事务级别的临时表只在当前事务中有效。</p> 
<h5>
<a id="_432"></a>创建：</h5> 
<pre><code>#会话级别
CREATE GLOBAL TEMPORARY TABLE 临时表名(
	字段1 约束条件,
	字段2 约束条件,
	...
) ON COMMIT PRESERVE ROWS;

#事务级别
CREATE GLOBAL TEMPORARY TABLE 临时表名(
	字段1 约束条件,
	字段2 约束条件,
	...
) ON COMMIT DELETE ROWS;
</code></pre> 
<h5>
<a id="_450"></a>使用：</h5> 
<pre><code>SELECT * FROM 临时表名;
</code></pre> 
<h5>
<a id="_455"></a>删除：</h5> 
<pre><code>DROP TABLE 临时表名;
</code></pre> 
<p><code>注意</code>：一个SQL中不能同时出现两次临时表</p> 
<h3>
<a id="133_462"></a>13.3.临时表的应用</h3> 
<p>企业开发中大多都是使用Spring进行事务管理的，很少自己开启事务、提交事务。我们大多都会将事务加在service层，这样在调用service层的每一个方法之前Spring都会为我们开启事务，在方法调用结束之后Spring会为我们提交事务，问题是数据库事务需要的数据库连接是在什么时候获取和释放的呢？这个是会影响我们对临时表的使用的。<br> 一般来说，数据库连接是在事务开启之前获取的，也就是在我们调用事务方法之前，肯定要先获取数据库连接，然后才能开启事务，提交或回滚事务，然后关闭数据库连接，这种情况下貌似如果我们在该方法中创建了临时表，则在此之后直至方法结束之前我们都可以使用这个创建的临时表，这么说基本上是正确的。但有一种情况除外那就是如果我们在事务方法A中调用了另一个事务方法B，而事务方法B的事务传播机制是PROPAGATION_REQUIRES_NEW(将原事务挂起，并新开一个事务)时，如果临时表是在B方法中创建的，则A在调用完B之后(B的事务已经提交了)也不可以使用B中创建的事务级别的临时表，但是可以使用会话级别的临时表以及全局临时表。</p> 
<h1>
<a id="SQL_467"></a>三.SQL语句提升</h1> 
<h2>
<a id="1_470"></a>1.复制表</h2> 
<p>(只复制结构,源表名：a 新表名：b) (Access可用)</p> 
<pre><code>法一：select * into b from a where 1&lt;&gt;1（仅用于SQlServer）
法二：select top 0 * into b from a
</code></pre> 
<h2>
<a id="2_479"></a>2.拷贝表</h2> 
<p>(拷贝数据,源表名：a 目标表名：b) (Access可用)</p> 
<pre><code>insert into b(a, b, c) select d,e,f from a;


--insert into b select * from a //从表a中获取数据，并将其插入到b中，只拷贝表的数据，不拷贝表的结构（前提：表b存在）

--select * into b from a //将a中的数据拷贝到 b中，拷贝表的数据以及表的结构（前提：表b不存在）

--select * into b from a where 1=0// 将a的表结构拷贝到b，不拷贝数据（前提：表b不存在）
</code></pre> 
<h2>
<a id="3_494"></a>3.跨数据库之间表的拷贝</h2> 
<p><strong>(具体数据使用绝对路径) (Access可用)</strong></p> 
<pre><code>insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件
例子：..from b in '"&amp;Server.MapPath(".")&amp;"data.mdb" &amp;"' where..
</code></pre> 
<h2>
<a id="4_503"></a>4.子查询</h2> 
<p><strong>(表名1：a 表名2：b)</strong></p> 
<pre><code>select a,b,c from a where a IN (select d from b ) 
或者: 
select a,b,c from a where a IN (1,2,3)
</code></pre> 
<h2>
<a id="5_513"></a>5.显示文章、提交人和最后回复时间</h2> 
<pre><code>select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b
</code></pre> 
<h2>
<a id="6_519"></a>6.外连接查询</h2> 
<p>(表名1：a 表名2：b)</p> 
<pre><code>select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c
</code></pre> 
<h2>
<a id="7_527"></a>7.在线视图查询</h2> 
<p><strong>(表名1：a )</strong></p> 
<pre><code>select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;
</code></pre> 
<h2>
<a id="8between_535"></a>8.between的用法</h2> 
<p>between限制查询数据范围时包括了边界值,not between不包括</p> 
<pre><code>select * from table1 where time between time1 and time2select a,b,c, from table1 where a not between 数值1 and 数值2
</code></pre> 
<h2>
<a id="9in__543"></a>9.in 的使用方法</h2> 
<pre><code>select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)
</code></pre> 
<h2>
<a id="10_549"></a>10.两张关联表，删除主表中已经在副表中没有的信息</h2> 
<pre><code>delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )
</code></pre> 
<h2>
<a id="11_555"></a>11.四表联查问题</h2> 
<pre><code>select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where .....
</code></pre> 
<h2>
<a id="12_561"></a>12.日程安排提前五分钟提醒</h2> 
<pre><code>SQL: select * from 日程安排 where datediff('minute',f开始时间,getdate())&gt;5
</code></pre> 
<h2>
<a id="13sql__567"></a>13.一条sql 语句搞定数据库分页</h2> 
<pre><code>select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段
</code></pre> 
<p><strong>具体实现：</strong></p> 
<p>关于数据库分页：</p> 
<pre><code>declare @start int,@end int
@sql  nvarchar(600)
set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’
exec sp_executesql @sql
</code></pre> 
<blockquote> 
 <p>**注意：**在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）</p> 
</blockquote> 
<h2>
<a id="1410_585"></a>14.前10条记录</h2> 
<pre><code>select top 10 * form table1 where 范围
</code></pre> 
<h2>
<a id="1510_591"></a>15.随机取出10条数据</h2> 
<pre><code>select top 10 * from tablename order by newid()
</code></pre> 
<h2>
<a id="16_597"></a>16.随机选择记录</h2> 
<pre><code>select newid()
</code></pre> 
<h2>
<a id="17_603"></a>17.删除重复记录</h2> 
<pre><code>1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)
2),select distinct * into temp from tablename  
delete from tablename  
insert into tablename select * from temp
</code></pre> 
<p><strong>评价：</strong> 这种操作牵连大量的数据的移动，这种做法不适合大容量的数据操作</p> 
<blockquote> 
 <p>**例如：**在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段</p> 
</blockquote> 
<pre><code>alter table tablename--添加一个自增列
add  column_b int identity(1,1) 
delete from tablename where column_b not in(select max(column_b)  from tablename group by column1,column2,...)
alter table tablename drop column column_b
</code></pre> 
<h2>
<a id="18_622"></a>18.列出数据库里所有的表名</h2> 
<pre><code>select name from sysobjects where type='U' // U代表用户
</code></pre> 
<h2>
<a id="19_628"></a>19.列出表里的所有的列名</h2> 
<pre><code>select name from syscolumns where id=object_id('TableName')
</code></pre> 
<h2>
<a id="20table1_634"></a>20.初始化表table1</h2> 
<pre><code>TRUNCATE TABLE table1
</code></pre> 
<h2>
<a id="211015_640"></a>21.选择从10到15的记录</h2> 
<pre><code>select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id des
</code></pre> 
<h1>
<a id="_646"></a>四、开发技巧</h1> 
<p><strong>1、where 1=1是表示选择全部，where 1=2全部不选</strong></p> 
<pre><code>if @strWhere !='' 
begin
set @strSQL = 'select count(*) as Total from [' + @tblName + '] where ' + @strWhere
end
else begin
set @strSQL = 'select count(*) as Total from [' + @tblName + ']' 
end
</code></pre> 
<p>我们可以直接写成</p> 
<pre><code>set @strSQL = 'select count(*) as Total from [' + @tblName + '] where 1=1 '+ @strWhere
</code></pre> 
<p><strong>2、收缩数据库</strong></p> 
<pre><code>--重建索引
DBCC REINDEX
DBCC INDEXDEFRAG
--收缩数据和日志
DBCC SHRINKDB
DBCC SHRINKFILE
</code></pre> 
<p><strong>3、压缩数据库</strong></p> 
<pre><code>dbcc shrinkdatabase(dbname)
</code></pre> 
<p><strong>4、转移数据库给新用户以已存在用户权限</strong></p> 
<pre><code>exec sp_change_users_login 'update_one','newname','oldname'
go
</code></pre> 
<p><strong>5、检查备份集</strong></p> 
<pre><code>RESTORE VERIFYONLY from disk='E:dvbbs.bak'
</code></pre> 
<p><strong>6、修复数据库</strong></p> 
<pre><code>ALTER DATABASE [dvbbs] SET SINGLE_USER
GO
DBCC CHECKDB('dvbbs',repair_allow_data_loss) WITH TABLOCK
GO
ALTER DATABASE [dvbbs] SET MULTI_USER
GO
</code></pre> 
<p><strong>7、日志清除</strong></p> 
<pre><code>SET NOCOUNT ONDECLARE @LogicalFileName sysname,
@MaxMinutes INT,
@NewSize INT
USE tablename -- 要操作的数据库名
SELECT  @LogicalFileName = 'tablename_log', -- 日志文件名
@MaxMinutes = 10, -- Limit on time allowed to wrap log.
@NewSize = 1  -- 你想设定的日志文件的大小(M)

Setup / initialize
DECLARE @OriginalSize int
SELECT @OriginalSize = size 
FROM sysfiles
WHERE name = @LogicalFileName
SELECT 'Original Size of ' + db_name() + ' LOG is ' + CONVERT(VARCHAR(30),@OriginalSize) + ' 8K pages or ' + CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + 'MB' 
FROM sysfiles 
WHERE name = @LogicalFileName
CREATE TABLE DummyTrans
(DummyColumn char (8000) not null)


DECLARE @Counter INT,
@StartTime DATETIME,
@TruncLog VARCHAR(255)
SELECT @StartTime = GETDATE(),
@TruncLog = 'BACKUP LOG ' + db_name() + ' WITH TRUNCATE_ONLY'
DBCC SHRINKFILE (@LogicalFileName, @NewSize)
EXEC (@TruncLog)
-- Wrap the log if necessary.
WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired 
AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName) 
AND (@OriginalSize * 8 /1024) &gt; @NewSize 
BEGIN -- Outer loop.
SELECT @Counter = 0 
WHILE   ((@Counter &lt; @OriginalSize / 16) AND (@Counter &lt; 50000)) 
BEGIN -- update 
INSERT DummyTrans VALUES ('Fill Log') DELETE DummyTrans 
SELECT @Counter = @Counter + 1 
END 
EXEC (@TruncLog) 
END
SELECT 'Final Size of ' + db_name() + ' LOG is ' + CONVERT(VARCHAR(30),size) + ' 8K pages or ' + CONVERT(VARCHAR(30),(size*8/1024)) + 'MB' 
FROM sysfiles 
WHERE name = @LogicalFileName
DROP TABLE DummyTrans
SET NOCOUNT OFF
</code></pre> 
<p><strong>8、更改某个表</strong></p> 
<pre><code>exec sp_changeobjectowner 'tablename','dbo'
</code></pre> 
<p><strong>9、存储更改全部表</strong></p> 
<pre><code>CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch
@OldOwner as NVARCHAR(128),
@NewOwner as NVARCHAR(128)
AS

DECLARE @Name    as NVARCHAR(128)
DECLARE @Owner as NVARCHAR(128)
DECLARE @OwnerName as NVARCHAR(128)

DECLARE curObject CURSOR FOR 
select 'Name'    = name,
   'Owner'    = user_name(uid)
from sysobjects
where user_name(uid)=@OldOwner
order by name

OPEN   curObject
FETCH NEXT FROM curObject INTO @Name, @Owner
WHILE(@@FETCH_STATUS=0)
BEGIN     
if @Owner=@OldOwner
begin
   set @OwnerName = @OldOwner + '.' + rtrim(@Name)
   exec sp_changeobjectowner @OwnerName, @NewOwner
end
-- select @name,@NewOwner,@OldOwner

FETCH NEXT FROM curObject INTO @Name, @Owner
END

close curObject
deallocate curObject
GO
</code></pre> 
<p><strong>10、SQL SERVER中直接循环写入数据</strong></p> 
<pre><code>declare @i int
set @i=1
while @i&lt;30
begin
    insert into test (userid) values(@i)
    set @i=@i+1
end
</code></pre> 
<p>案例：有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:</p> 
<p>Name score</p> 
<p>Zhangshan 80</p> 
<p>Lishi 59</p> 
<p>Wangwu 50</p> 
<p>Songquan 69</p> 
<pre><code>while((select min(score) from tb_table)&lt;60)
begin
update tb_table set score =score*1.01
where score&lt;60
if  (select min(score) from tb_table)&gt;60
  break
 else
    continue
end
</code></pre> 
<h1>
<a id="_827"></a>五、数据开发-经典</h1> 
<h2>
<a id="1_830"></a>1.按姓氏笔画排序:</h2> 
<p><code>Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多</code></p> 
<h2>
<a id="2_835"></a>2.数据库加密:</h2> 
<pre><code>select encrypt('原始密码')
select pwdencrypt('原始密码')
select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同 encrypt('原始密码')

select pwdencrypt('原始密码')
select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同
</code></pre> 
<hr> 
<h2>
<a id="3_848"></a>3.取回表中字段:</h2> 
<pre><code>declare @list varchar(1000),
@sql nvarchar(1000) 
select @list=@list+','+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name='表A'
set @sql='select '+right(@list,len(@list)-1)+' from 表A' 
exec (@sql)
</code></pre> 
<h2>
<a id="4_858"></a>4.查看硬盘分区:</h2> 
<pre><code>EXEC master..xp_fixeddrives
</code></pre> 
<h2>
<a id="5AB_864"></a>5.比较A,B表是否相等:</h2> 
<pre><code>if (select checksum_agg(binary_checksum(*)) from A)
   =
  (select checksum_agg(binary_checksum(*)) from B)
print '相等'
else
print '不相等'
</code></pre> 
<h2>
<a id="6_875"></a>6.杀掉所有的事件探察器进程:</h2> 
<pre><code>DECLARE hcforeach CURSOR GLOBAL FOR SELECT 'kill '+RTRIM(spid) FROM master.dbo.sysprocesses
WHERE program_name IN('SQL profiler',N'SQL 事件探查器')
EXEC sp_msforeach_worker '?'
</code></pre> 
<h2>
<a id="7_883"></a>7.记录搜索:</h2> 
<p><strong>开头到N条记录</strong></p> 
<p><strong>Select Top N * From 表-------------------------------</strong><br> <strong>N到M条记录(要有主索引ID)</strong><br> <strong>Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc</strong><br> <strong>----------------------------------</strong><br> <strong>N到结尾记录</strong></p> 
<p><strong>Select Top N * From 表 Order by ID Desc</strong></p> 
<p><strong>案例：</strong></p> 
<p><strong>例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第</strong>31到第40个记录。</p> 
<p><strong>select top 10 recid from A where recid not in(select top 30 recid from A)</strong></p> 
<p><strong>分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。</strong></p> 
<p><strong>select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。</strong></p> 
<p><strong>解决方案</strong></p> 
<p><strong>1，用order by</strong> <strong>select top 30 recid from A order by ricid</strong> <strong>如果该字段不是自增长，就会出现问题</strong></p> 
<p>**2，**<strong>在那个子查询中也加条件：select top 30 recid from A where recid&gt;-1</strong></p> 
<p>**例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。</p> 
<pre><code>set @s = 'select top 1 * from T  where pid not in (select top ' + str(@count-1) + ' pid from T)'

print @s   exec sp_executesql @s
</code></pre> 
<h2>
<a id="9_919"></a>9：获取当前数据库中的所有用户表</h2> 
<p><strong>select Name from sysobjects where xtype=‘u’ and status&gt;=0</strong></p> 
<h2>
<a id="10_924"></a>10：获取某一个表的所有字段</h2> 
<p><strong>select name from syscolumns where id=object_id(‘表名’)</strong></p> 
<p><strong>select name from syscolumns where id in (select id from sysobjects where type = ‘u’ and name = ‘表名’)</strong></p> 
<p><strong>两种方式的效果相同</strong></p> 
<h2>
<a id="11_933"></a>11：查看与某一个表相关的视图、存储过程、函数</h2> 
<p><strong>select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like ‘%表名%’</strong></p> 
<h2>
<a id="12_938"></a>12：查看当前数据库中所有存储过程</h2> 
<p><strong>select name as 存储过程名称 from sysobjects where xtype='P’</strong></p> 
<h2>
<a id="13_943"></a>13：查询用户创建的所有数据库</h2> 
<p><strong>select * from master…sysdatabases D where sid not in(select sid from master…syslogins where name=‘sa’)</strong><br> <strong>或者</strong><br> <strong>select dbid, name AS DB_NAME from master…sysdatabases where sid &lt;&gt; 0x01</strong></p> 
<h2>
<a id="14_950"></a>14：查询某一个表的字段和数据类型</h2> 
<p><strong>select column_name,data_type from information_schema.columns</strong><br> <strong>where table_name = '表名’</strong></p> 
<h2>
<a id="15_956"></a>15：不同服务器数据库之间的数据操作</h2> 
<p><strong>–创建链接服务器</strong></p> 
<p><strong>exec sp_addlinkedserver 'ITSV ', ’ ', 'SQLOLEDB ', '远程服务器名或ip地址 ’</strong></p> 
<p><strong>exec sp_addlinkedsrvlogin 'ITSV ', 'false ',null, '用户名 ', '密码 ’</strong></p> 
<p><strong>–查询示例</strong></p> 
<p><strong>select * from ITSV.数据库名.dbo.表名</strong></p> 
<p><strong>–导入示例</strong></p> 
<p><strong>select * into 表 from ITSV.数据库名.dbo.表名</strong></p> 
<p><strong>–以后不再使用时删除链接服务器</strong></p> 
<p><strong>exec sp_dropserver 'ITSV ', 'droplogins ’</strong></p> 
<p><strong>–连接远程/局域网数据</strong>(openrowset/openquery/opendatasource)</p> 
<p><strong>–1、openrowset</strong></p> 
<p><strong>–查询示例</strong></p> 
<p><strong>select * from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)</strong></p> 
<p><strong>–生成本地表</strong></p> 
<p><strong>select * into 表 from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)</strong></p> 
<p><strong>–把本地表导入远程表</strong></p> 
<p><strong>insert openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)</strong></p> 
<p><strong>select *from 本地表</strong></p> 
<p><strong>–更新本地表</strong></p> 
<p><strong>update b</strong></p> 
<p><strong>set b.列A=a.列A</strong></p> 
<p><strong>from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)as a inner join 本地表 b</strong></p> 
<p><strong>on a.column1=b.column1</strong></p> 
<p>**<br> **</p> 
<p><strong>–2、openquery用法需要创建一个连接</strong></p> 
<p><strong>–首先创建一个连接创建链接服务器</strong></p> 
<p><strong>exec sp_addlinkedserver 'ITSV ', ’ ', 'SQLOLEDB ', '远程服务器名或ip地址 ’</strong></p> 
<p><strong>–查询</strong></p> 
<p><strong>select *</strong></p> 
<p><strong>FROM openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ')</strong></p> 
<p><strong>–把本地表导入远程表</strong></p> 
<p><strong>insert openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ')</strong></p> 
<p><strong>select * from 本地表</strong></p> 
<p><strong>–更新本地表</strong></p> 
<p><strong>update b</strong></p> 
<p><strong>set b.列B=a.列B</strong></p> 
<p><strong>FROM openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ') as a</strong></p> 
<p><strong>inner join 本地表 b on a.列A=b.列A</strong></p> 
<p><strong>–3、opendatasource/openrowset</strong></p> 
<p><strong>SELECT *</strong></p> 
<p><strong>FROM opendatasource( 'SQLOLEDB ', 'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ’ ).test.dbo.roy_ta</strong></p> 
<p><strong>–把本地表导入远程表</strong></p> 
<p><strong>insert opendatasource( 'SQLOLEDB ', 'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ').数据库.dbo.表名</strong></p> 
<p><strong>select * from 本地表</strong></p> 
<p>SQL Server基本函数</p> 
<h1>
<a id="SQL_Server_1050"></a>六、SQL Server基本函数</h1> 
<h2>
<a id="1__1053"></a>1.字符串函数 长度与分析用</h2> 
<p><strong>1,datalength</strong>(Char_expr) 返回字符串包含字符数,但不包含后面的空格</p> 
<p><strong>2,substring</strong>(expression,start,length) 取子串，字符串的****下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度</p> 
<p><strong>3,right</strong>(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用left于之相反</p> 
<p><strong>4,isnull</strong>( check_ex*****pression* , *replacement_value* )如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类</p> 
<p><strong>5,Sp_addtype</strong>自定义数据类型<br> 例如：EXEC sp_addtype birthday, datetime, ‘NULL’</p> 
<p><strong>6,set nocount {on|off}</strong></p> 
<p>使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。</p> 
<p>SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。</p> 
<p>SET NOCOUNT 为 OFF 时，返回计数常识<br> 在SQL查询中：from后最多可以跟多少张表或视图：256<br> 在SQL语句中出现Order by，查询时，先排序，后取<br> 在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。</p> 
<p><strong>常识</strong><br> 在SQL查询中：from后最多可以跟多少张表或视图：256<br> 在SQL语句中出现Order by，查询时，先排序，后取<br> 在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>