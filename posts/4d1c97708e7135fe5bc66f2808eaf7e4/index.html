<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Java 注解 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 注解</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <p>注解的本质就是给载体打一个Tag，我们查找到这个tag后就可以对我们打Tag的载体进行一些特殊处理</p> 
<p><span style="color:#333333">Java 注解（Annotation</span><span style="color:#333333">）又称</span><span style="color:#333333"> Java </span><span style="color:#333333">标注，是</span><span style="color:#333333"> JDK5.0 </span><span style="color:#333333">引入的一种注释机制。 注解是元数据的一种形式，提供有关 于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。 </span></p> 
<div> 
 <div>
  <span style="color:#333333"><strong>注解声明 </strong></span>
 </div> 
 <div>
  <span style="color:#333333"><strong>声明一个注解类型</strong></span>
 </div> 
 <div> 
  <div>
   <span style="color:#333333">Java</span>
   <span style="color:#333333">中所有的注解，默认实现 </span>
   <span style="color:#333333">Annotation </span>
   <span style="color:#333333">接口：</span>
  </div> 
  <pre><code class="language-java">package java.lang.annotation;

public interface Annotation {
    boolean equals(Object obj);

    int hashCode();

    String toString();

    Class&lt;? extends Annotation&gt; annotationType();
}</code></pre> 
  <p><span style="color:#333333">与声明一个"</span><span style="color:#333333"><strong>Class</strong></span><span style="color:#333333">"</span><span style="color:#333333">不同的是，注解的声明使用 </span><span style="color:#333333">@interface </span><span style="color:#333333">关键字。一个注解的声明如下： </span></p> 
  <pre><code class="language-java">public @interface FirstAnnotation {
    String name();

    int age();
}</code></pre> 
  <p><span style="color:#333333"><strong>元注解 </strong></span></p> 
  <p><span style="color:#333333">在定义注解时，注解类也能够使用其他的注解声明。对注解类型进行注解的注解类，我们称之为 metaannotation（元注解）。一般的，我们在定义自定义注解时，需要指定的元注解有两个 ： </span></p> 
  <div> 
   <div>
    <span style="color:#777777">另外还有</span>
    <span style="color:#777777"><strong>@Documented </strong></span>
    <span style="color:#777777">与 </span>
    <span style="color:#777777"><strong>@Inherited </strong></span>
    <span style="color:#777777">元注解，前者用于被</span>
    <span style="color:#777777">javadoc</span>
    <span style="color:#777777">工具提取成文档，</span>
   </div> 
   <div>
    <span style="color:#777777">后者表示允许子类继承父类中定义的</span>
    <span style="color:#fe2c24">注解</span>
    <span style="color:#777777">,@Repeatable是jdk8中新增的注解在没有@Repeatable元注解的注解中，在同一个地方使用相同的注解会报错，有了此元注解注，既可以在同一个地方使用相同的注解。</span>
   </div> 
   <div></div> 
   <div> 
    <div>
     <span style="color:#333333"><strong>@Target</strong></span>
    </div> 
   </div> 
   <div>
    <span style="color:#333333">注解标记另一个注解，以限制可以应用注解的</span>
    <span style="color:#333333"> Java </span>
    <span style="color:#333333">元素类型。目标注解指定以下元素类型之一作为其值：</span>
   </div> 
  </div> 
  <div> 
   <div>
    <span style="color:#333333">ElementType.ANNOTATION_TYPE      </span>
    <span style="color:#333333">可以应用于注解类型。 </span>
   </div> 
   <div>
    <span style="color:#333333">ElementType.CONSTRUCTOR            </span>
    <span style="color:#333333">可以应用于构造函数。 </span>
   </div> 
   <div>
    <span style="color:#333333">ElementType.FIELD                              </span>
    <span style="color:#333333">可以应用于字段或属性。</span>
   </div> 
   <div>
    <span style="color:#333333">ElementType.LOCAL_VARIABLE         </span>
    <span style="color:#333333">可以应用于局部变量。 </span>
   </div> 
   <div>
    <span style="color:#333333">ElementType.METHOD                         </span>
    <span style="color:#333333">可以应用于方法级注解。 </span>
   </div> 
   <div>
    <span style="color:#333333">ElementType.PACKAGE                       </span>
    <span style="color:#333333">可以应用于包声明。 </span>
   </div> 
   <div>
    <span style="color:#333333">ElementType.PARAMETER                  </span>
    <span style="color:#333333">可以应用于方法的参数。 </span>
   </div> 
   <div>
    <span style="color:#333333">ElementType.TYPE_USE                      </span>
    <span style="color:#333333">可以应用于类的任何元素。 </span>
   </div> 
   <div>
    <span style="color:#333333">ElementType.TYPE.                               可以应用于类上</span>
   </div> 
   <div>
    ElementType.TYPE_PARAMETER        
    <span style="color:#333333">可以应用于</span>类型变量的声明语句中（eg：泛型声明）
   </div> 
   <p></p> 
   <p><span style="color:#333333"><strong>@Retention</strong></span></p> 
   <p><span style="color:#333333">注解指定标记注解的存储方式：</span></p> 
   <div>
    <span style="color:#333333">RetentionPolicy.SOURCE</span>
    <span style="color:#333333"> - </span>
    <span style="color:#333333">标记的注解仅保留在源级别中，并被编译器忽略。 </span>
   </div> 
   <div>
    <span style="color:#333333">RetentionPolicy.CLASS</span>
    <span style="color:#333333"> - </span>
    <span style="color:#333333">标记的注解在编译时由编译器保留，但</span>
    <span style="color:#333333"> Java </span>
    <span style="color:#333333">虚拟机</span>
    <span style="color:#333333">(JVM)</span>
    <span style="color:#333333">会忽略。 </span>
   </div> 
   <div>
    <span style="color:#333333">RetentionPolicy.RUNTIME</span>
    <span style="color:#333333"> - </span>
    <span style="color:#333333">标记的注解由</span>
    <span style="color:#333333"> JVM </span>
    <span style="color:#333333">保留，因此运行时环境可以使用它。 </span>
   </div> 
   <div></div> 
   <div> 
    <div>
     <span style="color:#777777">@Retention </span>
     <span style="color:#777777">三个值中</span>
     <span style="color:#777777"> SOURCE &lt; CLASS &lt; RUNTIME</span>
     <span style="color:#777777">，即</span>
     <span style="color:#777777">CLASS</span>
     <span style="color:#777777">包含了</span>
     <span style="color:#777777">SOURCE</span>
     <span style="color:#777777">，</span>
     <span style="color:#777777">RUNTIME</span>
     <span style="color:#777777">包含</span>
     <span style="color:#777777">SOURCE</span>
     <span style="color:#777777">、 CLASS。下文会介绍他们不同的应用场景。 </span>
    </div> 
   </div> 
  </div> 
  <div>
     
   <div>
    <span style="color:#333333">下面来看例子：</span>
   </div> 
   <div></div> 
   <div> 
    <pre><code class="language-java">@Retention(RetentionPolicy.SOURCE)  //只保留在java源码中
@Target({ElementType.FIELD}) //只能作用于属性
public @interface FirstAnnotation {
    String name(); //无默认值
    int age() default 18; // 有默认值
}</code></pre> 
    <p><span style="color:#777777">注意：在使用注解时，如果定义的注解中的类型元素无默认值，则必须进行传值。</span></p> 
   </div> 
   <pre><code class="language-java">public class AnnotationTest {
    @FirstAnnotation("那路多") //如果只存在value元素需要传值的情况，则可以省略:value =
    Student student; //注意只有命名为value才能省略 value = 直接写
 
    @FirstAnnotation(value = "萨斯给",age = 18)
    Student student1;
}</code></pre> 
   <div>
    <span style="color:#333333"><strong>注解应用场景:</strong></span>
   </div> 
   <div></div> 
   <div> 
    <div>
     <span style="color:#333333">按照</span>
     <span style="color:#333333"><strong>@Retention </strong></span>
     <span style="color:#333333">元注解定义的注解存储方式，注解可以被在三种场景下使用： </span>
    </div> 
   </div> 
  </div> 
  <div>
     
   <div>
    <span style="color:#333333"><strong>SOURCE 级别: </strong></span>
   </div> 
   <div> 
    <p>在把java文件编译成Class文件后source级别的注解就会消失:</p> 
    <p><img alt="" height="1200" src="https://images2.imgbox.com/45/7c/pt9LVT1a_o.png" width="1200"></p> 
    <p><img alt="" height="1200" src="https://images2.imgbox.com/83/4a/GchNqUr8_o.png" width="1200"></p> 
    <p>可以看到编译后source级别的注解消失了</p> 
    <p><span style="color:#333333"><strong>可以用于 IDE检查和APT等场景使用</strong></span></p> 
    <div>
     <span style="color:#333333">在</span>
     <span style="color:#333333">Android</span>
     <span style="color:#333333">开发中， </span>
     <span style="color:#333333">support</span>
     <span style="color:#333333">-</span>
     <span style="color:#333333">annotations </span>
     <span style="color:#333333">与 </span>
     <span style="color:#333333">androidx.annotation </span>
     <span style="color:#333333">中均有提供 </span>
     <span style="color:#333333">@IntDef</span>
     <span style="color:#333333">、</span>
     <span style="color:#333333">@DrawableResId </span>
     <span style="color:#333333">等注 解，此注解的定义如下：</span>
    </div> 
    <div> 
     <pre><code class="language-java">@Retention(SOURCE) //源码级别注解 
@Target({ANNOTATION_TYPE})
public @interface IntDef {
    int[] value() default {};

    boolean flag() default false;

    boolean open() default false;
}</code></pre> 
    </div>   
    <div>
     <span style="color:#777777">Java</span>
     <span style="color:#777777">中</span>
     <span style="color:#777777">Enum(</span>
     <span style="color:#777777">枚举</span>
     <span style="color:#777777">)</span>
     <span style="color:#777777">的实质是特殊单例的静态成员变量，在运行期所有枚举类作为单例，全部加载到内存中。 比常量多5</span>
     <span style="color:#777777">到</span>
     <span style="color:#777777">10</span>
     <span style="color:#777777">倍的内存占用。 </span>
    </div> 
    <div>
     <span style="color:#333333">此注解的意义在于能够取代枚举，实现如方法入参限制。</span>
    </div> 
    <div>
     <span style="color:#333333"><strong>例:</strong></span> 
    </div> 
   </div> 
   <div></div> 
   <div> 
    <pre><code class="language-java">@IntDef(value = {1,2}) // 限定只能传 1 和 2
@Retention(RetentionPolicy.SOURCE) //只保留在java源码中
@Target({ElementType.PARAMETER}) //只能作用于方法参数之上
public @interface IntDefAnnotationTest {
    int value();
}


public class AnnotationTest {

    public void test(@IntDefAnnotationTest(value = 1) int a){
        System.out.println(a);
    }
}</code></pre> 
    <p> 如果传1或者2编译器可以通过 </p> 
    <p><img alt="" height="740" src="https://images2.imgbox.com/a8/cd/fCCyL35T_o.png" width="1200"></p> 
   </div> 
   <div>
    如果传额外的数字例如3
    <span style="color:#333333">会显示 </span>
    <span style="color:#333333"><strong>Inspection </strong></span>
    <span style="color:#333333">警告</span>
   </div> 
   <div>
    <img alt="" height="772" src="https://images2.imgbox.com/b3/f9/vUouXNlu_o.png" width="1200">
   </div> 
   <p>IDE报警了但是还是能编译通过和运行</p> 
   <p><span style="color:#777777">可以修改此类语法检查级别：</span></p> 
   <p><img alt="" height="1200" src="https://images2.imgbox.com/b0/b7/xzmWDnZ6_o.png" width="1200"></p> 
   <p><img alt="" height="528" src="https://images2.imgbox.com/83/c2/DNvefGIW_o.png" width="1200"></p> 
   <p> 可以看到AS没有再报错,<span style="color:#333333">本身IDEA/AS </span><span style="color:#333333">就是由</span><span style="color:#333333">Java</span><span style="color:#333333">开发的，</span><span style="color:#333333">Lint</span><span style="color:#333333">工具实现了对</span><span style="color:#333333">Java</span><span style="color:#333333">语法的检查，借助注解能对被注解的特定语法进行额外检查。 </span></p> 
   <div>
    <span style="color:#333333"><strong>2.APT annotation processor tools 注解处理器技术</strong></span>
   </div> 
  </div> 
  <div>
     
   <div>
    <span style="color:#333333">APT</span>
    <span style="color:#333333">全称为：</span>
    <span style="color:#333333">"Anotation Processor Tools"</span>
    <span style="color:#333333">，意为注解处理器。顾名思义，其用于处理注解。编写好的</span>
    <span style="color:#333333">Java</span>
    <span style="color:#333333">源文 件，需要经过 javac </span>
    <span style="color:#333333">的编译，翻译为虚拟机能够加载解析的字节码</span>
    <span style="color:#333333">Class</span>
    <span style="color:#333333">文件。注解处理器是</span>
    <span style="color:#333333"> javac </span>
    <span style="color:#333333">自带的一个工 具，用来在编译时期扫描处理注解信息。你可以为某些注解注册自己的注解处理器。 注册的注解处理器由 javac调起，并将注解信息传递给注解处理器进行处理。</span>
   </div> 
   <div> 
    <div>
     <span style="color:#777777">注解处理器是对注解应用最为广泛的场景。在</span>
     <span style="color:#777777">Glide</span>
     <span style="color:#777777">、</span>
     <span style="color:#777777">EventBus3</span>
     <span style="color:#777777">、</span>
     <span style="color:#777777">Butterknifer</span>
     <span style="color:#777777">、</span>
     <span style="color:#777777">Tinker</span>
     <span style="color:#777777">、</span>
     <span style="color:#777777">ARouter</span>
     <span style="color:#777777">等等常用 框架中都有注解处理器的身影。但是你可能会发现，这些框架中对注解的定义并不是 SOURCE </span>
     <span style="color:#777777">级别，更多的是 CLASS </span>
     <span style="color:#777777">级别，别忘了：</span>
     <span style="color:#777777"><strong>CLASS</strong></span>
     <span style="color:#777777"><strong>包含了</strong></span>
     <span style="color:#777777"><strong>SOURCE</strong></span>
     <span style="color:#777777"><strong>，</strong></span>
     <span style="color:#777777"><strong>RUNTIME</strong></span>
     <span style="color:#777777"><strong>包含</strong></span>
     <span style="color:#777777"><strong>SOURCE</strong></span>
     <span style="color:#777777"><strong>、</strong></span>
     <span style="color:#777777"><strong>CLASS</strong></span>
     <span style="color:#777777"><strong>。</strong></span>
    </div> 
   </div> 
  </div> 
  <div>
     
   <div>
    <span style="color:#333333">关于注解处理器的实现，会在后续：<a class="link-info" href="https://blog.csdn.net/m0_37707561/article/details/121683048">APT注解处理器的实现</a>文章中给出。此处先不进行详细介绍。</span>
   </div> 
   <div></div> 
   <div> 
    <div>
     <span style="color:#333333"><strong>CLASS级别:</strong></span>
     <span style="color:#333333"><strong> 字节码增强（插桩）技术</strong></span>
    </div> 
    <div></div> 
    <div> 
     <div>
      <span style="color:#333333">定义为 </span>
      <span style="color:#333333">CLASS </span>
      <span style="color:#333333">的注解，会保留在</span>
      <span style="color:#333333">class</span>
      <span style="color:#333333">文件中，但是会被虚拟机忽略</span>
      <span style="color:#333333">(</span>
      <span style="color:#333333">即无法在运行期反射获取注解</span>
      <span style="color:#333333">)</span>
      <span style="color:#333333">。此时完全符合 此种注解的应用场景为字节码操作。如：AspectJ</span>
      <span style="color:#333333">、热修复</span>
      <span style="color:#333333">Roubust</span>
      <span style="color:#333333">中应用此场景。 所谓字节码操作即为，直接修改字节码Class</span>
      <span style="color:#333333">文件以达到修改代码执行逻辑的目的。在程序中有多处需要进行是否登录的判断。</span>
     </div> 
    </div> 
    <p><img alt="" height="379" src="https://images2.imgbox.com/98/55/sDhCRNdN_o.png" width="357"></p> 
    <div>
     <span style="color:#333333">如果我们使用普通的编程方式，需要在代码中进行 </span>
     <span style="color:#333333">if</span>
     <span style="color:#333333">-</span>
     <span style="color:#333333">else </span>
     <span style="color:#333333">的判断，也许存在十个判断点，则需要在每个判断点加 入此项判断。此时，我们可以借助AOP(</span>
     <span style="color:#333333">面向切面</span>
     <span style="color:#333333">)</span>
     <span style="color:#333333">编程思想，将程序中所有功能点划分为： </span>
     <span style="color:#333333">需要登录 </span>
     <span style="color:#333333">与 </span>
     <span style="color:#333333">无需登录两种类型，即两个切面。对于切面的区分即可采用注解。</span>
    </div> 
   </div> 
   <pre><code class="language-java">//Java源码
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.CLASS)
public @interface Login {
}

    @Login
    public void jumpA() {
        startActivity(new Intent(this, AActivity.class));
    }

    public void jumpB() {
        startActivity(new Intent(this, BActivity.class));
    }</code></pre> 
   <div>
    <span style="color:#333333">在上诉代码中， </span>
    <span style="color:#333333">jumpA </span>
    <span style="color:#333333">方法需要具备登录身份。而 </span>
    <span style="color:#333333">Login </span>
    <span style="color:#333333">注解的定义被设置为 </span>
    <span style="color:#333333">CLASS </span>
    <span style="color:#333333">。因此我们能够在该类所编 译的字节码中获得到方法注解 Login </span>
    <span style="color:#333333">。在操作字节码时，就能够根据方法是否具备该注解来修改</span>
    <span style="color:#333333">class</span>
    <span style="color:#333333">中该方法的内容加入 if</span>
    <span style="color:#333333">-</span>
    <span style="color:#333333">else </span>
    <span style="color:#333333">的代码段： </span>
   </div> 
   <div> 
    <pre><code class="language-java">    //Class字节码
    @Login
    public void jumpA() {
        if (this.isLogin) {
            this.startActivity(new Intent(this, LoginActivity.class));
        } else {
            this.startActivity(new Intent(this, AActivity.class));
        }
    }

    public void jumpB() {
        startActivity(new Intent(this, BActivity.class));
    }</code></pre> 
    <div>
     <span style="color:#333333">注解能够设置类型元素</span>
     <span style="color:#333333">(</span>
     <span style="color:#333333">参数</span>
     <span style="color:#333333">)</span>
     <span style="color:#333333">，结合参数能实现更为丰富的场景，如：运行期权限判定等。 </span>
    </div> 
    <div></div> 
    <div> 
     <div>
      <span style="color:#333333"><strong>RUNTIME ：</strong></span>
     </div> 
     <div></div> 
     <div>
      <span style="color:#333333">注解保留至运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。</span>
     </div> 
     <p>实现：<a class="link-info" href="https://blog.csdn.net/m0_37707561/article/details/121680920" title="用反射技术和RUNTIME级别注解，实现ButterKnife功能">用反射技术和RUNTIME级别注解，实现ButterKnife功能</a></p> 
     <p></p> 
     <h3>@Inherited</h3> 
     <p>作用：如果一个类用上了@Inherited修饰的注解，那么其子类也会继承这个注解</p> 
     <p>注意是作用在类上的注解切必须是继承关系。</p> 
     <p>注意：</p> 
     <ol>
<li>接口用上个@Inherited修饰的注解，其实现类不会继承这个注解</li>
<li>父类的方法用了@Inherited修饰的注解，子类也不会继承这个注解</li>
</ol>
     <p>例:</p> 
     <pre><code class="language-java">@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE,ElementType.FIELD})
public @interface FirstAnnotation {
    String value();
    int age() default 18;

}</code></pre> 
     <pre><code class="language-java">@FirstAnnotation("继承")
public class AnnotationTest {

    @FirstAnnotation("那路多")
    Student student;

    @FirstAnnotation(value = "萨斯给",age = 18)
    Student student1;

    public void test(@IntDefAnnotationTest(value = 1) int a){
        System.out.println(a);
    }
}</code></pre> 
     <pre><code class="language-java">
public class AnnotationTest1 extends AnnotationTest {



}</code></pre> 
     <pre><code class="language-java">public class AnnotationMainTest {
    public static void main(String[] args) {
        System.out.println(Arrays.toString(AnnotationTest1.class.getAnnotations()));
    }
}</code></pre> 
     <p>执行结果:</p> 
     <p><img alt="" height="346" src="https://images2.imgbox.com/24/b7/1FrxUwfn_o.png" width="1200"></p> 
     <p> 只有作用在类上的继承过来了。</p> 
     <h3>@Repeatable</h3> 
     <p><code>@Repeatable</code>是jdk8中新增的注解。在没有<code>@Repeatable</code>注解的的注解中，在同一个地方使用相同的注解会报错，有了此元注解注解的注解，就可以在同一个地方使用相同的注解。</p> 
     <p>官方解释:</p> 
     <p>The annotation type {@code java.lang.annotation.Repeatable} is used to indicate that the annotation type whose declaration it (meta-)annotates is repeatable. The value of @Repeatable indicates the containing annotation type for the repeatable annotation type.<br> @Repeatable 注解是用于声明其它类型注解的元注解，来表示这个声明的注解是可重复的。@Repeatable的值是另一个注解，其可以通过这个另一个注解的值来包含这个可重复的注解。</p> 
     <pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE,ElementType.FIELD})
@Repeatable(SecondAnnotation.class)
public @interface FirstAnnotation {
    String value();
    int age() default 18;

}</code></pre> 
     <pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE,ElementType.FIELD})
public @interface SecondAnnotation {
    FirstAnnotation[] value();
}</code></pre> 
     <p>其中，<code>@</code>FirstAnnotation 注解上的元注解<code>@Repeatable</code>中的值，使用了<code>@</code>SecondAnnotation注解，<code>@</code>SecondAnnotation注解中包含的值类型是一个<code>@</code>FirstAnnotation注解的数组！<br> 这就解释了官方文档中<code>@Repeatable</code>中值的使用。</p> 
     <p>测试: </p> 
     <pre><code class="language-java">public class AnnotationTest {


    @FirstAnnotation("1")
    @FirstAnnotation("2")
    @FirstAnnotation("3")
    int a;

}</code></pre> 
     <pre><code class="language-java">public class AnnotationMainTest {
    public static void main(String[] args) {
       Class annotationTestClass= AnnotationTest.class;
        try {
           Field field = annotationTestClass.getDeclaredField("a");
           Annotation[] annotations = field.getAnnotations();
           System.out.println(annotations.length);
           System.out.println(Arrays.toString(annotations));
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
     <p>执行：</p> 
     <p>因为int a属性上使用了3个@FirstAnnotation注解，所以猜测打印注解长度为3，然后打印详情，可是结果并不同。</p> 
     <p>1<br> [@com.example.fragmentadaptertest.annotation.<span style="color:#fe2c24">SecondAnnotation</span>(value=[@com.example.fragmentadaptertest.annotation.<span style="color:#ff9900">FirstAnnotation</span>(age=18, value=1), @com.example.fragmentadaptertest.annotation.<span style="color:#ff9900">FirstAnnotation</span>(age=18, value=2), @com.example.fragmentadaptertest.annotation.<span style="color:#ff9900">FirstAnnotation</span>(age=18, value=3)])]</p> 
     <p>结果显示，<code>int a属性</code>上的注解长度为 1 , 且打印信息为<code>@SecondAnnontation</code>注解，它的值包含了使用的两个注解。因此可知在jdk8中，相同注解只是以集合的方式进行了保存，原理并没有变化。</p> 
     <p><strong>注意事项</strong></p> 
     <p>一些约束</p> 
     <p>@Repeatable 所声明的注解，其元注解@Target的使用范围要比@Repeatable的值声明的注解中的@Target的范围要大或相同，否则编译器错误，显示@Repeatable值所声明的注解的元注解@Target不是@Repeatable声明的注解的@Target的子集</p> 
     <pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE,ElementType.FIELD})
@Repeatable(SecondAnnotation.class)
public @interface FirstAnnotation {
    String value();
    int age() default 18;

}</code></pre> 
     <pre><code class="language-java">@Retention(RetentionPolicy.SOURCE)
@Target({ElementType.TYPE,ElementType.FIELD})
public @interface SecondAnnotation {
    FirstAnnotation[] value();
}</code></pre> 
     <p><img alt="" height="760" src="https://images2.imgbox.com/b1/16/LIenS1Sr_o.png" width="1200"></p> 
     <p>简单说就是如果想让一个自定义注解A可以在一个地方使用，就打上<code>@Repeatable标签，标签的值是一个注解B，注解B的</code>value的<code>类型必须是A的数组类型。</code></p> 
     <p><code>最后使用多个A注解的实质，就是一个B注解类型包裹多个A注解类型的值。</code></p> 
     <p><code>想一想供需关系，A需要B来包裹实现注解数组，我们使用的是A在一个地方多次使用,就知道A在B必须在，A不在B可以在也可以不在。</code></p> 
     <p><code>所以B的存在级别要大于等于A。</code></p> 
     <p><code>RUNTIME &gt; CLASS &gt; SOURCE</code></p> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>