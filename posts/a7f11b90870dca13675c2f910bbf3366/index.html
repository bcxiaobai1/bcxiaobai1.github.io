<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>synchronized 原理、使用、锁升级过程，写到我要吐血了 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">synchronized 原理、使用、锁升级过程，写到我要吐血了</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-dracula">
                    
                        
                    
                    <p></p>
<div class="toc">
 <h3>本文目录</h3>
 <ul>
<li><a href="#1_15">1.锁的分类</a></li>
<li><a href="#2synchronized__24">2.synchronized 含义</a></li>
<li><a href="#3synchronized__32">3.synchronized 三种加锁方式</a></li>
<li>
<ul>
<li><a href="#1_37">1.修饰实例方法</a></li>
<li><a href="#2_46">2.修饰静态方法</a></li>
<li><a href="#3__55">3 修饰代码块</a></li>
<li>
<ul>
<li><a href="#1_59">1.变量锁</a></li>
<li><a href="#2_108">2.实例对象锁</a></li>
<li><a href="#3_Class__118">3.当前类的 Class 对象锁</a></li>
</ul>
  </li>
</ul>
  </li>
<li><a href="#4synchronized__126">4.synchronized 底层原理</a></li>
<li>
<ul>
<li><a href="#1Monitor__145">1.Monitor 管程对象</a></li>
<li>
<ul>
<li><a href="#1ObjectMonitor__154">1.ObjectMonitor 对象属性说明</a></li>
<li><a href="#2ObjectMonitor__162">2.ObjectMonitor 工作流程</a></li>
<li><a href="#3Java__173">3.Java 对象内存结构</a></li>
<li><a href="#4_header__181">4._header 对象头介绍(对象如何加锁)</a></li>
</ul>
   </li>
<li><a href="#2JDK_6_synchronized__243">2.JDK 6 synchronized 锁优化升级过程</a></li>
<li>
<ul>
<li><a href="#1_299">1.锁的四种状态介绍</a></li>
<li>
<ul>
<li><a href="#1_300">1.无锁</a></li>
<li><a href="#2_303">2.偏向锁</a></li>
<li><a href="#3_313">3.轻量级锁</a></li>
<li><a href="#4_333">4.重量级锁</a></li>
</ul>
    </li>
<li><a href="#2synchronized__341">2.synchronized 锁升级流程图</a></li>
<li><a href="#3_synchronized__343">3.示例演示 synchronized 锁升级全过程</a></li>
<li>
<ul>
<li><a href="#1___397">1.无锁 → 偏向锁</a></li>
<li><a href="#2___406">2.偏向锁 → 轻量级锁</a></li>
<li><a href="#3___413">3.无锁 → 轻量级锁</a></li>
<li><a href="#4__424">4.轻量级锁--&gt; 重量级锁</a></li>
</ul>
   </li>
</ul>
  </li>
</ul>
  </li>
<li><a href="#5_____433">5.锁粗化 &amp; 锁消除 &amp; 逃逸分析</a></li>
<li>
<ul>
<li><a href="#1_434">1.锁粗化</a></li>
<li><a href="#2_454">2.锁消除</a></li>
<li>
<ul>
<li><a href="#1_455">1.什么是锁消除</a></li>
<li><a href="#2_486">2.锁消除实例</a></li>
</ul>
   </li>
<li><a href="#3_521">3.逃逸分析</a></li>
<li>
<ul>
<li><a href="#1_527">1.什么是逃逸分析</a></li>
<li><a href="#2_530">2.逃逸分析的原理</a></li>
<li><a href="#3_535">3.逃逸的方式</a></li>
<li><a href="#4_540">4.逃逸分析，编译器对代码做了如下优化</a></li>
<li><a href="#5_546">5.逃逸分析命令</a></li>
<li><a href="#6_556">6.代码展示</a></li>
<li>
<ul>
<li><a href="#1_557">1.创建的对象并没有被方法外使用(发生逃逸)</a></li>
<li><a href="#2_593">2.创建的对象可能会被方法外部使用(未发生逃逸)</a></li>
</ul>
   </li>
</ul>
  </li>
</ul>
 </li>
</ul>
</div>
<br>   多线程编程中，会出现多个线程同时访问
<code>同一个</code>
<u><strong>共享、可变资源</strong></u>的情况，这个资源我们称之其为
<code>临界资源</code>；这种资源可以是：
<code>对象</code>、
<code>变量</code>、
<code>文件</code>等。
<p></p> 
<ol>
<li>
<strong>共享</strong>：资源可以由多个线程同时访问</li>
<li>
<strong>可变</strong>：资源在其生命周期内可以被修改</li>
</ol> 
<p>  由于线程执行的过程是不可控的，所以需要采用同步机制，对对象的可变状态进行访问 。<font color="green">实际上，所有的并发模式在解决线程安全问题时，采用的方案都是</font> <code>序列化访问临界资源</code>。即<strong>在同一时刻，只能有一个线程访问临界资源</strong>，也称作<code>同步互斥访问</code>。</p> 
<p><strong>解决方式：</strong></p> 
<p>  加锁 ！！！</p> 
<p>  不过有一点需要区别的是：当多个线程执行一个方法时，该方法内部的局部变量并不是临界资源，因为这些局部变量是在每个线程的私有栈（工作内存）中，因此不具有共享性，不会导致线程安全问题。</p> 
<p>  <strong>Java 中，提供了两种方式来实现同步互斥访问：<code>synchronized</code> 和 <code>Lock</code>，本文主要介绍 synchronized 锁。首先来了解一下 Java 中锁的分类吧。</strong></p> 
<h1>
<a id="1_15"></a>1.锁的分类</h1> 
<p>  锁，按照性质的不同，可以分为：<code>显示锁</code> 和 <code>隐式锁</code> 两种</p> 
<ol>
<li> <p><strong>隐式锁</strong>：即 synchronized 加锁，它是 JVM 内置锁，不需要我们手动的加锁与解锁。JVM 会进行自动加锁 &amp; 解锁；</p> </li>
<li> <p><strong>显示锁</strong>：即 JUC 并发包下的 Lock 接口。比如：ReentrantLock，它实现了 Lock 接口，<code>使用 ReentrantLock 时，需要我们在代码中手动的加锁 &amp; 解锁</code>。</p> </li>
</ol> 
<p>  根据不同标准，Java 锁还可以分为：<code>悲观锁、乐观锁</code>；<code>公平锁、非公平锁</code>；<code>可重入锁、非可重入锁</code>；<code>共享锁、排他(互斥)锁</code>；<code>自旋锁</code>；<code>偏向锁、轻量级锁、重量级锁</code> 等。如下图所示：<br> <img src="https://images2.imgbox.com/d3/50/CVZtMfoH_o.png" alt="在这里插入图片描述"></p> 
<h1>
<a id="2synchronized__24"></a>2.synchronized 含义</h1> 
<p>  synchronized 是同步锁，用来实现互斥同步。</p> 
<p>  在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块（主要是对方法或者代码块中存在共享数据的操作）</p> 
<p>  synchronized 还可以保证一个线程的变化（主要是共享数据的变化）被其他线程所看到（保证可见性，完全可以替代 volatile 功能，但是 volatile 更轻量，还是要分场景使用）。</p> 
<blockquote> 
 <p>并发编程 - 三大特性，以及 synchronized 在三大特性中的使用，参考：<a href="https://blog.csdn.net/lzb348110175/article/details/121360752#comments_19050403">JMM内存模型 &amp; 多线程三大特性</a></p> 
</blockquote> 
<h1>
<a id="3synchronized__32"></a>3.synchronized 三种加锁方式</h1> 
<ol>
<li>修饰<code>实例方法</code>
</li>
<li>修饰<code>类方法</code>
</li>
<li>修饰<code>代码块</code>
</li>
</ol> 
<h2>
<a id="1_37"></a>1.修饰实例方法</h2> 
<p>  实例对象锁，就是用 synchronized 修饰<code>实例对象中的实例方法</code>，注意：是实例方法不包括静态方法。<font color="red">它锁住的是当前对象(this)</font>。如下：</p> 
<pre><code class="prism language-java"><span class="token comment">// synchronzied 修饰实例对象方法</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="2_46"></a>2.修饰静态方法</h2> 
<p>  当 synchronized 作用于静态方法时，其<code>锁住的是当前类的 Class 对象锁</code>。由于静态成员不专属于任何一个实例对象，是类成员，因此通过 Class 对象锁可以控制静态成员的并发操作。</p> 
<p>  需要注意的是：<code>如果一个线程 A 调用一个实例对象的非 static synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象</code>。因为访问静态 synchronized 方法占用的锁是当前类的 class 对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁，二者的锁并不一样，所以不冲突。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="3__55"></a>3 修饰代码块</h2> 
<p>  在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方法对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了。</p> 
<p>我们可以使用如下几种对象来作为锁的对象：</p> 
<h3>
<a id="1_59"></a>1.变量锁</h3> 
<p>  使用 synchronized，锁住的是变量</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">synMethod</span><span class="token punctuation">(</span><span class="token class-name">Object</span> a1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 操作</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">synMethod</span><span class="token punctuation">(</span><span class="token class-name">Object</span> a1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Demo2</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 变量[区别：放在new Thread外层，30个线程使用同一个参数；放在内层，每一个线程使用一个参数]</span>
        <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 30个线程</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">30</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    demo<span class="token punctuation">.</span><span class="token function">synMethod</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"线程-"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>结果：</strong><br>   lock 作为参数，放在 new Thread 外，30个线程都使用这1个参数，就是同一把锁。结果就是：每2s输出一次<br>  <br>   如果将 lock 变量的定义，放在 new Thread 代码中，就是每个线程使用一个对象作为synMethod()方法的参数，最终结果就是：等待2s后，一次性输出30条<br>  <br> <strong>注意：</strong><br>   此处需要引用变量，如果说变量是String，则放在new Thread 内层 和 外层 都属于一个参数。这就涉及到 String 在 JVM 中如何存值的问题。<code>一般使用 Object 类型的 lock 作为锁即可</code>。</p> 
</blockquote> 
<h3>
<a id="2_108"></a>2.实例对象锁</h3> 
<p>this 代表当前实例，即 new 出来的当前对象。</p> 
<pre><code class="prism language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="3_Class__118"></a>3.当前类的 Class 对象锁</h3> 
<pre><code class="prism language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">AccountingSync</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h1>
<a id="4synchronized__126"></a>4.synchronized 底层原理</h1> 
<p>  synchronized 底层时通过内部对象 <code>Monitor(监视器锁)</code> 实现。</p> 
<p>  基于<code>进入与退出 Monitor 对象，来实现方法与代码块同步</code>。监视器锁的实现依赖底层操作系统的 Mutex lock（互斥锁：底层有一个互斥量，由操作系统维护，如果要对线程进行阻塞/上下文切换，也会涉及【用户态→内核态】的切换）实现。</p> 
<p>  synchronzied 锁，在JDK 6以前，是一个重量级锁，性能较低；JDK6 对 synchronzied 锁进行了比较大的优化，详细优化过程，继续往下看 <a href="">5.synchronized 锁优化升级过程</a>。</p> 
<p>  synchronized 翻译成汇编指令，就是 <code>monitorenter</code> 和 <code>monitorexit</code> 。这两个指令保证了同步块的进、出的标志，如图所示。</p> 
<p><img src="https://images2.imgbox.com/9a/42/zDq2Gfq3_o.png" alt="在这里插入图片描述"></p> 
<p>  我们已经了解了 synchronized 的三种加锁方式。<font color="green">每一个 Object 对象在被创建以后，其都会在 JVM 中维护一个与之相对应的 Monitor 对象。该 Monitor 对象就是控制加锁/解锁的对象</font>，<strong>我们又叫它</strong> <code>Monitor 管程对象</code>。所以 synchronized 是否加锁，以及锁的其他信息，都在这个对象的 Monitor 管程对象中记录。</p> 
<p><strong>示例：</strong></p> 
<p>  t1、t2、t3 三个线程，同时来到 monitorenter 临界点，开始共同竞争该对象中的 Monitor 管程对象。 <code>假如线程 t1 拿到管程对象，此时 t2、t3 将会被放到一个 waitSet 的阻塞等待队列中去，此时线程 t1 进入逻辑代码，执行逻辑，执行到 monitorExit 时，t1 会释放 monitor 对象，并发出一个通知，唤醒 waitSet 队列中等待的线程，通知 t2、t3 去抢锁</code>。<br> <img src="https://images2.imgbox.com/89/62/CMfozBvV_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="1Monitor__145"></a>1.Monitor 管程对象</h2> 
<p>  我们已经知道了 synchronized 加锁 &amp; 解锁，是通过一个叫做 Monitor 的管程对象来控制的。那这个对象在哪里定义的呢？这个对象又是怎么管理这些锁信息的呢？来聊聊 Monitor 管程对象</p> 
<p>  <code>1.每个锁对象里面，都会维护这样一个 ObjectMonitor 对象!!!</code></p> 
<p>  <code>2.Monitor 对象的定义，是在 JVM 源码中实现的。</code>要了解它，就需要来下载 OpenJDK Hotspot 源码进行分析了。下载源码地址：<a href="http://hg.openjdk.java.net/">http://hg.openjdk.java.net</a>。 <code>选择 jdk8，再选择 hotspot，再选择左侧的 browse，最后选择左侧的 zip 进行下载，解压即可</code>。hotspot 更多内容可参考：<a href="https://blog.csdn.net/qq_33996921/article/details/106334587">openJDK_HotSpot源码下载</a></p> 
<blockquote> 
 <p>ObjectMonitor 对象源码地址：<code>srcsharevmruntimeobjectMonitor.hpp</code></p> 
</blockquote> 
<h3>
<a id="1ObjectMonitor__154"></a>1.ObjectMonitor 对象属性说明</h3> 
<ol>
<li>
<code>_header</code> 属性，对象头（对象加锁信息，都保存在<code>对象头</code>中。该属性在 synchronized 锁升级中，会使用到）；</li>
<li>
<code>_count</code> 属性，用来计算加锁次数，可重入锁会用到；</li>
<li>
<code>_waiters</code> 属性，标识当前有多少处于 wait 等待状态的线程；</li>
<li>
<code>_owner</code> 属性，标识当前持有锁的线程（指向当前持有 ObjectMonitor 对象的线程）；</li>
<li>
<code>_WaitSet</code> 属性，处于 <code>wait 等待状态</code>的线程，会被加入到 waitSet 队列中；</li>
<li>
<code>_EntryList</code> 属性，处于等待加锁 <code>block 阻塞状态</code>的线程，会被加入到 entryList 队列中。<br> <img src="https://images2.imgbox.com/27/ed/x11y8AqU_o.png" alt="在这里插入图片描述">
</li>
</ol> 
<h3>
<a id="2ObjectMonitor__162"></a>2.ObjectMonitor 工作流程</h3> 
<ol>
<li> <p>多个线程同时访问某段同步代码，<code>首先所有线程会进入到 EntryList 队列</code>；</p> </li>
<li> <p><strong>在 EntryList 与 WaitSet 中的线程争夺锁</strong>。<code>成功获得锁的线程，会将锁对象中的 ObjectMonitor 对象的 count 值 +1，owner 属性设为自己的线程名称</code>；</p> </li>
<li> <p><code>如果线程调用 wait() 方法，该线程会放弃争夺当前锁中 ObjectMonitor 对象的权利，进入 WaitSet 线程进行等待，等待被唤醒</code>（<strong>通过notify() / notifyAll() 方法唤醒，只有被唤醒的线程，才能重新争夺锁资源</strong>）；</p> <p>3.1. 如果当前线程正好是已抢到锁的，则释放当前 monitor，owner 指针置为 NULL，count 减 1，转移到 WaitSet 中；</p> <p>3.2. 如果当前线程在 EntryList 队列中，则转移到 WaitSet 中；</p> </li>
<li> <p>如果<code>抢锁成功的线程执行完毕，释放 monitor 并复位变量的值，owner = NULL，count 减 1</code>，其他在 EntryList 与 WaitSet 中的所有线程开始新一轮所资源的争夺（WaitSet中被唤醒的线程，回去重新抢夺资源）</p> </li>
</ol> 
<p><img src="https://images2.imgbox.com/28/c5/8jJlNewx_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="3Java__173"></a>3.Java 对象内存结构</h3> 
<ol>
<li>
<strong>对象头</strong>：比如 <code>hash码</code>，<code>对象所属的年代</code>，<code>对象锁</code>，<code>锁状态标志</code>，<code>偏向锁（线程）ID</code>，<code>偏向时间</code>，<code>数组长度（数组对象</code>）等</li>
<li>
<strong>对象实际数据</strong>：即创建对象时，对象中成员变量，方法等</li>
<li>
<strong>对齐填充</strong>：对象的大小必须是8字节的整数倍</li>
</ol> 
<p>  Java 对象，包括：实例对象、类对象。它们两种对象内存结构基本一致。此处以实例对象说明，如图所示：</p> 
<p><img src="https://images2.imgbox.com/1d/2c/1nRRB2Ut_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="4_header__181"></a>4._header 对象头介绍(对象如何加锁)</h3> 
<p>  synchronized 锁住的只有这 2 种情况，不是<code>1.某个对象</code>，就是<code>2.某个类</code>。在 <a href="https://blog.csdn.net/lzb348110175/article/details/121452742#3Java__173">3.Java 对象内存结构</a> 中，我们已经知道：<code>实例对象和类对象的内存结构基本一致</code>，<font color="green"><strong>那么对象是如何进行加锁的呢？</strong></font></p> 
<p><img src="https://images2.imgbox.com/67/af/vGgodwNB_o.png" alt="在这里插入图片描述"><br>   了解 ObjectMonitor 对象属性后，知道 _header 对象头，保存的就是加锁的信息；在 synchronized 锁升级过程中，用到的也会是 _header 属性。此处来重点介绍一下 <code>_header</code> 对象头属性⬇⬇⬇⬇</p> 
<p>  <strong>HotSpot 虚拟机的对象头包括两部分信息：1.Mark Word  2.MetaData</strong></p> 
<p>  <code>第一部分“Mark Word”</code>，<strong>用于存储对象自身的运行时数据</strong>， 如<code>哈希码(HashCode)</code>、<code>GC分代年龄</code>、<code>锁状态标志</code>、<code>线程持有的锁</code>、<code>偏向线程ID</code>、<code>偏向时间戳</code>等等，这部分数据的长度在 32 位和 64 位的虚拟机（暂不考虑开启压缩指针的场景）中分别为 32 个和 64 个Bits，官方称它为 “Mark Word” 。对象需要存储的运行时数据很多，其实已经超出了 32、64 位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。<font color="red">(对象头在 32位 和 64位中，记录还是有点不同的，但是整体上逻辑是一样的)</font></p> 
<p>  <strong>如果对象是数组类型，则需要三个机器码，因为 JVM 虚拟机可以通过 Java 对象的元数据信息确定 Java 对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度</strong>。(可参考：<a href="https://blog.csdn.net/lzb348110175/article/details/121452742#3Java__173">3.Java 对象内存结构</a> 结构图)</p> 
<p>  在 32 位的 HotSpot 虚拟机中，对象在未被锁定的状态下，MarkWord 的 32 个 Bits 空间中的 <code>25 Bits用于存储对象哈希码(HashCode)</code>，<code>4 Bits用于存储对象分代年龄</code>，<code>1 Bit 用于存储是否是偏向锁</code>，<code>2 Bits用于存储锁标志位</code>。如下表所示</p> 
<table><tbody>
<tr><th colspan="4">32位虚拟机</th></tr>
<tr>
<td>25Bit </td>
<td>4Bit</td>
<td>1Bit</td>
<td>2Bit</td>
</tr>
<tr>
<td>对象的HashCode</td>
<td>对象的分代年龄</td>
<td>是否是偏向锁</td>
<td>锁标志位</td>
</tr>
</tbody></table> 
<p>  在 64 位的 HotSpot 虚拟机中，对象在未被锁定的状态下，MarkWord 的 64 个 Bits 空间中的 <code>25Bits 未使用</code>，<code>31 Bits用于存储对象哈希码(HashCode)</code>，<code>1Bit 未使用</code>，<code>4 Bits用于存储对象分代年龄</code>，<code>1 Bit 用于存储是否是偏向锁</code>，<code>2 Bits用于存储锁标志位</code>。如下表所示</p> 
<table><tbody>
<tr><th colspan="6">64位虚拟机</th></tr>
<tr>
<td>25Bit</td>
<td>31Bit </td>
<td>1Bit</td>
<td>4Bit</td>
<td>1Bit</td>
<td>2Bit</td>
</tr>
<tr>
<td>unused(未使用)</td>
<td>对象的HashCode</td>
<td>unused(未使用)</td>
<td>对象的分代年龄</td>
<td>是否是偏向锁</td>
<td>锁标志位</td>
</tr>
</tbody></table> 
<blockquote> 
 <p>Hotspot 虚拟机中，对象头存储的内容，源码地址：<code>srcsharevmoopsmarkOop.hpp</code></p> 
</blockquote> 
<p><strong>源码如图所示：</strong><br> <img src="https://images2.imgbox.com/ab/b2/mceR9GBB_o.png" alt="在这里插入图片描述"><br>   <code>第二部分是 Meta Data</code>，元数据指针，<code>指向当前实例对象的类</code>，这块和 synchronized 锁没关系，本文不对这块做介绍。主要是 <code>Mark Word</code>，JDK 6 中 synchronized 锁升级就会用到 Mark Word 内容。</p> 
<h2>
<a id="2JDK_6_synchronized__243"></a>2.JDK 6 synchronized 锁优化升级过程</h2> 
<p>  在 JDK 6 之前，使用 synchronized 就直接是重量级锁，严重影响性能，被人所诟病。在 JDK 6 中，对 synchronzied 锁进行了一次大的改进。改进后的 synchronized 就属于真香系列了。</p> 
<p>  到这里，相信你对对象头中的 <code>Mark Word</code> 有了一定的认识。以32位为例，<code>1 Bit 存储锁是否是偏向锁</code>，<code>2 Bit 存储锁标志位</code>。在 synchronized 锁升级的过程中，用到的主要就是这两个标识。</p> 
<p>  锁的状态总共有四种，<code>无锁状态</code>、<code>偏向锁</code>、<code>轻量级锁</code>和<code>重量级锁</code>。<font color="green">随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级</font>。<strong>针对 synchronized 四种锁状态，Mark Word 中具体存储内容如下：</strong></p> 
<table><tbody>
<tr>
<th colspan="1" rowspan="2"> 锁状态</th>
<th colspan="2" rowspan="1"> 25Bit</th>
<th colspan="1" rowspan="2">4Bit</th>
<th colspan="1" rowspan="1">1Bit</th>
<th colspan="1" rowspan="1">2Bit</th>
</tr>
<tr>
<td>23Bit </td>
<td>2Bit</td>
<td>是否是偏向锁</td>
<td>锁标志位</td>
</tr>
<tr>
<td><font color="#777">GC标记</font></td>
<td colspan="4"> 空 </td>
<td>11</td>
</tr>
<tr>
<td><font color="red">重量级锁</font></td>
<td colspan="4"> 指向重量级锁Monitor的指针（依赖Mutex操作系统的互斥） </td>
<td>10</td>
</tr>
<tr>
<td><font color="orange">轻量级锁</font></td>
<td colspan="4"> 指向线程栈中锁记录的指针(pointer to Lock Record )</td>
<td>00</td>
</tr>
<tr>
<td><font color="blue">偏向锁</font></td>
<td>线程ID</td>
<td>Epoch</td>
<td>对象分代年龄</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td><font color="green">无锁</font></td>
<td colspan="2">对象的 hashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody></table> 
<blockquote> 
 <p>GC标记：指的就是对象所没用了，要回收了</p> 
</blockquote> 
<h3>
<a id="1_299"></a>1.锁的四种状态介绍</h3> 
<h4>
<a id="1_300"></a>1.无锁</h4> 
<p>  初始化时，对象没有被访问，处于无锁状态</p> 
<h4>
<a id="2_303"></a>2.偏向锁</h4> 
<p>  <code>当前锁对象，只有一个线程访问，访问不是很激烈时，使用偏向锁</code>。偏向锁在 JDK6 以后才有，开启偏向锁，大概可以提升10%性能。JDK 7 / JDK 8 默认是开启偏向锁的。</p> 
<blockquote> 
 <p>开启偏向锁：<code>-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</code><br> 关闭偏向锁：<code>-XX:-UseBiasedLocking</code></p> 
</blockquote> 
<p>  如果JDK6之前，使用 synchronized 修饰，直接就申请一个互斥锁，另一个线程来了，直接阻塞。【会严重影响性能，所以在 synchronized 优化时，才有了锁4种状态】</p> 
<p>  JVM 作者认为大多数线程在进入到锁的状态之后，是没有竞争的，更多的可能是一个单线程的访问，单线程没必要向底层申请一个重量级锁，做一个偏向锁就 OK 了。</p> 
<h4>
<a id="3_313"></a>3.轻量级锁</h4> 
<p>  顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅将 Mark Word 中的部分字节 CAS更新指向线程栈中的 Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</p> 
<p>  当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。</p> 
<p>  <strong>适用场景：</strong><code>竞争不激烈，执行时间都不会太长的情况</code>。线程间交替执行，有很短一段时间两个线程存在竞争，此时轻量级锁会让后进来的线程进行自旋，等待前一个线程执行完毕。</p> 
<p>  <code>自旋锁的目标，就是降低线程切换的成本</code>。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。</p> 
<p>  <code>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等</code>。</p> 
<p><strong>示例场景：</strong></p> 
<ol>
<li>线程1开始执行，如果线程 1 没执行完成时，线程 2 进来了。线程 2 则会进行自旋，自旋不会丢弃 CPU 使用权，自旋锁的目标是降低线程切换的成本，JDK7 之前自旋次数可根据自己的要求手动设置。</li>
<li>如果自旋指定的次数后，线程 1 还没有执行完毕，则会升级为 重量级锁；</li>
<li>如果自旋一段时间，线程 1 执行完毕了，线程 2 获得锁后，则继续执行自己的逻辑。</li>
</ol> 
<p><img src="https://images2.imgbox.com/ff/bc/YbAa5aK8_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>  JDK 7 之后，JVM 可以智能的去调整自旋的最佳次数了。自旋就是一个循环空跑。JDK7 中设计了一个智能算法，自旋次数可以根据上一次自旋成功的次数，智能、弹性的调整本次自旋次数，叫做<code>自适应自旋锁</code></p> 
</blockquote> 
<h4>
<a id="4_333"></a>4.重量级锁</h4> 
<p>  重量级锁是依赖对象内部的 monitor 锁来实现的，而 monitor 又依赖操作系统的 Mutex Lock(互斥锁)来实现的，所以重量级锁也称为互斥锁。另一个线程来了，直接阻塞。</p> 
<p><strong>为什么重量级线程开销很大的？</strong></p> 
<p>  当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗 CPU。<code>但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长</code>。</p> 
<h3>
<a id="2synchronized__341"></a>2.synchronized 锁升级流程图</h3> 
<p><img src="https://images2.imgbox.com/7a/9b/7fzx4qe1_o.png" alt="在这里插入图片描述"></p> 
<h3>
<a id="3_synchronized__343"></a>3.示例演示 synchronized 锁升级全过程</h3> 
<p><strong>场景：</strong><br>    两个线程 t1 和 t2，对共享资源进行访问，来演示锁的四个状态变化过程。</p> 
<p><strong>锁升级场景图：</strong><br> <img src="https://images2.imgbox.com/dc/86/n9kYwXVW_o.png" alt="请添加图片描述"><br> <strong>32位JVM 中 Mark Word 不同锁状态下的存储内容，此处再来一次，方便查看</strong></p> 
<table><tbody>
<tr>
<th colspan="1" rowspan="2"> 锁状态</th>
<th colspan="2" rowspan="1"> 25Bit</th>
<th colspan="1" rowspan="2">4Bit</th>
<th colspan="1" rowspan="1">1Bit</th>
<th colspan="1" rowspan="1">2Bit</th>
</tr>
<tr>
<td>23Bit </td>
<td>2Bit</td>
<td>是否是偏向锁</td>
<td>锁标志位</td>
</tr>
<tr>
<td><font color="#777">GC标记</font></td>
<td colspan="4"> 空 </td>
<td>11</td>
</tr>
<tr>
<td><font color="red">重量级锁</font></td>
<td colspan="4"> 指向重量级锁 Monitor 的指针（依赖 Mutex 操作系统的互斥） </td>
<td>10</td>
</tr>
<tr>
<td><font color="orange">轻量级锁</font></td>
<td colspan="4"> 指向线程栈中锁记录的指针(pointer to Lock Record )</td>
<td>00</td>
</tr>
<tr>
<td><font color="blue">偏向锁</font></td>
<td>线程ID</td>
<td>Epoch</td>
<td>对象分代年龄</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td><font color="green">无锁</font></td>
<td colspan="2">对象的 hashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody></table> 
<h4>
<a id="1___397"></a>1.无锁 → 偏向锁</h4> 
<p>  线程 t1 访问，此时锁对象 Mark Word 处于无锁状态，检查锁标志位是否位 01，是的话，检查倒数第3位，是无锁状态还是偏向锁状态。</p> 
<p>  初次进来，还是无锁状态，线程 t1 会将锁升级为偏向锁（利用CAS算法将倒数第三位修改为1）。偏向锁不会自动释放，只有其他线程和他竞争时才会去释放，否则会一直偏向当前线程 t1。</p> 
<p>  此时线程 t1 进入 monitorenter，开始执行同步块内容。<code>此是线程 t2 也来了，和线程 t1 处于并发状态</code>。线程 t2 会去检查当前锁的偏向线程 ID是否是自己的 ID，如果不是自己，则锁已经被别人占用，此时 CAS 会尝试去修改一次(<font color="red">为什么还要修改？</font><font color="green">考虑到修改的同时，如果线程 t1 刚好释放掉锁，正好就OK</font>)，如果 CAS 修改失败，线程 t2 就会向 JVM 虚拟机申请撤销偏向锁。</p> 
<p>  线程 t1 此时如果还没执行完，多线程再 CPU 底层调用的是时间片，等到达一个安全点时，此时会再次检查线程 t1 的运行状态。如果线程 t1 运行完毕退出了同步块，此时处于解锁状态，那么通过 CAS 锁，对象会将末三位的状态由 1 变为 0 。然后线程 t2 获取锁，将 Mark Word 对象头中的线程 ID 替换为自己的 ID，开始执行自己的逻辑即可，此时就不需要由偏向锁升级至轻量级锁。</p> 
<h4>
<a id="2___406"></a>2.偏向锁 → 轻量级锁</h4> 
<p>  到达安全点，并不意味着线程 t1 已经执行完毕。如果线程 t1 还未执行完毕，那么将开始 <code>偏向锁 → 轻量级锁</code> 的升级。</p> 
<p>  暂停线程 t1 ，通过 CAS 设置锁标志位为 00 (变为轻量级锁)。线程 t1 和 t2 在自己线程栈上开辟一块空间 Lock Record，同时将 Mark Word 对象头数据复制一份到自己的 Lock Record 空间中。并将 Mark Word 中的前 30 位指向线程 t1 栈中所记录的指针。</p> 
<p>  偏向锁 → 轻量级锁，升级成功。</p> 
<h4>
<a id="3___413"></a>3.无锁 → 轻量级锁</h4> 
<p>  初次进入，属于无锁状态。线程 t1 和 线程 t2 存在竞争。</p> 
<p>  <font color="green">此时两个线程处于并发状态，每个线程都会在当前线程栈上开辟一块空间 Lock Record，同时将 Mark Word 对象头数据复制一份到自己的 Lock Record 空间中。</font></p> 
<p>  <strong>同时还会在 Lock Record 中定义一些变量，比如 owner 等</strong>，然后 Mark Word 的前 30 位清空，记录为线程栈中锁记录的指针，同时 Lock Record 的 owner 属性，也有个指针指向 Mark Word，<code>这就是一个双向指针，线程的栈空间和 Mark Word 双向互指对方</code>。</p> 
<p>  此时线程 t1 和线程 t2 就处于一个竞争状态，目前还不知道哪个线程获得锁，owner 属性等都为空。两个线程都开始通过 CAS算法修改 Mark Word 中的指针指向地址，准备升级为轻量级锁。</p> 
<p>  线程 t1 如果修改成功，拿到锁后，Mark Word 中的前 30 位指向线程 t1 栈中所记录的指针。就开始执行自己的同步逻辑块，线程 t2 发现自己修改失败，便进入<code>for( ; ; )</code>自旋阶段。</p> 
<h4>
<a id="4__424"></a>4.轻量级锁–&gt; 重量级锁</h4> 
<p>  <font color="red">当线程 t2 自旋一定次数后，发现线程 t1 还没执行完毕，线程 t2 自旋失败后，线程 t2 请求 JVM 进行锁升级，将自己的锁膨胀为重量级锁。<u>同时将 Mark Word 中的前 30 位指针指向重量级锁</u>。</font></p> 
<p>  线程 t2 会调用 pThread ，去底层申请一个互斥量。此时就会涉及【用户态 → 内存态】的切换，需要调用系统内核申请互斥量，状态转换是一个非常耗时、耗费资源的过程。（pThread参考：<a href="https://blog.csdn.net/lzb348110175/article/details/121354966">提起线程，你不了解的那些事</a>）</p> 
<p>  此时，锁的对象头 Mark Word 前 30 位，不再指向当前拥有锁的线程 t1，而是指向重量级锁。然后线程 t2 会调用底层 pThread.Mutex 方法，操作将自己成为阻塞挂起状态。所有的阻塞线程，都会放在 ObjectMonitor 的 waitSet 队列中去。</p> 
<p>  此时线程 t1 执行完同步代码后，开始释放锁，通过 CAS 修改 Mark Word，发现前 30位 指针并不是指向自己线程 t1 。<code>这时线程 t1 在释放轻量级锁时，则会去唤醒被阻塞的线程，进行新一轮的锁竞争。</code></p> 
<h1>
<a id="5_____433"></a>5.锁粗化 &amp; 锁消除 &amp; 逃逸分析</h1> 
<h2>
<a id="1_434"></a>1.锁粗化</h2> 
<p>  原则上，锁的粒度要尽量小，因为这样可以提高并发度，但是假如一系列的连环操作都是对同一个对象反复加锁，解锁，比如把锁加载在循环体里，单次同步操作的时间也许很短，但是高频反复的锁请求、同步和释放，也会对系统资源造成一定消耗，可能还不如加一把大锁。而锁粗化就是增大锁的作用域，把很多次锁的请求合并成一个请求，以此来降低短时间内大量锁请求、同步、释放带来的性能损耗。</p> 
<p>  <strong>场景：</strong> JVM 会检测到这样一连串的操作都对同一个对象加锁（for 循环内1000次执行append，没有锁粗化得话就要执行1000次加锁/解锁），此时JVM就会将加锁的范围粗化到这一连串的操作的外部（比如for 循环外），使得这一连串操作只需要加一次锁即可。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>

    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * 锁的粗化
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// StringBuffer 线程安全，每个 append 操作都会加锁，针对多次 append 操作的情况，JVM 会对锁进行粗化</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2>
<a id="2_454"></a>2.锁消除</h2> 
<h3>
<a id="1_455"></a>1.什么是锁消除</h3> 
<p>  虚拟机的即时编译器在运行时，会对一些代码上要求是同步的，但被检测到其实不可能存在共享数据竞争的<code>锁进行消除，主要判定依据来源于逃逸分析的数据支持</code>，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p> 
<p>  比如 StringBuffer 的 append 方法用了 synchronized 关键词，它是线程安全的。但我们可能仅在线程内部把 StringBuffer 当作局部变量使用：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * 锁的消除
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> str1<span class="token punctuation">,</span> <span class="token class-name">String</span> str2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">StringBuffer</span> sBuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// append方法是同步操作</span>
        sBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sBuf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  <strong>代码中 createStringBuffer 方法中的局部对象 sBuf</strong>，<strong><code>就只在该方法内的作用域有效，不同线程同时调用 createStringBuffer() 方法时，都会创建不同的 sBuf 对象，因此此时的 append 操作若是使用同步操作，就是白白浪费的系统资源</code></strong>。</p> 
<p>  这时我们可以通过编译器将其优化，将锁消除，前提是 Java 必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析：</p> 
<blockquote> 
 <p>-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks<br>  <br> <strong>其中：</strong><br>  <br>   +DoEscapeAnalysis   表示开启逃逸分析，<br>   +EliminateLocks   表示锁消除。</p> 
</blockquote> 
<p>  <font color="red"><strong>逃逸分析</strong></font>：<font color="green">比如上面的代码，它要看sBuf是否可能逃出它的作用域？</font>,<u>如果将 sBuf 作为方法的返回值进行返回，<strong>那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题</strong>，这时就可以说 sBuf 这个对象发生逃逸了，因而不应将 append 操作的锁消除</u>，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。</p> 
<h3>
<a id="2_486"></a>2.锁消除实例</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * 锁的消除
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> str1<span class="token punctuation">,</span> <span class="token class-name">String</span> str2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">StringBuffer</span> sBuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// append方法是同步操作</span>
        sBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sBuf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   	<span class="token punctuation">}</span>
   	
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用时:"</span> <span class="token operator">+</span> <span class="token punctuation">(</span> end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>关闭逃逸分析、关闭锁消除。JVM配置如下参数：<code>-XX:-DoEscapeAnalysis -XX:-EliminateLocks</code><br> 用时：337ms</p> 
</blockquote> 
<blockquote> 
 <p>开启逃逸分析、开启锁消除。JVM配置如下参数：<code>-XX:+DoEscapeAnalysis -XX:+EliminateLocks</code>(JDK 8 默认这两者都开启)<br> 用时：155ms</p> 
</blockquote> 
<p>  这就说明了逃逸分析把锁消除了，并在性能上得到了很大的提升。这里说明一下Java的逃逸分析是方法级别的，因为JIT的即时编译是方法级别。【除了方法逃逸，还有线程逃逸，继续看下面的逃逸分析】</p> 
<h2>
<a id="3_521"></a>3.逃逸分析</h2> 
<p><code>面试题： 实例对象在内存中，存储在哪？</code></p> 
<p>  <strong>实例对象存储在堆区时：</strong><font color="green">实例对象内存存在堆区，实例的引用存在栈上，实例的元数据class存在方法区或者元空间。</font><font color="red">但是，实例对象并不一定是存在堆区。只有在对象没有线程逃逸行为时，才全部存在堆区。如果发生线程逃逸行为，部分对象是会存在<strong>线程栈</strong>中的。</font></p> 
<hr> 
<h3>
<a id="1_527"></a>1.什么是逃逸分析</h3> 
<p>  逃逸分析，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析（Escape Analysis）算是目前Java虚拟机中比较前沿的优化技术了。Java 从 JDK6 才开始引入该技术。</p> 
<h3>
<a id="2_530"></a>2.逃逸分析的原理</h3> 
<p>  Java 本身的限制（对象只能分配到堆中），我们可以这么理解，为了减少临时对象在堆内分配的数量，我会在一个方法体内定义一个局部变量，并且该变量在方法执行过程中未发生逃逸，按照 JVM 调优机制，首先会在堆内存创建类的实例，然后将此对象的引用压入调用栈，继续执行，这是 JVM 优化前的方式。</p> 
<p>  然后，我采用逃逸分析对 JVM 进行优化。即针对栈的重新分配方式，首先找出未逃逸的变量，将该变量直接存到栈里，无需进入堆，分配完成后，继续调用栈内执行，最后线程执行结束，栈空间被回收，局部变量也被回收了。如此操作，是优化前在堆中，优化后在栈中，从而减少了堆中对象的分配和销毁，从而优化性能。</p> 
<h3>
<a id="3_535"></a>3.逃逸的方式</h3> 
<p>  <font color="green">方法逃逸：</font>在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。</p> 
<p>  <font color="green">线程逃逸：</font>这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程。</p> 
<h3>
<a id="4_540"></a>4.逃逸分析，编译器对代码做了如下优化</h3> 
<ol>
<li>同步消除(锁消除)。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。（例子参考：<a href="https://blog.csdn.net/lzb348110175/article/details/121452742#2_486">2.锁消除实例</a>）</li>
<li>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。（例子参考：<a href="https://blog.csdn.net/lzb348110175/article/details/121452742#1_556">逃逸分析实例</a>）</li>
<li>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。<br>   <strong>这个简单来说就是把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有，一、减少内存使用，因为不用生成对象头。 二、程序内存回收效率高，并且GC频率也会减少，总的来说和上面优点一的效果差不多</strong>。</li>
</ol> 
<h3>
<a id="5_546"></a>5.逃逸分析命令</h3> 
<ul>
<li> <p>开启逃逸分析（JDK8中，逃逸分析默认开启）<br> <code>-XX:+DoEscapeAnalysis</code></p> </li>
<li> <p>关闭逃逸分析<br> <code>-XX:-DoEscapeAnalysis</code></p> </li>
<li> <p>查看逃逸分析结果<br> <code>jps -l</code><br> <code>jmap -histo id号</code></p> </li>
</ul> 
<h3>
<a id="6_556"></a>6.代码展示</h3> 
<h4>
<a id="1_557"></a>1.创建的对象并没有被方法外使用(发生逃逸)</h4> 
<p>  for 循环创建 5w 个 People 对象，只创建，方法外并没有使用。采用 JDK8 默认开启逃逸分析</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 休眠100s,只是为了jmap -histo命令查看逃逸情况(不休眠,执行完就结束了,无法查看)</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 创建 People 对象</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">People</span> people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 内部类
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这种情况下创建的 people 实例，并不会被外部其他变量所使用，只是一个局部变量。开启 逃逸分析后，JVM 智能分析，实际 5w 个实例，在堆区只生成了 17792 个，其他实例都存储在当前线程栈中。<br> <img src="https://images2.imgbox.com/58/25/O4oWC2E8_o.png" alt="在这里插入图片描述"><br> 此处，通过 <code>-XX:-DoEscapeAnalysis</code> 关闭逃逸分析的话，也是会在堆区生成 5w 个实例的，可以自己来测试一下。</p> 
<hr> 
<h4>
<a id="2_593"></a>2.创建的对象可能会被方法外部使用(未发生逃逸)</h4> 
<p>  for 循环创建 5w 个 People 对象，通过 return 的方式返回，方法外可能会使用。采用 JDK8 默认开启逃逸分析</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 休眠100s,只是为了jmap -histo命令查看逃逸情况(不休眠,执行完就结束了,无法查看)</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 创建 People 对象(return 方式返回)</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">People</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 内部类
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这种情况下创建的 people 实例，通过 return 方式返回。JVM 分析到这些实例<code>可能</code>会被方法外部使用，它就会将对象全部存在堆区。<br> <img src="https://images2.imgbox.com/3d/56/wLRI5Stu_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>  <font color="red">2021-11-23，《synchronized 原理、使用、锁升级过程，写到我要吐血了》已更新，接下来将讲解： Lock 锁，ReentrantLock 可重入锁，ReentrantLock 源码解析，AQS 同步队列，Condition条件队列，如有需要，请持续关注《并发编程》板块！！！</font></p> 
<blockquote> 
 <p>参考：</p> 
 <ol>
<li><a href="https://www.cnblogs.com/weixuqin/p/11429005.html">synchronized（修饰方法和代码块）</a></li>
<li><a href="https://www.cnblogs.com/amunote/p/10328164.html">锁消除</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/401057707">每日一道面试题-什么是逃逸分析？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/59215831">Java之逃逸分析</a></li>
</ol> 
</blockquote> 
<hr> 
<p><font color="#3399EA" size="2"><strong>博主写作不易，加个关注呗</strong></font></p> 
<p><font color="#3399EA" size="2"><strong>求关注、求点赞，加个关注不迷路 ヾ(◍°∇°◍)ﾉﾞ</strong></font></p> 
<p><font color="#3399EA" size="2"><strong>我不能保证所写的内容都正确，但是可以保证不复制、不粘贴。保证每一句话、每一行代码都是亲手敲过的，错误也请指出，望轻喷 Thanks♪(･ω･)ﾉ</strong><font color="#3399EA"></font></font></p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>