<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>NFT合约分析:ERC721A - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NFT合约分析:ERC721A</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <h2>
<a id="_0"></a>概述</h2> 
<p>读者可前往<a href="https://blog.wssh.trade/posts/erc721a-contract/">我的博客</a>获得更好的阅读体验。</p> 
<p>本文主要介绍标准NFT实现的一个变体，即<code>ERC721A</code>合约实现的相关细节。<code>ERC721A</code>是由著名NFT系列<a href="https://www.azuki.com/">Azuki</a>提出，该系列NFT是著名的蓝筹NFT。本文主要聚焦于<code>Azuki</code>提出的<code>ERC721A</code>合约的代码细节分析。</p> 
<p>与传统的<code>ERC721</code>实现相比，<code>ERC721A</code>在批量铸造(batch mint)方面具有显著的<code>gas</code>优势，这得益于<code>ERC721A</code>的惰性初始化方面的设计。关于<code>ERC721A</code>与普通<code>ERC721</code>实现的对比，我们将会在下文展开说明。</p> 
<p>本文要求读者具有基础的<code>solidity</code>知识，希望读者对标准<code>ERC721</code>有所了解。</p> 
<p>读者可在阅读本文前，酌情阅读以下参考材料:</p> 
<ul>
<li><a href="https://www.erc721a.org/">ERC721A 官网</a></li>
<li><a href="https://github.com/chiru-labs/ERC721A">ERC721A 官方仓库</a></li>
<li><a href="https://www.azuki.com/erc721a">Azuki ERC721A 介绍</a></li>
</ul> 
<p>本文基于目前的最新版本(<code>4.2.3</code>)合约代码进行分析。</p> 
<h2>
<a id="ERC721_17"></a>ERC721实现</h2> 
<p>由于下文涉及到<code>ERC721A</code>与<code>ERC721</code>的技术对比，考虑到部分读者可以对<code>ERC721</code>合约实现并不清楚，本节简要的介绍<code>ERC721</code>正常实现的铸造功能，本节主要基于<a href="https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol">solmate</a>的实现版本。</p> 
<blockquote> 
 <p><code>solmate</code>实现都较为短小精悍且经过<code>gas</code>优化，我个人较为推崇。<code>solmate</code>的<code>ERC721</code>实现仅有 231 行，读者可自行阅读。</p> 
</blockquote> 
<p>在<code>solmate</code>合约中，我们可以看到核心数据结构为:</p> 
<pre><code class="prism language-solidity">mapping(uint256 =&gt; address) internal _ownerOf;
mapping(address =&gt; uint256) internal _balanceOf;
</code></pre> 
<p>其中，各映射功能如下:</p> 
<ul>
<li>
<code>_ownerOf</code> 记录 tokenId 与持有者的关系</li>
<li>
<code>_balanceOf</code> 记录持有人所持有的 NFT 数量</li>
</ul> 
<p>其铸造方法定义如下:</p> 
<pre><code class="prism language-solidity">function _mint(address to, uint256 id) internal virtual {
    require(to != address(0), "INVALID_RECIPIENT");

    require(_ownerOf[id] == address(0), "ALREADY_MINTED");

    // Counter overflow is incredibly unrealistic.
    unchecked {
        _balanceOf[to]++;
    }

    _ownerOf[id] = to;

    emit Transfer(address(0), to, id);
}
</code></pre> 
<p>通过此函数，我们更新了<code>_ownerOf</code>和<code>_balanceOf</code>实现用户铸造 NFT 的功能。我们可以发现用户每次铸造NFT都需要更新<code>_ownerOf</code>和<code>_balanceOf</code>映射。众所周知，在操作码<code>gas</code>消耗中，更新存储需要消耗大量<code>gas</code>。如果用户批量铸造，会在此过程中消耗大量<code>gas</code>。</p> 
<blockquote> 
 <p>根据<a href="https://crocswap-assets-public.s3.us-east-2.amazonaws.com/EVMGasOptim.pdf">数据</a>(PDF警告)，在ETH价格为 1500 美元时，更新存储的价格为 7.5 美元，而写入存储的价格为 30 美元。这意味着仅在<code>mint</code>过程中，更新映射会浪费大量资产。</p> 
</blockquote> 
<p>转账函数定义如下:</p> 
<pre><code class="prism language-solidity">function transferFrom(
    address from,
    address to,
    uint256 id
) public virtual {
    require(from == _ownerOf[id], "WRONG_FROM");

    require(to != address(0), "INVALID_RECIPIENT");

    require(
        msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],
        "NOT_AUTHORIZED"
    );

    // Underflow of the sender's balance is impossible because we check for
    // ownership above and the recipient's balance can't realistically overflow.
    unchecked {
        _balanceOf[from]--;

        _balanceOf[to]++;
    }

    _ownerOf[id] = to;

    delete getApproved[id];

    emit Transfer(from, to, id);
}
</code></pre> 
<p>由于对于每个<code>tokenId</code>都维护有一个<code>mapping</code>映射，所以转账逻辑实现也较为简单。</p> 
<p>总体来看，对于每一个NFT，在<code>solmate</code>实现的智能合约中，都维持有以下两个映射:</p> 
<ul>
<li>
<code>mapping(uint256 =&gt; address) internal _ownerOf;</code> 标识NFT的拥有者</li>
<li>
<code>mapping(uint256 =&gt; address) public getApproved;</code> 记录NFT的授权情况</li>
</ul> 
<h2>
<a id="_98"></a>优势</h2> 
<p>在上一节中，我们介绍了常规NFT实现的基本情况，正如上文所述，常规实现在批量<code>mint</code>铸造阶段会消耗大量<code>gas</code>。为了解决这一问题，<code>ERC721A</code>引入惰性初始化机制。简单来说，在批量铸造时，不再记录<code>tokenId</code>与用户地址的映射关系，而是记录起始<code>tokenId</code>和数量与用户的映射关系。在本节中，我们不对此实现的技术细节进行分析，我们会在本文稍后部分对此进行讨论。</p> 
<p>在批量铸造阶段，<code>ERC721A</code>与<code>OpenZeppelin</code>实现的对比如下:</p> 
<table>
<thead><tr>
<th></th>
<th>ERC721</th>
<th>ERC721A</th>
</tr></thead>
<tbody>
<tr>
<td>批量铸造 5 个 NFT</td>
<td>155949 gas</td>
<td>63748 gas</td>
</tr>
<tr>
<td>转移 5 个 NFT</td>
<td>226655 gas</td>
<td>334450 gas</td>
</tr>
<tr>
<td>铸造的 Base Fee</td>
<td>200 gwei</td>
<td>200 gwei</td>
</tr>
<tr>
<td>转移的 Base Fee</td>
<td>40 gwei</td>
<td>40 gwei</td>
</tr>
<tr>
<td>总花费</td>
<td>0.0403 ether</td>
<td>0.0261 ether</td>
</tr>
</tbody>
</table> 
<blockquote> 
 <p>如果读者对于此处的<code>gas</code>计算的细节感兴趣，可以阅读<a href="https://hugo.wongssh.cf/posts/ethereum-gas/">以太坊机制详解:Gas Price计算</a>。我们在此处不详细讨论计算方式。我们可以注意到铸造阶段的<code>Base fee</code>较高，这考虑到了NFT铸造导致的网络拥堵情况。</p> 
</blockquote> 
<p>显然，惰性初始化机制对于批量铸造阶段的<code>gas</code>节省是具有明显优势的，但惰性加载将初始化的成本转移到了转账部分，我们可以看到在转移NFT时的成本有所上升。但需要注意，第一次转账后由于彻底完成了初始化，所有后续转账的成本会降低，如下:</p> 
<table>
<thead><tr>
<th></th>
<th>ERC721</th>
<th>ERC721A</th>
</tr></thead>
<tbody>
<tr>
<td>First transfer</td>
<td>45331 gas</td>
<td>92822 gas</td>
</tr>
<tr>
<td>Subsequent transfers</td>
<td>45331 gas</td>
<td>44499 gas</td>
</tr>
</tbody>
</table> 
<p>通过表格可以看出，除第一次转账消耗的<code>gas</code>明显增多，但随后转账的价格与常规的NFT转账并无区别。</p> 
<p>总结来说，<code>ERC721A</code>实现了低成本的批量铸造，但将部分成本转移到了第一次转账中。这种设计充分考虑到了铸造阶段可能出现的以太坊网络拥堵而造成<code>gas</code>价格飙升的情况，而用户后期转账是偶发的且不会导致网络拥堵的。通过这种特殊的成本转嫁机制，<code>ERC721A</code>降低用户的总成本。</p> 
<blockquote> 
 <p>换言之，如果您认为您的NFT项目不存在批量铸造的情况或不会导致以太坊网络拥堵，可以选择常规NFT实现。</p> 
</blockquote> 
<h2>
<a id="_127"></a>具体实现</h2> 
<p>在讨论了<code>ERC721A</code>的基本内容后，为进一步增加我们对<code>ERC721A</code>的理解，我们将对其合约进行阅读分析。<code>ERC721A</code>的开源仓库位于<a href="https://github.com/chiru-labs/ERC721A/blob/main/contracts/ERC721A.sol">github</a>。此处，我们仅讨论<code>ERC721A</code>的主合约，而暂不讨论<code>extensions</code>部分。</p> 
<p>对于NFT合约的分析，存储数据结构和<code>_mint</code>函数是一个很好的入手点。我们首先关注存储数据结构。</p> 
<p>在NFT数据存储中，我们可以看到<code>solmate</code>等常规实现都使用了<code>mapping(uint256 =&gt; address) internal _ownerOf</code>将单个<code>tokenId</code>与持有者对应。但<code>ERC721A</code>是对批量铸造进行特殊优化的，开发者认为在批量铸造过程中，用户持有的NFT的<code>tokenId</code>往往是连续的，如下图:</p> 
<p><img src="https://images2.imgbox.com/7b/80/Ct5h7O75_o.png" alt="ERC721A TokenId"></p> 
<h3>
<a id="_137"></a>基本数据结构</h3> 
<p>在批量铸造过程中，用户铸造连续的NFT是极其常见的。为了实现连续分配<code>tokenID</code>以降低<code>gas</code>消耗的目的，我们需要一些更加复杂的数据结构设计，具体代码设计如下:</p> 
<pre><code class="prism language-solidity">// The next token ID to be minted.
uint256 private _currentIndex;

// The number of tokens burned.
uint256 private _burnCounter;

// Token name
string private _name;

// Token symbol
string private _symbol;

// Mapping from token ID to ownership details
// An empty struct value does not necessarily mean the token is unowned.
// See {_packedOwnershipOf} implementation for details.
//
// Bits Layout:
// - [0..159]   `addr`
// - [160..223] `startTimestamp`
// - [224]      `burned`
// - [225]      `nextInitialized`
// - [232..255] `extraData`
mapping(uint256 =&gt; uint256) private _packedOwnerships;

// Mapping owner address to address data.
//
// Bits Layout:
// - [0..63]    `balance`
// - [64..127]  `numberMinted`
// - [128..191] `numberBurned`
// - [192..255] `aux`
mapping(address =&gt; uint256) private _packedAddressData;

// Mapping from token ID to approved address.
mapping(uint256 =&gt; TokenApprovalRef) private _tokenApprovals;

// Mapping from owner to operator approvals
mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;
</code></pre> 
<p>与其他简单参数相比，我们主要关注复杂的参数:</p> 
<ol>
<li>
<code>_packedOwnerships</code> 类似常规NFT实现中的<code>_ownerOf</code>，我们通过此映射查询某 <code>tokenID</code> 的拥有者，但此结构是打包方式的，即我们并不指定每一个 tokenID 对应的拥有者而是仅记录开头</li>
<li>
<code>_packedAddressData</code> 类似常规NFT实现中的 <code>_balanceOf</code> ，用于查询某一用户所拥有的NFT的相关数据。此处的<code>aux</code>是指附加信息，比如用户当前使用的NFT铸造白名单数量，请根据自身项目酌情修改</li>
</ol> 
<p>此处，我们简单介绍数据读取的部分函数，关于在<code>uint256</code>压缩数据结构内进行数据读取的具体方法，我们已在 <a href="https://blog.wssh.trade/posts/aave-contract-part1#%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">深入解析AAVE智能合约:存款</a> 介绍过类似的<code>uint256</code>压缩数据提取方法。简单来说，就是使用<code>&amp;</code>操作的特性实现数据提取。我们给出<code>balanceOf</code>的代码实现:</p> 
<pre><code class="prism language-solidity">function balanceOf(address owner) public view virtual override returns (uint256) {
    if (owner == address(0)) _revert(BalanceQueryForZeroAddress.selector);
    return _packedAddressData[owner] &amp; _BITMASK_ADDRESS_DATA_ENTRY;
}
</code></pre> 
<p>基于 <code>1 &amp; 1 = 1</code> 、 <code>0 &amp; 1 = 0</code>和<code>0 &amp; 0 = 0</code>，我们可以通过将待提取位数(此处为0至63位置为 1 即可)。此处的<code>_BITMASK_ADDRESS_DATA_ENTRY</code>与我们设想的类似:</p> 
<pre><code class="prism language-solidity">uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 &lt;&lt; 64) - 1;
</code></pre> 
<blockquote> 
 <p>根据我们的设想，此处应填写 <code>0xffffffffffffffff</code>(总计 16 个 <code>f</code>)，正好为 0-63 位均为 1 。但 <code>ERC721A</code>开发者团队使用了位移方法表示，事实上是一致的</p> 
</blockquote> 
<p>对于其他并不是从 0 开始的元素提取，我们需要使用位移以移除不必要数据，此处以提取 <code>numberMinted</code> 为例进行分析:</p> 
<pre><code class="prism language-solidity">function _numberMinted(address owner) internal view returns (uint256) {
    return (_packedAddressData[owner] &gt;&gt; _BITPOS_NUMBER_MINTED) &amp; _BITMASK_ADDRESS_DATA_ENTRY;
}
</code></pre> 
<p>首先将数据右移 64 位(即<code>_BITPOS_NUMBER_MINTED</code>)使<code>balance</code>占用的数据因溢出而移除，而后使用 <code>&amp;</code> 操作符提取对应的数据，此处也需要提取 64 位数据，所以仍使用了<code>_BITMASK_ADDRESS_DATA_ENTRY</code></p> 
<p>对于其他数据的提取，我们不再赘述。</p> 
<p>在数据写入函数方面，ERC721A 仅提供<code>_setAux</code>函数，该函数的实现代码如下:</p> 
<pre><code class="prism language-solidity">function _setAux(address owner, uint64 aux) internal virtual {
    uint256 packed = _packedAddressData[owner];
    uint256 auxCasted;
    // Cast `aux` with assembly to avoid redundant masking.
    assembly {
        auxCasted := aux
    }
    packed = (packed &amp; _BITMASK_AUX_COMPLEMENT) | (auxCasted &lt;&lt; _BITPOS_AUX);
    _packedAddressData[owner] = packed;
}
</code></pre> 
<p>首先我们将输入的<code>aux</code>变量转化为<code>uint256</code>类型，以方便后期处理。此后，我们将<code>packed</code>与<code>(1 &lt;&lt; 192) - 1</code>进行 <code>&amp;</code> 操作，此步骤可以将 <code>aux</code> 占用 <code>[192..255]</code> 重置为 0 ，然后使用 <code>|</code> 操作符向该区域内填入最新的<code>aux</code>。</p> 
<blockquote> 
 <p>总结来说，我们可以通过与指定区域置为 1 的 <code>mask</code> 进行 <code>&amp;</code> 操作提取指定区域内的数据。另一方面，我们可以通过 <code>|</code> 操作向置为 0 的区域写入数据。</p> 
</blockquote> 
<h3>
<a id="_235"></a>铸造</h3> 
<h4>
<a id="_237"></a>基本函数</h4> 
<p>铸造使用了<code>_mint</code>函数，其函数定义是:</p> 
<pre><code class="prism language-solidity">function _mint(address to, uint256 quantity) internal virtual
</code></pre> 
<p>该函数规定了以下参数:</p> 
<ul>
<li>
<code>to</code> 铸造NFT接受地址</li>
<li>
<code>quantity</code> 铸造的NFT数量</li>
</ul> 
<blockquote> 
 <p>由于<code>ERC721A</code>只能铸造固定数量的 NFT，所以无法指定铸造NFT的<code>tokenID</code></p> 
</blockquote> 
<p>其函数的运行逻辑简单如下:</p> 
<ol>
<li>运行 <code>_beforeTokenTransfers</code>，此函数应根据具体目的编写</li>
<li>设置 <code>_packedOwnerships</code>,以方便查询NFT的拥有者</li>
<li>设置<code>_packedAddressData</code>,方便查询某一用户的所有NFT</li>
<li>释放<code>Transfer</code>事件</li>
<li>运行 <code>_afterTokenTransfers</code>，此函数应根据具体目的编写</li>
</ol> 
<p>接下来，我们将结合代码进行分析。</p> 
<p>最先运行的 <code>_beforeTokenTransfers</code> 和最后运行的<br> <code>_afterTokenTransfers</code> 都是由用户自定义的函数，用于实现白名单等功能。函数具体定义如下:</p> 
<pre><code class="prism language-solidity">function _beforeTokenTransfers(
    address from,
    address to,
    uint256 startTokenId,
    uint256 quantity
) internal virtual {}

function _afterTokenTransfers(
    address from,
    address to,
    uint256 startTokenId,
    uint256 quantity
) internal virtual {}
</code></pre> 
<p>读者可根据自身需求，通过继承覆盖的方式定义这两个函数。</p> 
<p>接下来，我们设置一些核心数据，这些数据的设置是 <code>_mint</code> 函数的核心。值得注意的是，这些函数都定义在 <code>unchecked</code> 代码块中，因为 NFT 的各个参数设置不会产生溢出情况，通过 <code>unchecked</code> 可以避免编译过程中插入溢出检查代码以减少 gas 消耗。</p> 
<blockquote> 
 <p>简而言之，在某些已经确定不会出现数据溢出的场景中使用 <code>unchecked</code> 包裹代码可以减少 gas 消耗</p> 
</blockquote> 
<p>最开始，我们设置表示 NFT 所有者的 <code>_packOwnershipData</code> 数据结构，具体设置方法如下:</p> 
<pre><code class="prism language-solidity">_packedOwnerships[startTokenId] = _packOwnershipData(
    to,
    _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)
);
</code></pre> 
<p>为方便读者理解代码，在此处，我们给出 <code>_packedOwnerships</code> 的定义:</p> 
<pre><code class="prism language-solidity">// Bits Layout:
// - [0..159]   `addr`
// - [160..223] `startTimestamp`
// - [224]      `burned`
// - [225]      `nextInitialized`
// - [232..255] `extraData`
mapping(uint256 =&gt; uint256) private _packedOwnerships;
</code></pre> 
<p>我们先对 <code>_packOwnershipData</code> 函数的输入参数进行分析，需要解决 <code>_nextInitializedFlag</code> 和 <code>_nextExtraData</code> 的定义问题，</p> 
<p>前者定义如下:</p> 
<pre><code class="prism language-solidity">function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {
    // For branchless setting of the `nextInitialized` flag.
    assembly {
        // `(quantity == 1) &lt;&lt; _BITPOS_NEXT_INITIALIZED`.
        result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))
    }
}
</code></pre> 
<p>显然，此函数用于设置 <code>nextInitialized</code> 标识，如果铸造的数量为 1 ，我们将此标识置为 1 (即 True )。当然，我们也使用了位移操作使其处于合适的位置。</p> 
<blockquote> 
 <p><code>nextInitialized</code> 是初始化的标识，如果此标识为 <code>True</code> 则说明此 NFT 对应的地址已被初始化。如果此标识为 <code>False</code> (正如上文所见，单次铸造多于 1 个 NFT 就会使标识为 <code>False</code> )，则意味着这段连续的 NFT 中除第一个外其他 NFT 均为初始化。如下图:<br> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DKMsV1oA-1675684640934)(https://files.catbox.moe/20sjdu.svg)]</p> 
</blockquote> 
<p>后者定义如下:</p> 
<pre><code class="prism language-solidity">function _nextExtraData(
    address from,
    address to,
    uint256 prevOwnershipPacked
) private view returns (uint256) {
    uint24 extraData = uint24(prevOwnershipPacked &gt;&gt; _BITPOS_EXTRA_DATA);
    return uint256(_extraData(from, to, extraData)) &lt;&lt; _BITPOS_EXTRA_DATA;
}
</code></pre> 
<p>此函数用于写入额外的信息，开发者需要自行定义 <code>_extraData</code> 函数以实现相关数据的写入。</p> 
<p>此过程的核心函数为 <code>_packOwnershipData</code> ，其定义如下:</p> 
<pre><code class="prism language-solidity">function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {
    assembly {
        // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.
        owner := and(owner, _BITMASK_ADDRESS)
        // `owner | (block.timestamp &lt;&lt; _BITPOS_START_TIMESTAMP) | flags`.
        result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))
    }
}
</code></pre> 
<p>有了上述 <code>_nextInitializedFlag</code> 和 <code>_nextExtraData</code> 的补充和注释，相信读者可以理解 <code>_packOwnershipData</code> 的实现原理，简单来说，该函数使用 <code>or</code> 操作符拼接 <code>owner</code> 、 <code>timestamp</code> 和 <code>flags</code> 以实现最终的数据结构。显然，我们只需要构造以下部分作为<code>flags</code>输入，即可完成 <code>_packOwnershipData</code> 的构造:</p> 
<pre><code>// - [224]      `burned`
// - [225]      `nextInitialized`
// - [232..255] `extraData`
</code></pre> 
<blockquote> 
 <p>读者可以注意到 <code>owner</code> 、 <code>timestamp</code> 和 <code>flags</code> 均为 <code>uint256</code> 数据类型，所以直接使用 <code>or</code> 进行拼接是合适的</p> 
</blockquote> 
<p>接下来设置 <code>_packedAddressData</code> 数据结构。此数据结构定义如下:</p> 
<pre><code class="prism language-solidity">// Bits Layout:
// - [0..63]    `balance`
// - [64..127]  `numberMinted`
// - [128..191] `numberBurned`
// - [192..255] `aux`
mapping(address =&gt; uint256) private _packedAddressData;
</code></pre> 
<p><code>mint</code> 过程仅涉及 <code>balance</code> 和 <code>numberMinted</code> 两部分数据。所以设置较为简单，代码如下:</p> 
<pre><code class="prism language-solidity">_packedAddressData[to] += quantity * ((1 &lt;&lt; _BITPOS_NUMBER_MINTED) | 1);
</code></pre> 
<p>我们使用 <code>((1 &lt;&lt; _BITPOS_NUMBER_MINTED) | 1)</code> 构造(此处 <code>_BITPOS_NUMBER_MINTED = 64</code> )出如下二进制数字 (以 16 进制表示):</p> 
<pre><code>0b10000001
</code></pre> 
<blockquote> 
 <p>使用 Python 运行 <code>bin((64 &lt;&lt; 1) | 1)</code> 可以获得此结果</p> 
</blockquote> 
<p>所以我们可以直接将数字与 <code>balance</code> 和 <code>numberMinted</code> 对齐相加。</p> 
<p>在释放 <code>Transfer</code> 事件前，我们需要对 NFT 接受方的地址进行简单校验，即保证 NFT 接受方的地址不为 0 地址，校验代码如下:</p> 
<pre><code class="prism language-solidity">uint256 toMasked = uint256(uint160(to)) &amp; _BITMASK_ADDRESS;

if (toMasked == 0) _revert(MintToZeroAddress.selector);
</code></pre> 
<p>此处进行了一个有趣的操作，将地址转化为 <code>uint256</code> 后与 <code>0</code> 进行比较。此处涉及 <code>address</code> 与 <code>uint256</code> 类型的转化。众所周知， <code>address</code> 类型事实上就是 <code>uint160</code> ，两者可以直接转化。</p> 
<blockquote> 
 <p>如果读者对 <code>address</code> 类型不熟悉，可参考 <a href="https://docs.soliditylang.org/en/latest/types.html#address">文档</a></p> 
</blockquote> 
<p>在直接转化后，为了避免直接转化导致的高位不为 0 的特殊情况出现，我们使用 <code>_BITMASK_ADDRESS</code> 进行清理。此常量定义如下:</p> 
<pre><code class="prism language-solidity">uint256 private constant _BITMASK_ADDRESS = (1 &lt;&lt; 160) - 1;
</code></pre> 
<p>通过使用此常量进行 <code>&amp;</code> ，我们可以保证 <code>address</code> 与 <code>uint256</code> 的安全转换。</p> 
<blockquote> 
 <p>此处我们没有深入讨论为什么 <code>uint160</code> 到 <code>uint256</code> 的直接转化可能导致高位不为 0 的情况发生，读者可编写一简单合约编译后使用字节码研究此问题</p> 
</blockquote> 
<p>释放 <code>Transfer</code> 事件，此处我们可以一窥 <code>emit</code> 背后的原理:</p> 
<pre><code class="prism language-solidity">uint256 end = startTokenId + quantity;
uint256 tokenId = startTokenId;

do {
    assembly {
        // Emit the `Transfer` event.
        log4(
            0, // Start of data (0, since no data).
            0, // End of data (0, since no data).
            _TRANSFER_EVENT_SIGNATURE, // Signature.
            0, // `address(0)`.
            toMasked, // `to`.
            tokenId // `tokenId`.
        )
    }
    // The `!=` check ensures that large values of `quantity`
    // that overflows uint256 will make the loop run out of gas.
} while (++tokenId != end);
</code></pre> 
<p>常规实现中， <code>Transfer</code> 定义如下:</p> 
<pre><code class="prism language-solidity">event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
</code></pre> 
<blockquote> 
 <p>来自 <a href="https://eips.ethereum.org/EIPS/eip-721#specification">EIP-721 标准</a> 原文</p> 
</blockquote> 
<p>我们可以看到此事件抛出了 3 个 <code>topic</code>，但事实上 <code>Transfer</code> 作为事件名称也需要占用一个 <code>topic</code> ，所以此处使用了 <code>log4</code> 操作码。</p> 
<p>此操作码需要的变量如下:</p> 
<ol>
<li>
<code>offset</code> 抛出内容位于内存的起始位置</li>
<li>
<code>size</code> 抛出内容的长度(与 <code>offset</code> 参数共同使用)</li>
<li>
<code>topic1</code> 抛出的的变量</li>
<li><code>topic2</code></li>
<li><code>topic3</code></li>
<li><code>topic4</code></li>
</ol> 
<blockquote> 
 <p>有读者好奇为什么存在 <code>offset</code> 和 <code>size</code> 参数？ 如果读者仔细阅读过 Events 部分的 <a href="https://docs.soliditylang.org/en/latest/abi-spec.html#events">Solidity 文档</a> 就会理解这一问题。 文档中明确指出 <code>events</code> 可以提供合约地址、 最多 4 个 <code>topic</code> 和一些任意长度二进制数据。此处的 <code>offset</code> 和 <code>size</code> 参数就是指明任意长度的二进制数据的</p> 
</blockquote> 
<blockquote> 
 <p>在编写 <code>solidity</code> 代码时，假设存在 <code>event foo(uint256 _a, uint256 indexed _b)</code> 定义，其中 <code>_a</code> 会以二进制数据的形式抛出(即通过 <code>offset</code> 和 <code>size</code> 定义抛出)，而 <code>_b</code> 则以 <code>topic</code> 的形式抛出。</p> 
</blockquote> 
<p>至此，读者应该可以很好的理解 <code>log4</code> 在代码中的具体功能。此处也使用了 <code>do while</code> 循环以逐一抛出每个 <code>tokenId</code> 的 <code>Transfer</code> 事件。</p> 
<h4>
<a id="_462"></a>补充函数</h4> 
<p>在 <code>ERC721A</code> 的官方实现中，开发者提供了一些其他的 <code>mint</code> 函数实现，这些实现的主体逻辑与 <code>_mint</code> 类似，但提供了一些特别的功能或者符合一些特定的 ERC 标准。</p> 
<p>我们首先分析 <code>_mintERC2309</code> 函数，此函数根据 <a href="https://eips.ethereum.org/EIPS/eip-2309">ERC 2309</a> 标准编写。在介绍函数具体实现前，我们简单介绍一下 <code>ERC 2309</code> 的具体内容。</p> 
<p><code>ERC 2309</code> 主要解决在大规模铸造和代币转账过程中释放过多 <code>event</code> 的问题。如在标准 <code>_mint</code> 函数实现中，我们在最后使用了 <code>while</code> 循环以逐一释放事件。这显然是低效的，且无法用于大规模代币铸造。</p> 
<p>为解决这一问题， <code>ERC 2309</code> 的开发者设计了一个新的事件:</p> 
<pre><code class="prism language-solidity">event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);
</code></pre> 
<p>基于此事件，我们可以一次性释放所有代币转移的事件，大大降低了 gas 消耗。</p> 
<p>对于 <code>_mintERC2309</code> 具体实现，与 <code>_mint</code> 基本一致，除了增加了以下代码:</p> 
<ol>
<li>ERC2309 最大转移量检查<br> <code>if (quantity &gt; _MAX_MINT_ERC2309_QUANTITY_LIMIT) _revert(MintERC2309QuantityExceedsLimit.selector);</code><br> 用于判断单次转移量是否超过 <code>5000</code>
</li>
<li>
<code>ConsecutiveTransfer</code> 事件抛出<br> <code>emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);</code><br> 由于使用了 <code>solidity</code> 语法编写，所以此处也减少了大量安全性代码编写(如上文的 <code>address</code> 到 <code>uint256</code> 转化等)。</li>
</ol> 
<p>另一个实现 <code>mint</code> 功能的函数是 <code>_safeMint</code> 函数，此函数会判断 NFT 接收地址 <code>to</code> 的属性，以避免 NFT 接受方不具有接受 NFT 的能力。</p> 
<p>此部分逻辑代码如下:</p> 
<pre><code class="prism language-solidity">unchecked {
    if (to.code.length != 0) {
        uint256 end = _currentIndex;
        uint256 index = end - quantity;
        do {
            if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {
                _revert(TransferToNonERC721ReceiverImplementer.selector);
            }
        } while (index &lt; end);
        // Reentrancy protection.
        if (_currentIndex != end) _revert(bytes4(0));
    }
}
</code></pre> 
<p>当接受方为一合约地址时，我们需要使用 <code>_checkContractOnERC721Received</code> 函数判断接受方是否可以接受 NFT，此函数定义如下:</p> 
<pre><code class="prism language-solidity">function _checkContractOnERC721Received(
    address from,
    address to,
    uint256 tokenId,
    bytes memory _data
) private returns (bool) {
    try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (
        bytes4 retval
    ) {
        return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;
    } catch (bytes memory reason) {
        if (reason.length == 0) {
            _revert(TransferToNonERC721ReceiverImplementer.selector);
        }
        assembly {
            revert(add(32, reason), mload(reason))
        }
    }
}
</code></pre> 
<p>我们在 <a href="https://blog.wssh.trade/posts/deep-in-safe-part-3/#receiver">深入解析Safe多签钱包智能合约:Fallback合约</a> 内已经对 <code>onERC721Received</code> 的相关内容进行了分析，读者可自行阅读理解。此处，我们主要对 <code>try/catch</code> 这一少见的 <code>solidity</code> 关键词进行分析。</p> 
<p><code>try</code> 关键词后必须为一个外部函数调用，在此处为<br> <code>ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data)</code>，即调用了外部 <code>ERC721A__IERC721Receiver</code> 的 <code>onERC721Received</code> 函数。 <code>return</code> 会将外部调用的返回值封装为特定的函数名，此处为 <code>retval</code> 。</p> 
<p>如果外部调用和返回值封装没有出现错误，就会运行第一个语句块的语句，此处为<br> <code>return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;</code></p> 
<p>该语句块较为简单，不再具体分析。</p> 
<p><code>catch</code> 用来捕获错误， <code>solidity</code> 提供了以下 <code>catch</code> 语句:</p> 
<ul>
<li>
<code>catch Error(string memory reason) { ... }</code> 用于捕获 <code>revert("reasonString")</code> 或 <code>require(false, "reasonString")</code> 等语句造成的错误</li>
<li>
<code>catch Panic(uint errorCode) { ... }</code> 用于捕获 <code>panic</code> 类型错误，如 <code>assert</code> 、除以 0 等错误</li>
<li>
<code>catch (bytes memory lowLevelData) { ... }</code> 用于直接捕获底层错误信息，涵盖所有类型错误</li>
</ul> 
<blockquote> 
 <p>在真实场景下，显然我们无法保证调用的合约使用 <code>solidity</code> 编写，所以使用最后一张 <code>catch</code> 方法是有必要的。</p> 
</blockquote> 
<p>显然，此处使用的是最后一种 <code>catch</code> 语句。在捕获到底层错误后，我们首先使用 <code>if</code> 语句判断此错误信息是否长度为 <code>0</code> ，如果长度为 0 ，则意味着我们没有具体的错误信息，采取直接抛出 <code>TransferToNonERC721ReceiverImplementer.selector</code> 的策略。</p> 
<p>此处使用了 <code>_revert</code> 函数，此函数是对 <code>revert</code> 包装，定义如下:</p> 
<pre><code class="prism language-solidity">function _revert(bytes4 errorSelector) internal pure {
    assembly {
        mstore(0x00, errorSelector)
        revert(0x00, 0x04)
    }
}
</code></pre> 
<p>此函数是对抛出 <code>errorSelector</code> 错误信息的 <code>revert</code> 的包装。读者应该可以理解此函数内部的 <code>yul</code> 代码，较为简单。</p> 
<p>如果错误信息 <code>reason</code> 长度不为 0 ，我们则考虑抛出此信息。使用 <code>revert</code> 抛出错误信息是一个好的选择。</p> 
<blockquote> 
 <p>可能有读者对 <code>revert</code> 操作码不熟悉，此操作码会抛出指定的错误信息、回滚当前状态并返还未使用的 <code>gas</code> 费用。使用 <code>revert</code> 操作码可以构建出稳赚不陪的偷跑(<code>front-running</code>)机器人，可参考 <a href="https://paulbrower.codes/posts/bear-traps-in-the-dark-forest/">Setting Bear Traps in the Dark Forest</a> 。</p> 
</blockquote> 
<p><code>revert(offset, size)</code> 需要以下参数以抛出错误信息:</p> 
<ol>
<li>
<code>offset</code> 错误信息在内存中的起始位置</li>
<li>
<code>size</code> 错误信息的长度</li>
</ol> 
<p>由于 <code>reason</code> 属于 <code>bytes</code> 类型，此类型属于 <code>array</code> ，其在内存中的存在方式如下图:</p> 
<pre><code>+--------+--------+
| length |  ....  |
+--------+--------+
|         _______/
|             length     
reason
</code></pre> 
<p><code>reason</code> 在内存中大致如上图。其在内存中的起始位置保存在 <code>reason</code> 代表的数字中，然后 <code>32 bytes</code> 是变量占据的内存长度，而后 <code>length</code> 长度的内容为其真正存储的内容。</p> 
<blockquote> 
 <p>如果读者阅读过我之前的一系列关于智能合约的文章，相信可以理解这一内容。简单来说，在 <code>solidity</code> 内所有变量都是指向内存特定位置的指针。但由于数据类型的不同，其在内存中的结构也不相同，可以参考 <a href="https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html">solidity 文档</a></p> 
</blockquote> 
<p>有了上述内容，我们可以理解 <code>revert(add(32, reason), mload(reason))</code> 的具体含义。</p> 
<p>我们使用 <code>add(32, reason)</code> 跳过 <code>reason</code> 的长度部分以其内容的起始部分作为 <code>offset</code> ，使用 <code>mload(reason)</code> 读取 <code>reason</code> 的前 <code>32 bytes</code> ，这正是 <code>reason</code> 的长度信息。使用上述操作，可以保证 <code>revert</code> 抛出的错误信息不包含长度内容。</p> 
<p>至此，我们完成了 <code>_safeMint</code> 的核心代码分析。</p> 
<h3>
<a id="_594"></a>授权</h3> 
<p>授权，或称 <code>approve</code> 是 NFT 的核心逻辑之一，也是 NFT 可组合性的基础之一。</p> 
<h4>
<a id="_approve_598"></a><code>_approve</code>
</h4> 
<p>实现 <code>approve</code> 的核心函数为 <code>_approve</code> 函数，其代码如下:</p> 
<pre><code class="prism language-solidity">function _approve(
    address to,
    uint256 tokenId,
    bool approvalCheck
) internal virtual {
    address owner = ownerOf(tokenId);

    if (approvalCheck &amp;&amp; _msgSenderERC721A() != owner)
        if (!isApprovedForAll(owner, _msgSenderERC721A())) {
            _revert(ApprovalCallerNotOwnerNorApproved.selector);
        }

    _tokenApprovals[tokenId].value = to;
    emit Approval(owner, to, tokenId);
}
</code></pre> 
<p>其逻辑大致如下:</p> 
<ol>
<li>查询待授权 NFT 的所有者</li>
<li>进行资格审查，判断函数调用者是否有权进行授权</li>
<li>设置 <code>_tokenApprovals</code> 映射，确定授权</li>
</ol> 
<p>在资格审查方面，要求函数调用者满足以下条件:</p> 
<ol>
<li>
<code>approvalCheck</code> 为<code>false</code> 且函数调用者是 NFT 拥有者</li>
<li>
<code>approvalCheck</code> 为 <code>true</code> 且函数调用者被授权控制 NFT 拥有者的 <strong>所有</strong> NFT</li>
</ol> 
<p>首先分析 <code>ownerOf</code> 函数，其定义如下:</p> 
<pre><code class="prism language-solidity">function ownerOf(uint256 tokenId) public view virtual override returns (address) {
    return address(uint160(_packedOwnershipOf(tokenId)));
}
</code></pre> 
<p>显然，我们需要分析 <code>_packedOwnershipOf</code> 的实现:</p> 
<pre><code class="prism language-solidity">function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {
    if (_startTokenId() &lt;= tokenId) {
        packed = _packedOwnerships[tokenId];
        if (packed &amp; _BITMASK_BURNED == 0) {
            if (packed == 0) {
                if (tokenId &gt;= _currentIndex) _revert(OwnerQueryForNonexistentToken.selector);
                for (;;) {
                    unchecked {
                        packed = _packedOwnerships[--tokenId];
                    }
                    if (packed == 0) continue;
                    return packed;
                }
            }
            return packed;
        }
    }
    _revert(OwnerQueryForNonexistentToken.selector);
}
</code></pre> 
<p>该函数的基本逻辑如下:</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-I4FT4MJs-1675684643092)(null)]</p> 
<p>通过上述流程图，读者应该可以理解查询 <code>packed</code> 的流程，其中的核心步骤是 <code>for</code> 循环代码块内的回溯。正如在 <a href="#%E9%93%B8%E9%80%A0">mint</a> 所说明的，<code>_packedOwnerships</code> 内仅存储 <code>startTokenId</code> ，所以此处使用 <code>--tokenId</code> 进行回溯查询。</p> 
<blockquote> 
 <p>此处使用了映射的性质，如果映射中的键不存在，那么返回的值为空。此处使用的 <code>_packedOwnerships[tokenId]</code> 会在 <code>tokenId</code> 不存在时返回空值。</p> 
</blockquote> 
<p>在理解 <code>_packedOwnershipOf</code> 和 <code>ownerOf</code> 的基础上，理解 <code>_approve</code> 实现是容易的。</p> 
<h4>
<a id="_673"></a>其他函数</h4> 
<p>本部分主要介绍关于 <code>approval</code> 授权相关的其他函数，这些函数在是实现上都较为简单。</p> 
<pre><code class="prism language-solidity">function setApprovalForAll(address operator, bool approved) public virtual override {
    _operatorApprovals[_msgSenderERC721A()][operator] = approved;
    emit ApprovalForAll(_msgSenderERC721A(), operator, approved);
}
</code></pre> 
<p>此处使用了 <code>_operatorApprovals</code> 映射以实现将拥有者所有 NFT 同一授权为其他地址，映射定义如下:</p> 
<pre><code class="prism language-solidity">mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;
</code></pre> 
<p><code>getApproved</code> 函数用于确定某个 NFT 被授权地址，实现如下:</p> 
<pre><code class="prism language-solidity">function getApproved(uint256 tokenId) public view virtual override returns (address) {
    if (!_exists(tokenId)) _revert(ApprovalQueryForNonexistentToken.selector);

    return _tokenApprovals[tokenId].value;
}
</code></pre> 
<p>在返回被授权者前，该函数使用了 <code>_exists</code> 确定对应的 NFT 存在，<code>_exists</code> 实现如下:</p> 
<pre><code class="prism language-solidity">function _exists(uint256 tokenId) internal view virtual returns (bool) {
    return
        _startTokenId() &lt;= tokenId &amp;&amp;
        tokenId &lt; _currentIndex &amp;&amp; // If within bounds,
        _packedOwnerships[tokenId] &amp; _BITMASK_BURNED == 0; // and not burned.
}
</code></pre> 
<p>配合注释，读者应该可以理解此函数的具体逻辑</p> 
<h3>
<a id="_713"></a>转账</h3> 
<p>转账方面的基础函数为 <code>transferFrom</code> 函数，其他所有转账函数都建立在此函数的基础上，该函数的逻辑设计如下:</p> 
<ol>
<li>使用 <code>_packedOwnershipOf</code> 函数获得 NFT 持有者地址</li>
<li>校验函数请求者是否是 NFT 拥有者或具有授权</li>
<li>删除待转移 NFT 的授权</li>
<li>修改 <code>_packedAddressData</code> 映射增减 <code>balance</code>
</li>
<li>修改 <code>_packedOwnerships</code> 映射</li>
<li>释放转移事件</li>
</ol> 
<p>函数定义如下:</p> 
<pre><code class="prism language-solidity">function transferFrom(
    address from,
    address to,
    uint256 tokenId
) public payable virtual override
</code></pre> 
<p>该函数的参数为:</p> 
<ol>
<li>
<code>from</code> 待转移 NFT 的拥有者地址</li>
<li>
<code>to</code> 待转移 NFT 的接收者地址</li>
<li>
<code>tokenId</code> 待转移 NFT 的 <code>tokenId</code>
</li>
</ol> 
<p>根据上述流程，我们将逐个解析其中使用的函数。</p> 
<pre><code class="prism language-solidity">uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);

from = address(uint160(uint256(uint160(from)) &amp; _BITMASK_ADDRESS));

if (address(uint160(prevOwnershipPacked)) != from) _revert(TransferFromIncorrectOwner.selector);
</code></pre> 
<p>通过 <code>_packedOwnershipOf</code> 函数获得 NFT 拥有者地址，使用 <code>address(uint160(uint256(uint160(from)) &amp; _BITMASK_ADDRESS))</code> 进行数据类型转化。如果我们发现调用参数中的 <code>from</code> 与 NFT 拥有者不同，则直接抛出错误。</p> 
<p>接下来，我们使用以下代码校验 NFT 转移的相关权限问题:</p> 
<pre><code class="prism language-solidity">(uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);

if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))
    if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);
</code></pre> 
<p>满足以下条件则继续运行:</p> 
<p>函数调用者为 NFT 拥有者或被授权者 或 函数调用者存在 <code>isApprovedForAll</code> 权限。</p> 
<p>如果上述条件全不满足，则抛出异常。</p> 
<p>该部分中最复杂的函数为<code>_getApprovedSlotAndAddress</code>:</p> 
<pre><code class="prism language-solidity">function _getApprovedSlotAndAddress(uint256 tokenId)
    private
    view
    returns (uint256 approvedAddressSlot, address approvedAddress)
{
    TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];
    assembly {
        approvedAddressSlot := tokenApproval.slot
        approvedAddress := sload(approvedAddressSlot)
    }
}
</code></pre> 
<p>该函数会返回两个底层数据，即授权地址在 <code>storage</code> 中的位置<code>approvedAddressSlot</code>和授权地址的值 <code>approvedAddress</code>。</p> 
<blockquote> 
 <p>理解此代码需要对 EVM 的存储结构有一定了解，推荐阅读 <a href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage"> Understanding Ethereum Smart Contract Storage </a></p> 
</blockquote> 
<p>当函数调用者满足条件后，我们进入真正的 NFT 转移程序。首先清除待转移 NFT 的原有授权，代码如下:</p> 
<pre><code class="prism language-solidity">assembly {
    if approvedAddress {
        sstore(approvedAddressSlot, 0)
    }
}
</code></pre> 
<p>直接将 <code>_tokenApprovals</code> 中 NFT 对应的值清空。</p> 
<p>接下来，我们进入了最复杂的 NFT 转移阶段，该阶段的逻辑大致如下:</p> 
<ol>
<li> <p>修正转移双方的 <code>balance</code> 参数</p> <pre><code class="prism language-solidity">--_packedAddressData[from];
++_packedAddressData[to]; 
</code></pre> </li>
<li> <p>更新 <code>tokenId</code> 对应的 <code>_packedOwnerships</code> 数据:</p> <pre><code class="prism language-solidity">_packedOwnerships[tokenId] = _packOwnershipData(
    to,
    _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)
);
</code></pre> <p>由于转移过程必须进行初始化，所以此处将转移的 NFT 的 <code>nextInitialized</code> 设置为 <code>True</code></p> </li>
<li> <p>考虑下一个 NFT 是否被初始化，<br> 如转移下图中 <code>tokenId = 3</code> 的 NFT:<br> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wKsxnwNP-1675684640935)(https://files.catbox.moe/20sjdu.svg)]<br> 该 NFT 转移后，由于破坏了拥有者 <code>0x2</code> 的连续性，所以我们需要重写 <code>tokenId = 4</code> 的对应数据，代码如下:</p> <pre><code class="prism language-solidity">if (prevOwnershipPacked &amp; _BITMASK_NEXT_INITIALIZED == 0) {
uint256 nextTokenId = tokenId + 1;
if (_packedOwnerships[nextTokenId] == 0) {
    if (nextTokenId != _currentIndex) {
        _packedOwnerships[nextTokenId] = prevOwnershipPacked;
    }
}
</code></pre> <p>此处使用了 <code>_packedOwnerships[nextTokenId] == 0</code> 排除了 <code>tokenId = 4</code> 转移的特殊情况。该 NFT 位于连续 NFT 的末尾，转移此 NFT 不会破环连续性</p> </li>
</ol> 
<p>至此，我们完成了 NFT 的转移的核心流程。接下来就是已经介绍过的 <code>Transfer</code> 释放流程:</p> 
<pre><code class="prism language-solidity">uint256 toMasked = uint256(uint160(to)) &amp; _BITMASK_ADDRESS;
assembly {
    // Emit the `Transfer` event.
    log4(
        0, // Start of data (0, since no data).
        0, // End of data (0, since no data).
        _TRANSFER_EVENT_SIGNATURE, // Signature.
        from, // `from`.
        toMasked, // `to`.
        tokenId // `tokenId`.
    )
}
if (toMasked == 0) _revert(TransferToZeroAddress.selector);
</code></pre> 
<p><code>safeTransferFrom</code> 作为 <code>transferFrom</code> 的安全版本，该函数只是增加了 <code>_checkContractOnERC721Received</code> 检测，此检测函数已在上文进行了介绍，此处不再赘述。</p> 
<h3>
<a id="_852"></a>销毁</h3> 
<p><code>burn</code> 销毁的核心函数为 <code>_burn</code> 函数，由于销毁事实上相当于将 NFT 转移给 0 地址，所以其大量逻辑与 <code>transfer</code> 类似。</p> 
<p><code>_burn</code> 函数定义如下:</p> 
<pre><code class="prism language-solidity">function _burn(uint256 tokenId, bool approvalCheck) internal virtual
</code></pre> 
<p>参数含义如下:</p> 
<ol>
<li>
<code>tokenId</code> 待销毁 NFT 的 <code>tokenId</code>
</li>
<li>
<code>approvalCheck</code> 是否检测函数调用者的权限</li>
</ol> 
<p>大致流程如下:</p> 
<ol>
<li>获取待销毁 NFT 拥有者的信息</li>
<li>如果设置 <code>approvalCheck</code> 为 <code>true</code> 则检测函数调用者的相关权限</li>
<li>清空待销毁 NFT 的授权 <code>approve</code> 数据</li>
<li>减少拥有者的 <code>balance</code>
</li>
<li>在 <code>_packedOwnerships</code> 中写入销毁信息</li>
<li>恢复代币连续性</li>
<li>释放事件</li>
</ol> 
<p>接下来，我们详细分析具体的代码实现:</p> 
<pre><code class="prism language-solidity">uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);

address from = address(uint160(prevOwnershipPacked));

(uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);
</code></pre> 
<p>此处代码与 <code>transferFrom</code> 函数的开始部分基本一致，但在 <code>from</code> 处理方面进行了简化。</p> 
<p>接下来，我们检查调用者的相关权限并清空授权，代码如下:</p> 
<pre><code class="prism language-solidity">if (approvalCheck) {
    if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))
        if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);
}

assembly {
    if approvedAddress {
        // This is equivalent to `delete _tokenApprovals[tokenId]`.
        sstore(approvedAddressSlot, 0)
    }
}
</code></pre> 
<p>此部分代码与 <code>transferFrom</code> 函数完全一致，不再详细介绍。</p> 
<pre><code class="prism language-solidity">_packedAddressData[from] += (1 &lt;&lt; _BITPOS_NUMBER_BURNED) - 1;
_packedOwnerships[tokenId] = _packOwnershipData(
    from,
    (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)
);
</code></pre> 
<p>此处使用 <code>_packedAddressData[from] += (1 &lt;&lt; _BITPOS_NUMBER_BURNED) - 1;</code> 代码将 <code>balance -= 1</code> 和 <code>numberBurned += 1</code> 合并一起执行。</p> 
<p>其中 <code>_BITPOS_NUMBER_BURNED</code> 的值为 128，为方便读者理解，我们再次给出 <code>_packedAddressData</code> 的格式:</p> 
<pre><code>// Bits Layout:
// - [0..63]    `balance`
// - [64..127]  `numberMinted`
// - [128..191] `numberBurned`
// - [192..255] `aux`
mapping(address =&gt; uint256) private _packedAddressData;
</code></pre> 
<p>为方便理解，我们将原有代码进行重写:</p> 
<pre><code class="prism language-solidity">_packedAddressData[from] = _packedAddressData[from] + (1 &lt;&lt; 128) - 1
</code></pre> 
<p>如此来看，我们首先使用加法完成了 <code>numberBurned</code> 的更新，然后使用减法完成了 <code>balance</code> 的更新。</p> 
<p>对于 <code>_packOwnershipData</code> 函数，最重要的是分析以下部分:</p> 
<pre><code class="prism language-solidity">(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)
</code></pre> 
<p>我们将 <code>burned</code> 和 <code>_BITMASK_NEXT_INITIALIZED</code> 置为 <code>True</code> 并写入 <code>extraData</code> 部分。</p> 
<p>最后我们还是讨论 <strong>连续性</strong> 问题，假如当前的代币拥有如下图:</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Fvkc8I16-1675684640935)(https://files.catbox.moe/20sjdu.svg)]</p> 
<p>我们将 <code>tokenId = 3</code> 的代币销毁，那么我们需要修正 <code>tokenId = 4</code> 的 NFT 以避免 NFT 丢失。这部分代码与 <code>transferFrom</code> 是一致的，实现如下:</p> 
<pre><code class="prism language-solidity">if (prevOwnershipPacked &amp; _BITMASK_NEXT_INITIALIZED == 0) {
    uint256 nextTokenId = tokenId + 1;
    if (_packedOwnerships[nextTokenId] == 0) {
        if (nextTokenId != _currentIndex) {
            _packedOwnerships[nextTokenId] = prevOwnershipPacked;
        }
    }
}
</code></pre> 
<p>简单来说，我们只需要将 <code>tokenId = 2</code> 的数据放入 <code>tokenId = 4</code> 的 NFT 中即可。</p> 
<p>对于释放事件，使用了 <code>emit Transfer(from, address(0), tokenId);</code> 语句，较为简单。</p> 
<blockquote> 
 <p>有读者可能发现为什么在 <code>ERC721A</code> 内的编码风格并不统一，有使用底层 <code>log4</code> 释放事件的，有使用 <code>emit</code> 释放事件的。这可能是我没有使用 <code>Realse</code> 版本的代码而是直接 <code>clone</code> 了开发中的代码。</p> 
</blockquote> 
<h2>
<a id="_966"></a>总结</h2> 
<p>在本文中，我们分析了 <code>ERC721A</code> 合约的主体逻辑，但仍存在部分代码没有分析。这些代码实现都较为简单，故不再本文继续介绍。</p> 
<p>总体而言，<code>ERC721A</code>通过对连续 NFT 的合并处理大幅度降低了 NFT 批量铸造的 gas 消耗。</p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>