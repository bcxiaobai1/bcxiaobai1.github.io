<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>《机器学习实战：基于Scikit-Learn、Keras和TensorFlow第2版》-学习笔记（2） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《机器学习实战：基于Scikit-Learn、Keras和TensorFlow第2版》-学习笔记（2）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <h1>
<a id="__0"></a>第二章 端到端的机器学习项目</h1> 
<blockquote> 
 <p>· Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow, 2nd Edition, by Aurélien Géron (O’Reilly). Copyright 2019 Aurélien Géron, 978-1-492-03264-9.<br> · 环境：Anaconda（Python 3.8） + Pycharm<br> · 学习时间：2022.03.29~2022.03.31<br> · 预计阅读时间：1小时</p> 
</blockquote> 
<p>本章将介绍一个端到端的项目案例。假设你是一个房地产公司最近新雇用的数据科学家，以下是你将会经历的主要步骤：</p> 
<p>1.观察大局。</p> 
<p>2.获得数据。</p> 
<p>3.从数据探索和可视化中获得洞见。</p> 
<p>4.机器学习算法的数据准备。</p> 
<p>5.选择并训练模型。</p> 
<p>6.微调模型。</p> 
<p>7.展示解决方案。</p> 
<p>8.启动、监控和维护系统。</p> 
<p>项目案例纯属虚构，目的仅仅是为了说明机器学习项目的主要步骤，而不是为了了解房地产业务。</p> 
<p></p>
<div class="toc">
 <h3>文章目录</h3>
 <ul>
<li><a href="#__0">第二章 端到端的机器学习项目</a></li>
<li>
<ul>
<li><a href="#21__28">2.1 使用真实数据</a></li>
<li><a href="#22__38">2.2 机器学习项目清单</a></li>
<li><a href="#23__60">2.3 观察大局</a></li>
<li>
<ul>
<li><a href="#231__62">2.3.1 数据流水线</a></li>
<li><a href="#232__76">2.3.2 框架问题</a></li>
<li><a href="#233__86">2.3.3 选择性能指标</a></li>
<li><a href="#234__92">2.3.4 获取数据及数据观察</a></li>
<li><a href="#235__141">2.3.5 创建测试集</a></li>
</ul>
   </li>
<li><a href="#24__231">2.4 从数据探索和可视化中获得洞见</a></li>
<li>
<ul>
<li><a href="#241__245">2.4.1 将地理数据可视化</a></li>
<li><a href="#242__270">2.4.2 寻找相关性</a></li>
<li><a href="#243__301">2.4.3 试验不同属性的组合</a></li>
</ul>
   </li>
<li><a href="#25__330">2.5 机器学习算法的数据准备</a></li>
<li>
<ul>
<li><a href="#251__355">2.5.1 数据清理</a></li>
<li><a href="#252__403">2.5.2 处理文本和分类属性</a></li>
<li><a href="#253__472">2.5.3 自定义转换器</a></li>
<li><a href="#254__518">2.5.4 特征缩放</a></li>
<li><a href="#255__572">2.5.5 转换流水线</a></li>
</ul>
   </li>
<li><a href="#26__627">2.6 选择和训练模型</a></li>
<li>
<ul>
<li><a href="#261__629">2.6.1 训练和评估训练集</a></li>
<li><a href="#262__699">2.6.2 使用交叉验证评估</a></li>
<li><a href="#263__784">2.6.3 保存模型</a></li>
</ul>
   </li>
<li><a href="#27__802">2.7 微调模型</a></li>
<li>
<ul>
<li><a href="#271__808">2.7.1 网格搜索</a></li>
<li><a href="#272__876">2.7.2 随机搜索</a></li>
<li><a href="#273__890">2.7.3 集成方法</a></li>
<li><a href="#274__898">2.7.4 分析最佳模型及其误差</a></li>
<li><a href="#275__915">2.7.5 通过测试集评估系统</a></li>
</ul>
   </li>
<li><a href="#28__950">2.8 启动、监控和维护你的系统</a></li>
<li><a href="#29__966">2.9 练习题</a></li>
<li><a href="#_984">代码精简汇总（结合练习）</a></li>
</ul>
 </li>
</ul>
</div>
<p></p> 
<h2>
<a id="21__28"></a>2.1 使用真实数据</h2> 
<p>本章我们从StatLib库中选择了加州住房价格的数据集。该数据集基于1990年加州人口普查的数据。</p> 
<p>出于教学目的，我们还特意添加了一个分类属性，并且移除了一些特征。</p> 
<blockquote> 
 <p>原 始 数 据 集 由 R.Kelley Pace 和 Ronald Barry 提 供 ， “Sparse Spatial Autoregressions”，Statistics&amp;Probability Letters 33，no.3（1997）：291–297。</p> 
</blockquote> 
<h2>
<a id="22__38"></a>2.2 机器学习项目清单</h2> 
<p>该清单可以指导你完成机器学习项目。主要有8个步骤：</p> 
<p>1.框出问题并看整体。</p> 
<p>2.获取数据。</p> 
<p>3.研究数据以获得深刻见解。</p> 
<p>4.准备数据以便更好地将潜在的数据模式提供给机器学习算法。</p> 
<p>5.探索许多不同的模型，并列出最佳模型。</p> 
<p>6.微调你的模型，并将它们组合成一个很好地解决方案。</p> 
<p>7.演示你的解决方案。</p> 
<p>8.启动、监视和维护你的系统。</p> 
<h2>
<a id="23__60"></a>2.3 观察大局</h2> 
<h3>
<a id="231__62"></a>2.3.1 数据流水线</h3> 
<p>一个序列的数据处理组件称为一个<strong>数据流水线</strong>。</p> 
<p>流水线在机器学习系统中非常普遍，因为需要大量的数据操作和数据转化才能应用。组件通常是异步运行的。每个组件拉取大量的数据，然后进行处理，</p> 
<p>再将结果传输给另一个数据仓库。一段时间之后，流水线中的下一个组件会拉取前面的数据，并给出自己的输出，以此类推。每个组件都很独立：</p> 
<p>组件和组件之间的连接只有数据仓库。这使得整个系统非常简单易懂（在数据流图表的帮助下），不同团队可以专注于不同的组件。</p> 
<p>如果某个组件发生故障，它的下游组件还能使用前面的最后一个输出继续正常运行（至少一段时间），所以使得整体架构鲁棒性较强。</p> 
<h3>
<a id="232__76"></a>2.3.2 框架问题</h3> 
<p>你现在可以开始设计系统了。首先，你需要回答框架问题：是有监督学习、无监督学习还是强化学习？是分类任务、回归任务还是其他任务？</p> 
<p>应该使用批量学习还是在线学习技术？在继续阅读之前，请先暂停一会儿，尝试回答一下这些问题。</p> 
<p>有监督、回归、批量学习</p> 
<h3>
<a id="233__86"></a>2.3.3 选择性能指标</h3> 
<p>下一步是选择性能指标。回归问题的典型性能指标是均方根误差（RMSE）。它给出了系统通常会在预测中产生多大误差，对于较大的误差，权重较高。</p> 
<h3>
<a id="234__92"></a>2.3.4 获取数据及数据观察</h3> 
<p>首先导入需要用到的库：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> os
<span class="token keyword">import</span> tarfile
<span class="token keyword">import</span> urllib
<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
</code></pre> 
<p>读取数据：</p> 
<pre><code class="prism language-python"><span class="token comment"># 文件地址</span>
csv_path <span class="token operator">=</span> <span class="token string">"D:\Py-project\Python Learning\Hands-On Machine Learning\2.End to End Project\housing.csv"</span>
<span class="token comment"># 读取文件</span>
housing <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>csv_path<span class="token punctuation">)</span>
<span class="token comment"># 查看文件基本信息</span>
housing<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 查看头五条数据</span>
housing<span class="token punctuation">.</span>tail<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 查看末五条数据</span>
housing<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 快速获取数据集的简单描述，特别是总行数、每个属性的类型和非空值的数量</span>
<span class="token comment"># 所有属性的字段都是数字，除了ocean_proximity。它的类型是object，因此它可以是任何类型的Python对象。不过从CSV中加载该数据，所以它是文本属性。</span>
housing<span class="token punctuation">[</span><span class="token string">"ocean_proximity"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 频次统计. 可以查看分类属性，有多少种分类存在，每种类别下分别有多少个区域</span>
housing<span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 显示数值属性的摘要</span>
</code></pre> 
<p>对于非数值型 Series 对象， describe() (opens new window)返回值的总数、唯一值数量、出现次数最多的值及出现的次数。</p> 
<p>count、mean、min以及max行的意思很清楚。需要注意的是，这里的空值会被忽略（因此本例中，total_bedrooms的count是20 433而不是20 640）。</p> 
<p>std行显示的是标准差（用来测量数值的离散程度）。25%、50%和75%行显示相应的百分位数：百分位数表示一组观测值中给定百分比的观测值都低于该值。</p> 
<p>快速查看数据的直方图：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> matplotlib
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt

plt<span class="token punctuation">.</span>style<span class="token punctuation">.</span>use<span class="token punctuation">(</span><span class="token string">'seaborn-white'</span><span class="token punctuation">)</span>
matplotlib<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">"font.sans-serif"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"SimHei"</span><span class="token punctuation">]</span>  <span class="token comment"># 指定字体为SimHei,用于显示中文,如果Ariel,中文会乱码</span>
matplotlib<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">"axes.unicode_minus"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 用来正常显示负号</span>
housing<span class="token punctuation">.</span>hist<span class="token punctuation">(</span>bins<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 绘制每个数值属性的直方图</span>
<span class="token comment"># 直方图用来显示给定值范围（横轴）的实例数量（纵轴）。你可以一次绘制一个属性，也可以在整个数据集上调用hist（）方法，绘制每个属性的直方图。</span>
plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'①直方图.png'</span><span class="token punctuation">)</span>
</code></pre> 
<h3>
<a id="235__141"></a>2.3.5 创建测试集</h3> 
<p>在进一步查看数据之前，你需要先创建一个测试集</p> 
<p>在这个阶段主动搁置部分数据听起来可能有些奇怪。毕竟，你才只简单浏览了一下数据而已，在决定用什么算法之前，当然还需要了解更多的知识，对吧？</p> 
<p>没错，但是大脑是个非常神奇的模式检测系统，也就是说，它很容易过拟合：如果是你本人来浏览测试集数据，很可能会跌入某个看似有趣的测试数据模式，</p> 
<p>进而选择某个特殊的机器学习模型。然后当你再使用测试集对泛化误差率进行估算时，估计结果将会过于乐观，该系统启动后的表现将不如预期那般优秀。</p> 
<p>这称为数据窥探偏误（data snooping bias）。</p> 
<p>理论上，创建测试集非常简单，只需要随机选择一些实例，通常是数据集的20%（如果数据集很大，比例将更小），然后将它们放在一边：</p> 
<p>但为了即使在更新数据集之后也有一个稳定的训练测试分割，常见地解决方案是每个实例都使用一个标识符来决定是否进入测试集</p> 
<p>（假定每个实例都有一个唯一且不变的标识符）。例如，你可以计算每个实例标识符的哈希值，如果这个哈希值小于或等于最大哈希值的20%，</p> 
<p>则将该实例放入测试集。这样可以确保测试集在多个运行里都是一致的，即便更新数据集也仍然一致。</p> 
<p>新实例的20%将被放入新的测试集，而之前训练集中的实例也不会被放入新测试集。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> zlib <span class="token keyword">import</span> crc32
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np


<span class="token keyword">def</span> <span class="token function">test_set_check</span><span class="token punctuation">(</span>identifier<span class="token punctuation">,</span> test_ratio<span class="token punctuation">)</span><span class="token punctuation">:</span>
 <span class="token keyword">return</span> crc32<span class="token punctuation">(</span>np<span class="token punctuation">.</span>int64<span class="token punctuation">(</span>identifier<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffffffff</span> <span class="token operator">&lt;</span> test_ratio <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">32</span>
</code></pre> 
<p>不幸的是，housing数据集没有标识符列。最简单的解决方法是使用行索引作为ID：</p> 
<pre><code class="prism language-python">housing_with_id <span class="token operator">=</span> housing<span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 添加一列‘index’索引列</span>
</code></pre> 
<p>如果使用行索引作为唯一标识符，你需要确保在数据集的末尾添加新数据，并且不会删除任何行。</p> 
<p>如果不能保证这一点，那么你可以尝试使用某个最稳定的特征来创建唯一标识符。</p> 
<blockquote> 
 <p>例如，一个区域的经纬度肯定几百万年都不会变，你可以将它们组合成如下的ID</p> 
 <p>housing_with_id[“id”] = housing[“longitude”] * 1000 + housing[“latitude”] # 添加一列‘index’索引列</p> 
</blockquote> 
<p>Scikit-Learn提供了一些函数，可以通过多种方式将数据集分成多个子集。</p> 
<p>最简单的函数是train_test_split()。首先，它也有random_state参数，让你可以像之前提到过的那样设置随机生成器种子；</p> 
<p>random_state是为了保证程序每次运行都分割一样的训练集和测试集。其次，你可以把行数相同的多个数据集一次性发送给它，它会根据相同的索引将其拆分</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split

train_set<span class="token punctuation">,</span> test_set <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>housing<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>  <span class="token comment"># 划分数据集，test_size是测试集的百分比大小</span>
</code></pre> 
<p>要预测房价中位数，收入中位数是一个非常重要的属性。于是你希望确保在收入属性上，测试集能够代表整个数据集中各种不同类型的收入。</p> 
<p>由于收入中位数是一个连续的数值属性，所以你得先创建一个收入类别的属性。</p> 
<p>用pd.cut()来创建5个收入类别属性的（用1～5来做标签），0～1.5是类别1，1.5～3是类别2，以此类推：</p> 
<pre><code class="prism language-python">housing<span class="token punctuation">[</span><span class="token string">"income_cat"</span><span class="token punctuation">]</span> <span class="token operator">=</span> pd<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>housing<span class="token punctuation">[</span><span class="token string">"median_income"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bins<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>inf<span class="token punctuation">]</span><span class="token punctuation">,</span> labels<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># np.inf是无穷大</span>
</code></pre> 
<p>重新抽样划分数据集：</p> 
<p>现在，你可以根据收入类别进行分层抽样了。使用Scikit-Learn的StratifiedShuffleSplit类(分层随机切分交叉验证器)：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> StratifiedShuffleSplit


split <span class="token operator">=</span> StratifiedShuffleSplit<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>  <span class="token comment"># 设置分组抽样切分数据集的参数</span>
n_splits重新打乱和切分迭代的次数。test_size和train_size的大小只用设置<span class="token number">1</span>个，另一个默认是其补集。
<span class="token keyword">for</span> train_index<span class="token punctuation">,</span> test_index <span class="token keyword">in</span> split<span class="token punctuation">.</span>split<span class="token punctuation">(</span>housing<span class="token punctuation">,</span> housing<span class="token punctuation">[</span><span class="token string">"income_cat"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 生成索引以将数据分为训练集和测试集。</span>
  strat_train_set <span class="token operator">=</span> housing<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>train_index<span class="token punctuation">]</span>
  strat_test_set <span class="token operator">=</span> housing<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>test_index<span class="token punctuation">]</span>
<span class="token comment"># 查看分层结果</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>strat_test_set<span class="token punctuation">[</span><span class="token string">"income_cat"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token builtin">len</span><span class="token punctuation">(</span>strat_test_set<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>strat_train_set<span class="token punctuation">[</span><span class="token string">"income_cat"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token builtin">len</span><span class="token punctuation">(</span>strat_train_set<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 现在你可以删除income_cat属性，将数据恢复原样了：</span>
<span class="token keyword">for</span> set_ <span class="token keyword">in</span> <span class="token punctuation">(</span>strat_train_set<span class="token punctuation">,</span> strat_test_set<span class="token punctuation">)</span><span class="token punctuation">:</span>
  set_<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">"income_cat"</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
</code></pre> 
<h2>
<a id="24__231"></a>2.4 从数据探索和可视化中获得洞见</h2> 
<p>到现在为止，我们还只是在快速浏览数据，从而对手头上正在处理的数据类型形成一个大致的了解。本阶段的目标是再深入一点。</p> 
<p>首先，把测试集放在一边，你能探索的只有训练集。此外，如果训练集非常庞大，你可以抽样一个探索集，这样后面的操作更简单快捷一些。</p> 
<p>让我们先创建一个副本，这样可以随便尝试而不损害训练集：</p> 
<pre><code class="prism language-python">housing <span class="token operator">=</span> strat_train_set<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3>
<a id="241__245"></a>2.4.1 将地理数据可视化</h3> 
<p>由于存在地理位置信息（经度和纬度），因此建立一个各区域的分布图以便于可视化数据是一个很好的想法</p> 
<pre><code class="prism language-python">housing<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>kind<span class="token operator">=</span><span class="token string">"scatter"</span><span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">"longitude"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"latitude"</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span>  <span class="token comment"># kind指定图形类型，x,y定数据，alpha突出高密度数据点位置</span>
plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'②地位位置.png'</span><span class="token punctuation">)</span>
</code></pre> 
<p>现在加入房价信息和人口信息。每个圆的半径大小代表了每个区域的人口数量（选项s），颜色代表价格（选项c）。</p> 
<p>我们使用一个名叫jet的预定义颜色表（选项cmap）来进行可视化，颜色范围从蓝（低）到红（高）</p> 
<pre><code class="prism language-python">housing<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>kind<span class="token operator">=</span><span class="token string">"scatter"</span><span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">"longitude"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"latitude"</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.4</span><span class="token punctuation">,</span>
             s<span class="token operator">=</span>housing<span class="token punctuation">[</span><span class="token string">"population"</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">"population"</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             c<span class="token operator">=</span><span class="token string">"median_house_value"</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span>plt<span class="token punctuation">.</span>get_cmap<span class="token punctuation">(</span><span class="token string">"jet"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> colorbar<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'③地理位置+房价+人口.png'</span><span class="token punctuation">)</span>
</code></pre> 
<p>s指定圆的大小与人口数量相关，label标注，c指定圆的颜色与房价高低相关，cmap指定颜色表，colorbar=True/False开启或关闭色条显示。</p> 
<h3>
<a id="242__270"></a>2.4.2 寻找相关性</h3> 
<pre><code class="prism language-python">corr_matrix <span class="token operator">=</span> housing<span class="token punctuation">.</span>corr<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># corr()方法计算每对属性之间的标准相关系数（默认pearson相关）</span>
<span class="token comment"># 也可以用kendall或spearman，eg: corr_matrix = housing.corr(method='spearman/kendall')</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>corr_matrix<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>corr_matrix<span class="token punctuation">[</span><span class="token string">"median_house_value"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sort_values<span class="token punctuation">(</span>ascending<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 单独现实1列的相关性，sort_values是用来排序的</span>
</code></pre> 
<p>还有一种方法可以检测属性之间的相关性，就是使用pandas的scatter_matrix函数，它会绘制出每个数值属性相对于其他数值属性的相关性。</p> 
<p>现在我们有11个数值属性，可以得到121个图像，篇幅原因无法完全展示，这里仅关注那些与房价中位数属性最相关的，可算作是最有潜力的属性</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> pandas<span class="token punctuation">.</span>plotting <span class="token keyword">import</span> scatter_matrix


attributes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"median_house_value"</span><span class="token punctuation">,</span> <span class="token string">"median_income"</span><span class="token punctuation">,</span> <span class="token string">"total_rooms"</span><span class="token punctuation">,</span> <span class="token string">"housing_median_age"</span><span class="token punctuation">]</span>
scatter_matrix<span class="token punctuation">(</span>housing<span class="token punctuation">[</span>attributes<span class="token punctuation">]</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 指定绘制部分数据，可加入“diagonal='kde'”让直方图变成密度分布图</span>
plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'④相关性散点图.png'</span><span class="token punctuation">)</span>
</code></pre> 
<p>最有潜力能够预测房价中位数的属性是收入中位数，所以我们单独来看看其相关性的散点图</p> 
<pre><code class="prism language-python">housing<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>kind<span class="token operator">=</span><span class="token string">"scatter"</span><span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">"median_income"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"median_house_value"</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'⑤房价中位数与收入中位数相关性散点图.png'</span><span class="token punctuation">)</span>
</code></pre> 
<h3>
<a id="243__301"></a>2.4.3 试验不同属性的组合</h3> 
<p>在准备给机器学习算法输入数据之前，你要做的最后一件事应该是尝试各种属性的组合。</p> 
<p>例如，如果你不知道一个区域有多少个家庭，那么知道一个区域的“房间总数”也没什么用。你真正想要知道的是一个家庭的房间数量。</p> 
<p>同样，单看“卧室总数”这个属性本身也没什么意义，你可能想拿它和“房间总数”来对比，或者拿来同“每个家庭的人口数”这个属性组合似乎也挺有意思。</p> 
<p>我们来试着创建这些新属性：</p> 
<pre><code class="prism language-python">housing<span class="token punctuation">[</span><span class="token string">"rooms_per_household"</span><span class="token punctuation">]</span> <span class="token operator">=</span> housing<span class="token punctuation">[</span><span class="token string">"total_rooms"</span><span class="token punctuation">]</span> <span class="token operator">/</span> housing<span class="token punctuation">[</span><span class="token string">"households"</span><span class="token punctuation">]</span>
housing<span class="token punctuation">[</span><span class="token string">"bedrooms_per_room"</span><span class="token punctuation">]</span> <span class="token operator">=</span> housing<span class="token punctuation">[</span><span class="token string">"total_bedrooms"</span><span class="token punctuation">]</span> <span class="token operator">/</span> housing<span class="token punctuation">[</span><span class="token string">"total_rooms"</span><span class="token punctuation">]</span>
housing<span class="token punctuation">[</span><span class="token string">"population_per_household"</span><span class="token punctuation">]</span> <span class="token operator">=</span> housing<span class="token punctuation">[</span><span class="token string">"population"</span><span class="token punctuation">]</span> <span class="token operator">/</span> housing<span class="token punctuation">[</span><span class="token string">"households"</span><span class="token punctuation">]</span>
<span class="token comment"># 再来看看相关矩阵：</span>
corr_matrix <span class="token operator">=</span> housing<span class="token punctuation">.</span>corr<span class="token punctuation">(</span><span class="token punctuation">)</span>
corr_matrix<span class="token punctuation">[</span><span class="token string">"median_house_value"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sort_values<span class="token punctuation">(</span>ascending<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_excel<span class="token punctuation">(</span><span class="token string">R"⑥新相关性矩阵.xlsx"</span><span class="token punctuation">)</span>
</code></pre> 
<p>显然，卧室/房间比例更低的房屋往往价格更贵。同样，“每个家庭的房间数量”也比“房间总数”更具信息量——房屋越大，价格越贵。</p> 
<p>这一轮的探索不一定要多么彻底，关键是迈开第一步，快速获得洞见，这将有助于你获得非常棒的第一个原型。</p> 
<p>这也是一个不断迭代的过程：一旦你的原型产生并且开始运行，你可以分析它的输出以获得更多洞见，然后再次回到这个探索步骤。</p> 
<h2>
<a id="25__330"></a>2.5 机器学习算法的数据准备</h2> 
<p>这里你应该编写函数来执行，而不是手动操作，原因如下：</p> 
<ul>
<li> <p>你可以在任何数据集上轻松重现这些转换（例如，获得更新的数据集之后）。</p> </li>
<li> <p>你可以逐渐建立起一个转换函数的函数库，可以在以后的项目中重用。</p> </li>
<li> <p>你可以在实时系统中使用这些函数来转换新数据，再输入给算法。</p> </li>
<li> <p>你可以轻松尝试多种转换方式，查看哪种转换的组合效果最佳。</p> </li>
</ul> 
<p>但是现在，让我们先回到一个干净的训练集（再次复制strat_train_set），然后将预测器和标签分开，因为这里我们不一定对它们使用相同的转换方式</p> 
<p>（需要注意drop（）会创建一个数据副本，但是不影响strat_train_set）</p> 
<pre><code class="prism language-python">housing <span class="token operator">=</span> strat_train_set<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">"median_house_value"</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># drop将预测值列和标签分开</span>
housing_labels <span class="token operator">=</span> strat_train_set<span class="token punctuation">[</span><span class="token string">"median_house_value"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3>
<a id="251__355"></a>2.5.1 数据清理</h3> 
<p>大部分的机器学习算法无法在缺失的特征上工作，所以我们要创建一些函数来辅助它。</p> 
<p>前面我们已经注意到total_bedrooms属性有部分值缺失，所以我们要解决它。有以下三种选择：</p> 
<ol>
<li> <p>放弃这些相应的区域。</p> </li>
<li> <p>放弃整个属性。</p> </li>
<li> <p>将缺失的值设置为某个值（0、平均数或者中位数等）。</p> </li>
</ol> 
<p>通过DataFrame的dropna（）、drop（）和fillna（）方法，可以轻松完成这些操作：</p> 
<pre><code class="prism language-python">housing<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span>subset<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"total_bedrooms"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># option 1</span>
housing<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">"total_bedrooms"</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># option 2</span>
median <span class="token operator">=</span> housing<span class="token punctuation">[</span><span class="token string">"total_bedrooms"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>median<span class="token punctuation">(</span><span class="token punctuation">)</span>
housing<span class="token punctuation">[</span><span class="token string">"total_bedrooms"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fillna<span class="token punctuation">(</span>median<span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token comment"># option 3</span>
</code></pre> 
<p>Scikit-Learn提供了一个非常容易上手的类来处理缺失值：SimpleImputer。使用方法如下：</p> 
<pre><code class="prism language-python"><span class="token comment"># 首先，你需要创建一个SimpleImputer实例，指定你要用属性的中位数值替换该属性的缺失值：</span>
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>impute <span class="token keyword">import</span> SimpleImputer


imputer <span class="token operator">=</span> SimpleImputer<span class="token punctuation">(</span>strategy<span class="token operator">=</span><span class="token string">"median"</span><span class="token punctuation">)</span>
<span class="token comment"># 由于中位数值只能在数值属性上计算，所以我们需要创建一个没有文本属性ocean_proximity的数据副本：</span>
housing_num <span class="token operator">=</span> housing<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">"ocean_proximity"</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment"># 使用fit（）方法将imputer实例适配到训练数据，使用transform()方法将imputer应用到housing_num：</span>
<span class="token comment"># fit_transform()是两者的联合优化方法。(适用于sklearn的大多数方法）</span>
x <span class="token operator">=</span> imputer<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing_num<span class="token punctuation">)</span>
</code></pre> 
<p>PS：这里imputer仅仅只是计算了每个属性的中位数值，并将结果存储在其实例变量statistics_中。虽然只有total_bedrooms这个属性存在缺失值，</p> 
<p>但是我们无法确认系统启动之后新数据中是否一定不存在任何缺失值，所以稳妥起见，还是将imputer应用于所有的数值属性：</p> 
<p>现在x是一个包含转换后特征的NumPy数组（不适用与pandas的dataframe）。如果你想将它放回pandas DataFrame，也很简单：</p> 
<pre><code class="prism language-python">housing_tr <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>x<span class="token punctuation">,</span> columns<span class="token operator">=</span>housing_num<span class="token punctuation">.</span>columns<span class="token punctuation">,</span> index<span class="token operator">=</span>housing_num<span class="token punctuation">.</span>index<span class="token punctuation">)</span>
</code></pre> 
<h3>
<a id="252__403"></a>2.5.2 处理文本和分类属性</h3> 
<p>到目前为止，我们只处理数值属性，但现在让我们看一下文本属性。在此数据集中，只有一个：ocean_proximity属性。</p> 
<pre><code class="prism language-python">housing_cat <span class="token operator">=</span> housing<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"ocean_proximity"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>它不是任意文本，而是有限个可能的取值，每个值代表一个类别。因此，此属性是分类属性。</p> 
<p>大多数机器学习算法更喜欢使用数字，因此让我们将这些类别从文本转到数字。为此，我们可以使用Scikit-Learn的OrdinalEncoder类</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> OrdinalEncoder


ordinal_encoder <span class="token operator">=</span> OrdinalEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span>
housing_cat_encoded <span class="token operator">=</span> ordinal_encoder<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing_cat<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'使用Categories_实例变量获取类别列表: '</span><span class="token punctuation">,</span> ordinal_encoder<span class="token punctuation">.</span>categories_<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>housing_cat_encoded<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>这种表征方式产生的一个问题是，机器学习算法会认为两个相近的值比两个离得较远的值更为相似一些。</p> 
<p>在某些情况下这是对的（对一些有序类别，像“坏”“平均”“好”“优秀”），但是，对ocean_proximity而言情况并非如此</p> 
<p>（例如，类别0和类别4之间就比类别0和类别1之间的相似度更高）。</p> 
<p>为了解决这个问题，常见的解决方案是给每个类别创建一个二进制的属性：</p> 
<p>当类别是“&lt;1H OCEAN”时，一个属性为1（其他为0），当类别是“INLAND”时，另一个属性为1（其他为0），以此类推。</p> 
<p>这就是独热编码(one hot)，因为只有一个属性为1（热），其他均为0（冷）。新的属性有时候称为哑（dummy）属性。</p> 
<p>Scikit-Learn提供了一个OneHotEncoder编码器，可以将整数类别值转换为独热向量。我们用它来将类别编码为独热向量。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> OneHotEncoder


cat_encoder <span class="token operator">=</span> OneHotEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span>
housing_cat_1hot <span class="token operator">=</span> cat_encoder<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing_cat<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'观察生成的SciPy稀疏矩阵：n'</span><span class="token punctuation">,</span> housing_cat_1hot<span class="token punctuation">)</span>
</code></pre> 
<p>这里的输出是一个SciPy稀疏矩阵，而不是一个NumPy数组。</p> 
<p>当你有成千上万个类别属性时，这个函数会非常有用。因为在独热编码完成之后，我们会得到一个几千列的矩阵，并且全是0，每行仅有一个1。</p> 
<p>占用大量内存来存储0是一件非常浪费的事情，因此稀疏矩阵选择仅存储非零元素的位置。而你依旧可以像使用一个普通的二维数组那样来使用它，</p> 
<p>当然如果你实在想把它转换成一个（密集的）NumPy数组，只需要调用toarray（）方法即可：</p> 
<pre><code class="prism language-pyhton">housing_cat_1hot_array = housing_cat_1hot.toarray()
print('---begin---n', housing_cat_1hot_array)
print('再次使用Categories_实例变量获取类别列表: ', cat_encoder.categories_)
</code></pre> 
<p>如果类别属性具有大量可能的类别（例如，国家代码、专业、物种），那么独热编码会导致大量的输入特征，这可能会减慢训练并降低性能。</p> 
<p>如果发生这种情况，你可能想要用相关的数字特征代替类别输入。</p> 
<blockquote> 
 <p>例如，你可以用与海洋的距离来替换ocean_proximity特征（类似地，可以用该国家的人口和人均GDP来代替国家代码）。</p> 
 <p>或者，你可以用可学习的低维向量（称为嵌入）来替换每个类别。每个类别的表征可以在训练期间学习。这是表征学习的示例</p> 
</blockquote> 
<h3>
<a id="253__472"></a>2.5.3 自定义转换器</h3> 
<p>虽然Scikit-Learn提供了许多有用的转换器(比如上面的SimpleImputer、OrdinalEncoder)，</p> 
<p>但是你仍然需要为一些诸如自定义清理操作或组合特定属性等任务编写自己的转换器。</p> 
<p>你当然希望让自己的转换器与Scikit-Learn自身的功能（比如流水线）无缝衔接，而由于Scikit-Learn依赖于鸭子类型的编译，而不是继承，</p> 
<p>所以你所需要的只是创建一个类，然后应用以下三种方法：fit（）（返回self）、transform（）、fit_transform（）。</p> 
<p>你可以通过添加TransformerMixin作为基类，直接得到最后一种方法。同时，如果添加BaseEstimator作为基类（并在构造函数中避免*args和**kargs）</p> 
<p>你还能额外获得两种非常有用的自动调整超参数的方法（get_params（）和set_params（），包含在BaseEstimator类中）。</p> 
<p>注：大概意思就是，用sklearn的类组建自己的新类。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>base <span class="token keyword">import</span> BaseEstimator<span class="token punctuation">,</span> TransformerMixin

rooms_ix<span class="token punctuation">,</span> bedrooms_ix<span class="token punctuation">,</span> population_ix<span class="token punctuation">,</span> households_ix <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span>
 

<span class="token keyword">class</span> <span class="token class-name">CombinedAttributesAdder</span><span class="token punctuation">(</span>BaseEstimator<span class="token punctuation">,</span> TransformerMixin<span class="token punctuation">)</span><span class="token punctuation">:</span>
  	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> add_bedrooms_per_room<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># no *args or **kargs</span>
   	 	self<span class="token punctuation">.</span>add_bedrooms_per_room <span class="token operator">=</span> add_bedrooms_per_room

  	<span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    	<span class="token keyword">return</span> self  <span class="token comment"># nothing else to do</span>
	<span class="token keyword">def</span> <span class="token function">transform</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        rooms_per_household <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> rooms_ix<span class="token punctuation">]</span> <span class="token operator">/</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> households_ix<span class="token punctuation">]</span>
        population_per_household <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> population_ix<span class="token punctuation">]</span> <span class="token operator">/</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> households_ix<span class="token punctuation">]</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>add_bedrooms_per_room<span class="token punctuation">:</span>
            bedrooms_per_room <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> bedrooms_ix<span class="token punctuation">]</span> <span class="token operator">/</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> rooms_ix<span class="token punctuation">]</span>
            <span class="token keyword">return</span> np<span class="token punctuation">.</span>c_<span class="token punctuation">[</span>x<span class="token punctuation">,</span> rooms_per_household<span class="token punctuation">,</span> population_per_household<span class="token punctuation">,</span> bedrooms_per_room<span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> np<span class="token punctuation">.</span>c_<span class="token punctuation">[</span>x<span class="token punctuation">,</span> rooms_per_household<span class="token punctuation">,</span> population_per_household<span class="token punctuation">]</span>


attr_adder <span class="token operator">=</span> CombinedAttributesAdder<span class="token punctuation">(</span>add_bedrooms_per_room<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
housing_extra_attribs <span class="token operator">=</span> attr_adder<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>housing<span class="token punctuation">.</span>values<span class="token punctuation">)</span>
</code></pre> 
<h3>
<a id="254__518"></a>2.5.4 特征缩放</h3> 
<p>特征缩放即把数据都放在同一个尺度下。</p> 
<p>最重要也最需要应用到数据上的转换就是特征缩放。如果输入的数值属性具有非常大的比例差异，往往会导致机器学习算法的性能表现不佳，当然也有极少数特例</p> 
<p>案例中的房屋数据就是这样：房间总数的范围从6～39 320，而收入中位数的范围是0～15。</p> 
<p>注意，目标值通常不需要缩放。</p> 
<p>同比例缩放所有属性的两种常用方法是最小-最大缩放和标准化。</p> 
<p>最小-最大缩放（又叫作归一化）：</p> 
<p>将值重新缩放使其最终范围归于0～1之间。实现方法是将值减去最小值并除以最大值和最小值的差。</p> 
<p>对此，Scikit-Learn提供了一个名为MinMaxScaler的转换器。如果出于某种原因，你希望范围不是0～1，那么可以通过调整超参数feature_range进行更改。</p> 
<pre><code class="prism language-python">housing_try_by_myself <span class="token operator">=</span> strat_train_set<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">'ocean_proximity'</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 创建一个自己用的训练数据集</span>

<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> MinMaxScaler

scaler <span class="token operator">=</span> MinMaxScaler<span class="token punctuation">(</span>feature_range<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># feature_range可用来设置归一化的范围区域，不设置默认是（0，1）</span>
housing_try_by_myself <span class="token operator">=</span> scaler<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing_try_by_myself<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'nhello myself: n'</span><span class="token punctuation">,</span> housing_try_by_myself<span class="token punctuation">)</span>
</code></pre> 
<p>标准化：</p> 
<p>首先减去平均值（所以标准化值的均值总是零），然后除以方差，从而使得结果的分布具备单位方差。不同于最小-最大缩放的是，标准化不将值绑定到特定范围，</p> 
<p>对某些算法而言，这可能是个问题（例如，神经网络期望的输入值范围通常是0～1）。但是标准化的方法受异常值的影响更小。</p> 
<p>例如，假设某个地区的平均收入为100（错误数据），最小-最大缩放会将所有其他值从0～15降到0～0.15，而标准化则不会受到很大影响。</p> 
<p>Scikit-Learn提供了一个标准化的转换器StandardScaler。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> StandardScaler

scaler <span class="token operator">=</span> StandardScaler<span class="token punctuation">(</span><span class="token punctuation">)</span>
housing_try_by_myself <span class="token operator">=</span> scaler<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing_try_by_myself<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'nhello myself 2 : n'</span><span class="token punctuation">,</span> housing_try_by_myself<span class="token punctuation">)</span>
</code></pre> 
<p>重要的是，跟所有转换一样，缩放器仅用来拟合训练集，而不是完整的数据集（包括测试集）。只有这样，才能使用它们来转换训练集和测试集（和新数据）。</p> 
<h3>
<a id="255__572"></a>2.5.5 转换流水线</h3> 
<p>转换流水线: 带有最终估计器的转换管道 → 按流程处理数据。</p> 
<p>正如你所见，许多数据转换的步骤需要以正确的顺序来执行。而Scikit-Learn正好提供了Pipeline类来支持这样的转换。下面是一个数值属性的流水线示例：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>pipeline <span class="token keyword">import</span> Pipeline
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> StandardScaler

num_pipeline <span class="token operator">=</span> Pipeline<span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">(</span><span class="token string">'imputer'</span><span class="token punctuation">,</span> SimpleImputer<span class="token punctuation">(</span>strategy<span class="token operator">=</span><span class="token string">"median"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token string">'attribs_adder'</span><span class="token punctuation">,</span> CombinedAttributesAdder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token string">'std_scaler'</span><span class="token punctuation">,</span> StandardScaler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
housing_num_tr <span class="token operator">=</span> num_pipeline<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing_num<span class="token punctuation">)</span>
</code></pre> 
<p>Pipeline构造函数会通过一系列名称/估算器的配对来定义步骤序列。除了最后一个是估算器之外，前面都必须是转换器（也就是说，必须有fit_transform（）方法）。至于命名可以随意，你喜欢就好（只要它们是独一无二的，不含双下划线），它们稍后在超参数调整中会有用</p> 
<p>到目前为止，我们分别处理了类别列和数值列。拥有一个能够处理所有列的转换器会更方便，将适当的转换应用于每个列。</p> 
<p>在0.20版中，Scikit-Learn为此引入了ColumnTransformer，好消息是它与pandas DataFrames一起使用时效果很好。</p> 
<p>让我们用它来将所有转换应用到房屋数据：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>compose <span class="token keyword">import</span> ColumnTransformer

<span class="token comment"># ColumnTransformer将转换器应用于数组或pandas的DataFrame的列</span>
<span class="token comment"># 该估计器允许独立地转换输入的不同列或列子集，并将每个转换器生成的特征连接起来形成一个单一的特征空间。</span>
<span class="token comment"># 这对于异构或柱状数据非常有用，可以将多个特征提取机制或转换组合成单个转换器。</span>
num_attribs <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>housing_num<span class="token punctuation">)</span>
cat_attribs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ocean_proximity"</span><span class="token punctuation">]</span>
full_pipeline <span class="token operator">=</span> ColumnTransformer<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> num_pipeline<span class="token punctuation">,</span> num_attribs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"cat"</span><span class="token punctuation">,</span> OneHotEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cat_attribs<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
housing_prepared <span class="token operator">=</span> full_pipeline<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing<span class="token punctuation">)</span>
</code></pre> 
<p>构造函数需要一个元组列表，其中每个元组都包含一个名字、一个转换器，以及一个该转换器能够应用的列名字（或索引）的列表。</p> 
<p>在此示例中，我们指定数值列使用之前定义的num_pipeline进行转换，类别列使用OneHotEncoder进行转换。</p> 
<p>最后，我们将ColumnTransformer应用到房屋数据：它将每个转换器应用于适当的列，并沿第二个轴合并输出（转换器必须返回相同数量的行）。</p> 
<p>请注意，OneHotEncoder返回一个稀疏矩阵，而num_pipeline返回一个密集矩阵。</p> 
<p>当稀疏矩阵和密集矩阵混合在一起时，ColumnTransformer会估算最终矩阵的密度（即单元格的非零比率），</p> 
<p>如果密度低于给定的阈值，则返回一个稀疏矩阵（通过默认值为sparse_threshold=0.3）。</p> 
<p>在此示例中，它返回一个密集矩阵。我们有一个预处理流水线，该流水线可以获取全部房屋数据并对每一列进行适当的转换。</p> 
<h2>
<a id="26__627"></a>2.6 选择和训练模型</h2> 
<h3>
<a id="261__629"></a>2.6.1 训练和评估训练集</h3> 
<p>首先，如同我们在第1章所做的，先训练一个线性回归模型：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LinearRegression

lin_reg <span class="token operator">=</span> LinearRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>
lin_reg<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">)</span>
<span class="token comment"># 现在你有一个可以工作的线性回归模型了。让我们用几个训练集的实例试试：</span>
some_data <span class="token operator">=</span> housing<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>
some_labels <span class="token operator">=</span> housing_labels<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>
some_data_prepared <span class="token operator">=</span> full_pipeline<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>some_data<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Predictions:"</span><span class="token punctuation">,</span> lin_reg<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>some_data_prepared<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Labels:"</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">(</span>some_labels<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>可以工作了，虽然预测还不是很准确（例如，第一次的预测失效接近40%！）。</p> 
<p>我们可以使用Scikit-Learn的mean_squared_error（）函数来测量整个训练集上回归模型的RMSE：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> mean_squared_error 

housing_predictions <span class="token operator">=</span> lin_reg<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">)</span>
lin_mse <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>housing_labels<span class="token punctuation">,</span> housing_predictions<span class="token punctuation">)</span>
lin_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>lin_mse<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lin_rmse<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>好吧，这虽然比什么都没有要好，但显然也不是一个好看的成绩：</p> 
<p>大多数区域的median_housing_values分布在120 000～265 000美元之间，所以典型的预测误差达到68 628美元只能算是差强人意。</p> 
<p>这就是一个典型的模型对训练数据欠拟合的案例。这种情况发生时，通常意味着这些特征可能无法提供足够的信息来做出更好的预测，或者是模型本身不够强大。</p> 
<p>我们在第1章已经提到，想要修正欠拟合，可以通过选择更强大的模型，或为算法训练提供更好的特征，又或者减少对模型的限制等方法。</p> 
<p>我们这个模型不是一个正则化的模型，所以就排除了最后那个选项。你可以试试添加更多的特征（例如，人口数量的日志），但首先，</p> 
<p>让我们尝试一个更复杂的模型，看看它到底是怎么工作的。</p> 
<p>我们来训练一个DecisionTreeRegressor。这是一个非常强大的模型，它能够从数据中找到复杂的非线性关系：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeRegressor

tree_reg <span class="token operator">=</span> DecisionTreeRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span>
tree_reg<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">)</span>
<span class="token comment"># 既然这个模型已经训练有素，我们可以用训练集来评估一下：</span>
housing_predictions <span class="token operator">=</span> tree_reg<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">)</span>
tree_mse <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>housing_labels<span class="token punctuation">,</span> housing_predictions<span class="token punctuation">)</span>
tree_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>tree_mse<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>tree_rmse<span class="token punctuation">)</span>
</code></pre> 
<p>PS: 和转换器的区别好像在：转换器的使用是fit和transform，而算法估算器是fit和predict。（好像还有SVM是用fit和score？）</p> 
<p>等等，什么！完全没有错误？这个模型真的可以做到绝对完美吗？当然，更有可能的是这个模型对数据严重过拟合了。我们怎么确认呢？</p> 
<p>前面提到过，在你有信心启动模型之前，都不要触碰测试集，所以这里，你需要拿训练集中的一部分用于训练，另一部分用于模型验证。</p> 
<h3>
<a id="262__699"></a>2.6.2 使用交叉验证评估</h3> 
<p>评估决策树模型的一种方法是使用train_test_split函数将训练集分为较小的训练集和验证集，然后根据这些较小的训练集来训练模型，并对其进行评估。</p> 
<p>另一个不错的选择是使用Scikit-Learn的K-折交叉验证功能。以下是执行K-折交叉验证的代码：</p> 
<p>它将训练集随机分割成10个不同的子集，每个子集称为一个折叠，然后对决策树模型进行10次训练和评估——每次挑选1个折叠进行评估，</p> 
<p>使用另外的9个折叠进行训练。产生的结果是一个包含10次评估分数的数组：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> cross_val_score

scores <span class="token operator">=</span> cross_val_score<span class="token punctuation">(</span>tree_reg<span class="token punctuation">,</span> housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">"neg_mean_squared_error"</span><span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
tree_rmse_scores <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token operator">-</span>scores<span class="token punctuation">)</span>
</code></pre> 
<p>Scikit-Learn的交叉验证功能更倾向于使用效用函数（越大越好）而不是成本函数（越小越好），所以计算分数的函数实际上是负的MSE（一个负值）函数，</p> 
<p>这就是为什么上面的代码在计算平方根之前会先计算出-scores。</p> 
<p>让我们看看结果：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">display_scores</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Scores:"</span><span class="token punctuation">,</span> scores<span class="token punctuation">)</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Mean:"</span><span class="token punctuation">,</span> scores<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Standard deviation:"</span><span class="token punctuation">,</span> scores<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


display_scores<span class="token punctuation">(</span>tree_rmse_scores<span class="token punctuation">)</span>
</code></pre> 
<p>这次的决策树模型好像不如之前表现得好。事实上，它看起来简直比线性回归模型还要糟糕！</p> 
<p>请注意，交叉验证不仅可以得到一个模型性能的评估值，还可以衡量该评估的精确度（即其标准差）。这里该决策树得出的评分约为71 407，上下浮动±2439。</p> 
<p>如果你只使用了一个验证集，就收不到这样的结果信息。交叉验证的代价就是要多次训练模型，因此也不是永远都行得通。</p> 
<p>保险起见，让我们也计算一下线性回归模型的评分：</p> 
<pre><code class="prism language-python">lin_scores <span class="token operator">=</span> cross_val_score<span class="token punctuation">(</span>lin_reg<span class="token punctuation">,</span> housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">"neg_mean_squared_error"</span><span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
lin_rmse_scores <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token operator">-</span>lin_scores<span class="token punctuation">)</span>
display_scores<span class="token punctuation">(</span>lin_rmse_scores<span class="token punctuation">)</span>
</code></pre> 
<p>没错，决策树模型确实是严重过拟合了，以至于表现得比线性回归模型还要糟糕。</p> 
<p>我们再来试试最后一个模型：RandomForestRegressor随机森林：</p> 
<p>通过对特征的随机子集进行许多个决策树的训练，然后对其预测取平均。在多个模型的基础之上建立模型，称为集成学习，</p> 
<p>这是进一步推动机器学习算法的好方法。这里我们将跳过大部分代码，因为与其他模型基本相同：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> RandomForestRegressor  <span class="token comment"># 导入模块</span>

forest_reg <span class="token operator">=</span> RandomForestRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 定义1个随机森林算法，因为后续可以对算法进行改进和微调，所以需要定义1个算法</span>
forest_reg<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">)</span>  <span class="token comment"># 训练该模型（就是用数据去fit这个模型）</span>
housing_predictions <span class="token operator">=</span> forest_reg<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">)</span>  <span class="token comment"># 使用模型，用模型去预测要预测的数据</span>
forest_mse <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>housing_labels<span class="token punctuation">,</span> housing_predictions<span class="token punctuation">)</span>
forest_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>forest_mse<span class="token punctuation">)</span>
scores <span class="token operator">=</span> cross_val_score<span class="token punctuation">(</span>forest_reg<span class="token punctuation">,</span> housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">"neg_mean_squared_error"</span><span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
forest_rmse_scores <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token operator">-</span>scores<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>forest_rmse<span class="token punctuation">)</span>
display_scores<span class="token punctuation">(</span>forest_rmse_scores<span class="token punctuation">)</span>
</code></pre> 
<p>哇，这个就好多了：随机森林看起来很有戏。但是，请注意，训练集上的分数仍然远低于验证集，这意味着该模型仍然对训练集过拟合。</p> 
<p>过拟合的可能解决方案包括简化模型、约束模型（即使其正规化），或获得更多的训练数据。不过在深入探索随机森林之前，</p> 
<p>你应该先尝试一遍各种机器学习算法的其他模型（几种具有不同内核的支持向量机，比如神经网络模型等），但是记住，别花太多时间去调整超参数。</p> 
<p>我们的目的是筛选出几个（2～5个）有效的模型。</p> 
<h3>
<a id="263__784"></a>2.6.3 保存模型</h3> 
<p>每一个尝试过的模型你都应该妥善保存，以便将来可以轻松回到你想要的模型当中。</p> 
<p>记得还要同时保存超参数和训练过的参数，以及交叉验证的评分和实际预测的结果。这样你就可以轻松地对比不同模型类型的评分，以及不同模型造成的错误类型</p> 
<p>通过Python的pickle模块或joblib库，你可以轻松保存Scikit-Learn模型，这样可以更有效地将大型NumPy数组（可以用pip安装）序列化：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> joblib

joblib<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>forest_reg<span class="token punctuation">,</span> filename<span class="token operator">=</span><span class="token string">'forest_reg_example_from_book.m'</span><span class="token punctuation">)</span>  <span class="token comment"># 将模型forest_reg存入forest_reg_example_from_book文件</span>
<span class="token comment"># and later...</span>
my_model_loaded <span class="token operator">=</span> joblib<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'forest_reg_example_from_book.m'</span><span class="token punctuation">)</span>  <span class="token comment"># 调用forest_reg_example_from_book 文件里的forest_reg模型</span>
</code></pre> 
<h2>
<a id="27__802"></a>2.7 微调模型</h2> 
<p>假设你现在有了一个有效模型的候选列表。现在你需要对它们进行微调。我们来看几个可行的方法。</p> 
<h3>
<a id="271__808"></a>2.7.1 网格搜索</h3> 
<p>一种微调的方法是手动调整超参数，直到找到一组很好的超参数值组合。这个过程非常枯燥乏味，你可能坚持不到足够的时间来探索出各种组合。</p> 
<p>相反，你可以用Scikit-Learn的GridSearchCV来替你进行探索。你所要做的只是告诉它你要进行实验的超参数是什么，以及需要尝试的值，</p> 
<p>它将会使用交叉验证来评估超参数值的所有可能组合。例如，下面这段代码搜索RandomForestRegressor的超参数值的最佳组合：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> GridSearchCV
param_grid <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token string">'n_estimators'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'max_features'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token string">'bootstrap'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'n_estimators'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'max_features'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
forest_reg <span class="token operator">=</span> RandomForestRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span>
grid_search <span class="token operator">=</span> GridSearchCV<span class="token punctuation">(</span>forest_reg<span class="token punctuation">,</span> param_grid<span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">'neg_mean_squared_error'</span><span class="token punctuation">,</span> return_train_score<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
grid_search<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">)</span>
</code></pre> 
<p>当你不知道超参数应该赋什么值时，一个简单的方法是尝试10的连续幂次方</p> 
<p>（如果你想要得到更细粒度的搜索，可以使用更小的数，参考这个示例中所示的n_estimators超参数）。</p> 
<p>这个param_grid告诉Scikit-Learn：</p> 
<p>首先评估第一个dict中的n_estimator和max_features的所有3×4=12种超参数值组合（先不要担心这些超参数现在意味着什么，在第7章中会解释）</p> 
<p>接着，尝试第二个dict中超参数值的所有2×3=6种组合，但这次超参数bootstrap需要设置为False而不是True（True是该超参数的默认值）。</p> 
<p>总而言之，网格搜索将探索RandomForestRegressor超参数值的12+6=18种组合，并对每个模型进行5次训练（因为我们使用的是5-折交叉验证）。</p> 
<p>换句话说，总共会完成18×5=90次训练！这可能需要相当长的时间，但是完成后你就可以获得最佳的参数组合：</p> 
<pre><code class="prism language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>grid_search<span class="token punctuation">.</span>best_params_<span class="token punctuation">)</span>
</code></pre> 
<p>因为被评估的最优n_estimator是最大值8和30，所以还可以试试更高的值，评分可能还会继续改善。</p> 
<p>你可以直接得到最好的估算器：</p> 
<pre><code class="prism language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>grid_search<span class="token punctuation">.</span>best_estimator_<span class="token punctuation">)</span>
</code></pre> 
<p>如果GridSearchCV被初始化为refit=True（默认值），那么一旦通过交叉验证找到了最佳估算器，它将在整个训练集上重新训练。</p> 
<p>这通常是个好方法，因为提供更多的数据很可能提升其性能。</p> 
<p>当然还有评估分数：</p> 
<pre><code class="prism language-python">cvres <span class="token operator">=</span> grid_search<span class="token punctuation">.</span>cv_results_
<span class="token keyword">for</span> mean_score<span class="token punctuation">,</span> params <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>cvres<span class="token punctuation">[</span><span class="token string">"mean_test_score"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cvres<span class="token punctuation">[</span><span class="token string">"params"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token operator">-</span>mean_score<span class="token punctuation">)</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span>
</code></pre> 
<p>在本例中，我们得到的最佳解决方案是将超参数max_features设置为8，将超参数n_estimators设置为30。这个组合的RMSE分数为49682，略优于之前使用默认超参数值的分数50 182。</p> 
<p>不要忘了，有些数据准备的步骤也可以当作超参数来处理。</p> 
<blockquote> 
 <p>例如，网格搜索会自动查找是否添加你不确定的特征（比如是否使用转换器CombinedAttributesAdder的超参数add_bedrooms_per_room）。</p> 
</blockquote> 
<p>同样，还可以用它来自动寻找处理问题的最佳方法，例如处理异常值、缺失特征，以及特征选择等。</p> 
<h3>
<a id="272__876"></a>2.7.2 随机搜索</h3> 
<p>如果探索的组合数量较少（例如上一个示例），那么网格搜索是一种不错的方法。</p> 
<p>但是当超参数的搜索范围较大时，通常会优先选择使用RandomizedSearchCV. 这个类用起来与GridSearchCV类大致相同，</p> 
<p>但它不会尝试所有可能的组合，而是在每次迭代中为每个超参数选择一个随机值，然后对一定数量的随机组合进行评估。这种方法有两个显著好处：</p> 
<p>如果运行随机搜索1000个迭代，那么将会探索每个超参数的1000个不同的值（而不是像网格搜索方法那样每个超参数仅探索少量几个值）。</p> 
<p>通过简单地设置迭代次数，可以更好地控制要分配给超参数搜索的计算预算。</p> 
<h3>
<a id="273__890"></a>2.7.3 集成方法</h3> 
<p>还有一种微调系统的方法是将表现最优的模型组合起来。组合（或“集成”）方法通常比最佳的单一模型更好</p> 
<p>（就像随机森林比其所依赖的任何单个决策树模型更好一样），特别是当单一模型会产生不同类型误差时更是如此。我们将在第7章中更详细地介绍这个主题。</p> 
<h3>
<a id="274__898"></a>2.7.4 分析最佳模型及其误差</h3> 
<p>通过检查最佳模型，你总是可以得到一些好的洞见。例如在进行准确预测时，RandomForestRegressor可以指出每个属性的相对重要程度：</p> 
<pre><code class="prism language-python">feature_importances <span class="token operator">=</span> grid_search<span class="token punctuation">.</span>best_estimator_<span class="token punctuation">.</span>feature_importances_
<span class="token keyword">print</span><span class="token punctuation">(</span>feature_importances<span class="token punctuation">)</span>  <span class="token comment"># 此处仅有数据中各个属性/特征的重要性分数，没有属性名称</span>
<span class="token comment"># 将这些重要性分数显示在对应的属性名称旁边：</span>
extra_attribs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"rooms_per_hhold"</span><span class="token punctuation">,</span> <span class="token string">"pop_per_hhold"</span><span class="token punctuation">,</span> <span class="token string">"bedrooms_per_room"</span><span class="token punctuation">]</span>
cat_encoder <span class="token operator">=</span> full_pipeline<span class="token punctuation">.</span>named_transformers_<span class="token punctuation">[</span><span class="token string">"cat"</span><span class="token punctuation">]</span>
cat_one_hot_attribs <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>cat_encoder<span class="token punctuation">.</span>categories_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
attributes <span class="token operator">=</span> num_attribs <span class="token operator">+</span> extra_attribs <span class="token operator">+</span> cat_one_hot_attribs
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">sorted</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>feature_importances<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3>
<a id="275__915"></a>2.7.5 通过测试集评估系统</h3> 
<p>通过一段时间的训练，你终于有了一个表现足够优秀的系统。现在是用测试集评估最终模型的时候了。</p> 
<p>这个过程没有什么特别的，只需要从测试集中获取预测器和标签，运行full_pipeline来转换数据（调用transform（）而不是fit_transform（））</p> 
<p>然后在测试集上评估最终模型：</p> 
<pre><code class="prism language-python">final_model <span class="token operator">=</span> grid_search<span class="token punctuation">.</span>best_estimator_
x_test <span class="token operator">=</span> strat_test_set<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">"median_house_value"</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
y_test <span class="token operator">=</span> strat_test_set<span class="token punctuation">[</span><span class="token string">"median_house_value"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
x_test_prepared <span class="token operator">=</span> full_pipeline<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span>
final_predictions <span class="token operator">=</span> final_model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x_test_prepared<span class="token punctuation">)</span>
final_mse <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> final_predictions<span class="token punctuation">)</span>
final_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>final_mse<span class="token punctuation">)</span>  <span class="token comment"># =&gt; evaluates to 47,730.2</span>
</code></pre> 
<p>在某些情况下，泛化误差的这种点估计将不足以说服你启动生产环境：如果它仅比当前生产环境中的模型好0.1%？</p> 
<p>你可能想知道这个估计的精确度。为此，你可以使用scipy.stats.t.interval（）计算泛化误差的95%置信区间：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> scipy <span class="token keyword">import</span> stats
confidence <span class="token operator">=</span> <span class="token number">0.95</span>
squared_errors <span class="token operator">=</span> <span class="token punctuation">(</span>final_predictions <span class="token operator">-</span> y_test<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>
np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>stats<span class="token punctuation">.</span>t<span class="token punctuation">.</span>interval<span class="token punctuation">(</span>confidence<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>squared_errors<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> loc<span class="token operator">=</span>squared_errors<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> scale<span class="token operator">=</span>stats<span class="token punctuation">.</span>sem<span class="token punctuation">(</span>squared_errors<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果之前进行过大量的超参数调整，这时的评估结果通常会略逊于你之前使用交叉验证时的表现结果（因为通过不断调整，系统在验证数据上终于表现良好，在未知数据集上可能达不到这么好的效果）。</p> 
<p>在本例中，结果虽然并非如此，但是当这种情况发生时，你一定不要继续调整超参数，不要试图再努力让测试集的结果变得好看一些，因为这些改进在泛化到新的数据集时又会变成无用功。</p> 
<h2>
<a id="28__950"></a>2.8 启动、监控和维护你的系统</h2> 
<p>即使是经过训练可以对猫和狗的图片进行分类的模型，也可能需要定期重新训练，不是因为猫和狗会一夜之间有变化，而是因为相机在不断变化，</p> 
<p>图像格式、清晰度、亮度和尺寸也会变化。而且，人们明年可能会爱上不同的品种，或者他们可能会给宠物戴上小帽子，谁知道呢？</p> 
<p>最后，请保留每个模型的备份，准备好流程和工具，以便在新模型出现时快速回滚到以前的模型，以防新模型由于某种情况开始出现严重故障。</p> 
<p>进行备份还可以轻松实现将新模型与以前的模型进行比较。同样，你应该保留每个版本的数据集，以便在新数据集遭到破坏的情况下可以回滚到先前的数据集</p> 
<p>（如果事实能证明添加到其中的新数据都是离群值）。备份数据集还可以针对任何先前的数据集来评估任何模型。</p> 
<h2>
<a id="29__966"></a>2.9 练习题</h2> 
<p>使用本章的房屋数据集完下面的练习题：</p> 
<ol>
<li> <p>使用不同的超参数，如kernel=“linear”（具有C超参数的多种值）或kernel=“rbf”（C超参数和gamma超参数的多种值），尝试一个支持向量机回归器（sklearn.svm.SVR），不用担心现在不知道这些超参数的含义。最好的SVR预测器是如何工作的？</p> </li>
<li> <p>尝试用RandomizedSearchCV替换GridSearchCV。</p> </li>
<li> <p>尝试在准备流水线中添加一个转换器，从而只选出最重要的属性。</p> </li>
<li> <p>尝试创建一个覆盖完整的数据准备和最终预测的流水线。</p> </li>
<li> <p>使用GridSearchCV自动探索一些准备选项。</p> </li>
</ol> 
<p>以上练习题的解决方案可以在Jupyter notebook上获得，链接地址为https://github.com/ageron/handson-ml2。</p> 
<h2>
<a id="_984"></a>代码精简汇总（结合练习）</h2> 
<pre><code class="prism language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> StratifiedShuffleSplit
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>impute <span class="token keyword">import</span> SimpleImputer
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> OneHotEncoder
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>base <span class="token keyword">import</span> BaseEstimator<span class="token punctuation">,</span> TransformerMixin
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> StandardScaler
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>pipeline <span class="token keyword">import</span> Pipeline
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>compose <span class="token keyword">import</span> ColumnTransformer
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LinearRegression
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> mean_squared_error
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> mean_absolute_error
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> r2_score
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> cross_val_score
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeRegressor
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> RandomForestRegressor
<span class="token keyword">import</span> joblib
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> GridSearchCV
<span class="token keyword">from</span> scipy <span class="token keyword">import</span> stats

<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>svm <span class="token keyword">import</span> SVC
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> RandomizedSearchCV
<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>stats <span class="token keyword">import</span> uniform


<span class="token comment"># 〇 读取文件</span>
<span class="token comment"># 文件地址</span>
csv_path <span class="token operator">=</span> <span class="token string">"housing.csv"</span>
<span class="token comment"># 读取文件</span>
housing <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>csv_path<span class="token punctuation">)</span>

<span class="token comment"># ① 数据集处理部分（划分训练集和测试集）</span>
<span class="token comment"># 添加一列‘index’索引列，使用行索引作为ID</span>
housing_with_id <span class="token operator">=</span> housing<span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 需要确保在数据集的末尾添加新数据，并且不会删除任何行。</span>
<span class="token comment"># 为收入中位数划分类别。用pd.cut()来创建5个收入类别属性的（用1～5来做标签），0～1.5是类别1，1.5～3是类别2，以此类推：</span>
housing<span class="token punctuation">[</span><span class="token string">"income_cat"</span><span class="token punctuation">]</span> <span class="token operator">=</span> pd<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>housing<span class="token punctuation">[</span><span class="token string">"median_income"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                               bins<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>inf<span class="token punctuation">]</span><span class="token punctuation">,</span> labels<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># np.inf是无穷大</span>
<span class="token comment"># 根据收入类别进行分层抽样了,划分数据集。使用Scikit-Learn的StratifiedShuffleSplit类(分层随机切分交叉验证器)：</span>
split <span class="token operator">=</span> StratifiedShuffleSplit<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>  <span class="token comment"># 设置分组抽样切分数据集的参数</span>
<span class="token comment"># n_splits重新打乱和切分迭代的次数。test_size和train_size的大小只用设置1个，另一个默认是其补集。</span>
<span class="token keyword">for</span> train_index<span class="token punctuation">,</span> test_index <span class="token keyword">in</span> split<span class="token punctuation">.</span>split<span class="token punctuation">(</span>housing<span class="token punctuation">,</span> housing<span class="token punctuation">[</span><span class="token string">"income_cat"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 生成索引以将数据分为训练集和测试集。</span>
    strat_train_set <span class="token operator">=</span> housing<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>train_index<span class="token punctuation">]</span>
    strat_test_set <span class="token operator">=</span> housing<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>test_index<span class="token punctuation">]</span>
<span class="token comment"># 删除income_cat属性，将数据恢复原样：</span>
<span class="token keyword">for</span> set_ <span class="token keyword">in</span> <span class="token punctuation">(</span>strat_train_set<span class="token punctuation">,</span> strat_test_set<span class="token punctuation">)</span><span class="token punctuation">:</span>
    set_<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">"income_cat"</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token comment"># 存入数据值（特征值）</span>
housing <span class="token operator">=</span> strat_train_set<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">"median_house_value"</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># drop将预测值列和标签分开</span>
<span class="token comment"># 存入预测值（即要预测的值）</span>
housing_labels <span class="token operator">=</span> strat_train_set<span class="token punctuation">[</span><span class="token string">"median_house_value"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment"># ② 数据预处理部分（此部分无用，全集合在第③部分里了）</span>
<span class="token comment"># 划分数据属性和文本属性：</span>
housing_num <span class="token operator">=</span> housing<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">"ocean_proximity"</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 仅有数据属性的数据集</span>
housing_cat <span class="token operator">=</span> housing<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"ocean_proximity"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 仅有文本属性的数据集</span>
<span class="token comment"># 1.对于数据属性缺失值：</span>
imputer <span class="token operator">=</span> SimpleImputer<span class="token punctuation">(</span>strategy<span class="token operator">=</span><span class="token string">"median"</span><span class="token punctuation">)</span>  <span class="token comment"># 创建一个SimpleImputer估算器，将数据型缺失值转换为该属性的中位数</span>
housing_num_fill <span class="token operator">=</span> imputer<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing_num<span class="token punctuation">)</span>  <span class="token comment"># fit适配该数据集的估算器，transform应用该估算器</span>
<span class="token comment"># 2.对于文本属性：</span>
<span class="token comment"># 首先判断它是分类属性，可以转化为数字标签。同时，为了避免数字之间相似性影响到原本标签之间的相似性，可以采用Onehot二进制编码.</span>
cat_encoder <span class="token operator">=</span> OneHotEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 创建一个OneHotEncoder编码器，将分类属性转换为onehot向量</span>
housing_cat_1hot <span class="token operator">=</span> cat_encoder<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing_cat<span class="token punctuation">)</span>  <span class="token comment"># fit适配该数据集的编码器，transform应用该编码器</span>
<span class="token comment"># 3.特征值缩放（标准化）：</span>
scaler <span class="token operator">=</span> StandardScaler<span class="token punctuation">(</span><span class="token punctuation">)</span>
housing_try_by_myself <span class="token operator">=</span> scaler<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing_num_fill<span class="token punctuation">)</span>
<span class="token comment"># 4.自定义一个CombinedAttributesAdder转换器（用sklearn的类组建自己的新类）</span>


<span class="token keyword">class</span> <span class="token class-name">CombinedAttributesAdder</span><span class="token punctuation">(</span>BaseEstimator<span class="token punctuation">,</span> TransformerMixin<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 添加TransformerMixin和BaseEstimator作为基类</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> add_bedrooms_per_room<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># no *args or **kargs</span>
        self<span class="token punctuation">.</span>add_bedrooms_per_room <span class="token operator">=</span> add_bedrooms_per_room

    <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self  <span class="token comment"># nothing else to do</span>

    <span class="token keyword">def</span> <span class="token function">transform</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        rooms_per_household <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> rooms_ix<span class="token punctuation">]</span> <span class="token operator">/</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> households_ix<span class="token punctuation">]</span>
        population_per_household <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> population_ix<span class="token punctuation">]</span> <span class="token operator">/</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> households_ix<span class="token punctuation">]</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>add_bedrooms_per_room<span class="token punctuation">:</span>
            bedrooms_per_room <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> bedrooms_ix<span class="token punctuation">]</span> <span class="token operator">/</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> rooms_ix<span class="token punctuation">]</span>
            <span class="token keyword">return</span> np<span class="token punctuation">.</span>c_<span class="token punctuation">[</span>x<span class="token punctuation">,</span> rooms_per_household<span class="token punctuation">,</span> population_per_household<span class="token punctuation">,</span> bedrooms_per_room<span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> np<span class="token punctuation">.</span>c_<span class="token punctuation">[</span>x<span class="token punctuation">,</span> rooms_per_household<span class="token punctuation">,</span> population_per_household<span class="token punctuation">]</span>


rooms_ix<span class="token punctuation">,</span> bedrooms_ix<span class="token punctuation">,</span> population_ix<span class="token punctuation">,</span> households_ix <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span>  <span class="token comment"># 定义类的初始值</span>


<span class="token comment"># ③ 将上述步骤转化成一个可以随时调用的流水线：</span>
<span class="token comment"># 1. 设置 数值属性的pipeline （# 命名，转换器/估算器/编码器）：</span>
num_pipeline <span class="token operator">=</span> Pipeline<span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">'imputer'</span><span class="token punctuation">,</span> SimpleImputer<span class="token punctuation">(</span>strategy<span class="token operator">=</span><span class="token string">"median"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># 将数据型缺失值转换为该属性的中位数</span>
    <span class="token punctuation">(</span><span class="token string">'attribs_adder'</span><span class="token punctuation">,</span> CombinedAttributesAdder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># 调用自己创建的转换器</span>
    <span class="token punctuation">(</span><span class="token string">'std_scaler'</span><span class="token punctuation">,</span> StandardScaler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 标准化缩放</span>
<span class="token comment"># 2.引入ColumnTransformer独立地转换输入的不同列或列子集，将多个转换组合成单个转换器（应用于数组或pandas的DataFrame的列）</span>
<span class="token comment"># 提供列名数据</span>
num_attribs <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>housing_num<span class="token punctuation">)</span>  <span class="token comment"># 数值属性列名的列表</span>
cat_attribs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ocean_proximity"</span><span class="token punctuation">]</span>  <span class="token comment"># 文本属性列名的列表</span>
<span class="token comment"># 构造1个ColumnTransformer需要一个元组列表，包含：1个名字、1个转换器，以及1个该转换器能够应用的列名字（或索引）的列表。</span>
full_pipeline <span class="token operator">=</span> ColumnTransformer<span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> num_pipeline<span class="token punctuation">,</span> num_attribs<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"cat"</span><span class="token punctuation">,</span> OneHotEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cat_attribs<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 定义1个集合转换器</span>

housing_prepared <span class="token operator">=</span> full_pipeline<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>housing<span class="token punctuation">)</span>  <span class="token comment"># 对训练数据应用数据处理流程</span>


<span class="token comment"># ④ 选择和训练模型</span>
<span class="token comment"># PS：定义一个查看评分的函数</span>
<span class="token keyword">def</span> <span class="token function">display_scores</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Scores:"</span><span class="token punctuation">,</span> scores<span class="token punctuation">)</span>  <span class="token comment"># 看交叉验证的一组的值</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Mean:"</span><span class="token punctuation">,</span> scores<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 取交叉验证的评分的均值</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Standard deviation:"</span><span class="token punctuation">,</span> scores<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 看标准差</span>
    scores_write <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span>
    scores_mean_write <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>scores<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    scores_std_write <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>scores<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'2.2预测结果.txt'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'n'</span> <span class="token operator">+</span> <span class="token string">'本部分结果如下：'</span><span class="token punctuation">)</span>
        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'n'</span> <span class="token operator">+</span> <span class="token string">"Scores:"</span> <span class="token operator">+</span> scores_write<span class="token punctuation">)</span>  <span class="token comment"># 写入交叉验证的一组的值</span>
        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'n'</span> <span class="token operator">+</span> <span class="token string">"Mean:"</span> <span class="token operator">+</span> scores_mean_write<span class="token punctuation">)</span>  <span class="token comment"># 写入交叉验证的评分的均值</span>
        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'n'</span> <span class="token operator">+</span> <span class="token string">"Standard deviation:"</span> <span class="token operator">+</span> scores_std_write<span class="token punctuation">)</span>  <span class="token comment"># 写入标准差</span>
        <span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment"># 1.使用LinearRegression训练一个线性回归模型：</span>
<span class="token comment"># first part 训练模型:</span>
lin_reg <span class="token operator">=</span> LinearRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 定义1个（含有特定参数的）线性回归模型（本例中没有设置参数）</span>
lin_reg<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">)</span>  <span class="token comment"># 用训练集训练这个模型</span>
<span class="token comment"># second part 模型应用:</span>
housing_predictions <span class="token operator">=</span> lin_reg<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">)</span>  <span class="token comment"># 带入数据进行预测</span>
<span class="token comment"># third part 结果评估:</span>
<span class="token comment"># 回归模型的评价指标有：MSE(均方误差)，RMSE(均方根误差)，MAE(平均绝对误差)、R-Squared(拟合度,三种误差的综合度量)</span>
lin_mse <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>housing_labels<span class="token punctuation">,</span> housing_predictions<span class="token punctuation">)</span>  <span class="token comment"># 用mean_squared_error测量回归模型的MSE</span>
lin_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>lin_mse<span class="token punctuation">)</span>  <span class="token comment"># 开根号，得到RMSE值</span>
lin_mae <span class="token operator">=</span> mean_absolute_error<span class="token punctuation">(</span>housing_labels<span class="token punctuation">,</span> housing_predictions<span class="token punctuation">)</span>  <span class="token comment"># 用mean_absolute_error测量回归模型的MAE</span>
lin_r_2 <span class="token operator">=</span> r2_score<span class="token punctuation">(</span>housing_labels<span class="token punctuation">,</span> housing_predictions<span class="token punctuation">)</span>  <span class="token comment"># 用r2_score测量回归模型的R-Squared</span>
<span class="token comment"># 也可交叉验证（KFold-折交叉验证功能）后，再来评估</span>
lin_cross_mse <span class="token operator">=</span> cross_val_score<span class="token punctuation">(</span>lin_reg<span class="token punctuation">,</span> housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">"neg_mean_squared_error"</span><span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment"># 模型，数据，预测值，scoring选择评分的指标（此处是‘-MSE’），cv用来确定交叉验证的切分策略，数值默认是指定KFold的折数</span>
<span class="token comment"># 此处得到一组-MSE值</span>
lin_cross_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token operator">-</span>lin_cross_mse<span class="token punctuation">)</span>  <span class="token comment"># 得到一组RMSE值</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'nn LinearRegression预测结果如下：n'</span><span class="token punctuation">)</span>
display_scores<span class="token punctuation">(</span>lin_cross_rmse<span class="token punctuation">)</span>  <span class="token comment"># 调用自定义函数，观察评分的均值和标准差</span>


<span class="token comment"># 2.使用DecisionTreeRegressor训练一个决策树模型</span>
<span class="token comment"># first part 训练模型:</span>
tree_reg <span class="token operator">=</span> DecisionTreeRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 定义1个（含有特定参数的）决策树模型（本例中没有设置参数）</span>
tree_reg<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">)</span>  <span class="token comment"># 用训练集训练这个模型</span>
<span class="token comment"># second part 模型应用:</span>
housing_predictions <span class="token operator">=</span> tree_reg<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">)</span>  <span class="token comment"># 带入数据进行预测</span>
<span class="token comment"># third part 结果评估:</span>
tree_mse <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>housing_labels<span class="token punctuation">,</span> housing_predictions<span class="token punctuation">)</span>  <span class="token comment"># 用mean_squared_error测量回归模型的MSE</span>
tree_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>tree_mse<span class="token punctuation">)</span>  <span class="token comment"># 开根号，得到RMSE值</span>
<span class="token comment"># 同样可以用交叉验证后的RMSE均值和标准差 进行评估</span>
tree_cross_mse <span class="token operator">=</span> cross_val_score<span class="token punctuation">(</span>tree_reg<span class="token punctuation">,</span> housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">"neg_mean_squared_error"</span><span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment"># 得到一组-MSE值</span>
tree_cross_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token operator">-</span>tree_cross_mse<span class="token punctuation">)</span>  <span class="token comment"># 得到一组RMSE值</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'nn DecisionTreeRegressor预测结果如下：n'</span><span class="token punctuation">)</span>
display_scores<span class="token punctuation">(</span>tree_cross_rmse<span class="token punctuation">)</span>  <span class="token comment"># 调用自定义函数，观察评分的均值和标准差</span>


<span class="token comment"># 3.使用RandomForestRegressor训练一个随机森林模型（进行许多个决策树的训练，然后对其预测取平均）：</span>
<span class="token comment"># first part 训练模型:</span>
forest_reg <span class="token operator">=</span> RandomForestRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 定义1个（含有特定参数的）随机森林模型（本例中没有设置参数）</span>
forest_reg<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">)</span>  <span class="token comment"># 训练该模型（就是用数据去fit这个模型）</span>
<span class="token comment"># second part 模型应用:</span>
housing_predictions <span class="token operator">=</span> forest_reg<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">)</span>  <span class="token comment"># 带入数据进行预测</span>
<span class="token comment"># third part 结果评估:</span>
forest_mse <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>housing_labels<span class="token punctuation">,</span> housing_predictions<span class="token punctuation">)</span>  <span class="token comment"># 算MSE</span>
forest_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>forest_mse<span class="token punctuation">)</span>  <span class="token comment"># 算RMSE</span>
forest_cross_mse <span class="token operator">=</span> cross_val_score<span class="token punctuation">(</span>forest_reg<span class="token punctuation">,</span> housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">"neg_mean_squared_error"</span><span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment"># 交叉验证，得到一组-MSE值</span>
forest_rmse_scores <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token operator">-</span>forest_cross_mse<span class="token punctuation">)</span>  <span class="token comment"># 得到一组RMSE值</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'nn RandomForestRegressor预测结果如下：n'</span><span class="token punctuation">)</span>
display_scores<span class="token punctuation">(</span>forest_rmse_scores<span class="token punctuation">)</span>  <span class="token comment"># 调用自定义函数，观察评分的均值和标准差</span>


<span class="token comment"># 4.保存每一个尝试过的模型</span>
joblib<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>lin_reg<span class="token punctuation">,</span> filename<span class="token operator">=</span><span class="token string">'book_lin_reg_example.m'</span><span class="token punctuation">)</span>  <span class="token comment"># 将模型lin_reg存入lin_reg_example_from_book文件</span>
joblib<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>tree_reg<span class="token punctuation">,</span> filename<span class="token operator">=</span><span class="token string">'book_tree_reg_example.m'</span><span class="token punctuation">)</span>  <span class="token comment"># 将模型tree_reg存入tree_reg_example_from_book文件</span>
joblib<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>forest_reg<span class="token punctuation">,</span> filename<span class="token operator">=</span><span class="token string">'book_forest_reg_example.m'</span><span class="token punctuation">)</span>  <span class="token comment"># 将模型forest_reg存入forest_reg_example_from_book文件</span>
<span class="token comment"># 调用保存的模型(需要的时候可以调用)：my_model_loaded = joblib.load('lin_reg_example_from_book.m')</span>
<span class="token comment"># 调用保存的模型(需要的时候可以调用)：my_model_loaded = joblib.load('tree_reg_example_from_book.m')</span>
<span class="token comment"># 调用保存的模型(需要的时候可以调用)：my_model_loaded = joblib.load('forest_reg_example_from_book.m')</span>


<span class="token comment"># ⑤ 微调模型（现在有了一些有效模型的候选列表。现在你需要对它们进行微调）</span>
<span class="token comment"># 1.方法一：网格搜索GridSearchCV（提供要实验的参数及其值，使用交叉验证来评估所有组合）</span>
<span class="token comment"># first 设置微调</span>
param_grid <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token string">'n_estimators'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'max_features'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
              <span class="token punctuation">{<!-- --></span><span class="token string">'bootstrap'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'n_estimators'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'max_features'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span>  <span class="token comment"># 提供参数及其值</span>
forest_reg <span class="token operator">=</span> RandomForestRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 定义1个随机森林模型</span>
grid_search <span class="token operator">=</span> GridSearchCV<span class="token punctuation">(</span>forest_reg<span class="token punctuation">,</span> param_grid<span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">'neg_mean_squared_error'</span><span class="token punctuation">,</span> return_train_score<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token comment"># 定义1个GridSearchCV微调模型</span>
<span class="token comment"># second 应用微调</span>
grid_search<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>housing_prepared<span class="token punctuation">,</span> housing_labels<span class="token punctuation">)</span>  <span class="token comment"># 把数据带入微调模型</span>
<span class="token comment"># third 结果展示</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'nn GridSearchCV随机森林调优结果如下：n'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>grid_search<span class="token punctuation">.</span>best_params_<span class="token punctuation">)</span>  <span class="token comment"># 显示最优的参数组合</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>grid_search<span class="token punctuation">.</span>best_estimator_<span class="token punctuation">)</span>  <span class="token comment"># 显示最好的估算器（随机森林模型在这个训练集上最优的参数）</span>
cvres <span class="token operator">=</span> grid_search<span class="token punctuation">.</span>cv_results_  <span class="token comment"># 将所有训练的结果存进cvres</span>
<span class="token keyword">for</span> mean_score<span class="token punctuation">,</span> params <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>cvres<span class="token punctuation">[</span><span class="token string">"mean_test_score"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cvres<span class="token punctuation">[</span><span class="token string">"params"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 循环读取每一个组合的模型得分</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token operator">-</span>mean_score<span class="token punctuation">)</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span>  <span class="token comment"># 显示每个参数组合下的RMSE得分</span>
feature_importances <span class="token operator">=</span> grid_search<span class="token punctuation">.</span>best_estimator_<span class="token punctuation">.</span>feature_importances_  <span class="token comment"># 显示每个属性的相对重要程度：</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>feature_importances<span class="token punctuation">)</span>  <span class="token comment"># 此处仅有数据中各个属性/特征的重要性分数，没有属性名称</span>
extra_attribs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"rooms_per_hhold"</span><span class="token punctuation">,</span> <span class="token string">"pop_per_hhold"</span><span class="token punctuation">,</span> <span class="token string">"bedrooms_per_room"</span><span class="token punctuation">]</span>  <span class="token comment"># 将这些重要性分数显示在对应的属性名称旁边：</span>
cat_encoder <span class="token operator">=</span> full_pipeline<span class="token punctuation">.</span>named_transformers_<span class="token punctuation">[</span><span class="token string">"cat"</span><span class="token punctuation">]</span>
cat_one_hot_attribs <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>cat_encoder<span class="token punctuation">.</span>categories_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
attributes <span class="token operator">=</span> num_attribs <span class="token operator">+</span> extra_attribs <span class="token operator">+</span> cat_one_hot_attribs
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">sorted</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>feature_importances<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 2.方法二：随机搜索RandomizedSearchCV（在每次迭代中为每个超参数选择一个随机值，然后对一定数量的随机组合进行评估）</span>
<span class="token comment">#   通过简单地设置迭代次数，可以更好地控制要分配给超参数搜索的计算预算。</span>
<span class="token comment"># svm_reg = SVC()</span>
<span class="token comment"># param_random = {'C': np.linspace(0.1, 10, 10), 'gamma': np.linspace(1, 0.01, 10)}</span>
<span class="token comment"># randomized_search = RandomizedSearchCV(svm_reg, param_distributions=param_random, cv=4)</span>
<span class="token comment"># randomized_search.fit(housing_prepared, housing_labels)</span>
<span class="token comment"># random_cvres = randomized_search.cv_results_</span>
<span class="token comment"># for mean_score, params in zip(random_cvres["mean_test_score"], random_cvres["params"]):</span>
<span class="token comment">#     print(np.sqrt(-mean_score), params)</span>
<span class="token comment"># PS: 以上内容输出有问题：“The least populated class in y has only 1 members, which is less than n_splits=4”，建议之后回头看</span>


<span class="token comment"># ⑥ 用测试集评估模型（从测试集中获取预测器和标签，运行full_pipeline来转换数据，然后在测试集上评估最终模型）</span>
final_model <span class="token operator">=</span> grid_search<span class="token punctuation">.</span>best_estimator_  <span class="token comment"># 调用微调后的最佳模型</span>
x_test <span class="token operator">=</span> strat_test_set<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">"median_house_value"</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 提取测试集的特征列</span>
y_test <span class="token operator">=</span> strat_test_set<span class="token punctuation">[</span><span class="token string">"median_house_value"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 提取测试集的预测列</span>
x_test_prepared <span class="token operator">=</span> full_pipeline<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span>  <span class="token comment"># 用full_pipeline转换测试集的数据</span>
final_predictions <span class="token operator">=</span> final_model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x_test_prepared<span class="token punctuation">)</span>  <span class="token comment"># 把测试集数据带入微调模型进行预测</span>
final_mse <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> final_predictions<span class="token punctuation">)</span>  <span class="token comment"># 评估MSE</span>
final_rmse <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>final_mse<span class="token punctuation">)</span>  <span class="token comment"># 评估RMSE</span>
<span class="token comment"># 使用scipy.stats.t.interval（）计算泛化误差的95%置信区间</span>
confidence <span class="token operator">=</span> <span class="token number">0.95</span>
squared_errors <span class="token operator">=</span> <span class="token punctuation">(</span>final_predictions <span class="token operator">-</span> y_test<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>
<span class="token builtin">intern</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>stats<span class="token punctuation">.</span>t<span class="token punctuation">.</span>interval<span class="token punctuation">(</span>confidence<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>squared_errors<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> loc<span class="token operator">=</span>squared_errors<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> scale<span class="token operator">=</span>stats<span class="token punctuation">.</span>sem<span class="token punctuation">(</span>squared_errors<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'nn 随机森林预测测试集置信区间如下：n'</span><span class="token punctuation">,</span> <span class="token builtin">intern</span><span class="token punctuation">)</span>
</code></pre>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>