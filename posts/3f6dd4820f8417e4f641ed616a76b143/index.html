<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>初识C语言（中篇） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初识C语言（中篇）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h1 id="%E7%A7%8D%E4%B8%80%E6%A3%B5%E6%A0%91%EF%BC%8C%E6%9C%80%E5%A5%BD%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF10%E5%B9%B4%E5%89%8D%EF%BC%8C%E5%85%B6%E6%AC%A1%E6%98%AF%E7%8E%B0%E5%9C%A8%E3%80%82"><strong>种一棵树，最好的时间是10年前，其次是现在。</strong></h1> 
 <p><img alt="" height="1183" src="https://images2.imgbox.com/82/ae/TCv9xs2I_o.jpg" width="1200"></p> 
 <p></p> 
</blockquote> 
<p><strong><span style="background-color:#fff5e6">大家好，这里是anduin，这次的主题依旧是初识C语言，和上次不同，这次我们主要讲两大块，对于一些知识，我们选择略讲，但是对于一些我觉得重要的知识我会对其进行精讲并做一些补充，其余的知识我会逐渐在以后一一讲解。话不多说，接下来就开始初识C语言吧！（以下程序均在vs2022中编译）</span></strong></p> 
<hr>
<p id="main-toc"><strong>目录</strong></p> 
<p id="10.%20%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px"><a href="#10.%20%E6%93%8D%E4%BD%9C%E7%AC%A6">10. 操作符</a></p> 
<p id="%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6">算数操作符</a></p> 
<p id="%2F%20%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:80px"><a href="#%2F%20%E6%93%8D%E4%BD%9C%E7%AC%A6">/ 操作符</a></p> 
<p id="%E5%B0%8F%E7%A7%91%E6%99%AE-toc" style="margin-left:80px"><a href="#%E5%B0%8F%E7%A7%91%E6%99%AE">小科普</a></p> 
<p id="%25%C2%A0%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#%25%C2%A0%E6%93%8D%E4%BD%9C%E7%AC%A6">% 操作符</a></p> 
<p id="%25%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AF%B9%E6%AD%A3%E6%95%B0-toc" style="margin-left:80px"><a href="#%25%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AF%B9%E6%AD%A3%E6%95%B0">% 操作符对正数</a></p> 
<p id="%25%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AF%B9%E8%B4%9F%E6%95%B0-toc" style="margin-left:80px"><a href="#%25%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AF%B9%E8%B4%9F%E6%95%B0">% 操作符对负数</a></p> 
<p id="%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6">移位操作符</a></p> 
<p id="%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6">位操作符</a></p> 
<p id="%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6">赋值操作符</a></p> 
<p id="%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6">单目操作符</a></p> 
<p id="%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6">关系操作符</a></p> 
<p id="%E4%BE%8B1-toc" style="margin-left:80px"><a href="#%E4%BE%8B1">例1</a></p> 
<p id="%E4%BE%8B2-toc" style="margin-left:80px"><a href="#%E4%BE%8B2">例2</a></p> 
<p id="%C2%A0%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#%C2%A0%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"> 逻辑操作符</a></p> 
<p id="%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px"><a href="#%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6">条件操作符</a></p> 
<p id="%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px"><a href="#%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F">逗号表达式</a></p> 
<p id="%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98-toc" style="margin-left:40px"><a href="#%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98">下标引用、函数调用和结构成员</a></p> 
<p id="11.%C2%A0%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px"><a href="#11.%C2%A0%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97">11. 常见关键字</a></p> 
<p id="auto-toc" style="margin-left:40px"><a href="#auto">auto</a></p> 
<p id="typedef-toc" style="margin-left:40px"><a href="#typedef">typedef</a></p> 
<p id="%E6%9C%AC%E8%B4%A8-toc" style="margin-left:80px"><a href="#%E6%9C%AC%E8%B4%A8">本质</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:80px"><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></p> 
<p id="%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px"><a href="#%E4%BD%9C%E7%94%A8">作用</a></p> 
<p id="register-toc" style="margin-left:40px"><a href="#register">register</a></p> 
<p id="%E5%AD%98%E5%82%A8%E9%87%91%E5%AD%97%E5%A1%94-toc" style="margin-left:80px"><a href="#%E5%AD%98%E5%82%A8%E9%87%91%E5%AD%97%E5%A1%94">存储金字塔</a></p> 
<p id="%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:80px"><a href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9C%AC%E8%B4%A8">寄存器存在的本质</a></p> 
<p id="register%C2%A0%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F-toc" style="margin-left:80px"><a href="#register%C2%A0%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F">register 修饰变量</a></p> 
<p id="%E5%B0%8F%E7%A7%91%E6%99%AE-toc" style="margin-left:80px"><a href="#%E5%B0%8F%E7%A7%91%E6%99%AE">小科普</a></p> 
<p id="%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px"><a href="#%E7%BB%93%E8%AF%AD">结语</a></p> 
<hr id="hr-toc">
<p></p> 
<hr>
<h1 id="10.%20%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">10. 操作符</span></strong></span></h1> 
<h2 id="%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">算数操作符</span></strong></span></h2> 
<blockquote> 
 <p><span style="color:#0d0016">+        -        *        /        %</span></p> 
 <p><strong><span style="background-color:#fff5e6">算数操作符中的+ - *和平常运算方法相似，我们在这边重点介绍 / 和 %运算符</span></strong></p> 
</blockquote> 
<hr>
<h3 id="%2F%20%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">/ 操作符</span></strong></span></h3> 
<p><strong>为了让我们的讲解更加具有针对性，我们分<span style="color:#fe2c24">正数</span>和<span style="color:#fe2c24">负数</span>两部分进行讲解：</strong></p> 
<p><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">/ 操作符对正数</span></strong></span></p> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a = 7 / 2;
    printf("%dn", a);//3
}</code></pre> 
<blockquote> 
 <p><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">分析：对于上方代码当我们用平时的逻辑，那么这个答案应该是3.5，可在程序中编译运行，结果是 </span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6">3</span></span><span style="color:#ad720d"><span style="background-color:#fff5e6">，我们不禁产生疑惑是不是因为你打印的结果是</span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6">整形</span></span><span style="color:#ad720d"><span style="background-color:#fff5e6">的缘故，其实本身结果还是</span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6">3.5</span></span><span style="color:#ad720d"><span style="background-color:#fff5e6">呢？让我们用代码验证：</span></span></strong></p> 
</blockquote> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    float f = 7 / 2;
    printf("%fn",f);//3.000000
}</code></pre> 
<blockquote> 
 <p><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">可当我们再次进行编译运行时，结果是</span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6">3.000000</span></span><span style="color:#ad720d"><span style="background-color:#fff5e6">，因此我们可以得出结论：</span></span></strong></p> 
 <p><span style="color:#ff9900"><strong><span style="background-color:#fff5e6">除号两端的操作数如果都是整数，执行的是整数除法，至少有一个操作数是浮点数，执行的才是浮点数的除法！！！</span></strong></span></p> 
 <p><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">对于正数是这样进行运算的，那么负数呢？</span></span></strong></p> 
</blockquote> 
<hr>
<p><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">/ 操作符对负数</span></strong></span></p> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int i = -2.9;
    int j = 2.9;
    printf("%dn",j);//-2
    printf("%dn",j);//2
    return 0;
}</code></pre> 
<blockquote> 
 <p><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">对于负数运算，我们打印</span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"> j </span></span><span style="color:#ad720d"><span style="background-color:#fff5e6">的值，结果为 -2 ，和正数运算规律相似，我们可以看出它们运算都是</span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6">向0取整</span></span><span style="color:#ad720d"><span style="background-color:#fff5e6">的，那么如何理解呢？对于取整，当正负数进行运算时，并不会出现四舍五入的情况，无论正数负数都是</span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6">向0方向</span></span><span style="color:#ad720d"><span style="background-color:#fff5e6">取整！（-2.9向零取整得到2）</span></span></strong></p> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>如下图所示：</strong></span></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="221" src="https://images2.imgbox.com/dd/c6/MG4X5VE3_o.png" width="1158"></p> 
<hr>
<h3 id="%E5%B0%8F%E7%A7%91%E6%99%AE"><span style="color:#0d0016"><span style="background-color:#fff5e6">小科普</span></span></h3> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">在C语言中，是不是只有一种取整方式？如果有它们分别是怎么实现的？接下来我们来一一了解：</span></strong></p> 
</blockquote> 
<p><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">trunc - 取整函数</span></span></strong></p> 
<pre><code>#include&lt;math.h&gt;
int main()
{
     printf("%dn",(int)trunc(-2.9));//-2 
     printf("%dn",(int)trunc(2.9));//2  
}
</code></pre> 
<blockquote> 
 <p><span style="color:#ff9900"><strong><span style="background-color:#fff5e6">Tips:由于trunc函数默认接收的返回值为%f，但是我们这边想输出的是整数所以强制类型转化成int类型。</span></strong></span></p> 
</blockquote> 
<p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>floor - 地板取整</strong></span></span></p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main()
{
    printf("%.lfn",floor(-2.9));//-3
    printf("%.lfn",floor(-2.1));//-3
    printf("%.lfn",floor(2.9));//2
    printf("%.lfn",floor(2.1));//2
}</code></pre> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>因为其取整方式和函数名，我们称它为地板取整，什么意思呢，我们编译结果发现负数</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>-2.9</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>的值变成了</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>-3</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，对于正数</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>2.9</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>的值变成了</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>2</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>。</strong></span></span></p> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>我们可以观察到无论是正数还是负数，在用</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>floor函数</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>进行取整的时候都是变小，我们观察其本质可以总结为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>-∞取整，</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>如下图所示：</strong></span></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="184" src="https://images2.imgbox.com/46/88/vfoCwLoS_o.png" width="1009"></p> 
<p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>ceil - +∞取整</strong></span></span></p> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    printf("%.lfn",ceil(-2.9));//-2
    printf("%.lfn",ceil(-2.1));//-2
    printf("%.lfn",ceil(2.9));//3
    printf("%.lfn",ceil(2.1));//3
}</code></pre> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>当我们编译运行程序，可以观察到负数</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>-2.9</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>变为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>-2</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>-2.1</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>变为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>-2</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>,正数</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>2.9</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>变为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>3</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>2.1</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>变为</strong></span></span><span style="background-color:#fff5e6"><strong><span style="color:#fe2c24">3</span><span style="color:#ad720d">。</span></strong></span></p> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>我们可以观察到</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>ceil函数</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>的取整，结果都会在原来的基础上变大一个整数位，我们总结出该取整方式为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>+∞取整</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，如下图所示：</strong></span></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/16/22/OJjT60L2_o.png" width="1015"></p> 
<p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>round - 四舍五入取整</strong></span></span></p> 
<p><strong><span style="background-color:#fff5e6">是的你没有看错，与我们平常思维方式相同的四舍五入取整来了，上代码：</span></strong></p> 
<pre><code>#include&lt;math.h&gt;
int main()
{
    printf("%.lfn",round(-2.9));//-3
    printf("%.lfn",round(-2.1));//-2
    printf("%.lfn",round(2.9));//3
    printf("%.lfn",round(2.1));//2
}</code></pre> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>对于这种取整方式，没什么好说的，就是按照我们平时的思路来，例如当值</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>2.9</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>时，值为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>3</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，</strong></span></span></p> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>当值为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>2.1</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>时，值为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>2</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>。在当前情况下，凡取整的值大于等于</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>2.5</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，得出的结果都会变为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>3</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>。</strong></span></span></p> 
</blockquote> 
<hr>
<h2 id="%25%C2%A0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><span style="background-color:#fff5e6"><strong>% 操作符</strong></span></span></h2> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">概念：如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数 q 和 r，满足 a = q*d + r 且0 ≤ r &lt; d。其中，q 被称为商，r 被称为余数。</span></strong></p> 
</blockquote> 
<hr>
<p><span style="color:#ad720d"><strong><span style="background-color:#fff5e6">对于此部分我们依旧是从</span></strong></span><span style="color:#ff9900"><strong><span style="background-color:#fff5e6">正数</span></strong></span><span style="color:#ad720d"><strong><span style="background-color:#fff5e6">和</span></strong></span><span style="color:#ff9900"><strong><span style="background-color:#fff5e6">负数</span></strong></span><span style="color:#ad720d"><strong><span style="background-color:#fff5e6">两方面进行剖析：</span></strong></span></p> 
<h3 id="%25%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AF%B9%E6%AD%A3%E6%95%B0"><span style="color:#0d0016"><span style="background-color:#fff5e6"><strong>% 操作符对正数</strong></span></span></h3> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a = 10;
    int d = 3;
    printf("%dn",a%d);//1
    //因为:a=10,d=3,q=3,r=1 0&lt;=r&lt;d(3)
    //所以：a=q*d+3 -&gt; 10=3*3+1
    return 0;
}
-
</code></pre> 
<blockquote> 
 <p><span style="color:#ad720d"><strong><span style="background-color:#fff5e6">代码：基于概念，我们可以理解当前代码的意思（详情见注释）。但我们还有</span></strong></span><span style="color:#ff9900"><strong><span style="background-color:#fff5e6">另一种理解方式</span></strong></span><span style="color:#ad720d"><strong><span style="background-color:#fff5e6">：% 操作符，关注的是除法后的余数，例如代码中的10%3，我们也可以理解为商3余1，相对于概念，这种方式更加容易接受一些。</span></strong></span></p> 
 <p><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>Warning：操作符两端的操作数必须是整数！！！</strong></span></span></p> 
</blockquote> 
<hr>
<h3 id="%25%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AF%B9%E8%B4%9F%E6%95%B0"><span style="color:#0d0016"><span style="background-color:#fff5e6"><strong>% 操作符对负数</strong></span></span></h3> 
<pre><code>int main()
{
    int a = - 10;
    int d= 3;
    printf("%dn",a%d);//-1
}</code></pre> 
<p><strong><span style="background-color:#fff5e6"> 很显然，结果不满足定义中的0&lt;=r&lt;d,故后来就有了一个修订版的定义：</span></strong></p> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数 q 和 r，满足 a = q*d + r , q 为整数，且0 ≤ |r| &lt; |d|。其中，q 被称为商，r 被称为余数。</span></strong></p> 
</blockquote> 
<p><strong><span style="background-color:#fff5e6">根据定义，这里的结果也能解释了，即-10 = (-3)*3+(-1)。</span></strong></p> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>在C语言中，%</strong></span></span><span style="color:#fe2c24"><strong><span style="background-color:#fff5e6">本质</span></strong></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>取余</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，余数的大小，本质取决于商q的，而商都取决于除法运算的</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>取整规则。</strong></span></span></p> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>在对于</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>正数</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>的取余和取模在C语言中是</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>相同</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>的，我们发现对于</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>向0取整</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>和</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>向-∞的取整</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>在正数上是同向的，但是对于</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>负数</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>上就</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>完全不同</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>了，因此我们平时遇到的大多都是</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>整数取模</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，并没有做太多解释。</strong></span></span></p> 
</blockquote> 
<hr>
<h2 id="%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><span style="background-color:#fff5e6"><strong>移位操作符</strong></span></span></h2> 
<blockquote> 
 <p><span style="color:#0d0016">&gt;&gt;        &lt;&lt;（以后讲解）</span></p> 
</blockquote> 
<hr>
<h2 id="%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong><span style="color:#0d0016"><span style="background-color:#fff5e6">位操作符</span></span></strong></h2> 
<blockquote> 
 <p>&amp;         ^（以后讲解）</p> 
</blockquote> 
<hr>
<h2 id="%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><span style="background-color:#fff5e6"><strong>赋值操作符</strong></span></span></h2> 
<blockquote> 
 <p>=        +=        -=        *=        /=        &amp;=        ^=        |=        &gt;&gt;=</p> 
</blockquote> 
<p><strong><span style="background-color:#fff5e6">由于赋值操作符便于理解，我们挑两个讲一下（详情见注释）：</span></strong></p> 
<pre><code>int main()
{
    int a = 10;//创建变量，并初始化
    a = 20;//赋值
    a = a+5//等价于 a+=5
    a = a-5//等价于 a-=5
}</code></pre> 
<hr>
<h2 id="%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><span style="background-color:#fff5e6">单目操作符</span></span></h2> 
<blockquote> 
 <p>!                <strong><span style="background-color:#fff5e6"> 逻辑反操作</span></strong></p> 
 <p>-                 <strong><span style="background-color:#fff5e6">负值</span></strong></p> 
 <p>+                <strong><span style="background-color:#fff5e6">正值</span></strong></p> 
 <p>&amp;                <strong><span style="background-color:#fff5e6">取地址</span></strong></p> 
 <p>sizeof         <strong><span style="background-color:#fff5e6">操作数的类型长度（以字节为单位）</span></strong></p> 
 <p>~                <strong><span style="background-color:#fff5e6">对一个数的二进制按位取反</span></strong></p> 
 <p>--                <strong><span style="background-color:#fff5e6">前置、后置--</span></strong></p> 
 <p>++             <strong><span style="background-color:#fff5e6"> 前置、后置++</span></strong></p> 
 <p>*                 <strong><span style="background-color:#fff5e6">间接访问操作符(解引用操作符)</span></strong></p> 
 <p>(类型)         <strong><span style="background-color:#fff5e6">强制类型转换</span></strong></p> 
</blockquote> 
<p><strong><span style="background-color:#fff5e6">我们常见的操作符比如+都有两个操作数，表示为<span style="color:#fe2c24">左操作数</span>+<span style="color:#fe2c24">右操作数</span>，这种操作符叫做<span style="color:#fe2c24">双目操作符</span>。</span></strong></p> 
<p><strong><span style="background-color:#fff5e6"><span style="color:#fe2c24">单目操作符</span>其实就是只有<span style="color:#fe2c24">一个操作数</span>的。</span></strong></p> 
<p><strong><span style="background-color:#fff5e6">在这里，对于！，-，+等操作符都便于理解，而对于&amp;和*我打算之后在指针部分讲解，这里我们着重讲一下--，和++操作符（详情见注释）：</span></strong></p> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a = 10;
    int b = ++a;//前置++,先++后使用
    //a=a+1,b=a
    printf("a=%d b=%dn",a,b);//11 11
    ---------------------------------
    int a = 10;
    int b = a++;//后置++，先使用，后++
    //b=a，a=a+1
    printf("a=%d b=%dn",a,b);//11 10
    ---------------------------------
    int a = 10;
    int b = --a;//前置--，先--后使用
    //a=a-1,b=a
    printf("a=%d b=%dn",a,b);//9 9
    ---------------------------------
    int a = 10;
    int b = a--;//后置--，先使用，后--
    //b=a,a=a-1
    printf("a=%d b=%dn",a,b);//10 9
}</code></pre> 
<hr>
<h2 id="%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><span style="background-color:#fff5e6">关系操作符</span></span></h2> 
<blockquote> 
 <p>&gt;         &gt;=         &lt;        &lt;=        !=（<strong><span style="background-color:#fff5e6">不相等</span></strong>）        ==（<strong><span style="background-color:#fff5e6">相等</span></strong>）</p> 
</blockquote> 
<p><strong><span style="background-color:#fff5e6">前几个操作符，也就是对应的大于，大于等于，小于，小于等于等比较关系的操作符，这里我们讲一下后两个操作符。</span></strong></p> 
<hr>
<h3 id="%E4%BE%8B1"><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">例1</span></strong></span></h3> 
<pre><code>int main()
{
    int a = 3;
    int b = 3;
    if(a!=b)
    {
        printf("hehen");    
    }
    if(a==b)
    {
        printf("hahan");    
    }
    //结果为hehe
}</code></pre> 
<p><strong><span style="background-color:#fff5e6">运行结果如下：</span></strong> <img alt="" height="35" src="https://images2.imgbox.com/84/83/qqLJp9uX_o.png" width="310"></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>观察代码，很简单，判断a和b是否相等，如果相等则输出haha，若不相等输出hehe，因为c此处a和b都等于3，所以打印结果为hehe。</strong></span></span></p> 
</blockquote> 
<hr>
<h3 id="%E4%BE%8B2"><span style="color:#0d0016"><span style="background-color:#fff5e6"><strong>例2</strong></span></span></h3> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    char arr1[] = "abcdef";
    char arr2[] = "abcdef";
    if(arr1==arr2)
    {
        printf("==n");    
    }
    else
    {
        printf("!=n");    
    }
}</code></pre> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>我们知道用==和！=可以判断是否相等，那么对于</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>字符串</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>呢？他们是否相等，当我们编译后，发现它们是</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>不相等</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>的！因为arr1和arr2是字符串首元素地址，开辟的空间不同，所以地址当然不同，如果要比较两个字符串的大小可以用</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>strcmp函数</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>,接下来看修改后的代码：</strong></span></span></p> 
</blockquote> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
    char arr1[] = "abcdef";
    char arr2[] = "abcdef";
    if(strcmp(arr1,arr2)==0)
    {
        printf("==n");    
    }
    else
    {
        printf("!=n");    
    }
}</code></pre> 
<p><strong><span style="background-color:#fff5e6">再次运行</span></strong>：<img alt="" height="42" src="https://images2.imgbox.com/28/c4/uYq7G6we_o.png" width="274"></p> 
<blockquote>
 <span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>对于strcmp这个函数使用时需要应用头文件#include&lt;string.h&gt;,如果返回的值为0，则两个字符串相等。</strong></span></span>
</blockquote> 
<hr>
<h2 id="%C2%A0%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><span style="background-color:#fff5e6"> 逻辑操作符</span></span></h2> 
<blockquote> 
 <p>&amp;&amp; - <strong><span style="background-color:#fff5e6">逻辑与</span></strong> - <strong><span style="background-color:#fff5e6">并且</span></strong>        || - <strong><span style="background-color:#fff5e6">逻辑或</span></strong> - <strong><span style="background-color:#fff5e6">或者</span></strong></p> 
</blockquote> 
<pre><code>int main()
{
    int a= 3;
    int b = 0;
    int c = a &amp;&amp; b;
    printf("%dn",c);//真为1，假为0
    if(a&amp;&amp;b)
    {
        printf("hehen");    
    }
    if(a||b)
    {
        printf("hahan);
    }
}</code></pre> 
<p><strong><span style="background-color:#fff5e6">运行得</span></strong>：<img alt="" height="48" src="https://images2.imgbox.com/ef/f0/1RZVit7V_o.png" width="242"></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>分析：&amp;&amp;的返回值是这样规定的，如果两个数都为真，则值为1，反之则为0。</strong></span></span></p> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>对于本代码由于a&amp;&amp;b为0，故不打印hehe，||的值是有一个为真则为真，值为1，反之为0。</strong></span></span></p> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>这里由于a||b为真，所以打印haha。</strong></span></span></p> 
</blockquote> 
<hr>
<h2 id="%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016"><span style="background-color:#fff5e6">条件操作符</span></span></h2> 
<blockquote> 
 <p>exp1?exp2:exp3</p> 
</blockquote> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a = 10;
    int b = 0;
    b = (a&gt;5?3:-3);
    printf("%dn",b);//3
    return 0;
}
</code></pre> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>分析：条件操作符使用时</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>先判断表达式1</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，如果表达式1结果为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>真</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，则</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>输出第一个值</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，否则为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>第二个值</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，改题中因为a&gt;10，所以打印结果为3。当然，这段代码也可以用if        else语句来表示：</strong></span></span></p> 
</blockquote> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a = 10;
    int b = 0;
    if(a&gt;5)
    {
        b=3;    
    }
    else
    {
        b=-3;    
    }
    printf("%dn", b);
}</code></pre> 
<hr>
<h2 id="%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span style="color:#0d0016"><span style="background-color:#fff5e6">逗号表达式</span></span></h2> 
<blockquote> 
 <p>exp1, exp2, exp3, …expN</p> 
</blockquote> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a=3;
    int b=5;
    int c=0;
    int d= (a+=2,b=b-c+a,c=a+b);
    //      a=5   b=10   c=5+10     
    
    printf("%dn",d);
}</code></pre> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>分析：对于逗号表达式其特点为</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>从左往右依次计算</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，整个表达式的结果是</strong></span></span><span style="color:#fe2c24"><span style="background-color:#fff5e6"><strong>最后一个表达式的结果</strong></span></span><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>，因此在代码中d的值也就是15。</strong></span></span></p> 
</blockquote> 
<hr>
<h2 id="%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span style="color:#0d0016"><span style="background-color:#fff5e6">下标引用、函数调用和结构成员</span></span></h2> 
<blockquote> 
 <p>[]        ()        .        -&gt;</p> 
</blockquote> 
<p><strong><span style="background-color:#fff5e6">对于这类操作符我们讲解一下[ ]操作符：</span></strong></p> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int arr[10] = {0};
    arr[4]=5;
    return 0;
}
</code></pre> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>分析：对于上述代码就是引用下标4，将arr[4]的位置上赋值5。</strong></span></span></p> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>和一些操作符相同，[ ]也有两个操作数，例如arr 和 4是两个操作数，对于这个代码写成4[arr]也可以，但是这种写法不仅让人难以理解，而且比较挫，我们可千万不要写出这样的代码！！！</strong></span></span></p> 
</blockquote> 
<hr>
<h1 id="11.%C2%A0%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#0d0016"><span style="background-color:#fff5e6"><strong>11. 常见关键字</strong></span></span></h1> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">C 语言标准中规定了32个关键字，而在之后C99的标准下又增加了五个关键字，anduin这次对大家进行归纳的是C标准中的32个关键字，我们根据其特性，可以把它分为几类：</span></strong></p> 
</blockquote> 
<p> <span style="color:#0d0016"> <strong><span style="background-color:#fff5e6">数据类型关键字（12个）</span></strong></span></p> 
<ul>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">char：声明字符型变量或函数</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">short：声明短整型或函数</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">Int ：声明整型变量或函数</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">long ：声明长整型变量或函数</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">signed：声明有符号类型变量或函数</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">unsigned：声明无符号整形变量或函数</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">foat：声明浮点型变量或函数</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">double：声明双精度变量或函数</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">struct：声明结构体变量或函数</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">union：声明共用体（联合）数据类型</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">enum：声明枚举类型</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">void：声明函数无返回值或无参数，声明无类型指针</span></span></strong></li>
</ul>
<p><strong><span style="color:#0d0016"><span style="background-color:#fff5e6">控制语句关键字（12个）</span></span></strong></p> 
<p><span style="color:#e6b223"><strong><span style="background-color:#fff5e6">1.循环控制（5个）</span></strong></span></p> 
<ul>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">for：一种循环语句</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">do：循环语句的循环体</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">while ：循环语句的循环条件</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">break：跳出当前循环</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">continue：结束当前循环，开始下一轮循环</span></span></strong></li>
</ul>
<p><span style="color:#e6b223"><strong><span style="background-color:#fff5e6">2.条件语句（3个）</span></strong></span></p> 
<ul>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">if：条件语句</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">else：条件语句否定分支</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">goto：无条件跳转语句</span></span></strong></li>
</ul>
<p><span style="color:#e6b223"><strong><span style="background-color:#fff5e6">3.开关语句（3个）</span></strong></span></p> 
<ul>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">switch：用于开关语句</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">case：开关语句分支</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">default：开关语句中的"其他"分支</span></span></strong></li>
</ul>
<p><span style="color:#e6b223"><strong><span style="background-color:#fff5e6">4.返回语句（1个）</span></strong></span></p> 
<ul><li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">return：函数返回语句（可以带参数，也可以不带参数）</span></span></strong></li></ul>
<p><span style="color:#e6b223"><strong><span style="background-color:#fff5e6">5.存储类型关键字（5个）</span></strong></span></p> 
<ul>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">auto：声明自动变量，一般不使用</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">extern：声明变量实在其他文件中声明</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">register：声明寄存器变量</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">static：声明静态变量</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">typedef：用以给数据类型取别名（但是该关键字被分到存储关键字分类中，虽然看起来没什么相关性）</span></span></strong></li>
</ul>
<p><span style="color:#fe2c24"><strong><span style="background-color:#fff5e6">注意：存储关键字，不可以同时出现，也就是说，在一个变量定义的时候，只能有一个。</span></strong></span></p> 
<p><span style="color:#e6b223"><strong><span style="background-color:#fff5e6">6.其它关键字（3个）</span></strong></span></p> 
<ul>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">const：声明只读变量</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">sizeof：计算数据类型长度</span></span></strong></li>
<li><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">volatile：说明变量在程序执行中可被隐含地改变</span></span></strong></li>
</ul>
<hr>
<p></p> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">这里anduin带大家有选择性的，讲解几个关键字，若没有讲到日后我们一一讲解：</span></strong></p> 
</blockquote> 
<h2 id="auto"><span style="color:#0d0016"><span style="background-color:#fff5e6">auto</span></span></h2> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">auto 从字面意思来看就是自动的意思 它也被成为</span></strong><span style="color:#fe2c24"><strong><span style="background-color:#fff5e6">自动变量</span></strong></span></p> 
 <p><strong><span style="background-color:#fff5e6">局部变量都是</span></strong><span style="color:#fe2c24"><strong><span style="background-color:#fff5e6">自动创建</span></strong></span><strong><span style="background-color:#fff5e6">，</span></strong><span style="color:#fe2c24"><strong><span style="background-color:#fff5e6">自动销毁</span></strong></span><strong><span style="background-color:#fff5e6">的，所以局部变量都是auto修饰的。</span></strong></p> 
</blockquote> 
<pre><code>int main()
{
    auto int a = 10;//局部变量都是auto类型的，因此auto基本会被省略
    return 0;
}</code></pre> 
<hr>
<h2 id="typedef"><span style="color:#0d0016"><span style="background-color:#fff5e6">typedef</span></span></h2> 
<h3 id="%E6%9C%AC%E8%B4%A8"><span style="color:#0d0016"><span style="background-color:#fff5e6">本质</span></span></h3> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">本质：类型重命名</span></strong></p> 
</blockquote> 
<hr>
<h3 id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">使用方法</span></strong></span></h3> 
<pre><code>#include&lt;stdio.h&gt;
typedef unsignde int u_int;
int main()
{
    u_int x = 0; 
    return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#ad720d"><span style="background-color:#fff5e6"><strong>分析:当我们在写代码时，一些代码类型很长，例如无符号整型unsigned int或者结构体，指针等，这时我们就可以用typedef对它进行类型重命名，本段代码中就是用了typedef来重命名unsigned int为u_int。</strong></span></span></p> 
</blockquote> 
<hr>
<h3 id="%E4%BD%9C%E7%94%A8"><span style="color:#0d0016"><span style="background-color:#fff5e6"><strong>作用</strong></span></span></h3> 
<blockquote> 
 <p><strong><span style="color:#ad720d"><span style="background-color:#fff5e6">对类型重命名的一种解决方案，让我们在面临冗长的类型命名方面上更加简便，可以对一些不太好理解的数据类型进行简化。</span></span></strong></p> 
</blockquote> 
<hr>
<h2 id="register"><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">register</span></strong></span></h2> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">我们先想想，数据在计算机上可以存放在哪里呢？</span></strong></p> 
 <p><strong><span style="background-color:#fff5e6">1.内存</span></strong></p> 
 <p><strong><span style="background-color:#fff5e6">2.硬盘</span></strong></p> 
 <p><strong><span style="background-color:#fff5e6">3.高速缓存</span></strong></p> 
 <p><strong><span style="background-color:#fff5e6">4.寄存器</span></strong></p> 
</blockquote> 
<hr>
<h3 id="%E5%AD%98%E5%82%A8%E9%87%91%E5%AD%97%E5%A1%94"><span style="color:#0d0016"><span style="background-color:#fff5e6">存储金字塔</span></span></h3> 
<p class="img-center"><img alt="" height="443" src="https://images2.imgbox.com/38/7e/Z4cp1uAe_o.png" width="650"></p> 
<hr>
<h3 id="%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">寄存器存在的本质</span></strong></span></h3> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">从硬件层面上，提高计算机的运算效率。当读取数据时，计算器先去寄存器中读取，如果没有读取到，再去高速缓存区中读取，最后才是内存，而且在cpu再读取寄存器中的数据时，内存-&gt;高数缓存区（cache），cache-&gt;寄存器，这个数据传递过程会持续进行，大大提高效率！</span></strong></p> 
</blockquote> 
<hr>
<h3 id="register%C2%A0%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span style="color:#0d0016"><span style="background-color:#fff5e6">register 修饰变量</span></span></h3> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">也就是相同的原理，尽量把所修饰变量，放入CPU寄存区中，从而达到提高效率的目的。</span></strong></p> 
</blockquote> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    register int a = 10;
    return 0;
}</code></pre> 
<hr>
<p><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">register 修饰什么变量</span></strong></span></p> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">register可不是什么变量都适合修饰的，要知道寄存器的价格是很昂贵的，register所修饰的变量也得"精挑细选"一番。</span></strong></p> 
</blockquote> 
<ol>
<li><span style="color:#ad720d"><strong><span style="background-color:#fff5e6">局部变量（全局变量由于其特性会导致CPU寄存器被长时间占用）</span></strong></span></li>
<li><span style="color:#ad720d"><strong><span style="background-color:#fff5e6">不会被写入的（写入就需要写回内存，register本身就是快速读取，后续还要读取检测的话，就与原目的背道而驰了）</span></strong></span></li>
<li><span style="color:#ad720d"><strong><span style="background-color:#fff5e6">高频被读取的变量（俗话说把钱用在刀刃上，存入了寄存器，当然要经常使用的）</span></strong></span></li>
<li><span style="color:#ad720d"><strong><span style="background-color:#fff5e6">如果要使用，不要大量使用，寄存器的数量是有限的！</span></strong></span></li>
</ol>
<hr>
<h3><span style="color:#0d0016"><span style="background-color:#fff5e6">小科普</span></span></h3> 
<blockquote> 
 <p><strong><span style="color:#fe2c24"><span style="background-color:#fff5e6">register修饰的变量，不能取地址！！！</span></span></strong></p> 
</blockquote> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    register int a = 0; 
    printf("&amp;a = %pn", &amp;a);
    return 0;
}</code></pre> 
<p><strong><span style="background-color:#fff5e6">编译运行：</span></strong><img alt="" height="22" src="https://images2.imgbox.com/9c/12/gQAoGsuj_o.png" width="879"></p> 
<blockquote> 
 <p><strong><span style="color:#ad720d"><span style="background-color:#fff5e6"> 分析：因为register的作用，变量a已经被放入寄存器中了，你怎么取地址呢？</span></span></strong></p> 
</blockquote> 
<hr>
<h1 id="%E7%BB%93%E8%AF%AD"><span style="color:#0d0016"><strong><span style="background-color:#fff5e6">结语</span></strong></span></h1> 
<blockquote> 
 <p><strong><span style="background-color:#fff5e6">以上就是初识C语言中篇的内容，虽然只有两个专题，但是内容其实也是很多的，希望我的文章对你有帮助，如果大家觉得anduin写的还可以的话，请点赞+收藏哦！你们的肯定就是对我最大的鼓励！</span></strong></p> 
 <p><strong><span style="background-color:#fff5e6">今天也是高考第一天，祝广大学子辛勤奋战在学海,汗水扬起成功帆！</span></strong></p> 
 <p><strong><span style="background-color:#fff5e6">愿大家都可以金榜题名！</span></strong></p> 
 <p class="img-center"><img alt="" height="295" src="https://images2.imgbox.com/8e/9c/7tUB0TGz_o.jpg" width="300"></p> 
 <p></p> 
 <p></p> 
</blockquote>
                </div>

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>