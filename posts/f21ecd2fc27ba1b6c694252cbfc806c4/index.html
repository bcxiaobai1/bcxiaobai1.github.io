<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>力扣周结03 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣周结03</h1>
			
		</header>
		<div class="content post__content clearfix">
			


                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <h2>
<a id="242_httpsleetcodecncomproblemsvalidanagram_1"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a>
</h2> 
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p> 
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
 </p> 
<p><strong>示例 1:</strong></p> 
<pre><code>输入: s = "anagram", t = "nagaram"
输出: true
</code></pre> 
<p><strong>示例 2:</strong></p> 
<pre><code>输入: s = "rat", t = "car"
输出: false
</code></pre> 
<p><strong>提示:</strong></p> 
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>
<li>
<code>s</code> 和 <code>t</code> 仅包含小写字母</li>
</ul> 
<h3>
<a id="_26"></a>解题思路</h3> 
<p>数组是一种最简单的哈希表，因为两个字符串只包含小写字母所以我们可以设置一个长度为26的数组，0-25分别对应a-z出现的次数，最后再遍历一次数组如果出现了不为1的元素就表明两个字符串不是有效的字母异位词</p> 
<h3>
<a id="_30"></a><strong>核心代码</strong>
</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">String</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            result<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            result<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="_52"></a>时间复杂度</h3> 
<p>O(n)</p> 
<h3>
<a id="_56"></a>空间复杂度</h3> 
<p>O(1)</p> 
<h2>
<a id="349_httpsleetcodecncomproblemsintersectionoftwoarrays_60"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a>
</h2> 
<p>给定两个数组，编写一个函数来计算它们的交集。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
</code></pre> 
<p><strong>说明：</strong></p> 
<ul>
<li>输出结果中的每个元素一定是唯一的。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul> 
<h3>
<a id="_83"></a>解题思路</h3> 
<p>这道题是虚假的求交集，即只是求出元素并不要求元素的个数所以我们可以声明两个set集合，然后将两个set集合中包含的元素加入到结果数组中</p> 
<p>也可以使用排序双指针求解这里就不做演示了</p> 
<h3>
<a id="_89"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">intersection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> set0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> item <span class="token operator">:</span> nums1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> item <span class="token operator">:</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
            set0<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>set0<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> item <span class="token operator">:</span> set0<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="_114"></a>时间复杂度</h3> 
<p>O(n)</p> 
<h3>
<a id="_118"></a>空间复杂度</h3> 
<p>O(n)</p> 
<h2>
<a id="350__IIhttpsleetcodecncomproblemsintersectionoftwoarraysii_122"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a>
</h2> 
<p>给定两个数组，编写一个函数来计算它们的交集。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
</code></pre> 
<p><strong>示例 2:</strong></p> 
<pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
</code></pre> 
<p><strong>说明：</strong></p> 
<ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul> 
<h3>
<a id="_145"></a>解题思路</h3> 
<p>真正的求交集，和上一题一样也是两种思路，排序双指针的会简单一些</p> 
<h3>
<a id="_149"></a>核心代码</h3> 
<p>排序双指针</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">intersect</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token comment">//将数组排序        Arrays.sort(nums1);        Arrays.sort(nums2);        //定义双指针分别指向两个数组的头部        int a = 0, b = 0;        //定义结果集        int[] result = new int[Math.min(nums1.length,nums2.length)];        //定义遍历结果集指针        int k = 0;        while(a &lt; nums1.length &amp;&amp; b &lt; nums2.length) {            if(nums1[a] == nums2[b]) { //第一种情况：如果两数相等就将数字加入到结果集中并让两个指针同时移动                result[k++] = nums1[a];                a++;                b++;             } else if(nums1[a] &gt; nums2[b]) { //第二种情况：如果第一个数组的值大于第二个数组那么就让值小的数组的指针前移                b++;            } else { //第三种情况：如果第二个数组的值大于第一个数组那么就让值小的数组的指针前移                a++;            }        }        return Arrays.copyOfRange(result, 0, k);    }}</span>
</code></pre> 
<p><strong>时间复杂度</strong></p> 
<p>O(n)<br> <strong>空间复杂度</strong></p> 
<p>O(n)</p> 
<p>两个map模拟并集</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">intersect</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token comment">//存储第一数组的元素和个数的key和value        HashMap&lt;Integer,Integer&gt; map0 = new HashMap&lt;&gt;();        //存储第二个数组的元素和个数的key和value        HashMap&lt;Integer,Integer&gt; map1 = new HashMap&lt;&gt;();        //存储并集        HashMap&lt;Integer,Integer&gt; temp = new HashMap&lt;&gt;();        //将第一数组的元素和对应的元素存储到map中        for(int i = 0; i &lt; nums1.length; i++) {            if(map0.containsKey(nums1[i])) {                map0.replace(nums1[i], map0.get(nums1[i]) + 1);            } else {                map0.put(nums1[i], 1);            }        }        //将第二数组的元素和对应的元素存储到map中        for(int j = 0; j &lt; nums2.length; j++) {            if(map1.containsKey(nums2[j])) {                map1.replace(nums2[j], map1.get(nums2[j]) + 1);            } else {                map1.put(nums2[j], 1);            }        }        //模拟并集的过程，将两个数组的相同元素作为key并将元素个数的最小值作为value存储到result结集合中        for(int index : map0.keySet()) {            if(map1.containsKey(index)) {                temp.put(index,Math.min(map0.get(index), map1.get(index)));            }        }        //定义数组长度        int length = 0;        //将并集的长度求出来        //具体做法为将result集合中所有的value求和        for(int index : temp.values()) {            length += index;        }        //定义返回数组        int[] result = new int[length];         /**         * k 用来遍历数组         * e 限制每个key的value循环         */        int k = 0, e = 0;        for(int index : temp.keySet()) {            e = 0;            while(e &lt; temp.get(index)) {                result[k++] = index;                e++;            }        }        return result;    }}</span>
</code></pre> 
<p><strong>时间复杂度</strong></p> 
<p>O(n)</p> 
<p><strong>空间复杂度</strong></p> 
<p>O(n)</p> 
<h2>
<a id="202_httpsleetcodecncomproblemshappynumber_178"></a><a href="https://leetcode-cn.com/problems/happy-number/">202. 快乐数</a>
</h2> 
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p> 
<p>「快乐数」定义为：</p> 
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li>
<li>如果 可以变为 1，那么这个数就是快乐数。</li>
</ul> 
<p>如果 <code>n</code> 是快乐数就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：n = 19输出：true解释：12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：n = 2输出：false
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul> 
<h3>
<a id="_206"></a>解题思路</h3> 
<p>将数通过%10分离个位数再通过/10移除个位数并让其他位数顺位减一，将分离完的个位数依次平方求和然后储存到set集合中，循环这个过程，如果平方和和set中的元素重复那么这个数就不是快乐数</p> 
<h3>
<a id="_210"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token comment">//定义哈希set存储每次sum的值如果添加sum的时候sum重复了那就返回false        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();        int sum = n;        //如果sum不为1        while(sum != 1) {            if(set.contains(sum)){                return false;            }else{                set.add(sum);            }            sum = 0;            while(n != 0) {                sum += Math.pow(n % 10, 2);                n /= 10;            }            n = sum;        }        return true;        }}</span>
</code></pre> 
<h3>
<a id="_216"></a>时间复杂度</h3> 
<p><em>O</em>(log<em>n</em>)</p> 
<h3>
<a id="_220"></a>空间复杂度</h3> 
<p><em>O</em>(log<em>n</em>)</p> 
<h2>
<a id="1_httpsleetcodecncomproblemstwosum_224"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a>
</h2> 
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。</p> 
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p> 
<p>你可以按任意顺序返回答案。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums = [3,2,4], target = 6输出：[1,2]
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：nums = [3,3], target = 6输出：[0,1]
</code></pre> 
<p>提示：</p> 
<ul>
<li>2 &lt;= nums.length &lt;= 104</li>
<li>-109 &lt;= nums[i] &lt;= 109</li>
<li>-109 &lt;= target &lt;= 109</li>
<li>只会存在一个有效答案</li>
</ul> 
<h3>
<a id="_257"></a>解题思路</h3> 
<p>这道题求解思路很多，暴力硬A的，二分查找，也可以使用哈希表来求得</p> 
<p>使用目标数字减去数组的值如果map中存在那么就返回这两个值如果map中不存在那么就将这个数组元素和数组下标存入map中</p> 
<h3>
<a id="_263"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>                result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="_269"></a>时间复杂度</h3> 
<p>O(n)</p> 
<h3>
<a id="_273"></a>空间复杂度</h3> 
<p>O(n)</p> 
<h2>
<a id="454__IIhttpsleetcodecncomproblems4sumii_277"></a><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a>
</h2> 
<p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p> 
<ul>
<li>0 &lt;= i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</li>
</ul> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1
</code></pre> 
<p>提示：</p> 
<ul>
<li>n == nums1.length</li>
<li>n == nums2.length</li>
<li>n == nums3.length</li>
<li>n == nums4.length</li>
<li>1 &lt;= n &lt;= 200</li>
<li>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</li>
</ul> 
<h3>
<a id="_305"></a>解题思路</h3> 
<p>因为题解的最后是需要得到能够构成0的个数，所以我们可以将前两个数组的元素之和求出同时统计出现的次数记录到map中，然后再统计剩余元素的和，在map中寻找后两个元素相加求和的相反数如果能找到就记录出现的次数</p> 
<h3>
<a id="_309"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fourSumCount</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums3<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums4<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> temp<span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map        for (int i : nums1) {            for (int j : nums2) {                temp = i + j;                if (map.containsKey(temp)) {                    map.put(temp, map.get(temp) + 1);                } else {                    map.put(temp, 1);                }            }        }        //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数        for (int i : nums3) {               for (int j : nums4) {                temp = i + j;                if (map.containsKey(0 - temp)) {                    res += map.get(0 - temp);                }            }        }        return res;        }}</span>
</code></pre> 
<h3>
<a id="_315"></a>时间复杂度</h3> 
<p>O(n^2)</p> 
<h3>
<a id="_319"></a>空间复杂度</h3> 
<p>O(n)</p> 
<h2>
<a id="383_httpsleetcodecncomproblemsransomnote_323"></a><a href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信</a>
</h2> 
<p>为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。</p> 
<p>给你一个赎金信 (ransomNote) 字符串和一个杂志(magazine)字符串，判断 ransomNote 能不能由 magazines 里面的字符构成。</p> 
<p>如果可以构成，返回 true ；否则返回 false 。</p> 
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：ransomNote = "a", magazine = "b"输出：false
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：ransomNote = "aa", magazine = "ab"输出：false
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：ransomNote = "aa", magazine = "aab"输出：true
</code></pre> 
<p>提示：</p> 
<ul>
<li>1 &lt;= ransomNote.length, magazine.length &lt;= 105</li>
<li>ansomNote 和 magazine 由小写英文字母组成</li>
</ul> 
<h3>
<a id="_356"></a>解题思路</h3> 
<p>因为只需要magazine中的字符在ransomNote中出现的次数一致就可以了，所以我们用数组来记录赎金信中的字母及其个数，然后将杂志中的元素进行比对</p> 
<h3>
<a id="_360"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> ransomNote<span class="token punctuation">,</span> <span class="token class-name">String</span> magazine<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ransomNote<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 遍历赎金信并记录次数            result[ransomNote.charAt(i) - 'a']++;        }        for(int j = 0; j &lt; magazine.length(); j++) { // 将杂志中的字符串和赎金信中的做比对            if(result[magazine.charAt(j) - 'a'] != 0)            result[magazine.charAt(j) - 'a']--;        }        for(int i = 0; i &lt; 26; i++) {            if(result[i] != 0)            return false;        }        return  true;    }}</span>
</code></pre> 
<h3>
<a id="_366"></a>时间复杂度</h3> 
<p>O(n + m)</p> 
<h3>
<a id="_370"></a>空间复杂度</h3> 
<p>O(1)</p> 
<h2>
<a id="15_httpsleetcodecncomproblems3sum_374"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a>
</h2> 
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p> 
<p>注意：答案中不可以包含重复的三元组。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums = []输出：[]
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：nums = [0]输出：[]
</code></pre> 
<h3>
<a id="_398"></a>解题思路</h3> 
<p>排序双指针，首先确认第一个元素，如果第一个元素大于0就没有后续的必要了，因为不可以包含重复的三元组所以还涉及到了去重的操作，再确认好第一个元素之后，剩下两个元素的值也很好确认可以使用双指针来分别指向末尾和第一个元素后一位的元素</p> 
<h3>
<a id="_402"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token comment">//定义结果集LinkedList相比于ArrayList添加和删除效率比较高        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();        //如果数组长度小于3就不需要进行后续操作了直接返回空的结果集即可        if(nums.length &lt; 3) {            return result;        }        //我们采用排序双指针的方法方便去重的操作        Arrays.sort(nums);        for(int i = 0; i &lt; nums.length; i++) {            //因为数组已经排过序了如果第一个值是正数后面就没必要比较了            if(nums[i] &gt; 0)                break;            //如果从数组第二个值开始，当前元素和前一个元素相同那么直接跳过本次循环            if(i &gt; 0 &amp;&amp; nums[i - 1] == nums[i])                continue;            //a &gt; b &gt; c 由于第一个元素的确认我们把他看作常数对待那么 满足函数 a(常数) + b(未知量) = -c(未知量) 形状有点像 y = -x            int left = i + 1;            int right = nums.length - 1;            while(left &lt; right) {                // temp = a + b + c                if(nums[left] + nums[right] == -nums[i]) {                    result.add(new LinkedList&lt;Integer&gt;(Arrays.asList(nums[i], nums[left], nums[right])));                    left++;                    right--;                    //去重操作                    while(left &lt; right &amp;&amp; nums[left] == nums[left - 1])                        left++;                    while(left &lt; right &amp;&amp; nums[right] == nums[right + 1])                        right--;                                  } else if(nums[left] + nums[right] &gt; -nums[i]) {                    right--;                } else if(nums[left] + nums[right] &lt; -nums[i]) {                    left++;                }            }        }        return result;    }}</span>
</code></pre> 
<h3>
<a id="_408"></a>时间复杂度</h3> 
<p>O(n^2)</p> 
<h3>
<a id="_412"></a>空间复杂度</h3> 
<p>O(n)</p> 
<h2>
<a id="18_httpsleetcodecncomproblems4sum_416"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a>
</h2> 
<blockquote> 
 <p>这道题和15题核心思路基本一致</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">fourSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token comment">//创建结果集        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();        if(nums.length &lt; 4) {            return result;        }        //排序双指针        Arrays.sort(nums);        for(int i = 0; i &lt; nums.length - 3; i++) {            //去重            if(i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) {                continue;            }            for(int j = i + 1; j &lt; nums.length - 2; j++) {                //去重                if(j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) {                    continue;                }                int left = j + 1;                int right = nums.length - 1;                int temp = target - nums[i] - nums[j];                while(left &lt; right) {                    int sum = nums[left] + nums[right];                    if(sum == temp) {                        result.add(new LinkedList&lt;Integer&gt;(Arrays.asList(nums[i], nums[j], nums[left], nums[right])));                        left++;                        right--;                        //去重                        while(left &lt; right &amp;&amp; nums[left] == nums[left - 1])                        left++;                        while(left &lt; right &amp;&amp; nums[right] == nums[right + 1])                        right--;                                            } else if(sum &lt; temp) {                        left++;                    } else {                        right--;                    }                }            }        }        return result;    }}</span>
</code></pre> 
<h2>
<a id="232_httpsleetcodecncomproblemsimplementqueueusingstacks_424"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a>
</h2> 
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p> 
<p>实现 MyQueue 类：</p> 
<ul>
<li>void push(int x) 将元素 x 推到队列的末尾</li>
<li>int pop() 从队列的开头移除并返回元素</li>
<li>int peek() 返回队列开头的元素</li>
<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li>
</ul> 
<h3>
<a id="_435"></a>解题思路</h3> 
<p>模拟题仔细就可以了</p> 
<h3>
<a id="_439"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">{<!-- --></span>    <span class="token comment">//定义两个栈    Stack&lt;Integer&gt; stack0 = null;    Stack&lt;Integer&gt; stack1 = null;    //初始化两个栈    public MyQueue() {        stack0 = new Stack&lt;&gt;();        stack1 = new Stack&lt;&gt;();    }    //如果栈1不为空那就先将栈1的元素全部出栈添加到栈0然后向栈0中添加新元素    public void push(int x) {        if(stack1.size() != 0) {            while(stack1.size() != 0) {                stack0.push(stack1.pop());            }        }        stack0.push(x);    }    //如果栈0中包含元素那么就将所有元素出栈并添加到栈1中移除并返回栈1的栈顶元素    public int pop() {        if(stack0.size() != 0) {            while(stack0.size() != 0) {                stack1.push(stack0.pop());            }        }        return stack1.pop();    }    //如果栈0中包含元素那么就将所有元素出栈并添加到栈1中返回栈1的栈顶元素    public int peek() {        if(stack0.size() != 0) {            while(stack0.size() != 0) {                stack1.push(stack0.pop());            }        }        return stack1.peek();    }    //查看栈0和栈1中是否含有元素    public boolean empty() {        return stack1.isEmpty() &amp;&amp; stack0.isEmpty();    }}</span>
</code></pre> 
<h2>
<a id="225_httpsleetcodecncomproblemsimplementstackusingqueues_445"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a>
</h2> 
<h3>
<a id="_447"></a>解题思路</h3> 
<p>模拟题我是使用一个队列实现的</p> 
<h3>
<a id="_451"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">{<!-- --></span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list0 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//初始化队列    public MyStack() {        list0 = new LinkedList&lt;Integer&gt;();    }            public void push(int x) {        list0.add(x);    }        public int pop() {        return list0.remove(list0.size() - 1);    }        public int top() {        return list0.get(list0.size() - 1);    }        public boolean empty() {        return list0.isEmpty();    }}</span>
</code></pre> 
<h2>
<a id="20_httpsleetcodecncomproblemsvalidparentheses_457"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a>
</h2> 
<h3>
<a id="_459"></a>解题思路</h3> 
<p>栈很适合用来做匹配消除，遍历整个字符串，如果栈中元素不为空并且栈顶元素和对应的右括号匹配就弹出栈</p> 
<h3>
<a id="_463"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token comment">//定义一个栈        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for(int i = 0; i &lt; s.length(); i++) {            if(!stack.isEmpty() &amp;&amp; stack.peek() == isType(s.charAt(i))) {                stack.pop();                continue;            }            stack.push(s.charAt(i));        }        return stack.isEmpty();    }    public char isType(char c) {        char flag = '';        if(c == ')') {            flag = '(';        }else if(c == ']') {            flag = '[';        }else if(c == '}') {            flag = '{';        }        return flag;    }}</span>
</code></pre> 
<h3>
<a id="_469"></a>时间复杂度</h3> 
<p>O(n)</p> 
<h3>
<a id="_473"></a>空间复杂度</h3> 
<p>O(n)</p> 
<h2>
<a id="1047_httpsleetcodecncomproblemsremovealladjacentduplicatesinstring_477"></a><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a>
</h2> 
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p> 
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p> 
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p> 
<pre><code>输入："abbaca"输出："ca"解释：例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
</code></pre> 
<h3>
<a id="_489"></a>解题思路</h3> 
<ol>
<li>消除相邻且相同的元素第一种思路用栈来实现</li>
<li>使用Stringbuffer模拟栈</li>
<li>双指针遍历字符串，让快慢指针同速前进，如果遇到需要删除的元素就让慢指针–下次循环直接就覆盖了</li>
</ol> 
<h3>
<a id="_495"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token comment">/** * 第一种思路，用栈来实现 * 依次将字符串的字符入栈如果两两相当，那么就消除 */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> temp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>            temp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果栈为空或者栈顶元素不等于temp就入栈，否则就出栈            if(queue.isEmpty() || queue.peek() != temp) {                queue.push(temp);            } else {                queue.pop();            }        }        // 剩余的元素就是最终字符串,但是由于栈的结构所以得出来的字符串是反的需要换一下        String result = "";        while(!queue.isEmpty()) {            result += queue.pop();        }        result = new StringBuffer(result).reverse().toString();        return result;    }}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">/** * 第二种思路，字符串模拟栈 */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        <span class="token class-name">StringBuffer</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> temp<span class="token punctuation">;</span>        <span class="token comment">// 记录buffer的长度，为什么是-1？        // 之所以是-1是因为第一个元素是默认添加的，它的索引值为0，此时为了能够判断第二次循环条件，        // l模仿指向栈顶        int l = -1;        for(int i = 0; i &lt; s.length(); i++) {            temp = s.charAt(i);            // 如果此时字符串的尾部元素和temp相同那么就把字符串尾部删除,为了添加第一个元素所以需要设置temp &gt;= 0            if(l &gt;= 0 &amp;&amp; temp == buffer.charAt(l)) {                buffer.deleteCharAt(l);                l--;            } else {                buffer.append(temp);                l++;            }        }        return buffer.toString();    }}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 第三种思路，双指针法,直接使用现有字符串使用双指针覆盖重复的元素
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> fast <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> fast<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            c<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果slow指向的元素和slow-1所指向的元素相等那么就让slow指针后移，下次循环直接就覆盖掉了</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>slow <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">==</span> c<span class="token punctuation">[</span>slow <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                slow<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                slow<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="_527"></a>时间复杂度</h3> 
<ol>
<li>O(n)</li>
<li>O(n)</li>
<li>O(n)</li>
</ol> 
<h3>
<a id="_533"></a>空间复杂度</h3> 
<ol>
<li>O(n)</li>
<li>O(n)</li>
<li>O(1)</li>
</ol> 
<h2>
<a id="150_httpsleetcodecncomproblemsevaluatereversepolishnotation_539"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a>
</h2> 
<p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求表达式的值。</p> 
<p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p> 
<p><strong>说明：</strong></p> 
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
</code></pre> 
<h3>
<a id="_566"></a>解题思路</h3> 
<p>求解逆波兰表达式，如果是数字直接入栈，如果是操作符，从栈中取出两个元素进行操作后再压入栈</p> 
<h3>
<a id="_570"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//定义一个栈便于存储运算数字</span>
        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//因为遍历到+ - * /需要出栈两个字符计算后入栈所以设置两个变量</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tokens<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                a <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                b <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                a <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                b <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                a <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                b <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b <span class="token operator">*</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                a <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                b <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b <span class="token operator">/</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="_606"></a>时间复杂度</h3> 
<p>O(n)</p> 
<h3>
<a id="_610"></a>空间复杂度</h3> 
<p>O(n)</p> 
<h2>
<a id="347__K_httpsleetcodecncomproblemstopkfrequentelements_614"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a>
</h2> 
<h3>
<a id="_616"></a>解题思路</h3> 
<p>需要统计前k个高频元素，既需要统计元素出现的个数而且需要按照出现的个数进行排序，我们可以使用优先级队列维护一个小根堆，按照出现次数对元素进行升序排序，如果队列长度大于k就将队头元素弹出，最后优先级队列剩余的即是前k个元素</p> 
<h3>
<a id="_620"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//定义结果集</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//记录nums中不同元素出现的个数</span>
        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> temp <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//使用Map.Entry方法将map存入set中</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//使用优先队列将map存入，小根堆！！</span>
        <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> o1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//将set中的元素存入</span>
            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//如果队列长度大于k就弹出</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3>
<a id="_652"></a>时间复杂度</h3> 
<p>O(nlogk)</p> 
<h3>
<a id="_656"></a>空间复杂度</h3> 
<p>O(n)</p> 
<h2>
<a id="239_httpsleetcodecncomproblemsslidingwindowmaximum_660"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a>
</h2> 
<h3>
<a id="_661"></a>核心代码</h3> 
<pre><code class="prism language-java"><span class="token comment">/**
单调队列真是一种让人感到五味杂陈的数据结构，它的维护过程更是如此.....就拿此题来说，队头最大，往队尾方向单调......有机会站在队头的老大永远心狠手辣，当它从队尾杀进去的时候，如果它发现这里面没一个够自己打的，它会毫无人性地屠城，把原先队里的人头全部丢出去，转身建立起自己的政权，野心勃勃地准备开创一个新的王朝.....这时候，它的人格竟发生了一百八十度大反转，它变成了一位胸怀宽广的慈父！它热情地请那些新来的“小个子”们入住自己的王国......然而，这些小个子似乎天性都是一样的——嫉妒心强，倘若见到比自己还小的居然更早入住王国，它们会心狠手辣地找一个夜晚把它们通通干掉，好让自己享受更大的“蛋糕”；当然，遇到比自己强大的，它们也没辙，乖乖夹起尾巴做人。像这样的暗杀事件每天都在上演，虽然王国里日益笼罩上白色恐怖，但是好在没有后来者强大到足以干翻国王，江山还算能稳住。直到有一天，闯进来了一位真正厉害的角色，就像当年打江山的国王一样，手段狠辣，野心膨胀，于是又是大屠城......历史总是轮回的。
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//定义结果集</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//定义指针遍历结果集</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//定义双端队列手动实现单调栈(单调递增)</span>
        <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//队头元素始终在窗口中如果不在窗口中就弹出 i - k + 1即根据右窗口得到左窗口</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> deque<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                deque<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//队尾元素小于右窗口就将元素弹出</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>deque<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//存下标</span>
            deque<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//当数组下标大于等于窗口大小-1的时候代表已经到达窗口最大值</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                result<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>deque<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>