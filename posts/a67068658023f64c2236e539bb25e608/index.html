<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>计算机二级C语言知识点 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机二级C语言知识点</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-light">
                    
                        
                    
                    <p>干货干货，全是知识点?（计算机二级C语言已过）<br> 前言：推荐买一本未来教育的书，有之前的试题，还会有软件，可以直接在电脑上刷题，模拟考试，进行刷题，计算机二级C语言会从这些试题中随机抽，然后一般会有三套左右的新题，坚持刷题，考的都挺基础的，选择题40个一分一个，主要是后面三道大题，程序填空18分，程序改错18分以及写代码24分（写的简单的代码，不过要运行成功才会有分）</p> 
<h2>
<a id="_2"></a>计算机二级知识点</h2> 
<h4>
<a id="_3"></a>数据结构</h4> 
<h6>
<a id="_5"></a>树与二叉树</h6> 
<ol>
<li> <p>满二叉树是指除最后一层外，每一层上的所有结点都有两个子结点的二叉树。<strong>深度为n的满二叉树的结点个数为2<sup>n</sup>个，第n层的结点数为2<sup>n-1</sup>个。</strong></p> </li>
<li> <p>二叉树中只有满二叉树与<strong>完全二叉树</strong>可以按层次进行<strong>顺序</strong>存储，<u>满二叉树也是完全二叉树</u>，而非完全二叉树不能采用顺序存储结构。</p> </li>
<li> <p>多重链表：结点中具有多个指针域的链表（双向链表有两个指针域，属于线性结构）</p> </li>
<li> <p>排序二叉树：设非空二叉树的所有子树中，其左子树上的结点值均小于根节点值，而右子树上的结点值均不小于根节点值，则称该二叉树为排序二叉树。（对于排序序列进行<strong>中序遍历</strong>，遍历的结果为<strong>有序</strong>序列）</p> </li>
<li> <p>堆的概念：若有n个元素的序列，将元素按顺序组成一棵完全二叉树，当且仅当满足条件：根结点值大于等于右子树的结点值 或 根结点值小于等于左子树的结点值且小于等于右子树的结点值时称为堆</p> <p>而堆的左子树的结点值与右子树的结点值大小无值法确定，所以无法判断堆进行中序遍历是否为有序序列</p> </li>
<li> <p><strong>对于任何一棵二叉树，度为0的结点（即叶子结点）总是比度为2的结点多一个</strong></p> </li>
<li> <p>若二叉树的前序遍历与中序遍历序列相同，则二叉树中任意一个结点均不存在左子树；若二叉树的后序遍历与中序遍历相同，则二叉树中任意一个结点均不存在右子树。若二叉树具有n个结点，则该二叉树的深度为n</p> </li>
<li> <p><strong>树的总结点数为：度为3的结点数+度为2的结点数+度为1的结点数+度为0的结点数</strong></p> <p><strong>树的总结点数为：树中所有结点的度数之和再+1</strong></p> </li>
</ol> 
<h6>
<a id="_27"></a>查找与排序</h6> 
<ol>
<li> <p><strong>长度为n的线性表进行 快速排序 或 简单插入排序 或 冒泡排序，最坏情况下需要比较的次数为n(n-1)/2</strong></p> </li>
<li> <p>逆序：在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序</p> </li>
<li> <p>快速排序的思想：从线性表中取一个元素，设为T，将线性表中后面小于T的元素移到前面，而前面大于T的元素移到后面，结果就是将线性表分成两部分（称两个子表），T插入到其分割线的位置处，这个过程称为线性表的分割，然后再用同样的方法对分割处的子表再进行同样的分割。</p> <p>快速排序不是对两个相邻元素进行比较，可以实现通过一次交换而消除多个逆序，但由于均与T（基准元素）比较，也可能会产生新的逆序。</p> </li>
<li> <p>对于长度为n的有序线性表，在最坏情况下，二分查找需要比较log <sub>2 </sub><sup>n</sup>。</p> </li>
<li> <p><strong>最坏情况下比较次数：有序表的二分查找为log<sub>2</sub><sup>n</sup>,堆排序为nlog<sub>2</sub><sup>n</sup>，顺序查找为n，寻找最大项或寻找最小项为n-1，希尔排序比较次数为nr(1&lt;r&lt;2)。</strong></p> </li>
<li> <p>希尔排序的基本思想：先取整数（称为增量）d1&lt;n，把全部数据元素分成d1组，所有距离为d1倍数的元素放在一组中，组成了一个子序列，对每个子序列分别进行简单插入排序，然后去d2&lt;d1重复上述分组和排序工作，直到di=1，即所有记录在一组中为止。</p> <p>希尔排序可以实现通过一次交换而消除多个逆序。</p> </li>
<li> <p>能使用二分查找（对分查找）的线性表必须满足两个条件：①用顺序存储结构；②线性表是有序表。</p> </li>
</ol> 
<h4>
<a id="_47"></a>软件工程基础</h4> 
<h6>
<a id="_49"></a>程序的调试</h6> 
<ol>
<li>程序调试的任务是诊断和改正程序中的错误</li>
<li>软件测试是尽可能多地发现软件中的错误</li>
<li>软件测试贯穿整个软件生命周期，需要考虑测试成本，程序调试主要在开发阶段，因为调试是在测试发现错误之后改正错误的过程</li>
</ol> 
<h6>
<a id="_55"></a>软件的测试</h6> 
<ol>
<li> <p>黑盒测试又称功能测试或数据驱动测试，着重测试软件功能。黑盒测试依据需求规格说明书的功能描述</p> </li>
<li> <p>白盒测试根据程序的内部逻辑来设计测试用例，检查程序中的逻辑通路是否都按预定的要求正确地工作</p> </li>
<li> <p><strong>黑盒测试方法和技术：等价类划分法、边界值分析法、错误推测法和因果图等</strong></p> </li>
<li> <p><strong>白盒测试的主要技术：逻辑覆盖测试（它包括：路径覆盖、判定覆盖、语句覆盖、条件覆盖、判定—条件覆盖）、基本路径测试</strong></p> </li>
<li> <p>软件测试的实施过程：单元测试、集成测试、确认测试（验收测试）和系统测试</p> </li>
<li> <p>测试用例（Test Case）是为测试设计的数据，由输入数据和与之对应的预期输出结果两部分组成</p> </li>
<li> <p>单元测试也称模块测试，模块是软件设计的最小单位，而单元测试是对模块进行正确性的检验，以期尽早发现各模块内部可能存在的各种错误，通常在编码阶段进行</p> </li>
<li> <p><strong>静态测试不实际运行软件，主要通过人工进行分析</strong></p> <p><strong>动态测试就是通过所说的上机测试，通过运行软件来检验软件中的动态行为和运行结果的正确性</strong></p> </li>
<li> <p>软件测试的基本准则：所有测试都应追溯到需求、严格执行测试计划，排序测试的随意性、充分注意测试中的群集现象、程序员应避免检查自己的程序、穷举测试不可能、妥善保存测试计划等文件</p> </li>
<li> <p>确认测试的任务是检查软件的功能、性能以及其他特征是否与用户的需求一致，它是以需求规格说明书作为依据的测试</p> </li>
<li> <p>集成测试也称组装测试，它是对各模块按照设计要求组装成的程序进行测试，主要目的是发现与接口有关的错误。集成测试主要发现设计阶段产生的错误，集成测试的依据是概要设计说明书</p> </li>
<li> <p>单元测试可以采用静态测试或动态测试。动态测试通常以白盒测试法为主，测试其结构；以黑盒测试法为辅，测试其功能</p> </li>
<li> <p>单元测试主要针对模块的5个基本特征进行：模块接口测试、局部数据结构测试，重要的执行路径的检查、出错测试、影响以上各点以及其他相关的边界条件测试</p> </li>
<li> <p>集成测试的方式可以分为非增量方式和增量方式两种。①非增量方式是先分别测试每个模块，再把所有模块按设计要求组装一起进行整体测试，因此非增量方式又称<u>一次性组装方式</u>。②增量方式是吧要测试的模块同已经测试好的那些模块连接起来进行测试，测试完以后再把下一个应测试的模块连接进来测试。<strong>增量方式包括自顶向下、自底向上以及自顶向上和自底向上相结合的混合增量方法</strong></p> </li>
</ol> 
<h6>
<a id="_87"></a>结构化设计方法</h6> 
<ol>
<li> <p>没有从属结点的模块是原子模块。扇入指调用一个给定模块的模块个数。结构图是描述软件系统结构的图形工具</p> </li>
<li> <p><strong>软件设计常用的工具：系统结构图、程序流程图、N-S图、PAD图、HIPO图、判定表、PDL&lt;DFP图即数据流程图，是需求分析时使用的工具&gt;</strong></p> </li>
<li> <p>详细设计的任务是为软件结构图中的每一个模块确定实现算法和局部数据结构，用某种选定的表达工具表示算法和数据结构的细节</p> </li>
<li> <p>在流程图中，构成程序流程图的最基本图符及含义：方框表示一个加工步骤；菱形表示一个逻辑条件；箭头表示控制流</p> </li>
<li> <p><strong>耦合用于衡量不同模块彼此间相互依赖（连接）的紧密程度；</strong></p> <p><strong>内聚用于衡量一个模块内部各元素彼此结合的紧密程度</strong></p> </li>
<li> <p>软件设计中模块划分时应每个模块完成一个相对独立的特定子功能，并且和其他模块之间的关系很简单，即高内聚低耦合</p> </li>
<li> <p>概要设计任务为：①设计软件系统结构；②数据结构及数据库设计；③编写概要设计文档；④概要设计问道评审</p> </li>
<li> <p>模块独立性的概念是抽象、模块化、信息隐蔽和局部化的直接结果</p> </li>
<li> <p>软件设计阶段从工程管理角度分为概要设计和详细设计两个阶段：</p> <p>①概要设计（又称结构设计）将软件需求转化为软件体系结构、确定系统级接口、全局数据结构或数据库模式</p> <p>②详细设计确立每个模块的实现算法和局部数据结构，用适当方法表示算法和数据结构的细节</p> <p>从技术观点来看，软件设计包括软件总体结构设计、数据设计、接口设计、过程设计4个步骤</p> </li>
<li> <p>软件设计准则：①提高模块独立性；②模块规模应该适中；③深度、宽度、扇入和扇出都应适当；④模块的作用域应该在控制域之内；⑤降低模块之间接口的复杂程度；⑥设计单入口和单出口的模块，不要使模块间出现内容耦合；⑦模块功能应该可以预测</p> </li>
<li> <p>软件系统总体结构图是描述软件系统结构的图形工具，描述软件系统的层次和分块结构关系，它反映了整个系统功能实现以及模块与模块之间的联系和通信，是未来程序中的控制层次体系</p> </li>
</ol> 
<h6>
<a id="_119"></a>结构化分析方法</h6> 
<ol>
<li> <p>需求分析阶段的工作可以分为4个方面：需求获取、需求分析、需求规格说明书编写和需求评审</p> </li>
<li> <p>需求分析的任务是发现需求、求精、建模和定义需求的过程，确定软件系统的功能</p> </li>
<li> <p>数据流图（DFD）的作用是支持软件系统功能建模。因为数据流图是系统逻辑模型的图形表示，从数据传递和加工的角度，来刻画数据流从输入到输出的移动变化过程，它直接支持系统的功能建模</p> </li>
<li> <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RBm2jOao-1649582728450)(D:photo数据流图.png)]</p> </li>
<li> <p>数据流图应该遵循一下构造规则和注意事项：①对加工处理建立唯一、层次性的编号，且每个加工处理通常要求既有输入又有输出。②数据存储之间不应该有数据流。③数据流图的一致性。即输入输出、读写的对应。④父图、子图关系与平衡规则。相邻两层DFD之间具有父子关系，子图代表了父图中某个加式的详细描述，父图表示了子图间的接口。子图个数不大于父图的处理个数。所有子图的输入输出数据流和父图中处理的对应输入输出数据流必须一致</p> </li>
<li> <p>数据流图是描述数据处理过程的工具，是需求理解的逻辑模型的图形表示，它直接支持系统的功能建模。</p> <p>从数据传递和加工的角度，来刻画数据流从输入到输出的移动变化过程。系统的数据建模是系统设计阶段的工作</p> </li>
<li> <p>软件需求规格说明书是需求分析阶段的最后成果，是软件开发过程中的重要文档之一。软件需求规格说明书有以下几个方面的作用：①便于用户、开发人员进行理解和交流；②反映出用户问题的结构，可以作为软件开发工作的基础和依据；③作为确认测试和验收的依据；④为成本估算和编制计划进度提供基础；⑤软件不断改进的基础。</p> </li>
</ol> 
<h6>
<a id="_137"></a>软件工程基本概念</h6> 
<ol>
<li> <p>软件生命周期可以分为定义阶段、开发阶段和维护阶段。</p> 
  <ul>
<li> <p>定义阶段包括问题定义、可行性研究和需求分析。</p> </li>
<li> <p>开发阶段包括概要设计、详细设计、实现和测试。</p> </li>
<li> <p>维护阶段包括使用和维护。</p> </li>
</ul> </li>
<li> <p>软件过程是把输入转化为输出的一组彼此相关的资源和活动。软件过程是将软件工程的方法和工具综合起来，以达到合理、及时地进行计算机软件开发的目的。软件过程应该确定方法使用的顺序、要求交付的文档资料、为保证质量和适应变化所需要的管理、软件开发各个阶段完成的任务</p> </li>
<li> <p>计算机软件是由程序、数据及相关文档构成的完整集合，它与计算机硬件一起组成计算机系统</p> </li>
<li> <p>软件工程包含方法、工具、和过程3个要素</p> 
  <ul>
<li>方法是完成软件开发各项任务的技术手段</li>
<li>工具支持软件的开发、管理、文档生成</li>
<li>过程支持软件开发的各个环节的控制、管理</li>
</ul> </li>
<li> <p>软件工程概念的出现源自软件危机，是为了解决软件危机的问题</p> <p>而软件危机主要表现：</p> 
  <ul>
<li>软件开发进度难以预测</li>
<li>软件开发成本难以控制</li>
<li>用户对产品功能难以满足</li>
<li>软件产品质量无法保证</li>
<li>软件产品难以维护</li>
<li>软件缺少适当的文档资料</li>
</ul> </li>
<li> <p>软件的特点：</p> 
  <ul>
<li>软件是一种逻辑实体，具有抽象性；</li>
<li>软件没有明显的制作过程；</li>
<li>软件在使用期间不存在磨损、老化问题；</li>
<li>软件对硬件和环境具有依赖性；</li>
<li>软件复杂性高，成本昂贵；</li>
<li>软件开发涉及诸多的社会因素</li>
</ul> </li>
<li> <p>通常包软件产品从提出、实现、使用、维护到停止、退役的过程称为软件生命周期</p> </li>
<li> <p>系统软件是管理计算机的资源，提高计算机的使用效率，为用户提供各种服务的软件，如操作系统、数据库管理系统、编译程序、汇编程序和网络软件等。应用软件是为了应用于特定的领域而开发的软件。</p> </li>
<li> <p><strong><u>软件设计</u>通常分为概要设计和详细设计两个阶段，会给出软件结构、模块的划分、功能的分配以及处理流程，是确定软件系统<u>“怎么做”</u>的阶段</strong></p> </li>
<li> <p><strong><u>需求分析</u>对待开发软件提出的需求进行分析并给出详细定义，是确定软件系统要<u>”做什么“</u>的阶段</strong></p> </li>
</ol> 
<h4>
<a id="_185"></a>数据库设计基础</h4> 
<h6>
<a id="_187"></a>数据库系统的基本概念</h6> 
<ol>
<li> <p>数据库管理系统的主要功能包括：①数据模式定义；②数据存取的物理构建；③数据操纵；④数据完整性，安全性的定义与检查；⑤数据库的并发控制与故障恢复；⑥数据的服务</p> </li>
<li> <p>概念模式（也称为模式）：是数据库系统中全局数据逻辑结构的描述，全体用户的公共数据视图</p> </li>
<li> <p>外模式（也称子模式或用户模式）：是用户的数据视图，也就是用户所能够看见和使用的局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示</p> </li>
<li> <p>内模式（又称物理模式）：是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式</p> </li>
<li> <p>将数据库的结构划分多个层次，是为了提高数据库的数据独立性。数据独立性包括数据的物理独立性和数据逻辑独立性两级</p> </li>
<li> <p>数据定义功能：数据的模式定义与数据的物理存取构建</p> <p>数据操纵功能：数据的操纵包括查询与增、删、改等操作</p> <p>数据控制功能：数据完整性、安全性的定义与检查以及并发控制、故障恢复等功能</p> </li>
<li> <p>数据库（DB）是指长期存储在计算机内的，有组织的，可共享的数据集合</p> </li>
<li> <p>数据独立性包括数据的物理独立性和数据的逻辑独立性。</p> 
  <ul>
<li> <p>数据的物理独立性是指数据的物理结构的改变，包括存储结构的改变，存储设备的更换，存取方式的改变不会影响数据库的逻辑结构，也不会引起应用程序的改动</p> </li>
<li> <p>数据的逻辑结构独立性是指数据库的总体逻辑结构的改变，如改变数据模式，增加新的数据结构，修改数据间的联系等，不会导致相应的应用程序的改变</p> </li>
</ul> </li>
<li> <p>数据库的数据独立性是通过数据库系统的二级映射实现的</p> </li>
<li> <p>数据库具有三级模式：概念模式、外模式、内模式</p> </li>
<li> <p>数据库系统的基本特点：数据集成性、数据的共享性高，冗余性低（减少冗余，并不是避免一切的冗余）、数据独立性高、数据统一管理与控制</p> </li>
<li> <p>数据管理的三个阶段：人工管理阶段、文件系统阶段和数据库系统阶段</p> </li>
<li> <p>数据库系统在三级模式之间提供了两级映射：外模式/概念模式的映射和概念模式/内模式的映射</p> </li>
<li> <p>一个数据库可以有多个外模式（因为用户可以有多个），但概念模式和内模式只能有一个</p> </li>
<li> <p>用户对应外模式，概念级对应概念模式，存储级对应内模式，使不同级别的用户对数据库形成不同的视图</p> </li>
<li> <p>数据库系统由数据库管理系统、数据库管理员、硬件平台和软件平台组成，这五个部分构成了一个以数据库为核心的完整的运行实体，称为数据库系统</p> </li>
</ol> 
<h6>
<a id="_230"></a>数据模型</h6> 
<ol>
<li> <p>在实体联系模型中，实体是客观存在并且可以相互区别的事物</p> </li>
<li> <p>关系模式采用二维表来表示关系，简称表</p> </li>
<li> <p>概念数据模型，简称概念模型，它是一种面向客观世界、面向用户的模型，它与具体的数据库管理系统和具体的计算机平台无关。<strong>概念模型着重于对客观世界复杂事物的描述及对它们内在联系的刻画</strong></p> </li>
<li> <p>数据模型通常由数据结构、数据操作及数据约束3部分组成。完整性规则属于数据约束</p> </li>
<li> <p>概念设计最常用的方法就是实体-联系方法，简称E-R方法</p> </li>
<li> <p>用树形结构表示实体及其之间联系的模型称为层次模型。用网状结构表示实体及其之间联系的模型称为网状模型。关系模型采用二维表来表示关系</p> </li>
<li> <p>在关系模式中凡能唯一标识元组的最小属性集称为该关系的键或码。关系模式中可能有若干个键，它们称为该表的候选码或候选键。关系模式中不能没有候选键</p> </li>
<li> <p>按照传统的数据模型分类，数据模型为层次模型、网状模型、关系模型</p> </li>
<li> <p>关系数据库中的二维表一般满足7个基本特征：</p> <p>①元组（行）个数是有限的——元组个数有限性</p> <p>②元组（行）均不相同——元组的唯一性</p> <p>③元组（行）的次序可以任意交换——元组的次序无关性</p> <p>④元组（行）的分量是不可分割的基本特征——元组分量的原子性</p> <p>⑤属性（列）名各不相同——属性名唯一性</p> <p>⑥属性（列）与次序无关，可以任意交换——属性的次序无关性</p> <p>⑦属性（列）的分量具有与该属性相同的值域——分量值域的统一性</p> </li>
<li> <p>数据模型按照不同的应用层次分为三种类型：概念数据模型（概念模型）、逻辑数据模型（逻辑模型）、物理数据模型（物理模型）</p> </li>
<li> <p>逻辑数据模型，也称数据模型，是面向数据库系统的模型，着重于在数据库系统一级的实现。成熟并大量使用的逻辑模型有层次模型、网状模型、关系模型和面向对象模型</p> </li>
<li> <p>物理数据模型，也称为物理模型，是面向计算机物理表示的模型，此模型给出了数据模型在计算机上物理结构的表示</p> </li>
<li> <p>关系模型允许定义三类约束：实体完整性约束、参照完整性约束、用户定义的完整性约束。参照完整性约束：若属性（或属性组）E是关系M的外键，它与关系N的主键相对应，则对于关系M中的每个元组在A上的值必须：①要么取空值（A的每个属性值均为空值）②要么等于关系N中某个元组的主键值。</p> </li>
<li> <p>数据模型的三要素：数据结构、数据操作、数据约束</p> </li>
</ol> 
<h6>
<a id="_274"></a>关系代数</h6> 
<ol>
<li> <p>数据库管理系统中关系代数的运算有：投影运算、选择运算、笛卡尔积、交、连接等</p> </li>
<li> <p>自然连接要求两个关系中进行比较的是相同的属性，并且进行等值连接，在结果中还要把重复的属性列去掉</p> </li>
<li> <p>设关系R除以关系S的结果为关系T，则T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中</p> </li>
<li> <p>满足最低要求的叫第一范式，简称1NF。在满足第一范式的基础上，进一步满足更多要求规范则是第二范式。然后再满足第三范式，以此类推</p> 
  <ul>
<li> <p>第一范式（1NF）：主属性（主键）不为空且不重复，字段不可再分（存在非主属性对主属性的部分依赖）</p> </li>
<li> <p>第二范式（2NF）：如果关系模式是第一范式，每个非主属性都没有对主键的部分依赖</p> </li>
<li> <p>第三范式（3NF）：如果关系模式是第二范式，没有非主属性对主键的传递依赖</p> </li>
<li> <p>BCNF范式：所有属性都不传递依赖于关系的任何候选键</p> </li>
</ul> </li>
</ol> 
<h6>
<a id="_295"></a>数据库的设计与管理</h6> 
<ol>
<li> <p>关系模式进行规范化的目的是使关系结构更加合理，消除存储异常，使数据冗余尽量小便于插入、删除和更新等操作</p> </li>
<li> <p>将实体-联系模型转换为关系模型时，一个多对多的联系可以转换为一个独立的关系模式，关系的建立为联系中各实体键的组合</p> </li>
<li> <p>设x，y是关系r的两个属性集合，若x→y，但y不完全函数依赖于x，则称y对x部分依赖</p> </li>
<li> <p>在关系模式中，如果y→x，x→a，且x不决定y和a不属于x，那么y→a是依赖传递</p> </li>
<li> <p>在任何一个关系数据库中，第一范式是对关系模式的基本要求</p> </li>
<li> <p>数据库设计过程包括需求分析、概念设计、逻辑设计、物理设计</p> </li>
<li> <p>需求分析的方法主要有结构化分析方法和面向对象分析方法。结构化分析方法采用自顶向下，逐步分解的方式分析系统，常用工具是数据流图和数据字典</p> </li>
<li> <p>关系数据库设计有需求分析、概念设计、逻辑设计、物理设计、编码、测试、运行、进一步修改等几个阶段。</p> 
  <ul>
<li> <p>在需求分析阶段形成需求说明书</p> </li>
<li> <p>概念设计阶段形成概念数据模型（E-R模型，作为进一步设计数据库的依据）</p> </li>
<li> <p>逻辑设计阶段形成逻辑数据模型（从E-R图向关系模式转换、关系视图设计、模式规范化）</p> </li>
<li> <p>物理设计阶段形成数据库内部模型（此时涉及具体软件硬件环境）</p> </li>
</ul> </li>
<li> <p>在逻辑设计阶段将E-R图转换为关系模式时对应关系：属性对应属性，实体集对应关系，联系对应关系</p> </li>
<li> <p>数据库的数据项之间以及表之间都存在联系</p> </li>
<li> <p>数据库物理设计的主要目标是对数据内部物理结构作调整并选择合理的存取路径，以提高数据库访问速度，有效利用存储空间。一般关系数据库管理系统（RDBMS）中留给用户参与物理设计的内容大致有索引设计、集簇设计和分区设计</p> </li>
</ol> 
<h3>
<a id="_327"></a>刷题笔记</h3> 
<ol>
<li>一个非空线性结构应满足两个条件：①有且只有一个根节点；②每个结点最多有一个前件，也最多有一个后件</li>
<li>根节点是指数据结构中没有前件的结点，终端结点（叶子结点）是指数据结构中没有后件的结点</li>
<li>二维数组、循环队列均为线性结构，采用顺序存储</li>
<li>二叉链表属于非线性结构，采用链式存储</li>
<li><img src="https://images2.imgbox.com/0c/58/b72DGwjQ_o.png" alt="在这里插入图片描述"></li>
<li>外存储器的容量一般都比较大，而且大部分可以移动，便于不同计算机之间进行信息交流。外存储器中数据被读入内存储器后，才能被cpu读取，<strong>cpu不能直接访问外存储器</strong>
</li>
<li>进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动</li>
<li>软件是指与计算机系操作有关的计算机程序、规程、规则。以及肯有的文件、文档及数据</li>
<li>数据库就是存放数据的仓库，只不过数据库存放数据时按数据所提供的数据模式（数据之间的联系）存放的</li>
<li>关系模式采用二维表来表示关系，简称表</li>
<li>关键字typedef的作用只是将C语言中的已有数据类型作了置换，并不是增加新的类型</li>
<li><strong>二叉树的性质：对任何一棵二叉树，度为0的结点（叶子结点）总是比度为2的结点多一个</strong></li>
<li>数据库管理系统的主要功能包括：①数据模式定义；②数据存取的物理构建；③数据操纵；④数据完整性、安全性的定义与检查；⑤数据库的并发与控制与故障恢复；⑥数据的服务</li>
<li>函数调用中发生的数据传送是单向的。实参→形参，形参的值不能反向传给实参</li>
<li>整数在计算机中存储和运算通常采用的格式是补码</li>
<li>一个计算机系统中有成千上万个文件，为了便于对文件进行存取和管理，计算机系统建立 文件的索引，即文件名和文件物理位置之间的映射关系，这种文件的索引称为文件目录</li>
<li>一个对象通常可由对象名（标识）、属性和操作三部分组成</li>
<li>软件工程包含方法、工具和过程三要素</li>
<li>I/O方式包含程序查询、程序中断、直接存储器存取（DMA）和通道控制等</li>
<li>通道控制方式可以做到一个通道控制多台设备与内存进行数据交换，因而通道方式进一步减轻了CPU的工作负担，增加了计算机系统的并行工作程度</li>
<li>缓冲技术是为了协调吞吐速度相差很大的设备之间数据传送而采用的技术</li>
<li>对长度为n的线性表进行快速排序，最坏情况下需要比较的次数为n(n-1)/2</li>
<li>若<strong>循环队列</strong>的存储空间为（1：m），在循环队列运转起来后，<strong>若front&lt;rear，则队列中的元素个数为rear-front；若front&gt;rear，则队列中的元素个数为rear-front+m</strong>
</li>
<li>黑盒测试又称功能测试或数据驱动测试，着重测试软件功能。黑盒测试依据需求规格说明书的功能描述</li>
<li>总线带宽可理解为总线的数据传输率，即单位时间内总线上传输数据的位数，通常用每秒传输信息的字节数来衡量，单位可用MBps（兆字节每秒）表示</li>
<li>结构化程序设计的重要原则是自顶向下、逐步求精、模块化及限制使用goto语句</li>
<li>没有从属结点的模块是原子模块</li>
<li>扇入指调用一个给定模块的模块个数</li>
<li>结果图是描述软件系统结构的图形工具</li>
<li>算法的特征：<img src="https://images2.imgbox.com/06/d4/22IYqfbb_o.png" alt="在这里插入图片描述">
</li>
<li>文件是有数据序列组成，可以构成二进制文件或文本文件</li>
<li>计算机中央处理器（cpu）和主存储器（内存储器）构成主机</li>
<li>进程是可以并发执行的程序的执行过程，它具有动态性、共享性、独立性、制约性和并发性5种属性</li>
<li>将实体—联系模型转换为关系模型时，一个多对多的联系可以转换为一个独立的关系模式，关系的键为联系中各实体键的组合</li>
<li>程序模块化思想中，可以采用自顶向下、逐步细化的方法</li>
<li>C语言中无逻辑类型</li>
<li>一维数组的定义方式为：类型说明符 数组名[常量表达式]；** 定义数组时，元素个数不能是变量**</li>
<li>总线按功能层次可以分为片内总线（内部总线）、系统总线和通信总线3类，片内总线是指芯片内部的总线</li>
<li>设循环队列的存储空间为Q（1：m），当front=rear=m时，循环队列为空；当front=rear且不等于m时，循环队列可能为空，也可能为满（当为空时，可以插入元素；当为满时，插入元素发生“上溢”）</li>
<li>解决软件“怎么做”的阶段是软件设计</li>
<li>c程序在运行过程中的所有计算都以二进制方式进行</li>
<li>C语言的数值常量中不能夹带空格</li>
<li>在C语言中，实参向形参传送数据的方式是“值传递”</li>
<li>C语言中，字符串是用一对双引号括起来的字符序列，并用字符型数组来存放</li>
<li>二叉树属于非线性结构，但满二叉树与完全二叉树可以按层次进行顺序存储。双向链表具有两个指针域，但属于线性结构。</li>
<li>二叉树中只有满二叉树与完全二叉树可以按层次进行顺序存储，满二叉树也是完全二叉树。非完全二叉树不能采用顺序存储结构</li>
<li>类是具有共同属性、共同方法的对象的集合。类是对象的抽象，它描述了属于改对象类型的所有对象的性质，而一个对象则是其对应类的一个实例</li>
<li>软件具有以下特点：<br> <img src="https://images2.imgbox.com/c4/82/nAEOXiVE_o.png" alt="在这里插入图片描述">
</li>
<li>数据流图是系统逻辑模型的图形表示，从数据传递和加工的角度，来刻画数据流从输入到输出的移动变化过程，它直接支持系统的功能建模</li>
<li>字符常量是使用<strong>单引号</strong>括起来的<strong>单个字符</strong>
</li>
<li>宏替换不占用程序的运行时间，在源文件的一行上至多只能有一条预处理命令</li>
<li>结构体变量中的成员可以是简单变量、数组、指针变量或结构体变量</li>
<li>C语言中的非执行语句不会被编译，不会生成二进制的机器指令。C程序在运行过程中的所有计算机都以二进制方式进行。一个C语句经过编译后产生若干条机器指令，但声明部分不是语句，不产生机器指令，只是对有关数据的声明，而且固定类型和格式的C语句被转换成机器指令的条数固定</li>
<li>由C语言构成的指令序列称C源程序，C语言程序名的后缀是.c（每个后缀为.c的C语言源程序都可以单独进行编译），C源程序经过C语言编译程序编译之后生成一个后缀为.obj的二进制文件（即目标文件），最后要由“连接程序”把此.obj文件与C语言提供的各种库函数连接起来生成一个后缀为.exe的可执行文件</li>
<li>C语言中八进制整型常量的开头是数字0，十六进制整型常量的开头数字是0x</li>
<li>C语言中的实型常量分为小数形式和指数形式。①小数形式表示的实型常量必须要有小数点。②指数形式以“e”或“E”后跟一个整数来表示以10为底数的幂数，且规定字母e或E之前必须要有数字，以及e或E后面的指数必须为整数。C语言规定E之前必须要有数字</li>
<li>C语言中标识符由字母、下划线、数字组成，且开头必须是字母或下划线，还有，关键字不能作为标识符。C语言的标识符分为三类：关键字（如：void）、预定义标识符（如:scanf）、用户标识符。不同C语言规定标识符的有效长度可能会不同，但没有限制最大长度</li>
<li>在C语言程序中可以进行多种算法的实现，对算法的个数没有规定。（算法的特征：①有穷性：一个算法对任何合法的输入 在执行有穷步后能够结束，并且在有限的时间内完成。②确定性：算法中的每一步都有确切的含。③可行性：算法中的操作能够用已经实现的基本运算执行有限次来实现。④输入：一个算法有零个或者多个输入，零个输入就是算法本身确定了初始条件。⑤输出：一个算法有一个或者逗哥输出，以反映出数据加工的结果。）</li>
<li>C程序可以由多个程序文件组成，可以由一个或多个函数组成，而且一个C函数可以单独作为一个C程序文件存在</li>
<li>结构化程序由顺序、分支、循环三种基本结构组成，使用这三种基本结构构成的程序可以解决所有问题，且结构化程序设计提倡模块化的设计方法。一个结构化程序可以包含循序、分支、循环结构中的一种或多种。</li>
<li>在C语言中整型常量可以用十进制、八进制和十六进制等形式表示，但不包括二进制，且每个字符变量被分配一个字节的内存空间</li>
<li>任何一个C程序都是从主函数main开始，至主函数main结束。而且C语言中的主函数唯一为main（）函数，不能任意指定。主函数必须写成小写main。C程序中主函数不能被其他函数调用。每个C程序中必须包含一个main函数，但不一定是每个C程序文件中必须有，且用户单独编写的某个函数也可以储存为一个C程序文件。</li>
<li>转义字符以"“开始，若要表示字符”“应写为”"。八进制的表示形式为ddd</li>
<li>计算机能直接执行的程序是二进制的可执行程序，扩展名为.exe</li>
<li>C语言规定，变量命名必须符合标识符的命名规则（一个变量实质上是代表了内存中的某个存储单元，必先定义后使用，且在定义时为之分配存储单元，不能随时改变）。要表示字符串常量应该使用双引号表示，单引号表示字符常量</li>
<li>C语言中，常量是指在程序运行过程中其值不能被改变的量（数值常量中不能夹带空格），变量是指运行过程中其值可以改变的量（变量都必须先定义再使用，对变量的定义通常放在函数体内的前部，但也可以放在函数外部或复合语句的开头，不能随便放置）</li>
<li>程序模块化思想中，可以采用自顶向下、逐步细化的方法。把程序分成若干相对独立、功能单一的模块，可便于重复使用这些模块（便于编码和调试）。C语言程序模块化通过函数来体现</li>
<li>在C语言中运算符两侧的运算数据类型可以不一致，且结果与精度较高的保持一致</li>
<li>在C程序的函数中不能定义另一个函数，可以声明或调用另一个函数</li>
<li>算法的描述有伪代码、流程图、N-S结构图（可以描述循环结构、选择结构、顺序结构等多种结构的程序）等</li>
<li>在VC环境下，double型数据在内存中占8个字节，float型数据占4个字节，int型数据占4个字节，char型数据占1个字节</li>
<li>C语言中的关键字即不能做变量名也不能做用户函数名</li>
<li>C语言的程序中，函数不一定都放在同一个源文件中，可以分别放在不同的源文件中，通过#include命令来引用</li>
<li>结构化程序设计把一个复杂问题的求解过程分阶段进行，需要保证自顶向下、逐步细化、模块化设计，结构化编码。进行模块化设计时，首先设计框架，并定义和协调好各个模块化之间的输入输出关系，然后完成各个模块的编写调试后再集中编译。</li>
<li>简单程序设计步骤：确定数据结构、确定算法、编码、调试、整理文档，不包括安装编译程序</li>
<li>C语言中最基本的数据类型包括整型、实型、字符型</li>
</ol>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>