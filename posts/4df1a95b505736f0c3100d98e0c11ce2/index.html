<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Csapp-程序人生 - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Csapp-程序人生</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>目录</h3> 
 <ul>
<li><a href="#_2">摘要</a></li>
<li><a href="#1__9">第1章 概述</a></li>
<li>
<ul>
<li><a href="#11_Hello_10">1.1 Hello简介</a></li>
<li>
<ul>
<li><a href="#111_P2PFrom_Program_to_Process_12">1.1.1 P2P（From Program to Process）</a></li>
<li><a href="#112_O2OFrom_Zero0_to_Zero0_15">1.1.2 O2O（From Zero-0 to Zero-0）</a></li>
</ul> 
   </li>
<li><a href="#13__20">1.3 中间结果</a></li>
<li><a href="#14__34">1.4 本章小结</a></li>
</ul> 
  </li>
<li><a href="#2__37">第2章 预处理</a></li>
<li>
<ul>
<li><a href="#21__38">2.1 预处理的概念与作用</a></li>
<li><a href="#22Ubuntu_44">2.2在Ubuntu下预处理的命令</a></li>
<li><a href="#23_Hello_45">2.3 Hello的预处理结果解析</a></li>
<li><a href="#24__49">2.4 本章小结</a></li>
</ul> 
  </li>
<li><a href="#3__52">第3章 编译</a></li>
<li>
<ul>
<li><a href="#31__53">3.1 编译的概念与作用</a></li>
<li><a href="#32_Ubuntu_60">3.2 在Ubuntu下编译的命令</a></li>
<li><a href="#33_Hello_61">3.3 Hello的编译结果解析</a></li>
<li>
<ul>
<li><a href="#331__66">3.3.1 数据操作</a></li>
<li>
<ul>
<li><a href="#1_68">1.常量（字符串）</a></li>
<li><a href="#2_73">2.局部变量</a></li>
<li><a href="#3argv_76">3.全局变量（数组argv[]）</a></li>
</ul> 
    </li>
<li><a href="#332__78">3.3.2 赋值</a></li>
<li><a href="#333_81">3.3.3类型转换</a></li>
<li><a href="#334__83">3.3.4 算术操作</a></li>
<li><a href="#335_88">3.3.5关系操作</a></li>
<li><a href="#336__90">3.3.6 函数操作</a></li>
<li>
<ul>
<li><a href="#1main_94">1.main函数</a></li>
<li><a href="#2printf_97">2.printf函数</a></li>
<li><a href="#3atoi_99">3.atoi函数</a></li>
<li><a href="#4sleep_101">4.sleep函数</a></li>
<li><a href="#5getchar_102">5.getchar函数</a></li>
<li><a href="#6exit_103">6.exit函数</a></li>
</ul> 
   </li>
</ul> 
   </li>
<li><a href="#34__104">3.4 本章小结</a></li>
</ul> 
  </li>
<li><a href="#4__107">第4章 汇编</a></li>
<li>
<ul>
<li><a href="#41__108">4.1 汇编的概念与作用</a></li>
<li><a href="#42_Ubuntu_111">4.2 在Ubuntu下汇编的命令</a></li>
<li><a href="#43_elf_112">4.3 可重定位目标elf格式</a></li>
<li><a href="#44_Helloo_127">4.4 Hello.o的结果解析</a></li>
<li><a href="#45__134">4.5 本章小结</a></li>
</ul> 
  </li>
<li><a href="#5__137">第5章 链接</a></li>
<li>
<ul>
<li><a href="#51__138">5.1 链接的概念与作用</a></li>
<li><a href="#52_Ubuntu_141">5.2 在Ubuntu下链接的命令</a></li>
<li><a href="#53_hello_152">5.3 可执行目标文件hello的格式</a></li>
<li><a href="#54_hello_168">5.4 hello的虚拟地址空间</a></li>
<li><a href="#55__172">5.5 链接的重定位过程分析</a></li>
<li><a href="#56_hello_180">5.6 hello的执行流程</a></li>
<li><a href="#57_Hello_195">5.7 Hello的动态链接分析</a></li>
<li><a href="#58__200">5.8 本章小结</a></li>
</ul> 
  </li>
<li><a href="#6_hello_203">第6章 hello进程管理</a></li>
<li>
<ul>
<li><a href="#61__204">6.1 进程的概念与作用</a></li>
<li><a href="#62_Shellbash_207">6.2 简述壳Shell-bash的作用与处理流程</a></li>
<li><a href="#63_Hellofork_215">6.3 Hello的fork进程创建过程</a></li>
<li><a href="#64_Helloexecve_217">6.4 Hello的execve过程</a></li>
<li><a href="#65_Hello_219">6.5 Hello的进程执行</a></li>
<li>
<ul>
<li><a href="#651__220">6.5.1 概念介绍</a></li>
<li><a href="#652__hello_236">6.5.2 hello的执行：</a></li>
</ul> 
   </li>
<li><a href="#66_hello_240">6.6 hello的异常与信号处理</a></li>
<li><a href="#67_245">6.7本章小结</a></li>
</ul> 
  </li>
<li><a href="#7_hello_248">第7章 hello的存储管理</a></li>
<li>
<ul>
<li><a href="#71_hello_249">7.1 hello的存储器地址空间</a></li>
<li><a href="#72_Intel_254">7.2 Intel逻辑地址到线性地址的变换-段式管理</a></li>
<li><a href="#73_Hello_258">7.3 Hello的线性地址到物理地址的变换-页式管理</a></li>
<li><a href="#74_TLBVAPA_260">7.4 TLB与四级页表支持下的VA到PA的变换</a></li>
<li><a href="#75_Cache_264">7.5 三级Cache支持下的物理内存访问</a></li>
<li><a href="#76_hellofork_267">7.6 hello进程fork时的内存映射</a></li>
<li><a href="#77_helloexecve_269">7.7 hello进程execve时的内存映射</a></li>
<li><a href="#78__275">7.8 缺页故障与缺页中断处理</a></li>
<li><a href="#79_284">7.9动态存储分配管理</a></li>
<li><a href="#710_291">7.10本章小结</a></li>
</ul> 
  </li>
<li><a href="#8_helloIO_294">第8章 hello的IO管理</a></li>
<li>
<ul>
<li><a href="#81_LinuxIO_295">8.1 Linux的IO设备管理方法</a></li>
<li><a href="#82_Unix_IO_297">8.2 简述Unix IO接口及其函数</a></li>
<li><a href="#83_printf_303">8.3 printf的实现分析</a></li>
<li><a href="#84_getchar_309">8.4 getchar的实现分析</a></li>
<li><a href="#85_314">8.5本章小结</a></li>
</ul> 
  </li>
<li><a href="#_317">结论</a></li>
</ul> 
</div> 
<p></p> 
<h1>
<a id="_2"></a>摘要</h1> 
<p>本文通过hello程序实例对《深入了解计算机系统》知识主线进行总结梳理，阐释分析了Linux系统下hello.c程序从 Program到Process，从无到有再到无的过程。运用了终端命令行和edb，从计算机系统的角度解释了Linux系统对典型C语言程序的处理机制。<br> gcc将C语言源文件进行预处理、编译、汇编、链接，最终形成可执行目标文件hello，由存储器保存在磁盘中。运行进程时，操作系统为其分配虚拟地址空间，提供异常控制流等强大的工具，Linux I/O为其提供与程序员和系统文件交互的方式。<br> 本文通过分析Hello程序从代码编辑器到运行进程的过程，对计算机系统编译源文件、运行进程等机制进行较深入的分析和介绍。有助于加深初学者对于计算机软硬件系统的初步认识。</p> 
<p>关键词：<strong>计算机系统；Linux；程序生命周期；C语言底层实现</strong></p> 
<h1>
<a id="1__9"></a>第1章 概述</h1> 
<h2>
<a id="11_Hello_10"></a>1.1 Hello简介</h2> 
<p>hello.c的程序是linux环境下，使用文本编辑器，利用C语言编写的程序。</p> 
<h3>
<a id="111_P2PFrom_Program_to_Process_12"></a>1.1.1 P2P（From Program to Process）</h3> 
<p>用户使用高级语言通过文本编辑器编写易读的代码，得到一个hello.c程序为了在系统上运行hello.c程序,每条C语旬都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令接照一种称为可执行目标程序的格式打好包,并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。<br> 用户在Ubuntu 终端中键入./hello启动此目标程序（可执行文件），shell调用fork函数为其产生子进程，实现hello.c（program）成为进程（process）</p> 
<h3>
<a id="112_O2OFrom_Zero0_to_Zero0_15"></a>1.1.2 O2O（From Zero-0 to Zero-0）</h3> 
<p>描述进程从产生到结束的过程。shell调用fork、vfork系统调用，得到父进程的一个复制品——子进程；为了让子进程运行main程序代码，父进程shell调用execve，操作系统为该进程分配一定虚拟空间，当程序加载到虚拟空间映射的物理内存空间中时，可执行目标文件hello中的代码段和数据段从磁盘复制到物理内存。在start_thread()内核函数完成后，结束execve()回到用户态时，内核已为hello进程分配时间片执行逻辑控制流，CPU此时已被系统调用切换至main程序的运行上下文(即main二进制程序对应的汇编代码的第一条指令start处）开始运行。<br> 后续的运行都按照main的汇编进行，主要由函数栈对esp寄存器值、ebp寄存器值、函数返回地址的压栈和退栈来实现；main函数结束前return 0；并使用ret 函数栈中弹出函数返回地址，并jump跳转到这个地址。<br> ret指令最终使得程序返回到<em>C程序例程</em>，<em>C程序例程</em>将调用exit系统调用，shell父进程回收此僵尸子进程。切换到系统内核态，结束进程，并且发送运行结束的状态码给父进程。shell调用的子进程执行完毕，准备处理下一条指令。</p> 
<h2>
<a id="13__20"></a>1.3 中间结果</h2> 
<table>
<thead><tr>
<th>文件的作用</th>
<th>文件名</th>
</tr></thead>
<tbody>
<tr>
<td>文件的作用</td>
<td>文件名</td>
</tr>
<tr>
<td>源程序</td>
<td>hello.c</td>
</tr>
<tr>
<td>预处理后的文件</td>
<td>hello.i</td>
</tr>
<tr>
<td>编译之后的汇编文件</td>
<td>hello.s</td>
</tr>
<tr>
<td>汇编之后的可重定位目标文件</td>
<td>hello.o</td>
</tr>
<tr>
<td>链接之后的可执行目标文件</td>
<td>hello</td>
</tr>
<tr>
<td>hello.o 的 ELF 格式</td>
<td>hello.o-elf</td>
</tr>
<tr>
<td>hello.o 的反汇编代码</td>
<td>hello.o-objdump</td>
</tr>
<tr>
<td>hello的ELF 格式</td>
<td>hello-elf</td>
</tr>
<tr>
<td>hello 的反汇编代码</td>
<td>hello-objdump</td>
</tr>
</tbody>
</table> 
<h2>
<a id="14__34"></a>1.4 本章小结</h2> 
<p>本章简要介绍了大作业的背景——针对hello程序的探究。简述了探究的流程：P2P和O2O，并介绍了大作业的环境和工具，以及中间结果文件。</p> 
<h1>
<a id="2__37"></a>第2章 预处理</h1> 
<h2>
<a id="21__38"></a>2.1 预处理的概念与作用</h2> 
<p>**概念：**预处理过程是编译之前进行的处理，预处理器(cpp)根据以字符#开头的命令（#include头文件和#define宏定义等）,修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件，得到了另一个C程序,通常是以.i作为文件扩展名。<br> **作用：**主要作用有宏定义、文件包含、条件编译</p> 
<ol>
<li>将所有的#define删除，并且展开所有的宏定义，将宏名替换为文本。.</li>
<li>处理所有条件预编译指令，根据#if以及#endif和#ifdef以及#ifndef来判断执行编译的条件。</li>
<li>预处理程序中的#include，将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件。</li>
</ol> 
<h2>
<a id="22Ubuntu_44"></a>2.2在Ubuntu下预处理的命令</h2> 
<h2>
<a id="23_Hello_45"></a>2.3 Hello的预处理结果解析</h2> 
<ol>
<li>代码行数以及文件大小增加，进行了头文件的展开，有大量对结构的定义，诸如typedef、struct、enum等等，对外部变量的引用，诸如extern。</li>
<li>预处理的结果在C源程序中插入所有用#include命令指定的文件,并扩展所有用#define声明指定的宏，它们扩充程序设计的环境。</li>
<li>main函数在hello.i的最后。</li>
</ol> 
<h2>
<a id="24__49"></a>2.4 本章小结</h2> 
<p>本章主要介绍预处理的概念和应用功能，以及linux下预处理的指令，对比hello.c文件和预处理结果hello.i文本文件解析，分析了头文件展开，宏替换，条件编译，去除注释等功能。详细了解了预处理的细节（插入所有用#include命令指定的文件,并扩展所有用#define声明指定的宏）过程和结果。</p> 
<h1>
<a id="3__52"></a>第3章 编译</h1> 
<h2>
<a id="31__53"></a>3.1 编译的概念与作用</h2> 
<p>**概念：**编译器（ccl）将预处理得到的ASCII码的中间文件hello.i翻译成汇编语言文件hello.s的过程。预处理后的文件到生成汇编语言程序。<br> **作用：**主要作用有语法分析，中间代码，优化，目标代码生成。</p> 
<ol>
<li>语法分析：分析代码的词法、语法、语义。词法分析对输入的字符串进行分析和分割，形成所使用的源程序语言所允许的记号，同时标注不规范记号，产生错误提示信息。语法分析词法分析得到的记号序列，并按一定规则识别并生成中间表示形式，以及符号表。同时将不符合语法规则的记号识别出其位置并产生错误提示语句。语义分析即静态语法检查，分析语法分析过程中产生的中间表示形式和符号表，以检查源程序的语义是否与源语言的静态语义属性相符合。</li>
<li>中间代码：源程序的一种内部表示，或称中间语言。使编译程序的结构在逻辑上更为简单明确，特别是可使目标代码的优化比较容易实现中间代码。</li>
<li>代码优化：指对程序进行多种等价变换，转换为功能等价但是运行时间更短或占用资源更少的等价中间代码。</li>
<li>目标代码：生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标汇编语言代码。相比机器代码的二进制格式可读性更好。可见一些通常对C语言程序员隐藏的处理器状态。例如程序计数器，整数寄存器，条件码寄存器。</li>
</ol> 
<h2>
<a id="32_Ubuntu_60"></a>3.2 在Ubuntu下编译的命令</h2> 
<h2>
<a id="33_Hello_61"></a>3.3 Hello的编译结果解析</h2> 
<p>**指示（Directives）：**以‘. ’开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。<br> **标签（Labels）：**以‘ ：’结尾，用来把标签名和标签出现的位置关联起来。例如，标签.LC0:表示紧接着的字符串的名称是 .LC0。按照惯例，以点号开始的标签都是编译器生成的临时局部标签，其它标签则是用户可见的函数和全局变量名称。<br> <strong>指令（Instructions）：</strong> 实际的汇编代码 (pushq %rbp), 一般都会缩进，以便和指示及标签区分开来。</p> 
<h3>
<a id="331__66"></a>3.3.1 数据操作</h3> 
<p>C语言的数据类型有常量，变量(全局/局部/静态)，表达式，类型，宏。</p> 
<h4>
<a id="1_68"></a>1.常量（字符串）</h4> 
<p>两个字符串都被存放在.section 的.rodata节（只读数据段）</p> 
<ol>
<li>"用法: Hello 学号 姓名 秒数！n"编译后上图。在hello.s，字符串使用UTF-8的格式编码的，一个汉字在UTF-8中占三个字节。</li>
<li>“Hello %s %sn”，仍然是由printf函数传入的格式化参数<br> main函数中对字符串引用为26行：leaq.LC1(%rip), %rdi，直接使用伪指令.LC1代指字符串。</li>
</ol> 
<h4>
<a id="2_73"></a>2.局部变量</h4> 
<p>变量 <strong>argc(传入main函数的参数个数)</strong> ：main函数的第一个形式参数（22-24行），由寄存器%edi传入，进而保存在堆栈中，其中argc自增加一(argv是指向指针的指针，main函数的第二个参数“char *argv[]“也可以替换为 “char **argv“，两者是等价的)。<br> <strong>int i</strong>：i在c程序里面被声明为局部变量，而且没有被初始化。它不占用文件的实际节空间，只有当运行时才在寄存器或者栈上分配空间进行操作。</p> 
<h4>
<a id="3argv_76"></a>3.全局变量（数组argv[]）</h4> 
<p>程序中涉及到的数组为字符串数组，程序中涉及到的数组为字符串数组（字符数组指针），即main函数的第二个参数char *argv[]。首先，它将数组的首元素地址存入栈中，采用寄存器寻址的方法。</p> 
<h3>
<a id="332__78"></a>3.3.2 赋值</h3> 
<p>源程序中的赋值操作有i=0;i++;对应汇编代码mol<br> mov指令的后缀：b/w/l/q 对应1/2/4/8字节。</p> 
<h3>
<a id="333_81"></a>3.3.3类型转换</h3> 
<p>利用atoi函数将字符类型转换为整数类型，先取出argv[3]，将其存入rdi。</p> 
<h3>
<a id="334__83"></a>3.3.4 算术操作</h3> 
<ol>
<li>加法操作add：在对计数器加一时addq，对应C语言“i+1”</li>
<li>减法操作sub：为main函数开辟栈帧是将栈顶指针-0x32。</li>
<li>地址的运算：整个字符串首地址±相对地址进行寻址。</li>
<li>加载有效地址leaq：计算LC0 的段地址%rip+.LC0并传递给%rdi。</li>
</ol> 
<h3>
<a id="335_88"></a>3.3.5关系操作</h3> 
<p>使用cmpl设置条件码，jxx根据条件码选择是否进行相应的跳转</p> 
<h3>
<a id="336__90"></a>3.3.6 函数操作</h3> 
<p>进行过程A 时，程序计数器必须设置为A 的代码的起始地址<br> 返回时，要把程序计数器设置为调用A后面那条指令的地址。<br> 在开始时，A可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。</p> 
<h4>
<a id="1main_94"></a>1.main函数</h4> 
<p>被调用call 才能执行（被系统启动函数__libc_start_main 调用），call 指令将下一条指令的地址dest 压栈，然后跳转到main 函数。<br> 结束时，用eax返回0，leave相当于mov %rbp,%rsp, pop %rbp，恢复栈空间为调用之前的状态，然后ret返回，将下一条要执行指令的地址设置为dest</p> 
<h4>
<a id="2printf_97"></a>2.printf函数</h4> 
<p>在.L4中，通过argv+8 和argv+16分别指向了argv[1],argv[2]，再由argv[1],argv[2]指向的参数字符串得到了%rsi，%rdx两个参数，并和%rdi所保存的字符串一起作为printf函数的三个参数。</p> 
<h4>
<a id="3atoi_99"></a>3.atoi函数</h4> 
<p>取出arg[3]放入rdi传入atoi函数</p> 
<h4>
<a id="4sleep_101"></a>4.sleep函数</h4> 
<h4>
<a id="5getchar_102"></a>5.getchar函数</h4> 
<h4>
<a id="6exit_103"></a>6.exit函数</h4> 
<h2>
<a id="34__104"></a>3.4 本章小结</h2> 
<p>本章把hello.i文件编译成了hello.s，并对源程序中的数据和操作做了解析，阐述了和汇编代码的对应关系。</p> 
<h1>
<a id="4__107"></a>第4章 汇编</h1> 
<h2>
<a id="41__108"></a>4.1 汇编的概念与作用</h2> 
<p>**概念：**汇编器(as)将hello.s文件翻译成二进制机器语言指令，把这些指令转化成一种叫做可重定位目标程序的格式，并将结果保存到二进制文件目标文件hello.o中。<br> **作用：**汇编过程将汇编代码转换为计算机能够理解并执行的二进制机器代码。</p> 
<h2>
<a id="42_Ubuntu_111"></a>4.2 在Ubuntu下汇编的命令</h2> 
<h2>
<a id="43_elf_112"></a>4.3 可重定位目标elf格式</h2> 
<p>**ELF头：**以一个16字节的序列开始，描述了生成该文件的系统的字的大小和字节顺序。还包含帮助链接器语法分析和解释目标文件的信息。包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。<br> **节头：**记录每个节的名称，偏移量，大小，位置等信息</p> 
<pre><code>.text节：已编译程序的机器代码以编译的机器代码。
.rela.text节：.text节中的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。
.data节：已初始化的静态和全局C变量。
.bss节：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量，在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。
.rodata节：存放只读数据。
.comment节：包含版本控制信息。
.note : 该节中包含注释;
.symtab：一个符号表，存放在程序中定义和引用的函数和全局变量的信息。
.strtab节：字符串表，其内容包括.symtab和.debug节中的符号表，节头部的节名字。
.shstrtab节：该区域包含节的名称。
</code></pre> 
<h2>
<a id="44_Helloo_127"></a>4.4 Hello.o的结果解析</h2> 
<p>Hello.o反汇编与hello.s的区别可知：</p> 
<ol>
<li>数据显示：立即数在hello.s这一汇编语言文本文件中为十进制，而在反汇编代码中为十六进制。</li>
<li>跳转方式：在汇编代码中，对于分支转移函数调用，通过助记符如.LC0，.LC1来进行跳转。在反汇编代码是依据地址跳转的。</li>
<li>函数调用：函数调用：在.s 文件中，函数调用之后直接跟着函数名称，而在反汇编序中，call 的目标地址是当前下一条指令。因为 hello.c 中调用的函数 都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执 行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0(目标地址正是下一条指令），然后在.rela.text 节中为其添加重定位条目，等待静态链接的进一步确定，其地址还需要重定位地址。</li>
<li>字符串常量：汇编中字符串常量在.rodata中存储，反汇编中字符串常量使用0x0暂时代替，等待重定位。<br> 机器指令由操作码和操作数构成，汇编语言是人们比较熟悉的词句直接表述CPU动作形成的语言，是最接近CPU运行原理的语言。每一条汇编语言操作码都可以用机器二进制数据来表示，进而可以将所有的汇编语言(操作码和操作数）和二进制机器语言建立一一映射的关系，因此可以将汇编语言转化为机器语言。</li>
</ol> 
<h2>
<a id="45__134"></a>4.5 本章小结</h2> 
<p>本章介绍了hello 从hello.s 到hello.o 的汇编过程、阅读了程序的ELF条目，了解了汇编、反汇编这两种相近而不相同的程序表现形式，了解到从汇编语言映射到机器语言汇编器需要实现的转换。</p> 
<h1>
<a id="5__137"></a>第5章 链接</h1> 
<h2>
<a id="51__138"></a>5.1 链接的概念与作用</h2> 
<p>**概念：**链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行<br> **作用：**链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。</p> 
<h2>
<a id="52_Ubuntu_141"></a>5.2 在Ubuntu下链接的命令</h2> 
<pre><code>crt1.o, crti.o, crtbegin.o, crtend.o, crtn.o 等目标文件和hello.o链接成一个执行文件。
这5个目标文件的作用分别是启动、初始化、构造、析构和结束，在标准的linux平台下,link的顺序是:ld crt1.o crti.o [user_objects] [system_libraries] crtn.o
ld -o hello -dynamic-linker
/lib64/ld-linux-x86-64.so.2
/usr/lib/x86_64-linux-gnu/crt1.o 
/usr/lib/x86_64-linux-gnu/crti.o hello.o 
/usr/lib/x86_64-linux-gnu/libc.so 
 /usr/lib/x86_64-linux-gnu/crtn.o
</code></pre> 
<h2>
<a id="53_hello_152"></a>5.3 可执行目标文件hello的格式</h2> 
<ol>
<li>ELF头：对文件类型、程序入口地址、头起点地址、各节的大小进行修改，得到了相应的节大小。<br> 在之前的.o文件中，所有的地址位都是零，而在可执行文件中，这些节都有了自己的地址。可重定位说明还未定位，而在可执行文件中，这些代码都已经定位到最终要执行的地址，涉及定位的节像rel.text等就没有了。同时出现程序表。</li>
<li>节头部表：给出各节的大小，地址（虚拟地址）和偏移量等。</li>
<li>程序头表：相当于一个目录，描述了各节的分布，地址的数值范围图 29 hello 程序头表</li>
</ol> 
<pre><code>程序包含**PHDR，INTERP，LOAD，DYNAMIC，NOTE，GNU_STACK，GNU_RELRO**几个部分。
其中PHDR 保存程序头表。
INTERP 指定在程序已经从可执行文件映射到内存之后，必须调用的解释器。
LOAD 表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据、程序的目标代码等。
DYNAMIC 保存了由动态链接器使用的信息。
NOTE 保存辅助信息。
GNU_STACK：权限标志，用于标志栈是否是可执行。
GNU_RELRO：指定在重定位结束之后哪些内存区域是需要设置只读。
</code></pre> 
<h2>
<a id="54_hello_168"></a>5.4 hello的虚拟地址空间</h2> 
<ol>
<li>edb的Data Dump窗口显示虚拟地址0x401000开始，0x402000结束与hello的Program Header对应</li>
<li>edb中查看Symbols选项，并与5.3中列出的虚拟地址各段信息做对比（以12-14为例），可以看到匹配的相同地址。</li>
<li>该两处操作中0x402008与0x40202e分别为两个字符串首地址，与节头部表中.rotata对应</li>
</ol> 
<h2>
<a id="55__172"></a>5.5 链接的重定位过程分析</h2> 
<p>链接过程主要包括了地址和空间分配、符号决议和重定向<br> 符号决议：有时候也被叫做符号绑定、名称绑定、名称决议、或者地址绑定，其实就是指用符号来去标识一个地址。<br> 重定位：重新计算各个目标的地址过程叫做重定位。<br> hello-o-objdump中的地址是相对偏移地址，hello-objdump中的地址是虚拟地址，而且跳转和函数调用都以虚拟地址。因为hello反汇编的结果中，由于链接过程中重定位而加入进来各种函数、数据，许多开始的函数和调用的函数填充在main函数之前，main函数的位置发生改变。而这些call函数引用全局变量，和跳转模块值时地址也有所变化。<br> 最基本的链接叫做静态链接，（Linux：.o）目标文件和库一起链接形成最后的可执行文件。库其实就是一组目标文件的包，就是一些最常用的代码变异成目标文件后打包存放。最常见的库就是运行时库，它是支持程序运行的基本函数的集合。<br> hello-objudmp中增加了许多外部链接的共享函数库，例如printf@plt以getchar@plt等等。<br> 可知链接器把 hello.o 中的偏移量加上程序在虚拟内存中的起始地址得到了可直接访问的地址。</p> 
<h2>
<a id="56_hello_180"></a>5.6 hello的执行流程</h2> 
<table>
<thead><tr>
<th>名称</th>
<th>地址</th>
</tr></thead>
<tbody>
<tr>
<td>_init</td>
<td>0x401000</td>
</tr>
<tr>
<td>.plt</td>
<td>0x401020</td>
</tr>
<tr>
<td>puts@plt</td>
<td>0x401030</td>
</tr>
<tr>
<td>exit@plt</td>
<td>0x401060</td>
</tr>
<tr>
<td>
<em>printf_chk</em>@plt</td>
<td>0x4010b0</td>
</tr>
<tr>
<td>sleep@plt</td>
<td>0x401070</td>
</tr>
<tr>
<td>getc@plt</td>
<td>0x4010e0</td>
</tr>
<tr>
<td>_start</td>
<td>0x4010f0</td>
</tr>
<tr>
<td>main</td>
<td>0x4011d6</td>
</tr>
<tr>
<td>_libc_csu_init</td>
<td>0x401260</td>
</tr>
<tr>
<td>_libc_csu_fini</td>
<td>0x4012d0</td>
</tr>
<tr>
<td>_fini</td>
<td>0x4012d8</td>
</tr>
</tbody>
</table> 
<h2>
<a id="57_Hello_195"></a>5.7 Hello的动态链接分析</h2> 
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而非静态链接一样把所有程序模块都链接成一个单独的可执行文件。（注意形成可执行文件和执行程序，生成可执行文件，在执行程序时仍会修改）<br> plt初始存的是一批代码，它们跳转到got所指示的位置，然后调用链接器。初始时got里面存的都是plt的第二条指令，随后链接器修改got，下一次plt就能跳转到正确的区域。延迟绑定是通过GOT和PLT实现的。GOT是数据段的一部分，而PLT是代码段的一部分。两表内容分别为：<br> PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。<br> GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。</p> 
<h2>
<a id="58__200"></a>5.8 本章小结</h2> 
<p>本章介绍了链接的概念、作用以及在Ubuntu下通过ld指令进行链接的方法，通过对hello.o进行链接得到可执行目标文件hello，分析hello的ELF格式，并动态链接的实现进行分析。</p> 
<h1>
<a id="6_hello_203"></a>第6章 hello进程管理</h1> 
<h2>
<a id="61__204"></a>6.1 进程的概念与作用</h2> 
<p>**概念：**进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。<br> **作用：**进程提供给应用程序的关键抽象：一个独立的逻辑控制流，如同程序独占处理器；一个私有的地址空间，如同程序独占内存系统。可以说，如果没有进程，体系如此庞大的计算机不可能设计出来。</p> 
<h2>
<a id="62_Shellbash_207"></a>6.2 简述壳Shell-bash的作用与处理流程</h2> 
<p>Shell是用户级的应用程序，代表用户控制操作系统中的任务。处理流程如下：<br> ①在shell命令行中输入命令：$./hello<br> ② shell命令行解释器构造argv和envp；<br> ③ 调用fork()函数创建子进程，其地址空间与shell父进程完全相同，包括只读代码段、读写数据段、堆及用户栈等<br> ④ 调用execve()函数在当前进程（新创建的子进程）的上下文中加载并运行hello程序。将hello中的.text节、.data节、.bss节等内容加载到当前进程的虚拟地址空间<br> ⑤ 调用hello程序的main()函数，hello程序开始在一个进程的上下文中运行。</p> 
<h2>
<a id="63_Hellofork_215"></a>6.3 Hello的fork进程创建过程</h2> 
<p>在命令行键入hello运行命令，shell判断该命令是可执行文件，于是调用fork函数给hello程序创建一个进程并分配一个标识符，子进程得到与父进程用户级虚拟地址空间和任何打开文件描述符相同的副本，但他们有不同的PID。</p> 
<h2>
<a id="64_Helloexecve_217"></a>6.4 Hello的execve过程</h2> 
<p>fork函数创建完进程后，调用execve函数到我们输入的目标路径中寻找hello文件，找到后创建一个内存映像，为该程序的栈区域创建新的区域结构将可执行文件的片复制到代码段和数据段等。然后为共享库建立映射空间，整个内存映射空间的结构如下图所示。最后设置当前进程上下文的程序计数器，将其指向入口函数，并将控制传递给新程序的主函数。</p> 
<h2>
<a id="65_Hello_219"></a>6.5 Hello的进程执行</h2> 
<h3>
<a id="651__220"></a>6.5.1 概念介绍</h3> 
<ol>
<li>时间片：分时操作系统分配给每个正在运行的进程微观上的一段CPU时间；</li>
<li>进程上下文：用户进程传递给内核的参数以及内核要保存的变量和寄存器值和当时的环境等；</li>
<li>中断上下文：硬件通过触发信号，导致内核调用中断处理程序，进入内核空间的过程中需要将一些参数传递给内核，内核通过这些参数进行中断处理，而硬件传递过来的参数和内核需要保存的一些其他环境即为中断上下文；</li>
<li>内核态：在CPU高执行级别下，代码可以访问任意的物理地址；</li>
<li>用户态：在CPU相应的低级别执行状态下，代码的掌控范围会受到限制，只能在对应级别允许的范围内活动；</li>
</ol> 
<p>从用户态到内核态切换可以通过三种方式：</p> 
<ol>
<li>系统调用；</li>
<li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换；</li>
<li>外设中断：当外设完成用户的请求时，会向CPU发送中断信号；</li>
</ol> 
<p>处理器总处于以下状态中的一种：</p> 
<ol>
<li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li>
<li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li>
<li>用户态，运行于用户空间。</li>
</ol> 
<h3>
<a id="652__hello_236"></a>6.5.2 hello的执行：</h3> 
<p>在execve将程序加载完毕之后，hello处于用户态，打印字符串”Hello 7203610720 王越琛”，然后调用sleep函数，该函数为系统函数，因此会产生用户态到内核态的切换，此时hello进程被移除运行队列，加入到等待队列，计时器计时开始，hello进程的上下文被保存，内核进行上下文的切换，将控制转移给其他进程，该进程恢复上下文开始继续运行。当计时时间达到预定时间后，会发送中断信号中断当前进程，进而又触发上下文转换，切换回hello进程的上下文。<br> 当hello调用getchar函数时，实际是调用的系统函数read，因此进入内核态，内核中的陷阱处理程序请求来自键盘缓冲区的直接存储器访问。此时进行上下文的切换，执行其他进程，在键盘缓冲区到内存的传输完成之后，引发中断信号，切换回hello进程的上下文继续执行。</p> 
<h2>
<a id="66_hello_240"></a>6.6 hello的异常与信号处理</h2> 
<ol>
<li>正常执行</li>
<li>不停乱按</li>
<li>Ctrl-Z</li>
<li>Ctrl-C</li>
</ol> 
<h2>
<a id="67_245"></a>6.7本章小结</h2> 
<p>阐明了进程的定义与作用，介绍了Shell 的一般处理流程，并探讨了hello进程运行过程中可能的异常和信号处理。</p> 
<h1>
<a id="7_hello_248"></a>第7章 hello的存储管理</h1> 
<h2>
<a id="71_hello_249"></a>7.1 hello的存储器地址空间</h2> 
<p>1.逻辑地址（Logical Address）：由程序产生的与段相关的偏移地址部分。在这里指的是hello.o中的内容。<br> 2.线性地址（Linear Address）：逻辑地址到物理地址变换之间的中间层。程序hello的代码会产生段中的偏移地址，加上相应段的基地址就生成了一个线性地址。<br> 3.虚拟地址：CPU 启动保护模式后，程序运行在虚拟地址空间中。与物理地址相似，虚拟内存被组织为一个存放在磁盘上的N 个连续的字节大小的单元组成的数组，其每个字节对应的地址成为虚拟地址。<br> 4.物理地址：放在寻址总线上的地址。放在寻址总线上，如果是读，电路根据这个地址每位的值就将相应地址的物理内存中的数据放到数据总线中传输。如果是写，电路根据这个地址每位的值就在相应地址的物理内存中放入数据总线上的内容。物理内存是以字节(8位)为单位编址的。</p> 
<h2>
<a id="72_Intel_254"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h2> 
<p>段式内存管理：把虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存单元。每个段有三个参数定义：段基地址，指定段在线性地址空间中的开始地址。段偏移量：是虚拟地址空间中段内最大可用偏移地址。段属性：指定段的特性。如该段是否可读、可写或可作为一个程序执行，段的特权级等。在此基础上，处理器有两种寻址模式：实模式与保护模式。线性地址等于基地址+偏移量。<br> 一个逻辑地址由段标识符和段内偏移量组成。段标识符是一个16位长的字段（段选择符）。可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这个描述符就描述了一个段。全局的段描述符，放在“全局段描述符表(GDT)”中，一些局部的段描述符，放在“局部段描述符表(LDT)”中。<br> 给定一个完整的逻辑地址段选择符+段内偏移地址，看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，就得到了其基地址。Base + offset = 线性地址。</p> 
<h2>
<a id="73_Hello_258"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h2> 
<p>页式管理是一种内存空间存储管理的技术，页式管理分为静态页式管理和动态页式管理。将各进程的虚拟空间划分成若干个长度相等的页(page)，页式管理把内存空间按页的大小划分成片或者页面（page frame），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。</p> 
<h2>
<a id="74_TLBVAPA_260"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h2> 
<p>MMU中包括了一个关于PTE的小的缓存，称为翻译后备缓存器（TLB）。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单一PTE组成的块。TLB通常有高的相联度，从虚拟地址中的页号提取出组选择和行匹配的索引和标记字段。TLB结构如下：<br> 翻译时，首先将虚拟地址的VPN划分为TLBT（TLB标记）和TLBI（TLB索引）。利用TLBI，访问TLB中的某一组。遍历该组中的所有行，若找到一行的标志等于TLBT，且有效位为有效,，则缓存命中，该行存储的即为PPN；若未找到一行的标签等于TLBT，或找到但该行无效，则缓存不命中。进而需要到页表中找到被请求的块，用以替换原TLB表项中的数据。<br> 在此基础之上，计算机还采取了多级页表的形式。它主要处理TLB不命中的情况，用来翻译虚拟地址。此时VPN被解释为4各=个段，从高地址开始，第一段VPN部分作为第一级页表的索引，用以确定第二级页表的基地址，以此类推直到在第四级页表里取到所需要的PPN，在整个过程中，一旦有一级的页表有效位为0，则下一级页表就不存在，产生缺页故障。</p> 
<h2>
<a id="75_Cache_264"></a>7.5 三级Cache支持下的物理内存访问</h2> 
<p>64位下，物理地址有52位，0到5位时CO偏移量，6到11位是CI组索引，12到51位是CT标记。<br> CPU发送一条虚拟地址，随后MMU按照7.4所述的操作获得了物理地址PA。根据cache大小组数的要求，将PA分为CT（标记位）CI(组索引)，CO（块偏移）。根据CI寻找到正确的组，依次与每一行的数据比较，有效位有效且标记位一致则命中。如果命中，直接返回想要的数据。如果不命中，就依次去L2,L3,主存判断是否命中，命中时将数据传给CPU同时更新各级cache的储存。</p> 
<h2>
<a id="76_hellofork_267"></a>7.6 hello进程fork时的内存映射</h2> 
<p>当fork 函数被shell 进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</p> 
<h2>
<a id="77_helloexecve_269"></a>7.7 hello进程execve时的内存映射</h2> 
<p>execve 函数在shell中加载并运行包含在可执行目标文件hello中的程序。需要以下几个步骤：</p> 
<ol>
<li>删除已存在的用户区域。删除shell虚拟地址的用户部分中的已存在的区域结构。</li>
<li>为hello的代码、数据、bss 和栈区域创建新的区域结构映射私有区域。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello 文件中的.text和.data 区。bss 区域是请求二进制零的，映射到匿名文件，其大小包含在hello 中。栈和堆区域也是请求二进制零的，初始长度为零。</li>
<li>映射共享区域。如果hello程序与共享对象（或目标）链接，比如标准C 库libc. so, 那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li>
<li>设置程序计数器(PC) 。execve 做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。</li>
</ol> 
<h2>
<a id="78__275"></a>7.8 缺页故障与缺页中断处理</h2> 
<p>虚拟内存中，DRAM缓存不命中称为缺页。缺页后，执行如下处理步骤：</p> 
<ol>
<li>处理器生成一个虚拟地址，并将它传送给MMU</li>
<li>MMU生成PTE地址，并从高速缓存/主存请求得到它</li>
<li>高速缓存/主存向MMU返回PTE</li>
<li>PTE中的有效位是0，所以MMU出发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li>
<li>缺页处理程序确认出物理内存中的牺牲页，如果这个页已经被修改了，则把它换到磁盘。</li>
<li>缺页处理程序页面调入新的页面，并更新内存中的PTE</li>
<li>缺页处理程序返回到原来的进程，再次执行导致缺页的命令。</li>
</ol> 
<h2>
<a id="79_284"></a>7.9动态存储分配管理</h2> 
<p>动态储存分配管理使用动态内存分配器(如malloc)来进行。动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合。每个块就是一个连续的虚拟内存页，状态为已分配或空闲。<br> 动态内存分配主要有两种基本方法与策略，分配器的类型：<br> 1.显式分配器: 要求应用显式地释放任何已分配的快<br> 将堆的空闲块组织成一个双向链表，在每个空闲块中，都包含一个前驱与一个后继指针。进行内存管理。在显式空闲链表中。可以采用后进先出的顺序维护链表，将最新释放的块放置在链表的开始处，也可以采用按照地址顺序来维护链表，其中链表中每个块的地址都小于它的后继地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱<br> 2.隐式分配器: 应用检测到已分配块不再被程序所使用，就释放这个块<br> 空闲块通过头部的大小字段隐含地连接着。分配器遍历堆中所有的块，间接地遍历整个空闲块的集合。</p> 
<h2>
<a id="710_291"></a>7.10本章小结</h2> 
<p>本章我们讨论了intel的段式管理、页式管理，以i7为例介绍了VA到PA的变换、物理内存访问，还介绍了hello进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。</p> 
<h1>
<a id="8_helloIO_294"></a>第8章 hello的IO管理</h1> 
<h2>
<a id="81_LinuxIO_295"></a>8.1 Linux的IO设备管理方法</h2> 
<p>Linux将文件所有的I/O设备都模型化为文件，甚至内核也被映射为文件。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O。Linux就是基于Unix I/O实现对设备的管理。</p> 
<h2>
<a id="82_Unix_IO_297"></a>8.2 简述Unix IO接口及其函数</h2> 
<ol>
<li>打开文件——open()：open函数将file那么转换为一个文件描述符并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。</li>
<li>关闭文件——close()：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。</li>
<li>读取文件——read()：read函数从描述符为fd 的当前文件位置复制最多n个字节到内存位置buf。返回值一1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。</li>
<li>写入文件——write()：write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。</li>
</ol> 
<h2>
<a id="83_printf_303"></a>8.3 printf的实现分析</h2> 
<p>https://www.cnblogs.com/pianist/p/3315801.html<br> 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用 int 0x80或syscall等.<br> 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。<br> 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。</p> 
<h2>
<a id="84_getchar_309"></a>8.4 getchar的实现分析</h2> 
<p>getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。用户输入的字符被存放在键盘缓冲区中直到用户按回车(回车也在缓冲区中)。<br> 如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取。也就是说，后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键。<br> **异步异常-键盘中断的处理：**当用户按键时触发键盘终端，操作系统将控制转移到键盘中断处理子程序，中断处理程序执行，接受按键扫描码转成ascii码，保存到系统的键盘缓冲区，显示在用户输入的终端内。当中断处理程序执行完毕后，返回到下一条指令运行。</p> 
<h2>
<a id="85_314"></a>8.5本章小结</h2> 
<p>本章介绍了 Linux 的 I/O 设备的基本概念和管理方法，以及Unix I/O 接口及其函数。最后分析了printf 函数和 getchar 函数的工作过程。</p> 
<h1>
<a id="_317"></a>结论</h1> 
<p>hello从Program到Process的P2P过程很快，但他经历了：</p> 
<ol>
<li>预处理，对预处理指令进行解释，生成hello.i文件；</li>
<li>编译，将C语言代码转换成汇编语言代码，生成hello.s；</li>
<li>汇编，把汇编语言转换成机器代码，生成hello.o；</li>
<li>链接，将hello.o与可重定位目标文件及动态库链接，生成可执行程序hello；</li>
<li>创建进程：通过shell运行hello,调用fork为hello创建子进程；</li>
<li>运行程序：通过execve和加载器，加载hello到虚拟内存；</li>
<li>执行指令：CPU为其分配时间片，在一个时间片中，hello享有CPU资源，顺序执行自己的控制逻辑流</li>
<li>访问内存：MMU将程序中使用的虚拟内存地址通过页表映射成物理地址。</li>
<li>异常信号：如果进程途中出现异常信号，则调用信号处理函数进行停止或挂起进程的操作。</li>
<li>Unix I/O：完成程序与文件之间的交互操作</li>
<li>进程结束：程序运行结束时，父进程回收子进程，CPU删除hello进程创建以来的数据。<br> 要成为合格的程序员或工程师，应该更加了解程序的底层实现，了解C语言如何从一个.c文件到可执行文件以及文件如何在计算机中运行和交互的。分析Hello程序从代码编辑器到运行进程的过程，对计算机系统编译源文件、运行进程等机制进行较深入的分析和介绍。加深我们对于计算机软硬件系统的初步认识。</li>
</ol>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>