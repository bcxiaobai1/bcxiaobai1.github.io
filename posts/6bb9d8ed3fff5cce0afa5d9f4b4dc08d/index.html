<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>qt6类QList的两种遍历风格（STL-style-iterators、java-style-iterators） - 编程小白</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程小白" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程小白</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">qt6类QList的两种遍历风格（STL-style-iterators、java-style-iterators）</h1>
			
		</header>
		<div class="content post__content clearfix">
			


        
                <div id="content_views" class="markdown_views prism-github-gist">
                    
                        
                    
                    <p></p> 
<div class="toc"> 
 <h3>文章目录</h3> 
 <ul>
<li><a href="#qt6QList_1">qt6类QList的两种遍历风格</a></li>
<li><a href="#STLStyle_Iterators_12">STL-Style Iterators</a></li>
<li><a href="#javastyleiterators_136">java-style-iterators</a></li>
<li>
<ul>
<li><a href="#QListIterator_178">QListIterator</a></li>
<li><a href="#QMutableListIterator_215">QMutableListIterator</a></li>
</ul> 
  </li>
<li><a href="#_310">参考资料</a></li>
</ul> 
</div> 
<p></p> 
<h1>
<a id="qt6QList_1"></a>qt6类QList的两种遍历风格</h1> 
<p>QList provides both STL-style iterators and Java-style iterators<br> QList同时提供STL风格的迭代器和Java风格的迭代器</p> 
<p>Warning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem<br> 警告：隐式共享容器上的迭代器的工作方式与STL迭代器不同。当迭代器在容器上处于活动状态时，应避免复制容器。有关更多信息，请阅读隐式共享迭代器问题</p> 
<p>Warning: Iterators are invalidated when QList is modified. Consider that all iterators are invalidated by default. Exceptions to this rule are explicitly documented<br> 警告：修改QList时，迭代器无效。假设默认情况下所有迭代器都是无效的。明确记录此规则的例外情况</p> 
<h1>
<a id="STLStyle_Iterators_12"></a>STL-Style Iterators</h1> 
<p>STL-style iterators have been available since the release of Qt 2.0. They are compatible with Qt’s and STL’s generic algorithms and are optimized for speed. For each container class, there are two STL-style iterator types: one that provides read-only access and one that provides read-write access. Read-only iterators should be used wherever possible because they are faster than read-write iterators</p> 
<p>STL风格的迭代器自Qt2.0发布以来就一直可用。它们与Qt和STL的通用算法兼容，并针对速度进行了优化。对于每个容器类，有两种STL样式的迭代器类型：<br> 一种提供只读访问，另一种提供读写访问。<br> 只读迭代器应该尽可能使用，因为它们比读写迭代器更快</p> 
<table>
<thead><tr>
<th align="center">Containers</th>
<th align="center">Read-only iterator</th>
<th align="center">Read-write iterator</th>
</tr></thead>
<tbody>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlist.html">QList</a>, <a href="https://doc.qt.io/qt-6/qstack.html">QStack</a>, <a href="https://doc.qt.io/qt-6/qqueue.html">QQueue</a>
</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlist.html">QList</a>::const_iterator</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlist.html">QList</a>::iterator</td>
</tr>
<tr>
<td align="center"><a href="https://doc.qt.io/qt-6/qset.html">QSet</a></td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qset.html">QSet</a>::const_iterator</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qset.html">QSet</a>::iterator</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qmap.html">QMap</a>&lt;Key, T&gt;, <a href="https://doc.qt.io/qt-6/qmultimap.html">QMultiMap</a>&lt;Key, T&gt;</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qmap.html">QMap</a>&lt;Key, T&gt;::const_iterator</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qmap.html">QMap</a>&lt;Key, T&gt;::iterator</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qhash.html#qhash">QHash</a>&lt;Key, T&gt;, <a href="https://doc.qt.io/qt-6/qmultihash.html">QMultiHash</a>&lt;Key, T&gt;</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qhash.html#qhash">QHash</a>&lt;Key, T&gt;::const_iterator</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qhash.html#qhash">QHash</a>&lt;Key, T&gt;::iterator</td>
</tr>
</tbody>
</table> 
<p>The API of the STL iterators is modelled on pointers in an array. For example, the ++ operator advances the iterator to the next item, and the operator returns the item that the iterator points to. In fact, for QList and QStack, which store their items at adjacent memory positions, the iterator type is just a typedef for T , and the const_iterator type is just a typedef for const T</p> 
<p>STL迭代器的API是以数组中的指针为模型的。例如，++运算符将迭代器前进到下一个项，并且运算符返回迭代器指向的项。事实上，对于将其项存储在相邻内存位置的QList和QStack，迭代器类型只是T的typedef，const_iterator类型只是const T的typedef</p> 
<p>In this discussion, we will concentrate on QList and QMap. The iterator types for QSet have exactly the same interface as QList’s iterators; similarly, the iterator types for QHash have the same interface as QMap’s iterators</p> 
<p>在本次讨论中，我们将集中讨论QList和QMap。QSet的迭代器类型与QList的迭代程序具有完全相同的接口；类似地，QHash的迭代器类型与QMap的迭代程序具有相同的接口</p> 
<p>Here’s a typical loop for iterating through all the elements of a QList&lt;QString&gt; in order and converting them to lowercase</p> 
<p>下面是一个典型的循环，用于按顺序遍历<code>QList&lt;QString&gt;</code>的所有元素，并将它们转换为小写</p> 
<pre><code class="prism language-cpp">QList<span class="token operator">&lt;</span>QString<span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token operator">*</span>i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLower</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>STL-style iterators point directly at items. The begin() function of a container returns an iterator that points to the first item in the container. The end() function of a container returns an iterator to the imaginary item one position past the last item in the container. end() marks an invalid position; it must never be dereferenced. It is typically used in a loop’s break condition. If the list is empty, begin() equals end(), so we never execute the loop.<br> STL风格的迭代器直接指向项目。容器的begin（）函数返回一个迭代器，该迭代器指向容器中的第一项。容器的end（）函数返回一个迭代器，返回到容器中最后一项之后一个位置的假想项。end（）标记无效位置；绝不能取消引用。它通常用于循环中断的情况。如果列表为空，begin（）等于end（），因此我们从不执行循环</p> 
<p>The diagram below shows the valid iterator positions as red arrows for a list containing four items<br> 下图显示了包含四项的列表的有效迭代器位置为红色箭头</p> 
<p><img src="https://images2.imgbox.com/9b/9d/9q9kmh9e_o.png" alt="在这里插入图片描述"><br> Iterating backward with an STL-style iterator is done with reverse iterators</p> 
<p>使用STL样式的迭代器反向迭代是使用反向迭代器完成的</p> 
<pre><code class="prism language-cpp">QList<span class="token operator">&lt;</span>QString<span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rend <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> rend<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token operator">*</span>i <span class="token operator">=</span> i<span class="token operator">-&gt;</span><span class="token function">toLower</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>In the code snippets so far, we used <code>the unary * operator</code> to retrieve the item (of type QString) stored at a certain iterator position, and we then called QString::toLower() on it.<br> For read-only access, you can use const_iterator, cbegin(), and cend(). For example</p> 
<p>在迄今为止的代码片段中，我们使用<code>一元运算符*</code>来检索存储在某个迭代器位置的项（类型为QString），然后对其调用QString:：toLower（）。<br> 对于只读访问，可以使用const_iterator、cbegin（）和cend（）。例如</p> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>i<span class="token punctuation">;</span>
</code></pre> 
<p>The following table summarizes the STL-style iterators’ API</p> 
<p>下表总结了STL风格迭代器的API</p> 
<table>
<thead><tr>
<th align="center">Expression</th>
<th align="center">Behavior</th>
</tr></thead>
<tbody>
<tr>
<td align="center"><code>*i</code></td>
<td align="center">Returns the current item</td>
</tr>
<tr>
<td align="center"><code>++i</code></td>
<td align="center">Advances the iterator to the next item</td>
</tr>
<tr>
<td align="center"><code>i += n</code></td>
<td align="center">Advances the iterator by <code>n</code> items</td>
</tr>
<tr>
<td align="center"><code>--i</code></td>
<td align="center">Moves the iterator back by one item</td>
</tr>
<tr>
<td align="center"><code>i -= n</code></td>
<td align="center">Moves the iterator back by <code>n</code> items</td>
</tr>
<tr>
<td align="center"><code>i - j</code></td>
<td align="center">Returns the number of items between iterators <code>i</code> and <code>j</code>
</td>
</tr>
</tbody>
</table> 
<p>The ++ and - - operators are available both as prefix (++i, - -i) and postfix (i++, i- -) operators.<br> The prefix versions modify the iterators and return a reference to the modified iterator;<br> the postfix versions take a copy of the iterator before they modify it, and return that copy.<br> In expressions where the return value is ignored, we recommend that you use the prefix operators (++i, --i), as these are slightly faster</p> 
<p>++和— —运算符可以作为前缀（++i，- -i）和后缀（i++，i- -）运算符使用。<br> 前缀版本修改迭代器并返回对修改后的迭代器的引用；<br> 后缀版本在修改迭代器之前获取迭代器的副本，并返回该副本。<br> 在忽略返回值的表达式中，我们建议您使用前缀运算符（++i，— —i），因为这些运算符会稍微快一些</p> 
<p>For non-const iterator types, the return value of <code>the unary * operator</code> can be used on the left side of the assignment operator.</p> 
<p>对于非常量迭代器类型，<code>一元*运算符</code>的返回值可以在赋值运算符的左侧使用。</p> 
<p>For QMap and QHash, the operator returns the value component of an item. If you want to retrieve the key, call key() on the iterator. For symmetry, the iterator types also provide a value() function to retrieve the value. For example, here’s how we would print all items in a QMap to the console</p> 
<p>对于QMap和QHash，运算符返回项的值组件。如果要检索键，请在迭代器上调用key（）。对于对称性，迭代器类型还提供了一个value（）函数来检索值。例如，下面是我们如何将QMap中的所有项目打印到控制台</p> 
<pre><code class="prism language-cpp">QMap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> map<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">':'</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>Thanks to implicit sharing, it is very inexpensive for a function to return a container per value. The Qt API contains dozens of functions that return a QList or QStringList per value (e.g., QSplitter::sizes()). If you want to iterate over these using an STL iterator, you should always take a copy of the container and iterate over the copy. For example</p> 
<p>Thanks to implicit sharing, it is very inexpensive for a function to return a container per value. The Qt API contains dozens of functions that return a QList or QStringList per value (e.g., QSplitter::sizes()). If you want to iterate over these using an STL iterator, you should always take a copy of the container and iterate over the copy. For example</p> 
<p>由于隐式共享，函数返回每个值一个容器的成本非常低。Qt API包含数十个函数，每个值返回一个QList或QStringList（例如，QSplitter:：sizes（））。如果您想使用STL迭代器对其进行迭代，则应始终获取容器的副本并对副本进行迭代。例如</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 对</span>
<span class="token keyword">const</span> QList<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sizes <span class="token operator">=</span> splitter<span class="token operator">-&gt;</span><span class="token function">sizes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> sizes<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> sizes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token comment">// 错</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> splitter<span class="token operator">-&gt;</span><span class="token function">sizes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        i <span class="token operator">!=</span> splitter<span class="token operator">-&gt;</span><span class="token function">sizes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>This problem doesn’t occur with functions that return a const or non-const reference to a container</p> 
<p>返回对容器的常量或非常量引用的函数不会出现此问题</p> 
<h1>
<a id="javastyleiterators_136"></a>java-style-iterators</h1> 
<p>For each container class, there are two Java-style iterator data types: one that provides read-only access and one that provides read-write access</p> 
<p>对于每个容器类，都有两种Java风格的迭代器数据类型：一种提供只读访问，另一种提供读写访问</p> 
<p>Note: New code should use STL-Style iterators since these are more efficient and can be used together with Qt’s and STL’s generic algorithms</p> 
<p>注意：新代码应该使用STL样式迭代器，因为这些迭代器更高效，并且可以与Qt和STL的通用算法一起使用</p> 
<table>
<thead><tr>
<th align="center">Containers</th>
<th align="center">Read-only iterator</th>
<th align="center">Read-write iterator</th>
</tr></thead>
<tbody>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlist.html">QList</a>, <a href="https://doc.qt.io/qt-6/qqueue.html">QQueue</a>, <a href="https://doc.qt.io/qt-6/qstack.html">QStack</a>,</td>
<td align="center"><a href="https://doc.qt.io/qt-6/qlistiterator.html">QListIterator</a></td>
<td align="center"><a href="https://doc.qt.io/qt-6/qmutablelistiterator.html">QMutableListIterator</a></td>
</tr>
<tr>
<td align="center"><a href="https://doc.qt.io/qt-6/qset.html">QSet</a></td>
<td align="center"><a href="https://doc.qt.io/qt-6/qsetiterator.html">QSetIterator</a></td>
<td align="center"><a href="https://doc.qt.io/qt-6/qmutablesetiterator.html">QMutableSetIterator</a></td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qmap.html">QMap</a>&lt;Key, T&gt;, <a href="https://doc.qt.io/qt-6/qmultimap.html">QMultiMap</a>&lt;Key, T&gt;</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qmapiterator.html">QMapIterator</a>&lt;Key, T&gt;</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qmutablemapiterator.html">QMutableMapIterator</a>&lt;Key, T&gt;</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qhash.html#qhash">QHash</a>&lt;Key, T&gt;, <a href="https://doc.qt.io/qt-6/qmultihash.html">QMultiHash</a>&lt;Key, T&gt;</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qhashiterator.html">QHashIterator</a>&lt;Key, T&gt;</td>
<td align="center">
<a href="https://doc.qt.io/qt-6/qmutablehashiterator.html">QMutableHashIterator</a>&lt;Key, T&gt;</td>
</tr>
</tbody>
</table> 
<p>In this discussion, we will concentrate on QList and QMap. The iterator types for QSet have exactly the same interface as QList’s iterators; similarly, the iterator types for QHash have the same interface as QMap’s iterators</p> 
<p>在这次讨论中，我们将集中讨论QList和QMap。QSet的迭代器类型与QList的迭代器具有完全相同的接口；类似地，QHash的迭代器类型与QMap的迭代器具有相同的接口</p> 
<p>Unlike STL-Style iterators, Java-style iterators point between items rather than directly at items. For this reason, they are either pointing to the very beginning of the container (before the first item), at the very end of the container (after the last item), or between two items. The diagram below shows the valid iterator positions as red arrows for a list containing four items</p> 
<p>与STL风格的迭代器不同，Java风格的迭代器指向项之间，而不是直接指向项。因此，它们要么指向容器的最开始（在第一个项目之前），要么指向容器的最末端（在最后一个项目之后），要么指向两个项目之间。下图显示了包含四项的列表的有效迭代器位置为红色箭头</p> 
<p><img src="https://images2.imgbox.com/5c/0a/KU7TUNMc_o.png" alt="在这里插入图片描述"><br> Here’s a typical loop for iterating through all the elements of a QList in order</p> 
<p>下面是一个典型的循环，用于按顺序迭代QList＜QString＞的所有元素</p> 
<pre><code class="prism language-cpp">QList<span class="token operator">&lt;</span>QString<span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

QListIterator<span class="token operator">&lt;</span>QString<span class="token operator">&gt;</span> <span class="token function">i</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    QString s <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>It works as follows: The QList to iterate over is passed to the QListIterator constructor. At that point, the iterator is located just in front of the first item in the list (before item “A”). Then we call hasNext() to check whether there is an item after the iterator. If there is, we call next() to jump over that item. The next() function returns the item that it jumps over. For a QList&lt;QString&gt;, that item is of type QString</p> 
<p>它的工作原理如下：要迭代的QList被传递给QListIterator构造函数。此时，迭代器正好位于列表中第一项的前面（在项“a”之前）。然后我们调用hasNext（）来检查迭代器后面是否有项。如果有，我们调用next（）跳过该项。next（）函数返回它跳过的项。对于<code>QList&lt;QString&gt;</code>，该项的类型为QString</p> 
<h2>
<a id="QListIterator_178"></a>QListIterator</h2> 
<p>Here’s how to iterate backward in a QList</p> 
<p>下面是如何在QList中向后迭代</p> 
<pre><code class="prism language-cpp">QListIterator<span class="token operator">&lt;</span>QString<span class="token operator">&gt;</span> <span class="token function">i</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
i<span class="token punctuation">.</span><span class="token function">toBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    QString s <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>The code is symmetric with iterating forward, except that we start by calling toBack() to move the iterator after the last item in the list</p> 
<p>代码与向前迭代是对称的，只是我们首先调用toBack（）将迭代器移动到列表中的最后一项之后<br> The diagram below illustrates the effect of calling next() and previous() on an iterator</p> 
<p>下图说明了在迭代器上调用next（）和previous（）的效果</p> 
<p><img src="https://images2.imgbox.com/1c/cf/Y8yyj1j5_o.png" alt="在这里插入图片描述"><br> The following table summarizes the QListIterator API</p> 
<p>下表总结了QListIterator API</p> 
<table>
<thead><tr>
<th align="center">Function</th>
<th align="center">Behavior</th>
</tr></thead>
<tbody>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlistiterator.html#toFront">toFront</a>()</td>
<td align="center">Moves the iterator to the front of the list (before the first item)</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlistiterator.html#toBack">toBack</a>()</td>
<td align="center">Moves the iterator to the back of the list (after the last item)</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlistiterator.html#hasNext">hasNext</a>()</td>
<td align="center">Returns <code>true</code> if the iterator isn’t at the back of the list</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlistiterator.html#next">next</a>()</td>
<td align="center">Returns the next item and advances the iterator by one position</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlistiterator.html#peekNext">peekNext</a>()</td>
<td align="center">Returns the next item without moving the iterator</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlistiterator.html#hasPrevious">hasPrevious</a>()</td>
<td align="center">Returns <code>true</code> if the iterator isn’t at the front of the list</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlistiterator.html#previous">previous</a>()</td>
<td align="center">Returns the previous item and moves the iterator back by one position</td>
</tr>
<tr>
<td align="center">
<a href="https://doc.qt.io/qt-6/qlistiterator.html#peekPrevious">peekPrevious</a>()</td>
<td align="center">Returns the previous item without moving the iterator</td>
</tr>
</tbody>
</table> 
<p>表格翻译如下<br> <img src="https://images2.imgbox.com/63/67/A1MAHNbj_o.png" alt="在这里插入图片描述"></p> 
<h2>
<a id="QMutableListIterator_215"></a>QMutableListIterator</h2> 
<p>QListIterator provides no functions to insert or remove items from the list as we iterate. To accomplish this, you must use QMutableListIterator. Here’s an example where we remove all odd numbers from a QList using QMutableListIterator</p> 
<p>当我们迭代时，QListIterator没有提供从列表中插入或删除项目的函数。为此，必须使用QMutableListIterator。下面是一个使用QMutableListIterator从QList&lt;int&gt;中删除所有奇数的示例</p> 
<pre><code class="prism language-cpp">QMutableListIterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">i</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        i<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>The next() call in the loop is made every time. It jumps over the next item in the list. The remove() function removes the last item that we jumped over from the list. The call to remove() does not invalidate the iterator, so it is safe to continue using it. This works just as well when iterating backward</p> 
<p>循环中的next（）调用每次都会进行。它跳过列表中的下一项。函数的作用是删除我们从列表中跳过的最后一项。对remove（）的调用不会使迭代器失效，因此继续使用它是安全的。这在向后迭代时也同样有效</p> 
<pre><code class="prism language-cpp">QMutableListIterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">i</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
i<span class="token punctuation">.</span><span class="token function">toBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        i<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>If we just want to modify the value of an existing item, we can use setValue(). In the code below, we replace any value larger than 128 with 128</p> 
<p>如果我们只想修改现有项的值，我们可以使用setValue（）。在下面的代码中，我们将任何大于128的值替换为128</p> 
<pre><code class="prism language-cpp">QMutableListIterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">i</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">128</span><span class="token punctuation">)</span>
        i<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Just like remove(), setValue() operates on the last item that we jumped over. If we iterate forward, this is the item just before the iterator; if we iterate backward, this is the item just after the iterator</p> 
<p>就像remove（）一样，setValue（）对我们跳过的最后一个项目进行操作。如果我们向前迭代，这就是迭代器前面的项；如果我们向后迭代，这就是迭代器后面的项</p> 
<p>The next() function returns a non-const reference to the item in the list. For simple operations, we don’t even need setValue</p> 
<p>next（）函数返回对列表中项的<code>non-const引用</code>。对于简单的操作，我们甚至不需要setValue</p> 
<pre><code class="prism language-cpp">QMutableListIterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">i</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> 
<p>As mentioned above QSet’s iterator classes have exactly the same API as QList’s. We will now turn to QMapIterator, which is somewhat different because it iterates on (key, value) pairs.<br> 如上所述，QSet的迭代器类与QList的具有完全相同的API。我们现在将转向QMapIterator，它有些不同，因为它迭代（键、值）对</p> 
<p>Like QListIterator, QMapIterator provides toFront(), toBack(), hasNext(), next(), peekNext(), hasPrevious(), previous(), and peekPrevious(). The key and value components are extracted by calling key() and value() on the object returned by next(), peekNext(), previous(), or peekPrevious().</p> 
<p>与QListIterator一样，QMapIterator提供了toFront（）、toBack（）、hasNext（）、next（）、peekNext（）、hasPrevious（）、previous（）和peekPrevious（）。通过对next（）、peekNext（）、previous（）或peekPrevious返回的对象调用key（）和value（）来提取键和值组件</p> 
<p>The following example removes all (capital, country) pairs where the capital’s name ends with “City”:<br> 以下示例删除首都名称以“City”结尾的所有（capital，country）对</p> 
<pre><code class="prism language-cpp">QMap<span class="token operator">&lt;</span>QString<span class="token punctuation">,</span> QString<span class="token operator">&gt;</span> map <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">{<!-- --></span><span class="token string">"Paris"</span><span class="token punctuation">,</span> <span class="token string">"France"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{<!-- --></span><span class="token string">"Guatemala City"</span><span class="token punctuation">,</span> <span class="token string">"Guatemala"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{<!-- --></span><span class="token string">"Mexico City"</span><span class="token punctuation">,</span> <span class="token string">"Mexico"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{<!-- --></span><span class="token string">"Moscow"</span><span class="token punctuation">,</span> <span class="token string">"Russia"</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

QMutableMapIterator<span class="token operator">&lt;</span>QString<span class="token punctuation">,</span> QString<span class="token operator">&gt;</span> <span class="token function">i</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"City"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        i<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>QMapIterator also provides a key() and a value() function that operate directly on the iterator and that return the key and value of the last item that the iterator jumped above. For example, the following code copies the contents of a QMap into a QHash:</p> 
<pre><code class="prism language-cpp">QMap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> QWidget <span class="token operator">*</span><span class="token operator">&gt;</span> map<span class="token punctuation">;</span>
QHash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> QWidget <span class="token operator">*</span><span class="token operator">&gt;</span> hash<span class="token punctuation">;</span>

QMapIterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> QWidget <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">i</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hash<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>If we want to iterate through all the items with the same value, we can use findNext() or findPrevious(). Here’s an example where we remove all the items with a particular value:</p> 
<pre><code class="prism language-cpp">QMutableMapIterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> QWidget <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">i</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">findNext</span><span class="token punctuation">(</span>widget<span class="token punctuation">)</span><span class="token punctuation">)</span>
    i<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h1>
<a id="_310"></a>参考资料</h1> 
<p><a href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">stl-style-iterators</a><br> <a href="https://doc.qt.io/qt-6/java-style-iterators.html#java-style-iterators">java-style-iterators</a></p>
                </div>
                
                

		</div>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程小白.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://www.w3counter.com/tracker.js?id=150625"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>